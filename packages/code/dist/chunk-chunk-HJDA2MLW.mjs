import {
  wait
} from "./chunk-chunk-NBK6NTLB.mjs";
import {
  require_localforage
} from "./chunk-chunk-AULC7L4Y.mjs";
import {
  emotionCache_default
} from "./chunk-chunk-TIL35SAU.mjs";
import {
  require_emotion_react_jsx_runtime_cjs
} from "./chunk-chunk-NFYMKIWC.mjs";
import {
  require_clsx,
  require_prop_types
} from "./chunk-chunk-ZZWIKWD4.mjs";
import {
  require_emotion_react_cjs
} from "./chunk-chunk-RNJNNLQS.mjs";
import {
  applyPatch,
  hashCode,
  mST,
  makePatch,
  md5,
  onSessionUpdate,
  startSession
} from "./chunk-chunk-55HOXNFZ.mjs";
import {
  require_client
} from "./chunk-chunk-FFMS35Y7.mjs";
import {
  require_react_dom
} from "./chunk-chunk-M3XF32XQ.mjs";
import {
  require_react
} from "./chunk-chunk-UX3KX3KY.mjs";
import {
  __commonJS,
  __export,
  __name,
  __toESM,
  init_define_process
} from "./chunk-chunk-A3E5PINE.mjs";

// ../../.yarn/global/cache/sdp-npm-3.0.3-3ac42de16d-9.zip/node_modules/sdp/sdp.js
var require_sdp = __commonJS({
  "../../.yarn/global/cache/sdp-npm-3.0.3-3ac42de16d-9.zip/node_modules/sdp/sdp.js"(exports, module) {
    "use strict";
    init_define_process();
    var SDPUtils2 = {};
    SDPUtils2.generateIdentifier = function() {
      return Math.random().toString(36).substr(2, 10);
    };
    SDPUtils2.localCName = SDPUtils2.generateIdentifier();
    SDPUtils2.splitLines = function(blob) {
      return blob.trim().split("\n").map((line) => line.trim());
    };
    SDPUtils2.splitSections = function(blob) {
      const parts = blob.split("\nm=");
      return parts.map((part, index) => (index > 0 ? "m=" + part : part).trim() + "\r\n");
    };
    SDPUtils2.getDescription = function(blob) {
      const sections = SDPUtils2.splitSections(blob);
      return sections && sections[0];
    };
    SDPUtils2.getMediaSections = function(blob) {
      const sections = SDPUtils2.splitSections(blob);
      sections.shift();
      return sections;
    };
    SDPUtils2.matchPrefix = function(blob, prefix) {
      return SDPUtils2.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);
    };
    SDPUtils2.parseCandidate = function(line) {
      let parts;
      if (line.indexOf("a=candidate:") === 0) {
        parts = line.substring(12).split(" ");
      } else {
        parts = line.substring(10).split(" ");
      }
      const candidate = {
        foundation: parts[0],
        component: { 1: "rtp", 2: "rtcp" }[parts[1]] || parts[1],
        protocol: parts[2].toLowerCase(),
        priority: parseInt(parts[3], 10),
        ip: parts[4],
        address: parts[4],
        port: parseInt(parts[5], 10),
        type: parts[7]
      };
      for (let i2 = 8; i2 < parts.length; i2 += 2) {
        switch (parts[i2]) {
          case "raddr":
            candidate.relatedAddress = parts[i2 + 1];
            break;
          case "rport":
            candidate.relatedPort = parseInt(parts[i2 + 1], 10);
            break;
          case "tcptype":
            candidate.tcpType = parts[i2 + 1];
            break;
          case "ufrag":
            candidate.ufrag = parts[i2 + 1];
            candidate.usernameFragment = parts[i2 + 1];
            break;
          default:
            if (candidate[parts[i2]] === void 0) {
              candidate[parts[i2]] = parts[i2 + 1];
            }
            break;
        }
      }
      return candidate;
    };
    SDPUtils2.writeCandidate = function(candidate) {
      const sdp2 = [];
      sdp2.push(candidate.foundation);
      const component = candidate.component;
      if (component === "rtp") {
        sdp2.push(1);
      } else if (component === "rtcp") {
        sdp2.push(2);
      } else {
        sdp2.push(component);
      }
      sdp2.push(candidate.protocol.toUpperCase());
      sdp2.push(candidate.priority);
      sdp2.push(candidate.address || candidate.ip);
      sdp2.push(candidate.port);
      const type = candidate.type;
      sdp2.push("typ");
      sdp2.push(type);
      if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {
        sdp2.push("raddr");
        sdp2.push(candidate.relatedAddress);
        sdp2.push("rport");
        sdp2.push(candidate.relatedPort);
      }
      if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
        sdp2.push("tcptype");
        sdp2.push(candidate.tcpType);
      }
      if (candidate.usernameFragment || candidate.ufrag) {
        sdp2.push("ufrag");
        sdp2.push(candidate.usernameFragment || candidate.ufrag);
      }
      return "candidate:" + sdp2.join(" ");
    };
    SDPUtils2.parseIceOptions = function(line) {
      return line.substr(14).split(" ");
    };
    SDPUtils2.parseRtpMap = function(line) {
      let parts = line.substr(9).split(" ");
      const parsed = {
        payloadType: parseInt(parts.shift(), 10)
      };
      parts = parts[0].split("/");
      parsed.name = parts[0];
      parsed.clockRate = parseInt(parts[1], 10);
      parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
      parsed.numChannels = parsed.channels;
      return parsed;
    };
    SDPUtils2.writeRtpMap = function(codec) {
      let pt = codec.payloadType;
      if (codec.preferredPayloadType !== void 0) {
        pt = codec.preferredPayloadType;
      }
      const channels = codec.channels || codec.numChannels || 1;
      return "a=rtpmap:" + pt + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
    };
    SDPUtils2.parseExtmap = function(line) {
      const parts = line.substr(9).split(" ");
      return {
        id: parseInt(parts[0], 10),
        direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
        uri: parts[1]
      };
    };
    SDPUtils2.writeExtmap = function(headerExtension) {
      return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + "\r\n";
    };
    SDPUtils2.parseFmtp = function(line) {
      const parsed = {};
      let kv;
      const parts = line.substr(line.indexOf(" ") + 1).split(";");
      for (let j2 = 0; j2 < parts.length; j2++) {
        kv = parts[j2].trim().split("=");
        parsed[kv[0].trim()] = kv[1];
      }
      return parsed;
    };
    SDPUtils2.writeFmtp = function(codec) {
      let line = "";
      let pt = codec.payloadType;
      if (codec.preferredPayloadType !== void 0) {
        pt = codec.preferredPayloadType;
      }
      if (codec.parameters && Object.keys(codec.parameters).length) {
        const params = [];
        Object.keys(codec.parameters).forEach((param) => {
          if (codec.parameters[param] !== void 0) {
            params.push(param + "=" + codec.parameters[param]);
          } else {
            params.push(param);
          }
        });
        line += "a=fmtp:" + pt + " " + params.join(";") + "\r\n";
      }
      return line;
    };
    SDPUtils2.parseRtcpFb = function(line) {
      const parts = line.substr(line.indexOf(" ") + 1).split(" ");
      return {
        type: parts.shift(),
        parameter: parts.join(" ")
      };
    };
    SDPUtils2.writeRtcpFb = function(codec) {
      let lines = "";
      let pt = codec.payloadType;
      if (codec.preferredPayloadType !== void 0) {
        pt = codec.preferredPayloadType;
      }
      if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
        codec.rtcpFeedback.forEach((fb) => {
          lines += "a=rtcp-fb:" + pt + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\r\n";
        });
      }
      return lines;
    };
    SDPUtils2.parseSsrcMedia = function(line) {
      const sp = line.indexOf(" ");
      const parts = {
        ssrc: parseInt(line.substr(7, sp - 7), 10)
      };
      const colon = line.indexOf(":", sp);
      if (colon > -1) {
        parts.attribute = line.substr(sp + 1, colon - sp - 1);
        parts.value = line.substr(colon + 1);
      } else {
        parts.attribute = line.substr(sp + 1);
      }
      return parts;
    };
    SDPUtils2.parseSsrcGroup = function(line) {
      const parts = line.substr(13).split(" ");
      return {
        semantics: parts.shift(),
        ssrcs: parts.map((ssrc) => parseInt(ssrc, 10))
      };
    };
    SDPUtils2.getMid = function(mediaSection) {
      const mid = SDPUtils2.matchPrefix(mediaSection, "a=mid:")[0];
      if (mid) {
        return mid.substr(6);
      }
    };
    SDPUtils2.parseFingerprint = function(line) {
      const parts = line.substr(14).split(" ");
      return {
        algorithm: parts[0].toLowerCase(),
        value: parts[1].toUpperCase()
      };
    };
    SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {
      const lines = SDPUtils2.matchPrefix(
        mediaSection + sessionpart,
        "a=fingerprint:"
      );
      return {
        role: "auto",
        fingerprints: lines.map(SDPUtils2.parseFingerprint)
      };
    };
    SDPUtils2.writeDtlsParameters = function(params, setupType) {
      let sdp2 = "a=setup:" + setupType + "\r\n";
      params.fingerprints.forEach((fp) => {
        sdp2 += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
      });
      return sdp2;
    };
    SDPUtils2.parseCryptoLine = function(line) {
      const parts = line.substr(9).split(" ");
      return {
        tag: parseInt(parts[0], 10),
        cryptoSuite: parts[1],
        keyParams: parts[2],
        sessionParams: parts.slice(3)
      };
    };
    SDPUtils2.writeCryptoLine = function(parameters) {
      return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
    };
    SDPUtils2.parseCryptoKeyParams = function(keyParams) {
      if (keyParams.indexOf("inline:") !== 0) {
        return null;
      }
      const parts = keyParams.substr(7).split("|");
      return {
        keyMethod: "inline",
        keySalt: parts[0],
        lifeTime: parts[1],
        mkiValue: parts[2] ? parts[2].split(":")[0] : void 0,
        mkiLength: parts[2] ? parts[2].split(":")[1] : void 0
      };
    };
    SDPUtils2.writeCryptoKeyParams = function(keyParams) {
      return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
    };
    SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {
      const lines = SDPUtils2.matchPrefix(
        mediaSection + sessionpart,
        "a=crypto:"
      );
      return lines.map(SDPUtils2.parseCryptoLine);
    };
    SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {
      const ufrag = SDPUtils2.matchPrefix(
        mediaSection + sessionpart,
        "a=ice-ufrag:"
      )[0];
      const pwd = SDPUtils2.matchPrefix(
        mediaSection + sessionpart,
        "a=ice-pwd:"
      )[0];
      if (!(ufrag && pwd)) {
        return null;
      }
      return {
        usernameFragment: ufrag.substr(12),
        password: pwd.substr(10)
      };
    };
    SDPUtils2.writeIceParameters = function(params) {
      let sdp2 = "a=ice-ufrag:" + params.usernameFragment + "\r\na=ice-pwd:" + params.password + "\r\n";
      if (params.iceLite) {
        sdp2 += "a=ice-lite\r\n";
      }
      return sdp2;
    };
    SDPUtils2.parseRtpParameters = function(mediaSection) {
      const description = {
        codecs: [],
        headerExtensions: [],
        fecMechanisms: [],
        rtcp: []
      };
      const lines = SDPUtils2.splitLines(mediaSection);
      const mline = lines[0].split(" ");
      for (let i2 = 3; i2 < mline.length; i2++) {
        const pt = mline[i2];
        const rtpmapline = SDPUtils2.matchPrefix(
          mediaSection,
          "a=rtpmap:" + pt + " "
        )[0];
        if (rtpmapline) {
          const codec = SDPUtils2.parseRtpMap(rtpmapline);
          const fmtps = SDPUtils2.matchPrefix(
            mediaSection,
            "a=fmtp:" + pt + " "
          );
          codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};
          codec.rtcpFeedback = SDPUtils2.matchPrefix(
            mediaSection,
            "a=rtcp-fb:" + pt + " "
          ).map(SDPUtils2.parseRtcpFb);
          description.codecs.push(codec);
          switch (codec.name.toUpperCase()) {
            case "RED":
            case "ULPFEC":
              description.fecMechanisms.push(codec.name.toUpperCase());
              break;
            default:
              break;
          }
        }
      }
      SDPUtils2.matchPrefix(mediaSection, "a=extmap:").forEach((line) => {
        description.headerExtensions.push(SDPUtils2.parseExtmap(line));
      });
      return description;
    };
    SDPUtils2.writeRtpDescription = function(kind, caps) {
      let sdp2 = "";
      sdp2 += "m=" + kind + " ";
      sdp2 += caps.codecs.length > 0 ? "9" : "0";
      sdp2 += " UDP/TLS/RTP/SAVPF ";
      sdp2 += caps.codecs.map((codec) => {
        if (codec.preferredPayloadType !== void 0) {
          return codec.preferredPayloadType;
        }
        return codec.payloadType;
      }).join(" ") + "\r\n";
      sdp2 += "c=IN IP4 0.0.0.0\r\n";
      sdp2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
      caps.codecs.forEach((codec) => {
        sdp2 += SDPUtils2.writeRtpMap(codec);
        sdp2 += SDPUtils2.writeFmtp(codec);
        sdp2 += SDPUtils2.writeRtcpFb(codec);
      });
      let maxptime = 0;
      caps.codecs.forEach((codec) => {
        if (codec.maxptime > maxptime) {
          maxptime = codec.maxptime;
        }
      });
      if (maxptime > 0) {
        sdp2 += "a=maxptime:" + maxptime + "\r\n";
      }
      if (caps.headerExtensions) {
        caps.headerExtensions.forEach((extension) => {
          sdp2 += SDPUtils2.writeExtmap(extension);
        });
      }
      return sdp2;
    };
    SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {
      const encodingParameters = [];
      const description = SDPUtils2.parseRtpParameters(mediaSection);
      const hasRed = description.fecMechanisms.indexOf("RED") !== -1;
      const hasUlpfec = description.fecMechanisms.indexOf("ULPFEC") !== -1;
      const ssrcs = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((parts) => parts.attribute === "cname");
      const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
      let secondarySsrc;
      const flows = SDPUtils2.matchPrefix(mediaSection, "a=ssrc-group:FID").map((line) => {
        const parts = line.substr(17).split(" ");
        return parts.map((part) => parseInt(part, 10));
      });
      if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
        secondarySsrc = flows[0][1];
      }
      description.codecs.forEach((codec) => {
        if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
          let encParam = {
            ssrc: primarySsrc,
            codecPayloadType: parseInt(codec.parameters.apt, 10)
          };
          if (primarySsrc && secondarySsrc) {
            encParam.rtx = { ssrc: secondarySsrc };
          }
          encodingParameters.push(encParam);
          if (hasRed) {
            encParam = JSON.parse(JSON.stringify(encParam));
            encParam.fec = {
              ssrc: primarySsrc,
              mechanism: hasUlpfec ? "red+ulpfec" : "red"
            };
            encodingParameters.push(encParam);
          }
        }
      });
      if (encodingParameters.length === 0 && primarySsrc) {
        encodingParameters.push({
          ssrc: primarySsrc
        });
      }
      let bandwidth = SDPUtils2.matchPrefix(mediaSection, "b=");
      if (bandwidth.length) {
        if (bandwidth[0].indexOf("b=TIAS:") === 0) {
          bandwidth = parseInt(bandwidth[0].substr(7), 10);
        } else if (bandwidth[0].indexOf("b=AS:") === 0) {
          bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;
        } else {
          bandwidth = void 0;
        }
        encodingParameters.forEach((params) => {
          params.maxBitrate = bandwidth;
        });
      }
      return encodingParameters;
    };
    SDPUtils2.parseRtcpParameters = function(mediaSection) {
      const rtcpParameters = {};
      const remoteSsrc = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((obj) => obj.attribute === "cname")[0];
      if (remoteSsrc) {
        rtcpParameters.cname = remoteSsrc.value;
        rtcpParameters.ssrc = remoteSsrc.ssrc;
      }
      const rsize = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-rsize");
      rtcpParameters.reducedSize = rsize.length > 0;
      rtcpParameters.compound = rsize.length === 0;
      const mux = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-mux");
      rtcpParameters.mux = mux.length > 0;
      return rtcpParameters;
    };
    SDPUtils2.writeRtcpParameters = function(rtcpParameters) {
      let sdp2 = "";
      if (rtcpParameters.reducedSize) {
        sdp2 += "a=rtcp-rsize\r\n";
      }
      if (rtcpParameters.mux) {
        sdp2 += "a=rtcp-mux\r\n";
      }
      if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) {
        sdp2 += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\r\n";
      }
      return sdp2;
    };
    SDPUtils2.parseMsid = function(mediaSection) {
      let parts;
      const spec = SDPUtils2.matchPrefix(mediaSection, "a=msid:");
      if (spec.length === 1) {
        parts = spec[0].substr(7).split(" ");
        return { stream: parts[0], track: parts[1] };
      }
      const planB = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((msidParts) => msidParts.attribute === "msid");
      if (planB.length > 0) {
        parts = planB[0].value.split(" ");
        return { stream: parts[0], track: parts[1] };
      }
    };
    SDPUtils2.parseSctpDescription = function(mediaSection) {
      const mline = SDPUtils2.parseMLine(mediaSection);
      const maxSizeLine = SDPUtils2.matchPrefix(mediaSection, "a=max-message-size:");
      let maxMessageSize;
      if (maxSizeLine.length > 0) {
        maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
      }
      if (isNaN(maxMessageSize)) {
        maxMessageSize = 65536;
      }
      const sctpPort = SDPUtils2.matchPrefix(mediaSection, "a=sctp-port:");
      if (sctpPort.length > 0) {
        return {
          port: parseInt(sctpPort[0].substr(12), 10),
          protocol: mline.fmt,
          maxMessageSize
        };
      }
      const sctpMapLines = SDPUtils2.matchPrefix(mediaSection, "a=sctpmap:");
      if (sctpMapLines.length > 0) {
        const parts = sctpMapLines[0].substr(10).split(" ");
        return {
          port: parseInt(parts[0], 10),
          protocol: parts[1],
          maxMessageSize
        };
      }
    };
    SDPUtils2.writeSctpDescription = function(media, sctp) {
      let output = [];
      if (media.protocol !== "DTLS/SCTP") {
        output = [
          "m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n",
          "c=IN IP4 0.0.0.0\r\n",
          "a=sctp-port:" + sctp.port + "\r\n"
        ];
      } else {
        output = [
          "m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n",
          "c=IN IP4 0.0.0.0\r\n",
          "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"
        ];
      }
      if (sctp.maxMessageSize !== void 0) {
        output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
      }
      return output.join("");
    };
    SDPUtils2.generateSessionId = function() {
      return Math.random().toString().substr(2, 21);
    };
    SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
      let sessionId;
      const version = sessVer !== void 0 ? sessVer : 2;
      if (sessId) {
        sessionId = sessId;
      } else {
        sessionId = SDPUtils2.generateSessionId();
      }
      const user2 = sessUser || "thisisadapterortc";
      return "v=0\r\no=" + user2 + " " + sessionId + " " + version + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
    };
    SDPUtils2.getDirection = function(mediaSection, sessionpart) {
      const lines = SDPUtils2.splitLines(mediaSection);
      for (let i2 = 0; i2 < lines.length; i2++) {
        switch (lines[i2]) {
          case "a=sendrecv":
          case "a=sendonly":
          case "a=recvonly":
          case "a=inactive":
            return lines[i2].substr(2);
          default:
        }
      }
      if (sessionpart) {
        return SDPUtils2.getDirection(sessionpart);
      }
      return "sendrecv";
    };
    SDPUtils2.getKind = function(mediaSection) {
      const lines = SDPUtils2.splitLines(mediaSection);
      const mline = lines[0].split(" ");
      return mline[0].substr(2);
    };
    SDPUtils2.isRejected = function(mediaSection) {
      return mediaSection.split(" ", 2)[1] === "0";
    };
    SDPUtils2.parseMLine = function(mediaSection) {
      const lines = SDPUtils2.splitLines(mediaSection);
      const parts = lines[0].substr(2).split(" ");
      return {
        kind: parts[0],
        port: parseInt(parts[1], 10),
        protocol: parts[2],
        fmt: parts.slice(3).join(" ")
      };
    };
    SDPUtils2.parseOLine = function(mediaSection) {
      const line = SDPUtils2.matchPrefix(mediaSection, "o=")[0];
      const parts = line.substr(2).split(" ");
      return {
        username: parts[0],
        sessionId: parts[1],
        sessionVersion: parseInt(parts[2], 10),
        netType: parts[3],
        addressType: parts[4],
        address: parts[5]
      };
    };
    SDPUtils2.isValidSDP = function(blob) {
      if (typeof blob !== "string" || blob.length === 0) {
        return false;
      }
      const lines = SDPUtils2.splitLines(blob);
      for (let i2 = 0; i2 < lines.length; i2++) {
        if (lines[i2].length < 2 || lines[i2].charAt(1) !== "=") {
          return false;
        }
      }
      return true;
    };
    if (typeof module === "object") {
      module.exports = SDPUtils2;
    }
  }
});

// ../../.yarn/global/cache/esbuild-wasm-npm-0.15.16-c2c146172f-9.zip/node_modules/esbuild-wasm/lib/browser.js
var require_browser = __commonJS({
  "../../.yarn/global/cache/esbuild-wasm-npm-0.15.16-c2c146172f-9.zip/node_modules/esbuild-wasm/lib/browser.js"(exports, module) {
    init_define_process();
    ((module2) => {
      "use strict";
      var __defProp = Object.defineProperty;
      var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames = Object.getOwnPropertyNames;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __export2 = /* @__PURE__ */ __name((target, all) => {
        for (var name in all)
          __defProp(target, name, { get: all[name], enumerable: true });
      }, "__export");
      var __copyProps = /* @__PURE__ */ __name((to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames(from))
            if (!__hasOwnProp.call(to, key) && key !== except)
              __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
        }
        return to;
      }, "__copyProps");
      var __toCommonJS = /* @__PURE__ */ __name((mod5) => __copyProps(__defProp({}, "__esModule", { value: true }), mod5), "__toCommonJS");
      var __async = /* @__PURE__ */ __name((__this, __arguments, generator) => {
        return new Promise((resolve, reject) => {
          var fulfilled = /* @__PURE__ */ __name((value) => {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }, "fulfilled");
          var rejected = /* @__PURE__ */ __name((value) => {
            try {
              step(generator.throw(value));
            } catch (e2) {
              reject(e2);
            }
          }, "rejected");
          var step = /* @__PURE__ */ __name((x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected), "step");
          step((generator = generator.apply(__this, __arguments)).next());
        });
      }, "__async");
      var browser_exports = {};
      __export2(browser_exports, {
        analyzeMetafile: () => analyzeMetafile,
        analyzeMetafileSync: () => analyzeMetafileSync,
        build: () => build2,
        buildSync: () => buildSync,
        default: () => browser_default,
        formatMessages: () => formatMessages,
        formatMessagesSync: () => formatMessagesSync,
        initialize: () => initialize2,
        serve: () => serve,
        transform: () => transform2,
        transformSync: () => transformSync,
        version: () => version
      });
      module2.exports = __toCommonJS(browser_exports);
      function encodePacket(packet) {
        let visit = /* @__PURE__ */ __name((value) => {
          if (value === null) {
            bb.write8(0);
          } else if (typeof value === "boolean") {
            bb.write8(1);
            bb.write8(+value);
          } else if (typeof value === "number") {
            bb.write8(2);
            bb.write32(value | 0);
          } else if (typeof value === "string") {
            bb.write8(3);
            bb.write(encodeUTF8(value));
          } else if (value instanceof Uint8Array) {
            bb.write8(4);
            bb.write(value);
          } else if (value instanceof Array) {
            bb.write8(5);
            bb.write32(value.length);
            for (let item of value) {
              visit(item);
            }
          } else {
            let keys = Object.keys(value);
            bb.write8(6);
            bb.write32(keys.length);
            for (let key of keys) {
              bb.write(encodeUTF8(key));
              visit(value[key]);
            }
          }
        }, "visit");
        let bb = new ByteBuffer();
        bb.write32(0);
        bb.write32(packet.id << 1 | +!packet.isRequest);
        visit(packet.value);
        writeUInt32LE(bb.buf, bb.len - 4, 0);
        return bb.buf.subarray(0, bb.len);
      }
      __name(encodePacket, "encodePacket");
      function decodePacket(bytes) {
        let visit = /* @__PURE__ */ __name(() => {
          switch (bb.read8()) {
            case 0:
              return null;
            case 1:
              return !!bb.read8();
            case 2:
              return bb.read32();
            case 3:
              return decodeUTF8(bb.read());
            case 4:
              return bb.read();
            case 5: {
              let count = bb.read32();
              let value2 = [];
              for (let i2 = 0; i2 < count; i2++) {
                value2.push(visit());
              }
              return value2;
            }
            case 6: {
              let count = bb.read32();
              let value2 = {};
              for (let i2 = 0; i2 < count; i2++) {
                value2[decodeUTF8(bb.read())] = visit();
              }
              return value2;
            }
            default:
              throw new Error("Invalid packet");
          }
        }, "visit");
        let bb = new ByteBuffer(bytes);
        let id = bb.read32();
        let isRequest = (id & 1) === 0;
        id >>>= 1;
        let value = visit();
        if (bb.ptr !== bytes.length) {
          throw new Error("Invalid packet");
        }
        return { id, isRequest, value };
      }
      __name(decodePacket, "decodePacket");
      var ByteBuffer = /* @__PURE__ */ __name(class {
        constructor(buf = new Uint8Array(1024)) {
          this.buf = buf;
          this.len = 0;
          this.ptr = 0;
        }
        _write(delta) {
          if (this.len + delta > this.buf.length) {
            let clone = new Uint8Array((this.len + delta) * 2);
            clone.set(this.buf);
            this.buf = clone;
          }
          this.len += delta;
          return this.len - delta;
        }
        write8(value) {
          let offset = this._write(1);
          this.buf[offset] = value;
        }
        write32(value) {
          let offset = this._write(4);
          writeUInt32LE(this.buf, value, offset);
        }
        write(bytes) {
          let offset = this._write(4 + bytes.length);
          writeUInt32LE(this.buf, bytes.length, offset);
          this.buf.set(bytes, offset + 4);
        }
        _read(delta) {
          if (this.ptr + delta > this.buf.length) {
            throw new Error("Invalid packet");
          }
          this.ptr += delta;
          return this.ptr - delta;
        }
        read8() {
          return this.buf[this._read(1)];
        }
        read32() {
          return readUInt32LE(this.buf, this._read(4));
        }
        read() {
          let length = this.read32();
          let bytes = new Uint8Array(length);
          let ptr = this._read(bytes.length);
          bytes.set(this.buf.subarray(ptr, ptr + length));
          return bytes;
        }
      }, "ByteBuffer");
      var encodeUTF8;
      var decodeUTF8;
      if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
        let encoder = new TextEncoder();
        let decoder = new TextDecoder();
        encodeUTF8 = /* @__PURE__ */ __name((text) => encoder.encode(text), "encodeUTF8");
        decodeUTF8 = /* @__PURE__ */ __name((bytes) => decoder.decode(bytes), "decodeUTF8");
      } else if (typeof Buffer !== "undefined") {
        encodeUTF8 = /* @__PURE__ */ __name((text) => {
          let buffer = Buffer.from(text);
          if (!(buffer instanceof Uint8Array)) {
            buffer = new Uint8Array(buffer);
          }
          return buffer;
        }, "encodeUTF8");
        decodeUTF8 = /* @__PURE__ */ __name((bytes) => {
          let { buffer, byteOffset, byteLength } = bytes;
          return Buffer.from(buffer, byteOffset, byteLength).toString();
        }, "decodeUTF8");
      } else {
        throw new Error("No UTF-8 codec found");
      }
      function readUInt32LE(buffer, offset) {
        return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
      }
      __name(readUInt32LE, "readUInt32LE");
      function writeUInt32LE(buffer, value, offset) {
        buffer[offset++] = value;
        buffer[offset++] = value >> 8;
        buffer[offset++] = value >> 16;
        buffer[offset++] = value >> 24;
      }
      __name(writeUInt32LE, "writeUInt32LE");
      var buildLogLevelDefault = "warning";
      var transformLogLevelDefault = "silent";
      function validateTarget(target) {
        target += "";
        if (target.indexOf(",") >= 0)
          throw new Error(`Invalid target: ${target}`);
        return target;
      }
      __name(validateTarget, "validateTarget");
      var canBeAnything = /* @__PURE__ */ __name(() => null, "canBeAnything");
      var mustBeBoolean = /* @__PURE__ */ __name((value) => typeof value === "boolean" ? null : "a boolean", "mustBeBoolean");
      var mustBeBooleanOrObject = /* @__PURE__ */ __name((value) => typeof value === "boolean" || typeof value === "object" && !Array.isArray(value) ? null : "a boolean or an object", "mustBeBooleanOrObject");
      var mustBeString = /* @__PURE__ */ __name((value) => typeof value === "string" ? null : "a string", "mustBeString");
      var mustBeRegExp = /* @__PURE__ */ __name((value) => value instanceof RegExp ? null : "a RegExp object", "mustBeRegExp");
      var mustBeInteger = /* @__PURE__ */ __name((value) => typeof value === "number" && value === (value | 0) ? null : "an integer", "mustBeInteger");
      var mustBeFunction = /* @__PURE__ */ __name((value) => typeof value === "function" ? null : "a function", "mustBeFunction");
      var mustBeArray = /* @__PURE__ */ __name((value) => Array.isArray(value) ? null : "an array", "mustBeArray");
      var mustBeObject = /* @__PURE__ */ __name((value) => typeof value === "object" && value !== null && !Array.isArray(value) ? null : "an object", "mustBeObject");
      var mustBeWebAssemblyModule = /* @__PURE__ */ __name((value) => value instanceof WebAssembly.Module ? null : "a WebAssembly.Module", "mustBeWebAssemblyModule");
      var mustBeArrayOrRecord = /* @__PURE__ */ __name((value) => typeof value === "object" && value !== null ? null : "an array or an object", "mustBeArrayOrRecord");
      var mustBeObjectOrNull = /* @__PURE__ */ __name((value) => typeof value === "object" && !Array.isArray(value) ? null : "an object or null", "mustBeObjectOrNull");
      var mustBeStringOrBoolean = /* @__PURE__ */ __name((value) => typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean", "mustBeStringOrBoolean");
      var mustBeStringOrObject = /* @__PURE__ */ __name((value) => typeof value === "string" || typeof value === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object", "mustBeStringOrObject");
      var mustBeStringOrArray = /* @__PURE__ */ __name((value) => typeof value === "string" || Array.isArray(value) ? null : "a string or an array", "mustBeStringOrArray");
      var mustBeStringOrUint8Array = /* @__PURE__ */ __name((value) => typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array", "mustBeStringOrUint8Array");
      function getFlag(object, keys, key, mustBeFn) {
        let value = object[key];
        keys[key + ""] = true;
        if (value === void 0)
          return void 0;
        let mustBe = mustBeFn(value);
        if (mustBe !== null)
          throw new Error(`"${key}" must be ${mustBe}`);
        return value;
      }
      __name(getFlag, "getFlag");
      function checkForInvalidFlags(object, keys, where) {
        for (let key in object) {
          if (!(key in keys)) {
            throw new Error(`Invalid option ${where}: "${key}"`);
          }
        }
      }
      __name(checkForInvalidFlags, "checkForInvalidFlags");
      function validateInitializeOptions(options) {
        let keys = /* @__PURE__ */ Object.create(null);
        let wasmURL = getFlag(options, keys, "wasmURL", mustBeString);
        let wasmModule = getFlag(options, keys, "wasmModule", mustBeWebAssemblyModule);
        let worker2 = getFlag(options, keys, "worker", mustBeBoolean);
        checkForInvalidFlags(options, keys, "in initialize() call");
        return {
          wasmURL,
          wasmModule,
          worker: worker2
        };
      }
      __name(validateInitializeOptions, "validateInitializeOptions");
      function validateMangleCache(mangleCache) {
        let validated;
        if (mangleCache !== void 0) {
          validated = /* @__PURE__ */ Object.create(null);
          for (let key of Object.keys(mangleCache)) {
            let value = mangleCache[key];
            if (typeof value === "string" || value === false) {
              validated[key] = value;
            } else {
              throw new Error(`Expected ${JSON.stringify(key)} in mangle cache to map to either a string or false`);
            }
          }
        }
        return validated;
      }
      __name(validateMangleCache, "validateMangleCache");
      function pushLogFlags(flags, options, keys, isTTY, logLevelDefault) {
        let color = getFlag(options, keys, "color", mustBeBoolean);
        let logLevel = getFlag(options, keys, "logLevel", mustBeString);
        let logLimit = getFlag(options, keys, "logLimit", mustBeInteger);
        if (color !== void 0)
          flags.push(`--color=${color}`);
        else if (isTTY)
          flags.push(`--color=true`);
        flags.push(`--log-level=${logLevel || logLevelDefault}`);
        flags.push(`--log-limit=${logLimit || 0}`);
      }
      __name(pushLogFlags, "pushLogFlags");
      function pushCommonFlags(flags, options, keys) {
        let legalComments = getFlag(options, keys, "legalComments", mustBeString);
        let sourceRoot = getFlag(options, keys, "sourceRoot", mustBeString);
        let sourcesContent = getFlag(options, keys, "sourcesContent", mustBeBoolean);
        let target = getFlag(options, keys, "target", mustBeStringOrArray);
        let format2 = getFlag(options, keys, "format", mustBeString);
        let globalName = getFlag(options, keys, "globalName", mustBeString);
        let mangleProps = getFlag(options, keys, "mangleProps", mustBeRegExp);
        let reserveProps = getFlag(options, keys, "reserveProps", mustBeRegExp);
        let mangleQuoted = getFlag(options, keys, "mangleQuoted", mustBeBoolean);
        let minify = getFlag(options, keys, "minify", mustBeBoolean);
        let minifySyntax = getFlag(options, keys, "minifySyntax", mustBeBoolean);
        let minifyWhitespace = getFlag(options, keys, "minifyWhitespace", mustBeBoolean);
        let minifyIdentifiers = getFlag(options, keys, "minifyIdentifiers", mustBeBoolean);
        let drop = getFlag(options, keys, "drop", mustBeArray);
        let charset = getFlag(options, keys, "charset", mustBeString);
        let treeShaking = getFlag(options, keys, "treeShaking", mustBeBoolean);
        let ignoreAnnotations = getFlag(options, keys, "ignoreAnnotations", mustBeBoolean);
        let jsx5 = getFlag(options, keys, "jsx", mustBeString);
        let jsxFactory = getFlag(options, keys, "jsxFactory", mustBeString);
        let jsxFragment = getFlag(options, keys, "jsxFragment", mustBeString);
        let jsxImportSource = getFlag(options, keys, "jsxImportSource", mustBeString);
        let jsxDev = getFlag(options, keys, "jsxDev", mustBeBoolean);
        let jsxSideEffects = getFlag(options, keys, "jsxSideEffects", mustBeBoolean);
        let define3 = getFlag(options, keys, "define", mustBeObject);
        let logOverride = getFlag(options, keys, "logOverride", mustBeObject);
        let supported = getFlag(options, keys, "supported", mustBeObject);
        let pure = getFlag(options, keys, "pure", mustBeArray);
        let keepNames = getFlag(options, keys, "keepNames", mustBeBoolean);
        let platform = getFlag(options, keys, "platform", mustBeString);
        if (legalComments)
          flags.push(`--legal-comments=${legalComments}`);
        if (sourceRoot !== void 0)
          flags.push(`--source-root=${sourceRoot}`);
        if (sourcesContent !== void 0)
          flags.push(`--sources-content=${sourcesContent}`);
        if (target) {
          if (Array.isArray(target))
            flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`);
          else
            flags.push(`--target=${validateTarget(target)}`);
        }
        if (format2)
          flags.push(`--format=${format2}`);
        if (globalName)
          flags.push(`--global-name=${globalName}`);
        if (platform)
          flags.push(`--platform=${platform}`);
        if (minify)
          flags.push("--minify");
        if (minifySyntax)
          flags.push("--minify-syntax");
        if (minifyWhitespace)
          flags.push("--minify-whitespace");
        if (minifyIdentifiers)
          flags.push("--minify-identifiers");
        if (charset)
          flags.push(`--charset=${charset}`);
        if (treeShaking !== void 0)
          flags.push(`--tree-shaking=${treeShaking}`);
        if (ignoreAnnotations)
          flags.push(`--ignore-annotations`);
        if (drop)
          for (let what of drop)
            flags.push(`--drop:${what}`);
        if (mangleProps)
          flags.push(`--mangle-props=${mangleProps.source}`);
        if (reserveProps)
          flags.push(`--reserve-props=${reserveProps.source}`);
        if (mangleQuoted !== void 0)
          flags.push(`--mangle-quoted=${mangleQuoted}`);
        if (jsx5)
          flags.push(`--jsx=${jsx5}`);
        if (jsxFactory)
          flags.push(`--jsx-factory=${jsxFactory}`);
        if (jsxFragment)
          flags.push(`--jsx-fragment=${jsxFragment}`);
        if (jsxImportSource)
          flags.push(`--jsx-import-source=${jsxImportSource}`);
        if (jsxDev)
          flags.push(`--jsx-dev`);
        if (jsxSideEffects)
          flags.push(`--jsx-side-effects`);
        if (define3) {
          for (let key in define3) {
            if (key.indexOf("=") >= 0)
              throw new Error(`Invalid define: ${key}`);
            flags.push(`--define:${key}=${define3[key]}`);
          }
        }
        if (logOverride) {
          for (let key in logOverride) {
            if (key.indexOf("=") >= 0)
              throw new Error(`Invalid log override: ${key}`);
            flags.push(`--log-override:${key}=${logOverride[key]}`);
          }
        }
        if (supported) {
          for (let key in supported) {
            if (key.indexOf("=") >= 0)
              throw new Error(`Invalid supported: ${key}`);
            flags.push(`--supported:${key}=${supported[key]}`);
          }
        }
        if (pure)
          for (let fn of pure)
            flags.push(`--pure:${fn}`);
        if (keepNames)
          flags.push(`--keep-names`);
      }
      __name(pushCommonFlags, "pushCommonFlags");
      function flagsForBuildOptions(callName, options, isTTY, logLevelDefault, writeDefault) {
        var _a;
        let flags = [];
        let entries = [];
        let keys = /* @__PURE__ */ Object.create(null);
        let stdinContents = null;
        let stdinResolveDir = null;
        let watchMode = null;
        pushLogFlags(flags, options, keys, isTTY, logLevelDefault);
        pushCommonFlags(flags, options, keys);
        let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
        let bundle = getFlag(options, keys, "bundle", mustBeBoolean);
        let watch = getFlag(options, keys, "watch", mustBeBooleanOrObject);
        let splitting = getFlag(options, keys, "splitting", mustBeBoolean);
        let preserveSymlinks = getFlag(options, keys, "preserveSymlinks", mustBeBoolean);
        let metafile = getFlag(options, keys, "metafile", mustBeBoolean);
        let outfile = getFlag(options, keys, "outfile", mustBeString);
        let outdir = getFlag(options, keys, "outdir", mustBeString);
        let outbase = getFlag(options, keys, "outbase", mustBeString);
        let tsconfig = getFlag(options, keys, "tsconfig", mustBeString);
        let resolveExtensions = getFlag(options, keys, "resolveExtensions", mustBeArray);
        let nodePathsInput = getFlag(options, keys, "nodePaths", mustBeArray);
        let mainFields = getFlag(options, keys, "mainFields", mustBeArray);
        let conditions = getFlag(options, keys, "conditions", mustBeArray);
        let external = getFlag(options, keys, "external", mustBeArray);
        let alias = getFlag(options, keys, "alias", mustBeObject);
        let loader = getFlag(options, keys, "loader", mustBeObject);
        let outExtension = getFlag(options, keys, "outExtension", mustBeObject);
        let publicPath = getFlag(options, keys, "publicPath", mustBeString);
        let entryNames = getFlag(options, keys, "entryNames", mustBeString);
        let chunkNames = getFlag(options, keys, "chunkNames", mustBeString);
        let assetNames = getFlag(options, keys, "assetNames", mustBeString);
        let inject = getFlag(options, keys, "inject", mustBeArray);
        let banner = getFlag(options, keys, "banner", mustBeObject);
        let footer = getFlag(options, keys, "footer", mustBeObject);
        let entryPoints = getFlag(options, keys, "entryPoints", mustBeArrayOrRecord);
        let absWorkingDir = getFlag(options, keys, "absWorkingDir", mustBeString);
        let stdin = getFlag(options, keys, "stdin", mustBeObject);
        let write = (_a = getFlag(options, keys, "write", mustBeBoolean)) != null ? _a : writeDefault;
        let allowOverwrite = getFlag(options, keys, "allowOverwrite", mustBeBoolean);
        let incremental = getFlag(options, keys, "incremental", mustBeBoolean) === true;
        let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
        keys.plugins = true;
        checkForInvalidFlags(options, keys, `in ${callName}() call`);
        if (sourcemap)
          flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
        if (bundle)
          flags.push("--bundle");
        if (allowOverwrite)
          flags.push("--allow-overwrite");
        if (watch) {
          flags.push("--watch");
          if (typeof watch === "boolean") {
            watchMode = {};
          } else {
            let watchKeys = /* @__PURE__ */ Object.create(null);
            let onRebuild = getFlag(watch, watchKeys, "onRebuild", mustBeFunction);
            checkForInvalidFlags(watch, watchKeys, `on "watch" in ${callName}() call`);
            watchMode = { onRebuild };
          }
        }
        if (splitting)
          flags.push("--splitting");
        if (preserveSymlinks)
          flags.push("--preserve-symlinks");
        if (metafile)
          flags.push(`--metafile`);
        if (outfile)
          flags.push(`--outfile=${outfile}`);
        if (outdir)
          flags.push(`--outdir=${outdir}`);
        if (outbase)
          flags.push(`--outbase=${outbase}`);
        if (tsconfig)
          flags.push(`--tsconfig=${tsconfig}`);
        if (resolveExtensions) {
          let values = [];
          for (let value of resolveExtensions) {
            value += "";
            if (value.indexOf(",") >= 0)
              throw new Error(`Invalid resolve extension: ${value}`);
            values.push(value);
          }
          flags.push(`--resolve-extensions=${values.join(",")}`);
        }
        if (publicPath)
          flags.push(`--public-path=${publicPath}`);
        if (entryNames)
          flags.push(`--entry-names=${entryNames}`);
        if (chunkNames)
          flags.push(`--chunk-names=${chunkNames}`);
        if (assetNames)
          flags.push(`--asset-names=${assetNames}`);
        if (mainFields) {
          let values = [];
          for (let value of mainFields) {
            value += "";
            if (value.indexOf(",") >= 0)
              throw new Error(`Invalid main field: ${value}`);
            values.push(value);
          }
          flags.push(`--main-fields=${values.join(",")}`);
        }
        if (conditions) {
          let values = [];
          for (let value of conditions) {
            value += "";
            if (value.indexOf(",") >= 0)
              throw new Error(`Invalid condition: ${value}`);
            values.push(value);
          }
          flags.push(`--conditions=${values.join(",")}`);
        }
        if (external)
          for (let name of external)
            flags.push(`--external:${name}`);
        if (alias) {
          for (let old in alias) {
            if (old.indexOf("=") >= 0)
              throw new Error(`Invalid package name in alias: ${old}`);
            flags.push(`--alias:${old}=${alias[old]}`);
          }
        }
        if (banner) {
          for (let type in banner) {
            if (type.indexOf("=") >= 0)
              throw new Error(`Invalid banner file type: ${type}`);
            flags.push(`--banner:${type}=${banner[type]}`);
          }
        }
        if (footer) {
          for (let type in footer) {
            if (type.indexOf("=") >= 0)
              throw new Error(`Invalid footer file type: ${type}`);
            flags.push(`--footer:${type}=${footer[type]}`);
          }
        }
        if (inject)
          for (let path of inject)
            flags.push(`--inject:${path}`);
        if (loader) {
          for (let ext in loader) {
            if (ext.indexOf("=") >= 0)
              throw new Error(`Invalid loader extension: ${ext}`);
            flags.push(`--loader:${ext}=${loader[ext]}`);
          }
        }
        if (outExtension) {
          for (let ext in outExtension) {
            if (ext.indexOf("=") >= 0)
              throw new Error(`Invalid out extension: ${ext}`);
            flags.push(`--out-extension:${ext}=${outExtension[ext]}`);
          }
        }
        if (entryPoints) {
          if (Array.isArray(entryPoints)) {
            for (let entryPoint of entryPoints) {
              entries.push(["", entryPoint + ""]);
            }
          } else {
            for (let [key, value] of Object.entries(entryPoints)) {
              entries.push([key + "", value + ""]);
            }
          }
        }
        if (stdin) {
          let stdinKeys = /* @__PURE__ */ Object.create(null);
          let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
          let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
          let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
          let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
          checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
          if (sourcefile)
            flags.push(`--sourcefile=${sourcefile}`);
          if (loader2)
            flags.push(`--loader=${loader2}`);
          if (resolveDir)
            stdinResolveDir = resolveDir + "";
          if (typeof contents === "string")
            stdinContents = encodeUTF8(contents);
          else if (contents instanceof Uint8Array)
            stdinContents = contents;
        }
        let nodePaths = [];
        if (nodePathsInput) {
          for (let value of nodePathsInput) {
            value += "";
            nodePaths.push(value);
          }
        }
        return {
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          incremental,
          nodePaths,
          watch: watchMode,
          mangleCache: validateMangleCache(mangleCache)
        };
      }
      __name(flagsForBuildOptions, "flagsForBuildOptions");
      function flagsForTransformOptions(callName, options, isTTY, logLevelDefault) {
        let flags = [];
        let keys = /* @__PURE__ */ Object.create(null);
        pushLogFlags(flags, options, keys, isTTY, logLevelDefault);
        pushCommonFlags(flags, options, keys);
        let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
        let tsconfigRaw = getFlag(options, keys, "tsconfigRaw", mustBeStringOrObject);
        let sourcefile = getFlag(options, keys, "sourcefile", mustBeString);
        let loader = getFlag(options, keys, "loader", mustBeString);
        let banner = getFlag(options, keys, "banner", mustBeString);
        let footer = getFlag(options, keys, "footer", mustBeString);
        let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
        checkForInvalidFlags(options, keys, `in ${callName}() call`);
        if (sourcemap)
          flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
        if (tsconfigRaw)
          flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
        if (sourcefile)
          flags.push(`--sourcefile=${sourcefile}`);
        if (loader)
          flags.push(`--loader=${loader}`);
        if (banner)
          flags.push(`--banner=${banner}`);
        if (footer)
          flags.push(`--footer=${footer}`);
        return {
          flags,
          mangleCache: validateMangleCache(mangleCache)
        };
      }
      __name(flagsForTransformOptions, "flagsForTransformOptions");
      function createChannel(streamIn) {
        const requestCallbacksByKey = {};
        const closeData = { didClose: false, reason: "" };
        let responseCallbacks = {};
        let nextRequestID = 0;
        let nextBuildKey = 0;
        let stdout = new Uint8Array(16 * 1024);
        let stdoutUsed = 0;
        let readFromStdout = /* @__PURE__ */ __name((chunk) => {
          let limit = stdoutUsed + chunk.length;
          if (limit > stdout.length) {
            let swap = new Uint8Array(limit * 2);
            swap.set(stdout);
            stdout = swap;
          }
          stdout.set(chunk, stdoutUsed);
          stdoutUsed += chunk.length;
          let offset = 0;
          while (offset + 4 <= stdoutUsed) {
            let length = readUInt32LE(stdout, offset);
            if (offset + 4 + length > stdoutUsed) {
              break;
            }
            offset += 4;
            handleIncomingPacket(stdout.subarray(offset, offset + length));
            offset += length;
          }
          if (offset > 0) {
            stdout.copyWithin(0, offset, stdoutUsed);
            stdoutUsed -= offset;
          }
        }, "readFromStdout");
        let afterClose = /* @__PURE__ */ __name((error) => {
          closeData.didClose = true;
          if (error)
            closeData.reason = ": " + (error.message || error);
          const text = "The service was stopped" + closeData.reason;
          for (let id in responseCallbacks) {
            responseCallbacks[id](text, null);
          }
          responseCallbacks = {};
        }, "afterClose");
        let sendRequest = /* @__PURE__ */ __name((refs, value, callback) => {
          if (closeData.didClose)
            return callback("The service is no longer running" + closeData.reason, null);
          let id = nextRequestID++;
          responseCallbacks[id] = (error, response) => {
            try {
              callback(error, response);
            } finally {
              if (refs)
                refs.unref();
            }
          };
          if (refs)
            refs.ref();
          streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));
        }, "sendRequest");
        let sendResponse = /* @__PURE__ */ __name((id, value) => {
          if (closeData.didClose)
            throw new Error("The service is no longer running" + closeData.reason);
          streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));
        }, "sendResponse");
        let handleRequest = /* @__PURE__ */ __name((id, request) => __async(this, null, function* () {
          try {
            if (request.command === "ping") {
              sendResponse(id, {});
              return;
            }
            if (typeof request.key === "number") {
              const requestCallbacks = requestCallbacksByKey[request.key];
              if (requestCallbacks) {
                const callback = requestCallbacks[request.command];
                if (callback) {
                  yield callback(id, request);
                  return;
                }
              }
            }
            throw new Error(`Invalid command: ` + request.command);
          } catch (e2) {
            sendResponse(id, { errors: [extractErrorMessageV8(e2, streamIn, null, void 0, "")] });
          }
        }), "handleRequest");
        let isFirstPacket = true;
        let handleIncomingPacket = /* @__PURE__ */ __name((bytes) => {
          if (isFirstPacket) {
            isFirstPacket = false;
            let binaryVersion = String.fromCharCode(...bytes);
            if (binaryVersion !== "0.15.16") {
              throw new Error(`Cannot start service: Host version "${"0.15.16"}" does not match binary version ${JSON.stringify(binaryVersion)}`);
            }
            return;
          }
          let packet = decodePacket(bytes);
          if (packet.isRequest) {
            handleRequest(packet.id, packet.value);
          } else {
            let callback = responseCallbacks[packet.id];
            delete responseCallbacks[packet.id];
            if (packet.value.error)
              callback(packet.value.error, {});
            else
              callback(null, packet.value);
          }
        }, "handleIncomingPacket");
        let buildOrServe = /* @__PURE__ */ __name(({ callName, refs, serveOptions, options, isTTY, defaultWD, callback }) => {
          let refCount = 0;
          const buildKey = nextBuildKey++;
          const requestCallbacks = {};
          const buildRefs = {
            ref() {
              if (++refCount === 1) {
                if (refs)
                  refs.ref();
              }
            },
            unref() {
              if (--refCount === 0) {
                delete requestCallbacksByKey[buildKey];
                if (refs)
                  refs.unref();
              }
            }
          };
          requestCallbacksByKey[buildKey] = requestCallbacks;
          buildRefs.ref();
          buildOrServeImpl(
            callName,
            buildKey,
            sendRequest,
            sendResponse,
            buildRefs,
            streamIn,
            requestCallbacks,
            options,
            serveOptions,
            isTTY,
            defaultWD,
            closeData,
            (err, res) => {
              try {
                callback(err, res);
              } finally {
                buildRefs.unref();
              }
            }
          );
        }, "buildOrServe");
        let transform22 = /* @__PURE__ */ __name(({ callName, refs, input, options, isTTY, fs, callback }) => {
          const details = createObjectStash();
          let start = /* @__PURE__ */ __name((inputPath) => {
            try {
              if (typeof input !== "string" && !(input instanceof Uint8Array))
                throw new Error('The input to "transform" must be a string or a Uint8Array');
              let {
                flags,
                mangleCache
              } = flagsForTransformOptions(callName, options, isTTY, transformLogLevelDefault);
              let request = {
                command: "transform",
                flags,
                inputFS: inputPath !== null,
                input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
              };
              if (mangleCache)
                request.mangleCache = mangleCache;
              sendRequest(refs, request, (error, response) => {
                if (error)
                  return callback(new Error(error), null);
                let errors = replaceDetailsInMessages(response.errors, details);
                let warnings = replaceDetailsInMessages(response.warnings, details);
                let outstanding = 1;
                let next = /* @__PURE__ */ __name(() => {
                  if (--outstanding === 0) {
                    let result = { warnings, code: response.code, map: response.map };
                    if (response.mangleCache)
                      result.mangleCache = response == null ? void 0 : response.mangleCache;
                    callback(null, result);
                  }
                }, "next");
                if (errors.length > 0)
                  return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
                if (response.codeFS) {
                  outstanding++;
                  fs.readFile(response.code, (err, contents) => {
                    if (err !== null) {
                      callback(err, null);
                    } else {
                      response.code = contents;
                      next();
                    }
                  });
                }
                if (response.mapFS) {
                  outstanding++;
                  fs.readFile(response.map, (err, contents) => {
                    if (err !== null) {
                      callback(err, null);
                    } else {
                      response.map = contents;
                      next();
                    }
                  });
                }
                next();
              });
            } catch (e2) {
              let flags = [];
              try {
                pushLogFlags(flags, options, {}, isTTY, transformLogLevelDefault);
              } catch (e22) {
              }
              const error = extractErrorMessageV8(e2, streamIn, details, void 0, "");
              sendRequest(refs, { command: "error", flags, error }, () => {
                error.detail = details.load(error.detail);
                callback(failureErrorWithLog("Transform failed", [error], []), null);
              });
            }
          }, "start");
          if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
            let next = start;
            start = /* @__PURE__ */ __name(() => fs.writeFile(input, next), "start");
          }
          start(null);
        }, "transform2");
        let formatMessages2 = /* @__PURE__ */ __name(({ callName, refs, messages, options, callback }) => {
          let result = sanitizeMessages(messages, "messages", null, "");
          if (!options)
            throw new Error(`Missing second argument in ${callName}() call`);
          let keys = {};
          let kind = getFlag(options, keys, "kind", mustBeString);
          let color = getFlag(options, keys, "color", mustBeBoolean);
          let terminalWidth = getFlag(options, keys, "terminalWidth", mustBeInteger);
          checkForInvalidFlags(options, keys, `in ${callName}() call`);
          if (kind === void 0)
            throw new Error(`Missing "kind" in ${callName}() call`);
          if (kind !== "error" && kind !== "warning")
            throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
          let request = {
            command: "format-msgs",
            messages: result,
            isWarning: kind === "warning"
          };
          if (color !== void 0)
            request.color = color;
          if (terminalWidth !== void 0)
            request.terminalWidth = terminalWidth;
          sendRequest(refs, request, (error, response) => {
            if (error)
              return callback(new Error(error), null);
            callback(null, response.messages);
          });
        }, "formatMessages2");
        let analyzeMetafile2 = /* @__PURE__ */ __name(({ callName, refs, metafile, options, callback }) => {
          if (options === void 0)
            options = {};
          let keys = {};
          let color = getFlag(options, keys, "color", mustBeBoolean);
          let verbose = getFlag(options, keys, "verbose", mustBeBoolean);
          checkForInvalidFlags(options, keys, `in ${callName}() call`);
          let request = {
            command: "analyze-metafile",
            metafile
          };
          if (color !== void 0)
            request.color = color;
          if (verbose !== void 0)
            request.verbose = verbose;
          sendRequest(refs, request, (error, response) => {
            if (error)
              return callback(new Error(error), null);
            callback(null, response.result);
          });
        }, "analyzeMetafile2");
        return {
          readFromStdout,
          afterClose,
          service: {
            buildOrServe,
            transform: transform22,
            formatMessages: formatMessages2,
            analyzeMetafile: analyzeMetafile2
          }
        };
      }
      __name(createChannel, "createChannel");
      function buildOrServeImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, serveOptions, isTTY, defaultWD, closeData, callback) {
        const details = createObjectStash();
        const logPluginError = /* @__PURE__ */ __name((e2, pluginName, note, done) => {
          const flags = [];
          try {
            pushLogFlags(flags, options, {}, isTTY, buildLogLevelDefault);
          } catch (e22) {
          }
          const message = extractErrorMessageV8(e2, streamIn, details, note, pluginName);
          sendRequest(refs, { command: "error", flags, error: message }, () => {
            message.detail = details.load(message.detail);
            done(message);
          });
        }, "logPluginError");
        const handleError = /* @__PURE__ */ __name((e2, pluginName) => {
          logPluginError(e2, pluginName, void 0, (error) => {
            callback(failureErrorWithLog("Build failed", [error], []), null);
          });
        }, "handleError");
        let plugins;
        if (typeof options === "object") {
          const value = options.plugins;
          if (value !== void 0) {
            if (!Array.isArray(value))
              throw new Error(`"plugins" must be an array`);
            plugins = value;
          }
        }
        if (plugins && plugins.length > 0) {
          if (streamIn.isSync) {
            handleError(new Error("Cannot use plugins in synchronous API calls"), "");
            return;
          }
          handlePlugins(
            buildKey,
            sendRequest,
            sendResponse,
            refs,
            streamIn,
            requestCallbacks,
            options,
            plugins,
            details
          ).then(
            (result) => {
              if (!result.ok) {
                handleError(result.error, result.pluginName);
                return;
              }
              try {
                buildOrServeContinue(result.requestPlugins, result.runOnEndCallbacks);
              } catch (e2) {
                handleError(e2, "");
              }
            },
            (e2) => handleError(e2, "")
          );
          return;
        }
        try {
          buildOrServeContinue(null, (result, logPluginError2, done) => done());
        } catch (e2) {
          handleError(e2, "");
        }
        function buildOrServeContinue(requestPlugins, runOnEndCallbacks) {
          let writeDefault = !streamIn.isWriteUnavailable;
          let {
            entries,
            flags,
            write,
            stdinContents,
            stdinResolveDir,
            absWorkingDir,
            incremental,
            nodePaths,
            watch,
            mangleCache
          } = flagsForBuildOptions(callName, options, isTTY, buildLogLevelDefault, writeDefault);
          let request = {
            command: "build",
            key: buildKey,
            entries,
            flags,
            write,
            stdinContents,
            stdinResolveDir,
            absWorkingDir: absWorkingDir || defaultWD,
            incremental,
            nodePaths
          };
          if (requestPlugins)
            request.plugins = requestPlugins;
          if (mangleCache)
            request.mangleCache = mangleCache;
          let serve2 = serveOptions && buildServeData(buildKey, sendRequest, sendResponse, refs, requestCallbacks, serveOptions, request);
          let rebuild;
          let stop;
          let copyResponseToResult = /* @__PURE__ */ __name((response, result) => {
            if (response.outputFiles)
              result.outputFiles = response.outputFiles.map(convertOutputFiles);
            if (response.metafile)
              result.metafile = JSON.parse(response.metafile);
            if (response.mangleCache)
              result.mangleCache = response.mangleCache;
            if (response.writeToStdout !== void 0)
              console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
          }, "copyResponseToResult");
          let buildResponseToResult = /* @__PURE__ */ __name((response, callback2) => {
            let result = {
              errors: replaceDetailsInMessages(response.errors, details),
              warnings: replaceDetailsInMessages(response.warnings, details)
            };
            copyResponseToResult(response, result);
            runOnEndCallbacks(result, logPluginError, () => {
              if (result.errors.length > 0) {
                return callback2(failureErrorWithLog("Build failed", result.errors, result.warnings), null);
              }
              if (response.rebuild) {
                if (!rebuild) {
                  let isDisposed = false;
                  rebuild = /* @__PURE__ */ __name(() => new Promise((resolve, reject) => {
                    if (isDisposed || closeData.didClose)
                      throw new Error("Cannot rebuild");
                    sendRequest(
                      refs,
                      { command: "rebuild", key: buildKey },
                      (error2, response2) => {
                        if (error2) {
                          const message = { id: "", pluginName: "", text: error2, location: null, notes: [], detail: void 0 };
                          return callback2(failureErrorWithLog("Build failed", [message], []), null);
                        }
                        buildResponseToResult(response2, (error3, result3) => {
                          if (error3)
                            reject(error3);
                          else
                            resolve(result3);
                        });
                      }
                    );
                  }), "rebuild");
                  refs.ref();
                  rebuild.dispose = () => {
                    if (isDisposed)
                      return;
                    isDisposed = true;
                    sendRequest(refs, { command: "rebuild-dispose", key: buildKey }, () => {
                    });
                    refs.unref();
                  };
                }
                result.rebuild = rebuild;
              }
              if (response.watch) {
                if (!stop) {
                  let isStopped = false;
                  refs.ref();
                  stop = /* @__PURE__ */ __name(() => {
                    if (isStopped)
                      return;
                    isStopped = true;
                    delete requestCallbacks["watch-rebuild"];
                    sendRequest(refs, { command: "watch-stop", key: buildKey }, () => {
                    });
                    refs.unref();
                  }, "stop");
                  if (watch) {
                    requestCallbacks["watch-rebuild"] = (id, request2) => {
                      try {
                        let watchResponse = request2.args;
                        let result2 = {
                          errors: replaceDetailsInMessages(watchResponse.errors, details),
                          warnings: replaceDetailsInMessages(watchResponse.warnings, details)
                        };
                        copyResponseToResult(watchResponse, result2);
                        runOnEndCallbacks(result2, logPluginError, () => {
                          if (result2.errors.length > 0) {
                            if (watch.onRebuild)
                              watch.onRebuild(failureErrorWithLog("Build failed", result2.errors, result2.warnings), null);
                            return;
                          }
                          result2.stop = stop;
                          if (watch.onRebuild)
                            watch.onRebuild(null, result2);
                        });
                      } catch (err) {
                        console.error(err);
                      }
                      sendResponse(id, {});
                    };
                  }
                }
                result.stop = stop;
              }
              callback2(null, result);
            });
          }, "buildResponseToResult");
          if (write && streamIn.isWriteUnavailable)
            throw new Error(`The "write" option is unavailable in this environment`);
          if (incremental && streamIn.isSync)
            throw new Error(`Cannot use "incremental" with a synchronous build`);
          if (watch && streamIn.isSync)
            throw new Error(`Cannot use "watch" with a synchronous build`);
          sendRequest(refs, request, (error, response) => {
            if (error)
              return callback(new Error(error), null);
            if (serve2) {
              let serveResponse = response;
              let isStopped = false;
              refs.ref();
              let result = {
                port: serveResponse.port,
                host: serveResponse.host,
                wait: serve2.wait,
                stop() {
                  if (isStopped)
                    return;
                  isStopped = true;
                  serve2.stop();
                  refs.unref();
                }
              };
              refs.ref();
              serve2.wait.then(refs.unref, refs.unref);
              return callback(null, result);
            }
            return buildResponseToResult(response, callback);
          });
        }
        __name(buildOrServeContinue, "buildOrServeContinue");
      }
      __name(buildOrServeImpl, "buildOrServeImpl");
      var buildServeData = /* @__PURE__ */ __name((buildKey, sendRequest, sendResponse, refs, requestCallbacks, options, request) => {
        let keys = {};
        let port = getFlag(options, keys, "port", mustBeInteger);
        let host = getFlag(options, keys, "host", mustBeString);
        let servedir = getFlag(options, keys, "servedir", mustBeString);
        let onRequest = getFlag(options, keys, "onRequest", mustBeFunction);
        let wait2 = new Promise((resolve, reject) => {
          requestCallbacks["serve-wait"] = (id, request2) => {
            if (request2.error !== null)
              reject(new Error(request2.error));
            else
              resolve();
            sendResponse(id, {});
          };
        });
        request.serve = {};
        checkForInvalidFlags(options, keys, `in serve() call`);
        if (port !== void 0)
          request.serve.port = port;
        if (host !== void 0)
          request.serve.host = host;
        if (servedir !== void 0)
          request.serve.servedir = servedir;
        requestCallbacks["serve-request"] = (id, request2) => {
          if (onRequest)
            onRequest(request2.args);
          sendResponse(id, {});
        };
        return {
          wait: wait2,
          stop() {
            sendRequest(refs, { command: "serve-stop", key: buildKey }, () => {
            });
          }
        };
      }, "buildServeData");
      var handlePlugins = /* @__PURE__ */ __name((buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => __async(void 0, null, function* () {
        let onStartCallbacks = [];
        let onEndCallbacks = [];
        let onResolveCallbacks = {};
        let onLoadCallbacks = {};
        let nextCallbackID = 0;
        let i2 = 0;
        let requestPlugins = [];
        let isSetupDone = false;
        plugins = [...plugins];
        for (let item of plugins) {
          let keys = {};
          if (typeof item !== "object")
            throw new Error(`Plugin at index ${i2} must be an object`);
          const name = getFlag(item, keys, "name", mustBeString);
          if (typeof name !== "string" || name === "")
            throw new Error(`Plugin at index ${i2} is missing a name`);
          try {
            let setup = getFlag(item, keys, "setup", mustBeFunction);
            if (typeof setup !== "function")
              throw new Error(`Plugin is missing a setup function`);
            checkForInvalidFlags(item, keys, `on plugin ${JSON.stringify(name)}`);
            let plugin = {
              name,
              onResolve: [],
              onLoad: []
            };
            i2++;
            let resolve = /* @__PURE__ */ __name((path, options = {}) => {
              if (!isSetupDone)
                throw new Error('Cannot call "resolve" before plugin setup has completed');
              if (typeof path !== "string")
                throw new Error(`The path to resolve must be a string`);
              let keys2 = /* @__PURE__ */ Object.create(null);
              let pluginName = getFlag(options, keys2, "pluginName", mustBeString);
              let importer = getFlag(options, keys2, "importer", mustBeString);
              let namespace = getFlag(options, keys2, "namespace", mustBeString);
              let resolveDir = getFlag(options, keys2, "resolveDir", mustBeString);
              let kind = getFlag(options, keys2, "kind", mustBeString);
              let pluginData = getFlag(options, keys2, "pluginData", canBeAnything);
              checkForInvalidFlags(options, keys2, "in resolve() call");
              return new Promise((resolve2, reject) => {
                const request = {
                  command: "resolve",
                  path,
                  key: buildKey,
                  pluginName: name
                };
                if (pluginName != null)
                  request.pluginName = pluginName;
                if (importer != null)
                  request.importer = importer;
                if (namespace != null)
                  request.namespace = namespace;
                if (resolveDir != null)
                  request.resolveDir = resolveDir;
                if (kind != null)
                  request.kind = kind;
                if (pluginData != null)
                  request.pluginData = details.store(pluginData);
                sendRequest(refs, request, (error, response) => {
                  if (error !== null)
                    reject(new Error(error));
                  else
                    resolve2({
                      errors: replaceDetailsInMessages(response.errors, details),
                      warnings: replaceDetailsInMessages(response.warnings, details),
                      path: response.path,
                      external: response.external,
                      sideEffects: response.sideEffects,
                      namespace: response.namespace,
                      suffix: response.suffix,
                      pluginData: details.load(response.pluginData)
                    });
                });
              });
            }, "resolve");
            let promise = setup({
              initialOptions,
              resolve,
              onStart(callback) {
                let registeredText = `This error came from the "onStart" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
                onStartCallbacks.push({ name, callback, note: registeredNote });
              },
              onEnd(callback) {
                let registeredText = `This error came from the "onEnd" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
                onEndCallbacks.push({ name, callback, note: registeredNote });
              },
              onResolve(options, callback) {
                let registeredText = `This error came from the "onResolve" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
                let keys2 = {};
                let filter = getFlag(options, keys2, "filter", mustBeRegExp);
                let namespace = getFlag(options, keys2, "namespace", mustBeString);
                checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${JSON.stringify(name)}`);
                if (filter == null)
                  throw new Error(`onResolve() call is missing a filter`);
                let id = nextCallbackID++;
                onResolveCallbacks[id] = { name, callback, note: registeredNote };
                plugin.onResolve.push({ id, filter: filter.source, namespace: namespace || "" });
              },
              onLoad(options, callback) {
                let registeredText = `This error came from the "onLoad" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
                let keys2 = {};
                let filter = getFlag(options, keys2, "filter", mustBeRegExp);
                let namespace = getFlag(options, keys2, "namespace", mustBeString);
                checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${JSON.stringify(name)}`);
                if (filter == null)
                  throw new Error(`onLoad() call is missing a filter`);
                let id = nextCallbackID++;
                onLoadCallbacks[id] = { name, callback, note: registeredNote };
                plugin.onLoad.push({ id, filter: filter.source, namespace: namespace || "" });
              },
              esbuild: streamIn.esbuild
            });
            if (promise)
              yield promise;
            requestPlugins.push(plugin);
          } catch (e2) {
            return { ok: false, error: e2, pluginName: name };
          }
        }
        requestCallbacks["on-start"] = (id, request) => __async(void 0, null, function* () {
          let response = { errors: [], warnings: [] };
          yield Promise.all(onStartCallbacks.map((_0) => __async(void 0, [_0], function* ({ name, callback, note }) {
            try {
              let result = yield callback();
              if (result != null) {
                if (typeof result !== "object")
                  throw new Error(`Expected onStart() callback in plugin ${JSON.stringify(name)} to return an object`);
                let keys = {};
                let errors = getFlag(result, keys, "errors", mustBeArray);
                let warnings = getFlag(result, keys, "warnings", mustBeArray);
                checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${JSON.stringify(name)}`);
                if (errors != null)
                  response.errors.push(...sanitizeMessages(errors, "errors", details, name));
                if (warnings != null)
                  response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name));
              }
            } catch (e2) {
              response.errors.push(extractErrorMessageV8(e2, streamIn, details, note && note(), name));
            }
          })));
          sendResponse(id, response);
        });
        requestCallbacks["on-resolve"] = (id, request) => __async(void 0, null, function* () {
          let response = {}, name = "", callback, note;
          for (let id2 of request.ids) {
            try {
              ({ name, callback, note } = onResolveCallbacks[id2]);
              let result = yield callback({
                path: request.path,
                importer: request.importer,
                namespace: request.namespace,
                resolveDir: request.resolveDir,
                kind: request.kind,
                pluginData: details.load(request.pluginData)
              });
              if (result != null) {
                if (typeof result !== "object")
                  throw new Error(`Expected onResolve() callback in plugin ${JSON.stringify(name)} to return an object`);
                let keys = {};
                let pluginName = getFlag(result, keys, "pluginName", mustBeString);
                let path = getFlag(result, keys, "path", mustBeString);
                let namespace = getFlag(result, keys, "namespace", mustBeString);
                let suffix = getFlag(result, keys, "suffix", mustBeString);
                let external = getFlag(result, keys, "external", mustBeBoolean);
                let sideEffects = getFlag(result, keys, "sideEffects", mustBeBoolean);
                let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
                let errors = getFlag(result, keys, "errors", mustBeArray);
                let warnings = getFlag(result, keys, "warnings", mustBeArray);
                let watchFiles = getFlag(result, keys, "watchFiles", mustBeArray);
                let watchDirs = getFlag(result, keys, "watchDirs", mustBeArray);
                checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${JSON.stringify(name)}`);
                response.id = id2;
                if (pluginName != null)
                  response.pluginName = pluginName;
                if (path != null)
                  response.path = path;
                if (namespace != null)
                  response.namespace = namespace;
                if (suffix != null)
                  response.suffix = suffix;
                if (external != null)
                  response.external = external;
                if (sideEffects != null)
                  response.sideEffects = sideEffects;
                if (pluginData != null)
                  response.pluginData = details.store(pluginData);
                if (errors != null)
                  response.errors = sanitizeMessages(errors, "errors", details, name);
                if (warnings != null)
                  response.warnings = sanitizeMessages(warnings, "warnings", details, name);
                if (watchFiles != null)
                  response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                if (watchDirs != null)
                  response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                break;
              }
            } catch (e2) {
              response = { id: id2, errors: [extractErrorMessageV8(e2, streamIn, details, note && note(), name)] };
              break;
            }
          }
          sendResponse(id, response);
        });
        requestCallbacks["on-load"] = (id, request) => __async(void 0, null, function* () {
          let response = {}, name = "", callback, note;
          for (let id2 of request.ids) {
            try {
              ({ name, callback, note } = onLoadCallbacks[id2]);
              let result = yield callback({
                path: request.path,
                namespace: request.namespace,
                suffix: request.suffix,
                pluginData: details.load(request.pluginData)
              });
              if (result != null) {
                if (typeof result !== "object")
                  throw new Error(`Expected onLoad() callback in plugin ${JSON.stringify(name)} to return an object`);
                let keys = {};
                let pluginName = getFlag(result, keys, "pluginName", mustBeString);
                let contents = getFlag(result, keys, "contents", mustBeStringOrUint8Array);
                let resolveDir = getFlag(result, keys, "resolveDir", mustBeString);
                let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
                let loader = getFlag(result, keys, "loader", mustBeString);
                let errors = getFlag(result, keys, "errors", mustBeArray);
                let warnings = getFlag(result, keys, "warnings", mustBeArray);
                let watchFiles = getFlag(result, keys, "watchFiles", mustBeArray);
                let watchDirs = getFlag(result, keys, "watchDirs", mustBeArray);
                checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${JSON.stringify(name)}`);
                response.id = id2;
                if (pluginName != null)
                  response.pluginName = pluginName;
                if (contents instanceof Uint8Array)
                  response.contents = contents;
                else if (contents != null)
                  response.contents = encodeUTF8(contents);
                if (resolveDir != null)
                  response.resolveDir = resolveDir;
                if (pluginData != null)
                  response.pluginData = details.store(pluginData);
                if (loader != null)
                  response.loader = loader;
                if (errors != null)
                  response.errors = sanitizeMessages(errors, "errors", details, name);
                if (warnings != null)
                  response.warnings = sanitizeMessages(warnings, "warnings", details, name);
                if (watchFiles != null)
                  response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                if (watchDirs != null)
                  response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                break;
              }
            } catch (e2) {
              response = { id: id2, errors: [extractErrorMessageV8(e2, streamIn, details, note && note(), name)] };
              break;
            }
          }
          sendResponse(id, response);
        });
        let runOnEndCallbacks = /* @__PURE__ */ __name((result, logPluginError, done) => done(), "runOnEndCallbacks");
        if (onEndCallbacks.length > 0) {
          runOnEndCallbacks = /* @__PURE__ */ __name((result, logPluginError, done) => {
            (() => __async(void 0, null, function* () {
              for (const { name, callback, note } of onEndCallbacks) {
                try {
                  yield callback(result);
                } catch (e2) {
                  result.errors.push(yield new Promise((resolve) => logPluginError(e2, name, note && note(), resolve)));
                }
              }
            }))().then(done);
          }, "runOnEndCallbacks");
        }
        isSetupDone = true;
        return {
          ok: true,
          requestPlugins,
          runOnEndCallbacks
        };
      }), "handlePlugins");
      function createObjectStash() {
        const map = /* @__PURE__ */ new Map();
        let nextID = 0;
        return {
          load(id) {
            return map.get(id);
          },
          store(value) {
            if (value === void 0)
              return -1;
            const id = nextID++;
            map.set(id, value);
            return id;
          }
        };
      }
      __name(createObjectStash, "createObjectStash");
      function extractCallerV8(e2, streamIn, ident) {
        let note;
        let tried = false;
        return () => {
          if (tried)
            return note;
          tried = true;
          try {
            let lines = (e2.stack + "").split("\n");
            lines.splice(1, 1);
            let location2 = parseStackLinesV8(streamIn, lines, ident);
            if (location2) {
              note = { text: e2.message, location: location2 };
              return note;
            }
          } catch (e22) {
          }
        };
      }
      __name(extractCallerV8, "extractCallerV8");
      function extractErrorMessageV8(e2, streamIn, stash, note, pluginName) {
        let text = "Internal error";
        let location2 = null;
        try {
          text = (e2 && e2.message || e2) + "";
        } catch (e22) {
        }
        try {
          location2 = parseStackLinesV8(streamIn, (e2.stack + "").split("\n"), "");
        } catch (e22) {
        }
        return { id: "", pluginName, text, location: location2, notes: note ? [note] : [], detail: stash ? stash.store(e2) : -1 };
      }
      __name(extractErrorMessageV8, "extractErrorMessageV8");
      function parseStackLinesV8(streamIn, lines, ident) {
        let at = "    at ";
        if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {
          for (let i2 = 1; i2 < lines.length; i2++) {
            let line = lines[i2];
            if (!line.startsWith(at))
              continue;
            line = line.slice(at.length);
            while (true) {
              let match = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
              if (match) {
                line = match[1];
                continue;
              }
              match = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
              if (match) {
                line = match[1];
                continue;
              }
              match = /^(\S+):(\d+):(\d+)$/.exec(line);
              if (match) {
                let contents;
                try {
                  contents = streamIn.readFileSync(match[1], "utf8");
                } catch (e2) {
                  break;
                }
                let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match[2] - 1] || "";
                let column = +match[3] - 1;
                let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
                return {
                  file: match[1],
                  namespace: "file",
                  line: +match[2],
                  column: encodeUTF8(lineText.slice(0, column)).length,
                  length: encodeUTF8(lineText.slice(column, column + length)).length,
                  lineText: lineText + "\n" + lines.slice(1).join("\n"),
                  suggestion: ""
                };
              }
              break;
            }
          }
        }
        return null;
      }
      __name(parseStackLinesV8, "parseStackLinesV8");
      function failureErrorWithLog(text, errors, warnings) {
        let limit = 5;
        let summary = errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e2, i2) => {
          if (i2 === limit)
            return "\n...";
          if (!e2.location)
            return `
error: ${e2.text}`;
          let { file, line, column } = e2.location;
          let pluginText = e2.pluginName ? `[plugin: ${e2.pluginName}] ` : "";
          return `
${file}:${line}:${column}: ERROR: ${pluginText}${e2.text}`;
        }).join("");
        let error = new Error(`${text}${summary}`);
        error.errors = errors;
        error.warnings = warnings;
        return error;
      }
      __name(failureErrorWithLog, "failureErrorWithLog");
      function replaceDetailsInMessages(messages, stash) {
        for (const message of messages) {
          message.detail = stash.load(message.detail);
        }
        return messages;
      }
      __name(replaceDetailsInMessages, "replaceDetailsInMessages");
      function sanitizeLocation(location2, where) {
        if (location2 == null)
          return null;
        let keys = {};
        let file = getFlag(location2, keys, "file", mustBeString);
        let namespace = getFlag(location2, keys, "namespace", mustBeString);
        let line = getFlag(location2, keys, "line", mustBeInteger);
        let column = getFlag(location2, keys, "column", mustBeInteger);
        let length = getFlag(location2, keys, "length", mustBeInteger);
        let lineText = getFlag(location2, keys, "lineText", mustBeString);
        let suggestion = getFlag(location2, keys, "suggestion", mustBeString);
        checkForInvalidFlags(location2, keys, where);
        return {
          file: file || "",
          namespace: namespace || "",
          line: line || 0,
          column: column || 0,
          length: length || 0,
          lineText: lineText || "",
          suggestion: suggestion || ""
        };
      }
      __name(sanitizeLocation, "sanitizeLocation");
      function sanitizeMessages(messages, property, stash, fallbackPluginName) {
        let messagesClone = [];
        let index = 0;
        for (const message of messages) {
          let keys = {};
          let id = getFlag(message, keys, "id", mustBeString);
          let pluginName = getFlag(message, keys, "pluginName", mustBeString);
          let text = getFlag(message, keys, "text", mustBeString);
          let location2 = getFlag(message, keys, "location", mustBeObjectOrNull);
          let notes = getFlag(message, keys, "notes", mustBeArray);
          let detail = getFlag(message, keys, "detail", canBeAnything);
          let where = `in element ${index} of "${property}"`;
          checkForInvalidFlags(message, keys, where);
          let notesClone = [];
          if (notes) {
            for (const note of notes) {
              let noteKeys = {};
              let noteText = getFlag(note, noteKeys, "text", mustBeString);
              let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
              checkForInvalidFlags(note, noteKeys, where);
              notesClone.push({
                text: noteText || "",
                location: sanitizeLocation(noteLocation, where)
              });
            }
          }
          messagesClone.push({
            id: id || "",
            pluginName: pluginName || fallbackPluginName,
            text: text || "",
            location: sanitizeLocation(location2, where),
            notes: notesClone,
            detail: stash ? stash.store(detail) : -1
          });
          index++;
        }
        return messagesClone;
      }
      __name(sanitizeMessages, "sanitizeMessages");
      function sanitizeStringArray(values, property) {
        const result = [];
        for (const value of values) {
          if (typeof value !== "string")
            throw new Error(`${JSON.stringify(property)} must be an array of strings`);
          result.push(value);
        }
        return result;
      }
      __name(sanitizeStringArray, "sanitizeStringArray");
      function convertOutputFiles({ path, contents }) {
        let text = null;
        return {
          path,
          contents,
          get text() {
            const binary = this.contents;
            if (text === null || binary !== contents) {
              contents = binary;
              text = decodeUTF8(binary);
            }
            return text;
          }
        };
      }
      __name(convertOutputFiles, "convertOutputFiles");
      var version = "0.15.16";
      var build2 = /* @__PURE__ */ __name((options) => ensureServiceIsRunning().build(options), "build");
      var serve = /* @__PURE__ */ __name(() => {
        throw new Error(`The "serve" API only works in node`);
      }, "serve");
      var transform2 = /* @__PURE__ */ __name((input, options) => ensureServiceIsRunning().transform(input, options), "transform");
      var formatMessages = /* @__PURE__ */ __name((messages, options) => ensureServiceIsRunning().formatMessages(messages, options), "formatMessages");
      var analyzeMetafile = /* @__PURE__ */ __name((metafile, options) => ensureServiceIsRunning().analyzeMetafile(metafile, options), "analyzeMetafile");
      var buildSync = /* @__PURE__ */ __name(() => {
        throw new Error(`The "buildSync" API only works in node`);
      }, "buildSync");
      var transformSync = /* @__PURE__ */ __name(() => {
        throw new Error(`The "transformSync" API only works in node`);
      }, "transformSync");
      var formatMessagesSync = /* @__PURE__ */ __name(() => {
        throw new Error(`The "formatMessagesSync" API only works in node`);
      }, "formatMessagesSync");
      var analyzeMetafileSync = /* @__PURE__ */ __name(() => {
        throw new Error(`The "analyzeMetafileSync" API only works in node`);
      }, "analyzeMetafileSync");
      var initializePromise;
      var longLivedService;
      var ensureServiceIsRunning = /* @__PURE__ */ __name(() => {
        if (longLivedService)
          return longLivedService;
        if (initializePromise)
          throw new Error('You need to wait for the promise returned from "initialize" to be resolved before calling this');
        throw new Error('You need to call "initialize" before calling this');
      }, "ensureServiceIsRunning");
      var initialize2 = /* @__PURE__ */ __name((options) => {
        options = validateInitializeOptions(options || {});
        let wasmURL = options.wasmURL;
        let wasmModule = options.wasmModule;
        let useWorker = options.worker !== false;
        if (!wasmURL && !wasmModule)
          throw new Error('Must provide either the "wasmURL" option or the "wasmModule" option');
        if (initializePromise)
          throw new Error('Cannot call "initialize" more than once');
        initializePromise = startRunningService(wasmURL || "", wasmModule, useWorker);
        initializePromise.catch(() => {
          initializePromise = void 0;
        });
        return initializePromise;
      }, "initialize");
      var startRunningService = /* @__PURE__ */ __name((wasmURL, wasmModule, useWorker) => __async(void 0, null, function* () {
        let wasm;
        if (wasmModule) {
          wasm = wasmModule;
        } else {
          let res = yield fetch(wasmURL);
          if (!res.ok)
            throw new Error(`Failed to download ${JSON.stringify(wasmURL)}`);
          wasm = yield res.arrayBuffer();
        }
        let worker2;
        if (useWorker) {
          let blob = new Blob([`onmessage=${'((postMessage) => {\n      // Copyright 2018 The Go Authors. All rights reserved.\n      // Use of this source code is governed by a BSD-style\n      // license that can be found in the LICENSE file.\n      var __async = (__this, __arguments, generator) => {\n        return new Promise((resolve, reject) => {\n          var fulfilled = (value) => {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var rejected = (value) => {\n            try {\n              step(generator.throw(value));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n          step((generator = generator.apply(__this, __arguments)).next());\n        });\n      };\n      let onmessage;\n      let globalThis = {};\n      for (let o = self; o; o = Object.getPrototypeOf(o))\n        for (let k of Object.getOwnPropertyNames(o))\n          if (!(k in globalThis))\n            Object.defineProperty(globalThis, k, { get: () => self[k] });\n      "use strict";\n      (() => {\n        const enosys = () => {\n          const err = new Error("not implemented");\n          err.code = "ENOSYS";\n          return err;\n        };\n        if (!globalThis.fs) {\n          let outputBuf = "";\n          globalThis.fs = {\n            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },\n            writeSync(fd, buf) {\n              outputBuf += decoder.decode(buf);\n              const nl = outputBuf.lastIndexOf("\\n");\n              if (nl != -1) {\n                console.log(outputBuf.substr(0, nl));\n                outputBuf = outputBuf.substr(nl + 1);\n              }\n              return buf.length;\n            },\n            write(fd, buf, offset, length, position, callback) {\n              if (offset !== 0 || length !== buf.length || position !== null) {\n                callback(enosys());\n                return;\n              }\n              const n = this.writeSync(fd, buf);\n              callback(null, n);\n            },\n            chmod(path, mode, callback) {\n              callback(enosys());\n            },\n            chown(path, uid, gid, callback) {\n              callback(enosys());\n            },\n            close(fd, callback) {\n              callback(enosys());\n            },\n            fchmod(fd, mode, callback) {\n              callback(enosys());\n            },\n            fchown(fd, uid, gid, callback) {\n              callback(enosys());\n            },\n            fstat(fd, callback) {\n              callback(enosys());\n            },\n            fsync(fd, callback) {\n              callback(null);\n            },\n            ftruncate(fd, length, callback) {\n              callback(enosys());\n            },\n            lchown(path, uid, gid, callback) {\n              callback(enosys());\n            },\n            link(path, link, callback) {\n              callback(enosys());\n            },\n            lstat(path, callback) {\n              callback(enosys());\n            },\n            mkdir(path, perm, callback) {\n              callback(enosys());\n            },\n            open(path, flags, mode, callback) {\n              callback(enosys());\n            },\n            read(fd, buffer, offset, length, position, callback) {\n              callback(enosys());\n            },\n            readdir(path, callback) {\n              callback(enosys());\n            },\n            readlink(path, callback) {\n              callback(enosys());\n            },\n            rename(from, to, callback) {\n              callback(enosys());\n            },\n            rmdir(path, callback) {\n              callback(enosys());\n            },\n            stat(path, callback) {\n              callback(enosys());\n            },\n            symlink(path, link, callback) {\n              callback(enosys());\n            },\n            truncate(path, length, callback) {\n              callback(enosys());\n            },\n            unlink(path, callback) {\n              callback(enosys());\n            },\n            utimes(path, atime, mtime, callback) {\n              callback(enosys());\n            }\n          };\n        }\n        if (!globalThis.process) {\n          globalThis.process = {\n            getuid() {\n              return -1;\n            },\n            getgid() {\n              return -1;\n            },\n            geteuid() {\n              return -1;\n            },\n            getegid() {\n              return -1;\n            },\n            getgroups() {\n              throw enosys();\n            },\n            pid: -1,\n            ppid: -1,\n            umask() {\n              throw enosys();\n            },\n            cwd() {\n              throw enosys();\n            },\n            chdir() {\n              throw enosys();\n            }\n          };\n        }\n        if (!globalThis.crypto) {\n          throw new Error("globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)");\n        }\n        if (!globalThis.performance) {\n          throw new Error("globalThis.performance is not available, polyfill required (performance.now only)");\n        }\n        if (!globalThis.TextEncoder) {\n          throw new Error("globalThis.TextEncoder is not available, polyfill required");\n        }\n        if (!globalThis.TextDecoder) {\n          throw new Error("globalThis.TextDecoder is not available, polyfill required");\n        }\n        const encoder = new TextEncoder("utf-8");\n        const decoder = new TextDecoder("utf-8");\n        globalThis.Go = class {\n          constructor() {\n            this.argv = ["js"];\n            this.env = {};\n            this.exit = (code) => {\n              if (code !== 0) {\n                console.warn("exit code:", code);\n              }\n            };\n            this._exitPromise = new Promise((resolve) => {\n              this._resolveExitPromise = resolve;\n            });\n            this._pendingEvent = null;\n            this._scheduledTimeouts = /* @__PURE__ */ new Map();\n            this._nextCallbackTimeoutID = 1;\n            const setInt64 = (addr, v) => {\n              this.mem.setUint32(addr + 0, v, true);\n              this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n            };\n            const getInt64 = (addr) => {\n              const low = this.mem.getUint32(addr + 0, true);\n              const high = this.mem.getInt32(addr + 4, true);\n              return low + high * 4294967296;\n            };\n            const loadValue = (addr) => {\n              const f = this.mem.getFloat64(addr, true);\n              if (f === 0) {\n                return void 0;\n              }\n              if (!isNaN(f)) {\n                return f;\n              }\n              const id = this.mem.getUint32(addr, true);\n              return this._values[id];\n            };\n            const storeValue = (addr, v) => {\n              const nanHead = 2146959360;\n              if (typeof v === "number" && v !== 0) {\n                if (isNaN(v)) {\n                  this.mem.setUint32(addr + 4, nanHead, true);\n                  this.mem.setUint32(addr, 0, true);\n                  return;\n                }\n                this.mem.setFloat64(addr, v, true);\n                return;\n              }\n              if (v === void 0) {\n                this.mem.setFloat64(addr, 0, true);\n                return;\n              }\n              let id = this._ids.get(v);\n              if (id === void 0) {\n                id = this._idPool.pop();\n                if (id === void 0) {\n                  id = this._values.length;\n                }\n                this._values[id] = v;\n                this._goRefCounts[id] = 0;\n                this._ids.set(v, id);\n              }\n              this._goRefCounts[id]++;\n              let typeFlag = 0;\n              switch (typeof v) {\n                case "object":\n                  if (v !== null) {\n                    typeFlag = 1;\n                  }\n                  break;\n                case "string":\n                  typeFlag = 2;\n                  break;\n                case "symbol":\n                  typeFlag = 3;\n                  break;\n                case "function":\n                  typeFlag = 4;\n                  break;\n              }\n              this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n              this.mem.setUint32(addr, id, true);\n            };\n            const loadSlice = (addr) => {\n              const array = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n            };\n            const loadSliceOfValues = (addr) => {\n              const array = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              const a = new Array(len);\n              for (let i = 0; i < len; i++) {\n                a[i] = loadValue(array + i * 8);\n              }\n              return a;\n            };\n            const loadString = (addr) => {\n              const saddr = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n            };\n            const timeOrigin = Date.now() - performance.now();\n            this.importObject = {\n              go: {\n                "runtime.wasmExit": (sp) => {\n                  sp >>>= 0;\n                  const code = this.mem.getInt32(sp + 8, true);\n                  this.exited = true;\n                  delete this._inst;\n                  delete this._values;\n                  delete this._goRefCounts;\n                  delete this._ids;\n                  delete this._idPool;\n                  this.exit(code);\n                },\n                "runtime.wasmWrite": (sp) => {\n                  sp >>>= 0;\n                  const fd = getInt64(sp + 8);\n                  const p = getInt64(sp + 16);\n                  const n = this.mem.getInt32(sp + 24, true);\n                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n                },\n                "runtime.resetMemoryDataView": (sp) => {\n                  sp >>>= 0;\n                  this.mem = new DataView(this._inst.exports.mem.buffer);\n                },\n                "runtime.nanotime1": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\n                },\n                "runtime.walltime": (sp) => {\n                  sp >>>= 0;\n                  const msec = new Date().getTime();\n                  setInt64(sp + 8, msec / 1e3);\n                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\n                },\n                "runtime.scheduleTimeoutEvent": (sp) => {\n                  sp >>>= 0;\n                  const id = this._nextCallbackTimeoutID;\n                  this._nextCallbackTimeoutID++;\n                  this._scheduledTimeouts.set(id, setTimeout(\n                    () => {\n                      this._resume();\n                      while (this._scheduledTimeouts.has(id)) {\n                        console.warn("scheduleTimeoutEvent: missed timeout event");\n                        this._resume();\n                      }\n                    },\n                    getInt64(sp + 8) + 1\n                  ));\n                  this.mem.setInt32(sp + 16, id, true);\n                },\n                "runtime.clearTimeoutEvent": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getInt32(sp + 8, true);\n                  clearTimeout(this._scheduledTimeouts.get(id));\n                  this._scheduledTimeouts.delete(id);\n                },\n                "runtime.getRandomData": (sp) => {\n                  sp >>>= 0;\n                  crypto.getRandomValues(loadSlice(sp + 8));\n                },\n                "syscall/js.finalizeRef": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getUint32(sp + 8, true);\n                  this._goRefCounts[id]--;\n                  if (this._goRefCounts[id] === 0) {\n                    const v = this._values[id];\n                    this._values[id] = null;\n                    this._ids.delete(v);\n                    this._idPool.push(id);\n                  }\n                },\n                "syscall/js.stringVal": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, loadString(sp + 8));\n                },\n                "syscall/js.valueGet": (sp) => {\n                  sp >>>= 0;\n                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                  sp = this._inst.exports.getsp() >>> 0;\n                  storeValue(sp + 32, result);\n                },\n                "syscall/js.valueSet": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                },\n                "syscall/js.valueDelete": (sp) => {\n                  sp >>>= 0;\n                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                },\n                "syscall/js.valueIndex": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                },\n                "syscall/js.valueSetIndex": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                },\n                "syscall/js.valueCall": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const m = Reflect.get(v, loadString(sp + 16));\n                    const args = loadSliceOfValues(sp + 32);\n                    const result = Reflect.apply(m, v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, result);\n                    this.mem.setUint8(sp + 64, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, err);\n                    this.mem.setUint8(sp + 64, 0);\n                  }\n                },\n                "syscall/js.valueInvoke": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.apply(v, void 0, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                "syscall/js.valueNew": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.construct(v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                "syscall/js.valueLength": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                },\n                "syscall/js.valuePrepareString": (sp) => {\n                  sp >>>= 0;\n                  const str = encoder.encode(String(loadValue(sp + 8)));\n                  storeValue(sp + 16, str);\n                  setInt64(sp + 24, str.length);\n                },\n                "syscall/js.valueLoadString": (sp) => {\n                  sp >>>= 0;\n                  const str = loadValue(sp + 8);\n                  loadSlice(sp + 16).set(str);\n                },\n                "syscall/js.valueInstanceOf": (sp) => {\n                  sp >>>= 0;\n                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\n                },\n                "syscall/js.copyBytesToGo": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadSlice(sp + 8);\n                  const src = loadValue(sp + 32);\n                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                "syscall/js.copyBytesToJS": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadValue(sp + 8);\n                  const src = loadSlice(sp + 16);\n                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                "debug": (value) => {\n                  console.log(value);\n                }\n              }\n            };\n          }\n          run(instance) {\n            return __async(this, null, function* () {\n              if (!(instance instanceof WebAssembly.Instance)) {\n                throw new Error("Go.run: WebAssembly.Instance expected");\n              }\n              this._inst = instance;\n              this.mem = new DataView(this._inst.exports.mem.buffer);\n              this._values = [\n                NaN,\n                0,\n                null,\n                true,\n                false,\n                globalThis,\n                this\n              ];\n              this._goRefCounts = new Array(this._values.length).fill(Infinity);\n              this._ids = /* @__PURE__ */ new Map([\n                [0, 1],\n                [null, 2],\n                [true, 3],\n                [false, 4],\n                [globalThis, 5],\n                [this, 6]\n              ]);\n              this._idPool = [];\n              this.exited = false;\n              let offset = 4096;\n              const strPtr = (str) => {\n                const ptr = offset;\n                const bytes = encoder.encode(str + "\\0");\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n                offset += bytes.length;\n                if (offset % 8 !== 0) {\n                  offset += 8 - offset % 8;\n                }\n                return ptr;\n              };\n              const argc = this.argv.length;\n              const argvPtrs = [];\n              this.argv.forEach((arg) => {\n                argvPtrs.push(strPtr(arg));\n              });\n              argvPtrs.push(0);\n              const keys = Object.keys(this.env).sort();\n              keys.forEach((key) => {\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n              });\n              argvPtrs.push(0);\n              const argv = offset;\n              argvPtrs.forEach((ptr) => {\n                this.mem.setUint32(offset, ptr, true);\n                this.mem.setUint32(offset + 4, 0, true);\n                offset += 8;\n              });\n              const wasmMinDataAddr = 4096 + 8192;\n              if (offset >= wasmMinDataAddr) {\n                throw new Error("total length of command line and environment variables exceeds limit");\n              }\n              this._inst.exports.run(argc, argv);\n              if (this.exited) {\n                this._resolveExitPromise();\n              }\n              yield this._exitPromise;\n            });\n          }\n          _resume() {\n            if (this.exited) {\n              throw new Error("Go program has already exited");\n            }\n            this._inst.exports.resume();\n            if (this.exited) {\n              this._resolveExitPromise();\n            }\n          }\n          _makeFuncWrapper(id) {\n            const go = this;\n            return function() {\n              const event = { id, this: this, args: arguments };\n              go._pendingEvent = event;\n              go._resume();\n              return event.result;\n            };\n          }\n        };\n      })();\n      onmessage = ({ data: wasm }) => {\n        let decoder = new TextDecoder();\n        let fs = globalThis.fs;\n        let stderr = "";\n        fs.writeSync = (fd, buffer) => {\n          if (fd === 1) {\n            postMessage(buffer);\n          } else if (fd === 2) {\n            stderr += decoder.decode(buffer);\n            let parts = stderr.split("\\n");\n            if (parts.length > 1)\n              console.log(parts.slice(0, -1).join("\\n"));\n            stderr = parts[parts.length - 1];\n          } else {\n            throw new Error("Bad write");\n          }\n          return buffer.length;\n        };\n        let stdin = [];\n        let resumeStdin;\n        let stdinPos = 0;\n        onmessage = ({ data }) => {\n          if (data.length > 0) {\n            stdin.push(data);\n            if (resumeStdin)\n              resumeStdin();\n          }\n        };\n        fs.read = (fd, buffer, offset, length, position, callback) => {\n          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n            throw new Error("Bad read");\n          }\n          if (stdin.length === 0) {\n            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n            return;\n          }\n          let first = stdin[0];\n          let count = Math.max(0, Math.min(length, first.length - stdinPos));\n          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n          stdinPos += count;\n          if (stdinPos === first.length) {\n            stdin.shift();\n            stdinPos = 0;\n          }\n          callback(null, count);\n        };\n        let go = new globalThis.Go();\n        go.argv = ["", `--service=${"0.15.16"}`];\n        if (wasm instanceof WebAssembly.Module) {\n          WebAssembly.instantiate(wasm, go.importObject).then((instance) => go.run(instance));\n        } else {\n          WebAssembly.instantiate(wasm, go.importObject).then(({ instance }) => go.run(instance));\n        }\n      };\n      return (m) => onmessage(m);\n    })'}(postMessage)`], { type: "text/javascript" });
          worker2 = new Worker(URL.createObjectURL(blob));
        } else {
          let onmessage = ((postMessage) => {
            var __async2 = /* @__PURE__ */ __name((__this, __arguments, generator) => {
              return new Promise((resolve, reject) => {
                var fulfilled = /* @__PURE__ */ __name((value) => {
                  try {
                    step(generator.next(value));
                  } catch (e2) {
                    reject(e2);
                  }
                }, "fulfilled");
                var rejected = /* @__PURE__ */ __name((value) => {
                  try {
                    step(generator.throw(value));
                  } catch (e2) {
                    reject(e2);
                  }
                }, "rejected");
                var step = /* @__PURE__ */ __name((x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected), "step");
                step((generator = generator.apply(__this, __arguments)).next());
              });
            }, "__async");
            let onmessage2;
            let globalThis2 = {};
            for (let o2 = self; o2; o2 = Object.getPrototypeOf(o2))
              for (let k2 of Object.getOwnPropertyNames(o2))
                if (!(k2 in globalThis2))
                  Object.defineProperty(globalThis2, k2, { get: () => self[k2] });
            "use strict";
            (() => {
              const enosys = /* @__PURE__ */ __name(() => {
                const err = new Error("not implemented");
                err.code = "ENOSYS";
                return err;
              }, "enosys");
              if (!globalThis2.fs) {
                let outputBuf = "";
                globalThis2.fs = {
                  constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },
                  writeSync(fd, buf) {
                    outputBuf += decoder.decode(buf);
                    const nl = outputBuf.lastIndexOf("\n");
                    if (nl != -1) {
                      console.log(outputBuf.substr(0, nl));
                      outputBuf = outputBuf.substr(nl + 1);
                    }
                    return buf.length;
                  },
                  write(fd, buf, offset, length, position, callback) {
                    if (offset !== 0 || length !== buf.length || position !== null) {
                      callback(enosys());
                      return;
                    }
                    const n2 = this.writeSync(fd, buf);
                    callback(null, n2);
                  },
                  chmod(path, mode, callback) {
                    callback(enosys());
                  },
                  chown(path, uid, gid, callback) {
                    callback(enosys());
                  },
                  close(fd, callback) {
                    callback(enosys());
                  },
                  fchmod(fd, mode, callback) {
                    callback(enosys());
                  },
                  fchown(fd, uid, gid, callback) {
                    callback(enosys());
                  },
                  fstat(fd, callback) {
                    callback(enosys());
                  },
                  fsync(fd, callback) {
                    callback(null);
                  },
                  ftruncate(fd, length, callback) {
                    callback(enosys());
                  },
                  lchown(path, uid, gid, callback) {
                    callback(enosys());
                  },
                  link(path, link, callback) {
                    callback(enosys());
                  },
                  lstat(path, callback) {
                    callback(enosys());
                  },
                  mkdir(path, perm, callback) {
                    callback(enosys());
                  },
                  open(path, flags, mode, callback) {
                    callback(enosys());
                  },
                  read(fd, buffer, offset, length, position, callback) {
                    callback(enosys());
                  },
                  readdir(path, callback) {
                    callback(enosys());
                  },
                  readlink(path, callback) {
                    callback(enosys());
                  },
                  rename(from, to, callback) {
                    callback(enosys());
                  },
                  rmdir(path, callback) {
                    callback(enosys());
                  },
                  stat(path, callback) {
                    callback(enosys());
                  },
                  symlink(path, link, callback) {
                    callback(enosys());
                  },
                  truncate(path, length, callback) {
                    callback(enosys());
                  },
                  unlink(path, callback) {
                    callback(enosys());
                  },
                  utimes(path, atime, mtime, callback) {
                    callback(enosys());
                  }
                };
              }
              if (!globalThis2.process) {
                globalThis2.process = {
                  getuid() {
                    return -1;
                  },
                  getgid() {
                    return -1;
                  },
                  geteuid() {
                    return -1;
                  },
                  getegid() {
                    return -1;
                  },
                  getgroups() {
                    throw enosys();
                  },
                  pid: -1,
                  ppid: -1,
                  umask() {
                    throw enosys();
                  },
                  cwd() {
                    throw enosys();
                  },
                  chdir() {
                    throw enosys();
                  }
                };
              }
              if (!globalThis2.crypto) {
                throw new Error("globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)");
              }
              if (!globalThis2.performance) {
                throw new Error("globalThis.performance is not available, polyfill required (performance.now only)");
              }
              if (!globalThis2.TextEncoder) {
                throw new Error("globalThis.TextEncoder is not available, polyfill required");
              }
              if (!globalThis2.TextDecoder) {
                throw new Error("globalThis.TextDecoder is not available, polyfill required");
              }
              const encoder = new TextEncoder("utf-8");
              const decoder = new TextDecoder("utf-8");
              globalThis2.Go = class {
                constructor() {
                  this.argv = ["js"];
                  this.env = {};
                  this.exit = (code) => {
                    if (code !== 0) {
                      console.warn("exit code:", code);
                    }
                  };
                  this._exitPromise = new Promise((resolve) => {
                    this._resolveExitPromise = resolve;
                  });
                  this._pendingEvent = null;
                  this._scheduledTimeouts = /* @__PURE__ */ new Map();
                  this._nextCallbackTimeoutID = 1;
                  const setInt64 = /* @__PURE__ */ __name((addr, v2) => {
                    this.mem.setUint32(addr + 0, v2, true);
                    this.mem.setUint32(addr + 4, Math.floor(v2 / 4294967296), true);
                  }, "setInt64");
                  const getInt64 = /* @__PURE__ */ __name((addr) => {
                    const low = this.mem.getUint32(addr + 0, true);
                    const high = this.mem.getInt32(addr + 4, true);
                    return low + high * 4294967296;
                  }, "getInt64");
                  const loadValue = /* @__PURE__ */ __name((addr) => {
                    const f2 = this.mem.getFloat64(addr, true);
                    if (f2 === 0) {
                      return void 0;
                    }
                    if (!isNaN(f2)) {
                      return f2;
                    }
                    const id = this.mem.getUint32(addr, true);
                    return this._values[id];
                  }, "loadValue");
                  const storeValue = /* @__PURE__ */ __name((addr, v2) => {
                    const nanHead = 2146959360;
                    if (typeof v2 === "number" && v2 !== 0) {
                      if (isNaN(v2)) {
                        this.mem.setUint32(addr + 4, nanHead, true);
                        this.mem.setUint32(addr, 0, true);
                        return;
                      }
                      this.mem.setFloat64(addr, v2, true);
                      return;
                    }
                    if (v2 === void 0) {
                      this.mem.setFloat64(addr, 0, true);
                      return;
                    }
                    let id = this._ids.get(v2);
                    if (id === void 0) {
                      id = this._idPool.pop();
                      if (id === void 0) {
                        id = this._values.length;
                      }
                      this._values[id] = v2;
                      this._goRefCounts[id] = 0;
                      this._ids.set(v2, id);
                    }
                    this._goRefCounts[id]++;
                    let typeFlag = 0;
                    switch (typeof v2) {
                      case "object":
                        if (v2 !== null) {
                          typeFlag = 1;
                        }
                        break;
                      case "string":
                        typeFlag = 2;
                        break;
                      case "symbol":
                        typeFlag = 3;
                        break;
                      case "function":
                        typeFlag = 4;
                        break;
                    }
                    this.mem.setUint32(addr + 4, nanHead | typeFlag, true);
                    this.mem.setUint32(addr, id, true);
                  }, "storeValue");
                  const loadSlice = /* @__PURE__ */ __name((addr) => {
                    const array = getInt64(addr + 0);
                    const len = getInt64(addr + 8);
                    return new Uint8Array(this._inst.exports.mem.buffer, array, len);
                  }, "loadSlice");
                  const loadSliceOfValues = /* @__PURE__ */ __name((addr) => {
                    const array = getInt64(addr + 0);
                    const len = getInt64(addr + 8);
                    const a2 = new Array(len);
                    for (let i2 = 0; i2 < len; i2++) {
                      a2[i2] = loadValue(array + i2 * 8);
                    }
                    return a2;
                  }, "loadSliceOfValues");
                  const loadString = /* @__PURE__ */ __name((addr) => {
                    const saddr = getInt64(addr + 0);
                    const len = getInt64(addr + 8);
                    return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));
                  }, "loadString");
                  const timeOrigin = Date.now() - performance.now();
                  this.importObject = {
                    go: {
                      "runtime.wasmExit": (sp) => {
                        sp >>>= 0;
                        const code = this.mem.getInt32(sp + 8, true);
                        this.exited = true;
                        delete this._inst;
                        delete this._values;
                        delete this._goRefCounts;
                        delete this._ids;
                        delete this._idPool;
                        this.exit(code);
                      },
                      "runtime.wasmWrite": (sp) => {
                        sp >>>= 0;
                        const fd = getInt64(sp + 8);
                        const p2 = getInt64(sp + 16);
                        const n2 = this.mem.getInt32(sp + 24, true);
                        globalThis2.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p2, n2));
                      },
                      "runtime.resetMemoryDataView": (sp) => {
                        sp >>>= 0;
                        this.mem = new DataView(this._inst.exports.mem.buffer);
                      },
                      "runtime.nanotime1": (sp) => {
                        sp >>>= 0;
                        setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);
                      },
                      "runtime.walltime": (sp) => {
                        sp >>>= 0;
                        const msec = new Date().getTime();
                        setInt64(sp + 8, msec / 1e3);
                        this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);
                      },
                      "runtime.scheduleTimeoutEvent": (sp) => {
                        sp >>>= 0;
                        const id = this._nextCallbackTimeoutID;
                        this._nextCallbackTimeoutID++;
                        this._scheduledTimeouts.set(id, setTimeout(
                          () => {
                            this._resume();
                            while (this._scheduledTimeouts.has(id)) {
                              console.warn("scheduleTimeoutEvent: missed timeout event");
                              this._resume();
                            }
                          },
                          getInt64(sp + 8) + 1
                        ));
                        this.mem.setInt32(sp + 16, id, true);
                      },
                      "runtime.clearTimeoutEvent": (sp) => {
                        sp >>>= 0;
                        const id = this.mem.getInt32(sp + 8, true);
                        clearTimeout(this._scheduledTimeouts.get(id));
                        this._scheduledTimeouts.delete(id);
                      },
                      "runtime.getRandomData": (sp) => {
                        sp >>>= 0;
                        crypto.getRandomValues(loadSlice(sp + 8));
                      },
                      "syscall/js.finalizeRef": (sp) => {
                        sp >>>= 0;
                        const id = this.mem.getUint32(sp + 8, true);
                        this._goRefCounts[id]--;
                        if (this._goRefCounts[id] === 0) {
                          const v2 = this._values[id];
                          this._values[id] = null;
                          this._ids.delete(v2);
                          this._idPool.push(id);
                        }
                      },
                      "syscall/js.stringVal": (sp) => {
                        sp >>>= 0;
                        storeValue(sp + 24, loadString(sp + 8));
                      },
                      "syscall/js.valueGet": (sp) => {
                        sp >>>= 0;
                        const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));
                        sp = this._inst.exports.getsp() >>> 0;
                        storeValue(sp + 32, result);
                      },
                      "syscall/js.valueSet": (sp) => {
                        sp >>>= 0;
                        Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));
                      },
                      "syscall/js.valueDelete": (sp) => {
                        sp >>>= 0;
                        Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));
                      },
                      "syscall/js.valueIndex": (sp) => {
                        sp >>>= 0;
                        storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));
                      },
                      "syscall/js.valueSetIndex": (sp) => {
                        sp >>>= 0;
                        Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));
                      },
                      "syscall/js.valueCall": (sp) => {
                        sp >>>= 0;
                        try {
                          const v2 = loadValue(sp + 8);
                          const m2 = Reflect.get(v2, loadString(sp + 16));
                          const args = loadSliceOfValues(sp + 32);
                          const result = Reflect.apply(m2, v2, args);
                          sp = this._inst.exports.getsp() >>> 0;
                          storeValue(sp + 56, result);
                          this.mem.setUint8(sp + 64, 1);
                        } catch (err) {
                          sp = this._inst.exports.getsp() >>> 0;
                          storeValue(sp + 56, err);
                          this.mem.setUint8(sp + 64, 0);
                        }
                      },
                      "syscall/js.valueInvoke": (sp) => {
                        sp >>>= 0;
                        try {
                          const v2 = loadValue(sp + 8);
                          const args = loadSliceOfValues(sp + 16);
                          const result = Reflect.apply(v2, void 0, args);
                          sp = this._inst.exports.getsp() >>> 0;
                          storeValue(sp + 40, result);
                          this.mem.setUint8(sp + 48, 1);
                        } catch (err) {
                          sp = this._inst.exports.getsp() >>> 0;
                          storeValue(sp + 40, err);
                          this.mem.setUint8(sp + 48, 0);
                        }
                      },
                      "syscall/js.valueNew": (sp) => {
                        sp >>>= 0;
                        try {
                          const v2 = loadValue(sp + 8);
                          const args = loadSliceOfValues(sp + 16);
                          const result = Reflect.construct(v2, args);
                          sp = this._inst.exports.getsp() >>> 0;
                          storeValue(sp + 40, result);
                          this.mem.setUint8(sp + 48, 1);
                        } catch (err) {
                          sp = this._inst.exports.getsp() >>> 0;
                          storeValue(sp + 40, err);
                          this.mem.setUint8(sp + 48, 0);
                        }
                      },
                      "syscall/js.valueLength": (sp) => {
                        sp >>>= 0;
                        setInt64(sp + 16, parseInt(loadValue(sp + 8).length));
                      },
                      "syscall/js.valuePrepareString": (sp) => {
                        sp >>>= 0;
                        const str = encoder.encode(String(loadValue(sp + 8)));
                        storeValue(sp + 16, str);
                        setInt64(sp + 24, str.length);
                      },
                      "syscall/js.valueLoadString": (sp) => {
                        sp >>>= 0;
                        const str = loadValue(sp + 8);
                        loadSlice(sp + 16).set(str);
                      },
                      "syscall/js.valueInstanceOf": (sp) => {
                        sp >>>= 0;
                        this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);
                      },
                      "syscall/js.copyBytesToGo": (sp) => {
                        sp >>>= 0;
                        const dst = loadSlice(sp + 8);
                        const src = loadValue(sp + 32);
                        if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {
                          this.mem.setUint8(sp + 48, 0);
                          return;
                        }
                        const toCopy = src.subarray(0, dst.length);
                        dst.set(toCopy);
                        setInt64(sp + 40, toCopy.length);
                        this.mem.setUint8(sp + 48, 1);
                      },
                      "syscall/js.copyBytesToJS": (sp) => {
                        sp >>>= 0;
                        const dst = loadValue(sp + 8);
                        const src = loadSlice(sp + 16);
                        if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {
                          this.mem.setUint8(sp + 48, 0);
                          return;
                        }
                        const toCopy = src.subarray(0, dst.length);
                        dst.set(toCopy);
                        setInt64(sp + 40, toCopy.length);
                        this.mem.setUint8(sp + 48, 1);
                      },
                      "debug": (value) => {
                        console.log(value);
                      }
                    }
                  };
                }
                run(instance) {
                  return __async2(this, null, function* () {
                    if (!(instance instanceof WebAssembly.Instance)) {
                      throw new Error("Go.run: WebAssembly.Instance expected");
                    }
                    this._inst = instance;
                    this.mem = new DataView(this._inst.exports.mem.buffer);
                    this._values = [
                      NaN,
                      0,
                      null,
                      true,
                      false,
                      globalThis2,
                      this
                    ];
                    this._goRefCounts = new Array(this._values.length).fill(Infinity);
                    this._ids = /* @__PURE__ */ new Map([
                      [0, 1],
                      [null, 2],
                      [true, 3],
                      [false, 4],
                      [globalThis2, 5],
                      [this, 6]
                    ]);
                    this._idPool = [];
                    this.exited = false;
                    let offset = 4096;
                    const strPtr = /* @__PURE__ */ __name((str) => {
                      const ptr = offset;
                      const bytes = encoder.encode(str + "\0");
                      new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);
                      offset += bytes.length;
                      if (offset % 8 !== 0) {
                        offset += 8 - offset % 8;
                      }
                      return ptr;
                    }, "strPtr");
                    const argc = this.argv.length;
                    const argvPtrs = [];
                    this.argv.forEach((arg) => {
                      argvPtrs.push(strPtr(arg));
                    });
                    argvPtrs.push(0);
                    const keys = Object.keys(this.env).sort();
                    keys.forEach((key) => {
                      argvPtrs.push(strPtr(`${key}=${this.env[key]}`));
                    });
                    argvPtrs.push(0);
                    const argv = offset;
                    argvPtrs.forEach((ptr) => {
                      this.mem.setUint32(offset, ptr, true);
                      this.mem.setUint32(offset + 4, 0, true);
                      offset += 8;
                    });
                    const wasmMinDataAddr = 4096 + 8192;
                    if (offset >= wasmMinDataAddr) {
                      throw new Error("total length of command line and environment variables exceeds limit");
                    }
                    this._inst.exports.run(argc, argv);
                    if (this.exited) {
                      this._resolveExitPromise();
                    }
                    yield this._exitPromise;
                  });
                }
                _resume() {
                  if (this.exited) {
                    throw new Error("Go program has already exited");
                  }
                  this._inst.exports.resume();
                  if (this.exited) {
                    this._resolveExitPromise();
                  }
                }
                _makeFuncWrapper(id) {
                  const go = this;
                  return function() {
                    const event = { id, this: this, args: arguments };
                    go._pendingEvent = event;
                    go._resume();
                    return event.result;
                  };
                }
              };
            })();
            onmessage2 = /* @__PURE__ */ __name(({ data: wasm2 }) => {
              let decoder = new TextDecoder();
              let fs = globalThis2.fs;
              let stderr = "";
              fs.writeSync = (fd, buffer) => {
                if (fd === 1) {
                  postMessage(buffer);
                } else if (fd === 2) {
                  stderr += decoder.decode(buffer);
                  let parts = stderr.split("\n");
                  if (parts.length > 1)
                    console.log(parts.slice(0, -1).join("\n"));
                  stderr = parts[parts.length - 1];
                } else {
                  throw new Error("Bad write");
                }
                return buffer.length;
              };
              let stdin = [];
              let resumeStdin;
              let stdinPos = 0;
              onmessage2 = /* @__PURE__ */ __name(({ data }) => {
                if (data.length > 0) {
                  stdin.push(data);
                  if (resumeStdin)
                    resumeStdin();
                }
              }, "onmessage");
              fs.read = (fd, buffer, offset, length, position, callback) => {
                if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {
                  throw new Error("Bad read");
                }
                if (stdin.length === 0) {
                  resumeStdin = /* @__PURE__ */ __name(() => fs.read(fd, buffer, offset, length, position, callback), "resumeStdin");
                  return;
                }
                let first = stdin[0];
                let count = Math.max(0, Math.min(length, first.length - stdinPos));
                buffer.set(first.subarray(stdinPos, stdinPos + count), offset);
                stdinPos += count;
                if (stdinPos === first.length) {
                  stdin.shift();
                  stdinPos = 0;
                }
                callback(null, count);
              };
              let go = new globalThis2.Go();
              go.argv = ["", `--service=${"0.15.16"}`];
              if (wasm2 instanceof WebAssembly.Module) {
                WebAssembly.instantiate(wasm2, go.importObject).then((instance) => go.run(instance));
              } else {
                WebAssembly.instantiate(wasm2, go.importObject).then(({ instance }) => go.run(instance));
              }
            }, "onmessage");
            return (m2) => onmessage2(m2);
          })((data) => worker2.onmessage({ data }));
          worker2 = {
            onmessage: null,
            postMessage: (data) => setTimeout(() => onmessage({ data })),
            terminate() {
            }
          };
        }
        worker2.postMessage(wasm);
        worker2.onmessage = ({ data }) => readFromStdout(data);
        let { readFromStdout, service } = createChannel({
          writeToStdin(bytes) {
            worker2.postMessage(bytes);
          },
          isSync: false,
          isWriteUnavailable: true,
          esbuild: browser_exports
        });
        longLivedService = {
          build: (options) => new Promise((resolve, reject) => service.buildOrServe({
            callName: "build",
            refs: null,
            serveOptions: null,
            options,
            isTTY: false,
            defaultWD: "/",
            callback: (err, res) => err ? reject(err) : resolve(res)
          })),
          transform: (input, options) => new Promise((resolve, reject) => service.transform({
            callName: "transform",
            refs: null,
            input,
            options: options || {},
            isTTY: false,
            fs: {
              readFile(_2, callback) {
                callback(new Error("Internal error"), null);
              },
              writeFile(_2, callback) {
                callback(null);
              }
            },
            callback: (err, res) => err ? reject(err) : resolve(res)
          })),
          formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({
            callName: "formatMessages",
            refs: null,
            messages,
            options,
            callback: (err, res) => err ? reject(err) : resolve(res)
          })),
          analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({
            callName: "analyzeMetafile",
            refs: null,
            metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
            options,
            callback: (err, res) => err ? reject(err) : resolve(res)
          }))
        };
      }), "startRunningService");
      var browser_default = browser_exports;
    })(typeof module === "object" ? module : { set exports(x2) {
      (typeof self !== "undefined" ? self : this).esbuild = x2;
    } });
  }
});

// ../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/utils/shims.js
var require_shims = __commonJS({
  "../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/utils/shims.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.findInArray = findInArray;
    exports.isFunction = isFunction;
    exports.isNum = isNum;
    exports.int = int;
    exports.dontSetMe = dontSetMe;
    function findInArray(array, callback) {
      for (var i2 = 0, length = array.length; i2 < length; i2++) {
        if (callback.apply(callback, [array[i2], i2, array]))
          return array[i2];
      }
    }
    __name(findInArray, "findInArray");
    function isFunction(func) {
      return typeof func === "function" || Object.prototype.toString.call(func) === "[object Function]";
    }
    __name(isFunction, "isFunction");
    function isNum(num) {
      return typeof num === "number" && !isNaN(num);
    }
    __name(isNum, "isNum");
    function int(a2) {
      return parseInt(a2, 10);
    }
    __name(int, "int");
    function dontSetMe(props, propName, componentName) {
      if (props[propName]) {
        return new Error("Invalid prop ".concat(propName, " passed to ").concat(componentName, " - do not set this, set it on the child."));
      }
    }
    __name(dontSetMe, "dontSetMe");
  }
});

// ../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/utils/getPrefix.js
var require_getPrefix = __commonJS({
  "../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/utils/getPrefix.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getPrefix = getPrefix;
    exports.browserPrefixToKey = browserPrefixToKey;
    exports.browserPrefixToStyle = browserPrefixToStyle;
    exports.default = void 0;
    var prefixes = ["Moz", "Webkit", "O", "ms"];
    function getPrefix() {
      var _window$document, _window$document$docu;
      var prop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
      if (typeof window === "undefined")
        return "";
      var style = (_window$document = window.document) === null || _window$document === void 0 ? void 0 : (_window$document$docu = _window$document.documentElement) === null || _window$document$docu === void 0 ? void 0 : _window$document$docu.style;
      if (!style)
        return "";
      if (prop in style)
        return "";
      for (var i2 = 0; i2 < prefixes.length; i2++) {
        if (browserPrefixToKey(prop, prefixes[i2]) in style)
          return prefixes[i2];
      }
      return "";
    }
    __name(getPrefix, "getPrefix");
    function browserPrefixToKey(prop, prefix) {
      return prefix ? "".concat(prefix).concat(kebabToTitleCase(prop)) : prop;
    }
    __name(browserPrefixToKey, "browserPrefixToKey");
    function browserPrefixToStyle(prop, prefix) {
      return prefix ? "-".concat(prefix.toLowerCase(), "-").concat(prop) : prop;
    }
    __name(browserPrefixToStyle, "browserPrefixToStyle");
    function kebabToTitleCase(str) {
      var out = "";
      var shouldCapitalize = true;
      for (var i2 = 0; i2 < str.length; i2++) {
        if (shouldCapitalize) {
          out += str[i2].toUpperCase();
          shouldCapitalize = false;
        } else if (str[i2] === "-") {
          shouldCapitalize = true;
        } else {
          out += str[i2];
        }
      }
      return out;
    }
    __name(kebabToTitleCase, "kebabToTitleCase");
    var _default = getPrefix();
    exports.default = _default;
  }
});

// ../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/utils/domFns.js
var require_domFns = __commonJS({
  "../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/utils/domFns.js"(exports) {
    "use strict";
    init_define_process();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = /* @__PURE__ */ __name(function _typeof2(obj2) {
          return typeof obj2;
        }, "_typeof");
      } else {
        _typeof = /* @__PURE__ */ __name(function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, "_typeof");
      }
      return _typeof(obj);
    }
    __name(_typeof, "_typeof");
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.matchesSelector = matchesSelector;
    exports.matchesSelectorAndParentsTo = matchesSelectorAndParentsTo;
    exports.addEvent = addEvent;
    exports.removeEvent = removeEvent;
    exports.outerHeight = outerHeight;
    exports.outerWidth = outerWidth;
    exports.innerHeight = innerHeight;
    exports.innerWidth = innerWidth;
    exports.offsetXYFromParent = offsetXYFromParent;
    exports.createCSSTransform = createCSSTransform;
    exports.createSVGTransform = createSVGTransform;
    exports.getTranslation = getTranslation;
    exports.getTouch = getTouch;
    exports.getTouchIdentifier = getTouchIdentifier;
    exports.addUserSelectStyles = addUserSelectStyles;
    exports.removeUserSelectStyles = removeUserSelectStyles;
    exports.addClassName = addClassName;
    exports.removeClassName = removeClassName;
    var _shims = require_shims();
    var _getPrefix = _interopRequireWildcard(require_getPrefix());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        if (i2 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    var matchesSelectorFunc = "";
    function matchesSelector(el, selector) {
      if (!matchesSelectorFunc) {
        matchesSelectorFunc = (0, _shims.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(method) {
          return (0, _shims.isFunction)(el[method]);
        });
      }
      if (!(0, _shims.isFunction)(el[matchesSelectorFunc]))
        return false;
      return el[matchesSelectorFunc](selector);
    }
    __name(matchesSelector, "matchesSelector");
    function matchesSelectorAndParentsTo(el, selector, baseNode) {
      var node = el;
      do {
        if (matchesSelector(node, selector))
          return true;
        if (node === baseNode)
          return false;
        node = node.parentNode;
      } while (node);
      return false;
    }
    __name(matchesSelectorAndParentsTo, "matchesSelectorAndParentsTo");
    function addEvent(el, event, handler, inputOptions) {
      if (!el)
        return;
      var options = _objectSpread({
        capture: true
      }, inputOptions);
      if (el.addEventListener) {
        el.addEventListener(event, handler, options);
      } else if (el.attachEvent) {
        el.attachEvent("on" + event, handler);
      } else {
        el["on" + event] = handler;
      }
    }
    __name(addEvent, "addEvent");
    function removeEvent(el, event, handler, inputOptions) {
      if (!el)
        return;
      var options = _objectSpread({
        capture: true
      }, inputOptions);
      if (el.removeEventListener) {
        el.removeEventListener(event, handler, options);
      } else if (el.detachEvent) {
        el.detachEvent("on" + event, handler);
      } else {
        el["on" + event] = null;
      }
    }
    __name(removeEvent, "removeEvent");
    function outerHeight(node) {
      var height2 = node.clientHeight;
      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      height2 += (0, _shims.int)(computedStyle.borderTopWidth);
      height2 += (0, _shims.int)(computedStyle.borderBottomWidth);
      return height2;
    }
    __name(outerHeight, "outerHeight");
    function outerWidth(node) {
      var width = node.clientWidth;
      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      width += (0, _shims.int)(computedStyle.borderLeftWidth);
      width += (0, _shims.int)(computedStyle.borderRightWidth);
      return width;
    }
    __name(outerWidth, "outerWidth");
    function innerHeight(node) {
      var height2 = node.clientHeight;
      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      height2 -= (0, _shims.int)(computedStyle.paddingTop);
      height2 -= (0, _shims.int)(computedStyle.paddingBottom);
      return height2;
    }
    __name(innerHeight, "innerHeight");
    function innerWidth(node) {
      var width = node.clientWidth;
      var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
      width -= (0, _shims.int)(computedStyle.paddingLeft);
      width -= (0, _shims.int)(computedStyle.paddingRight);
      return width;
    }
    __name(innerWidth, "innerWidth");
    function offsetXYFromParent(evt, offsetParent, scale) {
      var isBody = offsetParent === offsetParent.ownerDocument.body;
      var offsetParentRect = isBody ? {
        left: 0,
        top: 0
      } : offsetParent.getBoundingClientRect();
      var x2 = (evt.clientX + offsetParent.scrollLeft - offsetParentRect.left) / scale;
      var y2 = (evt.clientY + offsetParent.scrollTop - offsetParentRect.top) / scale;
      return {
        x: x2,
        y: y2
      };
    }
    __name(offsetXYFromParent, "offsetXYFromParent");
    function createCSSTransform(controlPos, positionOffset) {
      var translation = getTranslation(controlPos, positionOffset, "px");
      return _defineProperty({}, (0, _getPrefix.browserPrefixToKey)("transform", _getPrefix.default), translation);
    }
    __name(createCSSTransform, "createCSSTransform");
    function createSVGTransform(controlPos, positionOffset) {
      var translation = getTranslation(controlPos, positionOffset, "");
      return translation;
    }
    __name(createSVGTransform, "createSVGTransform");
    function getTranslation(_ref2, positionOffset, unitSuffix) {
      var x2 = _ref2.x, y2 = _ref2.y;
      var translation = "translate(".concat(x2).concat(unitSuffix, ",").concat(y2).concat(unitSuffix, ")");
      if (positionOffset) {
        var defaultX = "".concat(typeof positionOffset.x === "string" ? positionOffset.x : positionOffset.x + unitSuffix);
        var defaultY = "".concat(typeof positionOffset.y === "string" ? positionOffset.y : positionOffset.y + unitSuffix);
        translation = "translate(".concat(defaultX, ", ").concat(defaultY, ")") + translation;
      }
      return translation;
    }
    __name(getTranslation, "getTranslation");
    function getTouch(e2, identifier) {
      return e2.targetTouches && (0, _shims.findInArray)(e2.targetTouches, function(t2) {
        return identifier === t2.identifier;
      }) || e2.changedTouches && (0, _shims.findInArray)(e2.changedTouches, function(t2) {
        return identifier === t2.identifier;
      });
    }
    __name(getTouch, "getTouch");
    function getTouchIdentifier(e2) {
      if (e2.targetTouches && e2.targetTouches[0])
        return e2.targetTouches[0].identifier;
      if (e2.changedTouches && e2.changedTouches[0])
        return e2.changedTouches[0].identifier;
    }
    __name(getTouchIdentifier, "getTouchIdentifier");
    function addUserSelectStyles(doc) {
      if (!doc)
        return;
      var styleEl = doc.getElementById("react-draggable-style-el");
      if (!styleEl) {
        styleEl = doc.createElement("style");
        styleEl.type = "text/css";
        styleEl.id = "react-draggable-style-el";
        styleEl.innerHTML = ".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n";
        styleEl.innerHTML += ".react-draggable-transparent-selection *::selection {all: inherit;}\n";
        doc.getElementsByTagName("head")[0].appendChild(styleEl);
      }
      if (doc.body)
        addClassName(doc.body, "react-draggable-transparent-selection");
    }
    __name(addUserSelectStyles, "addUserSelectStyles");
    function removeUserSelectStyles(doc) {
      if (!doc)
        return;
      try {
        if (doc.body)
          removeClassName(doc.body, "react-draggable-transparent-selection");
        if (doc.selection) {
          doc.selection.empty();
        } else {
          var selection = (doc.defaultView || window).getSelection();
          if (selection && selection.type !== "Caret") {
            selection.removeAllRanges();
          }
        }
      } catch (e2) {
      }
    }
    __name(removeUserSelectStyles, "removeUserSelectStyles");
    function addClassName(el, className) {
      if (el.classList) {
        el.classList.add(className);
      } else {
        if (!el.className.match(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)")))) {
          el.className += " ".concat(className);
        }
      }
    }
    __name(addClassName, "addClassName");
    function removeClassName(el, className) {
      if (el.classList) {
        el.classList.remove(className);
      } else {
        el.className = el.className.replace(new RegExp("(?:^|\\s)".concat(className, "(?!\\S)"), "g"), "");
      }
    }
    __name(removeClassName, "removeClassName");
  }
});

// ../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/utils/positionFns.js
var require_positionFns = __commonJS({
  "../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/utils/positionFns.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getBoundPosition = getBoundPosition;
    exports.snapToGrid = snapToGrid;
    exports.canDragX = canDragX;
    exports.canDragY = canDragY;
    exports.getControlPosition = getControlPosition;
    exports.createCoreData = createCoreData;
    exports.createDraggableData = createDraggableData;
    var _shims = require_shims();
    var _domFns = require_domFns();
    function getBoundPosition(draggable, x2, y2) {
      if (!draggable.props.bounds)
        return [x2, y2];
      var bounds = draggable.props.bounds;
      bounds = typeof bounds === "string" ? bounds : cloneBounds(bounds);
      var node = findDOMNode(draggable);
      if (typeof bounds === "string") {
        var ownerDocument = node.ownerDocument;
        var ownerWindow = ownerDocument.defaultView;
        var boundNode;
        if (bounds === "parent") {
          boundNode = node.parentNode;
        } else {
          boundNode = ownerDocument.querySelector(bounds);
        }
        if (!(boundNode instanceof ownerWindow.HTMLElement)) {
          throw new Error('Bounds selector "' + bounds + '" could not find an element.');
        }
        var boundNodeEl = boundNode;
        var nodeStyle = ownerWindow.getComputedStyle(node);
        var boundNodeStyle = ownerWindow.getComputedStyle(boundNodeEl);
        bounds = {
          left: -node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingLeft) + (0, _shims.int)(nodeStyle.marginLeft),
          top: -node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingTop) + (0, _shims.int)(nodeStyle.marginTop),
          right: (0, _domFns.innerWidth)(boundNodeEl) - (0, _domFns.outerWidth)(node) - node.offsetLeft + (0, _shims.int)(boundNodeStyle.paddingRight) - (0, _shims.int)(nodeStyle.marginRight),
          bottom: (0, _domFns.innerHeight)(boundNodeEl) - (0, _domFns.outerHeight)(node) - node.offsetTop + (0, _shims.int)(boundNodeStyle.paddingBottom) - (0, _shims.int)(nodeStyle.marginBottom)
        };
      }
      if ((0, _shims.isNum)(bounds.right))
        x2 = Math.min(x2, bounds.right);
      if ((0, _shims.isNum)(bounds.bottom))
        y2 = Math.min(y2, bounds.bottom);
      if ((0, _shims.isNum)(bounds.left))
        x2 = Math.max(x2, bounds.left);
      if ((0, _shims.isNum)(bounds.top))
        y2 = Math.max(y2, bounds.top);
      return [x2, y2];
    }
    __name(getBoundPosition, "getBoundPosition");
    function snapToGrid(grid, pendingX, pendingY) {
      var x2 = Math.round(pendingX / grid[0]) * grid[0];
      var y2 = Math.round(pendingY / grid[1]) * grid[1];
      return [x2, y2];
    }
    __name(snapToGrid, "snapToGrid");
    function canDragX(draggable) {
      return draggable.props.axis === "both" || draggable.props.axis === "x";
    }
    __name(canDragX, "canDragX");
    function canDragY(draggable) {
      return draggable.props.axis === "both" || draggable.props.axis === "y";
    }
    __name(canDragY, "canDragY");
    function getControlPosition(e2, touchIdentifier, draggableCore) {
      var touchObj = typeof touchIdentifier === "number" ? (0, _domFns.getTouch)(e2, touchIdentifier) : null;
      if (typeof touchIdentifier === "number" && !touchObj)
        return null;
      var node = findDOMNode(draggableCore);
      var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
      return (0, _domFns.offsetXYFromParent)(touchObj || e2, offsetParent, draggableCore.props.scale);
    }
    __name(getControlPosition, "getControlPosition");
    function createCoreData(draggable, x2, y2) {
      var state = draggable.state;
      var isStart = !(0, _shims.isNum)(state.lastX);
      var node = findDOMNode(draggable);
      if (isStart) {
        return {
          node,
          deltaX: 0,
          deltaY: 0,
          lastX: x2,
          lastY: y2,
          x: x2,
          y: y2
        };
      } else {
        return {
          node,
          deltaX: x2 - state.lastX,
          deltaY: y2 - state.lastY,
          lastX: state.lastX,
          lastY: state.lastY,
          x: x2,
          y: y2
        };
      }
    }
    __name(createCoreData, "createCoreData");
    function createDraggableData(draggable, coreData) {
      var scale = draggable.props.scale;
      return {
        node: coreData.node,
        x: draggable.state.x + coreData.deltaX / scale,
        y: draggable.state.y + coreData.deltaY / scale,
        deltaX: coreData.deltaX / scale,
        deltaY: coreData.deltaY / scale,
        lastX: draggable.state.x,
        lastY: draggable.state.y
      };
    }
    __name(createDraggableData, "createDraggableData");
    function cloneBounds(bounds) {
      return {
        left: bounds.left,
        top: bounds.top,
        right: bounds.right,
        bottom: bounds.bottom
      };
    }
    __name(cloneBounds, "cloneBounds");
    function findDOMNode(draggable) {
      var node = draggable.findDOMNode();
      if (!node) {
        throw new Error("<DraggableCore>: Unmounted during event!");
      }
      return node;
    }
    __name(findDOMNode, "findDOMNode");
  }
});

// ../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/utils/log.js
var require_log = __commonJS({
  "../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/utils/log.js"(exports) {
    "use strict";
    init_define_process();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = log2;
    function log2() {
      var _console;
      if (void 0)
        (_console = console).log.apply(_console, arguments);
    }
    __name(log2, "log");
  }
});

// ../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/DraggableCore.js
var require_DraggableCore = __commonJS({
  "../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/DraggableCore.js"(exports) {
    "use strict";
    init_define_process();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = /* @__PURE__ */ __name(function _typeof2(obj2) {
          return typeof obj2;
        }, "_typeof");
      } else {
        _typeof = /* @__PURE__ */ __name(function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, "_typeof");
      }
      return _typeof(obj);
    }
    __name(_typeof, "_typeof");
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var React4 = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _reactDom = _interopRequireDefault(require_react_dom());
    var _domFns = require_domFns();
    var _positionFns = require_positionFns();
    var _shims = require_shims();
    var _log = _interopRequireDefault(require_log());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    __name(_slicedToArray, "_slicedToArray");
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableRest, "_nonIterableRest");
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    __name(_iterableToArrayLimit, "_iterableToArrayLimit");
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    __name(_arrayWithHoles, "_arrayWithHoles");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    __name(_inherits, "_inherits");
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || /* @__PURE__ */ __name(function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      }, "_setPrototypeOf");
      return _setPrototypeOf(o2, p2);
    }
    __name(_setPrototypeOf, "_setPrototypeOf");
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return /* @__PURE__ */ __name(function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      }, "_createSuperInternal");
    }
    __name(_createSuper, "_createSuper");
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    __name(_possibleConstructorReturn, "_possibleConstructorReturn");
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    __name(_assertThisInitialized, "_assertThisInitialized");
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    __name(_isNativeReflectConstruct, "_isNativeReflectConstruct");
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ __name(function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      }, "_getPrototypeOf");
      return _getPrototypeOf(o2);
    }
    __name(_getPrototypeOf, "_getPrototypeOf");
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    var eventsFor = {
      touch: {
        start: "touchstart",
        move: "touchmove",
        stop: "touchend"
      },
      mouse: {
        start: "mousedown",
        move: "mousemove",
        stop: "mouseup"
      }
    };
    var dragEventFor = eventsFor.mouse;
    var DraggableCore = /* @__PURE__ */ function(_React$Component) {
      _inherits(DraggableCore2, _React$Component);
      var _super = _createSuper(DraggableCore2);
      function DraggableCore2() {
        var _this;
        _classCallCheck(this, DraggableCore2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "state", {
          dragging: false,
          lastX: NaN,
          lastY: NaN,
          touchIdentifier: null
        });
        _defineProperty(_assertThisInitialized(_this), "mounted", false);
        _defineProperty(_assertThisInitialized(_this), "handleDragStart", function(e2) {
          _this.props.onMouseDown(e2);
          if (!_this.props.allowAnyClick && typeof e2.button === "number" && e2.button !== 0)
            return false;
          var thisNode = _this.findDOMNode();
          if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
            throw new Error("<DraggableCore> not mounted on DragStart!");
          }
          var ownerDocument = thisNode.ownerDocument;
          if (_this.props.disabled || !(e2.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !(0, _domFns.matchesSelectorAndParentsTo)(e2.target, _this.props.handle, thisNode) || _this.props.cancel && (0, _domFns.matchesSelectorAndParentsTo)(e2.target, _this.props.cancel, thisNode)) {
            return;
          }
          if (e2.type === "touchstart")
            e2.preventDefault();
          var touchIdentifier = (0, _domFns.getTouchIdentifier)(e2);
          _this.setState({
            touchIdentifier
          });
          var position = (0, _positionFns.getControlPosition)(e2, touchIdentifier, _assertThisInitialized(_this));
          if (position == null)
            return;
          var x2 = position.x, y2 = position.y;
          var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x2, y2);
          (0, _log.default)("DraggableCore: handleDragStart: %j", coreEvent);
          (0, _log.default)("calling", _this.props.onStart);
          var shouldUpdate = _this.props.onStart(e2, coreEvent);
          if (shouldUpdate === false || _this.mounted === false)
            return;
          if (_this.props.enableUserSelectHack)
            (0, _domFns.addUserSelectStyles)(ownerDocument);
          _this.setState({
            dragging: true,
            lastX: x2,
            lastY: y2
          });
          (0, _domFns.addEvent)(ownerDocument, dragEventFor.move, _this.handleDrag);
          (0, _domFns.addEvent)(ownerDocument, dragEventFor.stop, _this.handleDragStop);
        });
        _defineProperty(_assertThisInitialized(_this), "handleDrag", function(e2) {
          var position = (0, _positionFns.getControlPosition)(e2, _this.state.touchIdentifier, _assertThisInitialized(_this));
          if (position == null)
            return;
          var x2 = position.x, y2 = position.y;
          if (Array.isArray(_this.props.grid)) {
            var deltaX = x2 - _this.state.lastX, deltaY = y2 - _this.state.lastY;
            var _snapToGrid = (0, _positionFns.snapToGrid)(_this.props.grid, deltaX, deltaY);
            var _snapToGrid2 = _slicedToArray(_snapToGrid, 2);
            deltaX = _snapToGrid2[0];
            deltaY = _snapToGrid2[1];
            if (!deltaX && !deltaY)
              return;
            x2 = _this.state.lastX + deltaX, y2 = _this.state.lastY + deltaY;
          }
          var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x2, y2);
          (0, _log.default)("DraggableCore: handleDrag: %j", coreEvent);
          var shouldUpdate = _this.props.onDrag(e2, coreEvent);
          if (shouldUpdate === false || _this.mounted === false) {
            try {
              _this.handleDragStop(new MouseEvent("mouseup"));
            } catch (err) {
              var event = document.createEvent("MouseEvents");
              event.initMouseEvent("mouseup", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
              _this.handleDragStop(event);
            }
            return;
          }
          _this.setState({
            lastX: x2,
            lastY: y2
          });
        });
        _defineProperty(_assertThisInitialized(_this), "handleDragStop", function(e2) {
          if (!_this.state.dragging)
            return;
          var position = (0, _positionFns.getControlPosition)(e2, _this.state.touchIdentifier, _assertThisInitialized(_this));
          if (position == null)
            return;
          var x2 = position.x, y2 = position.y;
          var coreEvent = (0, _positionFns.createCoreData)(_assertThisInitialized(_this), x2, y2);
          var shouldContinue = _this.props.onStop(e2, coreEvent);
          if (shouldContinue === false || _this.mounted === false)
            return false;
          var thisNode = _this.findDOMNode();
          if (thisNode) {
            if (_this.props.enableUserSelectHack)
              (0, _domFns.removeUserSelectStyles)(thisNode.ownerDocument);
          }
          (0, _log.default)("DraggableCore: handleDragStop: %j", coreEvent);
          _this.setState({
            dragging: false,
            lastX: NaN,
            lastY: NaN
          });
          if (thisNode) {
            (0, _log.default)("DraggableCore: Removing handlers");
            (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.move, _this.handleDrag);
            (0, _domFns.removeEvent)(thisNode.ownerDocument, dragEventFor.stop, _this.handleDragStop);
          }
        });
        _defineProperty(_assertThisInitialized(_this), "onMouseDown", function(e2) {
          dragEventFor = eventsFor.mouse;
          return _this.handleDragStart(e2);
        });
        _defineProperty(_assertThisInitialized(_this), "onMouseUp", function(e2) {
          dragEventFor = eventsFor.mouse;
          return _this.handleDragStop(e2);
        });
        _defineProperty(_assertThisInitialized(_this), "onTouchStart", function(e2) {
          dragEventFor = eventsFor.touch;
          return _this.handleDragStart(e2);
        });
        _defineProperty(_assertThisInitialized(_this), "onTouchEnd", function(e2) {
          dragEventFor = eventsFor.touch;
          return _this.handleDragStop(e2);
        });
        return _this;
      }
      __name(DraggableCore2, "DraggableCore");
      _createClass(DraggableCore2, [{
        key: "componentDidMount",
        value: /* @__PURE__ */ __name(function componentDidMount() {
          this.mounted = true;
          var thisNode = this.findDOMNode();
          if (thisNode) {
            (0, _domFns.addEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
              passive: false
            });
          }
        }, "componentDidMount")
      }, {
        key: "componentWillUnmount",
        value: /* @__PURE__ */ __name(function componentWillUnmount() {
          this.mounted = false;
          var thisNode = this.findDOMNode();
          if (thisNode) {
            var ownerDocument = thisNode.ownerDocument;
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.move, this.handleDrag);
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.move, this.handleDrag);
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
            (0, _domFns.removeEvent)(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
            (0, _domFns.removeEvent)(thisNode, eventsFor.touch.start, this.onTouchStart, {
              passive: false
            });
            if (this.props.enableUserSelectHack)
              (0, _domFns.removeUserSelectStyles)(ownerDocument);
          }
        }, "componentWillUnmount")
      }, {
        key: "findDOMNode",
        value: /* @__PURE__ */ __name(function findDOMNode() {
          var _this$props$nodeRef$c, _this$props, _this$props$nodeRef;
          return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 ? void 0 : (_this$props$nodeRef = _this$props.nodeRef) === null || _this$props$nodeRef === void 0 ? void 0 : _this$props$nodeRef.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);
        }, "findDOMNode")
      }, {
        key: "render",
        value: /* @__PURE__ */ __name(function render2() {
          return /* @__PURE__ */ React4.cloneElement(React4.Children.only(this.props.children), {
            onMouseDown: this.onMouseDown,
            onMouseUp: this.onMouseUp,
            onTouchEnd: this.onTouchEnd
          });
        }, "render")
      }]);
      return DraggableCore2;
    }(React4.Component);
    exports.default = DraggableCore;
    _defineProperty(DraggableCore, "displayName", "DraggableCore");
    _defineProperty(DraggableCore, "propTypes", {
      allowAnyClick: _propTypes.default.bool,
      disabled: _propTypes.default.bool,
      enableUserSelectHack: _propTypes.default.bool,
      offsetParent: /* @__PURE__ */ __name(function offsetParent(props, propName) {
        if (props[propName] && props[propName].nodeType !== 1) {
          throw new Error("Draggable's offsetParent must be a DOM Node.");
        }
      }, "offsetParent"),
      grid: _propTypes.default.arrayOf(_propTypes.default.number),
      handle: _propTypes.default.string,
      cancel: _propTypes.default.string,
      nodeRef: _propTypes.default.object,
      onStart: _propTypes.default.func,
      onDrag: _propTypes.default.func,
      onStop: _propTypes.default.func,
      onMouseDown: _propTypes.default.func,
      scale: _propTypes.default.number,
      className: _shims.dontSetMe,
      style: _shims.dontSetMe,
      transform: _shims.dontSetMe
    });
    _defineProperty(DraggableCore, "defaultProps", {
      allowAnyClick: false,
      disabled: false,
      enableUserSelectHack: true,
      onStart: /* @__PURE__ */ __name(function onStart() {
      }, "onStart"),
      onDrag: /* @__PURE__ */ __name(function onDrag() {
      }, "onDrag"),
      onStop: /* @__PURE__ */ __name(function onStop() {
      }, "onStop"),
      onMouseDown: /* @__PURE__ */ __name(function onMouseDown() {
      }, "onMouseDown"),
      scale: 1
    });
  }
});

// ../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/Draggable.js
var require_Draggable = __commonJS({
  "../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/Draggable.js"(exports) {
    "use strict";
    init_define_process();
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = /* @__PURE__ */ __name(function _typeof2(obj2) {
          return typeof obj2;
        }, "_typeof");
      } else {
        _typeof = /* @__PURE__ */ __name(function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        }, "_typeof");
      }
      return _typeof(obj);
    }
    __name(_typeof, "_typeof");
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DraggableCore", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get() {
        return _DraggableCore.default;
      }, "get")
    });
    exports.default = void 0;
    var React4 = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _reactDom = _interopRequireDefault(require_react_dom());
    var _clsx2 = _interopRequireDefault(require_clsx());
    var _domFns = require_domFns();
    var _positionFns = require_positionFns();
    var _shims = require_shims();
    var _DraggableCore = _interopRequireDefault(require_DraggableCore());
    var _log = _interopRequireDefault(require_log());
    var _excluded = ["axis", "bounds", "children", "defaultPosition", "defaultClassName", "defaultClassNameDragging", "defaultClassNameDragged", "position", "positionOffset", "scale"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = /* @__PURE__ */ __name(function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      }, "_getRequireWildcardCache"))(nodeInterop);
    }
    __name(_getRequireWildcardCache, "_getRequireWildcardCache");
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    __name(_interopRequireWildcard, "_interopRequireWildcard");
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    __name(_extends, "_extends");
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i2;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
          key = sourceSymbolKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    __name(_objectWithoutProperties, "_objectWithoutProperties");
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    __name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        if (i2 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    __name(_objectSpread, "_objectSpread");
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    __name(_slicedToArray, "_slicedToArray");
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    __name(_nonIterableRest, "_nonIterableRest");
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2)
        return;
      if (typeof o2 === "string")
        return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor)
        n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o2, minLen);
    }
    __name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    __name(_arrayLikeToArray, "_arrayLikeToArray");
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    __name(_iterableToArrayLimit, "_iterableToArrayLimit");
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    __name(_arrayWithHoles, "_arrayWithHoles");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    __name(_inherits, "_inherits");
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || /* @__PURE__ */ __name(function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      }, "_setPrototypeOf");
      return _setPrototypeOf(o2, p2);
    }
    __name(_setPrototypeOf, "_setPrototypeOf");
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return /* @__PURE__ */ __name(function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      }, "_createSuperInternal");
    }
    __name(_createSuper, "_createSuper");
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    __name(_possibleConstructorReturn, "_possibleConstructorReturn");
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    __name(_assertThisInitialized, "_assertThisInitialized");
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    __name(_isNativeReflectConstruct, "_isNativeReflectConstruct");
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : /* @__PURE__ */ __name(function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      }, "_getPrototypeOf");
      return _getPrototypeOf(o2);
    }
    __name(_getPrototypeOf, "_getPrototypeOf");
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    var Draggable2 = /* @__PURE__ */ function(_React$Component) {
      _inherits(Draggable3, _React$Component);
      var _super = _createSuper(Draggable3);
      function Draggable3(props) {
        var _this;
        _classCallCheck(this, Draggable3);
        _this = _super.call(this, props);
        _defineProperty(_assertThisInitialized(_this), "onDragStart", function(e2, coreData) {
          (0, _log.default)("Draggable: onDragStart: %j", coreData);
          var shouldStart = _this.props.onStart(e2, (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData));
          if (shouldStart === false)
            return false;
          _this.setState({
            dragging: true,
            dragged: true
          });
        });
        _defineProperty(_assertThisInitialized(_this), "onDrag", function(e2, coreData) {
          if (!_this.state.dragging)
            return false;
          (0, _log.default)("Draggable: onDrag: %j", coreData);
          var uiData = (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData);
          var newState = {
            x: uiData.x,
            y: uiData.y
          };
          if (_this.props.bounds) {
            var x2 = newState.x, y2 = newState.y;
            newState.x += _this.state.slackX;
            newState.y += _this.state.slackY;
            var _getBoundPosition = (0, _positionFns.getBoundPosition)(_assertThisInitialized(_this), newState.x, newState.y), _getBoundPosition2 = _slicedToArray(_getBoundPosition, 2), newStateX = _getBoundPosition2[0], newStateY = _getBoundPosition2[1];
            newState.x = newStateX;
            newState.y = newStateY;
            newState.slackX = _this.state.slackX + (x2 - newState.x);
            newState.slackY = _this.state.slackY + (y2 - newState.y);
            uiData.x = newState.x;
            uiData.y = newState.y;
            uiData.deltaX = newState.x - _this.state.x;
            uiData.deltaY = newState.y - _this.state.y;
          }
          var shouldUpdate = _this.props.onDrag(e2, uiData);
          if (shouldUpdate === false)
            return false;
          _this.setState(newState);
        });
        _defineProperty(_assertThisInitialized(_this), "onDragStop", function(e2, coreData) {
          if (!_this.state.dragging)
            return false;
          var shouldContinue = _this.props.onStop(e2, (0, _positionFns.createDraggableData)(_assertThisInitialized(_this), coreData));
          if (shouldContinue === false)
            return false;
          (0, _log.default)("Draggable: onDragStop: %j", coreData);
          var newState = {
            dragging: false,
            slackX: 0,
            slackY: 0
          };
          var controlled = Boolean(_this.props.position);
          if (controlled) {
            var _this$props$position = _this.props.position, x2 = _this$props$position.x, y2 = _this$props$position.y;
            newState.x = x2;
            newState.y = y2;
          }
          _this.setState(newState);
        });
        _this.state = {
          dragging: false,
          dragged: false,
          x: props.position ? props.position.x : props.defaultPosition.x,
          y: props.position ? props.position.y : props.defaultPosition.y,
          prevPropsPosition: _objectSpread({}, props.position),
          slackX: 0,
          slackY: 0,
          isElementSVG: false
        };
        if (props.position && !(props.onDrag || props.onStop)) {
          console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
        }
        return _this;
      }
      __name(Draggable3, "Draggable");
      _createClass(Draggable3, [{
        key: "componentDidMount",
        value: /* @__PURE__ */ __name(function componentDidMount() {
          if (typeof window.SVGElement !== "undefined" && this.findDOMNode() instanceof window.SVGElement) {
            this.setState({
              isElementSVG: true
            });
          }
        }, "componentDidMount")
      }, {
        key: "componentWillUnmount",
        value: /* @__PURE__ */ __name(function componentWillUnmount() {
          this.setState({
            dragging: false
          });
        }, "componentWillUnmount")
      }, {
        key: "findDOMNode",
        value: /* @__PURE__ */ __name(function findDOMNode() {
          var _this$props$nodeRef$c, _this$props, _this$props$nodeRef;
          return (_this$props$nodeRef$c = (_this$props = this.props) === null || _this$props === void 0 ? void 0 : (_this$props$nodeRef = _this$props.nodeRef) === null || _this$props$nodeRef === void 0 ? void 0 : _this$props$nodeRef.current) !== null && _this$props$nodeRef$c !== void 0 ? _this$props$nodeRef$c : _reactDom.default.findDOMNode(this);
        }, "findDOMNode")
      }, {
        key: "render",
        value: /* @__PURE__ */ __name(function render2() {
          var _clsx;
          var _this$props2 = this.props, axis = _this$props2.axis, bounds = _this$props2.bounds, children = _this$props2.children, defaultPosition = _this$props2.defaultPosition, defaultClassName = _this$props2.defaultClassName, defaultClassNameDragging = _this$props2.defaultClassNameDragging, defaultClassNameDragged = _this$props2.defaultClassNameDragged, position = _this$props2.position, positionOffset = _this$props2.positionOffset, scale = _this$props2.scale, draggableCoreProps = _objectWithoutProperties(_this$props2, _excluded);
          var style = {};
          var svgTransform = null;
          var controlled = Boolean(position);
          var draggable = !controlled || this.state.dragging;
          var validPosition = position || defaultPosition;
          var transformOpts = {
            x: (0, _positionFns.canDragX)(this) && draggable ? this.state.x : validPosition.x,
            y: (0, _positionFns.canDragY)(this) && draggable ? this.state.y : validPosition.y
          };
          if (this.state.isElementSVG) {
            svgTransform = (0, _domFns.createSVGTransform)(transformOpts, positionOffset);
          } else {
            style = (0, _domFns.createCSSTransform)(transformOpts, positionOffset);
          }
          var className = (0, _clsx2.default)(children.props.className || "", defaultClassName, (_clsx = {}, _defineProperty(_clsx, defaultClassNameDragging, this.state.dragging), _defineProperty(_clsx, defaultClassNameDragged, this.state.dragged), _clsx));
          return /* @__PURE__ */ React4.createElement(_DraggableCore.default, _extends({}, draggableCoreProps, {
            onStart: this.onDragStart,
            onDrag: this.onDrag,
            onStop: this.onDragStop
          }), /* @__PURE__ */ React4.cloneElement(React4.Children.only(children), {
            className,
            style: _objectSpread(_objectSpread({}, children.props.style), style),
            transform: svgTransform
          }));
        }, "render")
      }], [{
        key: "getDerivedStateFromProps",
        value: /* @__PURE__ */ __name(function getDerivedStateFromProps(_ref, _ref2) {
          var position = _ref.position;
          var prevPropsPosition = _ref2.prevPropsPosition;
          if (position && (!prevPropsPosition || position.x !== prevPropsPosition.x || position.y !== prevPropsPosition.y)) {
            (0, _log.default)("Draggable: getDerivedStateFromProps %j", {
              position,
              prevPropsPosition
            });
            return {
              x: position.x,
              y: position.y,
              prevPropsPosition: _objectSpread({}, position)
            };
          }
          return null;
        }, "getDerivedStateFromProps")
      }]);
      return Draggable3;
    }(React4.Component);
    exports.default = Draggable2;
    _defineProperty(Draggable2, "displayName", "Draggable");
    _defineProperty(Draggable2, "propTypes", _objectSpread(_objectSpread({}, _DraggableCore.default.propTypes), {}, {
      axis: _propTypes.default.oneOf(["both", "x", "y", "none"]),
      bounds: _propTypes.default.oneOfType([_propTypes.default.shape({
        left: _propTypes.default.number,
        right: _propTypes.default.number,
        top: _propTypes.default.number,
        bottom: _propTypes.default.number
      }), _propTypes.default.string, _propTypes.default.oneOf([false])]),
      defaultClassName: _propTypes.default.string,
      defaultClassNameDragging: _propTypes.default.string,
      defaultClassNameDragged: _propTypes.default.string,
      defaultPosition: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
      }),
      positionOffset: _propTypes.default.shape({
        x: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),
        y: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
      }),
      position: _propTypes.default.shape({
        x: _propTypes.default.number,
        y: _propTypes.default.number
      }),
      className: _shims.dontSetMe,
      style: _shims.dontSetMe,
      transform: _shims.dontSetMe
    }));
    _defineProperty(Draggable2, "defaultProps", _objectSpread(_objectSpread({}, _DraggableCore.default.defaultProps), {}, {
      axis: "both",
      bounds: false,
      defaultClassName: "react-draggable",
      defaultClassNameDragging: "react-draggable-dragging",
      defaultClassNameDragged: "react-draggable-dragged",
      defaultPosition: {
        x: 0,
        y: 0
      },
      scale: 1
    }));
  }
});

// ../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/cjs.js
var require_cjs = __commonJS({
  "../../.yarn/__virtual__/react-draggable-virtual-7801c82329/0/global/cache/react-draggable-npm-4.4.4-f0b7a5c546-9.zip/node_modules/react-draggable/build/cjs/cjs.js"(exports, module) {
    "use strict";
    init_define_process();
    var _require = require_Draggable();
    var Draggable2 = _require.default;
    var DraggableCore = _require.DraggableCore;
    module.exports = Draggable2;
    module.exports.default = Draggable2;
    module.exports.DraggableCore = DraggableCore;
  }
});

// ../../.yarn/global/cache/fast-memoize-npm-2.5.2-f42a7c6940-9.zip/node_modules/fast-memoize/src/index.js
var require_src = __commonJS({
  "../../.yarn/global/cache/fast-memoize-npm-2.5.2-f42a7c6940-9.zip/node_modules/fast-memoize/src/index.js"(exports, module) {
    init_define_process();
    function memoize2(fn, options) {
      var cache = options && options.cache ? options.cache : cacheDefault;
      var serializer = options && options.serializer ? options.serializer : serializerDefault;
      var strategy = options && options.strategy ? options.strategy : strategyDefault;
      return strategy(fn, {
        cache,
        serializer
      });
    }
    __name(memoize2, "memoize");
    function isPrimitive(value) {
      return value == null || typeof value === "number" || typeof value === "boolean";
    }
    __name(isPrimitive, "isPrimitive");
    function monadic(fn, cache, serializer, arg) {
      var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
      var computedValue = cache.get(cacheKey);
      if (typeof computedValue === "undefined") {
        computedValue = fn.call(this, arg);
        cache.set(cacheKey, computedValue);
      }
      return computedValue;
    }
    __name(monadic, "monadic");
    function variadic(fn, cache, serializer) {
      var args = Array.prototype.slice.call(arguments, 3);
      var cacheKey = serializer(args);
      var computedValue = cache.get(cacheKey);
      if (typeof computedValue === "undefined") {
        computedValue = fn.apply(this, args);
        cache.set(cacheKey, computedValue);
      }
      return computedValue;
    }
    __name(variadic, "variadic");
    function assemble(fn, context, strategy, cache, serialize) {
      return strategy.bind(
        context,
        fn,
        cache,
        serialize
      );
    }
    __name(assemble, "assemble");
    function strategyDefault(fn, options) {
      var strategy = fn.length === 1 ? monadic : variadic;
      return assemble(
        fn,
        this,
        strategy,
        options.cache.create(),
        options.serializer
      );
    }
    __name(strategyDefault, "strategyDefault");
    function strategyVariadic(fn, options) {
      var strategy = variadic;
      return assemble(
        fn,
        this,
        strategy,
        options.cache.create(),
        options.serializer
      );
    }
    __name(strategyVariadic, "strategyVariadic");
    function strategyMonadic(fn, options) {
      var strategy = monadic;
      return assemble(
        fn,
        this,
        strategy,
        options.cache.create(),
        options.serializer
      );
    }
    __name(strategyMonadic, "strategyMonadic");
    function serializerDefault() {
      return JSON.stringify(arguments);
    }
    __name(serializerDefault, "serializerDefault");
    function ObjectWithoutPrototypeCache() {
      this.cache = /* @__PURE__ */ Object.create(null);
    }
    __name(ObjectWithoutPrototypeCache, "ObjectWithoutPrototypeCache");
    ObjectWithoutPrototypeCache.prototype.has = function(key) {
      return key in this.cache;
    };
    ObjectWithoutPrototypeCache.prototype.get = function(key) {
      return this.cache[key];
    };
    ObjectWithoutPrototypeCache.prototype.set = function(key, value) {
      this.cache[key] = value;
    };
    var cacheDefault = {
      create: /* @__PURE__ */ __name(function create() {
        return new ObjectWithoutPrototypeCache();
      }, "create")
    };
    module.exports = memoize2;
    module.exports.strategies = {
      variadic: strategyVariadic,
      monadic: strategyMonadic
    };
  }
});

// ../../.yarn/global/cache/prettier-npm-2.8.0-746e3df53e-9.zip/node_modules/prettier/parser-babel.js
var require_parser_babel = __commonJS({
  "../../.yarn/global/cache/prettier-npm-2.8.0-746e3df53e-9.zip/node_modules/prettier/parser-babel.js"(exports, module) {
    init_define_process();
    (function(e2) {
      if (typeof exports == "object" && typeof module == "object")
        module.exports = e2();
      else if (typeof define == "function" && define.amd)
        define(e2);
      else {
        var i2 = typeof globalThis < "u" ? globalThis : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : this || {};
        i2.prettierPlugins = i2.prettierPlugins || {}, i2.prettierPlugins.babel = e2();
      }
    })(function() {
      "use strict";
      var C2 = /* @__PURE__ */ __name((l2, u2) => () => (u2 || l2((u2 = { exports: {} }).exports, u2), u2.exports), "C");
      var W2 = C2((Hd, si) => {
        var vt = /* @__PURE__ */ __name(function(l2) {
          return l2 && l2.Math == Math && l2;
        }, "vt");
        si.exports = vt(typeof globalThis == "object" && globalThis) || vt(typeof window == "object" && window) || vt(typeof self == "object" && self) || vt(typeof globalThis == "object" && globalThis) || function() {
          return this;
        }() || Function("return this")();
      });
      var ge = C2(($d, ri) => {
        ri.exports = function(l2) {
          try {
            return !!l2();
          } catch {
            return true;
          }
        };
      });
      var De = C2((zd, ii) => {
        var uh = ge();
        ii.exports = !uh(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var Et = C2((Vd, ai) => {
        var ch = ge();
        ai.exports = !ch(function() {
          var l2 = function() {
          }.bind();
          return typeof l2 != "function" || l2.hasOwnProperty("prototype");
        });
      });
      var bt = C2((Kd, ni) => {
        var ph = Et(), Ct = Function.prototype.call;
        ni.exports = ph ? Ct.bind(Ct) : function() {
          return Ct.apply(Ct, arguments);
        };
      });
      var ui = C2((hi) => {
        "use strict";
        var oi = {}.propertyIsEnumerable, li = Object.getOwnPropertyDescriptor, dh = li && !oi.call({ 1: 2 }, 1);
        hi.f = dh ? function(u2) {
          var d2 = li(this, u2);
          return !!d2 && d2.enumerable;
        } : oi;
      });
      var xs = C2((Gd, ci) => {
        ci.exports = function(l2, u2) {
          return { enumerable: !(l2 & 1), configurable: !(l2 & 2), writable: !(l2 & 4), value: u2 };
        };
      });
      var ne = C2((Jd, fi) => {
        var pi = Et(), di = Function.prototype, fh = di.bind, gs = di.call, mh = pi && fh.bind(gs, gs);
        fi.exports = pi ? function(l2) {
          return l2 && mh(l2);
        } : function(l2) {
          return l2 && function() {
            return gs.apply(l2, arguments);
          };
        };
      });
      var St = C2((Xd, yi) => {
        var mi = ne(), yh = mi({}.toString), xh = mi("".slice);
        yi.exports = function(l2) {
          return xh(yh(l2), 8, -1);
        };
      });
      var gi = C2((Yd, xi) => {
        var gh = W2(), Ph = ne(), Ah = ge(), Th = St(), Ps = gh.Object, vh = Ph("".split);
        xi.exports = Ah(function() {
          return !Ps("z").propertyIsEnumerable(0);
        }) ? function(l2) {
          return Th(l2) == "String" ? vh(l2, "") : Ps(l2);
        } : Ps;
      });
      var As = C2((Qd, Pi) => {
        var Eh = W2(), Ch = Eh.TypeError;
        Pi.exports = function(l2) {
          if (l2 == null)
            throw Ch("Can't call method on " + l2);
          return l2;
        };
      });
      var wt = C2((Zd, Ai) => {
        var bh = gi(), Sh = As();
        Ai.exports = function(l2) {
          return bh(Sh(l2));
        };
      });
      var oe = C2((ef, Ti) => {
        Ti.exports = function(l2) {
          return typeof l2 == "function";
        };
      });
      var Fe = C2((tf, vi) => {
        var wh = oe();
        vi.exports = function(l2) {
          return typeof l2 == "object" ? l2 !== null : wh(l2);
        };
      });
      var tt = C2((sf, Ei) => {
        var Ts = W2(), Ih = oe(), Nh = /* @__PURE__ */ __name(function(l2) {
          return Ih(l2) ? l2 : void 0;
        }, "Nh");
        Ei.exports = function(l2, u2) {
          return arguments.length < 2 ? Nh(Ts[l2]) : Ts[l2] && Ts[l2][u2];
        };
      });
      var bi = C2((rf, Ci) => {
        var kh = ne();
        Ci.exports = kh({}.isPrototypeOf);
      });
      var wi = C2((af, Si) => {
        var Dh = tt();
        Si.exports = Dh("navigator", "userAgent") || "";
      });
      var Oi = C2((nf, Li) => {
        var Fi = W2(), vs = wi(), Ii = Fi.process, Ni = Fi.Deno, ki = Ii && Ii.versions || Ni && Ni.version, Di = ki && ki.v8, le, It;
        Di && (le = Di.split("."), It = le[0] > 0 && le[0] < 4 ? 1 : +(le[0] + le[1]));
        !It && vs && (le = vs.match(/Edge\/(\d+)/), (!le || le[1] >= 74) && (le = vs.match(/Chrome\/(\d+)/), le && (It = +le[1])));
        Li.exports = It;
      });
      var Es = C2((of, Bi) => {
        var Mi = Oi(), Fh = ge();
        Bi.exports = !!Object.getOwnPropertySymbols && !Fh(function() {
          var l2 = Symbol();
          return !String(l2) || !(Object(l2) instanceof Symbol) || !Symbol.sham && Mi && Mi < 41;
        });
      });
      var Cs = C2((lf, _i) => {
        var Lh = Es();
        _i.exports = Lh && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var bs = C2((hf, Ri) => {
        var Oh = W2(), Mh = tt(), Bh = oe(), _h = bi(), Rh = Cs(), jh = Oh.Object;
        Ri.exports = Rh ? function(l2) {
          return typeof l2 == "symbol";
        } : function(l2) {
          var u2 = Mh("Symbol");
          return Bh(u2) && _h(u2.prototype, jh(l2));
        };
      });
      var qi = C2((uf, ji) => {
        var qh = W2(), Uh = qh.String;
        ji.exports = function(l2) {
          try {
            return Uh(l2);
          } catch {
            return "Object";
          }
        };
      });
      var Nt = C2((cf, Ui) => {
        var Hh = W2(), $h = oe(), zh = qi(), Vh = Hh.TypeError;
        Ui.exports = function(l2) {
          if ($h(l2))
            return l2;
          throw Vh(zh(l2) + " is not a function");
        };
      });
      var $i = C2((pf, Hi) => {
        var Kh = Nt();
        Hi.exports = function(l2, u2) {
          var d2 = l2[u2];
          return d2 == null ? void 0 : Kh(d2);
        };
      });
      var Vi = C2((df, zi) => {
        var Wh = W2(), Ss = bt(), ws2 = oe(), Is = Fe(), Gh = Wh.TypeError;
        zi.exports = function(l2, u2) {
          var d2, f2;
          if (u2 === "string" && ws2(d2 = l2.toString) && !Is(f2 = Ss(d2, l2)) || ws2(d2 = l2.valueOf) && !Is(f2 = Ss(d2, l2)) || u2 !== "string" && ws2(d2 = l2.toString) && !Is(f2 = Ss(d2, l2)))
            return f2;
          throw Gh("Can't convert object to primitive value");
        };
      });
      var Wi = C2((ff, Ki) => {
        Ki.exports = false;
      });
      var kt = C2((mf, Ji) => {
        var Gi = W2(), Jh = Object.defineProperty;
        Ji.exports = function(l2, u2) {
          try {
            Jh(Gi, l2, { value: u2, configurable: true, writable: true });
          } catch {
            Gi[l2] = u2;
          }
          return u2;
        };
      });
      var Dt = C2((yf, Yi) => {
        var Xh = W2(), Yh = kt(), Xi = "__core-js_shared__", Qh = Xh[Xi] || Yh(Xi, {});
        Yi.exports = Qh;
      });
      var Ns = C2((xf, Zi) => {
        var Zh = Wi(), Qi = Dt();
        (Zi.exports = function(l2, u2) {
          return Qi[l2] || (Qi[l2] = u2 !== void 0 ? u2 : {});
        })("versions", []).push({ version: "3.22.2", mode: Zh ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var ks = C2((gf, ea) => {
        var eu = W2(), tu = As(), su = eu.Object;
        ea.exports = function(l2) {
          return su(tu(l2));
        };
      });
      var Ce = C2((Pf, ta) => {
        var ru = ne(), iu = ks(), au = ru({}.hasOwnProperty);
        ta.exports = Object.hasOwn || function(u2, d2) {
          return au(iu(u2), d2);
        };
      });
      var Ds = C2((Af, sa) => {
        var nu = ne(), ou = 0, lu = Math.random(), hu = nu(1 .toString);
        sa.exports = function(l2) {
          return "Symbol(" + (l2 === void 0 ? "" : l2) + ")_" + hu(++ou + lu, 36);
        };
      });
      var st = C2((Tf, oa) => {
        var uu = W2(), cu = Ns(), ra = Ce(), pu = Ds(), ia = Es(), na = Cs(), ze = cu("wks"), Le = uu.Symbol, aa = Le && Le.for, du = na ? Le : Le && Le.withoutSetter || pu;
        oa.exports = function(l2) {
          if (!ra(ze, l2) || !(ia || typeof ze[l2] == "string")) {
            var u2 = "Symbol." + l2;
            ia && ra(Le, l2) ? ze[l2] = Le[l2] : na && aa ? ze[l2] = aa(u2) : ze[l2] = du(u2);
          }
          return ze[l2];
        };
      });
      var ca = C2((vf, ua) => {
        var fu = W2(), mu = bt(), la = Fe(), ha = bs(), yu = $i(), xu = Vi(), gu = st(), Pu = fu.TypeError, Au = gu("toPrimitive");
        ua.exports = function(l2, u2) {
          if (!la(l2) || ha(l2))
            return l2;
          var d2 = yu(l2, Au), f2;
          if (d2) {
            if (u2 === void 0 && (u2 = "default"), f2 = mu(d2, l2, u2), !la(f2) || ha(f2))
              return f2;
            throw Pu("Can't convert object to primitive value");
          }
          return u2 === void 0 && (u2 = "number"), xu(l2, u2);
        };
      });
      var Fs = C2((Ef, pa) => {
        var Tu = ca(), vu = bs();
        pa.exports = function(l2) {
          var u2 = Tu(l2, "string");
          return vu(u2) ? u2 : u2 + "";
        };
      });
      var ma = C2((Cf, fa) => {
        var Eu = W2(), da = Fe(), Ls = Eu.document, Cu = da(Ls) && da(Ls.createElement);
        fa.exports = function(l2) {
          return Cu ? Ls.createElement(l2) : {};
        };
      });
      var Os = C2((bf, ya) => {
        var bu = De(), Su = ge(), wu = ma();
        ya.exports = !bu && !Su(function() {
          return Object.defineProperty(wu("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var Ms = C2((ga) => {
        var Iu = De(), Nu = bt(), ku = ui(), Du = xs(), Fu = wt(), Lu = Fs(), Ou = Ce(), Mu = Os(), xa = Object.getOwnPropertyDescriptor;
        ga.f = Iu ? xa : function(u2, d2) {
          if (u2 = Fu(u2), d2 = Lu(d2), Mu)
            try {
              return xa(u2, d2);
            } catch {
            }
          if (Ou(u2, d2))
            return Du(!Nu(ku.f, u2, d2), u2[d2]);
        };
      });
      var Aa = C2((wf, Pa) => {
        var Bu = De(), _u = ge();
        Pa.exports = Bu && _u(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Bs = C2((If, va) => {
        var Ta = W2(), Ru = Fe(), ju = Ta.String, qu = Ta.TypeError;
        va.exports = function(l2) {
          if (Ru(l2))
            return l2;
          throw qu(ju(l2) + " is not an object");
        };
      });
      var Us = C2((Ca) => {
        var Uu = W2(), Hu = De(), $u = Os(), zu = Aa(), Ft = Bs(), Ea = Fs(), Vu = Uu.TypeError, _s = Object.defineProperty, Ku = Object.getOwnPropertyDescriptor, Rs = "enumerable", js = "configurable", qs = "writable";
        Ca.f = Hu ? zu ? function(u2, d2, f2) {
          if (Ft(u2), d2 = Ea(d2), Ft(f2), typeof u2 == "function" && d2 === "prototype" && "value" in f2 && qs in f2 && !f2[qs]) {
            var y2 = Ku(u2, d2);
            y2 && y2[qs] && (u2[d2] = f2.value, f2 = { configurable: js in f2 ? f2[js] : y2[js], enumerable: Rs in f2 ? f2[Rs] : y2[Rs], writable: false });
          }
          return _s(u2, d2, f2);
        } : _s : function(u2, d2, f2) {
          if (Ft(u2), d2 = Ea(d2), Ft(f2), $u)
            try {
              return _s(u2, d2, f2);
            } catch {
            }
          if ("get" in f2 || "set" in f2)
            throw Vu("Accessors not supported");
          return "value" in f2 && (u2[d2] = f2.value), u2;
        };
      });
      var Lt = C2((kf, ba) => {
        var Wu = De(), Gu = Us(), Ju = xs();
        ba.exports = Wu ? function(l2, u2, d2) {
          return Gu.f(l2, u2, Ju(1, d2));
        } : function(l2, u2, d2) {
          return l2[u2] = d2, l2;
        };
      });
      var Ot = C2((Df, Sa) => {
        var Xu = ne(), Yu = oe(), Hs = Dt(), Qu = Xu(Function.toString);
        Yu(Hs.inspectSource) || (Hs.inspectSource = function(l2) {
          return Qu(l2);
        });
        Sa.exports = Hs.inspectSource;
      });
      var Na = C2((Ff, Ia) => {
        var Zu = W2(), ec = oe(), tc = Ot(), wa = Zu.WeakMap;
        Ia.exports = ec(wa) && /native code/.test(tc(wa));
      });
      var Fa = C2((Lf, Da) => {
        var sc = Ns(), rc = Ds(), ka = sc("keys");
        Da.exports = function(l2) {
          return ka[l2] || (ka[l2] = rc(l2));
        };
      });
      var $s = C2((Of, La) => {
        La.exports = {};
      });
      var ja = C2((Mf, Ra) => {
        var ic = Na(), _a = W2(), zs = ne(), ac = Fe(), nc = Lt(), Vs = Ce(), Ks = Dt(), oc = Fa(), lc = $s(), Oa = "Object already initialized", Gs = _a.TypeError, hc = _a.WeakMap, Mt, rt, Bt, uc = /* @__PURE__ */ __name(function(l2) {
          return Bt(l2) ? rt(l2) : Mt(l2, {});
        }, "uc"), cc = /* @__PURE__ */ __name(function(l2) {
          return function(u2) {
            var d2;
            if (!ac(u2) || (d2 = rt(u2)).type !== l2)
              throw Gs("Incompatible receiver, " + l2 + " required");
            return d2;
          };
        }, "cc");
        ic || Ks.state ? (be = Ks.state || (Ks.state = new hc()), Ma = zs(be.get), Ws = zs(be.has), Ba = zs(be.set), Mt = /* @__PURE__ */ __name(function(l2, u2) {
          if (Ws(be, l2))
            throw new Gs(Oa);
          return u2.facade = l2, Ba(be, l2, u2), u2;
        }, "Mt"), rt = /* @__PURE__ */ __name(function(l2) {
          return Ma(be, l2) || {};
        }, "rt"), Bt = /* @__PURE__ */ __name(function(l2) {
          return Ws(be, l2);
        }, "Bt")) : (Oe = oc("state"), lc[Oe] = true, Mt = /* @__PURE__ */ __name(function(l2, u2) {
          if (Vs(l2, Oe))
            throw new Gs(Oa);
          return u2.facade = l2, nc(l2, Oe, u2), u2;
        }, "Mt"), rt = /* @__PURE__ */ __name(function(l2) {
          return Vs(l2, Oe) ? l2[Oe] : {};
        }, "rt"), Bt = /* @__PURE__ */ __name(function(l2) {
          return Vs(l2, Oe);
        }, "Bt"));
        var be, Ma, Ws, Ba, Oe;
        Ra.exports = { set: Mt, get: rt, has: Bt, enforce: uc, getterFor: cc };
      });
      var Ha = C2((Bf, Ua) => {
        var Js = De(), pc = Ce(), qa = Function.prototype, dc = Js && Object.getOwnPropertyDescriptor, Xs = pc(qa, "name"), fc = Xs && function() {
        }.name === "something", mc = Xs && (!Js || Js && dc(qa, "name").configurable);
        Ua.exports = { EXISTS: Xs, PROPER: fc, CONFIGURABLE: mc };
      });
      var Wa = C2((_f, Ka) => {
        var yc = W2(), $a = oe(), xc = Ce(), za = Lt(), gc = kt(), Pc = Ot(), Va = ja(), Ac = Ha().CONFIGURABLE, Tc = Va.get, vc = Va.enforce, Ec = String(String).split("String");
        (Ka.exports = function(l2, u2, d2, f2) {
          var y2 = f2 ? !!f2.unsafe : false, A2 = f2 ? !!f2.enumerable : false, g2 = f2 ? !!f2.noTargetGet : false, T2 = f2 && f2.name !== void 0 ? f2.name : u2, S2;
          if ($a(d2) && (String(T2).slice(0, 7) === "Symbol(" && (T2 = "[" + String(T2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!xc(d2, "name") || Ac && d2.name !== T2) && za(d2, "name", T2), S2 = vc(d2), S2.source || (S2.source = Ec.join(typeof T2 == "string" ? T2 : ""))), l2 === yc) {
            A2 ? l2[u2] = d2 : gc(u2, d2);
            return;
          } else
            y2 ? !g2 && l2[u2] && (A2 = true) : delete l2[u2];
          A2 ? l2[u2] = d2 : za(l2, u2, d2);
        })(Function.prototype, "toString", function() {
          return $a(this) && Tc(this).source || Pc(this);
        });
      });
      var Ys = C2((Rf, Ga) => {
        var Cc = Math.ceil, bc2 = Math.floor;
        Ga.exports = function(l2) {
          var u2 = +l2;
          return u2 !== u2 || u2 === 0 ? 0 : (u2 > 0 ? bc2 : Cc)(u2);
        };
      });
      var Xa = C2((jf, Ja) => {
        var Sc = Ys(), wc = Math.max, Ic = Math.min;
        Ja.exports = function(l2, u2) {
          var d2 = Sc(l2);
          return d2 < 0 ? wc(d2 + u2, 0) : Ic(d2, u2);
        };
      });
      var Qa = C2((qf, Ya) => {
        var Nc = Ys(), kc = Math.min;
        Ya.exports = function(l2) {
          return l2 > 0 ? kc(Nc(l2), 9007199254740991) : 0;
        };
      });
      var _t = C2((Uf, Za) => {
        var Dc = Qa();
        Za.exports = function(l2) {
          return Dc(l2.length);
        };
      });
      var sn = C2((Hf, tn) => {
        var Fc = wt(), Lc = Xa(), Oc = _t(), en = /* @__PURE__ */ __name(function(l2) {
          return function(u2, d2, f2) {
            var y2 = Fc(u2), A2 = Oc(y2), g2 = Lc(f2, A2), T2;
            if (l2 && d2 != d2) {
              for (; A2 > g2; )
                if (T2 = y2[g2++], T2 != T2)
                  return true;
            } else
              for (; A2 > g2; g2++)
                if ((l2 || g2 in y2) && y2[g2] === d2)
                  return l2 || g2 || 0;
            return !l2 && -1;
          };
        }, "en");
        tn.exports = { includes: en(true), indexOf: en(false) };
      });
      var nn = C2(($f, an) => {
        var Mc = ne(), Qs = Ce(), Bc = wt(), _c = sn().indexOf, Rc = $s(), rn = Mc([].push);
        an.exports = function(l2, u2) {
          var d2 = Bc(l2), f2 = 0, y2 = [], A2;
          for (A2 in d2)
            !Qs(Rc, A2) && Qs(d2, A2) && rn(y2, A2);
          for (; u2.length > f2; )
            Qs(d2, A2 = u2[f2++]) && (~_c(y2, A2) || rn(y2, A2));
          return y2;
        };
      });
      var ln = C2((zf, on) => {
        on.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var un = C2((hn) => {
        var jc = nn(), qc = ln(), Uc = qc.concat("length", "prototype");
        hn.f = Object.getOwnPropertyNames || function(u2) {
          return jc(u2, Uc);
        };
      });
      var pn = C2((cn) => {
        cn.f = Object.getOwnPropertySymbols;
      });
      var fn = C2((Wf, dn) => {
        var Hc = tt(), $c = ne(), zc = un(), Vc = pn(), Kc = Bs(), Wc = $c([].concat);
        dn.exports = Hc("Reflect", "ownKeys") || function(u2) {
          var d2 = zc.f(Kc(u2)), f2 = Vc.f;
          return f2 ? Wc(d2, f2(u2)) : d2;
        };
      });
      var xn = C2((Gf, yn) => {
        var mn = Ce(), Gc = fn(), Jc = Ms(), Xc = Us();
        yn.exports = function(l2, u2, d2) {
          for (var f2 = Gc(u2), y2 = Xc.f, A2 = Jc.f, g2 = 0; g2 < f2.length; g2++) {
            var T2 = f2[g2];
            !mn(l2, T2) && !(d2 && mn(d2, T2)) && y2(l2, T2, A2(u2, T2));
          }
        };
      });
      var Pn = C2((Jf, gn) => {
        var Yc = ge(), Qc = oe(), Zc = /#|\.prototype\./, it = /* @__PURE__ */ __name(function(l2, u2) {
          var d2 = tp[ep(l2)];
          return d2 == rp ? true : d2 == sp ? false : Qc(u2) ? Yc(u2) : !!u2;
        }, "it"), ep = it.normalize = function(l2) {
          return String(l2).replace(Zc, ".").toLowerCase();
        }, tp = it.data = {}, sp = it.NATIVE = "N", rp = it.POLYFILL = "P";
        gn.exports = it;
      });
      var er = C2((Xf, An) => {
        var Zs = W2(), ip = Ms().f, ap = Lt(), np = Wa(), op = kt(), lp = xn(), hp = Pn();
        An.exports = function(l2, u2) {
          var d2 = l2.target, f2 = l2.global, y2 = l2.stat, A2, g2, T2, S2, F, I;
          if (f2 ? g2 = Zs : y2 ? g2 = Zs[d2] || op(d2, {}) : g2 = (Zs[d2] || {}).prototype, g2)
            for (T2 in u2) {
              if (F = u2[T2], l2.noTargetGet ? (I = ip(g2, T2), S2 = I && I.value) : S2 = g2[T2], A2 = hp(f2 ? T2 : d2 + (y2 ? "." : "#") + T2, l2.forced), !A2 && S2 !== void 0) {
                if (typeof F == typeof S2)
                  continue;
                lp(F, S2);
              }
              (l2.sham || S2 && S2.sham) && ap(F, "sham", true), np(g2, T2, F, l2);
            }
        };
      });
      var Tn = C2(() => {
        var up = er(), cp = W2();
        up({ global: true }, { globalThis: cp });
      });
      var vn = C2(() => {
        Tn();
      });
      var tr = C2((tm, En) => {
        var pp = St();
        En.exports = Array.isArray || function(u2) {
          return pp(u2) == "Array";
        };
      });
      var Sn = C2((sm, bn) => {
        var Cn = ne(), dp = Nt(), fp = Et(), mp = Cn(Cn.bind);
        bn.exports = function(l2, u2) {
          return dp(l2), u2 === void 0 ? l2 : fp ? mp(l2, u2) : function() {
            return l2.apply(u2, arguments);
          };
        };
      });
      var Nn = C2((rm, In) => {
        "use strict";
        var yp = W2(), xp = tr(), gp = _t(), Pp = Sn(), Ap = yp.TypeError, wn = /* @__PURE__ */ __name(function(l2, u2, d2, f2, y2, A2, g2, T2) {
          for (var S2 = y2, F = 0, I = g2 ? Pp(g2, T2) : false, E2, L2; F < f2; ) {
            if (F in d2) {
              if (E2 = I ? I(d2[F], F, u2) : d2[F], A2 > 0 && xp(E2))
                L2 = gp(E2), S2 = wn(l2, u2, E2, L2, S2, A2 - 1) - 1;
              else {
                if (S2 >= 9007199254740991)
                  throw Ap("Exceed the acceptable array length");
                l2[S2] = E2;
              }
              S2++;
            }
            F++;
          }
          return S2;
        }, "wn");
        In.exports = wn;
      });
      var Fn = C2((im, Dn) => {
        var Tp = st(), vp = Tp("toStringTag"), kn = {};
        kn[vp] = "z";
        Dn.exports = String(kn) === "[object z]";
      });
      var On = C2((am, Ln) => {
        var Ep = W2(), Cp = Fn(), bp = oe(), Rt = St(), Sp = st(), wp = Sp("toStringTag"), Ip = Ep.Object, Np = Rt(function() {
          return arguments;
        }()) == "Arguments", kp = /* @__PURE__ */ __name(function(l2, u2) {
          try {
            return l2[u2];
          } catch {
          }
        }, "kp");
        Ln.exports = Cp ? Rt : function(l2) {
          var u2, d2, f2;
          return l2 === void 0 ? "Undefined" : l2 === null ? "Null" : typeof (d2 = kp(u2 = Ip(l2), wp)) == "string" ? d2 : Np ? Rt(u2) : (f2 = Rt(u2)) == "Object" && bp(u2.callee) ? "Arguments" : f2;
        };
      });
      var qn = C2((nm, jn) => {
        var Dp = ne(), Fp = ge(), Mn = oe(), Lp = On(), Op = tt(), Mp = Ot(), Bn = /* @__PURE__ */ __name(function() {
        }, "Bn"), Bp = [], _n = Op("Reflect", "construct"), sr = /^\s*(?:class|function)\b/, _p = Dp(sr.exec), Rp = !sr.exec(Bn), at = /* @__PURE__ */ __name(function(u2) {
          if (!Mn(u2))
            return false;
          try {
            return _n(Bn, Bp, u2), true;
          } catch {
            return false;
          }
        }, "at"), Rn = /* @__PURE__ */ __name(function(u2) {
          if (!Mn(u2))
            return false;
          switch (Lp(u2)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Rp || !!_p(sr, Mp(u2));
          } catch {
            return true;
          }
        }, "Rn");
        Rn.sham = true;
        jn.exports = !_n || Fp(function() {
          var l2;
          return at(at.call) || !at(Object) || !at(function() {
            l2 = true;
          }) || l2;
        }) ? Rn : at;
      });
      var zn = C2((om, $n) => {
        var jp = W2(), Un = tr(), qp = qn(), Up = Fe(), Hp = st(), $p = Hp("species"), Hn = jp.Array;
        $n.exports = function(l2) {
          var u2;
          return Un(l2) && (u2 = l2.constructor, qp(u2) && (u2 === Hn || Un(u2.prototype)) ? u2 = void 0 : Up(u2) && (u2 = u2[$p], u2 === null && (u2 = void 0))), u2 === void 0 ? Hn : u2;
        };
      });
      var Kn = C2((lm, Vn) => {
        var zp = zn();
        Vn.exports = function(l2, u2) {
          return new (zp(l2))(u2 === 0 ? 0 : u2);
        };
      });
      var Wn = C2(() => {
        "use strict";
        var Vp = er(), Kp = Nn(), Wp = Nt(), Gp = ks(), Jp = _t(), Xp = Kn();
        Vp({ target: "Array", proto: true }, { flatMap: function(u2) {
          var d2 = Gp(this), f2 = Jp(d2), y2;
          return Wp(u2), y2 = Xp(d2, 0), y2.length = Kp(y2, d2, d2, f2, 0, 1, u2, arguments.length > 1 ? arguments[1] : void 0), y2;
        } });
      });
      var qd = C2((xm, Eo) => {
        vn();
        Wn();
        var nr = Object.defineProperty, Yp = Object.getOwnPropertyDescriptor, or = Object.getOwnPropertyNames, Qp = Object.prototype.hasOwnProperty, Zn = /* @__PURE__ */ __name((l2, u2) => function() {
          return l2 && (u2 = (0, l2[or(l2)[0]])(l2 = 0)), u2;
        }, "Zn"), K = /* @__PURE__ */ __name((l2, u2) => function() {
          return u2 || (0, l2[or(l2)[0]])((u2 = { exports: {} }).exports, u2), u2.exports;
        }, "K"), Zp = /* @__PURE__ */ __name((l2, u2) => {
          for (var d2 in u2)
            nr(l2, d2, { get: u2[d2], enumerable: true });
        }, "Zp"), ed = /* @__PURE__ */ __name((l2, u2, d2, f2) => {
          if (u2 && typeof u2 == "object" || typeof u2 == "function")
            for (let y2 of or(u2))
              !Qp.call(l2, y2) && y2 !== d2 && nr(l2, y2, { get: () => u2[y2], enumerable: !(f2 = Yp(u2, y2)) || f2.enumerable });
          return l2;
        }, "ed"), td = /* @__PURE__ */ __name((l2) => ed(nr({}, "__esModule", { value: true }), l2), "td"), V = Zn({ "<define:process>"() {
        } }), sd = K({ "src/utils/try-combinations.js"(l2, u2) {
          "use strict";
          V();
          function d2() {
            let f2;
            for (var y2 = arguments.length, A2 = new Array(y2), g2 = 0; g2 < y2; g2++)
              A2[g2] = arguments[g2];
            for (let [T2, S2] of A2.entries())
              try {
                return { result: S2() };
              } catch (F) {
                T2 === 0 && (f2 = F);
              }
            return { error: f2 };
          }
          __name(d2, "d");
          u2.exports = d2;
        } }), eo = K({ "src/language-js/utils/get-shebang.js"(l2, u2) {
          "use strict";
          V();
          function d2(f2) {
            if (!f2.startsWith("#!"))
              return "";
            let y2 = f2.indexOf(`
`);
            return y2 === -1 ? f2 : f2.slice(0, y2);
          }
          __name(d2, "d");
          u2.exports = d2;
        } }), rd = K({ "src/utils/text/skip-inline-comment.js"(l2, u2) {
          "use strict";
          V();
          function d2(f2, y2) {
            if (y2 === false)
              return false;
            if (f2.charAt(y2) === "/" && f2.charAt(y2 + 1) === "*") {
              for (let A2 = y2 + 2; A2 < f2.length; ++A2)
                if (f2.charAt(A2) === "*" && f2.charAt(A2 + 1) === "/")
                  return A2 + 2;
            }
            return y2;
          }
          __name(d2, "d");
          u2.exports = d2;
        } }), id = K({ "src/utils/text/skip-newline.js"(l2, u2) {
          "use strict";
          V();
          function d2(f2, y2, A2) {
            let g2 = A2 && A2.backwards;
            if (y2 === false)
              return false;
            let T2 = f2.charAt(y2);
            if (g2) {
              if (f2.charAt(y2 - 1) === "\r" && T2 === `
`)
                return y2 - 2;
              if (T2 === `
` || T2 === "\r" || T2 === "\u2028" || T2 === "\u2029")
                return y2 - 1;
            } else {
              if (T2 === "\r" && f2.charAt(y2 + 1) === `
`)
                return y2 + 2;
              if (T2 === `
` || T2 === "\r" || T2 === "\u2028" || T2 === "\u2029")
                return y2 + 1;
            }
            return y2;
          }
          __name(d2, "d");
          u2.exports = d2;
        } }), to = K({ "src/utils/text/skip.js"(l2, u2) {
          "use strict";
          V();
          function d2(T2) {
            return (S2, F, I) => {
              let E2 = I && I.backwards;
              if (F === false)
                return false;
              let { length: L2 } = S2, j2 = F;
              for (; j2 >= 0 && j2 < L2; ) {
                let k2 = S2.charAt(j2);
                if (T2 instanceof RegExp) {
                  if (!T2.test(k2))
                    return j2;
                } else if (!T2.includes(k2))
                  return j2;
                E2 ? j2-- : j2++;
              }
              return j2 === -1 || j2 === L2 ? j2 : false;
            };
          }
          __name(d2, "d");
          var f2 = d2(/\s/), y2 = d2(" 	"), A2 = d2(",; 	"), g2 = d2(/[^\n\r]/);
          u2.exports = { skipWhitespace: f2, skipSpaces: y2, skipToLineEnd: A2, skipEverythingButNewLine: g2 };
        } }), ad = K({ "src/utils/text/skip-trailing-comment.js"(l2, u2) {
          "use strict";
          V();
          var { skipEverythingButNewLine: d2 } = to();
          function f2(y2, A2) {
            return A2 === false ? false : y2.charAt(A2) === "/" && y2.charAt(A2 + 1) === "/" ? d2(y2, A2) : A2;
          }
          __name(f2, "f");
          u2.exports = f2;
        } }), nd = K({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(l2, u2) {
          "use strict";
          V();
          var d2 = rd(), f2 = id(), y2 = ad(), { skipSpaces: A2 } = to();
          function g2(T2, S2) {
            let F = null, I = S2;
            for (; I !== F; )
              F = I, I = A2(T2, I), I = d2(T2, I), I = y2(T2, I), I = f2(T2, I);
            return I;
          }
          __name(g2, "g");
          u2.exports = g2;
        } }), so = {};
        Zp(so, { EOL: () => ar, arch: () => od, cpus: () => ho, default: () => mo, endianness: () => ro, freemem: () => oo, getNetworkInterfaces: () => fo, hostname: () => io, loadavg: () => ao, networkInterfaces: () => po, platform: () => ld, release: () => co, tmpDir: () => rr, tmpdir: () => ir, totalmem: () => lo, type: () => uo, uptime: () => no });
        function ro() {
          if (typeof jt > "u") {
            var l2 = new ArrayBuffer(2), u2 = new Uint8Array(l2), d2 = new Uint16Array(l2);
            if (u2[0] = 1, u2[1] = 2, d2[0] === 258)
              jt = "BE";
            else if (d2[0] === 513)
              jt = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return jt;
        }
        __name(ro, "ro");
        function io() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        __name(io, "io");
        function ao() {
          return [];
        }
        __name(ao, "ao");
        function no() {
          return 0;
        }
        __name(no, "no");
        function oo() {
          return Number.MAX_VALUE;
        }
        __name(oo, "oo");
        function lo() {
          return Number.MAX_VALUE;
        }
        __name(lo, "lo");
        function ho() {
          return [];
        }
        __name(ho, "ho");
        function uo() {
          return "Browser";
        }
        __name(uo, "uo");
        function co() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        __name(co, "co");
        function po() {
        }
        __name(po, "po");
        function fo() {
        }
        __name(fo, "fo");
        function od() {
          return "javascript";
        }
        __name(od, "od");
        function ld() {
          return "browser";
        }
        __name(ld, "ld");
        function rr() {
          return "/tmp";
        }
        __name(rr, "rr");
        var jt, ir, ar, mo, hd = Zn({ "node-modules-polyfills:os"() {
          V(), ir = rr, ar = `
`, mo = { EOL: ar, tmpdir: ir, tmpDir: rr, networkInterfaces: po, getNetworkInterfaces: fo, release: co, type: uo, cpus: ho, totalmem: lo, freemem: oo, uptime: no, loadavg: ao, hostname: io, endianness: ro };
        } }), ud = K({ "node-modules-polyfills-commonjs:os"(l2, u2) {
          V();
          var d2 = (hd(), td(so));
          if (d2 && d2.default) {
            u2.exports = d2.default;
            for (let f2 in d2)
              u2.exports[f2] = d2[f2];
          } else
            d2 && (u2.exports = d2);
        } }), cd = K({ "node_modules/detect-newline/index.js"(l2, u2) {
          "use strict";
          V();
          var d2 = /* @__PURE__ */ __name((f2) => {
            if (typeof f2 != "string")
              throw new TypeError("Expected a string");
            let y2 = f2.match(/(?:\r?\n)/g) || [];
            if (y2.length === 0)
              return;
            let A2 = y2.filter((T2) => T2 === `\r
`).length, g2 = y2.length - A2;
            return A2 > g2 ? `\r
` : `
`;
          }, "d");
          u2.exports = d2, u2.exports.graceful = (f2) => typeof f2 == "string" && d2(f2) || `
`;
        } }), pd = K({ "node_modules/jest-docblock/build/index.js"(l2) {
          "use strict";
          V(), Object.defineProperty(l2, "__esModule", { value: true }), l2.extract = j2, l2.parse = z, l2.parseWithComments = G, l2.print = B, l2.strip = k2;
          function u2() {
            let h3 = ud();
            return u2 = /* @__PURE__ */ __name(function() {
              return h3;
            }, "u"), h3;
          }
          __name(u2, "u");
          function d2() {
            let h3 = f2(cd());
            return d2 = /* @__PURE__ */ __name(function() {
              return h3;
            }, "d"), h3;
          }
          __name(d2, "d");
          function f2(h3) {
            return h3 && h3.__esModule ? h3 : { default: h3 };
          }
          __name(f2, "f");
          var y2 = /\*\/$/, A2 = /^\/\*\*?/, g2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, T2 = /(^|\s+)\/\/([^\r\n]*)/g, S2 = /^(\r?\n)+/, F = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, I = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, E2 = /(\r?\n|^) *\* ?/g, L2 = [];
          function j2(h3) {
            let J = h3.match(g2);
            return J ? J[0].trimLeft() : "";
          }
          __name(j2, "j");
          function k2(h3) {
            let J = h3.match(g2);
            return J && J[0] ? h3.substring(J[0].length) : h3;
          }
          __name(k2, "k");
          function z(h3) {
            return G(h3).pragmas;
          }
          __name(z, "z");
          function G(h3) {
            let J = (0, d2().default)(h3) || u2().EOL;
            h3 = h3.replace(A2, "").replace(y2, "").replace(E2, "$1");
            let ae = "";
            for (; ae !== h3; )
              ae = h3, h3 = h3.replace(F, `${J}$1 $2${J}`);
            h3 = h3.replace(S2, "").trimRight();
            let Y = /* @__PURE__ */ Object.create(null), Me = h3.replace(I, "").replace(S2, "").trimRight(), ee;
            for (; ee = I.exec(h3); ) {
              let H = ee[2].replace(T2, "");
              typeof Y[ee[1]] == "string" || Array.isArray(Y[ee[1]]) ? Y[ee[1]] = L2.concat(Y[ee[1]], H) : Y[ee[1]] = H;
            }
            return { comments: Me, pragmas: Y };
          }
          __name(G, "G");
          function B(h3) {
            let { comments: J = "", pragmas: ae = {} } = h3, Y = (0, d2().default)(J) || u2().EOL, Me = "/**", ee = " *", H = " */", M2 = Object.keys(ae), v2 = M2.map((te) => _2(te, ae[te])).reduce((te, he) => te.concat(he), []).map((te) => `${ee} ${te}${Y}`).join("");
            if (!J) {
              if (M2.length === 0)
                return "";
              if (M2.length === 1 && !Array.isArray(ae[M2[0]])) {
                let te = ae[M2[0]];
                return `${Me} ${_2(M2[0], te)[0]}${H}`;
              }
            }
            let We = J.split(Y).map((te) => `${ee} ${te}`).join(Y) + Y;
            return Me + Y + (J ? We : "") + (J && M2.length ? ee + Y : "") + v2 + H;
          }
          __name(B, "B");
          function _2(h3, J) {
            return L2.concat(J).map((ae) => `@${h3} ${ae}`.trim());
          }
          __name(_2, "_");
        } }), dd = K({ "src/common/end-of-line.js"(l2, u2) {
          "use strict";
          V();
          function d2(g2) {
            let T2 = g2.indexOf("\r");
            return T2 >= 0 ? g2.charAt(T2 + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          __name(d2, "d");
          function f2(g2) {
            switch (g2) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          __name(f2, "f");
          function y2(g2, T2) {
            let S2;
            switch (T2) {
              case `
`:
                S2 = /\n/g;
                break;
              case "\r":
                S2 = /\r/g;
                break;
              case `\r
`:
                S2 = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(T2)}.`);
            }
            let F = g2.match(S2);
            return F ? F.length : 0;
          }
          __name(y2, "y");
          function A2(g2) {
            return g2.replace(/\r\n?/g, `
`);
          }
          __name(A2, "A");
          u2.exports = { guessEndOfLine: d2, convertEndOfLineToChars: f2, countEndOfLineChars: y2, normalizeEndOfLine: A2 };
        } }), fd = K({ "src/language-js/pragma.js"(l2, u2) {
          "use strict";
          V();
          var { parseWithComments: d2, strip: f2, extract: y2, print: A2 } = pd(), { normalizeEndOfLine: g2 } = dd(), T2 = eo();
          function S2(E2) {
            let L2 = T2(E2);
            L2 && (E2 = E2.slice(L2.length + 1));
            let j2 = y2(E2), { pragmas: k2, comments: z } = d2(j2);
            return { shebang: L2, text: E2, pragmas: k2, comments: z };
          }
          __name(S2, "S");
          function F(E2) {
            let L2 = Object.keys(S2(E2).pragmas);
            return L2.includes("prettier") || L2.includes("format");
          }
          __name(F, "F");
          function I(E2) {
            let { shebang: L2, text: j2, pragmas: k2, comments: z } = S2(E2), G = f2(j2), B = A2({ pragmas: Object.assign({ format: "" }, k2), comments: z.trimStart() });
            return (L2 ? `${L2}
` : "") + g2(B) + (G.startsWith(`
`) ? `
` : `

`) + G;
          }
          __name(I, "I");
          u2.exports = { hasPragma: F, insertPragma: I };
        } }), lr = K({ "src/utils/is-non-empty-array.js"(l2, u2) {
          "use strict";
          V();
          function d2(f2) {
            return Array.isArray(f2) && f2.length > 0;
          }
          __name(d2, "d");
          u2.exports = d2;
        } }), yo = K({ "src/language-js/loc.js"(l2, u2) {
          "use strict";
          V();
          var d2 = lr();
          function f2(S2) {
            var F, I;
            let E2 = S2.range ? S2.range[0] : S2.start, L2 = (F = (I = S2.declaration) === null || I === void 0 ? void 0 : I.decorators) !== null && F !== void 0 ? F : S2.decorators;
            return d2(L2) ? Math.min(f2(L2[0]), E2) : E2;
          }
          __name(f2, "f");
          function y2(S2) {
            return S2.range ? S2.range[1] : S2.end;
          }
          __name(y2, "y");
          function A2(S2, F) {
            let I = f2(S2);
            return Number.isInteger(I) && I === f2(F);
          }
          __name(A2, "A");
          function g2(S2, F) {
            let I = y2(S2);
            return Number.isInteger(I) && I === y2(F);
          }
          __name(g2, "g");
          function T2(S2, F) {
            return A2(S2, F) && g2(S2, F);
          }
          __name(T2, "T");
          u2.exports = { locStart: f2, locEnd: y2, hasSameLocStart: A2, hasSameLoc: T2 };
        } }), xo = K({ "src/language-js/parse/utils/create-parser.js"(l2, u2) {
          "use strict";
          V();
          var { hasPragma: d2 } = fd(), { locStart: f2, locEnd: y2 } = yo();
          function A2(g2) {
            return g2 = typeof g2 == "function" ? { parse: g2 } : g2, Object.assign({ astFormat: "estree", hasPragma: d2, locStart: f2, locEnd: y2 }, g2);
          }
          __name(A2, "A");
          u2.exports = A2;
        } }), hr = K({ "src/common/parser-create-error.js"(l2, u2) {
          "use strict";
          V();
          function d2(f2, y2) {
            let A2 = new SyntaxError(f2 + " (" + y2.start.line + ":" + y2.start.column + ")");
            return A2.loc = y2, A2;
          }
          __name(d2, "d");
          u2.exports = d2;
        } }), go = K({ "src/language-js/parse/utils/create-babel-parse-error.js"(l2, u2) {
          "use strict";
          V();
          var d2 = hr();
          function f2(y2) {
            let { message: A2, loc: g2 } = y2;
            return d2(A2.replace(/ \(.*\)/, ""), { start: { line: g2 ? g2.line : 0, column: g2 ? g2.column + 1 : 0 } });
          }
          __name(f2, "f");
          u2.exports = f2;
        } }), md = K({ "src/language-js/utils/is-ts-keyword-type.js"(l2, u2) {
          "use strict";
          V();
          function d2(f2) {
            let { type: y2 } = f2;
            return y2.startsWith("TS") && y2.endsWith("Keyword");
          }
          __name(d2, "d");
          u2.exports = d2;
        } }), yd = K({ "src/language-js/utils/is-block-comment.js"(l2, u2) {
          "use strict";
          V();
          var d2 = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), f2 = /* @__PURE__ */ __name((y2) => d2.has(y2 == null ? void 0 : y2.type), "f");
          u2.exports = f2;
        } }), xd = K({ "src/language-js/utils/is-type-cast-comment.js"(l2, u2) {
          "use strict";
          V();
          var d2 = yd();
          function f2(y2) {
            return d2(y2) && y2.value[0] === "*" && /@type\b/.test(y2.value);
          }
          __name(f2, "f");
          u2.exports = f2;
        } }), gd = K({ "src/utils/get-last.js"(l2, u2) {
          "use strict";
          V();
          var d2 = /* @__PURE__ */ __name((f2) => f2[f2.length - 1], "d");
          u2.exports = d2;
        } }), Po = K({ "src/language-js/parse/postprocess/visit-node.js"(l2, u2) {
          "use strict";
          V();
          function d2(f2, y2) {
            if (Array.isArray(f2)) {
              for (let A2 = 0; A2 < f2.length; A2++)
                f2[A2] = d2(f2[A2], y2);
              return f2;
            }
            if (f2 && typeof f2 == "object" && typeof f2.type == "string") {
              let A2 = Object.keys(f2);
              for (let g2 = 0; g2 < A2.length; g2++)
                f2[A2[g2]] = d2(f2[A2[g2]], y2);
              return y2(f2) || f2;
            }
            return f2;
          }
          __name(d2, "d");
          u2.exports = d2;
        } }), Ao = K({ "src/language-js/parse/postprocess/throw-syntax-error.js"(l2, u2) {
          "use strict";
          V();
          var d2 = hr();
          function f2(y2, A2) {
            let { start: g2, end: T2 } = y2.loc;
            throw d2(A2, { start: { line: g2.line, column: g2.column + 1 }, end: { line: T2.line, column: T2.column + 1 } });
          }
          __name(f2, "f");
          u2.exports = f2;
        } }), Pd = K({ "src/language-js/parse/postprocess/typescript.js"(l2, u2) {
          "use strict";
          V();
          var d2 = lr(), f2 = Po(), y2 = Ao(), A2 = { AbstractKeyword: 126, SourceFile: 308, PropertyDeclaration: 169 };
          function g2(I) {
            for (; I && I.kind !== A2.SourceFile; )
              I = I.parent;
            return I;
          }
          __name(g2, "g");
          function T2(I) {
            let { illegalDecorators: E2 } = I;
            if (!d2(E2))
              return;
            let [{ expression: L2 }] = E2, j2 = g2(L2), [k2, z] = [L2.pos, L2.end].map((G) => {
              let { line: B, character: _2 } = j2.getLineAndCharacterOfPosition(G);
              return { line: B + 1, column: _2 };
            });
            y2({ loc: { start: k2, end: z } }, "Decorators are not valid here.");
          }
          __name(T2, "T");
          function S2(I, E2) {
            I.kind !== A2.PropertyDeclaration || I.modifiers && !I.modifiers.some((L2) => L2.kind === A2.AbstractKeyword) || I.initializer && E2.value === null && y2(E2, "Abstract property cannot have an initializer");
          }
          __name(S2, "S");
          function F(I, E2) {
            let { esTreeNodeToTSNodeMap: L2, tsNodeToESTreeNodeMap: j2 } = E2.tsParseResult;
            f2(I, (k2) => {
              let z = L2.get(k2);
              if (!z)
                return;
              let G = j2.get(z);
              G === k2 && (T2(z), S2(z, G));
            });
          }
          __name(F, "F");
          u2.exports = { throwErrorForInvalidNodes: F };
        } }), Ad = K({ "src/language-js/parse/postprocess/index.js"(l2, u2) {
          "use strict";
          V();
          var { locStart: d2, locEnd: f2 } = yo(), y2 = md(), A2 = xd(), g2 = gd(), T2 = Po(), { throwErrorForInvalidNodes: S2 } = Pd(), F = Ao();
          function I(k2, z) {
            if (z.parser === "typescript" && /@|abstract/.test(z.originalText) && S2(k2, z), z.parser !== "typescript" && z.parser !== "flow" && z.parser !== "acorn" && z.parser !== "espree" && z.parser !== "meriyah") {
              let B = /* @__PURE__ */ new Set();
              k2 = T2(k2, (_2) => {
                _2.leadingComments && _2.leadingComments.some(A2) && B.add(d2(_2));
              }), k2 = T2(k2, (_2) => {
                if (_2.type === "ParenthesizedExpression") {
                  let { expression: h3 } = _2;
                  if (h3.type === "TypeCastExpression")
                    return h3.range = _2.range, h3;
                  let J = d2(_2);
                  if (!B.has(J))
                    return h3.extra = Object.assign(Object.assign({}, h3.extra), {}, { parenthesized: true }), h3;
                }
              });
            }
            return k2 = T2(k2, (B) => {
              switch (B.type) {
                case "ChainExpression":
                  return E2(B.expression);
                case "LogicalExpression": {
                  if (L2(B))
                    return j2(B);
                  break;
                }
                case "VariableDeclaration": {
                  let _2 = g2(B.declarations);
                  _2 && _2.init && G(B, _2);
                  break;
                }
                case "TSParenthesizedType":
                  return y2(B.typeAnnotation) || B.typeAnnotation.type === "TSThisType" || (B.typeAnnotation.range = [d2(B), f2(B)]), B.typeAnnotation;
                case "TSTypeParameter":
                  if (typeof B.name == "string") {
                    let _2 = d2(B);
                    B.name = { type: "Identifier", name: B.name, range: [_2, _2 + B.name.length] };
                  }
                  break;
                case "ObjectExpression":
                  if (z.parser === "typescript") {
                    let _2 = B.properties.find((h3) => h3.type === "Property" && h3.value.type === "TSEmptyBodyFunctionExpression");
                    _2 && F(_2.value, "Unexpected token.");
                  }
                  break;
                case "SequenceExpression": {
                  let _2 = g2(B.expressions);
                  B.range = [d2(B), Math.min(f2(_2), f2(B))];
                  break;
                }
                case "TopicReference":
                  z.__isUsingHackPipeline = true;
                  break;
                case "ExportAllDeclaration": {
                  let { exported: _2 } = B;
                  if (z.parser === "meriyah" && _2 && _2.type === "Identifier") {
                    let h3 = z.originalText.slice(d2(_2), f2(_2));
                    (h3.startsWith('"') || h3.startsWith("'")) && (B.exported = Object.assign(Object.assign({}, B.exported), {}, { type: "Literal", value: B.exported.name, raw: h3 }));
                  }
                  break;
                }
              }
            }), k2;
            function G(B, _2) {
              z.originalText[f2(_2)] !== ";" && (B.range = [d2(B), f2(_2)]);
            }
            __name(G, "G");
          }
          __name(I, "I");
          function E2(k2) {
            switch (k2.type) {
              case "CallExpression":
                k2.type = "OptionalCallExpression", k2.callee = E2(k2.callee);
                break;
              case "MemberExpression":
                k2.type = "OptionalMemberExpression", k2.object = E2(k2.object);
                break;
              case "TSNonNullExpression":
                k2.expression = E2(k2.expression);
                break;
            }
            return k2;
          }
          __name(E2, "E");
          function L2(k2) {
            return k2.type === "LogicalExpression" && k2.right.type === "LogicalExpression" && k2.operator === k2.right.operator;
          }
          __name(L2, "L");
          function j2(k2) {
            return L2(k2) ? j2({ type: "LogicalExpression", operator: k2.operator, left: j2({ type: "LogicalExpression", operator: k2.operator, left: k2.left, right: k2.right.left, range: [d2(k2.left), f2(k2.right.left)] }), right: k2.right.right, range: [d2(k2), f2(k2)] }) : k2;
          }
          __name(j2, "j");
          u2.exports = I;
        } }), To = K({ "node_modules/@babel/parser/lib/index.js"(l2) {
          "use strict";
          V(), Object.defineProperty(l2, "__esModule", { value: true });
          function u2(t2, r2) {
            if (t2 == null)
              return {};
            var e2 = {}, s2 = Object.keys(t2), i2, a2;
            for (a2 = 0; a2 < s2.length; a2++)
              i2 = s2[a2], !(r2.indexOf(i2) >= 0) && (e2[i2] = t2[i2]);
            return e2;
          }
          __name(u2, "u");
          var d2 = /* @__PURE__ */ __name(class {
            constructor(t2, r2, e2) {
              this.line = void 0, this.column = void 0, this.index = void 0, this.line = t2, this.column = r2, this.index = e2;
            }
          }, "d"), f2 = /* @__PURE__ */ __name(class {
            constructor(t2, r2) {
              this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t2, this.end = r2;
            }
          }, "f");
          function y2(t2, r2) {
            let { line: e2, column: s2, index: i2 } = t2;
            return new d2(e2, s2 + r2, i2 + r2);
          }
          __name(y2, "y");
          var A2 = { SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }, g2 = /* @__PURE__ */ __name(function(t2) {
            let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t2.length - 1;
            return { get() {
              return t2.reduce((e2, s2) => e2[s2], this);
            }, set(e2) {
              t2.reduce((s2, i2, a2) => a2 === r2 ? s2[i2] = e2 : s2[i2], this);
            } };
          }, "g"), T2 = /* @__PURE__ */ __name((t2, r2, e2) => Object.keys(e2).map((s2) => [s2, e2[s2]]).filter((s2) => {
            let [, i2] = s2;
            return !!i2;
          }).map((s2) => {
            let [i2, a2] = s2;
            return [i2, typeof a2 == "function" ? { value: a2, enumerable: false } : typeof a2.reflect == "string" ? Object.assign({}, a2, g2(a2.reflect.split("."))) : a2];
          }).reduce((s2, i2) => {
            let [a2, n2] = i2;
            return Object.defineProperty(s2, a2, Object.assign({ configurable: true }, n2));
          }, Object.assign(new t2(), r2)), "T"), S2 = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: A2.SourceTypeModuleError }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: A2.SourceTypeModuleError } }, F = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, I = /* @__PURE__ */ __name((t2) => {
            let { type: r2, prefix: e2 } = t2;
            return r2 === "UpdateExpression" ? F.UpdateExpression[String(e2)] : F[r2];
          }, "I"), E2 = { AccessorIsGenerator: (t2) => {
            let { kind: r2 } = t2;
            return `A ${r2}ter cannot be a generator.`;
          }, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accesor must not have any formal parameters.", BadSetterArity: "A 'set' accesor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: (t2) => {
            let { kind: r2 } = t2;
            return `Missing initializer in ${r2} declaration.`;
          }, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: (t2) => {
            let { exportName: r2 } = t2;
            return `\`${r2}\` has already been exported. Exported identifiers must be unique.`;
          }, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: (t2) => {
            let { localName: r2, exportName: e2 } = t2;
            return `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${r2}' as '${e2}' } from 'some-module'\`?`;
          }, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: (t2) => {
            let { type: r2 } = t2;
            return `'${r2 === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`;
          }, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: (t2) => {
            let { type: r2 } = t2;
            return `Unsyntactic ${r2 === "BreakStatement" ? "break" : "continue"}.`;
          }, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: (t2) => {
            let { importName: r2 } = t2;
            return `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${r2}" as foo }\`?`;
          }, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: (t2) => {
            let { maxArgumentCount: r2 } = t2;
            return `\`import()\` requires exactly ${r2 === 1 ? "one argument" : "one or two arguments"}.`;
          }, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: (t2) => {
            let { radix: r2 } = t2;
            return `Expected number in radix ${r2}.`;
          }, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: (t2) => {
            let { reservedWord: r2 } = t2;
            return `Escape sequence in keyword ${r2}.`;
          }, InvalidIdentifier: (t2) => {
            let { identifierName: r2 } = t2;
            return `Invalid identifier ${r2}.`;
          }, InvalidLhs: (t2) => {
            let { ancestor: r2 } = t2;
            return `Invalid left-hand side in ${I(r2)}.`;
          }, InvalidLhsBinding: (t2) => {
            let { ancestor: r2 } = t2;
            return `Binding invalid left-hand side in ${I(r2)}.`;
          }, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: (t2) => {
            let { unexpected: r2 } = t2;
            return `Unexpected character '${r2}'.`;
          }, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: (t2) => {
            let { identifierName: r2 } = t2;
            return `Private name #${r2} is not defined.`;
          }, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: (t2) => {
            let { labelName: r2 } = t2;
            return `Label '${r2}' is already declared.`;
          }, LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: (t2) => {
            let { missingPlugin: r2 } = t2;
            return `This experimental syntax requires enabling the parser plugin: ${r2.map((e2) => JSON.stringify(e2)).join(", ")}.`;
          }, MissingOneOfPlugins: (t2) => {
            let { missingPlugin: r2 } = t2;
            return `This experimental syntax requires enabling one of the following parser plugin(s): ${r2.map((e2) => JSON.stringify(e2)).join(", ")}.`;
          }, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: (t2) => {
            let { key: r2 } = t2;
            return `Duplicate key "${r2}" is not allowed in module attributes.`;
          }, ModuleExportNameHasLoneSurrogate: (t2) => {
            let { surrogateCharCode: r2 } = t2;
            return `An export name cannot include a lone surrogate, found '\\u${r2.toString(16)}'.`;
          }, ModuleExportUndefined: (t2) => {
            let { localName: r2 } = t2;
            return `Export '${r2}' is not defined.`;
          }, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: (t2) => {
            let { identifierName: r2 } = t2;
            return `Private names are only allowed in property accesses (\`obj.#${r2}\`) or in \`in\` expressions (\`#${r2} in obj\`).`;
          }, PrivateNameRedeclaration: (t2) => {
            let { identifierName: r2 } = t2;
            return `Duplicate private name #${r2}.`;
          }, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: (t2) => {
            let { keyword: r2 } = t2;
            return `Unexpected keyword '${r2}'.`;
          }, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: (t2) => {
            let { reservedWord: r2 } = t2;
            return `Unexpected reserved word '${r2}'.`;
          }, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: (t2) => {
            let { expected: r2, unexpected: e2 } = t2;
            return `Unexpected token${e2 ? ` '${e2}'.` : ""}${r2 ? `, expected "${r2}"` : ""}`;
          }, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: (t2) => {
            let { target: r2, onlyValidPropertyName: e2 } = t2;
            return `The only valid meta property for ${r2} is ${r2}.${e2}.`;
          }, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: (t2) => {
            let { identifierName: r2 } = t2;
            return `Identifier '${r2}' has already been declared.`;
          }, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, L2 = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: (t2) => {
            let { referenceName: r2 } = t2;
            return `Assigning to '${r2}' in strict mode.`;
          }, StrictEvalArgumentsBinding: (t2) => {
            let { bindingName: r2 } = t2;
            return `Binding '${r2}' in strict mode.`;
          }, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, j2 = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), k2 = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: (t2) => {
            let { token: r2 } = t2;
            return `Invalid topic token ${r2}. In order to use ${r2} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${r2}" }.`;
          }, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: (t2) => {
            let { type: r2 } = t2;
            return `Hack-style pipe body cannot be an unparenthesized ${I({ type: r2 })}; please wrap it in parentheses.`;
          }, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }, z = ["toMessage"], G = ["message"];
          function B(t2) {
            let { toMessage: r2 } = t2, e2 = u2(t2, z);
            return /* @__PURE__ */ __name(function s2(i2) {
              let { loc: a2, details: n2 } = i2;
              return T2(SyntaxError, Object.assign({}, e2, { loc: a2 }), { clone() {
                let o2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, c2 = o2.loc || {};
                return s2({ loc: new d2("line" in c2 ? c2.line : this.loc.line, "column" in c2 ? c2.column : this.loc.column, "index" in c2 ? c2.index : this.loc.index), details: Object.assign({}, this.details, o2.details) });
              }, details: { value: n2, enumerable: false }, message: { get() {
                return `${r2(this.details)} (${this.loc.line}:${this.loc.column})`;
              }, set(o2) {
                Object.defineProperty(this, "message", { value: o2 });
              } }, pos: { reflect: "loc.index", enumerable: true }, missingPlugin: "missingPlugin" in n2 && { reflect: "details.missingPlugin", enumerable: true } });
            }, "s");
          }
          __name(B, "B");
          function _2(t2, r2) {
            if (Array.isArray(t2))
              return (s2) => _2(s2, t2[0]);
            let e2 = {};
            for (let s2 of Object.keys(t2)) {
              let i2 = t2[s2], a2 = typeof i2 == "string" ? { message: () => i2 } : typeof i2 == "function" ? { message: i2 } : i2, { message: n2 } = a2, o2 = u2(a2, G), c2 = typeof n2 == "string" ? () => n2 : n2;
              e2[s2] = B(Object.assign({ code: A2.SyntaxError, reasonCode: s2, toMessage: c2 }, r2 ? { syntaxPlugin: r2 } : {}, o2));
            }
            return e2;
          }
          __name(_2, "_");
          var h3 = Object.assign({}, _2(S2), _2(E2), _2(L2), _2`pipelineOperator`(k2)), { defineProperty: J } = Object, ae = /* @__PURE__ */ __name((t2, r2) => J(t2, r2, { enumerable: false, value: t2[r2] }), "ae");
          function Y(t2) {
            return t2.loc.start && ae(t2.loc.start, "index"), t2.loc.end && ae(t2.loc.end, "index"), t2;
          }
          __name(Y, "Y");
          var Me = /* @__PURE__ */ __name((t2) => class extends t2 {
            parse() {
              let e2 = Y(super.parse());
              return this.options.tokens && (e2.tokens = e2.tokens.map(Y)), e2;
            }
            parseRegExpLiteral(e2) {
              let { pattern: s2, flags: i2 } = e2, a2 = null;
              try {
                a2 = new RegExp(s2, i2);
              } catch {
              }
              let n2 = this.estreeParseLiteral(a2);
              return n2.regex = { pattern: s2, flags: i2 }, n2;
            }
            parseBigIntLiteral(e2) {
              let s2;
              try {
                s2 = BigInt(e2);
              } catch {
                s2 = null;
              }
              let i2 = this.estreeParseLiteral(s2);
              return i2.bigint = String(i2.value || e2), i2;
            }
            parseDecimalLiteral(e2) {
              let i2 = this.estreeParseLiteral(null);
              return i2.decimal = String(i2.value || e2), i2;
            }
            estreeParseLiteral(e2) {
              return this.parseLiteral(e2, "Literal");
            }
            parseStringLiteral(e2) {
              return this.estreeParseLiteral(e2);
            }
            parseNumericLiteral(e2) {
              return this.estreeParseLiteral(e2);
            }
            parseNullLiteral() {
              return this.estreeParseLiteral(null);
            }
            parseBooleanLiteral(e2) {
              return this.estreeParseLiteral(e2);
            }
            directiveToStmt(e2) {
              let s2 = e2.value;
              delete e2.value, s2.type = "Literal", s2.raw = s2.extra.raw, s2.value = s2.extra.expressionValue;
              let i2 = e2;
              return i2.type = "ExpressionStatement", i2.expression = s2, i2.directive = s2.extra.rawValue, delete s2.extra, i2;
            }
            initFunction(e2, s2) {
              super.initFunction(e2, s2), e2.expression = false;
            }
            checkDeclaration(e2) {
              e2 != null && this.isObjectProperty(e2) ? this.checkDeclaration(e2.value) : super.checkDeclaration(e2);
            }
            getObjectOrClassMethodParams(e2) {
              return e2.value.params;
            }
            isValidDirective(e2) {
              var s2;
              return e2.type === "ExpressionStatement" && e2.expression.type === "Literal" && typeof e2.expression.value == "string" && !((s2 = e2.expression.extra) != null && s2.parenthesized);
            }
            parseBlockBody(e2, s2, i2, a2, n2) {
              super.parseBlockBody(e2, s2, i2, a2, n2);
              let o2 = e2.directives.map((c2) => this.directiveToStmt(c2));
              e2.body = o2.concat(e2.body), delete e2.directives;
            }
            pushClassMethod(e2, s2, i2, a2, n2, o2) {
              this.parseMethod(s2, i2, a2, n2, o2, "ClassMethod", true), s2.typeParameters && (s2.value.typeParameters = s2.typeParameters, delete s2.typeParameters), e2.body.push(s2);
            }
            parsePrivateName() {
              let e2 = super.parsePrivateName();
              return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e2) : e2;
            }
            convertPrivateNameToPrivateIdentifier(e2) {
              let s2 = super.getPrivateNameSV(e2);
              return e2 = e2, delete e2.id, e2.name = s2, e2.type = "PrivateIdentifier", e2;
            }
            isPrivateName(e2) {
              return this.getPluginOption("estree", "classFeatures") ? e2.type === "PrivateIdentifier" : super.isPrivateName(e2);
            }
            getPrivateNameSV(e2) {
              return this.getPluginOption("estree", "classFeatures") ? e2.name : super.getPrivateNameSV(e2);
            }
            parseLiteral(e2, s2) {
              let i2 = super.parseLiteral(e2, s2);
              return i2.raw = i2.extra.raw, delete i2.extra, i2;
            }
            parseFunctionBody(e2, s2) {
              let i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              super.parseFunctionBody(e2, s2, i2), e2.expression = e2.body.type !== "BlockStatement";
            }
            parseMethod(e2, s2, i2, a2, n2, o2) {
              let c2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false, p2 = this.startNode();
              return p2.kind = e2.kind, p2 = super.parseMethod(p2, s2, i2, a2, n2, o2, c2), p2.type = "FunctionExpression", delete p2.kind, e2.value = p2, o2 === "ClassPrivateMethod" && (e2.computed = false), this.finishNode(e2, "MethodDefinition");
            }
            parseClassProperty() {
              let e2 = super.parseClassProperty(...arguments);
              return this.getPluginOption("estree", "classFeatures") && (e2.type = "PropertyDefinition"), e2;
            }
            parseClassPrivateProperty() {
              let e2 = super.parseClassPrivateProperty(...arguments);
              return this.getPluginOption("estree", "classFeatures") && (e2.type = "PropertyDefinition", e2.computed = false), e2;
            }
            parseObjectMethod(e2, s2, i2, a2, n2) {
              let o2 = super.parseObjectMethod(e2, s2, i2, a2, n2);
              return o2 && (o2.type = "Property", o2.kind === "method" && (o2.kind = "init"), o2.shorthand = false), o2;
            }
            parseObjectProperty(e2, s2, i2, a2) {
              let n2 = super.parseObjectProperty(e2, s2, i2, a2);
              return n2 && (n2.kind = "init", n2.type = "Property"), n2;
            }
            isValidLVal(e2, s2, i2) {
              return e2 === "Property" ? "value" : super.isValidLVal(e2, s2, i2);
            }
            isAssignable(e2, s2) {
              return e2 != null && this.isObjectProperty(e2) ? this.isAssignable(e2.value, s2) : super.isAssignable(e2, s2);
            }
            toAssignable(e2) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (e2 != null && this.isObjectProperty(e2)) {
                let { key: i2, value: a2 } = e2;
                this.isPrivateName(i2) && this.classScope.usePrivateName(this.getPrivateNameSV(i2), i2.loc.start), this.toAssignable(a2, s2);
              } else
                super.toAssignable(e2, s2);
            }
            toAssignableObjectExpressionProp(e2, s2, i2) {
              e2.kind === "get" || e2.kind === "set" ? this.raise(h3.PatternHasAccessor, { at: e2.key }) : e2.method ? this.raise(h3.PatternHasMethod, { at: e2.key }) : super.toAssignableObjectExpressionProp(e2, s2, i2);
            }
            finishCallExpression(e2, s2) {
              let i2 = super.finishCallExpression(e2, s2);
              if (i2.callee.type === "Import") {
                if (i2.type = "ImportExpression", i2.source = i2.arguments[0], this.hasPlugin("importAssertions")) {
                  var a2;
                  i2.attributes = (a2 = i2.arguments[1]) != null ? a2 : null;
                }
                delete i2.arguments, delete i2.callee;
              }
              return i2;
            }
            toReferencedArguments(e2) {
              e2.type !== "ImportExpression" && super.toReferencedArguments(e2);
            }
            parseExport(e2, s2) {
              let i2 = this.state.lastTokStartLoc, a2 = super.parseExport(e2, s2);
              switch (a2.type) {
                case "ExportAllDeclaration":
                  a2.exported = null;
                  break;
                case "ExportNamedDeclaration":
                  a2.specifiers.length === 1 && a2.specifiers[0].type === "ExportNamespaceSpecifier" && (a2.type = "ExportAllDeclaration", a2.exported = a2.specifiers[0].exported, delete a2.specifiers);
                case "ExportDefaultDeclaration":
                  {
                    var n2;
                    let { declaration: o2 } = a2;
                    (o2 == null ? void 0 : o2.type) === "ClassDeclaration" && ((n2 = o2.decorators) == null ? void 0 : n2.length) > 0 && o2.start === a2.start && this.resetStartLocation(a2, i2);
                  }
                  break;
              }
              return a2;
            }
            parseSubscript(e2, s2, i2, a2) {
              let n2 = super.parseSubscript(e2, s2, i2, a2);
              if (a2.optionalChainMember) {
                if ((n2.type === "OptionalMemberExpression" || n2.type === "OptionalCallExpression") && (n2.type = n2.type.substring(8)), a2.stop) {
                  let o2 = this.startNodeAtNode(n2);
                  return o2.expression = n2, this.finishNode(o2, "ChainExpression");
                }
              } else
                (n2.type === "MemberExpression" || n2.type === "CallExpression") && (n2.optional = false);
              return n2;
            }
            hasPropertyAsPrivateName(e2) {
              return e2.type === "ChainExpression" && (e2 = e2.expression), super.hasPropertyAsPrivateName(e2);
            }
            isOptionalChain(e2) {
              return e2.type === "ChainExpression";
            }
            isObjectProperty(e2) {
              return e2.type === "Property" && e2.kind === "init" && !e2.method;
            }
            isObjectMethod(e2) {
              return e2.method || e2.kind === "get" || e2.kind === "set";
            }
            finishNodeAt(e2, s2, i2) {
              return Y(super.finishNodeAt(e2, s2, i2));
            }
            resetStartLocation(e2, s2) {
              super.resetStartLocation(e2, s2), Y(e2);
            }
            resetEndLocation(e2) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
              super.resetEndLocation(e2, s2), Y(e2);
            }
          }, "Me"), ee = /* @__PURE__ */ __name(class {
            constructor(t2, r2) {
              this.token = void 0, this.preserveSpace = void 0, this.token = t2, this.preserveSpace = !!r2;
            }
          }, "ee"), H = { brace: new ee("{"), j_oTag: new ee("<tag"), j_cTag: new ee("</tag"), j_expr: new ee("<tag>...</tag>", true) };
          H.template = new ee("`", true);
          var M2 = true, v2 = true, We = true, te = true, he = true, Co = true, ur = /* @__PURE__ */ __name(class {
            constructor(t2) {
              let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t2, this.keyword = r2.keyword, this.beforeExpr = !!r2.beforeExpr, this.startsExpr = !!r2.startsExpr, this.rightAssociative = !!r2.rightAssociative, this.isLoop = !!r2.isLoop, this.isAssign = !!r2.isAssign, this.prefix = !!r2.prefix, this.postfix = !!r2.postfix, this.binop = r2.binop != null ? r2.binop : null, this.updateContext = null;
            }
          }, "ur"), qt = /* @__PURE__ */ new Map();
          function U2(t2) {
            let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            r2.keyword = t2;
            let e2 = N2(t2, r2);
            return qt.set(t2, e2), e2;
          }
          __name(U2, "U");
          function ie(t2, r2) {
            return N2(t2, { beforeExpr: M2, binop: r2 });
          }
          __name(ie, "ie");
          var Ge = -1, ce = [], Ut = [], Ht = [], $t = [], zt = [], Vt = [];
          function N2(t2) {
            let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var e2, s2, i2, a2;
            return ++Ge, Ut.push(t2), Ht.push((e2 = r2.binop) != null ? e2 : -1), $t.push((s2 = r2.beforeExpr) != null ? s2 : false), zt.push((i2 = r2.startsExpr) != null ? i2 : false), Vt.push((a2 = r2.prefix) != null ? a2 : false), ce.push(new ur(t2, r2)), Ge;
          }
          __name(N2, "N");
          function q(t2) {
            let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var e2, s2, i2, a2;
            return ++Ge, qt.set(t2, Ge), Ut.push(t2), Ht.push((e2 = r2.binop) != null ? e2 : -1), $t.push((s2 = r2.beforeExpr) != null ? s2 : false), zt.push((i2 = r2.startsExpr) != null ? i2 : false), Vt.push((a2 = r2.prefix) != null ? a2 : false), ce.push(new ur("name", r2)), Ge;
          }
          __name(q, "q");
          var bo = { bracketL: N2("[", { beforeExpr: M2, startsExpr: v2 }), bracketHashL: N2("#[", { beforeExpr: M2, startsExpr: v2 }), bracketBarL: N2("[|", { beforeExpr: M2, startsExpr: v2 }), bracketR: N2("]"), bracketBarR: N2("|]"), braceL: N2("{", { beforeExpr: M2, startsExpr: v2 }), braceBarL: N2("{|", { beforeExpr: M2, startsExpr: v2 }), braceHashL: N2("#{", { beforeExpr: M2, startsExpr: v2 }), braceR: N2("}"), braceBarR: N2("|}"), parenL: N2("(", { beforeExpr: M2, startsExpr: v2 }), parenR: N2(")"), comma: N2(",", { beforeExpr: M2 }), semi: N2(";", { beforeExpr: M2 }), colon: N2(":", { beforeExpr: M2 }), doubleColon: N2("::", { beforeExpr: M2 }), dot: N2("."), question: N2("?", { beforeExpr: M2 }), questionDot: N2("?."), arrow: N2("=>", { beforeExpr: M2 }), template: N2("template"), ellipsis: N2("...", { beforeExpr: M2 }), backQuote: N2("`", { startsExpr: v2 }), dollarBraceL: N2("${", { beforeExpr: M2, startsExpr: v2 }), templateTail: N2("...`", { startsExpr: v2 }), templateNonTail: N2("...${", { beforeExpr: M2, startsExpr: v2 }), at: N2("@"), hash: N2("#", { startsExpr: v2 }), interpreterDirective: N2("#!..."), eq: N2("=", { beforeExpr: M2, isAssign: te }), assign: N2("_=", { beforeExpr: M2, isAssign: te }), slashAssign: N2("_=", { beforeExpr: M2, isAssign: te }), xorAssign: N2("_=", { beforeExpr: M2, isAssign: te }), moduloAssign: N2("_=", { beforeExpr: M2, isAssign: te }), incDec: N2("++/--", { prefix: he, postfix: Co, startsExpr: v2 }), bang: N2("!", { beforeExpr: M2, prefix: he, startsExpr: v2 }), tilde: N2("~", { beforeExpr: M2, prefix: he, startsExpr: v2 }), doubleCaret: N2("^^", { startsExpr: v2 }), doubleAt: N2("@@", { startsExpr: v2 }), pipeline: ie("|>", 0), nullishCoalescing: ie("??", 1), logicalOR: ie("||", 1), logicalAND: ie("&&", 2), bitwiseOR: ie("|", 3), bitwiseXOR: ie("^", 4), bitwiseAND: ie("&", 5), equality: ie("==/!=/===/!==", 6), lt: ie("</>/<=/>=", 7), gt: ie("</>/<=/>=", 7), relational: ie("</>/<=/>=", 7), bitShift: ie("<</>>/>>>", 8), bitShiftL: ie("<</>>/>>>", 8), bitShiftR: ie("<</>>/>>>", 8), plusMin: N2("+/-", { beforeExpr: M2, binop: 9, prefix: he, startsExpr: v2 }), modulo: N2("%", { binop: 10, startsExpr: v2 }), star: N2("*", { binop: 10 }), slash: ie("/", 10), exponent: N2("**", { beforeExpr: M2, binop: 11, rightAssociative: true }), _in: U2("in", { beforeExpr: M2, binop: 7 }), _instanceof: U2("instanceof", { beforeExpr: M2, binop: 7 }), _break: U2("break"), _case: U2("case", { beforeExpr: M2 }), _catch: U2("catch"), _continue: U2("continue"), _debugger: U2("debugger"), _default: U2("default", { beforeExpr: M2 }), _else: U2("else", { beforeExpr: M2 }), _finally: U2("finally"), _function: U2("function", { startsExpr: v2 }), _if: U2("if"), _return: U2("return", { beforeExpr: M2 }), _switch: U2("switch"), _throw: U2("throw", { beforeExpr: M2, prefix: he, startsExpr: v2 }), _try: U2("try"), _var: U2("var"), _const: U2("const"), _with: U2("with"), _new: U2("new", { beforeExpr: M2, startsExpr: v2 }), _this: U2("this", { startsExpr: v2 }), _super: U2("super", { startsExpr: v2 }), _class: U2("class", { startsExpr: v2 }), _extends: U2("extends", { beforeExpr: M2 }), _export: U2("export"), _import: U2("import", { startsExpr: v2 }), _null: U2("null", { startsExpr: v2 }), _true: U2("true", { startsExpr: v2 }), _false: U2("false", { startsExpr: v2 }), _typeof: U2("typeof", { beforeExpr: M2, prefix: he, startsExpr: v2 }), _void: U2("void", { beforeExpr: M2, prefix: he, startsExpr: v2 }), _delete: U2("delete", { beforeExpr: M2, prefix: he, startsExpr: v2 }), _do: U2("do", { isLoop: We, beforeExpr: M2 }), _for: U2("for", { isLoop: We }), _while: U2("while", { isLoop: We }), _as: q("as", { startsExpr: v2 }), _assert: q("assert", { startsExpr: v2 }), _async: q("async", { startsExpr: v2 }), _await: q("await", { startsExpr: v2 }), _from: q("from", { startsExpr: v2 }), _get: q("get", { startsExpr: v2 }), _let: q("let", { startsExpr: v2 }), _meta: q("meta", { startsExpr: v2 }), _of: q("of", { startsExpr: v2 }), _sent: q("sent", { startsExpr: v2 }), _set: q("set", { startsExpr: v2 }), _static: q("static", { startsExpr: v2 }), _using: q("using", { startsExpr: v2 }), _yield: q("yield", { startsExpr: v2 }), _asserts: q("asserts", { startsExpr: v2 }), _checks: q("checks", { startsExpr: v2 }), _exports: q("exports", { startsExpr: v2 }), _global: q("global", { startsExpr: v2 }), _implements: q("implements", { startsExpr: v2 }), _intrinsic: q("intrinsic", { startsExpr: v2 }), _infer: q("infer", { startsExpr: v2 }), _is: q("is", { startsExpr: v2 }), _mixins: q("mixins", { startsExpr: v2 }), _proto: q("proto", { startsExpr: v2 }), _require: q("require", { startsExpr: v2 }), _satisfies: q("satisfies", { startsExpr: v2 }), _keyof: q("keyof", { startsExpr: v2 }), _readonly: q("readonly", { startsExpr: v2 }), _unique: q("unique", { startsExpr: v2 }), _abstract: q("abstract", { startsExpr: v2 }), _declare: q("declare", { startsExpr: v2 }), _enum: q("enum", { startsExpr: v2 }), _module: q("module", { startsExpr: v2 }), _namespace: q("namespace", { startsExpr: v2 }), _interface: q("interface", { startsExpr: v2 }), _type: q("type", { startsExpr: v2 }), _opaque: q("opaque", { startsExpr: v2 }), name: N2("name", { startsExpr: v2 }), string: N2("string", { startsExpr: v2 }), num: N2("num", { startsExpr: v2 }), bigint: N2("bigint", { startsExpr: v2 }), decimal: N2("decimal", { startsExpr: v2 }), regexp: N2("regexp", { startsExpr: v2 }), privateName: N2("#name", { startsExpr: v2 }), eof: N2("eof"), jsxName: N2("jsxName"), jsxText: N2("jsxText", { beforeExpr: true }), jsxTagStart: N2("jsxTagStart", { startsExpr: true }), jsxTagEnd: N2("jsxTagEnd"), placeholder: N2("%%", { startsExpr: true }) };
          function $(t2) {
            return t2 >= 93 && t2 <= 130;
          }
          __name($, "$");
          function So(t2) {
            return t2 <= 92;
          }
          __name(So, "So");
          function pe(t2) {
            return t2 >= 58 && t2 <= 130;
          }
          __name(pe, "pe");
          function cr(t2) {
            return t2 >= 58 && t2 <= 134;
          }
          __name(cr, "cr");
          function wo(t2) {
            return $t[t2];
          }
          __name(wo, "wo");
          function Kt(t2) {
            return zt[t2];
          }
          __name(Kt, "Kt");
          function Io(t2) {
            return t2 >= 29 && t2 <= 33;
          }
          __name(Io, "Io");
          function pr(t2) {
            return t2 >= 127 && t2 <= 129;
          }
          __name(pr, "pr");
          function No(t2) {
            return t2 >= 90 && t2 <= 92;
          }
          __name(No, "No");
          function Wt(t2) {
            return t2 >= 58 && t2 <= 92;
          }
          __name(Wt, "Wt");
          function ko(t2) {
            return t2 >= 39 && t2 <= 59;
          }
          __name(ko, "ko");
          function Do(t2) {
            return t2 === 34;
          }
          __name(Do, "Do");
          function Fo(t2) {
            return Vt[t2];
          }
          __name(Fo, "Fo");
          function Lo(t2) {
            return t2 >= 119 && t2 <= 121;
          }
          __name(Lo, "Lo");
          function Oo(t2) {
            return t2 >= 122 && t2 <= 128;
          }
          __name(Oo, "Oo");
          function Pe(t2) {
            return Ut[t2];
          }
          __name(Pe, "Pe");
          function nt(t2) {
            return Ht[t2];
          }
          __name(nt, "nt");
          function Mo(t2) {
            return t2 === 57;
          }
          __name(Mo, "Mo");
          function ot(t2) {
            return t2 >= 24 && t2 <= 25;
          }
          __name(ot, "ot");
          function de(t2) {
            return ce[t2];
          }
          __name(de, "de");
          ce[8].updateContext = (t2) => {
            t2.pop();
          }, ce[5].updateContext = ce[7].updateContext = ce[23].updateContext = (t2) => {
            t2.push(H.brace);
          }, ce[22].updateContext = (t2) => {
            t2[t2.length - 1] === H.template ? t2.pop() : t2.push(H.template);
          }, ce[140].updateContext = (t2) => {
            t2.push(H.j_expr, H.j_oTag);
          };
          var Gt = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", dr = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F", Bo = new RegExp("[" + Gt + "]"), _o = new RegExp("[" + Gt + dr + "]");
          Gt = dr = null;
          var fr = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191], Ro = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
          function Jt(t2, r2) {
            let e2 = 65536;
            for (let s2 = 0, i2 = r2.length; s2 < i2; s2 += 2) {
              if (e2 += r2[s2], e2 > t2)
                return false;
              if (e2 += r2[s2 + 1], e2 >= t2)
                return true;
            }
            return false;
          }
          __name(Jt, "Jt");
          function fe(t2) {
            return t2 < 65 ? t2 === 36 : t2 <= 90 ? true : t2 < 97 ? t2 === 95 : t2 <= 122 ? true : t2 <= 65535 ? t2 >= 170 && Bo.test(String.fromCharCode(t2)) : Jt(t2, fr);
          }
          __name(fe, "fe");
          function Be(t2) {
            return t2 < 48 ? t2 === 36 : t2 < 58 ? true : t2 < 65 ? false : t2 <= 90 ? true : t2 < 97 ? t2 === 95 : t2 <= 122 ? true : t2 <= 65535 ? t2 >= 170 && _o.test(String.fromCharCode(t2)) : Jt(t2, fr) || Jt(t2, Ro);
          }
          __name(Be, "Be");
          var Xt = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, jo = new Set(Xt.keyword), qo = new Set(Xt.strict), Uo = new Set(Xt.strictBind);
          function mr(t2, r2) {
            return r2 && t2 === "await" || t2 === "enum";
          }
          __name(mr, "mr");
          function yr(t2, r2) {
            return mr(t2, r2) || qo.has(t2);
          }
          __name(yr, "yr");
          function xr(t2) {
            return Uo.has(t2);
          }
          __name(xr, "xr");
          function gr(t2, r2) {
            return yr(t2, r2) || xr(t2);
          }
          __name(gr, "gr");
          function Ho(t2) {
            return jo.has(t2);
          }
          __name(Ho, "Ho");
          function $o(t2, r2, e2) {
            return t2 === 64 && r2 === 64 && fe(e2);
          }
          __name($o, "$o");
          var zo = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
          function Vo(t2) {
            return zo.has(t2);
          }
          __name(Vo, "Vo");
          var _e = 0, Re = 1, me = 2, Yt = 4, Pr = 8, lt = 16, Ar = 32, Se = 64, ht = 128, je = 256, ut = Re | me | ht | je, ye = 1, we = 2, Tr = 4, Ae = 8, ct = 16, vr = 64, pt = 128, Qt = 256, Zt = 512, es = 1024, ts = 2048, Je = 4096, Er = ye | we | Ae | pt, Ie = ye | 0 | Ae | 0, dt = ye | 0 | Tr | 0, Cr = ye | 0 | ct | 0, Ko = 0 | we | 0 | pt, Wo = 0 | we | 0 | 0, br = ye | we | Ae | Qt, Sr = 0 | es, Te = 0 | vr, Go = ye | 0 | 0 | vr, Jo = br | Zt, Xo = 0 | es, wr = 0 | we | 0 | Je, Yo = ts, ft = 4, ss = 2, rs = 1, is = ss | rs, Qo = ss | ft, Zo = rs | ft, el = ss, tl = rs, as = 0, ns = /* @__PURE__ */ __name(class {
            constructor(t2) {
              this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = t2;
            }
          }, "ns"), os = /* @__PURE__ */ __name(class {
            constructor(t2, r2) {
              this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t2, this.inModule = r2;
            }
            get inTopLevel() {
              return (this.currentScope().flags & Re) > 0;
            }
            get inFunction() {
              return (this.currentVarScopeFlags() & me) > 0;
            }
            get allowSuper() {
              return (this.currentThisScopeFlags() & lt) > 0;
            }
            get allowDirectSuper() {
              return (this.currentThisScopeFlags() & Ar) > 0;
            }
            get inClass() {
              return (this.currentThisScopeFlags() & Se) > 0;
            }
            get inClassAndNotInNonArrowFunction() {
              let t2 = this.currentThisScopeFlags();
              return (t2 & Se) > 0 && (t2 & me) === 0;
            }
            get inStaticBlock() {
              for (let t2 = this.scopeStack.length - 1; ; t2--) {
                let { flags: r2 } = this.scopeStack[t2];
                if (r2 & ht)
                  return true;
                if (r2 & (ut | Se))
                  return false;
              }
            }
            get inNonArrowFunction() {
              return (this.currentThisScopeFlags() & me) > 0;
            }
            get treatFunctionsAsVar() {
              return this.treatFunctionsAsVarInScope(this.currentScope());
            }
            createScope(t2) {
              return new ns(t2);
            }
            enter(t2) {
              this.scopeStack.push(this.createScope(t2));
            }
            exit() {
              return this.scopeStack.pop().flags;
            }
            treatFunctionsAsVarInScope(t2) {
              return !!(t2.flags & (me | ht) || !this.parser.inModule && t2.flags & Re);
            }
            declareName(t2, r2, e2) {
              let s2 = this.currentScope();
              if (r2 & Ae || r2 & ct)
                this.checkRedeclarationInScope(s2, t2, r2, e2), r2 & ct ? s2.functions.add(t2) : s2.lexical.add(t2), r2 & Ae && this.maybeExportDefined(s2, t2);
              else if (r2 & Tr)
                for (let i2 = this.scopeStack.length - 1; i2 >= 0 && (s2 = this.scopeStack[i2], this.checkRedeclarationInScope(s2, t2, r2, e2), s2.var.add(t2), this.maybeExportDefined(s2, t2), !(s2.flags & ut)); --i2)
                  ;
              this.parser.inModule && s2.flags & Re && this.undefinedExports.delete(t2);
            }
            maybeExportDefined(t2, r2) {
              this.parser.inModule && t2.flags & Re && this.undefinedExports.delete(r2);
            }
            checkRedeclarationInScope(t2, r2, e2, s2) {
              this.isRedeclaredInScope(t2, r2, e2) && this.parser.raise(h3.VarRedeclaration, { at: s2, identifierName: r2 });
            }
            isRedeclaredInScope(t2, r2, e2) {
              return e2 & ye ? e2 & Ae ? t2.lexical.has(r2) || t2.functions.has(r2) || t2.var.has(r2) : e2 & ct ? t2.lexical.has(r2) || !this.treatFunctionsAsVarInScope(t2) && t2.var.has(r2) : t2.lexical.has(r2) && !(t2.flags & Pr && t2.lexical.values().next().value === r2) || !this.treatFunctionsAsVarInScope(t2) && t2.functions.has(r2) : false;
            }
            checkLocalExport(t2) {
              let { name: r2 } = t2, e2 = this.scopeStack[0];
              !e2.lexical.has(r2) && !e2.var.has(r2) && !e2.functions.has(r2) && this.undefinedExports.set(r2, t2.loc.start);
            }
            currentScope() {
              return this.scopeStack[this.scopeStack.length - 1];
            }
            currentVarScopeFlags() {
              for (let t2 = this.scopeStack.length - 1; ; t2--) {
                let { flags: r2 } = this.scopeStack[t2];
                if (r2 & ut)
                  return r2;
              }
            }
            currentThisScopeFlags() {
              for (let t2 = this.scopeStack.length - 1; ; t2--) {
                let { flags: r2 } = this.scopeStack[t2];
                if (r2 & (ut | Se) && !(r2 & Yt))
                  return r2;
              }
            }
          }, "os"), sl = /* @__PURE__ */ __name(class extends ns {
            constructor() {
              super(...arguments), this.declareFunctions = /* @__PURE__ */ new Set();
            }
          }, "sl"), rl = /* @__PURE__ */ __name(class extends os {
            createScope(t2) {
              return new sl(t2);
            }
            declareName(t2, r2, e2) {
              let s2 = this.currentScope();
              if (r2 & ts) {
                this.checkRedeclarationInScope(s2, t2, r2, e2), this.maybeExportDefined(s2, t2), s2.declareFunctions.add(t2);
                return;
              }
              super.declareName(t2, r2, e2);
            }
            isRedeclaredInScope(t2, r2, e2) {
              return super.isRedeclaredInScope(t2, r2, e2) ? true : e2 & ts ? !t2.declareFunctions.has(r2) && (t2.lexical.has(r2) || t2.functions.has(r2)) : false;
            }
            checkLocalExport(t2) {
              this.scopeStack[0].declareFunctions.has(t2.name) || super.checkLocalExport(t2);
            }
          }, "rl"), il = /* @__PURE__ */ __name(class {
            constructor() {
              this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
            }
            hasPlugin(t2) {
              if (typeof t2 == "string")
                return this.plugins.has(t2);
              {
                let [r2, e2] = t2;
                if (!this.hasPlugin(r2))
                  return false;
                let s2 = this.plugins.get(r2);
                for (let i2 of Object.keys(e2))
                  if ((s2 == null ? void 0 : s2[i2]) !== e2[i2])
                    return false;
                return true;
              }
            }
            getPluginOption(t2, r2) {
              var e2;
              return (e2 = this.plugins.get(t2)) == null ? void 0 : e2[r2];
            }
          }, "il");
          function Ir(t2, r2) {
            t2.trailingComments === void 0 ? t2.trailingComments = r2 : t2.trailingComments.unshift(...r2);
          }
          __name(Ir, "Ir");
          function al(t2, r2) {
            t2.leadingComments === void 0 ? t2.leadingComments = r2 : t2.leadingComments.unshift(...r2);
          }
          __name(al, "al");
          function Xe(t2, r2) {
            t2.innerComments === void 0 ? t2.innerComments = r2 : t2.innerComments.unshift(...r2);
          }
          __name(Xe, "Xe");
          function Ye(t2, r2, e2) {
            let s2 = null, i2 = r2.length;
            for (; s2 === null && i2 > 0; )
              s2 = r2[--i2];
            s2 === null || s2.start > e2.start ? Xe(t2, e2.comments) : Ir(s2, e2.comments);
          }
          __name(Ye, "Ye");
          var nl = /* @__PURE__ */ __name(class extends il {
            addComment(t2) {
              this.filename && (t2.loc.filename = this.filename), this.state.comments.push(t2);
            }
            processComment(t2) {
              let { commentStack: r2 } = this.state, e2 = r2.length;
              if (e2 === 0)
                return;
              let s2 = e2 - 1, i2 = r2[s2];
              i2.start === t2.end && (i2.leadingNode = t2, s2--);
              let { start: a2 } = t2;
              for (; s2 >= 0; s2--) {
                let n2 = r2[s2], o2 = n2.end;
                if (o2 > a2)
                  n2.containingNode = t2, this.finalizeComment(n2), r2.splice(s2, 1);
                else {
                  o2 === a2 && (n2.trailingNode = t2);
                  break;
                }
              }
            }
            finalizeComment(t2) {
              let { comments: r2 } = t2;
              if (t2.leadingNode !== null || t2.trailingNode !== null)
                t2.leadingNode !== null && Ir(t2.leadingNode, r2), t2.trailingNode !== null && al(t2.trailingNode, r2);
              else {
                let { containingNode: e2, start: s2 } = t2;
                if (this.input.charCodeAt(s2 - 1) === 44)
                  switch (e2.type) {
                    case "ObjectExpression":
                    case "ObjectPattern":
                    case "RecordExpression":
                      Ye(e2, e2.properties, t2);
                      break;
                    case "CallExpression":
                    case "OptionalCallExpression":
                      Ye(e2, e2.arguments, t2);
                      break;
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "ArrowFunctionExpression":
                    case "ObjectMethod":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                      Ye(e2, e2.params, t2);
                      break;
                    case "ArrayExpression":
                    case "ArrayPattern":
                    case "TupleExpression":
                      Ye(e2, e2.elements, t2);
                      break;
                    case "ExportNamedDeclaration":
                    case "ImportDeclaration":
                      Ye(e2, e2.specifiers, t2);
                      break;
                    default:
                      Xe(e2, r2);
                  }
                else
                  Xe(e2, r2);
              }
            }
            finalizeRemainingComments() {
              let { commentStack: t2 } = this.state;
              for (let r2 = t2.length - 1; r2 >= 0; r2--)
                this.finalizeComment(t2[r2]);
              this.state.commentStack = [];
            }
            resetPreviousNodeTrailingComments(t2) {
              let { commentStack: r2 } = this.state, { length: e2 } = r2;
              if (e2 === 0)
                return;
              let s2 = r2[e2 - 1];
              s2.leadingNode === t2 && (s2.leadingNode = null);
            }
            takeSurroundingComments(t2, r2, e2) {
              let { commentStack: s2 } = this.state, i2 = s2.length;
              if (i2 === 0)
                return;
              let a2 = i2 - 1;
              for (; a2 >= 0; a2--) {
                let n2 = s2[a2], o2 = n2.end;
                if (n2.start === e2)
                  n2.leadingNode = t2;
                else if (o2 === r2)
                  n2.trailingNode = t2;
                else if (o2 < r2)
                  break;
              }
            }
          }, "nl"), ls = /\r\n?|[\n\u2028\u2029]/, mt = new RegExp(ls.source, "g");
          function Qe(t2) {
            switch (t2) {
              case 10:
              case 13:
              case 8232:
              case 8233:
                return true;
              default:
                return false;
            }
          }
          __name(Qe, "Qe");
          var hs = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ol = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y, Nr = new RegExp("(?=(" + ol.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
          function ll(t2) {
            switch (t2) {
              case 9:
              case 11:
              case 12:
              case 32:
              case 160:
              case 5760:
              case 8192:
              case 8193:
              case 8194:
              case 8195:
              case 8196:
              case 8197:
              case 8198:
              case 8199:
              case 8200:
              case 8201:
              case 8202:
              case 8239:
              case 8287:
              case 12288:
              case 65279:
                return true;
              default:
                return false;
            }
          }
          __name(ll, "ll");
          var kr = /* @__PURE__ */ __name(class {
            constructor() {
              this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.inDisallowConditionalTypesContext = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 137, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [H.brace], this.canStartJSXElement = true, this.containsEsc = false, this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
            }
            init(t2) {
              let { strictMode: r2, sourceType: e2, startLine: s2, startColumn: i2 } = t2;
              this.strict = r2 === false ? false : r2 === true ? true : e2 === "module", this.curLine = s2, this.lineStart = -i2, this.startLoc = this.endLoc = new d2(s2, i2, 0);
            }
            curPosition() {
              return new d2(this.curLine, this.pos - this.lineStart, this.pos);
            }
            clone(t2) {
              let r2 = new kr(), e2 = Object.keys(this);
              for (let s2 = 0, i2 = e2.length; s2 < i2; s2++) {
                let a2 = e2[s2], n2 = this[a2];
                !t2 && Array.isArray(n2) && (n2 = n2.slice()), r2[a2] = n2;
              }
              return r2;
            }
          }, "kr"), hl = /* @__PURE__ */ __name(function(r2) {
            return r2 >= 48 && r2 <= 57;
          }, "hl"), Dr = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, yt = { bin: (t2) => t2 === 48 || t2 === 49, oct: (t2) => t2 >= 48 && t2 <= 55, dec: (t2) => t2 >= 48 && t2 <= 57, hex: (t2) => t2 >= 48 && t2 <= 57 || t2 >= 65 && t2 <= 70 || t2 >= 97 && t2 <= 102 };
          function Fr(t2, r2, e2, s2, i2, a2) {
            let n2 = e2, o2 = s2, c2 = i2, p2 = "", m2 = null, x2 = e2, { length: P2 } = r2;
            for (; ; ) {
              if (e2 >= P2) {
                a2.unterminated(n2, o2, c2), p2 += r2.slice(x2, e2);
                break;
              }
              let b2 = r2.charCodeAt(e2);
              if (ul(t2, b2, r2, e2)) {
                p2 += r2.slice(x2, e2);
                break;
              }
              if (b2 === 92) {
                p2 += r2.slice(x2, e2);
                let O2 = cl(r2, e2, s2, i2, t2 === "template", a2);
                O2.ch === null && !m2 ? m2 = { pos: e2, lineStart: s2, curLine: i2 } : p2 += O2.ch, { pos: e2, lineStart: s2, curLine: i2 } = O2, x2 = e2;
              } else
                b2 === 8232 || b2 === 8233 ? (++e2, ++i2, s2 = e2) : b2 === 10 || b2 === 13 ? t2 === "template" ? (p2 += r2.slice(x2, e2) + `
`, ++e2, b2 === 13 && r2.charCodeAt(e2) === 10 && ++e2, ++i2, x2 = s2 = e2) : a2.unterminated(n2, o2, c2) : ++e2;
            }
            return { pos: e2, str: p2, firstInvalidLoc: m2, lineStart: s2, curLine: i2, containsInvalid: !!m2 };
          }
          __name(Fr, "Fr");
          function ul(t2, r2, e2, s2) {
            return t2 === "template" ? r2 === 96 || r2 === 36 && e2.charCodeAt(s2 + 1) === 123 : r2 === (t2 === "double" ? 34 : 39);
          }
          __name(ul, "ul");
          function cl(t2, r2, e2, s2, i2, a2) {
            let n2 = !i2;
            r2++;
            let o2 = /* @__PURE__ */ __name((p2) => ({ pos: r2, ch: p2, lineStart: e2, curLine: s2 }), "o"), c2 = t2.charCodeAt(r2++);
            switch (c2) {
              case 110:
                return o2(`
`);
              case 114:
                return o2("\r");
              case 120: {
                let p2;
                return { code: p2, pos: r2 } = us(t2, r2, e2, s2, 2, false, n2, a2), o2(p2 === null ? null : String.fromCharCode(p2));
              }
              case 117: {
                let p2;
                return { code: p2, pos: r2 } = Or(t2, r2, e2, s2, n2, a2), o2(p2 === null ? null : String.fromCodePoint(p2));
              }
              case 116:
                return o2("	");
              case 98:
                return o2("\b");
              case 118:
                return o2("\v");
              case 102:
                return o2("\f");
              case 13:
                t2.charCodeAt(r2) === 10 && ++r2;
              case 10:
                e2 = r2, ++s2;
              case 8232:
              case 8233:
                return o2("");
              case 56:
              case 57:
                if (i2)
                  return o2(null);
                a2.strictNumericEscape(r2 - 1, e2, s2);
              default:
                if (c2 >= 48 && c2 <= 55) {
                  let p2 = r2 - 1, x2 = t2.slice(p2, r2 + 2).match(/^[0-7]+/)[0], P2 = parseInt(x2, 8);
                  P2 > 255 && (x2 = x2.slice(0, -1), P2 = parseInt(x2, 8)), r2 += x2.length - 1;
                  let b2 = t2.charCodeAt(r2);
                  if (x2 !== "0" || b2 === 56 || b2 === 57) {
                    if (i2)
                      return o2(null);
                    a2.strictNumericEscape(p2, e2, s2);
                  }
                  return o2(String.fromCharCode(P2));
                }
                return o2(String.fromCharCode(c2));
            }
          }
          __name(cl, "cl");
          function us(t2, r2, e2, s2, i2, a2, n2, o2) {
            let c2 = r2, p2;
            return { n: p2, pos: r2 } = Lr(t2, r2, e2, s2, 16, i2, a2, false, o2, !n2), p2 === null && (n2 ? o2.invalidEscapeSequence(c2, e2, s2) : r2 = c2 - 1), { code: p2, pos: r2 };
          }
          __name(us, "us");
          function Lr(t2, r2, e2, s2, i2, a2, n2, o2, c2, p2) {
            let m2 = r2, x2 = i2 === 16 ? Dr.hex : Dr.decBinOct, P2 = i2 === 16 ? yt.hex : i2 === 10 ? yt.dec : i2 === 8 ? yt.oct : yt.bin, b2 = false, O2 = 0;
            for (let R2 = 0, Q = a2 == null ? 1 / 0 : a2; R2 < Q; ++R2) {
              let Z = t2.charCodeAt(r2), X;
              if (Z === 95 && o2 !== "bail") {
                let re = t2.charCodeAt(r2 - 1), $e = t2.charCodeAt(r2 + 1);
                if (o2) {
                  if (Number.isNaN($e) || !P2($e) || x2.has(re) || x2.has($e)) {
                    if (p2)
                      return { n: null, pos: r2 };
                    c2.unexpectedNumericSeparator(r2, e2, s2);
                  }
                } else {
                  if (p2)
                    return { n: null, pos: r2 };
                  c2.numericSeparatorInEscapeSequence(r2, e2, s2);
                }
                ++r2;
                continue;
              }
              if (Z >= 97 ? X = Z - 97 + 10 : Z >= 65 ? X = Z - 65 + 10 : hl(Z) ? X = Z - 48 : X = 1 / 0, X >= i2) {
                if (X <= 9 && p2)
                  return { n: null, pos: r2 };
                if (X <= 9 && c2.invalidDigit(r2, e2, s2, i2))
                  X = 0;
                else if (n2)
                  X = 0, b2 = true;
                else
                  break;
              }
              ++r2, O2 = O2 * i2 + X;
            }
            return r2 === m2 || a2 != null && r2 - m2 !== a2 || b2 ? { n: null, pos: r2 } : { n: O2, pos: r2 };
          }
          __name(Lr, "Lr");
          function Or(t2, r2, e2, s2, i2, a2) {
            let n2 = t2.charCodeAt(r2), o2;
            if (n2 === 123) {
              if (++r2, { code: o2, pos: r2 } = us(t2, r2, e2, s2, t2.indexOf("}", r2) - r2, true, i2, a2), ++r2, o2 !== null && o2 > 1114111)
                if (i2)
                  a2.invalidCodePoint(r2, e2, s2);
                else
                  return { code: null, pos: r2 };
            } else
              ({ code: o2, pos: r2 } = us(t2, r2, e2, s2, 4, false, i2, a2));
            return { code: o2, pos: r2 };
          }
          __name(Or, "Or");
          var pl = ["at"], dl = ["at"];
          function Ze(t2, r2, e2) {
            return new d2(e2, t2 - r2, t2);
          }
          __name(Ze, "Ze");
          var fl = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), ve = /* @__PURE__ */ __name(class {
            constructor(t2) {
              this.type = t2.type, this.value = t2.value, this.start = t2.start, this.end = t2.end, this.loc = new f2(t2.startLoc, t2.endLoc);
            }
          }, "ve"), ml = /* @__PURE__ */ __name(class extends nl {
            constructor(t2, r2) {
              super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (e2, s2, i2, a2) => this.options.errorRecovery ? (this.raise(h3.InvalidDigit, { at: Ze(e2, s2, i2), radix: a2 }), true) : false, numericSeparatorInEscapeSequence: this.errorBuilder(h3.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(h3.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(h3.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(h3.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (e2, s2, i2) => {
                this.recordStrictModeErrors(h3.StrictNumericEscape, { at: Ze(e2, s2, i2) });
              }, unterminated: (e2, s2, i2) => {
                throw this.raise(h3.UnterminatedString, { at: Ze(e2 - 1, s2, i2) });
              } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(h3.StrictNumericEscape), unterminated: (e2, s2, i2) => {
                throw this.raise(h3.UnterminatedTemplate, { at: Ze(e2, s2, i2) });
              } }), this.state = new kr(), this.state.init(t2), this.input = r2, this.length = r2.length, this.isLookahead = false;
            }
            pushToken(t2) {
              this.tokens.length = this.state.tokensLength, this.tokens.push(t2), ++this.state.tokensLength;
            }
            next() {
              this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new ve(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
            }
            eat(t2) {
              return this.match(t2) ? (this.next(), true) : false;
            }
            match(t2) {
              return this.state.type === t2;
            }
            createLookaheadState(t2) {
              return { pos: t2.pos, value: null, type: t2.type, start: t2.start, end: t2.end, context: [this.curContext()], inType: t2.inType, startLoc: t2.startLoc, lastTokEndLoc: t2.lastTokEndLoc, curLine: t2.curLine, lineStart: t2.lineStart, curPosition: t2.curPosition };
            }
            lookahead() {
              let t2 = this.state;
              this.state = this.createLookaheadState(t2), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
              let r2 = this.state;
              return this.state = t2, r2;
            }
            nextTokenStart() {
              return this.nextTokenStartSince(this.state.pos);
            }
            nextTokenStartSince(t2) {
              return hs.lastIndex = t2, hs.test(this.input) ? hs.lastIndex : t2;
            }
            lookaheadCharCode() {
              return this.input.charCodeAt(this.nextTokenStart());
            }
            codePointAtPos(t2) {
              let r2 = this.input.charCodeAt(t2);
              if ((r2 & 64512) === 55296 && ++t2 < this.input.length) {
                let e2 = this.input.charCodeAt(t2);
                (e2 & 64512) === 56320 && (r2 = 65536 + ((r2 & 1023) << 10) + (e2 & 1023));
              }
              return r2;
            }
            setStrict(t2) {
              this.state.strict = t2, t2 && (this.state.strictErrors.forEach((r2) => {
                let [e2, s2] = r2;
                return this.raise(e2, { at: s2 });
              }), this.state.strictErrors.clear());
            }
            curContext() {
              return this.state.context[this.state.context.length - 1];
            }
            nextToken() {
              if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
                this.finishToken(137);
                return;
              }
              this.getTokenFromCode(this.codePointAtPos(this.state.pos));
            }
            skipBlockComment(t2) {
              let r2;
              this.isLookahead || (r2 = this.state.curPosition());
              let e2 = this.state.pos, s2 = this.input.indexOf(t2, e2 + 2);
              if (s2 === -1)
                throw this.raise(h3.UnterminatedComment, { at: this.state.curPosition() });
              for (this.state.pos = s2 + t2.length, mt.lastIndex = e2 + 2; mt.test(this.input) && mt.lastIndex <= s2; )
                ++this.state.curLine, this.state.lineStart = mt.lastIndex;
              if (this.isLookahead)
                return;
              let i2 = { type: "CommentBlock", value: this.input.slice(e2 + 2, s2), start: e2, end: s2 + t2.length, loc: new f2(r2, this.state.curPosition()) };
              return this.options.tokens && this.pushToken(i2), i2;
            }
            skipLineComment(t2) {
              let r2 = this.state.pos, e2;
              this.isLookahead || (e2 = this.state.curPosition());
              let s2 = this.input.charCodeAt(this.state.pos += t2);
              if (this.state.pos < this.length)
                for (; !Qe(s2) && ++this.state.pos < this.length; )
                  s2 = this.input.charCodeAt(this.state.pos);
              if (this.isLookahead)
                return;
              let i2 = this.state.pos, a2 = this.input.slice(r2 + t2, i2), n2 = { type: "CommentLine", value: a2, start: r2, end: i2, loc: new f2(e2, this.state.curPosition()) };
              return this.options.tokens && this.pushToken(n2), n2;
            }
            skipSpace() {
              let t2 = this.state.pos, r2 = [];
              e:
                for (; this.state.pos < this.length; ) {
                  let e2 = this.input.charCodeAt(this.state.pos);
                  switch (e2) {
                    case 32:
                    case 160:
                    case 9:
                      ++this.state.pos;
                      break;
                    case 13:
                      this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                    case 10:
                    case 8232:
                    case 8233:
                      ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                      break;
                    case 47:
                      switch (this.input.charCodeAt(this.state.pos + 1)) {
                        case 42: {
                          let s2 = this.skipBlockComment("*/");
                          s2 !== void 0 && (this.addComment(s2), this.options.attachComment && r2.push(s2));
                          break;
                        }
                        case 47: {
                          let s2 = this.skipLineComment(2);
                          s2 !== void 0 && (this.addComment(s2), this.options.attachComment && r2.push(s2));
                          break;
                        }
                        default:
                          break e;
                      }
                      break;
                    default:
                      if (ll(e2))
                        ++this.state.pos;
                      else if (e2 === 45 && !this.inModule) {
                        let s2 = this.state.pos;
                        if (this.input.charCodeAt(s2 + 1) === 45 && this.input.charCodeAt(s2 + 2) === 62 && (t2 === 0 || this.state.lineStart > t2)) {
                          let i2 = this.skipLineComment(3);
                          i2 !== void 0 && (this.addComment(i2), this.options.attachComment && r2.push(i2));
                        } else
                          break e;
                      } else if (e2 === 60 && !this.inModule) {
                        let s2 = this.state.pos;
                        if (this.input.charCodeAt(s2 + 1) === 33 && this.input.charCodeAt(s2 + 2) === 45 && this.input.charCodeAt(s2 + 3) === 45) {
                          let i2 = this.skipLineComment(4);
                          i2 !== void 0 && (this.addComment(i2), this.options.attachComment && r2.push(i2));
                        } else
                          break e;
                      } else
                        break e;
                  }
                }
              if (r2.length > 0) {
                let e2 = this.state.pos, s2 = { start: t2, end: e2, comments: r2, leadingNode: null, trailingNode: null, containingNode: null };
                this.state.commentStack.push(s2);
              }
            }
            finishToken(t2, r2) {
              this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
              let e2 = this.state.type;
              this.state.type = t2, this.state.value = r2, this.isLookahead || this.updateContext(e2);
            }
            replaceToken(t2) {
              this.state.type = t2, this.updateContext();
            }
            readToken_numberSign() {
              if (this.state.pos === 0 && this.readToken_interpreter())
                return;
              let t2 = this.state.pos + 1, r2 = this.codePointAtPos(t2);
              if (r2 >= 48 && r2 <= 57)
                throw this.raise(h3.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
              if (r2 === 123 || r2 === 91 && this.hasPlugin("recordAndTuple")) {
                if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
                  throw this.raise(r2 === 123 ? h3.RecordExpressionHashIncorrectStartSyntaxType : h3.TupleExpressionHashIncorrectStartSyntaxType, { at: this.state.curPosition() });
                this.state.pos += 2, r2 === 123 ? this.finishToken(7) : this.finishToken(1);
              } else
                fe(r2) ? (++this.state.pos, this.finishToken(136, this.readWord1(r2))) : r2 === 92 ? (++this.state.pos, this.finishToken(136, this.readWord1())) : this.finishOp(27, 1);
            }
            readToken_dot() {
              let t2 = this.input.charCodeAt(this.state.pos + 1);
              if (t2 >= 48 && t2 <= 57) {
                this.readNumber(true);
                return;
              }
              t2 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
            }
            readToken_slash() {
              this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
            }
            readToken_interpreter() {
              if (this.state.pos !== 0 || this.length < 2)
                return false;
              let t2 = this.input.charCodeAt(this.state.pos + 1);
              if (t2 !== 33)
                return false;
              let r2 = this.state.pos;
              for (this.state.pos += 1; !Qe(t2) && ++this.state.pos < this.length; )
                t2 = this.input.charCodeAt(this.state.pos);
              let e2 = this.input.slice(r2 + 2, this.state.pos);
              return this.finishToken(28, e2), true;
            }
            readToken_mult_modulo(t2) {
              let r2 = t2 === 42 ? 55 : 54, e2 = 1, s2 = this.input.charCodeAt(this.state.pos + 1);
              t2 === 42 && s2 === 42 && (e2++, s2 = this.input.charCodeAt(this.state.pos + 2), r2 = 57), s2 === 61 && !this.state.inType && (e2++, r2 = t2 === 37 ? 33 : 30), this.finishOp(r2, e2);
            }
            readToken_pipe_amp(t2) {
              let r2 = this.input.charCodeAt(this.state.pos + 1);
              if (r2 === t2) {
                this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t2 === 124 ? 41 : 42, 2);
                return;
              }
              if (t2 === 124) {
                if (r2 === 62) {
                  this.finishOp(39, 2);
                  return;
                }
                if (this.hasPlugin("recordAndTuple") && r2 === 125) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(h3.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(9);
                  return;
                }
                if (this.hasPlugin("recordAndTuple") && r2 === 93) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(h3.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(4);
                  return;
                }
              }
              if (r2 === 61) {
                this.finishOp(30, 2);
                return;
              }
              this.finishOp(t2 === 124 ? 43 : 45, 1);
            }
            readToken_caret() {
              let t2 = this.input.charCodeAt(this.state.pos + 1);
              if (t2 === 61 && !this.state.inType)
                this.finishOp(32, 2);
              else if (t2 === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }])) {
                if (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94)
                  throw this.unexpected();
              } else
                this.finishOp(44, 1);
            }
            readToken_atSign() {
              this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
            }
            readToken_plus_min(t2) {
              let r2 = this.input.charCodeAt(this.state.pos + 1);
              if (r2 === t2) {
                this.finishOp(34, 2);
                return;
              }
              r2 === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
            }
            readToken_lt() {
              let { pos: t2 } = this.state, r2 = this.input.charCodeAt(t2 + 1);
              if (r2 === 60) {
                if (this.input.charCodeAt(t2 + 2) === 61) {
                  this.finishOp(30, 3);
                  return;
                }
                this.finishOp(51, 2);
                return;
              }
              if (r2 === 61) {
                this.finishOp(49, 2);
                return;
              }
              this.finishOp(47, 1);
            }
            readToken_gt() {
              let { pos: t2 } = this.state, r2 = this.input.charCodeAt(t2 + 1);
              if (r2 === 62) {
                let e2 = this.input.charCodeAt(t2 + 2) === 62 ? 3 : 2;
                if (this.input.charCodeAt(t2 + e2) === 61) {
                  this.finishOp(30, e2 + 1);
                  return;
                }
                this.finishOp(52, e2);
                return;
              }
              if (r2 === 61) {
                this.finishOp(49, 2);
                return;
              }
              this.finishOp(48, 1);
            }
            readToken_eq_excl(t2) {
              let r2 = this.input.charCodeAt(this.state.pos + 1);
              if (r2 === 61) {
                this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
                return;
              }
              if (t2 === 61 && r2 === 62) {
                this.state.pos += 2, this.finishToken(19);
                return;
              }
              this.finishOp(t2 === 61 ? 29 : 35, 1);
            }
            readToken_question() {
              let t2 = this.input.charCodeAt(this.state.pos + 1), r2 = this.input.charCodeAt(this.state.pos + 2);
              t2 === 63 ? r2 === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t2 === 46 && !(r2 >= 48 && r2 <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
            }
            getTokenFromCode(t2) {
              switch (t2) {
                case 46:
                  this.readToken_dot();
                  return;
                case 40:
                  ++this.state.pos, this.finishToken(10);
                  return;
                case 41:
                  ++this.state.pos, this.finishToken(11);
                  return;
                case 59:
                  ++this.state.pos, this.finishToken(13);
                  return;
                case 44:
                  ++this.state.pos, this.finishToken(12);
                  return;
                case 91:
                  if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                      throw this.raise(h3.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                    this.state.pos += 2, this.finishToken(2);
                  } else
                    ++this.state.pos, this.finishToken(0);
                  return;
                case 93:
                  ++this.state.pos, this.finishToken(3);
                  return;
                case 123:
                  if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                      throw this.raise(h3.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                    this.state.pos += 2, this.finishToken(6);
                  } else
                    ++this.state.pos, this.finishToken(5);
                  return;
                case 125:
                  ++this.state.pos, this.finishToken(8);
                  return;
                case 58:
                  this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
                  return;
                case 63:
                  this.readToken_question();
                  return;
                case 96:
                  this.readTemplateToken();
                  return;
                case 48: {
                  let r2 = this.input.charCodeAt(this.state.pos + 1);
                  if (r2 === 120 || r2 === 88) {
                    this.readRadixNumber(16);
                    return;
                  }
                  if (r2 === 111 || r2 === 79) {
                    this.readRadixNumber(8);
                    return;
                  }
                  if (r2 === 98 || r2 === 66) {
                    this.readRadixNumber(2);
                    return;
                  }
                }
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                  this.readNumber(false);
                  return;
                case 34:
                case 39:
                  this.readString(t2);
                  return;
                case 47:
                  this.readToken_slash();
                  return;
                case 37:
                case 42:
                  this.readToken_mult_modulo(t2);
                  return;
                case 124:
                case 38:
                  this.readToken_pipe_amp(t2);
                  return;
                case 94:
                  this.readToken_caret();
                  return;
                case 43:
                case 45:
                  this.readToken_plus_min(t2);
                  return;
                case 60:
                  this.readToken_lt();
                  return;
                case 62:
                  this.readToken_gt();
                  return;
                case 61:
                case 33:
                  this.readToken_eq_excl(t2);
                  return;
                case 126:
                  this.finishOp(36, 1);
                  return;
                case 64:
                  this.readToken_atSign();
                  return;
                case 35:
                  this.readToken_numberSign();
                  return;
                case 92:
                  this.readWord();
                  return;
                default:
                  if (fe(t2)) {
                    this.readWord(t2);
                    return;
                  }
              }
              throw this.raise(h3.InvalidOrUnexpectedToken, { at: this.state.curPosition(), unexpected: String.fromCodePoint(t2) });
            }
            finishOp(t2, r2) {
              let e2 = this.input.slice(this.state.pos, this.state.pos + r2);
              this.state.pos += r2, this.finishToken(t2, e2);
            }
            readRegexp() {
              let t2 = this.state.startLoc, r2 = this.state.start + 1, e2, s2, { pos: i2 } = this.state;
              for (; ; ++i2) {
                if (i2 >= this.length)
                  throw this.raise(h3.UnterminatedRegExp, { at: y2(t2, 1) });
                let c2 = this.input.charCodeAt(i2);
                if (Qe(c2))
                  throw this.raise(h3.UnterminatedRegExp, { at: y2(t2, 1) });
                if (e2)
                  e2 = false;
                else {
                  if (c2 === 91)
                    s2 = true;
                  else if (c2 === 93 && s2)
                    s2 = false;
                  else if (c2 === 47 && !s2)
                    break;
                  e2 = c2 === 92;
                }
              }
              let a2 = this.input.slice(r2, i2);
              ++i2;
              let n2 = "", o2 = /* @__PURE__ */ __name(() => y2(t2, i2 + 2 - r2), "o");
              for (; i2 < this.length; ) {
                let c2 = this.codePointAtPos(i2), p2 = String.fromCharCode(c2);
                if (fl.has(c2))
                  c2 === 118 ? (this.expectPlugin("regexpUnicodeSets", o2()), n2.includes("u") && this.raise(h3.IncompatibleRegExpUVFlags, { at: o2() })) : c2 === 117 && n2.includes("v") && this.raise(h3.IncompatibleRegExpUVFlags, { at: o2() }), n2.includes(p2) && this.raise(h3.DuplicateRegExpFlags, { at: o2() });
                else if (Be(c2) || c2 === 92)
                  this.raise(h3.MalformedRegExpFlags, { at: o2() });
                else
                  break;
                ++i2, n2 += p2;
              }
              this.state.pos = i2, this.finishToken(135, { pattern: a2, flags: n2 });
            }
            readInt(t2, r2) {
              let e2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, { n: i2, pos: a2 } = Lr(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t2, r2, e2, s2, this.errorHandlers_readInt, false);
              return this.state.pos = a2, i2;
            }
            readRadixNumber(t2) {
              let r2 = this.state.curPosition(), e2 = false;
              this.state.pos += 2;
              let s2 = this.readInt(t2);
              s2 == null && this.raise(h3.InvalidDigit, { at: y2(r2, 2), radix: t2 });
              let i2 = this.input.charCodeAt(this.state.pos);
              if (i2 === 110)
                ++this.state.pos, e2 = true;
              else if (i2 === 109)
                throw this.raise(h3.InvalidDecimal, { at: r2 });
              if (fe(this.codePointAtPos(this.state.pos)))
                throw this.raise(h3.NumberIdentifier, { at: this.state.curPosition() });
              if (e2) {
                let a2 = this.input.slice(r2.index, this.state.pos).replace(/[_n]/g, "");
                this.finishToken(133, a2);
                return;
              }
              this.finishToken(132, s2);
            }
            readNumber(t2) {
              let r2 = this.state.pos, e2 = this.state.curPosition(), s2 = false, i2 = false, a2 = false, n2 = false, o2 = false;
              !t2 && this.readInt(10) === null && this.raise(h3.InvalidNumber, { at: this.state.curPosition() });
              let c2 = this.state.pos - r2 >= 2 && this.input.charCodeAt(r2) === 48;
              if (c2) {
                let P2 = this.input.slice(r2, this.state.pos);
                if (this.recordStrictModeErrors(h3.StrictOctalLiteral, { at: e2 }), !this.state.strict) {
                  let b2 = P2.indexOf("_");
                  b2 > 0 && this.raise(h3.ZeroDigitNumericSeparator, { at: y2(e2, b2) });
                }
                o2 = c2 && !/[89]/.test(P2);
              }
              let p2 = this.input.charCodeAt(this.state.pos);
              if (p2 === 46 && !o2 && (++this.state.pos, this.readInt(10), s2 = true, p2 = this.input.charCodeAt(this.state.pos)), (p2 === 69 || p2 === 101) && !o2 && (p2 = this.input.charCodeAt(++this.state.pos), (p2 === 43 || p2 === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(h3.InvalidOrMissingExponent, { at: e2 }), s2 = true, n2 = true, p2 = this.input.charCodeAt(this.state.pos)), p2 === 110 && ((s2 || c2) && this.raise(h3.InvalidBigIntLiteral, { at: e2 }), ++this.state.pos, i2 = true), p2 === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (n2 || c2) && this.raise(h3.InvalidDecimal, { at: e2 }), ++this.state.pos, a2 = true), fe(this.codePointAtPos(this.state.pos)))
                throw this.raise(h3.NumberIdentifier, { at: this.state.curPosition() });
              let m2 = this.input.slice(r2, this.state.pos).replace(/[_mn]/g, "");
              if (i2) {
                this.finishToken(133, m2);
                return;
              }
              if (a2) {
                this.finishToken(134, m2);
                return;
              }
              let x2 = o2 ? parseInt(m2, 8) : parseFloat(m2);
              this.finishToken(132, x2);
            }
            readCodePoint(t2) {
              let { code: r2, pos: e2 } = Or(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t2, this.errorHandlers_readCodePoint);
              return this.state.pos = e2, r2;
            }
            readString(t2) {
              let { str: r2, pos: e2, curLine: s2, lineStart: i2 } = Fr(t2 === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
              this.state.pos = e2 + 1, this.state.lineStart = i2, this.state.curLine = s2, this.finishToken(131, r2);
            }
            readTemplateContinuation() {
              this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
            }
            readTemplateToken() {
              let t2 = this.input[this.state.pos], { str: r2, firstInvalidLoc: e2, pos: s2, curLine: i2, lineStart: a2 } = Fr("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
              this.state.pos = s2 + 1, this.state.lineStart = a2, this.state.curLine = i2, e2 && (this.state.firstInvalidTemplateEscapePos = new d2(e2.curLine, e2.pos - e2.lineStart, e2.pos)), this.input.codePointAt(s2) === 96 ? this.finishToken(24, e2 ? null : t2 + r2 + "`") : (this.state.pos++, this.finishToken(25, e2 ? null : t2 + r2 + "${"));
            }
            recordStrictModeErrors(t2, r2) {
              let { at: e2 } = r2, s2 = e2.index;
              this.state.strict && !this.state.strictErrors.has(s2) ? this.raise(t2, { at: e2 }) : this.state.strictErrors.set(s2, [t2, e2]);
            }
            readWord1(t2) {
              this.state.containsEsc = false;
              let r2 = "", e2 = this.state.pos, s2 = this.state.pos;
              for (t2 !== void 0 && (this.state.pos += t2 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
                let i2 = this.codePointAtPos(this.state.pos);
                if (Be(i2))
                  this.state.pos += i2 <= 65535 ? 1 : 2;
                else if (i2 === 92) {
                  this.state.containsEsc = true, r2 += this.input.slice(s2, this.state.pos);
                  let a2 = this.state.curPosition(), n2 = this.state.pos === e2 ? fe : Be;
                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(h3.MissingUnicodeEscape, { at: this.state.curPosition() }), s2 = this.state.pos - 1;
                    continue;
                  }
                  ++this.state.pos;
                  let o2 = this.readCodePoint(true);
                  o2 !== null && (n2(o2) || this.raise(h3.EscapedCharNotAnIdentifier, { at: a2 }), r2 += String.fromCodePoint(o2)), s2 = this.state.pos;
                } else
                  break;
              }
              return r2 + this.input.slice(s2, this.state.pos);
            }
            readWord(t2) {
              let r2 = this.readWord1(t2), e2 = qt.get(r2);
              e2 !== void 0 ? this.finishToken(e2, Pe(e2)) : this.finishToken(130, r2);
            }
            checkKeywordEscapes() {
              let { type: t2 } = this.state;
              Wt(t2) && this.state.containsEsc && this.raise(h3.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: Pe(t2) });
            }
            raise(t2, r2) {
              let { at: e2 } = r2, s2 = u2(r2, pl), i2 = e2 instanceof d2 ? e2 : e2.loc.start, a2 = t2({ loc: i2, details: s2 });
              if (!this.options.errorRecovery)
                throw a2;
              return this.isLookahead || this.state.errors.push(a2), a2;
            }
            raiseOverwrite(t2, r2) {
              let { at: e2 } = r2, s2 = u2(r2, dl), i2 = e2 instanceof d2 ? e2 : e2.loc.start, a2 = i2.index, n2 = this.state.errors;
              for (let o2 = n2.length - 1; o2 >= 0; o2--) {
                let c2 = n2[o2];
                if (c2.loc.index === a2)
                  return n2[o2] = t2({ loc: i2, details: s2 });
                if (c2.loc.index < a2)
                  break;
              }
              return this.raise(t2, r2);
            }
            updateContext(t2) {
            }
            unexpected(t2, r2) {
              throw this.raise(h3.UnexpectedToken, { expected: r2 ? Pe(r2) : null, at: t2 != null ? t2 : this.state.startLoc });
            }
            expectPlugin(t2, r2) {
              if (this.hasPlugin(t2))
                return true;
              throw this.raise(h3.MissingPlugin, { at: r2 != null ? r2 : this.state.startLoc, missingPlugin: [t2] });
            }
            expectOnePlugin(t2) {
              if (!t2.some((r2) => this.hasPlugin(r2)))
                throw this.raise(h3.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: t2 });
            }
            errorBuilder(t2) {
              return (r2, e2, s2) => {
                this.raise(t2, { at: Ze(r2, e2, s2) });
              };
            }
          }, "ml"), yl = /* @__PURE__ */ __name(class {
            constructor() {
              this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
            }
          }, "yl"), xl = /* @__PURE__ */ __name(class {
            constructor(t2) {
              this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t2;
            }
            current() {
              return this.stack[this.stack.length - 1];
            }
            enter() {
              this.stack.push(new yl());
            }
            exit() {
              let t2 = this.stack.pop(), r2 = this.current();
              for (let [e2, s2] of Array.from(t2.undefinedPrivateNames))
                r2 ? r2.undefinedPrivateNames.has(e2) || r2.undefinedPrivateNames.set(e2, s2) : this.parser.raise(h3.InvalidPrivateFieldResolution, { at: s2, identifierName: e2 });
            }
            declarePrivateName(t2, r2, e2) {
              let { privateNames: s2, loneAccessors: i2, undefinedPrivateNames: a2 } = this.current(), n2 = s2.has(t2);
              if (r2 & is) {
                let o2 = n2 && i2.get(t2);
                if (o2) {
                  let c2 = o2 & ft, p2 = r2 & ft, m2 = o2 & is, x2 = r2 & is;
                  n2 = m2 === x2 || c2 !== p2, n2 || i2.delete(t2);
                } else
                  n2 || i2.set(t2, r2);
              }
              n2 && this.parser.raise(h3.PrivateNameRedeclaration, { at: e2, identifierName: t2 }), s2.add(t2), a2.delete(t2);
            }
            usePrivateName(t2, r2) {
              let e2;
              for (e2 of this.stack)
                if (e2.privateNames.has(t2))
                  return;
              e2 ? e2.undefinedPrivateNames.set(t2, r2) : this.parser.raise(h3.InvalidPrivateFieldResolution, { at: r2, identifierName: t2 });
            }
          }, "xl"), gl = 0, Mr = 1, cs = 2, Br = 3, xt = /* @__PURE__ */ __name(class {
            constructor() {
              let t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : gl;
              this.type = void 0, this.type = t2;
            }
            canBeArrowParameterDeclaration() {
              return this.type === cs || this.type === Mr;
            }
            isCertainlyParameterDeclaration() {
              return this.type === Br;
            }
          }, "xt"), _r = /* @__PURE__ */ __name(class extends xt {
            constructor(t2) {
              super(t2), this.declarationErrors = /* @__PURE__ */ new Map();
            }
            recordDeclarationError(t2, r2) {
              let { at: e2 } = r2, s2 = e2.index;
              this.declarationErrors.set(s2, [t2, e2]);
            }
            clearDeclarationError(t2) {
              this.declarationErrors.delete(t2);
            }
            iterateErrors(t2) {
              this.declarationErrors.forEach(t2);
            }
          }, "_r"), Pl = /* @__PURE__ */ __name(class {
            constructor(t2) {
              this.parser = void 0, this.stack = [new xt()], this.parser = t2;
            }
            enter(t2) {
              this.stack.push(t2);
            }
            exit() {
              this.stack.pop();
            }
            recordParameterInitializerError(t2, r2) {
              let { at: e2 } = r2, s2 = { at: e2.loc.start }, { stack: i2 } = this, a2 = i2.length - 1, n2 = i2[a2];
              for (; !n2.isCertainlyParameterDeclaration(); ) {
                if (n2.canBeArrowParameterDeclaration())
                  n2.recordDeclarationError(t2, s2);
                else
                  return;
                n2 = i2[--a2];
              }
              this.parser.raise(t2, s2);
            }
            recordArrowParemeterBindingError(t2, r2) {
              let { at: e2 } = r2, { stack: s2 } = this, i2 = s2[s2.length - 1], a2 = { at: e2.loc.start };
              if (i2.isCertainlyParameterDeclaration())
                this.parser.raise(t2, a2);
              else if (i2.canBeArrowParameterDeclaration())
                i2.recordDeclarationError(t2, a2);
              else
                return;
            }
            recordAsyncArrowParametersError(t2) {
              let { at: r2 } = t2, { stack: e2 } = this, s2 = e2.length - 1, i2 = e2[s2];
              for (; i2.canBeArrowParameterDeclaration(); )
                i2.type === cs && i2.recordDeclarationError(h3.AwaitBindingIdentifier, { at: r2 }), i2 = e2[--s2];
            }
            validateAsPattern() {
              let { stack: t2 } = this, r2 = t2[t2.length - 1];
              !r2.canBeArrowParameterDeclaration() || r2.iterateErrors((e2) => {
                let [s2, i2] = e2;
                this.parser.raise(s2, { at: i2 });
                let a2 = t2.length - 2, n2 = t2[a2];
                for (; n2.canBeArrowParameterDeclaration(); )
                  n2.clearDeclarationError(i2.index), n2 = t2[--a2];
              });
            }
          }, "Pl");
          function Al() {
            return new xt(Br);
          }
          __name(Al, "Al");
          function Tl() {
            return new _r(Mr);
          }
          __name(Tl, "Tl");
          function vl() {
            return new _r(cs);
          }
          __name(vl, "vl");
          function Rr() {
            return new xt();
          }
          __name(Rr, "Rr");
          var qe = 0, jr = 1, gt = 2, qr = 4, Ue = 8, El = /* @__PURE__ */ __name(class {
            constructor() {
              this.stacks = [];
            }
            enter(t2) {
              this.stacks.push(t2);
            }
            exit() {
              this.stacks.pop();
            }
            currentFlags() {
              return this.stacks[this.stacks.length - 1];
            }
            get hasAwait() {
              return (this.currentFlags() & gt) > 0;
            }
            get hasYield() {
              return (this.currentFlags() & jr) > 0;
            }
            get hasReturn() {
              return (this.currentFlags() & qr) > 0;
            }
            get hasIn() {
              return (this.currentFlags() & Ue) > 0;
            }
          }, "El");
          function Pt(t2, r2) {
            return (t2 ? gt : 0) | (r2 ? jr : 0);
          }
          __name(Pt, "Pt");
          var Cl = /* @__PURE__ */ __name(class extends ml {
            addExtra(t2, r2, e2) {
              let s2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
              if (!t2)
                return;
              let i2 = t2.extra = t2.extra || {};
              s2 ? i2[r2] = e2 : Object.defineProperty(i2, r2, { enumerable: s2, value: e2 });
            }
            isContextual(t2) {
              return this.state.type === t2 && !this.state.containsEsc;
            }
            isUnparsedContextual(t2, r2) {
              let e2 = t2 + r2.length;
              if (this.input.slice(t2, e2) === r2) {
                let s2 = this.input.charCodeAt(e2);
                return !(Be(s2) || (s2 & 64512) === 55296);
              }
              return false;
            }
            isLookaheadContextual(t2) {
              let r2 = this.nextTokenStart();
              return this.isUnparsedContextual(r2, t2);
            }
            eatContextual(t2) {
              return this.isContextual(t2) ? (this.next(), true) : false;
            }
            expectContextual(t2, r2) {
              if (!this.eatContextual(t2))
                throw r2 != null ? this.raise(r2, { at: this.state.startLoc }) : this.unexpected(null, t2);
            }
            canInsertSemicolon() {
              return this.match(137) || this.match(8) || this.hasPrecedingLineBreak();
            }
            hasPrecedingLineBreak() {
              return ls.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
            }
            hasFollowingLineBreak() {
              return Nr.lastIndex = this.state.end, Nr.test(this.input);
            }
            isLineTerminator() {
              return this.eat(13) || this.canInsertSemicolon();
            }
            semicolon() {
              ((arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true) ? this.isLineTerminator() : this.eat(13)) || this.raise(h3.MissingSemicolon, { at: this.state.lastTokEndLoc });
            }
            expect(t2, r2) {
              this.eat(t2) || this.unexpected(r2, t2);
            }
            tryParse(t2) {
              let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.clone(), e2 = { node: null };
              try {
                let s2 = t2(function() {
                  let i2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  throw e2.node = i2, e2;
                });
                if (this.state.errors.length > r2.errors.length) {
                  let i2 = this.state;
                  return this.state = r2, this.state.tokensLength = i2.tokensLength, { node: s2, error: i2.errors[r2.errors.length], thrown: false, aborted: false, failState: i2 };
                }
                return { node: s2, error: null, thrown: false, aborted: false, failState: null };
              } catch (s2) {
                let i2 = this.state;
                if (this.state = r2, s2 instanceof SyntaxError)
                  return { node: null, error: s2, thrown: true, aborted: false, failState: i2 };
                if (s2 === e2)
                  return { node: e2.node, error: null, thrown: false, aborted: true, failState: i2 };
                throw s2;
              }
            }
            checkExpressionErrors(t2, r2) {
              if (!t2)
                return false;
              let { shorthandAssignLoc: e2, doubleProtoLoc: s2, privateKeyLoc: i2, optionalParametersLoc: a2 } = t2, n2 = !!e2 || !!s2 || !!a2 || !!i2;
              if (!r2)
                return n2;
              e2 != null && this.raise(h3.InvalidCoverInitializedName, { at: e2 }), s2 != null && this.raise(h3.DuplicateProto, { at: s2 }), i2 != null && this.raise(h3.UnexpectedPrivateField, { at: i2 }), a2 != null && this.unexpected(a2);
            }
            isLiteralPropertyName() {
              return cr(this.state.type);
            }
            isPrivateName(t2) {
              return t2.type === "PrivateName";
            }
            getPrivateNameSV(t2) {
              return t2.id.name;
            }
            hasPropertyAsPrivateName(t2) {
              return (t2.type === "MemberExpression" || t2.type === "OptionalMemberExpression") && this.isPrivateName(t2.property);
            }
            isOptionalChain(t2) {
              return t2.type === "OptionalMemberExpression" || t2.type === "OptionalCallExpression";
            }
            isObjectProperty(t2) {
              return t2.type === "ObjectProperty";
            }
            isObjectMethod(t2) {
              return t2.type === "ObjectMethod";
            }
            initializeScopes() {
              let t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.sourceType === "module", r2 = this.state.labels;
              this.state.labels = [];
              let e2 = this.exportedIdentifiers;
              this.exportedIdentifiers = /* @__PURE__ */ new Set();
              let s2 = this.inModule;
              this.inModule = t2;
              let i2 = this.scope, a2 = this.getScopeHandler();
              this.scope = new a2(this, t2);
              let n2 = this.prodParam;
              this.prodParam = new El();
              let o2 = this.classScope;
              this.classScope = new xl(this);
              let c2 = this.expressionScope;
              return this.expressionScope = new Pl(this), () => {
                this.state.labels = r2, this.exportedIdentifiers = e2, this.inModule = s2, this.scope = i2, this.prodParam = n2, this.classScope = o2, this.expressionScope = c2;
              };
            }
            enterInitialScopes() {
              let t2 = qe;
              this.inModule && (t2 |= gt), this.scope.enter(Re), this.prodParam.enter(t2);
            }
            checkDestructuringPrivate(t2) {
              let { privateKeyLoc: r2 } = t2;
              r2 !== null && this.expectPlugin("destructuringPrivate", r2);
            }
          }, "Cl"), At = /* @__PURE__ */ __name(class {
            constructor() {
              this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
            }
          }, "At"), Tt = /* @__PURE__ */ __name(class {
            constructor(t2, r2, e2) {
              this.type = "", this.start = r2, this.end = 0, this.loc = new f2(e2), t2 != null && t2.options.ranges && (this.range = [r2, 0]), t2 != null && t2.filename && (this.loc.filename = t2.filename);
            }
          }, "Tt"), ps = Tt.prototype;
          ps.__clone = function() {
            let t2 = new Tt(void 0, this.start, this.loc.start), r2 = Object.keys(this);
            for (let e2 = 0, s2 = r2.length; e2 < s2; e2++) {
              let i2 = r2[e2];
              i2 !== "leadingComments" && i2 !== "trailingComments" && i2 !== "innerComments" && (t2[i2] = this[i2]);
            }
            return t2;
          };
          function bl(t2) {
            return xe(t2);
          }
          __name(bl, "bl");
          function xe(t2) {
            let { type: r2, start: e2, end: s2, loc: i2, range: a2, extra: n2, name: o2 } = t2, c2 = Object.create(ps);
            return c2.type = r2, c2.start = e2, c2.end = s2, c2.loc = i2, c2.range = a2, c2.extra = n2, c2.name = o2, r2 === "Placeholder" && (c2.expectedNode = t2.expectedNode), c2;
          }
          __name(xe, "xe");
          function Sl(t2) {
            let { type: r2, start: e2, end: s2, loc: i2, range: a2, extra: n2 } = t2;
            if (r2 === "Placeholder")
              return bl(t2);
            let o2 = Object.create(ps);
            return o2.type = r2, o2.start = e2, o2.end = s2, o2.loc = i2, o2.range = a2, t2.raw !== void 0 ? o2.raw = t2.raw : o2.extra = n2, o2.value = t2.value, o2;
          }
          __name(Sl, "Sl");
          var wl = /* @__PURE__ */ __name(class extends Cl {
            startNode() {
              return new Tt(this, this.state.start, this.state.startLoc);
            }
            startNodeAt(t2) {
              return new Tt(this, t2.index, t2);
            }
            startNodeAtNode(t2) {
              return this.startNodeAt(t2.loc.start);
            }
            finishNode(t2, r2) {
              return this.finishNodeAt(t2, r2, this.state.lastTokEndLoc);
            }
            finishNodeAt(t2, r2, e2) {
              return t2.type = r2, t2.end = e2.index, t2.loc.end = e2, this.options.ranges && (t2.range[1] = e2.index), this.options.attachComment && this.processComment(t2), t2;
            }
            resetStartLocation(t2, r2) {
              t2.start = r2.index, t2.loc.start = r2, this.options.ranges && (t2.range[0] = r2.index);
            }
            resetEndLocation(t2) {
              let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
              t2.end = r2.index, t2.loc.end = r2, this.options.ranges && (t2.range[1] = r2.index);
            }
            resetStartLocationFromNode(t2, r2) {
              this.resetStartLocation(t2, r2.loc.start);
            }
          }, "wl"), Il = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), D = _2`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: (t2) => {
            let { reservedType: r2 } = t2;
            return `Cannot overwrite reserved type ${r2}.`;
          }, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: (t2) => {
            let { memberName: r2, enumName: e2 } = t2;
            return `Boolean enum members need to be initialized. Use either \`${r2} = true,\` or \`${r2} = false,\` in enum \`${e2}\`.`;
          }, EnumDuplicateMemberName: (t2) => {
            let { memberName: r2, enumName: e2 } = t2;
            return `Enum member names need to be unique, but the name \`${r2}\` has already been used before in enum \`${e2}\`.`;
          }, EnumInconsistentMemberValues: (t2) => {
            let { enumName: r2 } = t2;
            return `Enum \`${r2}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`;
          }, EnumInvalidExplicitType: (t2) => {
            let { invalidEnumType: r2, enumName: e2 } = t2;
            return `Enum type \`${r2}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e2}\`.`;
          }, EnumInvalidExplicitTypeUnknownSupplied: (t2) => {
            let { enumName: r2 } = t2;
            return `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${r2}\`.`;
          }, EnumInvalidMemberInitializerPrimaryType: (t2) => {
            let { enumName: r2, memberName: e2, explicitType: s2 } = t2;
            return `Enum \`${r2}\` has type \`${s2}\`, so the initializer of \`${e2}\` needs to be a ${s2} literal.`;
          }, EnumInvalidMemberInitializerSymbolType: (t2) => {
            let { enumName: r2, memberName: e2 } = t2;
            return `Symbol enum members cannot be initialized. Use \`${e2},\` in enum \`${r2}\`.`;
          }, EnumInvalidMemberInitializerUnknownType: (t2) => {
            let { enumName: r2, memberName: e2 } = t2;
            return `The enum member initializer for \`${e2}\` needs to be a literal (either a boolean, number, or string) in enum \`${r2}\`.`;
          }, EnumInvalidMemberName: (t2) => {
            let { enumName: r2, memberName: e2, suggestion: s2 } = t2;
            return `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${e2}\`, consider using \`${s2}\`, in enum \`${r2}\`.`;
          }, EnumNumberMemberNotInitialized: (t2) => {
            let { enumName: r2, memberName: e2 } = t2;
            return `Number enum members need to be initialized, e.g. \`${e2} = 1\` in enum \`${r2}\`.`;
          }, EnumStringMemberInconsistentlyInitailized: (t2) => {
            let { enumName: r2 } = t2;
            return `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${r2}\`.`;
          }, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: (t2) => {
            let { reservedType: r2 } = t2;
            return `Unexpected reserved type ${r2}.`;
          }, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: (t2) => {
            let { unsupportedExportKind: r2, suggestion: e2 } = t2;
            return `\`declare export ${r2}\` is not supported. Use \`${e2}\` instead.`;
          }, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
          function Nl(t2) {
            return t2.type === "DeclareExportAllDeclaration" || t2.type === "DeclareExportDeclaration" && (!t2.declaration || t2.declaration.type !== "TypeAlias" && t2.declaration.type !== "InterfaceDeclaration");
          }
          __name(Nl, "Nl");
          function ds(t2) {
            return t2.importKind === "type" || t2.importKind === "typeof";
          }
          __name(ds, "ds");
          function Ur(t2) {
            return pe(t2) && t2 !== 97;
          }
          __name(Ur, "Ur");
          var kl = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
          function Dl(t2, r2) {
            let e2 = [], s2 = [];
            for (let i2 = 0; i2 < t2.length; i2++)
              (r2(t2[i2], i2, t2) ? e2 : s2).push(t2[i2]);
            return [e2, s2];
          }
          __name(Dl, "Dl");
          var Fl = /\*?\s*@((?:no)?flow)\b/, Ll = /* @__PURE__ */ __name((t2) => class extends t2 {
            constructor() {
              super(...arguments), this.flowPragma = void 0;
            }
            getScopeHandler() {
              return rl;
            }
            shouldParseTypes() {
              return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
            }
            shouldParseEnums() {
              return !!this.getPluginOption("flow", "enums");
            }
            finishToken(e2, s2) {
              return e2 !== 131 && e2 !== 13 && e2 !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e2, s2);
            }
            addComment(e2) {
              if (this.flowPragma === void 0) {
                let s2 = Fl.exec(e2.value);
                if (s2)
                  if (s2[1] === "flow")
                    this.flowPragma = "flow";
                  else if (s2[1] === "noflow")
                    this.flowPragma = "noflow";
                  else
                    throw new Error("Unexpected flow pragma");
              }
              return super.addComment(e2);
            }
            flowParseTypeInitialiser(e2) {
              let s2 = this.state.inType;
              this.state.inType = true, this.expect(e2 || 14);
              let i2 = this.flowParseType();
              return this.state.inType = s2, i2;
            }
            flowParsePredicate() {
              let e2 = this.startNode(), s2 = this.state.startLoc;
              return this.next(), this.expectContextual(108), this.state.lastTokStart > s2.index + 1 && this.raise(D.UnexpectedSpaceBetweenModuloChecks, { at: s2 }), this.eat(10) ? (e2.value = super.parseExpression(), this.expect(11), this.finishNode(e2, "DeclaredPredicate")) : this.finishNode(e2, "InferredPredicate");
            }
            flowParseTypeAndPredicateInitialiser() {
              let e2 = this.state.inType;
              this.state.inType = true, this.expect(14);
              let s2 = null, i2 = null;
              return this.match(54) ? (this.state.inType = e2, i2 = this.flowParsePredicate()) : (s2 = this.flowParseType(), this.state.inType = e2, this.match(54) && (i2 = this.flowParsePredicate())), [s2, i2];
            }
            flowParseDeclareClass(e2) {
              return this.next(), this.flowParseInterfaceish(e2, true), this.finishNode(e2, "DeclareClass");
            }
            flowParseDeclareFunction(e2) {
              this.next();
              let s2 = e2.id = this.parseIdentifier(), i2 = this.startNode(), a2 = this.startNode();
              this.match(47) ? i2.typeParameters = this.flowParseTypeParameterDeclaration() : i2.typeParameters = null, this.expect(10);
              let n2 = this.flowParseFunctionTypeParams();
              return i2.params = n2.params, i2.rest = n2.rest, i2.this = n2._this, this.expect(11), [i2.returnType, e2.predicate] = this.flowParseTypeAndPredicateInitialiser(), a2.typeAnnotation = this.finishNode(i2, "FunctionTypeAnnotation"), s2.typeAnnotation = this.finishNode(a2, "TypeAnnotation"), this.resetEndLocation(s2), this.semicolon(), this.scope.declareName(e2.id.name, Yo, e2.id.loc.start), this.finishNode(e2, "DeclareFunction");
            }
            flowParseDeclare(e2, s2) {
              if (this.match(80))
                return this.flowParseDeclareClass(e2);
              if (this.match(68))
                return this.flowParseDeclareFunction(e2);
              if (this.match(74))
                return this.flowParseDeclareVariable(e2);
              if (this.eatContextual(125))
                return this.match(16) ? this.flowParseDeclareModuleExports(e2) : (s2 && this.raise(D.NestedDeclareModule, { at: this.state.lastTokStartLoc }), this.flowParseDeclareModule(e2));
              if (this.isContextual(128))
                return this.flowParseDeclareTypeAlias(e2);
              if (this.isContextual(129))
                return this.flowParseDeclareOpaqueType(e2);
              if (this.isContextual(127))
                return this.flowParseDeclareInterface(e2);
              if (this.match(82))
                return this.flowParseDeclareExportDeclaration(e2, s2);
              throw this.unexpected();
            }
            flowParseDeclareVariable(e2) {
              return this.next(), e2.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e2.id.name, dt, e2.id.loc.start), this.semicolon(), this.finishNode(e2, "DeclareVariable");
            }
            flowParseDeclareModule(e2) {
              this.scope.enter(_e), this.match(131) ? e2.id = super.parseExprAtom() : e2.id = this.parseIdentifier();
              let s2 = e2.body = this.startNode(), i2 = s2.body = [];
              for (this.expect(5); !this.match(8); ) {
                let o2 = this.startNode();
                this.match(83) ? (this.next(), !this.isContextual(128) && !this.match(87) && this.raise(D.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }), super.parseImport(o2)) : (this.expectContextual(123, D.UnsupportedStatementInDeclareModule), o2 = this.flowParseDeclare(o2, true)), i2.push(o2);
              }
              this.scope.exit(), this.expect(8), this.finishNode(s2, "BlockStatement");
              let a2 = null, n2 = false;
              return i2.forEach((o2) => {
                Nl(o2) ? (a2 === "CommonJS" && this.raise(D.AmbiguousDeclareModuleKind, { at: o2 }), a2 = "ES") : o2.type === "DeclareModuleExports" && (n2 && this.raise(D.DuplicateDeclareModuleExports, { at: o2 }), a2 === "ES" && this.raise(D.AmbiguousDeclareModuleKind, { at: o2 }), a2 = "CommonJS", n2 = true);
              }), e2.kind = a2 || "CommonJS", this.finishNode(e2, "DeclareModule");
            }
            flowParseDeclareExportDeclaration(e2, s2) {
              if (this.expect(82), this.eat(65))
                return this.match(68) || this.match(80) ? e2.declaration = this.flowParseDeclare(this.startNode()) : (e2.declaration = this.flowParseType(), this.semicolon()), e2.default = true, this.finishNode(e2, "DeclareExportDeclaration");
              if (this.match(75) || this.isLet() || (this.isContextual(128) || this.isContextual(127)) && !s2) {
                let i2 = this.state.value;
                throw this.raise(D.UnsupportedDeclareExportKind, { at: this.state.startLoc, unsupportedExportKind: i2, suggestion: kl[i2] });
              }
              if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(129))
                return e2.declaration = this.flowParseDeclare(this.startNode()), e2.default = false, this.finishNode(e2, "DeclareExportDeclaration");
              if (this.match(55) || this.match(5) || this.isContextual(127) || this.isContextual(128) || this.isContextual(129))
                return e2 = this.parseExport(e2, null), e2.type === "ExportNamedDeclaration" && (e2.type = "ExportDeclaration", e2.default = false, delete e2.exportKind), e2.type = "Declare" + e2.type, e2;
              throw this.unexpected();
            }
            flowParseDeclareModuleExports(e2) {
              return this.next(), this.expectContextual(109), e2.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e2, "DeclareModuleExports");
            }
            flowParseDeclareTypeAlias(e2) {
              this.next();
              let s2 = this.flowParseTypeAlias(e2);
              return s2.type = "DeclareTypeAlias", s2;
            }
            flowParseDeclareOpaqueType(e2) {
              this.next();
              let s2 = this.flowParseOpaqueType(e2, true);
              return s2.type = "DeclareOpaqueType", s2;
            }
            flowParseDeclareInterface(e2) {
              return this.next(), this.flowParseInterfaceish(e2), this.finishNode(e2, "DeclareInterface");
            }
            flowParseInterfaceish(e2) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (e2.id = this.flowParseRestrictedIdentifier(!s2, true), this.scope.declareName(e2.id.name, s2 ? Cr : Ie, e2.id.loc.start), this.match(47) ? e2.typeParameters = this.flowParseTypeParameterDeclaration() : e2.typeParameters = null, e2.extends = [], e2.implements = [], e2.mixins = [], this.eat(81))
                do
                  e2.extends.push(this.flowParseInterfaceExtends());
                while (!s2 && this.eat(12));
              if (this.isContextual(115)) {
                this.next();
                do
                  e2.mixins.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
              }
              if (this.isContextual(111)) {
                this.next();
                do
                  e2.implements.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
              }
              e2.body = this.flowParseObjectType({ allowStatic: s2, allowExact: false, allowSpread: false, allowProto: s2, allowInexact: false });
            }
            flowParseInterfaceExtends() {
              let e2 = this.startNode();
              return e2.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e2.typeParameters = this.flowParseTypeParameterInstantiation() : e2.typeParameters = null, this.finishNode(e2, "InterfaceExtends");
            }
            flowParseInterface(e2) {
              return this.flowParseInterfaceish(e2), this.finishNode(e2, "InterfaceDeclaration");
            }
            checkNotUnderscore(e2) {
              e2 === "_" && this.raise(D.UnexpectedReservedUnderscore, { at: this.state.startLoc });
            }
            checkReservedType(e2, s2, i2) {
              !Il.has(e2) || this.raise(i2 ? D.AssignReservedType : D.UnexpectedReservedType, { at: s2, reservedType: e2 });
            }
            flowParseRestrictedIdentifier(e2, s2) {
              return this.checkReservedType(this.state.value, this.state.startLoc, s2), this.parseIdentifier(e2);
            }
            flowParseTypeAlias(e2) {
              return e2.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e2.id.name, Ie, e2.id.loc.start), this.match(47) ? e2.typeParameters = this.flowParseTypeParameterDeclaration() : e2.typeParameters = null, e2.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e2, "TypeAlias");
            }
            flowParseOpaqueType(e2, s2) {
              return this.expectContextual(128), e2.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e2.id.name, Ie, e2.id.loc.start), this.match(47) ? e2.typeParameters = this.flowParseTypeParameterDeclaration() : e2.typeParameters = null, e2.supertype = null, this.match(14) && (e2.supertype = this.flowParseTypeInitialiser(14)), e2.impltype = null, s2 || (e2.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e2, "OpaqueType");
            }
            flowParseTypeParameter() {
              let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, s2 = this.state.startLoc, i2 = this.startNode(), a2 = this.flowParseVariance(), n2 = this.flowParseTypeAnnotatableIdentifier();
              return i2.name = n2.name, i2.variance = a2, i2.bound = n2.typeAnnotation, this.match(29) ? (this.eat(29), i2.default = this.flowParseType()) : e2 && this.raise(D.MissingTypeParamDefault, { at: s2 }), this.finishNode(i2, "TypeParameter");
            }
            flowParseTypeParameterDeclaration() {
              let e2 = this.state.inType, s2 = this.startNode();
              s2.params = [], this.state.inType = true, this.match(47) || this.match(140) ? this.next() : this.unexpected();
              let i2 = false;
              do {
                let a2 = this.flowParseTypeParameter(i2);
                s2.params.push(a2), a2.default && (i2 = true), this.match(48) || this.expect(12);
              } while (!this.match(48));
              return this.expect(48), this.state.inType = e2, this.finishNode(s2, "TypeParameterDeclaration");
            }
            flowParseTypeParameterInstantiation() {
              let e2 = this.startNode(), s2 = this.state.inType;
              e2.params = [], this.state.inType = true, this.expect(47);
              let i2 = this.state.noAnonFunctionType;
              for (this.state.noAnonFunctionType = false; !this.match(48); )
                e2.params.push(this.flowParseType()), this.match(48) || this.expect(12);
              return this.state.noAnonFunctionType = i2, this.expect(48), this.state.inType = s2, this.finishNode(e2, "TypeParameterInstantiation");
            }
            flowParseTypeParameterInstantiationCallOrNew() {
              let e2 = this.startNode(), s2 = this.state.inType;
              for (e2.params = [], this.state.inType = true, this.expect(47); !this.match(48); )
                e2.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
              return this.expect(48), this.state.inType = s2, this.finishNode(e2, "TypeParameterInstantiation");
            }
            flowParseInterfaceType() {
              let e2 = this.startNode();
              if (this.expectContextual(127), e2.extends = [], this.eat(81))
                do
                  e2.extends.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
              return e2.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e2, "InterfaceTypeAnnotation");
            }
            flowParseObjectPropertyKey() {
              return this.match(132) || this.match(131) ? super.parseExprAtom() : this.parseIdentifier(true);
            }
            flowParseObjectTypeIndexer(e2, s2, i2) {
              return e2.static = s2, this.lookahead().type === 14 ? (e2.id = this.flowParseObjectPropertyKey(), e2.key = this.flowParseTypeInitialiser()) : (e2.id = null, e2.key = this.flowParseType()), this.expect(3), e2.value = this.flowParseTypeInitialiser(), e2.variance = i2, this.finishNode(e2, "ObjectTypeIndexer");
            }
            flowParseObjectTypeInternalSlot(e2, s2) {
              return e2.static = s2, e2.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e2.method = true, e2.optional = false, e2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e2.loc.start))) : (e2.method = false, this.eat(17) && (e2.optional = true), e2.value = this.flowParseTypeInitialiser()), this.finishNode(e2, "ObjectTypeInternalSlot");
            }
            flowParseObjectTypeMethodish(e2) {
              for (e2.params = [], e2.rest = null, e2.typeParameters = null, e2.this = null, this.match(47) && (e2.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e2.this = this.flowParseFunctionTypeParam(true), e2.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
                e2.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
              return this.eat(21) && (e2.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e2.returnType = this.flowParseTypeInitialiser(), this.finishNode(e2, "FunctionTypeAnnotation");
            }
            flowParseObjectTypeCallProperty(e2, s2) {
              let i2 = this.startNode();
              return e2.static = s2, e2.value = this.flowParseObjectTypeMethodish(i2), this.finishNode(e2, "ObjectTypeCallProperty");
            }
            flowParseObjectType(e2) {
              let { allowStatic: s2, allowExact: i2, allowSpread: a2, allowProto: n2, allowInexact: o2 } = e2, c2 = this.state.inType;
              this.state.inType = true;
              let p2 = this.startNode();
              p2.callProperties = [], p2.properties = [], p2.indexers = [], p2.internalSlots = [];
              let m2, x2, P2 = false;
              for (i2 && this.match(6) ? (this.expect(6), m2 = 9, x2 = true) : (this.expect(5), m2 = 8, x2 = false), p2.exact = x2; !this.match(m2); ) {
                let O2 = false, R2 = null, Q = null, Z = this.startNode();
                if (n2 && this.isContextual(116)) {
                  let re = this.lookahead();
                  re.type !== 14 && re.type !== 17 && (this.next(), R2 = this.state.startLoc, s2 = false);
                }
                if (s2 && this.isContextual(104)) {
                  let re = this.lookahead();
                  re.type !== 14 && re.type !== 17 && (this.next(), O2 = true);
                }
                let X = this.flowParseVariance();
                if (this.eat(0))
                  R2 != null && this.unexpected(R2), this.eat(0) ? (X && this.unexpected(X.loc.start), p2.internalSlots.push(this.flowParseObjectTypeInternalSlot(Z, O2))) : p2.indexers.push(this.flowParseObjectTypeIndexer(Z, O2, X));
                else if (this.match(10) || this.match(47))
                  R2 != null && this.unexpected(R2), X && this.unexpected(X.loc.start), p2.callProperties.push(this.flowParseObjectTypeCallProperty(Z, O2));
                else {
                  let re = "init";
                  if (this.isContextual(98) || this.isContextual(103)) {
                    let hh = this.lookahead();
                    cr(hh.type) && (re = this.state.value, this.next());
                  }
                  let $e = this.flowParseObjectTypeProperty(Z, O2, R2, X, re, a2, o2 != null ? o2 : !x2);
                  $e === null ? (P2 = true, Q = this.state.lastTokStartLoc) : p2.properties.push($e);
                }
                this.flowObjectTypeSemicolon(), Q && !this.match(8) && !this.match(9) && this.raise(D.UnexpectedExplicitInexactInObject, { at: Q });
              }
              this.expect(m2), a2 && (p2.inexact = P2);
              let b2 = this.finishNode(p2, "ObjectTypeAnnotation");
              return this.state.inType = c2, b2;
            }
            flowParseObjectTypeProperty(e2, s2, i2, a2, n2, o2, c2) {
              if (this.eat(21))
                return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o2 ? c2 || this.raise(D.InexactInsideExact, { at: this.state.lastTokStartLoc }) : this.raise(D.InexactInsideNonObject, { at: this.state.lastTokStartLoc }), a2 && this.raise(D.InexactVariance, { at: a2 }), null) : (o2 || this.raise(D.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }), i2 != null && this.unexpected(i2), a2 && this.raise(D.SpreadVariance, { at: a2 }), e2.argument = this.flowParseType(), this.finishNode(e2, "ObjectTypeSpreadProperty"));
              {
                e2.key = this.flowParseObjectPropertyKey(), e2.static = s2, e2.proto = i2 != null, e2.kind = n2;
                let p2 = false;
                return this.match(47) || this.match(10) ? (e2.method = true, i2 != null && this.unexpected(i2), a2 && this.unexpected(a2.loc.start), e2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e2.loc.start)), (n2 === "get" || n2 === "set") && this.flowCheckGetterSetterParams(e2), !o2 && e2.key.name === "constructor" && e2.value.this && this.raise(D.ThisParamBannedInConstructor, { at: e2.value.this })) : (n2 !== "init" && this.unexpected(), e2.method = false, this.eat(17) && (p2 = true), e2.value = this.flowParseTypeInitialiser(), e2.variance = a2), e2.optional = p2, this.finishNode(e2, "ObjectTypeProperty");
              }
            }
            flowCheckGetterSetterParams(e2) {
              let s2 = e2.kind === "get" ? 0 : 1, i2 = e2.value.params.length + (e2.value.rest ? 1 : 0);
              e2.value.this && this.raise(e2.kind === "get" ? D.GetterMayNotHaveThisParam : D.SetterMayNotHaveThisParam, { at: e2.value.this }), i2 !== s2 && this.raise(e2.kind === "get" ? h3.BadGetterArity : h3.BadSetterArity, { at: e2 }), e2.kind === "set" && e2.value.rest && this.raise(h3.BadSetterRestParameter, { at: e2 });
            }
            flowObjectTypeSemicolon() {
              !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
            }
            flowParseQualifiedTypeIdentifier(e2, s2) {
              var i2;
              (i2 = e2) != null || (e2 = this.state.startLoc);
              let a2 = s2 || this.flowParseRestrictedIdentifier(true);
              for (; this.eat(16); ) {
                let n2 = this.startNodeAt(e2);
                n2.qualification = a2, n2.id = this.flowParseRestrictedIdentifier(true), a2 = this.finishNode(n2, "QualifiedTypeIdentifier");
              }
              return a2;
            }
            flowParseGenericType(e2, s2) {
              let i2 = this.startNodeAt(e2);
              return i2.typeParameters = null, i2.id = this.flowParseQualifiedTypeIdentifier(e2, s2), this.match(47) && (i2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i2, "GenericTypeAnnotation");
            }
            flowParseTypeofType() {
              let e2 = this.startNode();
              return this.expect(87), e2.argument = this.flowParsePrimaryType(), this.finishNode(e2, "TypeofTypeAnnotation");
            }
            flowParseTupleType() {
              let e2 = this.startNode();
              for (e2.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e2.types.push(this.flowParseType()), !this.match(3)); )
                this.expect(12);
              return this.expect(3), this.finishNode(e2, "TupleTypeAnnotation");
            }
            flowParseFunctionTypeParam(e2) {
              let s2 = null, i2 = false, a2 = null, n2 = this.startNode(), o2 = this.lookahead(), c2 = this.state.type === 78;
              return o2.type === 14 || o2.type === 17 ? (c2 && !e2 && this.raise(D.ThisParamMustBeFirst, { at: n2 }), s2 = this.parseIdentifier(c2), this.eat(17) && (i2 = true, c2 && this.raise(D.ThisParamMayNotBeOptional, { at: n2 })), a2 = this.flowParseTypeInitialiser()) : a2 = this.flowParseType(), n2.name = s2, n2.optional = i2, n2.typeAnnotation = a2, this.finishNode(n2, "FunctionTypeParam");
            }
            reinterpretTypeAsFunctionTypeParam(e2) {
              let s2 = this.startNodeAt(e2.loc.start);
              return s2.name = null, s2.optional = false, s2.typeAnnotation = e2, this.finishNode(s2, "FunctionTypeParam");
            }
            flowParseFunctionTypeParams() {
              let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], s2 = null, i2 = null;
              for (this.match(78) && (i2 = this.flowParseFunctionTypeParam(true), i2.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
                e2.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
              return this.eat(21) && (s2 = this.flowParseFunctionTypeParam(false)), { params: e2, rest: s2, _this: i2 };
            }
            flowIdentToTypeAnnotation(e2, s2, i2) {
              switch (i2.name) {
                case "any":
                  return this.finishNode(s2, "AnyTypeAnnotation");
                case "bool":
                case "boolean":
                  return this.finishNode(s2, "BooleanTypeAnnotation");
                case "mixed":
                  return this.finishNode(s2, "MixedTypeAnnotation");
                case "empty":
                  return this.finishNode(s2, "EmptyTypeAnnotation");
                case "number":
                  return this.finishNode(s2, "NumberTypeAnnotation");
                case "string":
                  return this.finishNode(s2, "StringTypeAnnotation");
                case "symbol":
                  return this.finishNode(s2, "SymbolTypeAnnotation");
                default:
                  return this.checkNotUnderscore(i2.name), this.flowParseGenericType(e2, i2);
              }
            }
            flowParsePrimaryType() {
              let e2 = this.state.startLoc, s2 = this.startNode(), i2, a2, n2 = false, o2 = this.state.noAnonFunctionType;
              switch (this.state.type) {
                case 5:
                  return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
                case 6:
                  return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
                case 0:
                  return this.state.noAnonFunctionType = false, a2 = this.flowParseTupleType(), this.state.noAnonFunctionType = o2, a2;
                case 47:
                  return s2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i2 = this.flowParseFunctionTypeParams(), s2.params = i2.params, s2.rest = i2.rest, s2.this = i2._this, this.expect(11), this.expect(19), s2.returnType = this.flowParseType(), this.finishNode(s2, "FunctionTypeAnnotation");
                case 10:
                  if (this.next(), !this.match(11) && !this.match(21))
                    if ($(this.state.type) || this.match(78)) {
                      let c2 = this.lookahead().type;
                      n2 = c2 !== 17 && c2 !== 14;
                    } else
                      n2 = true;
                  if (n2) {
                    if (this.state.noAnonFunctionType = false, a2 = this.flowParseType(), this.state.noAnonFunctionType = o2, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
                      return this.expect(11), a2;
                    this.eat(12);
                  }
                  return a2 ? i2 = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a2)]) : i2 = this.flowParseFunctionTypeParams(), s2.params = i2.params, s2.rest = i2.rest, s2.this = i2._this, this.expect(11), this.expect(19), s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
                case 131:
                  return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                case 85:
                case 86:
                  return s2.value = this.match(85), this.next(), this.finishNode(s2, "BooleanLiteralTypeAnnotation");
                case 53:
                  if (this.state.value === "-") {
                    if (this.next(), this.match(132))
                      return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s2);
                    if (this.match(133))
                      return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s2);
                    throw this.raise(D.UnexpectedSubtractionOperand, { at: this.state.startLoc });
                  }
                  throw this.unexpected();
                case 132:
                  return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                case 133:
                  return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                case 88:
                  return this.next(), this.finishNode(s2, "VoidTypeAnnotation");
                case 84:
                  return this.next(), this.finishNode(s2, "NullLiteralTypeAnnotation");
                case 78:
                  return this.next(), this.finishNode(s2, "ThisTypeAnnotation");
                case 55:
                  return this.next(), this.finishNode(s2, "ExistsTypeAnnotation");
                case 87:
                  return this.flowParseTypeofType();
                default:
                  if (Wt(this.state.type)) {
                    let c2 = Pe(this.state.type);
                    return this.next(), super.createIdentifier(s2, c2);
                  } else if ($(this.state.type))
                    return this.isContextual(127) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e2, s2, this.parseIdentifier());
              }
              throw this.unexpected();
            }
            flowParsePostfixType() {
              let e2 = this.state.startLoc, s2 = this.flowParsePrimaryType(), i2 = false;
              for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
                let a2 = this.startNodeAt(e2), n2 = this.eat(18);
                i2 = i2 || n2, this.expect(0), !n2 && this.match(3) ? (a2.elementType = s2, this.next(), s2 = this.finishNode(a2, "ArrayTypeAnnotation")) : (a2.objectType = s2, a2.indexType = this.flowParseType(), this.expect(3), i2 ? (a2.optional = n2, s2 = this.finishNode(a2, "OptionalIndexedAccessType")) : s2 = this.finishNode(a2, "IndexedAccessType"));
              }
              return s2;
            }
            flowParsePrefixType() {
              let e2 = this.startNode();
              return this.eat(17) ? (e2.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e2, "NullableTypeAnnotation")) : this.flowParsePostfixType();
            }
            flowParseAnonFunctionWithoutParens() {
              let e2 = this.flowParsePrefixType();
              if (!this.state.noAnonFunctionType && this.eat(19)) {
                let s2 = this.startNodeAt(e2.loc.start);
                return s2.params = [this.reinterpretTypeAsFunctionTypeParam(e2)], s2.rest = null, s2.this = null, s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
              }
              return e2;
            }
            flowParseIntersectionType() {
              let e2 = this.startNode();
              this.eat(45);
              let s2 = this.flowParseAnonFunctionWithoutParens();
              for (e2.types = [s2]; this.eat(45); )
                e2.types.push(this.flowParseAnonFunctionWithoutParens());
              return e2.types.length === 1 ? s2 : this.finishNode(e2, "IntersectionTypeAnnotation");
            }
            flowParseUnionType() {
              let e2 = this.startNode();
              this.eat(43);
              let s2 = this.flowParseIntersectionType();
              for (e2.types = [s2]; this.eat(43); )
                e2.types.push(this.flowParseIntersectionType());
              return e2.types.length === 1 ? s2 : this.finishNode(e2, "UnionTypeAnnotation");
            }
            flowParseType() {
              let e2 = this.state.inType;
              this.state.inType = true;
              let s2 = this.flowParseUnionType();
              return this.state.inType = e2, s2;
            }
            flowParseTypeOrImplicitInstantiation() {
              if (this.state.type === 130 && this.state.value === "_") {
                let e2 = this.state.startLoc, s2 = this.parseIdentifier();
                return this.flowParseGenericType(e2, s2);
              } else
                return this.flowParseType();
            }
            flowParseTypeAnnotation() {
              let e2 = this.startNode();
              return e2.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e2, "TypeAnnotation");
            }
            flowParseTypeAnnotatableIdentifier(e2) {
              let s2 = e2 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
              return this.match(14) && (s2.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s2)), s2;
            }
            typeCastToParameter(e2) {
              return e2.expression.typeAnnotation = e2.typeAnnotation, this.resetEndLocation(e2.expression, e2.typeAnnotation.loc.end), e2.expression;
            }
            flowParseVariance() {
              let e2 = null;
              return this.match(53) ? (e2 = this.startNode(), this.state.value === "+" ? e2.kind = "plus" : e2.kind = "minus", this.next(), this.finishNode(e2, "Variance")) : e2;
            }
            parseFunctionBody(e2, s2) {
              let i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return s2 ? this.forwardNoArrowParamsConversionAt(e2, () => super.parseFunctionBody(e2, true, i2)) : super.parseFunctionBody(e2, false, i2);
            }
            parseFunctionBodyAndFinish(e2, s2) {
              let i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              if (this.match(14)) {
                let a2 = this.startNode();
                [a2.typeAnnotation, e2.predicate] = this.flowParseTypeAndPredicateInitialiser(), e2.returnType = a2.typeAnnotation ? this.finishNode(a2, "TypeAnnotation") : null;
              }
              return super.parseFunctionBodyAndFinish(e2, s2, i2);
            }
            parseStatement(e2, s2) {
              if (this.state.strict && this.isContextual(127)) {
                let a2 = this.lookahead();
                if (pe(a2.type)) {
                  let n2 = this.startNode();
                  return this.next(), this.flowParseInterface(n2);
                }
              } else if (this.shouldParseEnums() && this.isContextual(124)) {
                let a2 = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(a2);
              }
              let i2 = super.parseStatement(e2, s2);
              return this.flowPragma === void 0 && !this.isValidDirective(i2) && (this.flowPragma = null), i2;
            }
            parseExpressionStatement(e2, s2, i2) {
              if (s2.type === "Identifier") {
                if (s2.name === "declare") {
                  if (this.match(80) || $(this.state.type) || this.match(68) || this.match(74) || this.match(82))
                    return this.flowParseDeclare(e2);
                } else if ($(this.state.type)) {
                  if (s2.name === "interface")
                    return this.flowParseInterface(e2);
                  if (s2.name === "type")
                    return this.flowParseTypeAlias(e2);
                  if (s2.name === "opaque")
                    return this.flowParseOpaqueType(e2, false);
                }
              }
              return super.parseExpressionStatement(e2, s2, i2);
            }
            shouldParseExportDeclaration() {
              let { type: e2 } = this.state;
              return pr(e2) || this.shouldParseEnums() && e2 === 124 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
            }
            isExportDefaultSpecifier() {
              let { type: e2 } = this.state;
              return pr(e2) || this.shouldParseEnums() && e2 === 124 ? this.state.containsEsc : super.isExportDefaultSpecifier();
            }
            parseExportDefaultExpression() {
              if (this.shouldParseEnums() && this.isContextual(124)) {
                let e2 = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(e2);
              }
              return super.parseExportDefaultExpression();
            }
            parseConditional(e2, s2, i2) {
              if (!this.match(17))
                return e2;
              if (this.state.maybeInArrowParameters) {
                let P2 = this.lookaheadCharCode();
                if (P2 === 44 || P2 === 61 || P2 === 58 || P2 === 41)
                  return this.setOptionalParametersError(i2), e2;
              }
              this.expect(17);
              let a2 = this.state.clone(), n2 = this.state.noArrowAt, o2 = this.startNodeAt(s2), { consequent: c2, failed: p2 } = this.tryParseConditionalConsequent(), [m2, x2] = this.getArrowLikeExpressions(c2);
              if (p2 || x2.length > 0) {
                let P2 = [...n2];
                if (x2.length > 0) {
                  this.state = a2, this.state.noArrowAt = P2;
                  for (let b2 = 0; b2 < x2.length; b2++)
                    P2.push(x2[b2].start);
                  ({ consequent: c2, failed: p2 } = this.tryParseConditionalConsequent()), [m2, x2] = this.getArrowLikeExpressions(c2);
                }
                p2 && m2.length > 1 && this.raise(D.AmbiguousConditionalArrow, { at: a2.startLoc }), p2 && m2.length === 1 && (this.state = a2, P2.push(m2[0].start), this.state.noArrowAt = P2, { consequent: c2, failed: p2 } = this.tryParseConditionalConsequent());
              }
              return this.getArrowLikeExpressions(c2, true), this.state.noArrowAt = n2, this.expect(14), o2.test = e2, o2.consequent = c2, o2.alternate = this.forwardNoArrowParamsConversionAt(o2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o2, "ConditionalExpression");
            }
            tryParseConditionalConsequent() {
              this.state.noArrowParamsConversionAt.push(this.state.start);
              let e2 = this.parseMaybeAssignAllowIn(), s2 = !this.match(14);
              return this.state.noArrowParamsConversionAt.pop(), { consequent: e2, failed: s2 };
            }
            getArrowLikeExpressions(e2, s2) {
              let i2 = [e2], a2 = [];
              for (; i2.length !== 0; ) {
                let n2 = i2.pop();
                n2.type === "ArrowFunctionExpression" ? (n2.typeParameters || !n2.returnType ? this.finishArrowValidation(n2) : a2.push(n2), i2.push(n2.body)) : n2.type === "ConditionalExpression" && (i2.push(n2.consequent), i2.push(n2.alternate));
              }
              return s2 ? (a2.forEach((n2) => this.finishArrowValidation(n2)), [a2, []]) : Dl(a2, (n2) => n2.params.every((o2) => this.isAssignable(o2, true)));
            }
            finishArrowValidation(e2) {
              var s2;
              this.toAssignableList(e2.params, (s2 = e2.extra) == null ? void 0 : s2.trailingCommaLoc, false), this.scope.enter(me | Yt), super.checkParams(e2, false, true), this.scope.exit();
            }
            forwardNoArrowParamsConversionAt(e2, s2) {
              let i2;
              return this.state.noArrowParamsConversionAt.indexOf(e2.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), i2 = s2(), this.state.noArrowParamsConversionAt.pop()) : i2 = s2(), i2;
            }
            parseParenItem(e2, s2) {
              if (e2 = super.parseParenItem(e2, s2), this.eat(17) && (e2.optional = true, this.resetEndLocation(e2)), this.match(14)) {
                let i2 = this.startNodeAt(s2);
                return i2.expression = e2, i2.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i2, "TypeCastExpression");
              }
              return e2;
            }
            assertModuleNodeAllowed(e2) {
              e2.type === "ImportDeclaration" && (e2.importKind === "type" || e2.importKind === "typeof") || e2.type === "ExportNamedDeclaration" && e2.exportKind === "type" || e2.type === "ExportAllDeclaration" && e2.exportKind === "type" || super.assertModuleNodeAllowed(e2);
            }
            parseExport(e2, s2) {
              let i2 = super.parseExport(e2, s2);
              return (i2.type === "ExportNamedDeclaration" || i2.type === "ExportAllDeclaration") && (i2.exportKind = i2.exportKind || "value"), i2;
            }
            parseExportDeclaration(e2) {
              if (this.isContextual(128)) {
                e2.exportKind = "type";
                let s2 = this.startNode();
                return this.next(), this.match(5) ? (e2.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e2), null) : this.flowParseTypeAlias(s2);
              } else if (this.isContextual(129)) {
                e2.exportKind = "type";
                let s2 = this.startNode();
                return this.next(), this.flowParseOpaqueType(s2, false);
              } else if (this.isContextual(127)) {
                e2.exportKind = "type";
                let s2 = this.startNode();
                return this.next(), this.flowParseInterface(s2);
              } else if (this.shouldParseEnums() && this.isContextual(124)) {
                e2.exportKind = "value";
                let s2 = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(s2);
              } else
                return super.parseExportDeclaration(e2);
            }
            eatExportStar(e2) {
              return super.eatExportStar(e2) ? true : this.isContextual(128) && this.lookahead().type === 55 ? (e2.exportKind = "type", this.next(), this.next(), true) : false;
            }
            maybeParseExportNamespaceSpecifier(e2) {
              let { startLoc: s2 } = this.state, i2 = super.maybeParseExportNamespaceSpecifier(e2);
              return i2 && e2.exportKind === "type" && this.unexpected(s2), i2;
            }
            parseClassId(e2, s2, i2) {
              super.parseClassId(e2, s2, i2), this.match(47) && (e2.typeParameters = this.flowParseTypeParameterDeclaration());
            }
            parseClassMember(e2, s2, i2) {
              let { startLoc: a2 } = this.state;
              if (this.isContextual(123)) {
                if (super.parseClassMemberFromModifier(e2, s2))
                  return;
                s2.declare = true;
              }
              super.parseClassMember(e2, s2, i2), s2.declare && (s2.type !== "ClassProperty" && s2.type !== "ClassPrivateProperty" && s2.type !== "PropertyDefinition" ? this.raise(D.DeclareClassElement, { at: a2 }) : s2.value && this.raise(D.DeclareClassFieldInitializer, { at: s2.value }));
            }
            isIterator(e2) {
              return e2 === "iterator" || e2 === "asyncIterator";
            }
            readIterator() {
              let e2 = super.readWord1(), s2 = "@@" + e2;
              (!this.isIterator(e2) || !this.state.inType) && this.raise(h3.InvalidIdentifier, { at: this.state.curPosition(), identifierName: s2 }), this.finishToken(130, s2);
            }
            getTokenFromCode(e2) {
              let s2 = this.input.charCodeAt(this.state.pos + 1);
              return e2 === 123 && s2 === 124 ? this.finishOp(6, 2) : this.state.inType && (e2 === 62 || e2 === 60) ? this.finishOp(e2 === 62 ? 48 : 47, 1) : this.state.inType && e2 === 63 ? s2 === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : $o(e2, s2, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e2);
            }
            isAssignable(e2, s2) {
              return e2.type === "TypeCastExpression" ? this.isAssignable(e2.expression, s2) : super.isAssignable(e2, s2);
            }
            toAssignable(e2) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              !s2 && e2.type === "AssignmentExpression" && e2.left.type === "TypeCastExpression" && (e2.left = this.typeCastToParameter(e2.left)), super.toAssignable(e2, s2);
            }
            toAssignableList(e2, s2, i2) {
              for (let a2 = 0; a2 < e2.length; a2++) {
                let n2 = e2[a2];
                (n2 == null ? void 0 : n2.type) === "TypeCastExpression" && (e2[a2] = this.typeCastToParameter(n2));
              }
              super.toAssignableList(e2, s2, i2);
            }
            toReferencedList(e2, s2) {
              for (let a2 = 0; a2 < e2.length; a2++) {
                var i2;
                let n2 = e2[a2];
                n2 && n2.type === "TypeCastExpression" && !((i2 = n2.extra) != null && i2.parenthesized) && (e2.length > 1 || !s2) && this.raise(D.TypeCastInPattern, { at: n2.typeAnnotation });
              }
              return e2;
            }
            parseArrayLike(e2, s2, i2, a2) {
              let n2 = super.parseArrayLike(e2, s2, i2, a2);
              return s2 && !this.state.maybeInArrowParameters && this.toReferencedList(n2.elements), n2;
            }
            isValidLVal(e2, s2, i2) {
              return e2 === "TypeCastExpression" || super.isValidLVal(e2, s2, i2);
            }
            parseClassProperty(e2) {
              return this.match(14) && (e2.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e2);
            }
            parseClassPrivateProperty(e2) {
              return this.match(14) && (e2.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e2);
            }
            isClassMethod() {
              return this.match(47) || super.isClassMethod();
            }
            isClassProperty() {
              return this.match(14) || super.isClassProperty();
            }
            isNonstaticConstructor(e2) {
              return !this.match(14) && super.isNonstaticConstructor(e2);
            }
            pushClassMethod(e2, s2, i2, a2, n2, o2) {
              if (s2.variance && this.unexpected(s2.variance.loc.start), delete s2.variance, this.match(47) && (s2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e2, s2, i2, a2, n2, o2), s2.params && n2) {
                let c2 = s2.params;
                c2.length > 0 && this.isThisParam(c2[0]) && this.raise(D.ThisParamBannedInConstructor, { at: s2 });
              } else if (s2.type === "MethodDefinition" && n2 && s2.value.params) {
                let c2 = s2.value.params;
                c2.length > 0 && this.isThisParam(c2[0]) && this.raise(D.ThisParamBannedInConstructor, { at: s2 });
              }
            }
            pushClassPrivateMethod(e2, s2, i2, a2) {
              s2.variance && this.unexpected(s2.variance.loc.start), delete s2.variance, this.match(47) && (s2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e2, s2, i2, a2);
            }
            parseClassSuper(e2) {
              if (super.parseClassSuper(e2), e2.superClass && this.match(47) && (e2.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(111)) {
                this.next();
                let s2 = e2.implements = [];
                do {
                  let i2 = this.startNode();
                  i2.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? i2.typeParameters = this.flowParseTypeParameterInstantiation() : i2.typeParameters = null, s2.push(this.finishNode(i2, "ClassImplements"));
                } while (this.eat(12));
              }
            }
            checkGetterSetterParams(e2) {
              super.checkGetterSetterParams(e2);
              let s2 = this.getObjectOrClassMethodParams(e2);
              if (s2.length > 0) {
                let i2 = s2[0];
                this.isThisParam(i2) && e2.kind === "get" ? this.raise(D.GetterMayNotHaveThisParam, { at: i2 }) : this.isThisParam(i2) && this.raise(D.SetterMayNotHaveThisParam, { at: i2 });
              }
            }
            parsePropertyNamePrefixOperator(e2) {
              e2.variance = this.flowParseVariance();
            }
            parseObjPropValue(e2, s2, i2, a2, n2, o2, c2) {
              e2.variance && this.unexpected(e2.variance.loc.start), delete e2.variance;
              let p2;
              this.match(47) && !o2 && (p2 = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
              let m2 = super.parseObjPropValue(e2, s2, i2, a2, n2, o2, c2);
              return p2 && ((m2.value || m2).typeParameters = p2), m2;
            }
            parseAssignableListItemTypes(e2) {
              return this.eat(17) && (e2.type !== "Identifier" && this.raise(D.PatternIsOptional, { at: e2 }), this.isThisParam(e2) && this.raise(D.ThisParamMayNotBeOptional, { at: e2 }), e2.optional = true), this.match(14) ? e2.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e2) && this.raise(D.ThisParamAnnotationRequired, { at: e2 }), this.match(29) && this.isThisParam(e2) && this.raise(D.ThisParamNoDefault, { at: e2 }), this.resetEndLocation(e2), e2;
            }
            parseMaybeDefault(e2, s2) {
              let i2 = super.parseMaybeDefault(e2, s2);
              return i2.type === "AssignmentPattern" && i2.typeAnnotation && i2.right.start < i2.typeAnnotation.start && this.raise(D.TypeBeforeInitializer, { at: i2.typeAnnotation }), i2;
            }
            shouldParseDefaultImport(e2) {
              return ds(e2) ? Ur(this.state.type) : super.shouldParseDefaultImport(e2);
            }
            checkImportReflection(e2) {
              super.checkImportReflection(e2), e2.module && e2.importKind !== "value" && this.raise(D.ImportReflectionHasImportType, { at: e2.specifiers[0].loc.start });
            }
            parseImportSpecifierLocal(e2, s2, i2) {
              s2.local = ds(e2) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e2.specifiers.push(this.finishImportSpecifier(s2, i2));
            }
            maybeParseDefaultImportSpecifier(e2) {
              e2.importKind = "value";
              let s2 = null;
              if (this.match(87) ? s2 = "typeof" : this.isContextual(128) && (s2 = "type"), s2) {
                let i2 = this.lookahead(), { type: a2 } = i2;
                s2 === "type" && a2 === 55 && this.unexpected(null, i2.type), (Ur(a2) || a2 === 5 || a2 === 55) && (this.next(), e2.importKind = s2);
              }
              return super.maybeParseDefaultImportSpecifier(e2);
            }
            parseImportSpecifier(e2, s2, i2, a2, n2) {
              let o2 = e2.imported, c2 = null;
              o2.type === "Identifier" && (o2.name === "type" ? c2 = "type" : o2.name === "typeof" && (c2 = "typeof"));
              let p2 = false;
              if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
                let x2 = this.parseIdentifier(true);
                c2 !== null && !pe(this.state.type) ? (e2.imported = x2, e2.importKind = c2, e2.local = xe(x2)) : (e2.imported = o2, e2.importKind = null, e2.local = this.parseIdentifier());
              } else {
                if (c2 !== null && pe(this.state.type))
                  e2.imported = this.parseIdentifier(true), e2.importKind = c2;
                else {
                  if (s2)
                    throw this.raise(h3.ImportBindingIsString, { at: e2, importName: o2.value });
                  e2.imported = o2, e2.importKind = null;
                }
                this.eatContextual(93) ? e2.local = this.parseIdentifier() : (p2 = true, e2.local = xe(e2.imported));
              }
              let m2 = ds(e2);
              return i2 && m2 && this.raise(D.ImportTypeShorthandOnlyInPureImport, { at: e2 }), (i2 || m2) && this.checkReservedType(e2.local.name, e2.local.loc.start, true), p2 && !i2 && !m2 && this.checkReservedWord(e2.local.name, e2.loc.start, true, true), this.finishImportSpecifier(e2, "ImportSpecifier");
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case 78:
                  return this.parseIdentifier(true);
                default:
                  return super.parseBindingAtom();
              }
            }
            parseFunctionParams(e2, s2) {
              let i2 = e2.kind;
              i2 !== "get" && i2 !== "set" && this.match(47) && (e2.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e2, s2);
            }
            parseVarId(e2, s2) {
              super.parseVarId(e2, s2), this.match(14) && (e2.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e2.id));
            }
            parseAsyncArrowFromCallExpression(e2, s2) {
              if (this.match(14)) {
                let i2 = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true, e2.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i2;
              }
              return super.parseAsyncArrowFromCallExpression(e2, s2);
            }
            shouldParseAsyncArrow() {
              return this.match(14) || super.shouldParseAsyncArrow();
            }
            parseMaybeAssign(e2, s2) {
              var i2;
              let a2 = null, n2;
              if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                if (a2 = this.state.clone(), n2 = this.tryParse(() => super.parseMaybeAssign(e2, s2), a2), !n2.error)
                  return n2.node;
                let { context: p2 } = this.state, m2 = p2[p2.length - 1];
                (m2 === H.j_oTag || m2 === H.j_expr) && p2.pop();
              }
              if ((i2 = n2) != null && i2.error || this.match(47)) {
                var o2, c2;
                a2 = a2 || this.state.clone();
                let p2, m2 = this.tryParse((P2) => {
                  var b2;
                  p2 = this.flowParseTypeParameterDeclaration();
                  let O2 = this.forwardNoArrowParamsConversionAt(p2, () => {
                    let Q = super.parseMaybeAssign(e2, s2);
                    return this.resetStartLocationFromNode(Q, p2), Q;
                  });
                  (b2 = O2.extra) != null && b2.parenthesized && P2();
                  let R2 = this.maybeUnwrapTypeCastExpression(O2);
                  return R2.type !== "ArrowFunctionExpression" && P2(), R2.typeParameters = p2, this.resetStartLocationFromNode(R2, p2), O2;
                }, a2), x2 = null;
                if (m2.node && this.maybeUnwrapTypeCastExpression(m2.node).type === "ArrowFunctionExpression") {
                  if (!m2.error && !m2.aborted)
                    return m2.node.async && this.raise(D.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: p2 }), m2.node;
                  x2 = m2.node;
                }
                if ((o2 = n2) != null && o2.node)
                  return this.state = n2.failState, n2.node;
                if (x2)
                  return this.state = m2.failState, x2;
                throw (c2 = n2) != null && c2.thrown ? n2.error : m2.thrown ? m2.error : this.raise(D.UnexpectedTokenAfterTypeParameter, { at: p2 });
              }
              return super.parseMaybeAssign(e2, s2);
            }
            parseArrow(e2) {
              if (this.match(14)) {
                let s2 = this.tryParse(() => {
                  let i2 = this.state.noAnonFunctionType;
                  this.state.noAnonFunctionType = true;
                  let a2 = this.startNode();
                  return [a2.typeAnnotation, e2.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i2, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), a2;
                });
                if (s2.thrown)
                  return null;
                s2.error && (this.state = s2.failState), e2.returnType = s2.node.typeAnnotation ? this.finishNode(s2.node, "TypeAnnotation") : null;
              }
              return super.parseArrow(e2);
            }
            shouldParseArrow(e2) {
              return this.match(14) || super.shouldParseArrow(e2);
            }
            setArrowFunctionParameters(e2, s2) {
              this.state.noArrowParamsConversionAt.indexOf(e2.start) !== -1 ? e2.params = s2 : super.setArrowFunctionParameters(e2, s2);
            }
            checkParams(e2, s2, i2) {
              let a2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
              if (!(i2 && this.state.noArrowParamsConversionAt.indexOf(e2.start) !== -1)) {
                for (let n2 = 0; n2 < e2.params.length; n2++)
                  this.isThisParam(e2.params[n2]) && n2 > 0 && this.raise(D.ThisParamMustBeFirst, { at: e2.params[n2] });
                return super.checkParams(e2, s2, i2, a2);
              }
            }
            parseParenAndDistinguishExpression(e2) {
              return super.parseParenAndDistinguishExpression(e2 && this.state.noArrowAt.indexOf(this.state.start) === -1);
            }
            parseSubscripts(e2, s2, i2) {
              if (e2.type === "Identifier" && e2.name === "async" && this.state.noArrowAt.indexOf(s2.index) !== -1) {
                this.next();
                let a2 = this.startNodeAt(s2);
                a2.callee = e2, a2.arguments = super.parseCallExpressionArguments(11, false), e2 = this.finishNode(a2, "CallExpression");
              } else if (e2.type === "Identifier" && e2.name === "async" && this.match(47)) {
                let a2 = this.state.clone(), n2 = this.tryParse((c2) => this.parseAsyncArrowWithTypeParameters(s2) || c2(), a2);
                if (!n2.error && !n2.aborted)
                  return n2.node;
                let o2 = this.tryParse(() => super.parseSubscripts(e2, s2, i2), a2);
                if (o2.node && !o2.error)
                  return o2.node;
                if (n2.node)
                  return this.state = n2.failState, n2.node;
                if (o2.node)
                  return this.state = o2.failState, o2.node;
                throw n2.error || o2.error;
              }
              return super.parseSubscripts(e2, s2, i2);
            }
            parseSubscript(e2, s2, i2, a2) {
              if (this.match(18) && this.isLookaheadToken_lt()) {
                if (a2.optionalChainMember = true, i2)
                  return a2.stop = true, e2;
                this.next();
                let n2 = this.startNodeAt(s2);
                return n2.callee = e2, n2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), n2.arguments = this.parseCallExpressionArguments(11, false), n2.optional = true, this.finishCallExpression(n2, true);
              } else if (!i2 && this.shouldParseTypes() && this.match(47)) {
                let n2 = this.startNodeAt(s2);
                n2.callee = e2;
                let o2 = this.tryParse(() => (n2.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n2.arguments = super.parseCallExpressionArguments(11, false), a2.optionalChainMember && (n2.optional = false), this.finishCallExpression(n2, a2.optionalChainMember)));
                if (o2.node)
                  return o2.error && (this.state = o2.failState), o2.node;
              }
              return super.parseSubscript(e2, s2, i2, a2);
            }
            parseNewCallee(e2) {
              super.parseNewCallee(e2);
              let s2 = null;
              this.shouldParseTypes() && this.match(47) && (s2 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e2.typeArguments = s2;
            }
            parseAsyncArrowWithTypeParameters(e2) {
              let s2 = this.startNodeAt(e2);
              if (this.parseFunctionParams(s2), !!this.parseArrow(s2))
                return super.parseArrowExpression(s2, void 0, true);
            }
            readToken_mult_modulo(e2) {
              let s2 = this.input.charCodeAt(this.state.pos + 1);
              if (e2 === 42 && s2 === 47 && this.state.hasFlowComment) {
                this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
                return;
              }
              super.readToken_mult_modulo(e2);
            }
            readToken_pipe_amp(e2) {
              let s2 = this.input.charCodeAt(this.state.pos + 1);
              if (e2 === 124 && s2 === 125) {
                this.finishOp(9, 2);
                return;
              }
              super.readToken_pipe_amp(e2);
            }
            parseTopLevel(e2, s2) {
              let i2 = super.parseTopLevel(e2, s2);
              return this.state.hasFlowComment && this.raise(D.UnterminatedFlowComment, { at: this.state.curPosition() }), i2;
            }
            skipBlockComment() {
              if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                if (this.state.hasFlowComment)
                  throw this.raise(D.NestedFlowComment, { at: this.state.startLoc });
                this.hasFlowCommentCompletion();
                let e2 = this.skipFlowComment();
                e2 && (this.state.pos += e2, this.state.hasFlowComment = true);
                return;
              }
              return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
            }
            skipFlowComment() {
              let { pos: e2 } = this.state, s2 = 2;
              for (; [32, 9].includes(this.input.charCodeAt(e2 + s2)); )
                s2++;
              let i2 = this.input.charCodeAt(s2 + e2), a2 = this.input.charCodeAt(s2 + e2 + 1);
              return i2 === 58 && a2 === 58 ? s2 + 2 : this.input.slice(s2 + e2, s2 + e2 + 12) === "flow-include" ? s2 + 12 : i2 === 58 && a2 !== 58 ? s2 : false;
            }
            hasFlowCommentCompletion() {
              if (this.input.indexOf("*/", this.state.pos) === -1)
                throw this.raise(h3.UnterminatedComment, { at: this.state.curPosition() });
            }
            flowEnumErrorBooleanMemberNotInitialized(e2, s2) {
              let { enumName: i2, memberName: a2 } = s2;
              this.raise(D.EnumBooleanMemberNotInitialized, { at: e2, memberName: a2, enumName: i2 });
            }
            flowEnumErrorInvalidMemberInitializer(e2, s2) {
              return this.raise(s2.explicitType ? s2.explicitType === "symbol" ? D.EnumInvalidMemberInitializerSymbolType : D.EnumInvalidMemberInitializerPrimaryType : D.EnumInvalidMemberInitializerUnknownType, Object.assign({ at: e2 }, s2));
            }
            flowEnumErrorNumberMemberNotInitialized(e2, s2) {
              let { enumName: i2, memberName: a2 } = s2;
              this.raise(D.EnumNumberMemberNotInitialized, { at: e2, enumName: i2, memberName: a2 });
            }
            flowEnumErrorStringMemberInconsistentlyInitailized(e2, s2) {
              let { enumName: i2 } = s2;
              this.raise(D.EnumStringMemberInconsistentlyInitailized, { at: e2, enumName: i2 });
            }
            flowEnumMemberInit() {
              let e2 = this.state.startLoc, s2 = /* @__PURE__ */ __name(() => this.match(12) || this.match(8), "s");
              switch (this.state.type) {
                case 132: {
                  let i2 = this.parseNumericLiteral(this.state.value);
                  return s2() ? { type: "number", loc: i2.loc.start, value: i2 } : { type: "invalid", loc: e2 };
                }
                case 131: {
                  let i2 = this.parseStringLiteral(this.state.value);
                  return s2() ? { type: "string", loc: i2.loc.start, value: i2 } : { type: "invalid", loc: e2 };
                }
                case 85:
                case 86: {
                  let i2 = this.parseBooleanLiteral(this.match(85));
                  return s2() ? { type: "boolean", loc: i2.loc.start, value: i2 } : { type: "invalid", loc: e2 };
                }
                default:
                  return { type: "invalid", loc: e2 };
              }
            }
            flowEnumMemberRaw() {
              let e2 = this.state.startLoc, s2 = this.parseIdentifier(true), i2 = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e2 };
              return { id: s2, init: i2 };
            }
            flowEnumCheckExplicitTypeMismatch(e2, s2, i2) {
              let { explicitType: a2 } = s2;
              a2 !== null && a2 !== i2 && this.flowEnumErrorInvalidMemberInitializer(e2, s2);
            }
            flowEnumMembers(e2) {
              let { enumName: s2, explicitType: i2 } = e2, a2 = /* @__PURE__ */ new Set(), n2 = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, o2 = false;
              for (; !this.match(8); ) {
                if (this.eat(21)) {
                  o2 = true;
                  break;
                }
                let c2 = this.startNode(), { id: p2, init: m2 } = this.flowEnumMemberRaw(), x2 = p2.name;
                if (x2 === "")
                  continue;
                /^[a-z]/.test(x2) && this.raise(D.EnumInvalidMemberName, { at: p2, memberName: x2, suggestion: x2[0].toUpperCase() + x2.slice(1), enumName: s2 }), a2.has(x2) && this.raise(D.EnumDuplicateMemberName, { at: p2, memberName: x2, enumName: s2 }), a2.add(x2);
                let P2 = { enumName: s2, explicitType: i2, memberName: x2 };
                switch (c2.id = p2, m2.type) {
                  case "boolean": {
                    this.flowEnumCheckExplicitTypeMismatch(m2.loc, P2, "boolean"), c2.init = m2.value, n2.booleanMembers.push(this.finishNode(c2, "EnumBooleanMember"));
                    break;
                  }
                  case "number": {
                    this.flowEnumCheckExplicitTypeMismatch(m2.loc, P2, "number"), c2.init = m2.value, n2.numberMembers.push(this.finishNode(c2, "EnumNumberMember"));
                    break;
                  }
                  case "string": {
                    this.flowEnumCheckExplicitTypeMismatch(m2.loc, P2, "string"), c2.init = m2.value, n2.stringMembers.push(this.finishNode(c2, "EnumStringMember"));
                    break;
                  }
                  case "invalid":
                    throw this.flowEnumErrorInvalidMemberInitializer(m2.loc, P2);
                  case "none":
                    switch (i2) {
                      case "boolean":
                        this.flowEnumErrorBooleanMemberNotInitialized(m2.loc, P2);
                        break;
                      case "number":
                        this.flowEnumErrorNumberMemberNotInitialized(m2.loc, P2);
                        break;
                      default:
                        n2.defaultedMembers.push(this.finishNode(c2, "EnumDefaultedMember"));
                    }
                }
                this.match(8) || this.expect(12);
              }
              return { members: n2, hasUnknownMembers: o2 };
            }
            flowEnumStringMembers(e2, s2, i2) {
              let { enumName: a2 } = i2;
              if (e2.length === 0)
                return s2;
              if (s2.length === 0)
                return e2;
              if (s2.length > e2.length) {
                for (let n2 of e2)
                  this.flowEnumErrorStringMemberInconsistentlyInitailized(n2, { enumName: a2 });
                return s2;
              } else {
                for (let n2 of s2)
                  this.flowEnumErrorStringMemberInconsistentlyInitailized(n2, { enumName: a2 });
                return e2;
              }
            }
            flowEnumParseExplicitType(e2) {
              let { enumName: s2 } = e2;
              if (!this.eatContextual(101))
                return null;
              if (!$(this.state.type))
                throw this.raise(D.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: s2 });
              let { value: i2 } = this.state;
              return this.next(), i2 !== "boolean" && i2 !== "number" && i2 !== "string" && i2 !== "symbol" && this.raise(D.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: s2, invalidEnumType: i2 }), i2;
            }
            flowEnumBody(e2, s2) {
              let i2 = s2.name, a2 = s2.loc.start, n2 = this.flowEnumParseExplicitType({ enumName: i2 });
              this.expect(5);
              let { members: o2, hasUnknownMembers: c2 } = this.flowEnumMembers({ enumName: i2, explicitType: n2 });
              switch (e2.hasUnknownMembers = c2, n2) {
                case "boolean":
                  return e2.explicitType = true, e2.members = o2.booleanMembers, this.expect(8), this.finishNode(e2, "EnumBooleanBody");
                case "number":
                  return e2.explicitType = true, e2.members = o2.numberMembers, this.expect(8), this.finishNode(e2, "EnumNumberBody");
                case "string":
                  return e2.explicitType = true, e2.members = this.flowEnumStringMembers(o2.stringMembers, o2.defaultedMembers, { enumName: i2 }), this.expect(8), this.finishNode(e2, "EnumStringBody");
                case "symbol":
                  return e2.members = o2.defaultedMembers, this.expect(8), this.finishNode(e2, "EnumSymbolBody");
                default: {
                  let p2 = /* @__PURE__ */ __name(() => (e2.members = [], this.expect(8), this.finishNode(e2, "EnumStringBody")), "p");
                  e2.explicitType = false;
                  let m2 = o2.booleanMembers.length, x2 = o2.numberMembers.length, P2 = o2.stringMembers.length, b2 = o2.defaultedMembers.length;
                  if (!m2 && !x2 && !P2 && !b2)
                    return p2();
                  if (!m2 && !x2)
                    return e2.members = this.flowEnumStringMembers(o2.stringMembers, o2.defaultedMembers, { enumName: i2 }), this.expect(8), this.finishNode(e2, "EnumStringBody");
                  if (!x2 && !P2 && m2 >= b2) {
                    for (let O2 of o2.defaultedMembers)
                      this.flowEnumErrorBooleanMemberNotInitialized(O2.loc.start, { enumName: i2, memberName: O2.id.name });
                    return e2.members = o2.booleanMembers, this.expect(8), this.finishNode(e2, "EnumBooleanBody");
                  } else if (!m2 && !P2 && x2 >= b2) {
                    for (let O2 of o2.defaultedMembers)
                      this.flowEnumErrorNumberMemberNotInitialized(O2.loc.start, { enumName: i2, memberName: O2.id.name });
                    return e2.members = o2.numberMembers, this.expect(8), this.finishNode(e2, "EnumNumberBody");
                  } else
                    return this.raise(D.EnumInconsistentMemberValues, { at: a2, enumName: i2 }), p2();
                }
              }
            }
            flowParseEnumDeclaration(e2) {
              let s2 = this.parseIdentifier();
              return e2.id = s2, e2.body = this.flowEnumBody(this.startNode(), s2), this.finishNode(e2, "EnumDeclaration");
            }
            isLookaheadToken_lt() {
              let e2 = this.nextTokenStart();
              if (this.input.charCodeAt(e2) === 60) {
                let s2 = this.input.charCodeAt(e2 + 1);
                return s2 !== 60 && s2 !== 61;
              }
              return false;
            }
            maybeUnwrapTypeCastExpression(e2) {
              return e2.type === "TypeCastExpression" ? e2.expression : e2;
            }
          }, "Ll"), Ol = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" }, Ne = _2`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: (t2) => {
            let { openingTagName: r2 } = t2;
            return `Expected corresponding JSX closing tag for <${r2}>.`;
          }, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: (t2) => {
            let { unexpected: r2, HTMLEntity: e2 } = t2;
            return `Unexpected token \`${r2}\`. Did you mean \`${e2}\` or \`{'${r2}'}\`?`;
          }, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
          function Ee(t2) {
            return t2 ? t2.type === "JSXOpeningFragment" || t2.type === "JSXClosingFragment" : false;
          }
          __name(Ee, "Ee");
          function He(t2) {
            if (t2.type === "JSXIdentifier")
              return t2.name;
            if (t2.type === "JSXNamespacedName")
              return t2.namespace.name + ":" + t2.name.name;
            if (t2.type === "JSXMemberExpression")
              return He(t2.object) + "." + He(t2.property);
            throw new Error("Node had unexpected type: " + t2.type);
          }
          __name(He, "He");
          var Ml = /* @__PURE__ */ __name((t2) => class extends t2 {
            jsxReadToken() {
              let e2 = "", s2 = this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length)
                  throw this.raise(Ne.UnterminatedJsxContent, { at: this.state.startLoc });
                let i2 = this.input.charCodeAt(this.state.pos);
                switch (i2) {
                  case 60:
                  case 123:
                    return this.state.pos === this.state.start ? i2 === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(140)) : super.getTokenFromCode(i2) : (e2 += this.input.slice(s2, this.state.pos), this.finishToken(139, e2));
                  case 38:
                    e2 += this.input.slice(s2, this.state.pos), e2 += this.jsxReadEntity(), s2 = this.state.pos;
                    break;
                  case 62:
                  case 125:
                  default:
                    Qe(i2) ? (e2 += this.input.slice(s2, this.state.pos), e2 += this.jsxReadNewLine(true), s2 = this.state.pos) : ++this.state.pos;
                }
              }
            }
            jsxReadNewLine(e2) {
              let s2 = this.input.charCodeAt(this.state.pos), i2;
              return ++this.state.pos, s2 === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i2 = e2 ? `
` : `\r
`) : i2 = String.fromCharCode(s2), ++this.state.curLine, this.state.lineStart = this.state.pos, i2;
            }
            jsxReadString(e2) {
              let s2 = "", i2 = ++this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length)
                  throw this.raise(h3.UnterminatedString, { at: this.state.startLoc });
                let a2 = this.input.charCodeAt(this.state.pos);
                if (a2 === e2)
                  break;
                a2 === 38 ? (s2 += this.input.slice(i2, this.state.pos), s2 += this.jsxReadEntity(), i2 = this.state.pos) : Qe(a2) ? (s2 += this.input.slice(i2, this.state.pos), s2 += this.jsxReadNewLine(false), i2 = this.state.pos) : ++this.state.pos;
              }
              return s2 += this.input.slice(i2, this.state.pos++), this.finishToken(131, s2);
            }
            jsxReadEntity() {
              let e2 = ++this.state.pos;
              if (this.codePointAtPos(this.state.pos) === 35) {
                ++this.state.pos;
                let s2 = 10;
                this.codePointAtPos(this.state.pos) === 120 && (s2 = 16, ++this.state.pos);
                let i2 = this.readInt(s2, void 0, false, "bail");
                if (i2 !== null && this.codePointAtPos(this.state.pos) === 59)
                  return ++this.state.pos, String.fromCodePoint(i2);
              } else {
                let s2 = 0, i2 = false;
                for (; s2++ < 10 && this.state.pos < this.length && !(i2 = this.codePointAtPos(this.state.pos) == 59); )
                  ++this.state.pos;
                if (i2) {
                  let a2 = this.input.slice(e2, this.state.pos), n2 = Ol[a2];
                  if (++this.state.pos, n2)
                    return n2;
                }
              }
              return this.state.pos = e2, "&";
            }
            jsxReadWord() {
              let e2, s2 = this.state.pos;
              do
                e2 = this.input.charCodeAt(++this.state.pos);
              while (Be(e2) || e2 === 45);
              return this.finishToken(138, this.input.slice(s2, this.state.pos));
            }
            jsxParseIdentifier() {
              let e2 = this.startNode();
              return this.match(138) ? e2.name = this.state.value : Wt(this.state.type) ? e2.name = Pe(this.state.type) : this.unexpected(), this.next(), this.finishNode(e2, "JSXIdentifier");
            }
            jsxParseNamespacedName() {
              let e2 = this.state.startLoc, s2 = this.jsxParseIdentifier();
              if (!this.eat(14))
                return s2;
              let i2 = this.startNodeAt(e2);
              return i2.namespace = s2, i2.name = this.jsxParseIdentifier(), this.finishNode(i2, "JSXNamespacedName");
            }
            jsxParseElementName() {
              let e2 = this.state.startLoc, s2 = this.jsxParseNamespacedName();
              if (s2.type === "JSXNamespacedName")
                return s2;
              for (; this.eat(16); ) {
                let i2 = this.startNodeAt(e2);
                i2.object = s2, i2.property = this.jsxParseIdentifier(), s2 = this.finishNode(i2, "JSXMemberExpression");
              }
              return s2;
            }
            jsxParseAttributeValue() {
              let e2;
              switch (this.state.type) {
                case 5:
                  return e2 = this.startNode(), this.setContext(H.brace), this.next(), e2 = this.jsxParseExpressionContainer(e2, H.j_oTag), e2.expression.type === "JSXEmptyExpression" && this.raise(Ne.AttributeIsEmpty, { at: e2 }), e2;
                case 140:
                case 131:
                  return this.parseExprAtom();
                default:
                  throw this.raise(Ne.UnsupportedJsxValue, { at: this.state.startLoc });
              }
            }
            jsxParseEmptyExpression() {
              let e2 = this.startNodeAt(this.state.lastTokEndLoc);
              return this.finishNodeAt(e2, "JSXEmptyExpression", this.state.startLoc);
            }
            jsxParseSpreadChild(e2) {
              return this.next(), e2.expression = this.parseExpression(), this.setContext(H.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e2, "JSXSpreadChild");
            }
            jsxParseExpressionContainer(e2, s2) {
              if (this.match(8))
                e2.expression = this.jsxParseEmptyExpression();
              else {
                let i2 = this.parseExpression();
                e2.expression = i2;
              }
              return this.setContext(s2), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e2, "JSXExpressionContainer");
            }
            jsxParseAttribute() {
              let e2 = this.startNode();
              return this.match(5) ? (this.setContext(H.brace), this.next(), this.expect(21), e2.argument = this.parseMaybeAssignAllowIn(), this.setContext(H.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e2, "JSXSpreadAttribute")) : (e2.name = this.jsxParseNamespacedName(), e2.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e2, "JSXAttribute"));
            }
            jsxParseOpeningElementAt(e2) {
              let s2 = this.startNodeAt(e2);
              return this.eat(141) ? this.finishNode(s2, "JSXOpeningFragment") : (s2.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s2));
            }
            jsxParseOpeningElementAfterName(e2) {
              let s2 = [];
              for (; !this.match(56) && !this.match(141); )
                s2.push(this.jsxParseAttribute());
              return e2.attributes = s2, e2.selfClosing = this.eat(56), this.expect(141), this.finishNode(e2, "JSXOpeningElement");
            }
            jsxParseClosingElementAt(e2) {
              let s2 = this.startNodeAt(e2);
              return this.eat(141) ? this.finishNode(s2, "JSXClosingFragment") : (s2.name = this.jsxParseElementName(), this.expect(141), this.finishNode(s2, "JSXClosingElement"));
            }
            jsxParseElementAt(e2) {
              let s2 = this.startNodeAt(e2), i2 = [], a2 = this.jsxParseOpeningElementAt(e2), n2 = null;
              if (!a2.selfClosing) {
                e:
                  for (; ; )
                    switch (this.state.type) {
                      case 140:
                        if (e2 = this.state.startLoc, this.next(), this.eat(56)) {
                          n2 = this.jsxParseClosingElementAt(e2);
                          break e;
                        }
                        i2.push(this.jsxParseElementAt(e2));
                        break;
                      case 139:
                        i2.push(this.parseExprAtom());
                        break;
                      case 5: {
                        let o2 = this.startNode();
                        this.setContext(H.brace), this.next(), this.match(21) ? i2.push(this.jsxParseSpreadChild(o2)) : i2.push(this.jsxParseExpressionContainer(o2, H.j_expr));
                        break;
                      }
                      default:
                        throw this.unexpected();
                    }
                Ee(a2) && !Ee(n2) && n2 !== null ? this.raise(Ne.MissingClosingTagFragment, { at: n2 }) : !Ee(a2) && Ee(n2) ? this.raise(Ne.MissingClosingTagElement, { at: n2, openingTagName: He(a2.name) }) : !Ee(a2) && !Ee(n2) && He(n2.name) !== He(a2.name) && this.raise(Ne.MissingClosingTagElement, { at: n2, openingTagName: He(a2.name) });
              }
              if (Ee(a2) ? (s2.openingFragment = a2, s2.closingFragment = n2) : (s2.openingElement = a2, s2.closingElement = n2), s2.children = i2, this.match(47))
                throw this.raise(Ne.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
              return Ee(a2) ? this.finishNode(s2, "JSXFragment") : this.finishNode(s2, "JSXElement");
            }
            jsxParseElement() {
              let e2 = this.state.startLoc;
              return this.next(), this.jsxParseElementAt(e2);
            }
            setContext(e2) {
              let { context: s2 } = this.state;
              s2[s2.length - 1] = e2;
            }
            parseExprAtom(e2) {
              return this.match(139) ? this.parseLiteral(this.state.value, "JSXText") : this.match(140) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(140), this.jsxParseElement()) : super.parseExprAtom(e2);
            }
            skipSpace() {
              this.curContext().preserveSpace || super.skipSpace();
            }
            getTokenFromCode(e2) {
              let s2 = this.curContext();
              if (s2 === H.j_expr)
                return this.jsxReadToken();
              if (s2 === H.j_oTag || s2 === H.j_cTag) {
                if (fe(e2))
                  return this.jsxReadWord();
                if (e2 === 62)
                  return ++this.state.pos, this.finishToken(141);
                if ((e2 === 34 || e2 === 39) && s2 === H.j_oTag)
                  return this.jsxReadString(e2);
              }
              return e2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(140)) : super.getTokenFromCode(e2);
            }
            updateContext(e2) {
              let { context: s2, type: i2 } = this.state;
              if (i2 === 56 && e2 === 140)
                s2.splice(-2, 2, H.j_cTag), this.state.canStartJSXElement = false;
              else if (i2 === 140)
                s2.push(H.j_oTag);
              else if (i2 === 141) {
                let a2 = s2[s2.length - 1];
                a2 === H.j_oTag && e2 === 56 || a2 === H.j_cTag ? (s2.pop(), this.state.canStartJSXElement = s2[s2.length - 1] === H.j_expr) : (this.setContext(H.j_expr), this.state.canStartJSXElement = true);
              } else
                this.state.canStartJSXElement = wo(i2);
            }
          }, "Ml"), Bl = /* @__PURE__ */ __name(class extends ns {
            constructor() {
              super(...arguments), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
            }
          }, "Bl"), _l = /* @__PURE__ */ __name(class extends os {
            constructor() {
              super(...arguments), this.importsStack = [];
            }
            createScope(t2) {
              return this.importsStack.push(/* @__PURE__ */ new Set()), new Bl(t2);
            }
            enter(t2) {
              t2 == je && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t2);
            }
            exit() {
              let t2 = super.exit();
              return t2 == je && this.importsStack.pop(), t2;
            }
            hasImport(t2, r2) {
              let e2 = this.importsStack.length;
              if (this.importsStack[e2 - 1].has(t2))
                return true;
              if (!r2 && e2 > 1) {
                for (let s2 = 0; s2 < e2 - 1; s2++)
                  if (this.importsStack[s2].has(t2))
                    return true;
              }
              return false;
            }
            declareName(t2, r2, e2) {
              if (r2 & Je) {
                this.hasImport(t2, true) && this.parser.raise(h3.VarRedeclaration, { at: e2, identifierName: t2 }), this.importsStack[this.importsStack.length - 1].add(t2);
                return;
              }
              let s2 = this.currentScope();
              if (r2 & es) {
                this.maybeExportDefined(s2, t2), s2.exportOnlyBindings.add(t2);
                return;
              }
              super.declareName(t2, r2, e2), r2 & we && (r2 & ye || (this.checkRedeclarationInScope(s2, t2, r2, e2), this.maybeExportDefined(s2, t2)), s2.types.add(t2)), r2 & Qt && s2.enums.add(t2), r2 & Zt && s2.constEnums.add(t2), r2 & pt && s2.classes.add(t2);
            }
            isRedeclaredInScope(t2, r2, e2) {
              if (t2.enums.has(r2)) {
                if (e2 & Qt) {
                  let s2 = !!(e2 & Zt), i2 = t2.constEnums.has(r2);
                  return s2 !== i2;
                }
                return true;
              }
              return e2 & pt && t2.classes.has(r2) ? t2.lexical.has(r2) ? !!(e2 & ye) : false : e2 & we && t2.types.has(r2) ? true : super.isRedeclaredInScope(t2, r2, e2);
            }
            checkLocalExport(t2) {
              let { name: r2 } = t2;
              if (this.hasImport(r2))
                return;
              let e2 = this.scopeStack.length;
              for (let s2 = e2 - 1; s2 >= 0; s2--) {
                let i2 = this.scopeStack[s2];
                if (i2.types.has(r2) || i2.exportOnlyBindings.has(r2))
                  return;
              }
              super.checkLocalExport(t2);
            }
          }, "_l"), Rl = /* @__PURE__ */ __name((t2, r2) => Object.hasOwnProperty.call(t2, r2) && t2[r2], "Rl");
          function jl(t2) {
            if (t2 == null)
              throw new Error(`Unexpected ${t2} value.`);
            return t2;
          }
          __name(jl, "jl");
          function Hr(t2) {
            if (!t2)
              throw new Error("Assert fail");
          }
          __name(Hr, "Hr");
          var w2 = _2`typescript`({ AbstractMethodHasImplementation: (t2) => {
            let { methodName: r2 } = t2;
            return `Method '${r2}' cannot have an implementation because it is marked abstract.`;
          }, AbstractPropertyHasInitializer: (t2) => {
            let { propertyName: r2 } = t2;
            return `Property '${r2}' cannot have an initializer because it is marked abstract.`;
          }, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: (t2) => {
            let { kind: r2 } = t2;
            return `'declare' is not allowed in ${r2}ters.`;
          }, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: (t2) => {
            let { modifier: r2 } = t2;
            return "Accessibility modifier already seen.";
          }, DuplicateModifier: (t2) => {
            let { modifier: r2 } = t2;
            return `Duplicate modifier: '${r2}'.`;
          }, EmptyHeritageClauseType: (t2) => {
            let { token: r2 } = t2;
            return `'${r2}' list cannot be empty.`;
          }, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: (t2) => {
            let { modifiers: r2 } = t2;
            return `'${r2[0]}' modifier cannot be used with '${r2[1]}' modifier.`;
          }, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: (t2) => {
            let { modifier: r2 } = t2;
            return `Index signatures cannot have an accessibility modifier ('${r2}').`;
          }, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: (t2) => {
            let { modifier: r2 } = t2;
            return `'${r2}' modifier cannot appear on a type member.`;
          }, InvalidModifierOnTypeParameter: (t2) => {
            let { modifier: r2 } = t2;
            return `'${r2}' modifier cannot appear on a type parameter.`;
          }, InvalidModifierOnTypeParameterPositions: (t2) => {
            let { modifier: r2 } = t2;
            return `'${r2}' modifier can only appear on a type parameter of a class, interface or type alias.`;
          }, InvalidModifiersOrder: (t2) => {
            let { orderedModifiers: r2 } = t2;
            return `'${r2[0]}' modifier must precede '${r2[1]}' modifier.`;
          }, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: (t2) => {
            let { modifier: r2 } = t2;
            return `Private elements cannot have an accessibility modifier ('${r2}').`;
          }, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: (t2) => {
            let { typeParameterName: r2 } = t2;
            return `Single type parameter ${r2} should have a trailing comma. Example usage: <${r2},>.`;
          }, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: (t2) => {
            let { type: r2 } = t2;
            return `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${r2}.`;
          } });
          function ql(t2) {
            switch (t2) {
              case "any":
                return "TSAnyKeyword";
              case "boolean":
                return "TSBooleanKeyword";
              case "bigint":
                return "TSBigIntKeyword";
              case "never":
                return "TSNeverKeyword";
              case "number":
                return "TSNumberKeyword";
              case "object":
                return "TSObjectKeyword";
              case "string":
                return "TSStringKeyword";
              case "symbol":
                return "TSSymbolKeyword";
              case "undefined":
                return "TSUndefinedKeyword";
              case "unknown":
                return "TSUnknownKeyword";
              default:
                return;
            }
          }
          __name(ql, "ql");
          function $r(t2) {
            return t2 === "private" || t2 === "public" || t2 === "protected";
          }
          __name($r, "$r");
          function Ul(t2) {
            return t2 === "in" || t2 === "out";
          }
          __name(Ul, "Ul");
          var Hl = /* @__PURE__ */ __name((t2) => class extends t2 {
            getScopeHandler() {
              return _l;
            }
            tsIsIdentifier() {
              return $(this.state.type);
            }
            tsTokenCanFollowModifier() {
              return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(136) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
            }
            tsNextTokenCanFollowModifier() {
              return this.next(), this.tsTokenCanFollowModifier();
            }
            tsParseModifier(e2, s2) {
              if (!$(this.state.type) && this.state.type !== 58)
                return;
              let i2 = this.state.value;
              if (e2.indexOf(i2) !== -1) {
                if (s2 && this.tsIsStartOfStaticBlocks())
                  return;
                if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
                  return i2;
              }
            }
            tsParseModifiers(e2) {
              let { modified: s2, allowedModifiers: i2, disallowedModifiers: a2, stopOnStartOfClassStaticBlock: n2, errorTemplate: o2 = w2.InvalidModifierOnTypeMember } = e2, c2 = /* @__PURE__ */ __name((m2, x2, P2, b2) => {
                x2 === P2 && s2[b2] && this.raise(w2.InvalidModifiersOrder, { at: m2, orderedModifiers: [P2, b2] });
              }, "c"), p2 = /* @__PURE__ */ __name((m2, x2, P2, b2) => {
                (s2[P2] && x2 === b2 || s2[b2] && x2 === P2) && this.raise(w2.IncompatibleModifiers, { at: m2, modifiers: [P2, b2] });
              }, "p");
              for (; ; ) {
                let { startLoc: m2 } = this.state, x2 = this.tsParseModifier(i2.concat(a2 != null ? a2 : []), n2);
                if (!x2)
                  break;
                $r(x2) ? s2.accessibility ? this.raise(w2.DuplicateAccessibilityModifier, { at: m2, modifier: x2 }) : (c2(m2, x2, x2, "override"), c2(m2, x2, x2, "static"), c2(m2, x2, x2, "readonly"), s2.accessibility = x2) : Ul(x2) ? (s2[x2] && this.raise(w2.DuplicateModifier, { at: m2, modifier: x2 }), s2[x2] = true, c2(m2, x2, "in", "out")) : (Object.hasOwnProperty.call(s2, x2) ? this.raise(w2.DuplicateModifier, { at: m2, modifier: x2 }) : (c2(m2, x2, "static", "readonly"), c2(m2, x2, "static", "override"), c2(m2, x2, "override", "readonly"), c2(m2, x2, "abstract", "override"), p2(m2, x2, "declare", "override"), p2(m2, x2, "static", "abstract")), s2[x2] = true), a2 != null && a2.includes(x2) && this.raise(o2, { at: m2, modifier: x2 });
              }
            }
            tsIsListTerminator(e2) {
              switch (e2) {
                case "EnumMembers":
                case "TypeMembers":
                  return this.match(8);
                case "HeritageClauseElement":
                  return this.match(5);
                case "TupleElementTypes":
                  return this.match(3);
                case "TypeParametersOrArguments":
                  return this.match(48);
              }
              throw new Error("Unreachable");
            }
            tsParseList(e2, s2) {
              let i2 = [];
              for (; !this.tsIsListTerminator(e2); )
                i2.push(s2());
              return i2;
            }
            tsParseDelimitedList(e2, s2, i2) {
              return jl(this.tsParseDelimitedListWorker(e2, s2, true, i2));
            }
            tsParseDelimitedListWorker(e2, s2, i2, a2) {
              let n2 = [], o2 = -1;
              for (; !this.tsIsListTerminator(e2); ) {
                o2 = -1;
                let c2 = s2();
                if (c2 == null)
                  return;
                if (n2.push(c2), this.eat(12)) {
                  o2 = this.state.lastTokStart;
                  continue;
                }
                if (this.tsIsListTerminator(e2))
                  break;
                i2 && this.expect(12);
                return;
              }
              return a2 && (a2.value = o2), n2;
            }
            tsParseBracketedList(e2, s2, i2, a2, n2) {
              a2 || (i2 ? this.expect(0) : this.expect(47));
              let o2 = this.tsParseDelimitedList(e2, s2, n2);
              return i2 ? this.expect(3) : this.expect(48), o2;
            }
            tsParseImportType() {
              let e2 = this.startNode();
              return this.expect(83), this.expect(10), this.match(131) || this.raise(w2.UnsupportedImportTypeArgument, { at: this.state.startLoc }), e2.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (e2.qualifier = this.tsParseEntityName()), this.match(47) && (e2.typeParameters = this.tsParseTypeArguments()), this.finishNode(e2, "TSImportType");
            }
            tsParseEntityName() {
              let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s2 = this.parseIdentifier(e2);
              for (; this.eat(16); ) {
                let i2 = this.startNodeAtNode(s2);
                i2.left = s2, i2.right = this.parseIdentifier(e2), s2 = this.finishNode(i2, "TSQualifiedName");
              }
              return s2;
            }
            tsParseTypeReference() {
              let e2 = this.startNode();
              return e2.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e2.typeParameters = this.tsParseTypeArguments()), this.finishNode(e2, "TSTypeReference");
            }
            tsParseThisTypePredicate(e2) {
              this.next();
              let s2 = this.startNodeAtNode(e2);
              return s2.parameterName = e2, s2.typeAnnotation = this.tsParseTypeAnnotation(false), s2.asserts = false, this.finishNode(s2, "TSTypePredicate");
            }
            tsParseThisTypeNode() {
              let e2 = this.startNode();
              return this.next(), this.finishNode(e2, "TSThisType");
            }
            tsParseTypeQuery() {
              let e2 = this.startNode();
              return this.expect(87), this.match(83) ? e2.exprName = this.tsParseImportType() : e2.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e2.typeParameters = this.tsParseTypeArguments()), this.finishNode(e2, "TSTypeQuery");
            }
            tsParseInOutModifiers(e2) {
              this.tsParseModifiers({ modified: e2, allowedModifiers: ["in", "out"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: w2.InvalidModifierOnTypeParameter });
            }
            tsParseNoneModifiers(e2) {
              this.tsParseModifiers({ modified: e2, allowedModifiers: [], disallowedModifiers: ["in", "out"], errorTemplate: w2.InvalidModifierOnTypeParameterPositions });
            }
            tsParseTypeParameter() {
              let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.tsParseNoneModifiers.bind(this), s2 = this.startNode();
              return e2(s2), s2.name = this.tsParseTypeParameterName(), s2.constraint = this.tsEatThenParseType(81), s2.default = this.tsEatThenParseType(29), this.finishNode(s2, "TSTypeParameter");
            }
            tsTryParseTypeParameters(e2) {
              if (this.match(47))
                return this.tsParseTypeParameters(e2);
            }
            tsParseTypeParameters(e2) {
              let s2 = this.startNode();
              this.match(47) || this.match(140) ? this.next() : this.unexpected();
              let i2 = { value: -1 };
              return s2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e2), false, true, i2), s2.params.length === 0 && this.raise(w2.EmptyTypeParameters, { at: s2 }), i2.value !== -1 && this.addExtra(s2, "trailingComma", i2.value), this.finishNode(s2, "TSTypeParameterDeclaration");
            }
            tsFillSignature(e2, s2) {
              let i2 = e2 === 19, a2 = "parameters", n2 = "typeAnnotation";
              s2.typeParameters = this.tsTryParseTypeParameters(), this.expect(10), s2[a2] = this.tsParseBindingListForSignature(), i2 ? s2[n2] = this.tsParseTypeOrTypePredicateAnnotation(e2) : this.match(e2) && (s2[n2] = this.tsParseTypeOrTypePredicateAnnotation(e2));
            }
            tsParseBindingListForSignature() {
              return super.parseBindingList(11, 41).map((e2) => (e2.type !== "Identifier" && e2.type !== "RestElement" && e2.type !== "ObjectPattern" && e2.type !== "ArrayPattern" && this.raise(w2.UnsupportedSignatureParameterKind, { at: e2, type: e2.type }), e2));
            }
            tsParseTypeMemberSemicolon() {
              !this.eat(12) && !this.isLineTerminator() && this.expect(13);
            }
            tsParseSignatureMember(e2, s2) {
              return this.tsFillSignature(14, s2), this.tsParseTypeMemberSemicolon(), this.finishNode(s2, e2);
            }
            tsIsUnambiguouslyIndexSignature() {
              return this.next(), $(this.state.type) ? (this.next(), this.match(14)) : false;
            }
            tsTryParseIndexSignature(e2) {
              if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
                return;
              this.expect(0);
              let s2 = this.parseIdentifier();
              s2.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s2), this.expect(3), e2.parameters = [s2];
              let i2 = this.tsTryParseTypeAnnotation();
              return i2 && (e2.typeAnnotation = i2), this.tsParseTypeMemberSemicolon(), this.finishNode(e2, "TSIndexSignature");
            }
            tsParsePropertyOrMethodSignature(e2, s2) {
              this.eat(17) && (e2.optional = true);
              let i2 = e2;
              if (this.match(10) || this.match(47)) {
                s2 && this.raise(w2.ReadonlyForMethodSignature, { at: e2 });
                let a2 = i2;
                a2.kind && this.match(47) && this.raise(w2.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }), this.tsFillSignature(14, a2), this.tsParseTypeMemberSemicolon();
                let n2 = "parameters", o2 = "typeAnnotation";
                if (a2.kind === "get")
                  a2[n2].length > 0 && (this.raise(h3.BadGetterArity, { at: this.state.curPosition() }), this.isThisParam(a2[n2][0]) && this.raise(w2.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
                else if (a2.kind === "set") {
                  if (a2[n2].length !== 1)
                    this.raise(h3.BadSetterArity, { at: this.state.curPosition() });
                  else {
                    let c2 = a2[n2][0];
                    this.isThisParam(c2) && this.raise(w2.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }), c2.type === "Identifier" && c2.optional && this.raise(w2.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }), c2.type === "RestElement" && this.raise(w2.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
                  }
                  a2[o2] && this.raise(w2.SetAccesorCannotHaveReturnType, { at: a2[o2] });
                } else
                  a2.kind = "method";
                return this.finishNode(a2, "TSMethodSignature");
              } else {
                let a2 = i2;
                s2 && (a2.readonly = true);
                let n2 = this.tsTryParseTypeAnnotation();
                return n2 && (a2.typeAnnotation = n2), this.tsParseTypeMemberSemicolon(), this.finishNode(a2, "TSPropertySignature");
              }
            }
            tsParseTypeMember() {
              let e2 = this.startNode();
              if (this.match(10) || this.match(47))
                return this.tsParseSignatureMember("TSCallSignatureDeclaration", e2);
              if (this.match(77)) {
                let i2 = this.startNode();
                return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e2) : (e2.key = this.createIdentifier(i2, "new"), this.tsParsePropertyOrMethodSignature(e2, false));
              }
              this.tsParseModifiers({ modified: e2, allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] });
              let s2 = this.tsTryParseIndexSignature(e2);
              return s2 || (super.parsePropertyName(e2), !e2.computed && e2.key.type === "Identifier" && (e2.key.name === "get" || e2.key.name === "set") && this.tsTokenCanFollowModifier() && (e2.kind = e2.key.name, super.parsePropertyName(e2)), this.tsParsePropertyOrMethodSignature(e2, !!e2.readonly));
            }
            tsParseTypeLiteral() {
              let e2 = this.startNode();
              return e2.members = this.tsParseObjectTypeMembers(), this.finishNode(e2, "TSTypeLiteral");
            }
            tsParseObjectTypeMembers() {
              this.expect(5);
              let e2 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
              return this.expect(8), e2;
            }
            tsIsStartOfMappedType() {
              return this.next(), this.eat(53) ? this.isContextual(120) : (this.isContextual(120) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
            }
            tsParseMappedTypeParameter() {
              let e2 = this.startNode();
              return e2.name = this.tsParseTypeParameterName(), e2.constraint = this.tsExpectThenParseType(58), this.finishNode(e2, "TSTypeParameter");
            }
            tsParseMappedType() {
              let e2 = this.startNode();
              return this.expect(5), this.match(53) ? (e2.readonly = this.state.value, this.next(), this.expectContextual(120)) : this.eatContextual(120) && (e2.readonly = true), this.expect(0), e2.typeParameter = this.tsParseMappedTypeParameter(), e2.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e2.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e2.optional = true), e2.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e2, "TSMappedType");
            }
            tsParseTupleType() {
              let e2 = this.startNode();
              e2.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
              let s2 = false, i2 = null;
              return e2.elementTypes.forEach((a2) => {
                var n2;
                let { type: o2 } = a2;
                s2 && o2 !== "TSRestType" && o2 !== "TSOptionalType" && !(o2 === "TSNamedTupleMember" && a2.optional) && this.raise(w2.OptionalTypeBeforeRequired, { at: a2 }), s2 || (s2 = o2 === "TSNamedTupleMember" && a2.optional || o2 === "TSOptionalType");
                let c2 = o2;
                o2 === "TSRestType" && (a2 = a2.typeAnnotation, c2 = a2.type);
                let p2 = c2 === "TSNamedTupleMember";
                (n2 = i2) != null || (i2 = p2), i2 !== p2 && this.raise(w2.MixedLabeledAndUnlabeledElements, { at: a2 });
              }), this.finishNode(e2, "TSTupleType");
            }
            tsParseTupleElementType() {
              let { startLoc: e2 } = this.state, s2 = this.eat(21), i2 = this.tsParseType(), a2 = this.eat(17);
              if (this.eat(14)) {
                let o2 = this.startNodeAtNode(i2);
                o2.optional = a2, i2.type === "TSTypeReference" && !i2.typeParameters && i2.typeName.type === "Identifier" ? o2.label = i2.typeName : (this.raise(w2.InvalidTupleMemberLabel, { at: i2 }), o2.label = i2), o2.elementType = this.tsParseType(), i2 = this.finishNode(o2, "TSNamedTupleMember");
              } else if (a2) {
                let o2 = this.startNodeAtNode(i2);
                o2.typeAnnotation = i2, i2 = this.finishNode(o2, "TSOptionalType");
              }
              if (s2) {
                let o2 = this.startNodeAt(e2);
                o2.typeAnnotation = i2, i2 = this.finishNode(o2, "TSRestType");
              }
              return i2;
            }
            tsParseParenthesizedType() {
              let e2 = this.startNode();
              return this.expect(10), e2.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e2, "TSParenthesizedType");
            }
            tsParseFunctionOrConstructorType(e2, s2) {
              let i2 = this.startNode();
              return e2 === "TSConstructorType" && (i2.abstract = !!s2, s2 && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i2)), this.finishNode(i2, e2);
            }
            tsParseLiteralTypeNode() {
              let e2 = this.startNode();
              return e2.literal = (() => {
                switch (this.state.type) {
                  case 132:
                  case 133:
                  case 131:
                  case 85:
                  case 86:
                    return super.parseExprAtom();
                  default:
                    throw this.unexpected();
                }
              })(), this.finishNode(e2, "TSLiteralType");
            }
            tsParseTemplateLiteralType() {
              let e2 = this.startNode();
              return e2.literal = super.parseTemplate(false), this.finishNode(e2, "TSLiteralType");
            }
            parseTemplateSubstitution() {
              return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
            }
            tsParseThisTypeOrThisTypePredicate() {
              let e2 = this.tsParseThisTypeNode();
              return this.isContextual(114) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e2) : e2;
            }
            tsParseNonArrayType() {
              switch (this.state.type) {
                case 131:
                case 132:
                case 133:
                case 85:
                case 86:
                  return this.tsParseLiteralTypeNode();
                case 53:
                  if (this.state.value === "-") {
                    let e2 = this.startNode(), s2 = this.lookahead();
                    if (s2.type !== 132 && s2.type !== 133)
                      throw this.unexpected();
                    return e2.literal = this.parseMaybeUnary(), this.finishNode(e2, "TSLiteralType");
                  }
                  break;
                case 78:
                  return this.tsParseThisTypeOrThisTypePredicate();
                case 87:
                  return this.tsParseTypeQuery();
                case 83:
                  return this.tsParseImportType();
                case 5:
                  return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                case 0:
                  return this.tsParseTupleType();
                case 10:
                  return this.tsParseParenthesizedType();
                case 25:
                case 24:
                  return this.tsParseTemplateLiteralType();
                default: {
                  let { type: e2 } = this.state;
                  if ($(e2) || e2 === 88 || e2 === 84) {
                    let s2 = e2 === 88 ? "TSVoidKeyword" : e2 === 84 ? "TSNullKeyword" : ql(this.state.value);
                    if (s2 !== void 0 && this.lookaheadCharCode() !== 46) {
                      let i2 = this.startNode();
                      return this.next(), this.finishNode(i2, s2);
                    }
                    return this.tsParseTypeReference();
                  }
                }
              }
              throw this.unexpected();
            }
            tsParseArrayTypeOrHigher() {
              let e2 = this.tsParseNonArrayType();
              for (; !this.hasPrecedingLineBreak() && this.eat(0); )
                if (this.match(3)) {
                  let s2 = this.startNodeAtNode(e2);
                  s2.elementType = e2, this.expect(3), e2 = this.finishNode(s2, "TSArrayType");
                } else {
                  let s2 = this.startNodeAtNode(e2);
                  s2.objectType = e2, s2.indexType = this.tsParseType(), this.expect(3), e2 = this.finishNode(s2, "TSIndexedAccessType");
                }
              return e2;
            }
            tsParseTypeOperator() {
              let e2 = this.startNode(), s2 = this.state.value;
              return this.next(), e2.operator = s2, e2.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s2 === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e2), this.finishNode(e2, "TSTypeOperator");
            }
            tsCheckTypeAnnotationForReadOnly(e2) {
              switch (e2.typeAnnotation.type) {
                case "TSTupleType":
                case "TSArrayType":
                  return;
                default:
                  this.raise(w2.UnexpectedReadonly, { at: e2 });
              }
            }
            tsParseInferType() {
              let e2 = this.startNode();
              this.expectContextual(113);
              let s2 = this.startNode();
              return s2.name = this.tsParseTypeParameterName(), s2.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e2.typeParameter = this.finishNode(s2, "TSTypeParameter"), this.finishNode(e2, "TSInferType");
            }
            tsParseConstraintForInferType() {
              if (this.eat(81)) {
                let e2 = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
                if (this.state.inDisallowConditionalTypesContext || !this.match(17))
                  return e2;
              }
            }
            tsParseTypeOperatorOrHigher() {
              return Lo(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(113) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
            }
            tsParseUnionOrIntersectionType(e2, s2, i2) {
              let a2 = this.startNode(), n2 = this.eat(i2), o2 = [];
              do
                o2.push(s2());
              while (this.eat(i2));
              return o2.length === 1 && !n2 ? o2[0] : (a2.types = o2, this.finishNode(a2, e2));
            }
            tsParseIntersectionTypeOrHigher() {
              return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
            }
            tsParseUnionTypeOrHigher() {
              return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
            }
            tsIsStartOfFunctionType() {
              return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
            }
            tsSkipParameterStart() {
              if ($(this.state.type) || this.match(78))
                return this.next(), true;
              if (this.match(5)) {
                let { errors: e2 } = this.state, s2 = e2.length;
                try {
                  return this.parseObjectLike(8, true), e2.length === s2;
                } catch {
                  return false;
                }
              }
              if (this.match(0)) {
                this.next();
                let { errors: e2 } = this.state, s2 = e2.length;
                try {
                  return super.parseBindingList(3, 93, true), e2.length === s2;
                } catch {
                  return false;
                }
              }
              return false;
            }
            tsIsUnambiguouslyStartOfFunctionType() {
              return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
            }
            tsParseTypeOrTypePredicateAnnotation(e2) {
              return this.tsInType(() => {
                let s2 = this.startNode();
                this.expect(e2);
                let i2 = this.startNode(), a2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                if (a2 && this.match(78)) {
                  let c2 = this.tsParseThisTypeOrThisTypePredicate();
                  return c2.type === "TSThisType" ? (i2.parameterName = c2, i2.asserts = true, i2.typeAnnotation = null, c2 = this.finishNode(i2, "TSTypePredicate")) : (this.resetStartLocationFromNode(c2, i2), c2.asserts = true), s2.typeAnnotation = c2, this.finishNode(s2, "TSTypeAnnotation");
                }
                let n2 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                if (!n2)
                  return a2 ? (i2.parameterName = this.parseIdentifier(), i2.asserts = a2, i2.typeAnnotation = null, s2.typeAnnotation = this.finishNode(i2, "TSTypePredicate"), this.finishNode(s2, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, s2);
                let o2 = this.tsParseTypeAnnotation(false);
                return i2.parameterName = n2, i2.typeAnnotation = o2, i2.asserts = a2, s2.typeAnnotation = this.finishNode(i2, "TSTypePredicate"), this.finishNode(s2, "TSTypeAnnotation");
              });
            }
            tsTryParseTypeOrTypePredicateAnnotation() {
              return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
            }
            tsTryParseTypeAnnotation() {
              return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
            }
            tsTryParseType() {
              return this.tsEatThenParseType(14);
            }
            tsParseTypePredicatePrefix() {
              let e2 = this.parseIdentifier();
              if (this.isContextual(114) && !this.hasPrecedingLineBreak())
                return this.next(), e2;
            }
            tsParseTypePredicateAsserts() {
              if (this.state.type !== 107)
                return false;
              let e2 = this.state.containsEsc;
              return this.next(), !$(this.state.type) && !this.match(78) ? false : (e2 && this.raise(h3.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: "asserts" }), true);
            }
            tsParseTypeAnnotation() {
              let e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startNode();
              return this.tsInType(() => {
                e2 && this.expect(14), s2.typeAnnotation = this.tsParseType();
              }), this.finishNode(s2, "TSTypeAnnotation");
            }
            tsParseType() {
              Hr(this.state.inType);
              let e2 = this.tsParseNonConditionalType();
              if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
                return e2;
              let s2 = this.startNodeAtNode(e2);
              return s2.checkType = e2, s2.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s2.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s2.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s2, "TSConditionalType");
            }
            isAbstractConstructorSignature() {
              return this.isContextual(122) && this.lookahead().type === 77;
            }
            tsParseNonConditionalType() {
              return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
            }
            tsParseTypeAssertion() {
              this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(w2.ReservedTypeAssertion, { at: this.state.startLoc });
              let e2 = this.startNode();
              return e2.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e2.expression = this.parseMaybeUnary(), this.finishNode(e2, "TSTypeAssertion");
            }
            tsParseHeritageClause(e2) {
              let s2 = this.state.startLoc, i2 = this.tsParseDelimitedList("HeritageClauseElement", () => {
                let a2 = this.startNode();
                return a2.expression = this.tsParseEntityName(), this.match(47) && (a2.typeParameters = this.tsParseTypeArguments()), this.finishNode(a2, "TSExpressionWithTypeArguments");
              });
              return i2.length || this.raise(w2.EmptyHeritageClauseType, { at: s2, token: e2 }), i2;
            }
            tsParseInterfaceDeclaration(e2) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              if (this.hasFollowingLineBreak())
                return null;
              this.expectContextual(127), s2.declare && (e2.declare = true), $(this.state.type) ? (e2.id = this.parseIdentifier(), this.checkIdentifier(e2.id, Ko)) : (e2.id = null, this.raise(w2.MissingInterfaceName, { at: this.state.startLoc })), e2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.eat(81) && (e2.extends = this.tsParseHeritageClause("extends"));
              let i2 = this.startNode();
              return i2.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e2.body = this.finishNode(i2, "TSInterfaceBody"), this.finishNode(e2, "TSInterfaceDeclaration");
            }
            tsParseTypeAliasDeclaration(e2) {
              return e2.id = this.parseIdentifier(), this.checkIdentifier(e2.id, Wo), e2.typeAnnotation = this.tsInType(() => {
                if (e2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.expect(29), this.isContextual(112) && this.lookahead().type !== 16) {
                  let s2 = this.startNode();
                  return this.next(), this.finishNode(s2, "TSIntrinsicKeyword");
                }
                return this.tsParseType();
              }), this.semicolon(), this.finishNode(e2, "TSTypeAliasDeclaration");
            }
            tsInNoContext(e2) {
              let s2 = this.state.context;
              this.state.context = [s2[0]];
              try {
                return e2();
              } finally {
                this.state.context = s2;
              }
            }
            tsInType(e2) {
              let s2 = this.state.inType;
              this.state.inType = true;
              try {
                return e2();
              } finally {
                this.state.inType = s2;
              }
            }
            tsInDisallowConditionalTypesContext(e2) {
              let s2 = this.state.inDisallowConditionalTypesContext;
              this.state.inDisallowConditionalTypesContext = true;
              try {
                return e2();
              } finally {
                this.state.inDisallowConditionalTypesContext = s2;
              }
            }
            tsInAllowConditionalTypesContext(e2) {
              let s2 = this.state.inDisallowConditionalTypesContext;
              this.state.inDisallowConditionalTypesContext = false;
              try {
                return e2();
              } finally {
                this.state.inDisallowConditionalTypesContext = s2;
              }
            }
            tsEatThenParseType(e2) {
              return this.match(e2) ? this.tsNextThenParseType() : void 0;
            }
            tsExpectThenParseType(e2) {
              return this.tsDoThenParseType(() => this.expect(e2));
            }
            tsNextThenParseType() {
              return this.tsDoThenParseType(() => this.next());
            }
            tsDoThenParseType(e2) {
              return this.tsInType(() => (e2(), this.tsParseType()));
            }
            tsParseEnumMember() {
              let e2 = this.startNode();
              return e2.id = this.match(131) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e2.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e2, "TSEnumMember");
            }
            tsParseEnumDeclaration(e2) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              return s2.const && (e2.const = true), s2.declare && (e2.declare = true), this.expectContextual(124), e2.id = this.parseIdentifier(), this.checkIdentifier(e2.id, e2.const ? Jo : br), this.expect(5), e2.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e2, "TSEnumDeclaration");
            }
            tsParseModuleBlock() {
              let e2 = this.startNode();
              return this.scope.enter(_e), this.expect(5), super.parseBlockOrModuleBlockBody(e2.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e2, "TSModuleBlock");
            }
            tsParseModuleOrNamespaceDeclaration(e2) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (e2.id = this.parseIdentifier(), s2 || this.checkIdentifier(e2.id, Xo), this.eat(16)) {
                let i2 = this.startNode();
                this.tsParseModuleOrNamespaceDeclaration(i2, true), e2.body = i2;
              } else
                this.scope.enter(je), this.prodParam.enter(qe), e2.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
              return this.finishNode(e2, "TSModuleDeclaration");
            }
            tsParseAmbientExternalModuleDeclaration(e2) {
              return this.isContextual(110) ? (e2.global = true, e2.id = this.parseIdentifier()) : this.match(131) ? e2.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(je), this.prodParam.enter(qe), e2.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e2, "TSModuleDeclaration");
            }
            tsParseImportEqualsDeclaration(e2, s2) {
              e2.isExport = s2 || false, e2.id = this.parseIdentifier(), this.checkIdentifier(e2.id, Je), this.expect(29);
              let i2 = this.tsParseModuleReference();
              return e2.importKind === "type" && i2.type !== "TSExternalModuleReference" && this.raise(w2.ImportAliasHasImportType, { at: i2 }), e2.moduleReference = i2, this.semicolon(), this.finishNode(e2, "TSImportEqualsDeclaration");
            }
            tsIsExternalModuleReference() {
              return this.isContextual(117) && this.lookaheadCharCode() === 40;
            }
            tsParseModuleReference() {
              return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
            }
            tsParseExternalModuleReference() {
              let e2 = this.startNode();
              if (this.expectContextual(117), this.expect(10), !this.match(131))
                throw this.unexpected();
              return e2.expression = super.parseExprAtom(), this.expect(11), this.finishNode(e2, "TSExternalModuleReference");
            }
            tsLookAhead(e2) {
              let s2 = this.state.clone(), i2 = e2();
              return this.state = s2, i2;
            }
            tsTryParseAndCatch(e2) {
              let s2 = this.tryParse((i2) => e2() || i2());
              if (!(s2.aborted || !s2.node))
                return s2.error && (this.state = s2.failState), s2.node;
            }
            tsTryParse(e2) {
              let s2 = this.state.clone(), i2 = e2();
              if (i2 !== void 0 && i2 !== false)
                return i2;
              this.state = s2;
            }
            tsTryParseDeclare(e2) {
              if (this.isLineTerminator())
                return;
              let s2 = this.state.type, i2;
              return this.isContextual(99) && (s2 = 74, i2 = "let"), this.tsInAmbientContext(() => {
                if (s2 === 68)
                  return e2.declare = true, super.parseFunctionStatement(e2, false, true);
                if (s2 === 80)
                  return e2.declare = true, this.parseClass(e2, true, false);
                if (s2 === 124)
                  return this.tsParseEnumDeclaration(e2, { declare: true });
                if (s2 === 110)
                  return this.tsParseAmbientExternalModuleDeclaration(e2);
                if (s2 === 75 || s2 === 74)
                  return !this.match(75) || !this.isLookaheadContextual("enum") ? (e2.declare = true, this.parseVarStatement(e2, i2 || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e2, { const: true, declare: true }));
                if (s2 === 127) {
                  let a2 = this.tsParseInterfaceDeclaration(e2, { declare: true });
                  if (a2)
                    return a2;
                }
                if ($(s2))
                  return this.tsParseDeclaration(e2, this.state.value, true, null);
              });
            }
            tsTryParseExportDeclaration() {
              return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
            }
            tsParseExpressionStatement(e2, s2, i2) {
              switch (s2.name) {
                case "declare": {
                  let a2 = this.tsTryParseDeclare(e2);
                  if (a2)
                    return a2.declare = true, a2;
                  break;
                }
                case "global":
                  if (this.match(5)) {
                    this.scope.enter(je), this.prodParam.enter(qe);
                    let a2 = e2;
                    return a2.global = true, a2.id = s2, a2.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(a2, "TSModuleDeclaration");
                  }
                  break;
                default:
                  return this.tsParseDeclaration(e2, s2.name, false, i2);
              }
            }
            tsParseDeclaration(e2, s2, i2, a2) {
              switch (s2) {
                case "abstract":
                  if (this.tsCheckLineTerminator(i2) && (this.match(80) || $(this.state.type)))
                    return this.tsParseAbstractDeclaration(e2, a2);
                  break;
                case "module":
                  if (this.tsCheckLineTerminator(i2)) {
                    if (this.match(131))
                      return this.tsParseAmbientExternalModuleDeclaration(e2);
                    if ($(this.state.type))
                      return this.tsParseModuleOrNamespaceDeclaration(e2);
                  }
                  break;
                case "namespace":
                  if (this.tsCheckLineTerminator(i2) && $(this.state.type))
                    return this.tsParseModuleOrNamespaceDeclaration(e2);
                  break;
                case "type":
                  if (this.tsCheckLineTerminator(i2) && $(this.state.type))
                    return this.tsParseTypeAliasDeclaration(e2);
                  break;
              }
            }
            tsCheckLineTerminator(e2) {
              return e2 ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
            }
            tsTryParseGenericAsyncArrowFunction(e2) {
              if (!this.match(47))
                return;
              let s2 = this.state.maybeInArrowParameters;
              this.state.maybeInArrowParameters = true;
              let i2 = this.tsTryParseAndCatch(() => {
                let a2 = this.startNodeAt(e2);
                return a2.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(a2), a2.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), a2;
              });
              if (this.state.maybeInArrowParameters = s2, !!i2)
                return super.parseArrowExpression(i2, null, true);
            }
            tsParseTypeArgumentsInExpression() {
              if (this.reScan_lt() === 47)
                return this.tsParseTypeArguments();
            }
            tsParseTypeArguments() {
              let e2 = this.startNode();
              return e2.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e2.params.length === 0 && this.raise(w2.EmptyTypeArguments, { at: e2 }), this.expect(48), this.finishNode(e2, "TSTypeParameterInstantiation");
            }
            tsIsDeclarationStart() {
              return Oo(this.state.type);
            }
            isExportDefaultSpecifier() {
              return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
            }
            parseAssignableListItem(e2, s2) {
              let i2 = this.state.startLoc, a2, n2 = false, o2 = false;
              if (e2 !== void 0) {
                let m2 = {};
                this.tsParseModifiers({ modified: m2, allowedModifiers: ["public", "private", "protected", "override", "readonly"] }), a2 = m2.accessibility, o2 = m2.override, n2 = m2.readonly, e2 === false && (a2 || n2 || o2) && this.raise(w2.UnexpectedParameterModifier, { at: i2 });
              }
              let c2 = this.parseMaybeDefault();
              this.parseAssignableListItemTypes(c2);
              let p2 = this.parseMaybeDefault(c2.loc.start, c2);
              if (a2 || n2 || o2) {
                let m2 = this.startNodeAt(i2);
                return s2.length && (m2.decorators = s2), a2 && (m2.accessibility = a2), n2 && (m2.readonly = n2), o2 && (m2.override = o2), p2.type !== "Identifier" && p2.type !== "AssignmentPattern" && this.raise(w2.UnsupportedParameterPropertyKind, { at: m2 }), m2.parameter = p2, this.finishNode(m2, "TSParameterProperty");
              }
              return s2.length && (c2.decorators = s2), p2;
            }
            isSimpleParameter(e2) {
              return e2.type === "TSParameterProperty" && super.isSimpleParameter(e2.parameter) || super.isSimpleParameter(e2);
            }
            parseFunctionBodyAndFinish(e2, s2) {
              let i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              this.match(14) && (e2.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
              let a2 = s2 === "FunctionDeclaration" ? "TSDeclareFunction" : s2 === "ClassMethod" || s2 === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
              return a2 && !this.match(5) && this.isLineTerminator() ? this.finishNode(e2, a2) : a2 === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(w2.DeclareFunctionHasImplementation, { at: e2 }), e2.declare) ? super.parseFunctionBodyAndFinish(e2, a2, i2) : super.parseFunctionBodyAndFinish(e2, s2, i2);
            }
            registerFunctionStatementId(e2) {
              !e2.body && e2.id ? this.checkIdentifier(e2.id, Sr) : super.registerFunctionStatementId(e2);
            }
            tsCheckForInvalidTypeCasts(e2) {
              e2.forEach((s2) => {
                (s2 == null ? void 0 : s2.type) === "TSTypeCastExpression" && this.raise(w2.UnexpectedTypeAnnotation, { at: s2.typeAnnotation });
              });
            }
            toReferencedList(e2, s2) {
              return this.tsCheckForInvalidTypeCasts(e2), e2;
            }
            parseArrayLike(e2, s2, i2, a2) {
              let n2 = super.parseArrayLike(e2, s2, i2, a2);
              return n2.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(n2.elements), n2;
            }
            parseSubscript(e2, s2, i2, a2) {
              if (!this.hasPrecedingLineBreak() && this.match(35)) {
                this.state.canStartJSXElement = false, this.next();
                let o2 = this.startNodeAt(s2);
                return o2.expression = e2, this.finishNode(o2, "TSNonNullExpression");
              }
              let n2 = false;
              if (this.match(18) && this.lookaheadCharCode() === 60) {
                if (i2)
                  return a2.stop = true, e2;
                a2.optionalChainMember = n2 = true, this.next();
              }
              if (this.match(47) || this.match(51)) {
                let o2, c2 = this.tsTryParseAndCatch(() => {
                  if (!i2 && this.atPossibleAsyncArrow(e2)) {
                    let P2 = this.tsTryParseGenericAsyncArrowFunction(s2);
                    if (P2)
                      return P2;
                  }
                  let p2 = this.tsParseTypeArgumentsInExpression();
                  if (!p2)
                    return;
                  if (n2 && !this.match(10)) {
                    o2 = this.state.curPosition();
                    return;
                  }
                  if (ot(this.state.type)) {
                    let P2 = super.parseTaggedTemplateExpression(e2, s2, a2);
                    return P2.typeParameters = p2, P2;
                  }
                  if (!i2 && this.eat(10)) {
                    let P2 = this.startNodeAt(s2);
                    return P2.callee = e2, P2.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(P2.arguments), P2.typeParameters = p2, a2.optionalChainMember && (P2.optional = n2), this.finishCallExpression(P2, a2.optionalChainMember);
                  }
                  let m2 = this.state.type;
                  if (m2 === 48 || m2 === 52 || m2 !== 10 && Kt(m2) && !this.hasPrecedingLineBreak())
                    return;
                  let x2 = this.startNodeAt(s2);
                  return x2.expression = e2, x2.typeParameters = p2, this.finishNode(x2, "TSInstantiationExpression");
                });
                if (o2 && this.unexpected(o2, 10), c2)
                  return c2.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(w2.InvalidPropertyAccessAfterInstantiationExpression, { at: this.state.startLoc }), c2;
              }
              return super.parseSubscript(e2, s2, i2, a2);
            }
            parseNewCallee(e2) {
              var s2;
              super.parseNewCallee(e2);
              let { callee: i2 } = e2;
              i2.type === "TSInstantiationExpression" && !((s2 = i2.extra) != null && s2.parenthesized) && (e2.typeParameters = i2.typeParameters, e2.callee = i2.expression);
            }
            parseExprOp(e2, s2, i2) {
              let a2;
              if (nt(58) > i2 && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a2 = this.isContextual(118)))) {
                let n2 = this.startNodeAt(s2);
                return n2.expression = e2, n2.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a2 && this.raise(h3.UnexpectedKeyword, { at: this.state.startLoc, keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(n2, a2 ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(n2, s2, i2);
              }
              return super.parseExprOp(e2, s2, i2);
            }
            checkReservedWord(e2, s2, i2, a2) {
              this.state.isAmbientContext || super.checkReservedWord(e2, s2, i2, a2);
            }
            checkImportReflection(e2) {
              super.checkImportReflection(e2), e2.module && e2.importKind !== "value" && this.raise(w2.ImportReflectionHasImportType, { at: e2.specifiers[0].loc.start });
            }
            checkDuplicateExports() {
            }
            parseImport(e2) {
              if (e2.importKind = "value", $(this.state.type) || this.match(55) || this.match(5)) {
                let i2 = this.lookahead();
                if (this.isContextual(128) && i2.type !== 12 && i2.type !== 97 && i2.type !== 29 && (e2.importKind = "type", this.next(), i2 = this.lookahead()), $(this.state.type) && i2.type === 29)
                  return this.tsParseImportEqualsDeclaration(e2);
              }
              let s2 = super.parseImport(e2);
              return s2.importKind === "type" && s2.specifiers.length > 1 && s2.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(w2.TypeImportCannotSpecifyDefaultAndNamed, { at: s2 }), s2;
            }
            parseExport(e2, s2) {
              if (this.match(83))
                return this.next(), this.isContextual(128) && this.lookaheadCharCode() !== 61 ? (e2.importKind = "type", this.next()) : e2.importKind = "value", this.tsParseImportEqualsDeclaration(e2, true);
              if (this.eat(29)) {
                let i2 = e2;
                return i2.expression = super.parseExpression(), this.semicolon(), this.finishNode(i2, "TSExportAssignment");
              } else if (this.eatContextual(93)) {
                let i2 = e2;
                return this.expectContextual(126), i2.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i2, "TSNamespaceExportDeclaration");
              } else
                return this.isContextual(128) && this.lookahead().type === 5 ? (this.next(), e2.exportKind = "type") : e2.exportKind = "value", super.parseExport(e2, s2);
            }
            isAbstractClass() {
              return this.isContextual(122) && this.lookahead().type === 80;
            }
            parseExportDefaultExpression() {
              if (this.isAbstractClass()) {
                let e2 = this.startNode();
                return this.next(), e2.abstract = true, this.parseClass(e2, true, true);
              }
              if (this.match(127)) {
                let e2 = this.tsParseInterfaceDeclaration(this.startNode());
                if (e2)
                  return e2;
              }
              return super.parseExportDefaultExpression();
            }
            parseVarStatement(e2, s2) {
              let i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, { isAmbientContext: a2 } = this.state, n2 = super.parseVarStatement(e2, s2, i2 || a2);
              if (!a2)
                return n2;
              for (let { id: o2, init: c2 } of n2.declarations)
                !c2 || (s2 !== "const" || !!o2.typeAnnotation ? this.raise(w2.InitializerNotAllowedInAmbientContext, { at: c2 }) : c2.type !== "StringLiteral" && c2.type !== "BooleanLiteral" && c2.type !== "NumericLiteral" && c2.type !== "BigIntLiteral" && (c2.type !== "TemplateLiteral" || c2.expressions.length > 0) && !$l(c2) && this.raise(w2.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: c2 }));
              return n2;
            }
            parseStatementContent(e2, s2, i2) {
              if (this.match(75) && this.isLookaheadContextual("enum")) {
                let a2 = this.startNode();
                return this.expect(75), this.tsParseEnumDeclaration(a2, { const: true });
              }
              if (this.isContextual(124))
                return this.tsParseEnumDeclaration(this.startNode());
              if (this.isContextual(127)) {
                let a2 = this.tsParseInterfaceDeclaration(this.startNode());
                if (a2)
                  return a2;
              }
              return super.parseStatementContent(e2, s2, i2);
            }
            parseAccessModifier() {
              return this.tsParseModifier(["public", "protected", "private"]);
            }
            tsHasSomeModifiers(e2, s2) {
              return s2.some((i2) => $r(i2) ? e2.accessibility === i2 : !!e2[i2]);
            }
            tsIsStartOfStaticBlocks() {
              return this.isContextual(104) && this.lookaheadCharCode() === 123;
            }
            parseClassMember(e2, s2, i2) {
              let a2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
              this.tsParseModifiers({ modified: s2, allowedModifiers: a2, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: w2.InvalidModifierOnTypeParameterPositions });
              let n2 = /* @__PURE__ */ __name(() => {
                this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s2, a2) && this.raise(w2.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }), super.parseClassStaticBlock(e2, s2)) : this.parseClassMemberWithIsStatic(e2, s2, i2, !!s2.static);
              }, "n");
              s2.declare ? this.tsInAmbientContext(n2) : n2();
            }
            parseClassMemberWithIsStatic(e2, s2, i2, a2) {
              let n2 = this.tsTryParseIndexSignature(s2);
              if (n2) {
                e2.body.push(n2), s2.abstract && this.raise(w2.IndexSignatureHasAbstract, { at: s2 }), s2.accessibility && this.raise(w2.IndexSignatureHasAccessibility, { at: s2, modifier: s2.accessibility }), s2.declare && this.raise(w2.IndexSignatureHasDeclare, { at: s2 }), s2.override && this.raise(w2.IndexSignatureHasOverride, { at: s2 });
                return;
              }
              !this.state.inAbstractClass && s2.abstract && this.raise(w2.NonAbstractClassHasAbstractMethod, { at: s2 }), s2.override && (i2.hadSuperClass || this.raise(w2.OverrideNotInSubClass, { at: s2 })), super.parseClassMemberWithIsStatic(e2, s2, i2, a2);
            }
            parsePostMemberNameModifiers(e2) {
              this.eat(17) && (e2.optional = true), e2.readonly && this.match(10) && this.raise(w2.ClassMethodHasReadonly, { at: e2 }), e2.declare && this.match(10) && this.raise(w2.ClassMethodHasDeclare, { at: e2 });
            }
            parseExpressionStatement(e2, s2, i2) {
              return (s2.type === "Identifier" ? this.tsParseExpressionStatement(e2, s2, i2) : void 0) || super.parseExpressionStatement(e2, s2, i2);
            }
            shouldParseExportDeclaration() {
              return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
            }
            parseConditional(e2, s2, i2) {
              if (!this.state.maybeInArrowParameters || !this.match(17))
                return super.parseConditional(e2, s2, i2);
              let a2 = this.tryParse(() => super.parseConditional(e2, s2));
              return a2.node ? (a2.error && (this.state = a2.failState), a2.node) : (a2.error && super.setOptionalParametersError(i2, a2.error), e2);
            }
            parseParenItem(e2, s2) {
              if (e2 = super.parseParenItem(e2, s2), this.eat(17) && (e2.optional = true, this.resetEndLocation(e2)), this.match(14)) {
                let i2 = this.startNodeAt(s2);
                return i2.expression = e2, i2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i2, "TSTypeCastExpression");
              }
              return e2;
            }
            parseExportDeclaration(e2) {
              if (!this.state.isAmbientContext && this.isContextual(123))
                return this.tsInAmbientContext(() => this.parseExportDeclaration(e2));
              let s2 = this.state.startLoc, i2 = this.eatContextual(123);
              if (i2 && (this.isContextual(123) || !this.shouldParseExportDeclaration()))
                throw this.raise(w2.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
              let n2 = $(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e2);
              return n2 ? ((n2.type === "TSInterfaceDeclaration" || n2.type === "TSTypeAliasDeclaration" || i2) && (e2.exportKind = "type"), i2 && (this.resetStartLocation(n2, s2), n2.declare = true), n2) : null;
            }
            parseClassId(e2, s2, i2, a2) {
              if ((!s2 || i2) && this.isContextual(111))
                return;
              super.parseClassId(e2, s2, i2, e2.declare ? Sr : Er);
              let n2 = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
              n2 && (e2.typeParameters = n2);
            }
            parseClassPropertyAnnotation(e2) {
              !e2.optional && this.eat(35) && (e2.definite = true);
              let s2 = this.tsTryParseTypeAnnotation();
              s2 && (e2.typeAnnotation = s2);
            }
            parseClassProperty(e2) {
              if (this.parseClassPropertyAnnotation(e2), this.state.isAmbientContext && !(e2.readonly && !e2.typeAnnotation) && this.match(29) && this.raise(w2.DeclareClassFieldHasInitializer, { at: this.state.startLoc }), e2.abstract && this.match(29)) {
                let { key: s2 } = e2;
                this.raise(w2.AbstractPropertyHasInitializer, { at: this.state.startLoc, propertyName: s2.type === "Identifier" && !e2.computed ? s2.name : `[${this.input.slice(s2.start, s2.end)}]` });
              }
              return super.parseClassProperty(e2);
            }
            parseClassPrivateProperty(e2) {
              return e2.abstract && this.raise(w2.PrivateElementHasAbstract, { at: e2 }), e2.accessibility && this.raise(w2.PrivateElementHasAccessibility, { at: e2, modifier: e2.accessibility }), this.parseClassPropertyAnnotation(e2), super.parseClassPrivateProperty(e2);
            }
            pushClassMethod(e2, s2, i2, a2, n2, o2) {
              let c2 = this.tsTryParseTypeParameters();
              c2 && n2 && this.raise(w2.ConstructorHasTypeParameters, { at: c2 });
              let { declare: p2 = false, kind: m2 } = s2;
              p2 && (m2 === "get" || m2 === "set") && this.raise(w2.DeclareAccessor, { at: s2, kind: m2 }), c2 && (s2.typeParameters = c2), super.pushClassMethod(e2, s2, i2, a2, n2, o2);
            }
            pushClassPrivateMethod(e2, s2, i2, a2) {
              let n2 = this.tsTryParseTypeParameters();
              n2 && (s2.typeParameters = n2), super.pushClassPrivateMethod(e2, s2, i2, a2);
            }
            declareClassPrivateMethodInScope(e2, s2) {
              e2.type !== "TSDeclareMethod" && (e2.type === "MethodDefinition" && !e2.value.body || super.declareClassPrivateMethodInScope(e2, s2));
            }
            parseClassSuper(e2) {
              super.parseClassSuper(e2), e2.superClass && (this.match(47) || this.match(51)) && (e2.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(111) && (e2.implements = this.tsParseHeritageClause("implements"));
            }
            parseObjPropValue(e2, s2, i2, a2, n2, o2, c2) {
              let p2 = this.tsTryParseTypeParameters();
              return p2 && (e2.typeParameters = p2), super.parseObjPropValue(e2, s2, i2, a2, n2, o2, c2);
            }
            parseFunctionParams(e2, s2) {
              let i2 = this.tsTryParseTypeParameters();
              i2 && (e2.typeParameters = i2), super.parseFunctionParams(e2, s2);
            }
            parseVarId(e2, s2) {
              super.parseVarId(e2, s2), e2.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e2.definite = true);
              let i2 = this.tsTryParseTypeAnnotation();
              i2 && (e2.id.typeAnnotation = i2, this.resetEndLocation(e2.id));
            }
            parseAsyncArrowFromCallExpression(e2, s2) {
              return this.match(14) && (e2.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e2, s2);
            }
            parseMaybeAssign(e2, s2) {
              var i2, a2, n2, o2, c2, p2, m2;
              let x2, P2, b2;
              if (this.hasPlugin("jsx") && (this.match(140) || this.match(47))) {
                if (x2 = this.state.clone(), P2 = this.tryParse(() => super.parseMaybeAssign(e2, s2), x2), !P2.error)
                  return P2.node;
                let { context: Q } = this.state, Z = Q[Q.length - 1];
                (Z === H.j_oTag || Z === H.j_expr) && Q.pop();
              }
              if (!((i2 = P2) != null && i2.error) && !this.match(47))
                return super.parseMaybeAssign(e2, s2);
              (!x2 || x2 === this.state) && (x2 = this.state.clone());
              let O2, R2 = this.tryParse((Q) => {
                var Z, X;
                O2 = this.tsParseTypeParameters();
                let re = super.parseMaybeAssign(e2, s2);
                return (re.type !== "ArrowFunctionExpression" || (Z = re.extra) != null && Z.parenthesized) && Q(), ((X = O2) == null ? void 0 : X.params.length) !== 0 && this.resetStartLocationFromNode(re, O2), re.typeParameters = O2, re;
              }, x2);
              if (!R2.error && !R2.aborted)
                return O2 && this.reportReservedArrowTypeParam(O2), R2.node;
              if (!P2 && (Hr(!this.hasPlugin("jsx")), b2 = this.tryParse(() => super.parseMaybeAssign(e2, s2), x2), !b2.error))
                return b2.node;
              if ((a2 = P2) != null && a2.node)
                return this.state = P2.failState, P2.node;
              if (R2.node)
                return this.state = R2.failState, O2 && this.reportReservedArrowTypeParam(O2), R2.node;
              if ((n2 = b2) != null && n2.node)
                return this.state = b2.failState, b2.node;
              throw (o2 = P2) != null && o2.thrown ? P2.error : R2.thrown ? R2.error : (c2 = b2) != null && c2.thrown ? b2.error : ((p2 = P2) == null ? void 0 : p2.error) || R2.error || ((m2 = b2) == null ? void 0 : m2.error);
            }
            reportReservedArrowTypeParam(e2) {
              var s2;
              e2.params.length === 1 && !((s2 = e2.extra) != null && s2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(w2.ReservedArrowTypeParam, { at: e2 });
            }
            parseMaybeUnary(e2, s2) {
              return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e2, s2);
            }
            parseArrow(e2) {
              if (this.match(14)) {
                let s2 = this.tryParse((i2) => {
                  let a2 = this.tsParseTypeOrTypePredicateAnnotation(14);
                  return (this.canInsertSemicolon() || !this.match(19)) && i2(), a2;
                });
                if (s2.aborted)
                  return;
                s2.thrown || (s2.error && (this.state = s2.failState), e2.returnType = s2.node);
              }
              return super.parseArrow(e2);
            }
            parseAssignableListItemTypes(e2) {
              this.eat(17) && (e2.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType && this.raise(w2.PatternIsOptional, { at: e2 }), e2.optional = true);
              let s2 = this.tsTryParseTypeAnnotation();
              return s2 && (e2.typeAnnotation = s2), this.resetEndLocation(e2), e2;
            }
            isAssignable(e2, s2) {
              switch (e2.type) {
                case "TSTypeCastExpression":
                  return this.isAssignable(e2.expression, s2);
                case "TSParameterProperty":
                  return true;
                default:
                  return super.isAssignable(e2, s2);
              }
            }
            toAssignable(e2) {
              let s2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              switch (e2.type) {
                case "ParenthesizedExpression":
                  this.toAssignableParenthesizedExpression(e2, s2);
                  break;
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                  s2 ? this.expressionScope.recordArrowParemeterBindingError(w2.UnexpectedTypeCastInParameter, { at: e2 }) : this.raise(w2.UnexpectedTypeCastInParameter, { at: e2 }), this.toAssignable(e2.expression, s2);
                  break;
                case "AssignmentExpression":
                  !s2 && e2.left.type === "TSTypeCastExpression" && (e2.left = this.typeCastToParameter(e2.left));
                default:
                  super.toAssignable(e2, s2);
              }
            }
            toAssignableParenthesizedExpression(e2, s2) {
              switch (e2.expression.type) {
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                case "ParenthesizedExpression":
                  this.toAssignable(e2.expression, s2);
                  break;
                default:
                  super.toAssignable(e2, s2);
              }
            }
            checkToRestConversion(e2, s2) {
              switch (e2.type) {
                case "TSAsExpression":
                case "TSSatisfiesExpression":
                case "TSTypeAssertion":
                case "TSNonNullExpression":
                  this.checkToRestConversion(e2.expression, false);
                  break;
                default:
                  super.checkToRestConversion(e2, s2);
              }
            }
            isValidLVal(e2, s2, i2) {
              return Rl({ TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (i2 !== Te || !s2) && ["expression", true], TSSatisfiesExpression: (i2 !== Te || !s2) && ["expression", true], TSTypeAssertion: (i2 !== Te || !s2) && ["expression", true] }, e2) || super.isValidLVal(e2, s2, i2);
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case 78:
                  return this.parseIdentifier(true);
                default:
                  return super.parseBindingAtom();
              }
            }
            parseMaybeDecoratorArguments(e2) {
              if (this.match(47) || this.match(51)) {
                let s2 = this.tsParseTypeArgumentsInExpression();
                if (this.match(10)) {
                  let i2 = super.parseMaybeDecoratorArguments(e2);
                  return i2.typeParameters = s2, i2;
                }
                this.unexpected(null, 10);
              }
              return super.parseMaybeDecoratorArguments(e2);
            }
            checkCommaAfterRest(e2) {
              return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e2 ? (this.next(), false) : super.checkCommaAfterRest(e2);
            }
            isClassMethod() {
              return this.match(47) || super.isClassMethod();
            }
            isClassProperty() {
              return this.match(35) || this.match(14) || super.isClassProperty();
            }
            parseMaybeDefault(e2, s2) {
              let i2 = super.parseMaybeDefault(e2, s2);
              return i2.type === "AssignmentPattern" && i2.typeAnnotation && i2.right.start < i2.typeAnnotation.start && this.raise(w2.TypeAnnotationAfterAssign, { at: i2.typeAnnotation }), i2;
            }
            getTokenFromCode(e2) {
              if (this.state.inType) {
                if (e2 === 62)
                  return this.finishOp(48, 1);
                if (e2 === 60)
                  return this.finishOp(47, 1);
              }
              return super.getTokenFromCode(e2);
            }
            reScan_lt_gt() {
              let { type: e2 } = this.state;
              e2 === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e2 === 48 && (this.state.pos -= 1, this.readToken_gt());
            }
            reScan_lt() {
              let { type: e2 } = this.state;
              return e2 === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e2;
            }
            toAssignableList(e2, s2, i2) {
              for (let a2 = 0; a2 < e2.length; a2++) {
                let n2 = e2[a2];
                (n2 == null ? void 0 : n2.type) === "TSTypeCastExpression" && (e2[a2] = this.typeCastToParameter(n2));
              }
              super.toAssignableList(e2, s2, i2);
            }
            typeCastToParameter(e2) {
              return e2.expression.typeAnnotation = e2.typeAnnotation, this.resetEndLocation(e2.expression, e2.typeAnnotation.loc.end), e2.expression;
            }
            shouldParseArrow(e2) {
              return this.match(14) ? e2.every((s2) => this.isAssignable(s2, true)) : super.shouldParseArrow(e2);
            }
            shouldParseAsyncArrow() {
              return this.match(14) || super.shouldParseAsyncArrow();
            }
            canHaveLeadingDecorator() {
              return super.canHaveLeadingDecorator() || this.isAbstractClass();
            }
            jsxParseOpeningElementAfterName(e2) {
              if (this.match(47) || this.match(51)) {
                let s2 = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
                s2 && (e2.typeParameters = s2);
              }
              return super.jsxParseOpeningElementAfterName(e2);
            }
            getGetterSetterExpectedParamCount(e2) {
              let s2 = super.getGetterSetterExpectedParamCount(e2), a2 = this.getObjectOrClassMethodParams(e2)[0];
              return a2 && this.isThisParam(a2) ? s2 + 1 : s2;
            }
            parseCatchClauseParam() {
              let e2 = super.parseCatchClauseParam(), s2 = this.tsTryParseTypeAnnotation();
              return s2 && (e2.typeAnnotation = s2, this.resetEndLocation(e2)), e2;
            }
            tsInAmbientContext(e2) {
              let s2 = this.state.isAmbientContext;
              this.state.isAmbientContext = true;
              try {
                return e2();
              } finally {
                this.state.isAmbientContext = s2;
              }
            }
            parseClass(e2, s2, i2) {
              let a2 = this.state.inAbstractClass;
              this.state.inAbstractClass = !!e2.abstract;
              try {
                return super.parseClass(e2, s2, i2);
              } finally {
                this.state.inAbstractClass = a2;
              }
            }
            tsParseAbstractDeclaration(e2, s2) {
              if (this.match(80))
                return e2.abstract = true, this.maybeTakeDecorators(s2, this.parseClass(e2, true, false));
              if (this.isContextual(127)) {
                if (!this.hasFollowingLineBreak())
                  return e2.abstract = true, this.raise(w2.NonClassMethodPropertyHasAbstractModifer, { at: e2 }), this.tsParseInterfaceDeclaration(e2);
              } else
                this.unexpected(null, 80);
            }
            parseMethod(e2, s2, i2, a2, n2, o2, c2) {
              let p2 = super.parseMethod(e2, s2, i2, a2, n2, o2, c2);
              if (p2.abstract && (this.hasPlugin("estree") ? !!p2.value.body : !!p2.body)) {
                let { key: x2 } = p2;
                this.raise(w2.AbstractMethodHasImplementation, { at: p2, methodName: x2.type === "Identifier" && !p2.computed ? x2.name : `[${this.input.slice(x2.start, x2.end)}]` });
              }
              return p2;
            }
            tsParseTypeParameterName() {
              return this.parseIdentifier().name;
            }
            shouldParseAsAmbientContext() {
              return !!this.getPluginOption("typescript", "dts");
            }
            parse() {
              return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
            }
            getExpression() {
              return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
            }
            parseExportSpecifier(e2, s2, i2, a2) {
              return !s2 && a2 ? (this.parseTypeOnlyImportExportSpecifier(e2, false, i2), this.finishNode(e2, "ExportSpecifier")) : (e2.exportKind = "value", super.parseExportSpecifier(e2, s2, i2, a2));
            }
            parseImportSpecifier(e2, s2, i2, a2, n2) {
              return !s2 && a2 ? (this.parseTypeOnlyImportExportSpecifier(e2, true, i2), this.finishNode(e2, "ImportSpecifier")) : (e2.importKind = "value", super.parseImportSpecifier(e2, s2, i2, a2, i2 ? wr : Je));
            }
            parseTypeOnlyImportExportSpecifier(e2, s2, i2) {
              let a2 = s2 ? "imported" : "local", n2 = s2 ? "local" : "exported", o2 = e2[a2], c2, p2 = false, m2 = true, x2 = o2.loc.start;
              if (this.isContextual(93)) {
                let b2 = this.parseIdentifier();
                if (this.isContextual(93)) {
                  let O2 = this.parseIdentifier();
                  pe(this.state.type) ? (p2 = true, o2 = b2, c2 = s2 ? this.parseIdentifier() : this.parseModuleExportName(), m2 = false) : (c2 = O2, m2 = false);
                } else
                  pe(this.state.type) ? (m2 = false, c2 = s2 ? this.parseIdentifier() : this.parseModuleExportName()) : (p2 = true, o2 = b2);
              } else
                pe(this.state.type) && (p2 = true, s2 ? (o2 = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(o2.name, o2.loc.start, true, true)) : o2 = this.parseModuleExportName());
              p2 && i2 && this.raise(s2 ? w2.TypeModifierIsUsedInTypeImports : w2.TypeModifierIsUsedInTypeExports, { at: x2 }), e2[a2] = o2, e2[n2] = c2;
              let P2 = s2 ? "importKind" : "exportKind";
              e2[P2] = p2 ? "type" : "value", m2 && this.eatContextual(93) && (e2[n2] = s2 ? this.parseIdentifier() : this.parseModuleExportName()), e2[n2] || (e2[n2] = xe(e2[a2])), s2 && this.checkIdentifier(e2[n2], p2 ? wr : Je);
            }
          }, "Hl");
          function $l(t2) {
            if (t2.type !== "MemberExpression")
              return false;
            let { computed: r2, property: e2 } = t2;
            return r2 && e2.type !== "StringLiteral" && (e2.type !== "TemplateLiteral" || e2.expressions.length > 0) ? false : zr(t2.object);
          }
          __name($l, "$l");
          function zr(t2) {
            return t2.type === "Identifier" ? true : t2.type !== "MemberExpression" || t2.computed ? false : zr(t2.object);
          }
          __name(zr, "zr");
          var Vr = _2`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), zl = /* @__PURE__ */ __name((t2) => class extends t2 {
            parsePlaceholder(e2) {
              if (this.match(142)) {
                let s2 = this.startNode();
                return this.next(), this.assertNoSpace(), s2.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(142), this.finishPlaceholder(s2, e2);
              }
            }
            finishPlaceholder(e2, s2) {
              let i2 = !!(e2.expectedNode && e2.type === "Placeholder");
              return e2.expectedNode = s2, i2 ? e2 : this.finishNode(e2, "Placeholder");
            }
            getTokenFromCode(e2) {
              return e2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(142, 2) : super.getTokenFromCode(e2);
            }
            parseExprAtom(e2) {
              return this.parsePlaceholder("Expression") || super.parseExprAtom(e2);
            }
            parseIdentifier(e2) {
              return this.parsePlaceholder("Identifier") || super.parseIdentifier(e2);
            }
            checkReservedWord(e2, s2, i2, a2) {
              e2 !== void 0 && super.checkReservedWord(e2, s2, i2, a2);
            }
            parseBindingAtom() {
              return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
            }
            isValidLVal(e2, s2, i2) {
              return e2 === "Placeholder" || super.isValidLVal(e2, s2, i2);
            }
            toAssignable(e2, s2) {
              e2 && e2.type === "Placeholder" && e2.expectedNode === "Expression" ? e2.expectedNode = "Pattern" : super.toAssignable(e2, s2);
            }
            hasFollowingIdentifier(e2) {
              return super.hasFollowingIdentifier(e2) ? true : e2 ? false : this.lookahead().type === 142;
            }
            verifyBreakContinue(e2, s2) {
              e2.label && e2.label.type === "Placeholder" || super.verifyBreakContinue(e2, s2);
            }
            parseExpressionStatement(e2, s2) {
              if (s2.type !== "Placeholder" || s2.extra && s2.extra.parenthesized)
                return super.parseExpressionStatement(e2, s2);
              if (this.match(14)) {
                let i2 = e2;
                return i2.label = this.finishPlaceholder(s2, "Identifier"), this.next(), i2.body = super.parseStatement("label"), this.finishNode(i2, "LabeledStatement");
              }
              return this.semicolon(), e2.name = s2.name, this.finishPlaceholder(e2, "Statement");
            }
            parseBlock(e2, s2, i2) {
              return this.parsePlaceholder("BlockStatement") || super.parseBlock(e2, s2, i2);
            }
            parseFunctionId(e2) {
              return this.parsePlaceholder("Identifier") || super.parseFunctionId(e2);
            }
            parseClass(e2, s2, i2) {
              let a2 = s2 ? "ClassDeclaration" : "ClassExpression";
              this.next();
              let n2 = this.state.strict, o2 = this.parsePlaceholder("Identifier");
              if (o2)
                if (this.match(81) || this.match(142) || this.match(5))
                  e2.id = o2;
                else {
                  if (i2 || !s2)
                    return e2.id = null, e2.body = this.finishPlaceholder(o2, "ClassBody"), this.finishNode(e2, a2);
                  throw this.raise(Vr.ClassNameIsRequired, { at: this.state.startLoc });
                }
              else
                this.parseClassId(e2, s2, i2);
              return super.parseClassSuper(e2), e2.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e2.superClass, n2), this.finishNode(e2, a2);
            }
            parseExport(e2, s2) {
              let i2 = this.parsePlaceholder("Identifier");
              if (!i2)
                return super.parseExport(e2, s2);
              if (!this.isContextual(97) && !this.match(12))
                return e2.specifiers = [], e2.source = null, e2.declaration = this.finishPlaceholder(i2, "Declaration"), this.finishNode(e2, "ExportNamedDeclaration");
              this.expectPlugin("exportDefaultFrom");
              let a2 = this.startNode();
              return a2.exported = i2, e2.specifiers = [this.finishNode(a2, "ExportDefaultSpecifier")], super.parseExport(e2, s2);
            }
            isExportDefaultSpecifier() {
              if (this.match(65)) {
                let e2 = this.nextTokenStart();
                if (this.isUnparsedContextual(e2, "from") && this.input.startsWith(Pe(142), this.nextTokenStartSince(e2 + 4)))
                  return true;
              }
              return super.isExportDefaultSpecifier();
            }
            maybeParseExportDefaultSpecifier(e2) {
              return e2.specifiers && e2.specifiers.length > 0 ? true : super.maybeParseExportDefaultSpecifier(e2);
            }
            checkExport(e2) {
              let { specifiers: s2 } = e2;
              s2 != null && s2.length && (e2.specifiers = s2.filter((i2) => i2.exported.type === "Placeholder")), super.checkExport(e2), e2.specifiers = s2;
            }
            parseImport(e2) {
              let s2 = this.parsePlaceholder("Identifier");
              if (!s2)
                return super.parseImport(e2);
              if (e2.specifiers = [], !this.isContextual(97) && !this.match(12))
                return e2.source = this.finishPlaceholder(s2, "StringLiteral"), this.semicolon(), this.finishNode(e2, "ImportDeclaration");
              let i2 = this.startNodeAtNode(s2);
              return i2.local = s2, e2.specifiers.push(this.finishNode(i2, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e2) || this.parseNamedImportSpecifiers(e2)), this.expectContextual(97), e2.source = this.parseImportSource(), this.semicolon(), this.finishNode(e2, "ImportDeclaration");
            }
            parseImportSource() {
              return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
            }
            assertNoSpace() {
              this.state.start > this.state.lastTokEndLoc.index && this.raise(Vr.UnexpectedSpace, { at: this.state.lastTokEndLoc });
            }
          }, "zl"), Vl = /* @__PURE__ */ __name((t2) => class extends t2 {
            parseV8Intrinsic() {
              if (this.match(54)) {
                let e2 = this.state.startLoc, s2 = this.startNode();
                if (this.next(), $(this.state.type)) {
                  let i2 = this.parseIdentifierName(), a2 = this.createIdentifier(s2, i2);
                  if (a2.type = "V8IntrinsicIdentifier", this.match(10))
                    return a2;
                }
                this.unexpected(e2);
              }
            }
            parseExprAtom(e2) {
              return this.parseV8Intrinsic() || super.parseExprAtom(e2);
            }
          }, "Vl");
          function se(t2, r2) {
            let [e2, s2] = typeof r2 == "string" ? [r2, {}] : r2, i2 = Object.keys(s2), a2 = i2.length === 0;
            return t2.some((n2) => {
              if (typeof n2 == "string")
                return a2 && n2 === e2;
              {
                let [o2, c2] = n2;
                if (o2 !== e2)
                  return false;
                for (let p2 of i2)
                  if (c2[p2] !== s2[p2])
                    return false;
                return true;
              }
            });
          }
          __name(se, "se");
          function ke(t2, r2, e2) {
            let s2 = t2.find((i2) => Array.isArray(i2) ? i2[0] === r2 : i2 === r2);
            return s2 && Array.isArray(s2) && s2.length > 1 ? s2[1][e2] : null;
          }
          __name(ke, "ke");
          var Kr = ["minimal", "fsharp", "hack", "smart"], Wr = ["^^", "@@", "^", "%", "#"], Gr = ["hash", "bar"];
          function Kl(t2) {
            if (se(t2, "decorators")) {
              if (se(t2, "decorators-legacy"))
                throw new Error("Cannot use the decorators and decorators-legacy plugin together");
              let r2 = ke(t2, "decorators", "decoratorsBeforeExport");
              if (r2 != null && typeof r2 != "boolean")
                throw new Error("'decoratorsBeforeExport' must be a boolean.");
              let e2 = ke(t2, "decorators", "allowCallParenthesized");
              if (e2 != null && typeof e2 != "boolean")
                throw new Error("'allowCallParenthesized' must be a boolean.");
            }
            if (se(t2, "flow") && se(t2, "typescript"))
              throw new Error("Cannot combine flow and typescript plugins.");
            if (se(t2, "placeholders") && se(t2, "v8intrinsic"))
              throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            if (se(t2, "pipelineOperator")) {
              let r2 = ke(t2, "pipelineOperator", "proposal");
              if (!Kr.includes(r2)) {
                let s2 = Kr.map((i2) => `"${i2}"`).join(", ");
                throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${s2}.`);
              }
              let e2 = se(t2, ["recordAndTuple", { syntaxType: "hash" }]);
              if (r2 === "hack") {
                if (se(t2, "placeholders"))
                  throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                if (se(t2, "v8intrinsic"))
                  throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                let s2 = ke(t2, "pipelineOperator", "topicToken");
                if (!Wr.includes(s2)) {
                  let i2 = Wr.map((a2) => `"${a2}"`).join(", ");
                  throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${i2}.`);
                }
                if (s2 === "#" && e2)
                  throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
              } else if (r2 === "smart" && e2)
                throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
            if (se(t2, "moduleAttributes")) {
              if (se(t2, "importAssertions"))
                throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
              if (ke(t2, "moduleAttributes", "version") !== "may-2020")
                throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
            if (se(t2, "recordAndTuple") && ke(t2, "recordAndTuple", "syntaxType") != null && !Gr.includes(ke(t2, "recordAndTuple", "syntaxType")))
              throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + Gr.map((r2) => `'${r2}'`).join(", "));
            if (se(t2, "asyncDoExpressions") && !se(t2, "doExpressions")) {
              let r2 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
              throw r2.missingPlugins = "doExpressions", r2;
            }
          }
          __name(Kl, "Kl");
          var Jr = { estree: Me, jsx: Ml, flow: Ll, typescript: Hl, v8intrinsic: Vl, placeholders: zl }, Wl = Object.keys(Jr), Xr = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true };
          function Gl(t2) {
            let r2 = {};
            for (let e2 of Object.keys(Xr))
              r2[e2] = t2 && t2[e2] != null ? t2[e2] : Xr[e2];
            return r2;
          }
          __name(Gl, "Gl");
          var Jl = /* @__PURE__ */ __name((t2, r2) => Object.hasOwnProperty.call(t2, r2) && t2[r2], "Jl"), Yr = /* @__PURE__ */ __name((t2) => t2.type === "ParenthesizedExpression" ? Yr(t2.expression) : t2, "Yr"), Xl = /* @__PURE__ */ __name(class extends wl {
            toAssignable(t2) {
              let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var e2, s2;
              let i2;
              switch ((t2.type === "ParenthesizedExpression" || (e2 = t2.extra) != null && e2.parenthesized) && (i2 = Yr(t2), r2 ? i2.type === "Identifier" ? this.expressionScope.recordArrowParemeterBindingError(h3.InvalidParenthesizedAssignment, { at: t2 }) : i2.type !== "MemberExpression" && this.raise(h3.InvalidParenthesizedAssignment, { at: t2 }) : this.raise(h3.InvalidParenthesizedAssignment, { at: t2 })), t2.type) {
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                case "RestElement":
                  break;
                case "ObjectExpression":
                  t2.type = "ObjectPattern";
                  for (let n2 = 0, o2 = t2.properties.length, c2 = o2 - 1; n2 < o2; n2++) {
                    var a2;
                    let p2 = t2.properties[n2], m2 = n2 === c2;
                    this.toAssignableObjectExpressionProp(p2, m2, r2), m2 && p2.type === "RestElement" && (a2 = t2.extra) != null && a2.trailingCommaLoc && this.raise(h3.RestTrailingComma, { at: t2.extra.trailingCommaLoc });
                  }
                  break;
                case "ObjectProperty": {
                  let { key: n2, value: o2 } = t2;
                  this.isPrivateName(n2) && this.classScope.usePrivateName(this.getPrivateNameSV(n2), n2.loc.start), this.toAssignable(o2, r2);
                  break;
                }
                case "SpreadElement":
                  throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
                case "ArrayExpression":
                  t2.type = "ArrayPattern", this.toAssignableList(t2.elements, (s2 = t2.extra) == null ? void 0 : s2.trailingCommaLoc, r2);
                  break;
                case "AssignmentExpression":
                  t2.operator !== "=" && this.raise(h3.MissingEqInAssignment, { at: t2.left.loc.end }), t2.type = "AssignmentPattern", delete t2.operator, this.toAssignable(t2.left, r2);
                  break;
                case "ParenthesizedExpression":
                  this.toAssignable(i2, r2);
                  break;
              }
            }
            toAssignableObjectExpressionProp(t2, r2, e2) {
              if (t2.type === "ObjectMethod")
                this.raise(t2.kind === "get" || t2.kind === "set" ? h3.PatternHasAccessor : h3.PatternHasMethod, { at: t2.key });
              else if (t2.type === "SpreadElement") {
                t2.type = "RestElement";
                let s2 = t2.argument;
                this.checkToRestConversion(s2, false), this.toAssignable(s2, e2), r2 || this.raise(h3.RestTrailingComma, { at: t2 });
              } else
                this.toAssignable(t2, e2);
            }
            toAssignableList(t2, r2, e2) {
              let s2 = t2.length - 1;
              for (let i2 = 0; i2 <= s2; i2++) {
                let a2 = t2[i2];
                if (!!a2) {
                  if (a2.type === "SpreadElement") {
                    a2.type = "RestElement";
                    let n2 = a2.argument;
                    this.checkToRestConversion(n2, true), this.toAssignable(n2, e2);
                  } else
                    this.toAssignable(a2, e2);
                  a2.type === "RestElement" && (i2 < s2 ? this.raise(h3.RestTrailingComma, { at: a2 }) : r2 && this.raise(h3.RestTrailingComma, { at: r2 }));
                }
              }
            }
            isAssignable(t2, r2) {
              switch (t2.type) {
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                case "RestElement":
                  return true;
                case "ObjectExpression": {
                  let e2 = t2.properties.length - 1;
                  return t2.properties.every((s2, i2) => s2.type !== "ObjectMethod" && (i2 === e2 || s2.type !== "SpreadElement") && this.isAssignable(s2));
                }
                case "ObjectProperty":
                  return this.isAssignable(t2.value);
                case "SpreadElement":
                  return this.isAssignable(t2.argument);
                case "ArrayExpression":
                  return t2.elements.every((e2) => e2 === null || this.isAssignable(e2));
                case "AssignmentExpression":
                  return t2.operator === "=";
                case "ParenthesizedExpression":
                  return this.isAssignable(t2.expression);
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return !r2;
                default:
                  return false;
              }
            }
            toReferencedList(t2, r2) {
              return t2;
            }
            toReferencedListDeep(t2, r2) {
              this.toReferencedList(t2, r2);
              for (let e2 of t2)
                (e2 == null ? void 0 : e2.type) === "ArrayExpression" && this.toReferencedListDeep(e2.elements);
            }
            parseSpread(t2) {
              let r2 = this.startNode();
              return this.next(), r2.argument = this.parseMaybeAssignAllowIn(t2, void 0), this.finishNode(r2, "SpreadElement");
            }
            parseRestBinding() {
              let t2 = this.startNode();
              return this.next(), t2.argument = this.parseBindingAtom(), this.finishNode(t2, "RestElement");
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case 0: {
                  let t2 = this.startNode();
                  return this.next(), t2.elements = this.parseBindingList(3, 93, true), this.finishNode(t2, "ArrayPattern");
                }
                case 5:
                  return this.parseObjectLike(8, true);
              }
              return this.parseIdentifier();
            }
            parseBindingList(t2, r2, e2, s2) {
              let i2 = [], a2 = true;
              for (; !this.eat(t2); )
                if (a2 ? a2 = false : this.expect(12), e2 && this.match(12))
                  i2.push(null);
                else {
                  if (this.eat(t2))
                    break;
                  if (this.match(21)) {
                    if (i2.push(this.parseAssignableListItemTypes(this.parseRestBinding())), !this.checkCommaAfterRest(r2)) {
                      this.expect(t2);
                      break;
                    }
                  } else {
                    let n2 = [];
                    for (this.match(26) && this.hasPlugin("decorators") && this.raise(h3.UnsupportedParameterDecorator, { at: this.state.startLoc }); this.match(26); )
                      n2.push(this.parseDecorator());
                    i2.push(this.parseAssignableListItem(s2, n2));
                  }
                }
              return i2;
            }
            parseBindingRestProperty(t2) {
              return this.next(), t2.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t2, "RestElement");
            }
            parseBindingProperty() {
              let t2 = this.startNode(), { type: r2, startLoc: e2 } = this.state;
              return r2 === 21 ? this.parseBindingRestProperty(t2) : (r2 === 136 ? (this.expectPlugin("destructuringPrivate", e2), this.classScope.usePrivateName(this.state.value, e2), t2.key = this.parsePrivateName()) : this.parsePropertyName(t2), t2.method = false, this.parseObjPropValue(t2, e2, false, false, true, false));
            }
            parseAssignableListItem(t2, r2) {
              let e2 = this.parseMaybeDefault();
              this.parseAssignableListItemTypes(e2);
              let s2 = this.parseMaybeDefault(e2.loc.start, e2);
              return r2.length && (e2.decorators = r2), s2;
            }
            parseAssignableListItemTypes(t2) {
              return t2;
            }
            parseMaybeDefault(t2, r2) {
              var e2, s2;
              if ((e2 = t2) != null || (t2 = this.state.startLoc), r2 = (s2 = r2) != null ? s2 : this.parseBindingAtom(), !this.eat(29))
                return r2;
              let i2 = this.startNodeAt(t2);
              return i2.left = r2, i2.right = this.parseMaybeAssignAllowIn(), this.finishNode(i2, "AssignmentPattern");
            }
            isValidLVal(t2, r2, e2) {
              return Jl({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, t2);
            }
            checkLVal(t2, r2) {
              let { in: e2, binding: s2 = Te, checkClashes: i2 = false, strictModeChanged: a2 = false, allowingSloppyLetBinding: n2 = !(s2 & Ae), hasParenthesizedAncestor: o2 = false } = r2;
              var c2;
              let p2 = t2.type;
              if (this.isObjectMethod(t2))
                return;
              if (p2 === "MemberExpression") {
                s2 !== Te && this.raise(h3.InvalidPropertyBindingPattern, { at: t2 });
                return;
              }
              if (t2.type === "Identifier") {
                this.checkIdentifier(t2, s2, a2, n2);
                let { name: O2 } = t2;
                i2 && (i2.has(O2) ? this.raise(h3.ParamDupe, { at: t2 }) : i2.add(O2));
                return;
              }
              let m2 = this.isValidLVal(t2.type, !(o2 || (c2 = t2.extra) != null && c2.parenthesized) && e2.type === "AssignmentExpression", s2);
              if (m2 === true)
                return;
              if (m2 === false) {
                let O2 = s2 === Te ? h3.InvalidLhs : h3.InvalidLhsBinding;
                this.raise(O2, { at: t2, ancestor: e2.type === "UpdateExpression" ? { type: "UpdateExpression", prefix: e2.prefix } : { type: e2.type } });
                return;
              }
              let [x2, P2] = Array.isArray(m2) ? m2 : [m2, p2 === "ParenthesizedExpression"], b2 = t2.type === "ArrayPattern" || t2.type === "ObjectPattern" || t2.type === "ParenthesizedExpression" ? t2 : e2;
              for (let O2 of [].concat(t2[x2]))
                O2 && this.checkLVal(O2, { in: b2, binding: s2, checkClashes: i2, allowingSloppyLetBinding: n2, strictModeChanged: a2, hasParenthesizedAncestor: P2 });
            }
            checkIdentifier(t2, r2) {
              let e2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !(r2 & Ae);
              this.state.strict && (e2 ? gr(t2.name, this.inModule) : xr(t2.name)) && (r2 === Te ? this.raise(h3.StrictEvalArguments, { at: t2, referenceName: t2.name }) : this.raise(h3.StrictEvalArgumentsBinding, { at: t2, bindingName: t2.name })), !s2 && t2.name === "let" && this.raise(h3.LetInLexicalBinding, { at: t2 }), r2 & Te || this.declareNameFromIdentifier(t2, r2);
            }
            declareNameFromIdentifier(t2, r2) {
              this.scope.declareName(t2.name, r2, t2.loc.start);
            }
            checkToRestConversion(t2, r2) {
              switch (t2.type) {
                case "ParenthesizedExpression":
                  this.checkToRestConversion(t2.expression, r2);
                  break;
                case "Identifier":
                case "MemberExpression":
                  break;
                case "ArrayExpression":
                case "ObjectExpression":
                  if (r2)
                    break;
                default:
                  this.raise(h3.InvalidRestAssignmentPattern, { at: t2 });
              }
            }
            checkCommaAfterRest(t2) {
              return this.match(12) ? (this.raise(this.lookaheadCharCode() === t2 ? h3.RestTrailingComma : h3.ElementAfterRest, { at: this.state.startLoc }), true) : false;
            }
          }, "Xl"), Yl = /* @__PURE__ */ __name(class extends Xl {
            checkProto(t2, r2, e2, s2) {
              if (t2.type === "SpreadElement" || this.isObjectMethod(t2) || t2.computed || t2.shorthand)
                return;
              let i2 = t2.key;
              if ((i2.type === "Identifier" ? i2.name : i2.value) === "__proto__") {
                if (r2) {
                  this.raise(h3.RecordNoProto, { at: i2 });
                  return;
                }
                e2.used && (s2 ? s2.doubleProtoLoc === null && (s2.doubleProtoLoc = i2.loc.start) : this.raise(h3.DuplicateProto, { at: i2 })), e2.used = true;
              }
            }
            shouldExitDescending(t2, r2) {
              return t2.type === "ArrowFunctionExpression" && t2.start === r2;
            }
            getExpression() {
              this.enterInitialScopes(), this.nextToken();
              let t2 = this.parseExpression();
              return this.match(137) || this.unexpected(), this.finalizeRemainingComments(), t2.comments = this.state.comments, t2.errors = this.state.errors, this.options.tokens && (t2.tokens = this.tokens), t2;
            }
            parseExpression(t2, r2) {
              return t2 ? this.disallowInAnd(() => this.parseExpressionBase(r2)) : this.allowInAnd(() => this.parseExpressionBase(r2));
            }
            parseExpressionBase(t2) {
              let r2 = this.state.startLoc, e2 = this.parseMaybeAssign(t2);
              if (this.match(12)) {
                let s2 = this.startNodeAt(r2);
                for (s2.expressions = [e2]; this.eat(12); )
                  s2.expressions.push(this.parseMaybeAssign(t2));
                return this.toReferencedList(s2.expressions), this.finishNode(s2, "SequenceExpression");
              }
              return e2;
            }
            parseMaybeAssignDisallowIn(t2, r2) {
              return this.disallowInAnd(() => this.parseMaybeAssign(t2, r2));
            }
            parseMaybeAssignAllowIn(t2, r2) {
              return this.allowInAnd(() => this.parseMaybeAssign(t2, r2));
            }
            setOptionalParametersError(t2, r2) {
              var e2;
              t2.optionalParametersLoc = (e2 = r2 == null ? void 0 : r2.loc) != null ? e2 : this.state.startLoc;
            }
            parseMaybeAssign(t2, r2) {
              let e2 = this.state.startLoc;
              if (this.isContextual(106) && this.prodParam.hasYield) {
                let n2 = this.parseYield();
                return r2 && (n2 = r2.call(this, n2, e2)), n2;
              }
              let s2;
              t2 ? s2 = false : (t2 = new At(), s2 = true);
              let { type: i2 } = this.state;
              (i2 === 10 || $(i2)) && (this.state.potentialArrowAt = this.state.start);
              let a2 = this.parseMaybeConditional(t2);
              if (r2 && (a2 = r2.call(this, a2, e2)), Io(this.state.type)) {
                let n2 = this.startNodeAt(e2), o2 = this.state.value;
                if (n2.operator = o2, this.match(29)) {
                  this.toAssignable(a2, true), n2.left = a2;
                  let c2 = e2.index;
                  t2.doubleProtoLoc != null && t2.doubleProtoLoc.index >= c2 && (t2.doubleProtoLoc = null), t2.shorthandAssignLoc != null && t2.shorthandAssignLoc.index >= c2 && (t2.shorthandAssignLoc = null), t2.privateKeyLoc != null && t2.privateKeyLoc.index >= c2 && (this.checkDestructuringPrivate(t2), t2.privateKeyLoc = null);
                } else
                  n2.left = a2;
                return this.next(), n2.right = this.parseMaybeAssign(), this.checkLVal(a2, { in: this.finishNode(n2, "AssignmentExpression") }), n2;
              } else
                s2 && this.checkExpressionErrors(t2, true);
              return a2;
            }
            parseMaybeConditional(t2) {
              let r2 = this.state.startLoc, e2 = this.state.potentialArrowAt, s2 = this.parseExprOps(t2);
              return this.shouldExitDescending(s2, e2) ? s2 : this.parseConditional(s2, r2, t2);
            }
            parseConditional(t2, r2, e2) {
              if (this.eat(17)) {
                let s2 = this.startNodeAt(r2);
                return s2.test = t2, s2.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), s2.alternate = this.parseMaybeAssign(), this.finishNode(s2, "ConditionalExpression");
              }
              return t2;
            }
            parseMaybeUnaryOrPrivate(t2) {
              return this.match(136) ? this.parsePrivateName() : this.parseMaybeUnary(t2);
            }
            parseExprOps(t2) {
              let r2 = this.state.startLoc, e2 = this.state.potentialArrowAt, s2 = this.parseMaybeUnaryOrPrivate(t2);
              return this.shouldExitDescending(s2, e2) ? s2 : this.parseExprOp(s2, r2, -1);
            }
            parseExprOp(t2, r2, e2) {
              if (this.isPrivateName(t2)) {
                let i2 = this.getPrivateNameSV(t2);
                (e2 >= nt(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(h3.PrivateInExpectedIn, { at: t2, identifierName: i2 }), this.classScope.usePrivateName(i2, t2.loc.start);
              }
              let s2 = this.state.type;
              if (ko(s2) && (this.prodParam.hasIn || !this.match(58))) {
                let i2 = nt(s2);
                if (i2 > e2) {
                  if (s2 === 39) {
                    if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                      return t2;
                    this.checkPipelineAtInfixOperator(t2, r2);
                  }
                  let a2 = this.startNodeAt(r2);
                  a2.left = t2, a2.operator = this.state.value;
                  let n2 = s2 === 41 || s2 === 42, o2 = s2 === 40;
                  if (o2 && (i2 = nt(42)), this.next(), s2 === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait)
                    throw this.raise(h3.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
                  a2.right = this.parseExprOpRightExpr(s2, i2);
                  let c2 = this.finishNode(a2, n2 || o2 ? "LogicalExpression" : "BinaryExpression"), p2 = this.state.type;
                  if (o2 && (p2 === 41 || p2 === 42) || n2 && p2 === 40)
                    throw this.raise(h3.MixingCoalesceWithLogical, { at: this.state.startLoc });
                  return this.parseExprOp(c2, r2, e2);
                }
              }
              return t2;
            }
            parseExprOpRightExpr(t2, r2) {
              let e2 = this.state.startLoc;
              switch (t2) {
                case 39:
                  switch (this.getPluginOption("pipelineOperator", "proposal")) {
                    case "hack":
                      return this.withTopicBindingContext(() => this.parseHackPipeBody());
                    case "smart":
                      return this.withTopicBindingContext(() => {
                        if (this.prodParam.hasYield && this.isContextual(106))
                          throw this.raise(h3.PipeBodyIsTighter, { at: this.state.startLoc });
                        return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t2, r2), e2);
                      });
                    case "fsharp":
                      return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r2));
                  }
                default:
                  return this.parseExprOpBaseRightExpr(t2, r2);
              }
            }
            parseExprOpBaseRightExpr(t2, r2) {
              let e2 = this.state.startLoc;
              return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e2, Mo(t2) ? r2 - 1 : r2);
            }
            parseHackPipeBody() {
              var t2;
              let { startLoc: r2 } = this.state, e2 = this.parseMaybeAssign();
              return j2.has(e2.type) && !((t2 = e2.extra) != null && t2.parenthesized) && this.raise(h3.PipeUnparenthesizedBody, { at: r2, type: e2.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(h3.PipeTopicUnused, { at: r2 }), e2;
            }
            checkExponentialAfterUnary(t2) {
              this.match(57) && this.raise(h3.UnexpectedTokenUnaryExponentiation, { at: t2.argument });
            }
            parseMaybeUnary(t2, r2) {
              let e2 = this.state.startLoc, s2 = this.isContextual(96);
              if (s2 && this.isAwaitAllowed()) {
                this.next();
                let o2 = this.parseAwait(e2);
                return r2 || this.checkExponentialAfterUnary(o2), o2;
              }
              let i2 = this.match(34), a2 = this.startNode();
              if (Fo(this.state.type)) {
                a2.operator = this.state.value, a2.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
                let o2 = this.match(89);
                if (this.next(), a2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t2, true), this.state.strict && o2) {
                  let c2 = a2.argument;
                  c2.type === "Identifier" ? this.raise(h3.StrictDelete, { at: a2 }) : this.hasPropertyAsPrivateName(c2) && this.raise(h3.DeletePrivateField, { at: a2 });
                }
                if (!i2)
                  return r2 || this.checkExponentialAfterUnary(a2), this.finishNode(a2, "UnaryExpression");
              }
              let n2 = this.parseUpdate(a2, i2, t2);
              if (s2) {
                let { type: o2 } = this.state;
                if ((this.hasPlugin("v8intrinsic") ? Kt(o2) : Kt(o2) && !this.match(54)) && !this.isAmbiguousAwait())
                  return this.raiseOverwrite(h3.AwaitNotInAsyncContext, { at: e2 }), this.parseAwait(e2);
              }
              return n2;
            }
            parseUpdate(t2, r2, e2) {
              if (r2) {
                let a2 = t2;
                return this.checkLVal(a2.argument, { in: this.finishNode(a2, "UpdateExpression") }), t2;
              }
              let s2 = this.state.startLoc, i2 = this.parseExprSubscripts(e2);
              if (this.checkExpressionErrors(e2, false))
                return i2;
              for (; Do(this.state.type) && !this.canInsertSemicolon(); ) {
                let a2 = this.startNodeAt(s2);
                a2.operator = this.state.value, a2.prefix = false, a2.argument = i2, this.next(), this.checkLVal(i2, { in: i2 = this.finishNode(a2, "UpdateExpression") });
              }
              return i2;
            }
            parseExprSubscripts(t2) {
              let r2 = this.state.startLoc, e2 = this.state.potentialArrowAt, s2 = this.parseExprAtom(t2);
              return this.shouldExitDescending(s2, e2) ? s2 : this.parseSubscripts(s2, r2);
            }
            parseSubscripts(t2, r2, e2) {
              let s2 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t2), stop: false };
              do
                t2 = this.parseSubscript(t2, r2, e2, s2), s2.maybeAsyncArrow = false;
              while (!s2.stop);
              return t2;
            }
            parseSubscript(t2, r2, e2, s2) {
              let { type: i2 } = this.state;
              if (!e2 && i2 === 15)
                return this.parseBind(t2, r2, e2, s2);
              if (ot(i2))
                return this.parseTaggedTemplateExpression(t2, r2, s2);
              let a2 = false;
              if (i2 === 18) {
                if (e2 && this.lookaheadCharCode() === 40)
                  return s2.stop = true, t2;
                s2.optionalChainMember = a2 = true, this.next();
              }
              if (!e2 && this.match(10))
                return this.parseCoverCallAndAsyncArrowHead(t2, r2, s2, a2);
              {
                let n2 = this.eat(0);
                return n2 || a2 || this.eat(16) ? this.parseMember(t2, r2, s2, n2, a2) : (s2.stop = true, t2);
              }
            }
            parseMember(t2, r2, e2, s2, i2) {
              let a2 = this.startNodeAt(r2);
              return a2.object = t2, a2.computed = s2, s2 ? (a2.property = this.parseExpression(), this.expect(3)) : this.match(136) ? (t2.type === "Super" && this.raise(h3.SuperPrivateField, { at: r2 }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), a2.property = this.parsePrivateName()) : a2.property = this.parseIdentifier(true), e2.optionalChainMember ? (a2.optional = i2, this.finishNode(a2, "OptionalMemberExpression")) : this.finishNode(a2, "MemberExpression");
            }
            parseBind(t2, r2, e2, s2) {
              let i2 = this.startNodeAt(r2);
              return i2.object = t2, this.next(), i2.callee = this.parseNoCallExpr(), s2.stop = true, this.parseSubscripts(this.finishNode(i2, "BindExpression"), r2, e2);
            }
            parseCoverCallAndAsyncArrowHead(t2, r2, e2, s2) {
              let i2 = this.state.maybeInArrowParameters, a2 = null;
              this.state.maybeInArrowParameters = true, this.next();
              let n2 = this.startNodeAt(r2);
              n2.callee = t2;
              let { maybeAsyncArrow: o2, optionalChainMember: c2 } = e2;
              o2 && (this.expressionScope.enter(vl()), a2 = new At()), c2 && (n2.optional = s2), s2 ? n2.arguments = this.parseCallExpressionArguments(11) : n2.arguments = this.parseCallExpressionArguments(11, t2.type === "Import", t2.type !== "Super", n2, a2);
              let p2 = this.finishCallExpression(n2, c2);
              return o2 && this.shouldParseAsyncArrow() && !s2 ? (e2.stop = true, this.checkDestructuringPrivate(a2), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), p2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r2), p2)) : (o2 && (this.checkExpressionErrors(a2, true), this.expressionScope.exit()), this.toReferencedArguments(p2)), this.state.maybeInArrowParameters = i2, p2;
            }
            toReferencedArguments(t2, r2) {
              this.toReferencedListDeep(t2.arguments, r2);
            }
            parseTaggedTemplateExpression(t2, r2, e2) {
              let s2 = this.startNodeAt(r2);
              return s2.tag = t2, s2.quasi = this.parseTemplate(true), e2.optionalChainMember && this.raise(h3.OptionalChainingNoTemplate, { at: r2 }), this.finishNode(s2, "TaggedTemplateExpression");
            }
            atPossibleAsyncArrow(t2) {
              return t2.type === "Identifier" && t2.name === "async" && this.state.lastTokEndLoc.index === t2.end && !this.canInsertSemicolon() && t2.end - t2.start === 5 && t2.start === this.state.potentialArrowAt;
            }
            finishCallExpression(t2, r2) {
              if (t2.callee.type === "Import")
                if (t2.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), t2.arguments.length === 0 || t2.arguments.length > 2)
                  this.raise(h3.ImportCallArity, { at: t2, maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
                else
                  for (let e2 of t2.arguments)
                    e2.type === "SpreadElement" && this.raise(h3.ImportCallSpreadArgument, { at: e2 });
              return this.finishNode(t2, r2 ? "OptionalCallExpression" : "CallExpression");
            }
            parseCallExpressionArguments(t2, r2, e2, s2, i2) {
              let a2 = [], n2 = true, o2 = this.state.inFSharpPipelineDirectBody;
              for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t2); ) {
                if (n2)
                  n2 = false;
                else if (this.expect(12), this.match(t2)) {
                  r2 && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(h3.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }), s2 && this.addTrailingCommaExtraToNode(s2), this.next();
                  break;
                }
                a2.push(this.parseExprListItem(false, i2, e2));
              }
              return this.state.inFSharpPipelineDirectBody = o2, a2;
            }
            shouldParseAsyncArrow() {
              return this.match(19) && !this.canInsertSemicolon();
            }
            parseAsyncArrowFromCallExpression(t2, r2) {
              var e2;
              return this.resetPreviousNodeTrailingComments(r2), this.expect(19), this.parseArrowExpression(t2, r2.arguments, true, (e2 = r2.extra) == null ? void 0 : e2.trailingCommaLoc), r2.innerComments && Xe(t2, r2.innerComments), r2.callee.trailingComments && Xe(t2, r2.callee.trailingComments), t2;
            }
            parseNoCallExpr() {
              let t2 = this.state.startLoc;
              return this.parseSubscripts(this.parseExprAtom(), t2, true);
            }
            parseExprAtom(t2) {
              let r2, e2 = null, { type: s2 } = this.state;
              switch (s2) {
                case 79:
                  return this.parseSuper();
                case 83:
                  return r2 = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(r2) : (this.match(10) || this.raise(h3.UnsupportedImport, { at: this.state.lastTokStartLoc }), this.finishNode(r2, "Import"));
                case 78:
                  return r2 = this.startNode(), this.next(), this.finishNode(r2, "ThisExpression");
                case 90:
                  return this.parseDo(this.startNode(), false);
                case 56:
                case 31:
                  return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
                case 132:
                  return this.parseNumericLiteral(this.state.value);
                case 133:
                  return this.parseBigIntLiteral(this.state.value);
                case 134:
                  return this.parseDecimalLiteral(this.state.value);
                case 131:
                  return this.parseStringLiteral(this.state.value);
                case 84:
                  return this.parseNullLiteral();
                case 85:
                  return this.parseBooleanLiteral(true);
                case 86:
                  return this.parseBooleanLiteral(false);
                case 10: {
                  let i2 = this.state.potentialArrowAt === this.state.start;
                  return this.parseParenAndDistinguishExpression(i2);
                }
                case 2:
                case 1:
                  return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
                case 0:
                  return this.parseArrayLike(3, true, false, t2);
                case 6:
                case 7:
                  return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
                case 5:
                  return this.parseObjectLike(8, false, false, t2);
                case 68:
                  return this.parseFunctionOrFunctionSent();
                case 26:
                  e2 = this.parseDecorators();
                case 80:
                  return this.parseClass(this.maybeTakeDecorators(e2, this.startNode()), false);
                case 77:
                  return this.parseNewOrNewTarget();
                case 25:
                case 24:
                  return this.parseTemplate(false);
                case 15: {
                  r2 = this.startNode(), this.next(), r2.object = null;
                  let i2 = r2.callee = this.parseNoCallExpr();
                  if (i2.type === "MemberExpression")
                    return this.finishNode(r2, "BindExpression");
                  throw this.raise(h3.UnsupportedBind, { at: i2 });
                }
                case 136:
                  return this.raise(h3.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }), this.parsePrivateName();
                case 33:
                  return this.parseTopicReferenceThenEqualsSign(54, "%");
                case 32:
                  return this.parseTopicReferenceThenEqualsSign(44, "^");
                case 37:
                case 38:
                  return this.parseTopicReference("hack");
                case 44:
                case 54:
                case 27: {
                  let i2 = this.getPluginOption("pipelineOperator", "proposal");
                  if (i2)
                    return this.parseTopicReference(i2);
                  throw this.unexpected();
                }
                case 47: {
                  let i2 = this.input.codePointAt(this.nextTokenStart());
                  if (fe(i2) || i2 === 62) {
                    this.expectOnePlugin(["jsx", "flow", "typescript"]);
                    break;
                  } else
                    throw this.unexpected();
                }
                default:
                  if ($(s2)) {
                    if (this.isContextual(125) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
                      return this.parseModuleExpression();
                    let i2 = this.state.potentialArrowAt === this.state.start, a2 = this.state.containsEsc, n2 = this.parseIdentifier();
                    if (!a2 && n2.name === "async" && !this.canInsertSemicolon()) {
                      let { type: o2 } = this.state;
                      if (o2 === 68)
                        return this.resetPreviousNodeTrailingComments(n2), this.next(), this.parseFunction(this.startNodeAtNode(n2), void 0, true);
                      if ($(o2))
                        return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(n2)) : n2;
                      if (o2 === 90)
                        return this.resetPreviousNodeTrailingComments(n2), this.parseDo(this.startNodeAtNode(n2), true);
                    }
                    return i2 && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(n2), [n2], false)) : n2;
                  } else
                    throw this.unexpected();
              }
            }
            parseTopicReferenceThenEqualsSign(t2, r2) {
              let e2 = this.getPluginOption("pipelineOperator", "proposal");
              if (e2)
                return this.state.type = t2, this.state.value = r2, this.state.pos--, this.state.end--, this.state.endLoc = y2(this.state.endLoc, -1), this.parseTopicReference(e2);
              throw this.unexpected();
            }
            parseTopicReference(t2) {
              let r2 = this.startNode(), e2 = this.state.startLoc, s2 = this.state.type;
              return this.next(), this.finishTopicReference(r2, e2, t2, s2);
            }
            finishTopicReference(t2, r2, e2, s2) {
              if (this.testTopicReferenceConfiguration(e2, r2, s2)) {
                let i2 = e2 === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
                return this.topicReferenceIsAllowedInCurrentContext() || this.raise(e2 === "smart" ? h3.PrimaryTopicNotAllowed : h3.PipeTopicUnbound, { at: r2 }), this.registerTopicReference(), this.finishNode(t2, i2);
              } else
                throw this.raise(h3.PipeTopicUnconfiguredToken, { at: r2, token: Pe(s2) });
            }
            testTopicReferenceConfiguration(t2, r2, e2) {
              switch (t2) {
                case "hack":
                  return this.hasPlugin(["pipelineOperator", { topicToken: Pe(e2) }]);
                case "smart":
                  return e2 === 27;
                default:
                  throw this.raise(h3.PipeTopicRequiresHackPipes, { at: r2 });
              }
            }
            parseAsyncArrowUnaryFunction(t2) {
              this.prodParam.enter(Pt(true, this.prodParam.hasYield));
              let r2 = [this.parseIdentifier()];
              return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(h3.LineTerminatorBeforeArrow, { at: this.state.curPosition() }), this.expect(19), this.parseArrowExpression(t2, r2, true);
            }
            parseDo(t2, r2) {
              this.expectPlugin("doExpressions"), r2 && this.expectPlugin("asyncDoExpressions"), t2.async = r2, this.next();
              let e2 = this.state.labels;
              return this.state.labels = [], r2 ? (this.prodParam.enter(gt), t2.body = this.parseBlock(), this.prodParam.exit()) : t2.body = this.parseBlock(), this.state.labels = e2, this.finishNode(t2, "DoExpression");
            }
            parseSuper() {
              let t2 = this.startNode();
              return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(h3.SuperNotAllowed, { at: t2 }) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(h3.UnexpectedSuper, { at: t2 }), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(h3.UnsupportedSuper, { at: t2 }), this.finishNode(t2, "Super");
            }
            parsePrivateName() {
              let t2 = this.startNode(), r2 = this.startNodeAt(y2(this.state.startLoc, 1)), e2 = this.state.value;
              return this.next(), t2.id = this.createIdentifier(r2, e2), this.finishNode(t2, "PrivateName");
            }
            parseFunctionOrFunctionSent() {
              let t2 = this.startNode();
              if (this.next(), this.prodParam.hasYield && this.match(16)) {
                let r2 = this.createIdentifier(this.startNodeAtNode(t2), "function");
                return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t2, r2, "sent");
              }
              return this.parseFunction(t2);
            }
            parseMetaProperty(t2, r2, e2) {
              t2.meta = r2;
              let s2 = this.state.containsEsc;
              return t2.property = this.parseIdentifier(true), (t2.property.name !== e2 || s2) && this.raise(h3.UnsupportedMetaProperty, { at: t2.property, target: r2.name, onlyValidPropertyName: e2 }), this.finishNode(t2, "MetaProperty");
            }
            parseImportMetaProperty(t2) {
              let r2 = this.createIdentifier(this.startNodeAtNode(t2), "import");
              return this.next(), this.isContextual(100) && (this.inModule || this.raise(h3.ImportMetaOutsideModule, { at: r2 }), this.sawUnambiguousESM = true), this.parseMetaProperty(t2, r2, "meta");
            }
            parseLiteralAtNode(t2, r2, e2) {
              return this.addExtra(e2, "rawValue", t2), this.addExtra(e2, "raw", this.input.slice(e2.start, this.state.end)), e2.value = t2, this.next(), this.finishNode(e2, r2);
            }
            parseLiteral(t2, r2) {
              let e2 = this.startNode();
              return this.parseLiteralAtNode(t2, r2, e2);
            }
            parseStringLiteral(t2) {
              return this.parseLiteral(t2, "StringLiteral");
            }
            parseNumericLiteral(t2) {
              return this.parseLiteral(t2, "NumericLiteral");
            }
            parseBigIntLiteral(t2) {
              return this.parseLiteral(t2, "BigIntLiteral");
            }
            parseDecimalLiteral(t2) {
              return this.parseLiteral(t2, "DecimalLiteral");
            }
            parseRegExpLiteral(t2) {
              let r2 = this.parseLiteral(t2.value, "RegExpLiteral");
              return r2.pattern = t2.pattern, r2.flags = t2.flags, r2;
            }
            parseBooleanLiteral(t2) {
              let r2 = this.startNode();
              return r2.value = t2, this.next(), this.finishNode(r2, "BooleanLiteral");
            }
            parseNullLiteral() {
              let t2 = this.startNode();
              return this.next(), this.finishNode(t2, "NullLiteral");
            }
            parseParenAndDistinguishExpression(t2) {
              let r2 = this.state.startLoc, e2;
              this.next(), this.expressionScope.enter(Tl());
              let s2 = this.state.maybeInArrowParameters, i2 = this.state.inFSharpPipelineDirectBody;
              this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
              let a2 = this.state.startLoc, n2 = [], o2 = new At(), c2 = true, p2, m2;
              for (; !this.match(11); ) {
                if (c2)
                  c2 = false;
                else if (this.expect(12, o2.optionalParametersLoc === null ? null : o2.optionalParametersLoc), this.match(11)) {
                  m2 = this.state.startLoc;
                  break;
                }
                if (this.match(21)) {
                  let b2 = this.state.startLoc;
                  if (p2 = this.state.startLoc, n2.push(this.parseParenItem(this.parseRestBinding(), b2)), !this.checkCommaAfterRest(41))
                    break;
                } else
                  n2.push(this.parseMaybeAssignAllowIn(o2, this.parseParenItem));
              }
              let x2 = this.state.lastTokEndLoc;
              this.expect(11), this.state.maybeInArrowParameters = s2, this.state.inFSharpPipelineDirectBody = i2;
              let P2 = this.startNodeAt(r2);
              return t2 && this.shouldParseArrow(n2) && (P2 = this.parseArrow(P2)) ? (this.checkDestructuringPrivate(o2), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(P2, n2, false), P2) : (this.expressionScope.exit(), n2.length || this.unexpected(this.state.lastTokStartLoc), m2 && this.unexpected(m2), p2 && this.unexpected(p2), this.checkExpressionErrors(o2, true), this.toReferencedListDeep(n2, true), n2.length > 1 ? (e2 = this.startNodeAt(a2), e2.expressions = n2, this.finishNode(e2, "SequenceExpression"), this.resetEndLocation(e2, x2)) : e2 = n2[0], this.wrapParenthesis(r2, e2));
            }
            wrapParenthesis(t2, r2) {
              if (!this.options.createParenthesizedExpressions)
                return this.addExtra(r2, "parenthesized", true), this.addExtra(r2, "parenStart", t2.index), this.takeSurroundingComments(r2, t2.index, this.state.lastTokEndLoc.index), r2;
              let e2 = this.startNodeAt(t2);
              return e2.expression = r2, this.finishNode(e2, "ParenthesizedExpression");
            }
            shouldParseArrow(t2) {
              return !this.canInsertSemicolon();
            }
            parseArrow(t2) {
              if (this.eat(19))
                return t2;
            }
            parseParenItem(t2, r2) {
              return t2;
            }
            parseNewOrNewTarget() {
              let t2 = this.startNode();
              if (this.next(), this.match(16)) {
                let r2 = this.createIdentifier(this.startNodeAtNode(t2), "new");
                this.next();
                let e2 = this.parseMetaProperty(t2, r2, "target");
                return !this.scope.inNonArrowFunction && !this.scope.inClass && this.raise(h3.UnexpectedNewTarget, { at: e2 }), e2;
              }
              return this.parseNew(t2);
            }
            parseNew(t2) {
              if (this.parseNewCallee(t2), this.eat(10)) {
                let r2 = this.parseExprList(11);
                this.toReferencedList(r2), t2.arguments = r2;
              } else
                t2.arguments = [];
              return this.finishNode(t2, "NewExpression");
            }
            parseNewCallee(t2) {
              t2.callee = this.parseNoCallExpr(), t2.callee.type === "Import" ? this.raise(h3.ImportCallNotNewExpression, { at: t2.callee }) : this.isOptionalChain(t2.callee) ? this.raise(h3.OptionalChainingNoNew, { at: this.state.lastTokEndLoc }) : this.eat(18) && this.raise(h3.OptionalChainingNoNew, { at: this.state.startLoc });
            }
            parseTemplateElement(t2) {
              let { start: r2, startLoc: e2, end: s2, value: i2 } = this.state, a2 = r2 + 1, n2 = this.startNodeAt(y2(e2, 1));
              i2 === null && (t2 || this.raise(h3.InvalidEscapeSequenceTemplate, { at: y2(this.state.firstInvalidTemplateEscapePos, 1) }));
              let o2 = this.match(24), c2 = o2 ? -1 : -2, p2 = s2 + c2;
              n2.value = { raw: this.input.slice(a2, p2).replace(/\r\n?/g, `
`), cooked: i2 === null ? null : i2.slice(1, c2) }, n2.tail = o2, this.next();
              let m2 = this.finishNode(n2, "TemplateElement");
              return this.resetEndLocation(m2, y2(this.state.lastTokEndLoc, c2)), m2;
            }
            parseTemplate(t2) {
              let r2 = this.startNode();
              r2.expressions = [];
              let e2 = this.parseTemplateElement(t2);
              for (r2.quasis = [e2]; !e2.tail; )
                r2.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), r2.quasis.push(e2 = this.parseTemplateElement(t2));
              return this.finishNode(r2, "TemplateLiteral");
            }
            parseTemplateSubstitution() {
              return this.parseExpression();
            }
            parseObjectLike(t2, r2, e2, s2) {
              e2 && this.expectPlugin("recordAndTuple");
              let i2 = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = false;
              let a2 = /* @__PURE__ */ Object.create(null), n2 = true, o2 = this.startNode();
              for (o2.properties = [], this.next(); !this.match(t2); ) {
                if (n2)
                  n2 = false;
                else if (this.expect(12), this.match(t2)) {
                  this.addTrailingCommaExtraToNode(o2);
                  break;
                }
                let p2;
                r2 ? p2 = this.parseBindingProperty() : (p2 = this.parsePropertyDefinition(s2), this.checkProto(p2, e2, a2, s2)), e2 && !this.isObjectProperty(p2) && p2.type !== "SpreadElement" && this.raise(h3.InvalidRecordProperty, { at: p2 }), p2.shorthand && this.addExtra(p2, "shorthand", true), o2.properties.push(p2);
              }
              this.next(), this.state.inFSharpPipelineDirectBody = i2;
              let c2 = "ObjectExpression";
              return r2 ? c2 = "ObjectPattern" : e2 && (c2 = "RecordExpression"), this.finishNode(o2, c2);
            }
            addTrailingCommaExtraToNode(t2) {
              this.addExtra(t2, "trailingComma", this.state.lastTokStart), this.addExtra(t2, "trailingCommaLoc", this.state.lastTokStartLoc, false);
            }
            maybeAsyncOrAccessorProp(t2) {
              return !t2.computed && t2.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
            }
            parsePropertyDefinition(t2) {
              let r2 = [];
              if (this.match(26))
                for (this.hasPlugin("decorators") && this.raise(h3.UnsupportedPropertyDecorator, { at: this.state.startLoc }); this.match(26); )
                  r2.push(this.parseDecorator());
              let e2 = this.startNode(), s2 = false, i2 = false, a2;
              if (this.match(21))
                return r2.length && this.unexpected(), this.parseSpread();
              r2.length && (e2.decorators = r2, r2 = []), e2.method = false, t2 && (a2 = this.state.startLoc);
              let n2 = this.eat(55);
              this.parsePropertyNamePrefixOperator(e2);
              let o2 = this.state.containsEsc, c2 = this.parsePropertyName(e2, t2);
              if (!n2 && !o2 && this.maybeAsyncOrAccessorProp(e2)) {
                let p2 = c2.name;
                p2 === "async" && !this.hasPrecedingLineBreak() && (s2 = true, this.resetPreviousNodeTrailingComments(c2), n2 = this.eat(55), this.parsePropertyName(e2)), (p2 === "get" || p2 === "set") && (i2 = true, this.resetPreviousNodeTrailingComments(c2), e2.kind = p2, this.match(55) && (n2 = true, this.raise(h3.AccessorIsGenerator, { at: this.state.curPosition(), kind: p2 }), this.next()), this.parsePropertyName(e2));
              }
              return this.parseObjPropValue(e2, a2, n2, s2, false, i2, t2);
            }
            getGetterSetterExpectedParamCount(t2) {
              return t2.kind === "get" ? 0 : 1;
            }
            getObjectOrClassMethodParams(t2) {
              return t2.params;
            }
            checkGetterSetterParams(t2) {
              var r2;
              let e2 = this.getGetterSetterExpectedParamCount(t2), s2 = this.getObjectOrClassMethodParams(t2);
              s2.length !== e2 && this.raise(t2.kind === "get" ? h3.BadGetterArity : h3.BadSetterArity, { at: t2 }), t2.kind === "set" && ((r2 = s2[s2.length - 1]) == null ? void 0 : r2.type) === "RestElement" && this.raise(h3.BadSetterRestParameter, { at: t2 });
            }
            parseObjectMethod(t2, r2, e2, s2, i2) {
              if (i2) {
                let a2 = this.parseMethod(t2, r2, false, false, false, "ObjectMethod");
                return this.checkGetterSetterParams(a2), a2;
              }
              if (e2 || r2 || this.match(10))
                return s2 && this.unexpected(), t2.kind = "method", t2.method = true, this.parseMethod(t2, r2, e2, false, false, "ObjectMethod");
            }
            parseObjectProperty(t2, r2, e2, s2) {
              if (t2.shorthand = false, this.eat(14))
                return t2.value = e2 ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(s2), this.finishNode(t2, "ObjectProperty");
              if (!t2.computed && t2.key.type === "Identifier") {
                if (this.checkReservedWord(t2.key.name, t2.key.loc.start, true, false), e2)
                  t2.value = this.parseMaybeDefault(r2, xe(t2.key));
                else if (this.match(29)) {
                  let i2 = this.state.startLoc;
                  s2 != null ? s2.shorthandAssignLoc === null && (s2.shorthandAssignLoc = i2) : this.raise(h3.InvalidCoverInitializedName, { at: i2 }), t2.value = this.parseMaybeDefault(r2, xe(t2.key));
                } else
                  t2.value = xe(t2.key);
                return t2.shorthand = true, this.finishNode(t2, "ObjectProperty");
              }
            }
            parseObjPropValue(t2, r2, e2, s2, i2, a2, n2) {
              let o2 = this.parseObjectMethod(t2, e2, s2, i2, a2) || this.parseObjectProperty(t2, r2, i2, n2);
              return o2 || this.unexpected(), o2;
            }
            parsePropertyName(t2, r2) {
              if (this.eat(0))
                t2.computed = true, t2.key = this.parseMaybeAssignAllowIn(), this.expect(3);
              else {
                let { type: e2, value: s2 } = this.state, i2;
                if (pe(e2))
                  i2 = this.parseIdentifier(true);
                else
                  switch (e2) {
                    case 132:
                      i2 = this.parseNumericLiteral(s2);
                      break;
                    case 131:
                      i2 = this.parseStringLiteral(s2);
                      break;
                    case 133:
                      i2 = this.parseBigIntLiteral(s2);
                      break;
                    case 134:
                      i2 = this.parseDecimalLiteral(s2);
                      break;
                    case 136: {
                      let a2 = this.state.startLoc;
                      r2 != null ? r2.privateKeyLoc === null && (r2.privateKeyLoc = a2) : this.raise(h3.UnexpectedPrivateField, { at: a2 }), i2 = this.parsePrivateName();
                      break;
                    }
                    default:
                      throw this.unexpected();
                  }
                t2.key = i2, e2 !== 136 && (t2.computed = false);
              }
              return t2.key;
            }
            initFunction(t2, r2) {
              t2.id = null, t2.generator = false, t2.async = !!r2;
            }
            parseMethod(t2, r2, e2, s2, i2, a2) {
              let n2 = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
              this.initFunction(t2, e2), t2.generator = !!r2;
              let o2 = s2;
              this.scope.enter(me | lt | (n2 ? Se : 0) | (i2 ? Ar : 0)), this.prodParam.enter(Pt(e2, t2.generator)), this.parseFunctionParams(t2, o2);
              let c2 = this.parseFunctionBodyAndFinish(t2, a2, true);
              return this.prodParam.exit(), this.scope.exit(), c2;
            }
            parseArrayLike(t2, r2, e2, s2) {
              e2 && this.expectPlugin("recordAndTuple");
              let i2 = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = false;
              let a2 = this.startNode();
              return this.next(), a2.elements = this.parseExprList(t2, !e2, s2, a2), this.state.inFSharpPipelineDirectBody = i2, this.finishNode(a2, e2 ? "TupleExpression" : "ArrayExpression");
            }
            parseArrowExpression(t2, r2, e2, s2) {
              this.scope.enter(me | Yt);
              let i2 = Pt(e2, false);
              !this.match(5) && this.prodParam.hasIn && (i2 |= Ue), this.prodParam.enter(i2), this.initFunction(t2, e2);
              let a2 = this.state.maybeInArrowParameters;
              return r2 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t2, r2, s2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t2, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a2, this.finishNode(t2, "ArrowFunctionExpression");
            }
            setArrowFunctionParameters(t2, r2, e2) {
              this.toAssignableList(r2, e2, false), t2.params = r2;
            }
            parseFunctionBodyAndFinish(t2, r2) {
              let e2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return this.parseFunctionBody(t2, false, e2), this.finishNode(t2, r2);
            }
            parseFunctionBody(t2, r2) {
              let e2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s2 = r2 && !this.match(5);
              if (this.expressionScope.enter(Rr()), s2)
                t2.body = this.parseMaybeAssign(), this.checkParams(t2, false, r2, false);
              else {
                let i2 = this.state.strict, a2 = this.state.labels;
                this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | qr), t2.body = this.parseBlock(true, false, (n2) => {
                  let o2 = !this.isSimpleParamList(t2.params);
                  n2 && o2 && this.raise(h3.IllegalLanguageModeDirective, { at: (t2.kind === "method" || t2.kind === "constructor") && !!t2.key ? t2.key.loc.end : t2 });
                  let c2 = !i2 && this.state.strict;
                  this.checkParams(t2, !this.state.strict && !r2 && !e2 && !o2, r2, c2), this.state.strict && t2.id && this.checkIdentifier(t2.id, Go, c2);
                }), this.prodParam.exit(), this.state.labels = a2;
              }
              this.expressionScope.exit();
            }
            isSimpleParameter(t2) {
              return t2.type === "Identifier";
            }
            isSimpleParamList(t2) {
              for (let r2 = 0, e2 = t2.length; r2 < e2; r2++)
                if (!this.isSimpleParameter(t2[r2]))
                  return false;
              return true;
            }
            checkParams(t2, r2, e2) {
              let s2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, i2 = !r2 && /* @__PURE__ */ new Set(), a2 = { type: "FormalParameters" };
              for (let n2 of t2.params)
                this.checkLVal(n2, { in: a2, binding: dt, checkClashes: i2, strictModeChanged: s2 });
            }
            parseExprList(t2, r2, e2, s2) {
              let i2 = [], a2 = true;
              for (; !this.eat(t2); ) {
                if (a2)
                  a2 = false;
                else if (this.expect(12), this.match(t2)) {
                  s2 && this.addTrailingCommaExtraToNode(s2), this.next();
                  break;
                }
                i2.push(this.parseExprListItem(r2, e2));
              }
              return i2;
            }
            parseExprListItem(t2, r2, e2) {
              let s2;
              if (this.match(12))
                t2 || this.raise(h3.UnexpectedToken, { at: this.state.curPosition(), unexpected: "," }), s2 = null;
              else if (this.match(21)) {
                let i2 = this.state.startLoc;
                s2 = this.parseParenItem(this.parseSpread(r2), i2);
              } else if (this.match(17)) {
                this.expectPlugin("partialApplication"), e2 || this.raise(h3.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
                let i2 = this.startNode();
                this.next(), s2 = this.finishNode(i2, "ArgumentPlaceholder");
              } else
                s2 = this.parseMaybeAssignAllowIn(r2, this.parseParenItem);
              return s2;
            }
            parseIdentifier(t2) {
              let r2 = this.startNode(), e2 = this.parseIdentifierName(t2);
              return this.createIdentifier(r2, e2);
            }
            createIdentifier(t2, r2) {
              return t2.name = r2, t2.loc.identifierName = r2, this.finishNode(t2, "Identifier");
            }
            parseIdentifierName(t2) {
              let r2, { startLoc: e2, type: s2 } = this.state;
              if (pe(s2))
                r2 = this.state.value;
              else
                throw this.unexpected();
              let i2 = So(s2);
              return t2 ? i2 && this.replaceToken(130) : this.checkReservedWord(r2, e2, i2, false), this.next(), r2;
            }
            checkReservedWord(t2, r2, e2, s2) {
              if (t2.length > 10 || !Vo(t2))
                return;
              if (t2 === "yield") {
                if (this.prodParam.hasYield) {
                  this.raise(h3.YieldBindingIdentifier, { at: r2 });
                  return;
                }
              } else if (t2 === "await") {
                if (this.prodParam.hasAwait) {
                  this.raise(h3.AwaitBindingIdentifier, { at: r2 });
                  return;
                }
                if (this.scope.inStaticBlock) {
                  this.raise(h3.AwaitBindingIdentifierInStaticBlock, { at: r2 });
                  return;
                }
                this.expressionScope.recordAsyncArrowParametersError({ at: r2 });
              } else if (t2 === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
                this.raise(h3.ArgumentsInClass, { at: r2 });
                return;
              }
              if (e2 && Ho(t2)) {
                this.raise(h3.UnexpectedKeyword, { at: r2, keyword: t2 });
                return;
              }
              (this.state.strict ? s2 ? gr : yr : mr)(t2, this.inModule) && this.raise(h3.UnexpectedReservedWord, { at: r2, reservedWord: t2 });
            }
            isAwaitAllowed() {
              return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
            }
            parseAwait(t2) {
              let r2 = this.startNodeAt(t2);
              return this.expressionScope.recordParameterInitializerError(h3.AwaitExpressionFormalParameter, { at: r2 }), this.eat(55) && this.raise(h3.ObsoleteAwaitStar, { at: r2 }), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (r2.argument = this.parseMaybeUnary(null, true)), this.finishNode(r2, "AwaitExpression");
            }
            isAmbiguousAwait() {
              if (this.hasPrecedingLineBreak())
                return true;
              let { type: t2 } = this.state;
              return t2 === 53 || t2 === 10 || t2 === 0 || ot(t2) || t2 === 135 || t2 === 56 || this.hasPlugin("v8intrinsic") && t2 === 54;
            }
            parseYield() {
              let t2 = this.startNode();
              this.expressionScope.recordParameterInitializerError(h3.YieldInParameter, { at: t2 }), this.next();
              let r2 = false, e2 = null;
              if (!this.hasPrecedingLineBreak())
                switch (r2 = this.eat(55), this.state.type) {
                  case 13:
                  case 137:
                  case 8:
                  case 11:
                  case 3:
                  case 9:
                  case 14:
                  case 12:
                    if (!r2)
                      break;
                  default:
                    e2 = this.parseMaybeAssign();
                }
              return t2.delegate = r2, t2.argument = e2, this.finishNode(t2, "YieldExpression");
            }
            checkPipelineAtInfixOperator(t2, r2) {
              this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && t2.type === "SequenceExpression" && this.raise(h3.PipelineHeadSequenceExpression, { at: r2 });
            }
            parseSmartPipelineBodyInStyle(t2, r2) {
              if (this.isSimpleReference(t2)) {
                let e2 = this.startNodeAt(r2);
                return e2.callee = t2, this.finishNode(e2, "PipelineBareFunction");
              } else {
                let e2 = this.startNodeAt(r2);
                return this.checkSmartPipeTopicBodyEarlyErrors(r2), e2.expression = t2, this.finishNode(e2, "PipelineTopicExpression");
              }
            }
            isSimpleReference(t2) {
              switch (t2.type) {
                case "MemberExpression":
                  return !t2.computed && this.isSimpleReference(t2.object);
                case "Identifier":
                  return true;
                default:
                  return false;
              }
            }
            checkSmartPipeTopicBodyEarlyErrors(t2) {
              if (this.match(19))
                throw this.raise(h3.PipelineBodyNoArrow, { at: this.state.startLoc });
              this.topicReferenceWasUsedInCurrentContext() || this.raise(h3.PipelineTopicUnused, { at: t2 });
            }
            withTopicBindingContext(t2) {
              let r2 = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
              try {
                return t2();
              } finally {
                this.state.topicContext = r2;
              }
            }
            withSmartMixTopicForbiddingContext(t2) {
              if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
                let r2 = this.state.topicContext;
                this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
                try {
                  return t2();
                } finally {
                  this.state.topicContext = r2;
                }
              } else
                return t2();
            }
            withSoloAwaitPermittingContext(t2) {
              let r2 = this.state.soloAwait;
              this.state.soloAwait = true;
              try {
                return t2();
              } finally {
                this.state.soloAwait = r2;
              }
            }
            allowInAnd(t2) {
              let r2 = this.prodParam.currentFlags();
              if (Ue & ~r2) {
                this.prodParam.enter(r2 | Ue);
                try {
                  return t2();
                } finally {
                  this.prodParam.exit();
                }
              }
              return t2();
            }
            disallowInAnd(t2) {
              let r2 = this.prodParam.currentFlags();
              if (Ue & r2) {
                this.prodParam.enter(r2 & ~Ue);
                try {
                  return t2();
                } finally {
                  this.prodParam.exit();
                }
              }
              return t2();
            }
            registerTopicReference() {
              this.state.topicContext.maxTopicIndex = 0;
            }
            topicReferenceIsAllowedInCurrentContext() {
              return this.state.topicContext.maxNumOfResolvableTopics >= 1;
            }
            topicReferenceWasUsedInCurrentContext() {
              return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
            }
            parseFSharpPipelineBody(t2) {
              let r2 = this.state.startLoc;
              this.state.potentialArrowAt = this.state.start;
              let e2 = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = true;
              let s2 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r2, t2);
              return this.state.inFSharpPipelineDirectBody = e2, s2;
            }
            parseModuleExpression() {
              this.expectPlugin("moduleBlocks");
              let t2 = this.startNode();
              this.next(), this.match(5) || this.unexpected(null, 5);
              let r2 = this.startNodeAt(this.state.endLoc);
              this.next();
              let e2 = this.initializeScopes(true);
              this.enterInitialScopes();
              try {
                t2.body = this.parseProgram(r2, 8, "module");
              } finally {
                e2();
              }
              return this.finishNode(t2, "ModuleExpression");
            }
            parsePropertyNamePrefixOperator(t2) {
            }
          }, "Yl"), fs = { kind: "loop" }, Ql = { kind: "switch" }, Zl = 0, ms = 1, Qr = 2, Zr = 4, eh = /[\uD800-\uDFFF]/u, ys = /in(?:stanceof)?/y;
          function th(t2, r2) {
            for (let e2 = 0; e2 < t2.length; e2++) {
              let s2 = t2[e2], { type: i2 } = s2;
              if (typeof i2 == "number") {
                {
                  if (i2 === 136) {
                    let { loc: a2, start: n2, value: o2, end: c2 } = s2, p2 = n2 + 1, m2 = y2(a2.start, 1);
                    t2.splice(e2, 1, new ve({ type: de(27), value: "#", start: n2, end: p2, startLoc: a2.start, endLoc: m2 }), new ve({ type: de(130), value: o2, start: p2, end: c2, startLoc: m2, endLoc: a2.end })), e2++;
                    continue;
                  }
                  if (ot(i2)) {
                    let { loc: a2, start: n2, value: o2, end: c2 } = s2, p2 = n2 + 1, m2 = y2(a2.start, 1), x2;
                    r2.charCodeAt(n2) === 96 ? x2 = new ve({ type: de(22), value: "`", start: n2, end: p2, startLoc: a2.start, endLoc: m2 }) : x2 = new ve({ type: de(8), value: "}", start: n2, end: p2, startLoc: a2.start, endLoc: m2 });
                    let P2, b2, O2, R2;
                    i2 === 24 ? (b2 = c2 - 1, O2 = y2(a2.end, -1), P2 = o2 === null ? null : o2.slice(1, -1), R2 = new ve({ type: de(22), value: "`", start: b2, end: c2, startLoc: O2, endLoc: a2.end })) : (b2 = c2 - 2, O2 = y2(a2.end, -2), P2 = o2 === null ? null : o2.slice(1, -2), R2 = new ve({ type: de(23), value: "${", start: b2, end: c2, startLoc: O2, endLoc: a2.end })), t2.splice(e2, 1, x2, new ve({ type: de(20), value: P2, start: p2, end: b2, startLoc: m2, endLoc: O2 }), R2), e2 += 2;
                    continue;
                  }
                }
                s2.type = de(i2);
              }
            }
            return t2;
          }
          __name(th, "th");
          var sh = /* @__PURE__ */ __name(class extends Yl {
            parseTopLevel(t2, r2) {
              return t2.program = this.parseProgram(r2), t2.comments = this.state.comments, this.options.tokens && (t2.tokens = th(this.tokens, this.input)), this.finishNode(t2, "File");
            }
            parseProgram(t2) {
              let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 137, e2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.options.sourceType;
              if (t2.sourceType = e2, t2.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t2, true, true, r2), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
                for (let [i2, a2] of Array.from(this.scope.undefinedExports))
                  this.raise(h3.ModuleExportUndefined, { at: a2, localName: i2 });
              let s2;
              return r2 === 137 ? s2 = this.finishNode(t2, "Program") : s2 = this.finishNodeAt(t2, "Program", y2(this.state.startLoc, -1)), s2;
            }
            stmtToDirective(t2) {
              let r2 = t2;
              r2.type = "Directive", r2.value = r2.expression, delete r2.expression;
              let e2 = r2.value, s2 = e2.value, i2 = this.input.slice(e2.start, e2.end), a2 = e2.value = i2.slice(1, -1);
              return this.addExtra(e2, "raw", i2), this.addExtra(e2, "rawValue", a2), this.addExtra(e2, "expressionValue", s2), e2.type = "DirectiveLiteral", r2;
            }
            parseInterpreterDirective() {
              if (!this.match(28))
                return null;
              let t2 = this.startNode();
              return t2.value = this.state.value, this.next(), this.finishNode(t2, "InterpreterDirective");
            }
            isLet(t2) {
              return this.isContextual(99) ? this.hasFollowingIdentifier(t2) : false;
            }
            hasFollowingIdentifier(t2) {
              let r2 = this.nextTokenStart(), e2 = this.codePointAtPos(r2);
              if (e2 === 92 || e2 === 91)
                return true;
              if (t2)
                return false;
              if (e2 === 123)
                return true;
              if (fe(e2)) {
                if (ys.lastIndex = r2, ys.test(this.input)) {
                  let s2 = this.codePointAtPos(ys.lastIndex);
                  if (!Be(s2) && s2 !== 92)
                    return false;
                }
                return true;
              }
              return false;
            }
            startsUsingForOf() {
              let t2 = this.lookahead();
              return t2.type === 101 && !t2.containsEsc ? false : (this.expectPlugin("explicitResourceManagement"), true);
            }
            parseStatement(t2, r2) {
              let e2 = null;
              return this.match(26) && (e2 = this.parseDecorators(true)), this.parseStatementContent(t2, r2, e2);
            }
            parseStatementContent(t2, r2, e2) {
              let s2 = this.state.type, i2 = this.startNode();
              switch (s2) {
                case 60:
                  return this.parseBreakContinueStatement(i2, true);
                case 63:
                  return this.parseBreakContinueStatement(i2, false);
                case 64:
                  return this.parseDebuggerStatement(i2);
                case 90:
                  return this.parseDoStatement(i2);
                case 91:
                  return this.parseForStatement(i2);
                case 68:
                  if (this.lookaheadCharCode() === 46)
                    break;
                  return t2 && (this.state.strict ? this.raise(h3.StrictFunction, { at: this.state.startLoc }) : t2 !== "if" && t2 !== "label" && this.raise(h3.SloppyFunction, { at: this.state.startLoc })), this.parseFunctionStatement(i2, false, !t2);
                case 80:
                  return t2 && this.unexpected(), this.parseClass(this.maybeTakeDecorators(e2, i2), true);
                case 69:
                  return this.parseIfStatement(i2);
                case 70:
                  return this.parseReturnStatement(i2);
                case 71:
                  return this.parseSwitchStatement(i2);
                case 72:
                  return this.parseThrowStatement(i2);
                case 73:
                  return this.parseTryStatement(i2);
                case 105:
                  if (this.hasFollowingLineBreak())
                    break;
                case 99:
                  if (this.state.containsEsc || !this.hasFollowingIdentifier(t2))
                    break;
                case 75:
                case 74: {
                  let o2 = this.state.value;
                  return o2 === "using" && (this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel && this.raise(h3.UnexpectedUsingDeclaration, { at: this.state.startLoc })), t2 && o2 !== "var" && this.raise(h3.UnexpectedLexicalDeclaration, { at: this.state.startLoc }), this.parseVarStatement(i2, o2);
                }
                case 92:
                  return this.parseWhileStatement(i2);
                case 76:
                  return this.parseWithStatement(i2);
                case 5:
                  return this.parseBlock();
                case 13:
                  return this.parseEmptyStatement(i2);
                case 83: {
                  let o2 = this.lookaheadCharCode();
                  if (o2 === 40 || o2 === 46)
                    break;
                }
                case 82: {
                  !this.options.allowImportExportEverywhere && !r2 && this.raise(h3.UnexpectedImportExport, { at: this.state.startLoc }), this.next();
                  let o2;
                  return s2 === 83 ? (o2 = this.parseImport(i2), o2.type === "ImportDeclaration" && (!o2.importKind || o2.importKind === "value") && (this.sawUnambiguousESM = true)) : (o2 = this.parseExport(i2, e2), (o2.type === "ExportNamedDeclaration" && (!o2.exportKind || o2.exportKind === "value") || o2.type === "ExportAllDeclaration" && (!o2.exportKind || o2.exportKind === "value") || o2.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(o2), o2;
                }
                default:
                  if (this.isAsyncFunction())
                    return t2 && this.raise(h3.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }), this.next(), this.parseFunctionStatement(i2, true, !t2);
              }
              let a2 = this.state.value, n2 = this.parseExpression();
              return $(s2) && n2.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i2, a2, n2, t2) : this.parseExpressionStatement(i2, n2, e2);
            }
            assertModuleNodeAllowed(t2) {
              !this.options.allowImportExportEverywhere && !this.inModule && this.raise(h3.ImportOutsideModule, { at: t2 });
            }
            decoratorsEnabledBeforeExport() {
              return this.hasPlugin("decorators-legacy") ? true : this.hasPlugin("decorators") && !!this.getPluginOption("decorators", "decoratorsBeforeExport");
            }
            maybeTakeDecorators(t2, r2, e2) {
              return t2 && (r2.decorators = t2, this.resetStartLocationFromNode(r2, t2[0]), e2 && this.resetStartLocationFromNode(e2, r2)), r2;
            }
            canHaveLeadingDecorator() {
              return this.match(80);
            }
            parseDecorators(t2) {
              let r2 = [];
              do
                r2.push(this.parseDecorator());
              while (this.match(26));
              if (this.match(82))
                t2 || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(h3.DecoratorExportClass, { at: this.state.startLoc });
              else if (!this.canHaveLeadingDecorator())
                throw this.raise(h3.UnexpectedLeadingDecorator, { at: this.state.startLoc });
              return r2;
            }
            parseDecorator() {
              this.expectOnePlugin(["decorators", "decorators-legacy"]);
              let t2 = this.startNode();
              if (this.next(), this.hasPlugin("decorators")) {
                let r2 = this.state.startLoc, e2;
                if (this.match(10)) {
                  let s2 = this.state.startLoc;
                  this.next(), e2 = this.parseExpression(), this.expect(11), e2 = this.wrapParenthesis(s2, e2);
                  let i2 = this.state.startLoc;
                  t2.expression = this.parseMaybeDecoratorArguments(e2), this.getPluginOption("decorators", "allowCallParenthesized") === false && t2.expression !== e2 && this.raise(h3.DecoratorArgumentsOutsideParentheses, { at: i2 });
                } else {
                  for (e2 = this.parseIdentifier(false); this.eat(16); ) {
                    let s2 = this.startNodeAt(r2);
                    s2.object = e2, this.match(136) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), s2.property = this.parsePrivateName()) : s2.property = this.parseIdentifier(true), s2.computed = false, e2 = this.finishNode(s2, "MemberExpression");
                  }
                  t2.expression = this.parseMaybeDecoratorArguments(e2);
                }
              } else
                t2.expression = this.parseExprSubscripts();
              return this.finishNode(t2, "Decorator");
            }
            parseMaybeDecoratorArguments(t2) {
              if (this.eat(10)) {
                let r2 = this.startNodeAtNode(t2);
                return r2.callee = t2, r2.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(r2.arguments), this.finishNode(r2, "CallExpression");
              }
              return t2;
            }
            parseBreakContinueStatement(t2, r2) {
              return this.next(), this.isLineTerminator() ? t2.label = null : (t2.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t2, r2), this.finishNode(t2, r2 ? "BreakStatement" : "ContinueStatement");
            }
            verifyBreakContinue(t2, r2) {
              let e2;
              for (e2 = 0; e2 < this.state.labels.length; ++e2) {
                let s2 = this.state.labels[e2];
                if ((t2.label == null || s2.name === t2.label.name) && (s2.kind != null && (r2 || s2.kind === "loop") || t2.label && r2))
                  break;
              }
              if (e2 === this.state.labels.length) {
                let s2 = r2 ? "BreakStatement" : "ContinueStatement";
                this.raise(h3.IllegalBreakContinue, { at: t2, type: s2 });
              }
            }
            parseDebuggerStatement(t2) {
              return this.next(), this.semicolon(), this.finishNode(t2, "DebuggerStatement");
            }
            parseHeaderExpression() {
              this.expect(10);
              let t2 = this.parseExpression();
              return this.expect(11), t2;
            }
            parseDoStatement(t2) {
              return this.next(), this.state.labels.push(fs), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(92), t2.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t2, "DoWhileStatement");
            }
            parseForStatement(t2) {
              this.next(), this.state.labels.push(fs);
              let r2 = null;
              if (this.isAwaitAllowed() && this.eatContextual(96) && (r2 = this.state.lastTokStartLoc), this.scope.enter(_e), this.expect(10), this.match(13))
                return r2 !== null && this.unexpected(r2), this.parseFor(t2, null);
              let e2 = this.isContextual(99), s2 = this.isContextual(105) && !this.hasFollowingLineBreak(), i2 = e2 && this.hasFollowingIdentifier() || s2 && this.hasFollowingIdentifier() && this.startsUsingForOf();
              if (this.match(74) || this.match(75) || i2) {
                let p2 = this.startNode(), m2 = this.state.value;
                this.next(), this.parseVar(p2, true, m2);
                let x2 = this.finishNode(p2, "VariableDeclaration"), P2 = this.match(58);
                return P2 && s2 && this.raise(h3.ForInUsing, { at: x2 }), (P2 || this.isContextual(101)) && x2.declarations.length === 1 ? this.parseForIn(t2, x2, r2) : (r2 !== null && this.unexpected(r2), this.parseFor(t2, x2));
              }
              let a2 = this.isContextual(95), n2 = new At(), o2 = this.parseExpression(true, n2), c2 = this.isContextual(101);
              if (c2 && (e2 && this.raise(h3.ForOfLet, { at: o2 }), r2 === null && a2 && o2.type === "Identifier" && this.raise(h3.ForOfAsync, { at: o2 })), c2 || this.match(58)) {
                this.checkDestructuringPrivate(n2), this.toAssignable(o2, true);
                let p2 = c2 ? "ForOfStatement" : "ForInStatement";
                return this.checkLVal(o2, { in: { type: p2 } }), this.parseForIn(t2, o2, r2);
              } else
                this.checkExpressionErrors(n2, true);
              return r2 !== null && this.unexpected(r2), this.parseFor(t2, o2);
            }
            parseFunctionStatement(t2, r2, e2) {
              return this.next(), this.parseFunction(t2, ms | (e2 ? 0 : Qr), r2);
            }
            parseIfStatement(t2) {
              return this.next(), t2.test = this.parseHeaderExpression(), t2.consequent = this.parseStatement("if"), t2.alternate = this.eat(66) ? this.parseStatement("if") : null, this.finishNode(t2, "IfStatement");
            }
            parseReturnStatement(t2) {
              return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(h3.IllegalReturn, { at: this.state.startLoc }), this.next(), this.isLineTerminator() ? t2.argument = null : (t2.argument = this.parseExpression(), this.semicolon()), this.finishNode(t2, "ReturnStatement");
            }
            parseSwitchStatement(t2) {
              this.next(), t2.discriminant = this.parseHeaderExpression();
              let r2 = t2.cases = [];
              this.expect(5), this.state.labels.push(Ql), this.scope.enter(_e);
              let e2;
              for (let s2; !this.match(8); )
                if (this.match(61) || this.match(65)) {
                  let i2 = this.match(61);
                  e2 && this.finishNode(e2, "SwitchCase"), r2.push(e2 = this.startNode()), e2.consequent = [], this.next(), i2 ? e2.test = this.parseExpression() : (s2 && this.raise(h3.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }), s2 = true, e2.test = null), this.expect(14);
                } else
                  e2 ? e2.consequent.push(this.parseStatement(null)) : this.unexpected();
              return this.scope.exit(), e2 && this.finishNode(e2, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t2, "SwitchStatement");
            }
            parseThrowStatement(t2) {
              return this.next(), this.hasPrecedingLineBreak() && this.raise(h3.NewlineAfterThrow, { at: this.state.lastTokEndLoc }), t2.argument = this.parseExpression(), this.semicolon(), this.finishNode(t2, "ThrowStatement");
            }
            parseCatchClauseParam() {
              let t2 = this.parseBindingAtom(), r2 = t2.type === "Identifier";
              return this.scope.enter(r2 ? Pr : 0), this.checkLVal(t2, { in: { type: "CatchClause" }, binding: Ie, allowingSloppyLetBinding: true }), t2;
            }
            parseTryStatement(t2) {
              if (this.next(), t2.block = this.parseBlock(), t2.handler = null, this.match(62)) {
                let r2 = this.startNode();
                this.next(), this.match(10) ? (this.expect(10), r2.param = this.parseCatchClauseParam(), this.expect(11)) : (r2.param = null, this.scope.enter(_e)), r2.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t2.handler = this.finishNode(r2, "CatchClause");
              }
              return t2.finalizer = this.eat(67) ? this.parseBlock() : null, !t2.handler && !t2.finalizer && this.raise(h3.NoCatchOrFinally, { at: t2 }), this.finishNode(t2, "TryStatement");
            }
            parseVarStatement(t2, r2) {
              let e2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return this.next(), this.parseVar(t2, false, r2, e2), this.semicolon(), this.finishNode(t2, "VariableDeclaration");
            }
            parseWhileStatement(t2) {
              return this.next(), t2.test = this.parseHeaderExpression(), this.state.labels.push(fs), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(t2, "WhileStatement");
            }
            parseWithStatement(t2) {
              return this.state.strict && this.raise(h3.StrictWith, { at: this.state.startLoc }), this.next(), t2.object = this.parseHeaderExpression(), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(t2, "WithStatement");
            }
            parseEmptyStatement(t2) {
              return this.next(), this.finishNode(t2, "EmptyStatement");
            }
            parseLabeledStatement(t2, r2, e2, s2) {
              for (let a2 of this.state.labels)
                a2.name === r2 && this.raise(h3.LabelRedeclaration, { at: e2, labelName: r2 });
              let i2 = No(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
              for (let a2 = this.state.labels.length - 1; a2 >= 0; a2--) {
                let n2 = this.state.labels[a2];
                if (n2.statementStart === t2.start)
                  n2.statementStart = this.state.start, n2.kind = i2;
                else
                  break;
              }
              return this.state.labels.push({ name: r2, kind: i2, statementStart: this.state.start }), t2.body = this.parseStatement(s2 ? s2.indexOf("label") === -1 ? s2 + "label" : s2 : "label"), this.state.labels.pop(), t2.label = e2, this.finishNode(t2, "LabeledStatement");
            }
            parseExpressionStatement(t2, r2, e2) {
              return t2.expression = r2, this.semicolon(), this.finishNode(t2, "ExpressionStatement");
            }
            parseBlock() {
              let t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, e2 = arguments.length > 2 ? arguments[2] : void 0, s2 = this.startNode();
              return t2 && this.state.strictErrors.clear(), this.expect(5), r2 && this.scope.enter(_e), this.parseBlockBody(s2, t2, false, 8, e2), r2 && this.scope.exit(), this.finishNode(s2, "BlockStatement");
            }
            isValidDirective(t2) {
              return t2.type === "ExpressionStatement" && t2.expression.type === "StringLiteral" && !t2.expression.extra.parenthesized;
            }
            parseBlockBody(t2, r2, e2, s2, i2) {
              let a2 = t2.body = [], n2 = t2.directives = [];
              this.parseBlockOrModuleBlockBody(a2, r2 ? n2 : void 0, e2, s2, i2);
            }
            parseBlockOrModuleBlockBody(t2, r2, e2, s2, i2) {
              let a2 = this.state.strict, n2 = false, o2 = false;
              for (; !this.match(s2); ) {
                let c2 = this.parseStatement(null, e2);
                if (r2 && !o2) {
                  if (this.isValidDirective(c2)) {
                    let p2 = this.stmtToDirective(c2);
                    r2.push(p2), !n2 && p2.value.value === "use strict" && (n2 = true, this.setStrict(true));
                    continue;
                  }
                  o2 = true, this.state.strictErrors.clear();
                }
                t2.push(c2);
              }
              i2 && i2.call(this, n2), a2 || this.setStrict(false), this.next();
            }
            parseFor(t2, r2) {
              return t2.init = r2, this.semicolon(false), t2.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t2.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t2, "ForStatement");
            }
            parseForIn(t2, r2, e2) {
              let s2 = this.match(58);
              return this.next(), s2 ? e2 !== null && this.unexpected(e2) : t2.await = e2 !== null, r2.type === "VariableDeclaration" && r2.declarations[0].init != null && (!s2 || this.state.strict || r2.kind !== "var" || r2.declarations[0].id.type !== "Identifier") && this.raise(h3.ForInOfLoopInitializer, { at: r2, type: s2 ? "ForInStatement" : "ForOfStatement" }), r2.type === "AssignmentPattern" && this.raise(h3.InvalidLhs, { at: r2, ancestor: { type: "ForStatement" } }), t2.left = r2, t2.right = s2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t2, s2 ? "ForInStatement" : "ForOfStatement");
            }
            parseVar(t2, r2, e2) {
              let s2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, i2 = t2.declarations = [];
              for (t2.kind = e2; ; ) {
                let a2 = this.startNode();
                if (this.parseVarId(a2, e2), a2.init = this.eat(29) ? r2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, a2.init === null && !s2 && (a2.id.type !== "Identifier" && !(r2 && (this.match(58) || this.isContextual(101))) ? this.raise(h3.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "destructuring" }) : e2 === "const" && !(this.match(58) || this.isContextual(101)) && this.raise(h3.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "const" })), i2.push(this.finishNode(a2, "VariableDeclarator")), !this.eat(12))
                  break;
              }
              return t2;
            }
            parseVarId(t2, r2) {
              let e2 = this.parseBindingAtom();
              r2 === "using" && e2.type !== "Identifier" && this.raise(h3.UsingDeclarationHasBindingPattern, { at: e2 }), this.checkLVal(e2, { in: { type: "VariableDeclarator" }, binding: r2 === "var" ? dt : Ie }), t2.id = e2;
            }
            parseFunction(t2) {
              let r2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Zl, e2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s2 = r2 & ms, i2 = r2 & Qr, a2 = !!s2 && !(r2 & Zr);
              this.initFunction(t2, e2), this.match(55) && i2 && this.raise(h3.GeneratorInSingleStatementContext, { at: this.state.startLoc }), t2.generator = this.eat(55), s2 && (t2.id = this.parseFunctionId(a2));
              let n2 = this.state.maybeInArrowParameters;
              return this.state.maybeInArrowParameters = false, this.scope.enter(me), this.prodParam.enter(Pt(e2, t2.generator)), s2 || (t2.id = this.parseFunctionId()), this.parseFunctionParams(t2, false), this.withSmartMixTopicForbiddingContext(() => {
                this.parseFunctionBodyAndFinish(t2, s2 ? "FunctionDeclaration" : "FunctionExpression");
              }), this.prodParam.exit(), this.scope.exit(), s2 && !i2 && this.registerFunctionStatementId(t2), this.state.maybeInArrowParameters = n2, t2;
            }
            parseFunctionId(t2) {
              return t2 || $(this.state.type) ? this.parseIdentifier() : null;
            }
            parseFunctionParams(t2, r2) {
              this.expect(10), this.expressionScope.enter(Al()), t2.params = this.parseBindingList(11, 41, false, r2), this.expressionScope.exit();
            }
            registerFunctionStatementId(t2) {
              !t2.id || this.scope.declareName(t2.id.name, this.state.strict || t2.generator || t2.async ? this.scope.treatFunctionsAsVar ? dt : Ie : Cr, t2.id.loc.start);
            }
            parseClass(t2, r2, e2) {
              this.next();
              let s2 = this.state.strict;
              return this.state.strict = true, this.parseClassId(t2, r2, e2), this.parseClassSuper(t2), t2.body = this.parseClassBody(!!t2.superClass, s2), this.finishNode(t2, r2 ? "ClassDeclaration" : "ClassExpression");
            }
            isClassProperty() {
              return this.match(29) || this.match(13) || this.match(8);
            }
            isClassMethod() {
              return this.match(10);
            }
            isNonstaticConstructor(t2) {
              return !t2.computed && !t2.static && (t2.key.name === "constructor" || t2.key.value === "constructor");
            }
            parseClassBody(t2, r2) {
              this.classScope.enter();
              let e2 = { hadConstructor: false, hadSuperClass: t2 }, s2 = [], i2 = this.startNode();
              if (i2.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
                for (; !this.match(8); ) {
                  if (this.eat(13)) {
                    if (s2.length > 0)
                      throw this.raise(h3.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
                    continue;
                  }
                  if (this.match(26)) {
                    s2.push(this.parseDecorator());
                    continue;
                  }
                  let a2 = this.startNode();
                  s2.length && (a2.decorators = s2, this.resetStartLocationFromNode(a2, s2[0]), s2 = []), this.parseClassMember(i2, a2, e2), a2.kind === "constructor" && a2.decorators && a2.decorators.length > 0 && this.raise(h3.DecoratorConstructor, { at: a2 });
                }
              }), this.state.strict = r2, this.next(), s2.length)
                throw this.raise(h3.TrailingDecorator, { at: this.state.startLoc });
              return this.classScope.exit(), this.finishNode(i2, "ClassBody");
            }
            parseClassMemberFromModifier(t2, r2) {
              let e2 = this.parseIdentifier(true);
              if (this.isClassMethod()) {
                let s2 = r2;
                return s2.kind = "method", s2.computed = false, s2.key = e2, s2.static = false, this.pushClassMethod(t2, s2, false, false, false, false), true;
              } else if (this.isClassProperty()) {
                let s2 = r2;
                return s2.computed = false, s2.key = e2, s2.static = false, t2.body.push(this.parseClassProperty(s2)), true;
              }
              return this.resetPreviousNodeTrailingComments(e2), false;
            }
            parseClassMember(t2, r2, e2) {
              let s2 = this.isContextual(104);
              if (s2) {
                if (this.parseClassMemberFromModifier(t2, r2))
                  return;
                if (this.eat(5)) {
                  this.parseClassStaticBlock(t2, r2);
                  return;
                }
              }
              this.parseClassMemberWithIsStatic(t2, r2, e2, s2);
            }
            parseClassMemberWithIsStatic(t2, r2, e2, s2) {
              let i2 = r2, a2 = r2, n2 = r2, o2 = r2, c2 = r2, p2 = i2, m2 = i2;
              if (r2.static = s2, this.parsePropertyNamePrefixOperator(r2), this.eat(55)) {
                p2.kind = "method";
                let R2 = this.match(136);
                if (this.parseClassElementName(p2), R2) {
                  this.pushClassPrivateMethod(t2, a2, true, false);
                  return;
                }
                this.isNonstaticConstructor(i2) && this.raise(h3.ConstructorIsGenerator, { at: i2.key }), this.pushClassMethod(t2, i2, true, false, false, false);
                return;
              }
              let x2 = $(this.state.type) && !this.state.containsEsc, P2 = this.match(136), b2 = this.parseClassElementName(r2), O2 = this.state.startLoc;
              if (this.parsePostMemberNameModifiers(m2), this.isClassMethod()) {
                if (p2.kind = "method", P2) {
                  this.pushClassPrivateMethod(t2, a2, false, false);
                  return;
                }
                let R2 = this.isNonstaticConstructor(i2), Q = false;
                R2 && (i2.kind = "constructor", e2.hadConstructor && !this.hasPlugin("typescript") && this.raise(h3.DuplicateConstructor, { at: b2 }), R2 && this.hasPlugin("typescript") && r2.override && this.raise(h3.OverrideOnConstructor, { at: b2 }), e2.hadConstructor = true, Q = e2.hadSuperClass), this.pushClassMethod(t2, i2, false, false, R2, Q);
              } else if (this.isClassProperty())
                P2 ? this.pushClassPrivateProperty(t2, o2) : this.pushClassProperty(t2, n2);
              else if (x2 && b2.name === "async" && !this.isLineTerminator()) {
                this.resetPreviousNodeTrailingComments(b2);
                let R2 = this.eat(55);
                m2.optional && this.unexpected(O2), p2.kind = "method";
                let Q = this.match(136);
                this.parseClassElementName(p2), this.parsePostMemberNameModifiers(m2), Q ? this.pushClassPrivateMethod(t2, a2, R2, true) : (this.isNonstaticConstructor(i2) && this.raise(h3.ConstructorIsAsync, { at: i2.key }), this.pushClassMethod(t2, i2, R2, true, false, false));
              } else if (x2 && (b2.name === "get" || b2.name === "set") && !(this.match(55) && this.isLineTerminator())) {
                this.resetPreviousNodeTrailingComments(b2), p2.kind = b2.name;
                let R2 = this.match(136);
                this.parseClassElementName(i2), R2 ? this.pushClassPrivateMethod(t2, a2, false, false) : (this.isNonstaticConstructor(i2) && this.raise(h3.ConstructorIsAccessor, { at: i2.key }), this.pushClassMethod(t2, i2, false, false, false, false)), this.checkGetterSetterParams(i2);
              } else if (x2 && b2.name === "accessor" && !this.isLineTerminator()) {
                this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(b2);
                let R2 = this.match(136);
                this.parseClassElementName(n2), this.pushClassAccessorProperty(t2, c2, R2);
              } else
                this.isLineTerminator() ? P2 ? this.pushClassPrivateProperty(t2, o2) : this.pushClassProperty(t2, n2) : this.unexpected();
            }
            parseClassElementName(t2) {
              let { type: r2, value: e2 } = this.state;
              if ((r2 === 130 || r2 === 131) && t2.static && e2 === "prototype" && this.raise(h3.StaticPrototype, { at: this.state.startLoc }), r2 === 136) {
                e2 === "constructor" && this.raise(h3.ConstructorClassPrivateField, { at: this.state.startLoc });
                let s2 = this.parsePrivateName();
                return t2.key = s2, s2;
              }
              return this.parsePropertyName(t2);
            }
            parseClassStaticBlock(t2, r2) {
              var e2;
              this.scope.enter(Se | ht | lt);
              let s2 = this.state.labels;
              this.state.labels = [], this.prodParam.enter(qe);
              let i2 = r2.body = [];
              this.parseBlockOrModuleBlockBody(i2, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = s2, t2.body.push(this.finishNode(r2, "StaticBlock")), (e2 = r2.decorators) != null && e2.length && this.raise(h3.DecoratorStaticBlock, { at: r2 });
            }
            pushClassProperty(t2, r2) {
              !r2.computed && (r2.key.name === "constructor" || r2.key.value === "constructor") && this.raise(h3.ConstructorClassField, { at: r2.key }), t2.body.push(this.parseClassProperty(r2));
            }
            pushClassPrivateProperty(t2, r2) {
              let e2 = this.parseClassPrivateProperty(r2);
              t2.body.push(e2), this.classScope.declarePrivateName(this.getPrivateNameSV(e2.key), as, e2.key.loc.start);
            }
            pushClassAccessorProperty(t2, r2, e2) {
              if (!e2 && !r2.computed) {
                let i2 = r2.key;
                (i2.name === "constructor" || i2.value === "constructor") && this.raise(h3.ConstructorClassField, { at: i2 });
              }
              let s2 = this.parseClassAccessorProperty(r2);
              t2.body.push(s2), e2 && this.classScope.declarePrivateName(this.getPrivateNameSV(s2.key), as, s2.key.loc.start);
            }
            pushClassMethod(t2, r2, e2, s2, i2, a2) {
              t2.body.push(this.parseMethod(r2, e2, s2, i2, a2, "ClassMethod", true));
            }
            pushClassPrivateMethod(t2, r2, e2, s2) {
              let i2 = this.parseMethod(r2, e2, s2, false, false, "ClassPrivateMethod", true);
              t2.body.push(i2);
              let a2 = i2.kind === "get" ? i2.static ? Qo : el : i2.kind === "set" ? i2.static ? Zo : tl : as;
              this.declareClassPrivateMethodInScope(i2, a2);
            }
            declareClassPrivateMethodInScope(t2, r2) {
              this.classScope.declarePrivateName(this.getPrivateNameSV(t2.key), r2, t2.key.loc.start);
            }
            parsePostMemberNameModifiers(t2) {
            }
            parseClassPrivateProperty(t2) {
              return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassPrivateProperty");
            }
            parseClassProperty(t2) {
              return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassProperty");
            }
            parseClassAccessorProperty(t2) {
              return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassAccessorProperty");
            }
            parseInitializer(t2) {
              this.scope.enter(Se | lt), this.expressionScope.enter(Rr()), this.prodParam.enter(qe), t2.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
            }
            parseClassId(t2, r2, e2) {
              let s2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Er;
              if ($(this.state.type))
                t2.id = this.parseIdentifier(), r2 && this.declareNameFromIdentifier(t2.id, s2);
              else if (e2 || !r2)
                t2.id = null;
              else
                throw this.raise(h3.MissingClassName, { at: this.state.startLoc });
            }
            parseClassSuper(t2) {
              t2.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
            }
            parseExport(t2, r2) {
              let e2 = this.maybeParseExportDefaultSpecifier(t2), s2 = !e2 || this.eat(12), i2 = s2 && this.eatExportStar(t2), a2 = i2 && this.maybeParseExportNamespaceSpecifier(t2), n2 = s2 && (!a2 || this.eat(12)), o2 = e2 || i2;
              if (i2 && !a2) {
                if (e2 && this.unexpected(), r2)
                  throw this.raise(h3.UnsupportedDecoratorExport, { at: t2 });
                return this.parseExportFrom(t2, true), this.finishNode(t2, "ExportAllDeclaration");
              }
              let c2 = this.maybeParseExportNamedSpecifiers(t2);
              if (e2 && s2 && !i2 && !c2 || a2 && n2 && !c2)
                throw this.unexpected(null, 5);
              let p2;
              if (o2 || c2) {
                if (p2 = false, r2)
                  throw this.raise(h3.UnsupportedDecoratorExport, { at: t2 });
                this.parseExportFrom(t2, o2);
              } else
                p2 = this.maybeParseExportDeclaration(t2);
              if (o2 || c2 || p2) {
                var m2;
                let x2 = t2;
                if (this.checkExport(x2, true, false, !!x2.source), ((m2 = x2.declaration) == null ? void 0 : m2.type) === "ClassDeclaration")
                  this.maybeTakeDecorators(r2, x2.declaration, x2);
                else if (r2)
                  throw this.raise(h3.UnsupportedDecoratorExport, { at: t2 });
                return this.finishNode(x2, "ExportNamedDeclaration");
              }
              if (this.eat(65)) {
                let x2 = t2, P2 = this.parseExportDefaultExpression();
                if (x2.declaration = P2, P2.type === "ClassDeclaration")
                  this.maybeTakeDecorators(r2, P2, x2);
                else if (r2)
                  throw this.raise(h3.UnsupportedDecoratorExport, { at: t2 });
                return this.checkExport(x2, true, true), this.finishNode(x2, "ExportDefaultDeclaration");
              }
              throw this.unexpected(null, 5);
            }
            eatExportStar(t2) {
              return this.eat(55);
            }
            maybeParseExportDefaultSpecifier(t2) {
              if (this.isExportDefaultSpecifier()) {
                this.expectPlugin("exportDefaultFrom");
                let r2 = this.startNode();
                return r2.exported = this.parseIdentifier(true), t2.specifiers = [this.finishNode(r2, "ExportDefaultSpecifier")], true;
              }
              return false;
            }
            maybeParseExportNamespaceSpecifier(t2) {
              if (this.isContextual(93)) {
                t2.specifiers || (t2.specifiers = []);
                let r2 = this.startNodeAt(this.state.lastTokStartLoc);
                return this.next(), r2.exported = this.parseModuleExportName(), t2.specifiers.push(this.finishNode(r2, "ExportNamespaceSpecifier")), true;
              }
              return false;
            }
            maybeParseExportNamedSpecifiers(t2) {
              if (this.match(5)) {
                t2.specifiers || (t2.specifiers = []);
                let r2 = t2.exportKind === "type";
                return t2.specifiers.push(...this.parseExportSpecifiers(r2)), t2.source = null, t2.declaration = null, this.hasPlugin("importAssertions") && (t2.assertions = []), true;
              }
              return false;
            }
            maybeParseExportDeclaration(t2) {
              return this.shouldParseExportDeclaration() ? (t2.specifiers = [], t2.source = null, this.hasPlugin("importAssertions") && (t2.assertions = []), t2.declaration = this.parseExportDeclaration(t2), true) : false;
            }
            isAsyncFunction() {
              if (!this.isContextual(95))
                return false;
              let t2 = this.nextTokenStart();
              return !ls.test(this.input.slice(this.state.pos, t2)) && this.isUnparsedContextual(t2, "function");
            }
            parseExportDefaultExpression() {
              let t2 = this.startNode(), r2 = this.isAsyncFunction();
              if (this.match(68) || r2)
                return this.next(), r2 && this.next(), this.parseFunction(t2, ms | Zr, r2);
              if (this.match(80))
                return this.parseClass(t2, true, true);
              if (this.match(26))
                return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(h3.DecoratorBeforeExport, { at: this.state.startLoc }), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
              if (this.match(75) || this.match(74) || this.isLet())
                throw this.raise(h3.UnsupportedDefaultExport, { at: this.state.startLoc });
              let e2 = this.parseMaybeAssignAllowIn();
              return this.semicolon(), e2;
            }
            parseExportDeclaration(t2) {
              return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatement(null);
            }
            isExportDefaultSpecifier() {
              let { type: t2 } = this.state;
              if ($(t2)) {
                if (t2 === 95 && !this.state.containsEsc || t2 === 99)
                  return false;
                if ((t2 === 128 || t2 === 127) && !this.state.containsEsc) {
                  let { type: s2 } = this.lookahead();
                  if ($(s2) && s2 !== 97 || s2 === 5)
                    return this.expectOnePlugin(["flow", "typescript"]), false;
                }
              } else if (!this.match(65))
                return false;
              let r2 = this.nextTokenStart(), e2 = this.isUnparsedContextual(r2, "from");
              if (this.input.charCodeAt(r2) === 44 || $(this.state.type) && e2)
                return true;
              if (this.match(65) && e2) {
                let s2 = this.input.charCodeAt(this.nextTokenStartSince(r2 + 4));
                return s2 === 34 || s2 === 39;
              }
              return false;
            }
            parseExportFrom(t2, r2) {
              if (this.eatContextual(97)) {
                t2.source = this.parseImportSource(), this.checkExport(t2);
                let e2 = this.maybeParseImportAssertions();
                e2 && (t2.assertions = e2, this.checkJSONModuleImport(t2));
              } else
                r2 && this.unexpected();
              this.semicolon();
            }
            shouldParseExportDeclaration() {
              let { type: t2 } = this.state;
              if (t2 === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
                if (this.getPluginOption("decorators", "decoratorsBeforeExport"))
                  throw this.raise(h3.DecoratorBeforeExport, { at: this.state.startLoc });
                return true;
              }
              return t2 === 74 || t2 === 75 || t2 === 68 || t2 === 80 || this.isLet() || this.isAsyncFunction();
            }
            checkExport(t2, r2, e2, s2) {
              if (r2) {
                if (e2) {
                  if (this.checkDuplicateExports(t2, "default"), this.hasPlugin("exportDefaultFrom")) {
                    var i2;
                    let a2 = t2.declaration;
                    a2.type === "Identifier" && a2.name === "from" && a2.end - a2.start === 4 && !((i2 = a2.extra) != null && i2.parenthesized) && this.raise(h3.ExportDefaultFromAsIdentifier, { at: a2 });
                  }
                } else if (t2.specifiers && t2.specifiers.length)
                  for (let a2 of t2.specifiers) {
                    let { exported: n2 } = a2, o2 = n2.type === "Identifier" ? n2.name : n2.value;
                    if (this.checkDuplicateExports(a2, o2), !s2 && a2.local) {
                      let { local: c2 } = a2;
                      c2.type !== "Identifier" ? this.raise(h3.ExportBindingIsString, { at: a2, localName: c2.value, exportName: o2 }) : (this.checkReservedWord(c2.name, c2.loc.start, true, false), this.scope.checkLocalExport(c2));
                    }
                  }
                else if (t2.declaration) {
                  if (t2.declaration.type === "FunctionDeclaration" || t2.declaration.type === "ClassDeclaration") {
                    let a2 = t2.declaration.id;
                    if (!a2)
                      throw new Error("Assertion failure");
                    this.checkDuplicateExports(t2, a2.name);
                  } else if (t2.declaration.type === "VariableDeclaration")
                    for (let a2 of t2.declaration.declarations)
                      this.checkDeclaration(a2.id);
                }
              }
            }
            checkDeclaration(t2) {
              if (t2.type === "Identifier")
                this.checkDuplicateExports(t2, t2.name);
              else if (t2.type === "ObjectPattern")
                for (let r2 of t2.properties)
                  this.checkDeclaration(r2);
              else if (t2.type === "ArrayPattern")
                for (let r2 of t2.elements)
                  r2 && this.checkDeclaration(r2);
              else
                t2.type === "ObjectProperty" ? this.checkDeclaration(t2.value) : t2.type === "RestElement" ? this.checkDeclaration(t2.argument) : t2.type === "AssignmentPattern" && this.checkDeclaration(t2.left);
            }
            checkDuplicateExports(t2, r2) {
              this.exportedIdentifiers.has(r2) && (r2 === "default" ? this.raise(h3.DuplicateDefaultExport, { at: t2 }) : this.raise(h3.DuplicateExport, { at: t2, exportName: r2 })), this.exportedIdentifiers.add(r2);
            }
            parseExportSpecifiers(t2) {
              let r2 = [], e2 = true;
              for (this.expect(5); !this.eat(8); ) {
                if (e2)
                  e2 = false;
                else if (this.expect(12), this.eat(8))
                  break;
                let s2 = this.isContextual(128), i2 = this.match(131), a2 = this.startNode();
                a2.local = this.parseModuleExportName(), r2.push(this.parseExportSpecifier(a2, i2, t2, s2));
              }
              return r2;
            }
            parseExportSpecifier(t2, r2, e2, s2) {
              return this.eatContextual(93) ? t2.exported = this.parseModuleExportName() : r2 ? t2.exported = Sl(t2.local) : t2.exported || (t2.exported = xe(t2.local)), this.finishNode(t2, "ExportSpecifier");
            }
            parseModuleExportName() {
              if (this.match(131)) {
                let t2 = this.parseStringLiteral(this.state.value), r2 = t2.value.match(eh);
                return r2 && this.raise(h3.ModuleExportNameHasLoneSurrogate, { at: t2, surrogateCharCode: r2[0].charCodeAt(0) }), t2;
              }
              return this.parseIdentifier(true);
            }
            isJSONModuleImport(t2) {
              return t2.assertions != null ? t2.assertions.some((r2) => {
                let { key: e2, value: s2 } = r2;
                return s2.value === "json" && (e2.type === "Identifier" ? e2.name === "type" : e2.value === "type");
              }) : false;
            }
            checkImportReflection(t2) {
              if (t2.module) {
                var r2;
                (t2.specifiers.length !== 1 || t2.specifiers[0].type !== "ImportDefaultSpecifier") && this.raise(h3.ImportReflectionNotBinding, { at: t2.specifiers[0].loc.start }), ((r2 = t2.assertions) == null ? void 0 : r2.length) > 0 && this.raise(h3.ImportReflectionHasAssertion, { at: t2.specifiers[0].loc.start });
              }
            }
            checkJSONModuleImport(t2) {
              if (this.isJSONModuleImport(t2) && t2.type !== "ExportAllDeclaration") {
                let { specifiers: r2 } = t2;
                if (r2 != null) {
                  let e2 = r2.find((s2) => {
                    let i2;
                    if (s2.type === "ExportSpecifier" ? i2 = s2.local : s2.type === "ImportSpecifier" && (i2 = s2.imported), i2 !== void 0)
                      return i2.type === "Identifier" ? i2.name !== "default" : i2.value !== "default";
                  });
                  e2 !== void 0 && this.raise(h3.ImportJSONBindingNotDefault, { at: e2.loc.start });
                }
              }
            }
            parseMaybeImportReflection(t2) {
              let r2 = false;
              if (this.isContextual(125)) {
                let e2 = this.lookahead();
                $(e2.type) ? (e2.type !== 97 || this.input.charCodeAt(this.nextTokenStartSince(e2.end)) === 102) && (r2 = true) : r2 = true;
              }
              r2 ? (this.expectPlugin("importReflection"), this.next(), t2.module = true) : this.hasPlugin("importReflection") && (t2.module = false);
            }
            parseImport(t2) {
              if (t2.specifiers = [], !this.match(131)) {
                this.parseMaybeImportReflection(t2);
                let s2 = !this.maybeParseDefaultImportSpecifier(t2) || this.eat(12), i2 = s2 && this.maybeParseStarImportSpecifier(t2);
                s2 && !i2 && this.parseNamedImportSpecifiers(t2), this.expectContextual(97);
              }
              t2.source = this.parseImportSource();
              let r2 = this.maybeParseImportAssertions();
              if (r2)
                t2.assertions = r2;
              else {
                let e2 = this.maybeParseModuleAttributes();
                e2 && (t2.attributes = e2);
              }
              return this.checkImportReflection(t2), this.checkJSONModuleImport(t2), this.semicolon(), this.finishNode(t2, "ImportDeclaration");
            }
            parseImportSource() {
              return this.match(131) || this.unexpected(), this.parseExprAtom();
            }
            shouldParseDefaultImport(t2) {
              return $(this.state.type);
            }
            parseImportSpecifierLocal(t2, r2, e2) {
              r2.local = this.parseIdentifier(), t2.specifiers.push(this.finishImportSpecifier(r2, e2));
            }
            finishImportSpecifier(t2, r2) {
              let e2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ie;
              return this.checkLVal(t2.local, { in: t2, binding: e2 }), this.finishNode(t2, r2);
            }
            parseAssertEntries() {
              let t2 = [], r2 = /* @__PURE__ */ new Set();
              do {
                if (this.match(8))
                  break;
                let e2 = this.startNode(), s2 = this.state.value;
                if (r2.has(s2) && this.raise(h3.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: s2 }), r2.add(s2), this.match(131) ? e2.key = this.parseStringLiteral(s2) : e2.key = this.parseIdentifier(true), this.expect(14), !this.match(131))
                  throw this.raise(h3.ModuleAttributeInvalidValue, { at: this.state.startLoc });
                e2.value = this.parseStringLiteral(this.state.value), t2.push(this.finishNode(e2, "ImportAttribute"));
              } while (this.eat(12));
              return t2;
            }
            maybeParseModuleAttributes() {
              if (this.match(76) && !this.hasPrecedingLineBreak())
                this.expectPlugin("moduleAttributes"), this.next();
              else
                return this.hasPlugin("moduleAttributes") ? [] : null;
              let t2 = [], r2 = /* @__PURE__ */ new Set();
              do {
                let e2 = this.startNode();
                if (e2.key = this.parseIdentifier(true), e2.key.name !== "type" && this.raise(h3.ModuleAttributeDifferentFromType, { at: e2.key }), r2.has(e2.key.name) && this.raise(h3.ModuleAttributesWithDuplicateKeys, { at: e2.key, key: e2.key.name }), r2.add(e2.key.name), this.expect(14), !this.match(131))
                  throw this.raise(h3.ModuleAttributeInvalidValue, { at: this.state.startLoc });
                e2.value = this.parseStringLiteral(this.state.value), this.finishNode(e2, "ImportAttribute"), t2.push(e2);
              } while (this.eat(12));
              return t2;
            }
            maybeParseImportAssertions() {
              if (this.isContextual(94) && !this.hasPrecedingLineBreak())
                this.expectPlugin("importAssertions"), this.next();
              else
                return this.hasPlugin("importAssertions") ? [] : null;
              this.eat(5);
              let t2 = this.parseAssertEntries();
              return this.eat(8), t2;
            }
            maybeParseDefaultImportSpecifier(t2) {
              return this.shouldParseDefaultImport(t2) ? (this.parseImportSpecifierLocal(t2, this.startNode(), "ImportDefaultSpecifier"), true) : false;
            }
            maybeParseStarImportSpecifier(t2) {
              if (this.match(55)) {
                let r2 = this.startNode();
                return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t2, r2, "ImportNamespaceSpecifier"), true;
              }
              return false;
            }
            parseNamedImportSpecifiers(t2) {
              let r2 = true;
              for (this.expect(5); !this.eat(8); ) {
                if (r2)
                  r2 = false;
                else {
                  if (this.eat(14))
                    throw this.raise(h3.DestructureNamedImport, { at: this.state.startLoc });
                  if (this.expect(12), this.eat(8))
                    break;
                }
                let e2 = this.startNode(), s2 = this.match(131), i2 = this.isContextual(128);
                e2.imported = this.parseModuleExportName();
                let a2 = this.parseImportSpecifier(e2, s2, t2.importKind === "type" || t2.importKind === "typeof", i2, void 0);
                t2.specifiers.push(a2);
              }
            }
            parseImportSpecifier(t2, r2, e2, s2, i2) {
              if (this.eatContextual(93))
                t2.local = this.parseIdentifier();
              else {
                let { imported: a2 } = t2;
                if (r2)
                  throw this.raise(h3.ImportBindingIsString, { at: t2, importName: a2.value });
                this.checkReservedWord(a2.name, t2.loc.start, true, true), t2.local || (t2.local = xe(a2));
              }
              return this.finishImportSpecifier(t2, "ImportSpecifier", i2);
            }
            isThisParam(t2) {
              return t2.type === "Identifier" && t2.name === "this";
            }
          }, "sh"), ei = /* @__PURE__ */ __name(class extends sh {
            constructor(t2, r2) {
              t2 = Gl(t2), super(t2, r2), this.options = t2, this.initializeScopes(), this.plugins = rh(this.options.plugins), this.filename = t2.sourceFilename;
            }
            getScopeHandler() {
              return os;
            }
            parse() {
              this.enterInitialScopes();
              let t2 = this.startNode(), r2 = this.startNode();
              return this.nextToken(), t2.errors = null, this.parseTopLevel(t2, r2), t2.errors = this.state.errors, t2;
            }
          }, "ei");
          function rh(t2) {
            let r2 = /* @__PURE__ */ new Map();
            for (let e2 of t2) {
              let [s2, i2] = Array.isArray(e2) ? e2 : [e2, {}];
              r2.has(s2) || r2.set(s2, i2 || {});
            }
            return r2;
          }
          __name(rh, "rh");
          function ih(t2, r2) {
            var e2;
            if (((e2 = r2) == null ? void 0 : e2.sourceType) === "unambiguous") {
              r2 = Object.assign({}, r2);
              try {
                r2.sourceType = "module";
                let s2 = et(r2, t2), i2 = s2.parse();
                if (s2.sawUnambiguousESM)
                  return i2;
                if (s2.ambiguousScriptDifferentAst)
                  try {
                    return r2.sourceType = "script", et(r2, t2).parse();
                  } catch {
                  }
                else
                  i2.program.sourceType = "script";
                return i2;
              } catch (s2) {
                try {
                  return r2.sourceType = "script", et(r2, t2).parse();
                } catch {
                }
                throw s2;
              }
            } else
              return et(r2, t2).parse();
          }
          __name(ih, "ih");
          function ah(t2, r2) {
            let e2 = et(r2, t2);
            return e2.options.strictMode && (e2.state.strict = true), e2.getExpression();
          }
          __name(ah, "ah");
          function nh(t2) {
            let r2 = {};
            for (let e2 of Object.keys(t2))
              r2[e2] = de(t2[e2]);
            return r2;
          }
          __name(nh, "nh");
          var oh = nh(bo);
          function et(t2, r2) {
            let e2 = ei;
            return t2 != null && t2.plugins && (Kl(t2.plugins), e2 = lh(t2.plugins)), new e2(t2, r2);
          }
          __name(et, "et");
          var ti = {};
          function lh(t2) {
            let r2 = Wl.filter((i2) => se(t2, i2)), e2 = r2.join("/"), s2 = ti[e2];
            if (!s2) {
              s2 = ei;
              for (let i2 of r2)
                s2 = Jr[i2](s2);
              ti[e2] = s2;
            }
            return s2;
          }
          __name(lh, "lh");
          l2.parse = ih, l2.parseExpression = ah, l2.tokTypes = oh;
        } }), Td = K({ "src/language-js/parse/json.js"(l2, u2) {
          "use strict";
          V();
          var d2 = lr(), f2 = hr(), y2 = xo(), A2 = go();
          function g2() {
            let E2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { allowComments: L2 = true } = E2;
            return function(k2) {
              let { parseExpression: z } = To(), G;
              try {
                G = z(k2, { tokens: true, ranges: true });
              } catch (B) {
                throw A2(B);
              }
              if (!L2 && d2(G.comments))
                throw T2(G.comments[0], "Comment");
              return S2(G), G;
            };
          }
          __name(g2, "g");
          function T2(E2, L2) {
            let [j2, k2] = [E2.loc.start, E2.loc.end].map((z) => {
              let { line: G, column: B } = z;
              return { line: G, column: B + 1 };
            });
            return f2(`${L2} is not allowed in JSON.`, { start: j2, end: k2 });
          }
          __name(T2, "T");
          function S2(E2) {
            switch (E2.type) {
              case "ArrayExpression":
                for (let L2 of E2.elements)
                  L2 !== null && S2(L2);
                return;
              case "ObjectExpression":
                for (let L2 of E2.properties)
                  S2(L2);
                return;
              case "ObjectProperty":
                if (E2.computed)
                  throw T2(E2.key, "Computed key");
                if (E2.shorthand)
                  throw T2(E2.key, "Shorthand property");
                E2.key.type !== "Identifier" && S2(E2.key), S2(E2.value);
                return;
              case "UnaryExpression": {
                let { operator: L2, argument: j2 } = E2;
                if (L2 !== "+" && L2 !== "-")
                  throw T2(E2, `Operator '${E2.operator}'`);
                if (j2.type === "NumericLiteral" || j2.type === "Identifier" && (j2.name === "Infinity" || j2.name === "NaN"))
                  return;
                throw T2(j2, `Operator '${L2}' before '${j2.type}'`);
              }
              case "Identifier":
                if (E2.name !== "Infinity" && E2.name !== "NaN" && E2.name !== "undefined")
                  throw T2(E2, `Identifier '${E2.name}'`);
                return;
              case "TemplateLiteral":
                if (d2(E2.expressions))
                  throw T2(E2.expressions[0], "'TemplateLiteral' with expression");
                for (let L2 of E2.quasis)
                  S2(L2);
                return;
              case "NullLiteral":
              case "BooleanLiteral":
              case "NumericLiteral":
              case "StringLiteral":
              case "TemplateElement":
                return;
              default:
                throw T2(E2, `'${E2.type}'`);
            }
          }
          __name(S2, "S");
          var F = g2(), I = { json: y2({ parse: F, hasPragma() {
            return true;
          } }), json5: y2(F), "json-stringify": y2({ parse: g2({ allowComments: false }), astFormat: "estree-json" }) };
          u2.exports = I;
        } });
        V();
        var vd = sd(), Ed = eo(), Cd = nd(), Ve = xo(), bd = go(), Sd = Ad(), wd = Td(), Id = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", ["decorators", { decoratorsBeforeExport: false }], "importAssertions", "decimal", "moduleBlocks", "asyncDoExpressions", "regexpUnicodeSets", "destructuringPrivate", "decoratorAutoAccessors"], tokens: true, ranges: true }, Nd = ["recordAndTuple", { syntaxType: "hash" }], Gn = "v8intrinsic", Jn = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], ue = /* @__PURE__ */ __name(function(l2) {
          let u2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Id;
          return Object.assign(Object.assign({}, u2), {}, { plugins: [...u2.plugins, ...l2] });
        }, "ue"), kd = /@(?:no)?flow\b/;
        function Dd(l2, u2) {
          if (u2.filepath && u2.filepath.endsWith(".js.flow"))
            return true;
          let d2 = Ed(l2);
          d2 && (l2 = l2.slice(d2.length));
          let f2 = Cd(l2, 0);
          return f2 !== false && (l2 = l2.slice(0, f2)), kd.test(l2);
        }
        __name(Dd, "Dd");
        function Fd(l2, u2, d2) {
          let y2 = To()[l2](u2, d2), A2 = y2.errors.find((g2) => !Rd.has(g2.reasonCode));
          if (A2)
            throw A2;
          return y2;
        }
        __name(Fd, "Fd");
        function Ke(l2) {
          for (var u2 = arguments.length, d2 = new Array(u2 > 1 ? u2 - 1 : 0), f2 = 1; f2 < u2; f2++)
            d2[f2 - 1] = arguments[f2];
          return function(y2, A2) {
            let g2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if ((g2.parser === "babel" || g2.parser === "__babel_estree") && Dd(y2, g2))
              return g2.parser = "babel-flow", vo(y2, A2, g2);
            let T2 = d2;
            g2.__babelSourceType === "script" && (T2 = T2.map((E2) => Object.assign(Object.assign({}, E2), {}, { sourceType: "script" }))), /#[[{]/.test(y2) && (T2 = T2.map((E2) => ue([Nd], E2)));
            let S2 = /%[A-Z]/.test(y2);
            y2.includes("|>") ? T2 = (S2 ? [...Jn, Gn] : Jn).flatMap((L2) => T2.map((j2) => ue([L2], j2))) : S2 && (T2 = T2.map((E2) => ue([Gn], E2)));
            let { result: F, error: I } = vd(...T2.map((E2) => () => Fd(l2, y2, E2)));
            if (!F)
              throw bd(I);
            return g2.originalText = y2, Sd(F, g2);
          };
        }
        __name(Ke, "Ke");
        var Ld = Ke("parse", ue(["jsx", "flow"])), vo = Ke("parse", ue(["jsx", ["flow", { all: true, enums: true }]])), Od = Ke("parse", ue(["jsx", "typescript"]), ue(["typescript"])), Md = Ke("parse", ue(["jsx", "flow", "estree"])), Bd = Ke("parseExpression", ue(["jsx"])), _d = Ke("parseExpression", ue(["typescript"])), Rd = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "UnexpectedParameterModifier", "MixedLabeledAndUnlabeledElements", "InvalidTupleMemberLabel", "NonClassMethodPropertyHasAbstractModifer", "ReadonlyForMethodSignature", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "InvalidModifierOnTypeMember", "DuplicateAccessibilityModifier", "IndexSignatureHasDeclare", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "UnsupportedPropertyDecorator", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), Xn = Ve(Ld), Yn = Ve(Od), Qn = Ve(Bd), jd = Ve(_d);
        Eo.exports = { parsers: Object.assign(Object.assign({ babel: Xn, "babel-flow": Ve(vo), "babel-ts": Yn }, wd), {}, { __js_expression: Qn, __vue_expression: Qn, __vue_ts_expression: jd, __vue_event_binding: Xn, __vue_ts_event_binding: Yn, __babel_estree: Ve(Md) }) };
      });
      return qd();
    });
  }
});

// ../../.yarn/global/cache/prettier-npm-2.8.0-746e3df53e-9.zip/node_modules/prettier/standalone.js
var require_standalone = __commonJS({
  "../../.yarn/global/cache/prettier-npm-2.8.0-746e3df53e-9.zip/node_modules/prettier/standalone.js"(exports, module) {
    init_define_process();
    (function(e2) {
      if (typeof exports == "object" && typeof module == "object")
        module.exports = e2();
      else if (typeof define == "function" && define.amd)
        define(e2);
      else {
        var f2 = typeof globalThis < "u" ? globalThis : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : this || {};
        f2.prettier = e2();
      }
    })(function() {
      "use strict";
      var Ne = /* @__PURE__ */ __name((e2, n2) => () => (n2 || e2((n2 = { exports: {} }).exports, n2), n2.exports), "Ne");
      var Qe = Ne((Ng, nu) => {
        var ur = /* @__PURE__ */ __name(function(e2) {
          return e2 && e2.Math == Math && e2;
        }, "ur");
        nu.exports = ur(typeof globalThis == "object" && globalThis) || ur(typeof window == "object" && window) || ur(typeof self == "object" && self) || ur(typeof globalThis == "object" && globalThis) || function() {
          return this;
        }() || Function("return this")();
      });
      var dt = Ne((wg, uu) => {
        uu.exports = function(e2) {
          try {
            return !!e2();
          } catch {
            return true;
          }
        };
      });
      var Ft = Ne((_g, su) => {
        var vo = dt();
        su.exports = !vo(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var sr = Ne((Pg, iu) => {
        var Co = dt();
        iu.exports = !Co(function() {
          var e2 = function() {
          }.bind();
          return typeof e2 != "function" || e2.hasOwnProperty("prototype");
        });
      });
      var At = Ne((Ig, au) => {
        var Eo = sr(), ir = Function.prototype.call;
        au.exports = Eo ? ir.bind(ir) : function() {
          return ir.apply(ir, arguments);
        };
      });
      var pu = Ne((cu) => {
        "use strict";
        var ou = {}.propertyIsEnumerable, lu = Object.getOwnPropertyDescriptor, Fo = lu && !ou.call({ 1: 2 }, 1);
        cu.f = Fo ? function(n2) {
          var t2 = lu(this, n2);
          return !!t2 && t2.enumerable;
        } : ou;
      });
      var ar = Ne((Lg, fu) => {
        fu.exports = function(e2, n2) {
          return { enumerable: !(e2 & 1), configurable: !(e2 & 2), writable: !(e2 & 4), value: n2 };
        };
      });
      var ct = Ne((jg, du) => {
        var Du = sr(), mu = Function.prototype, Ao = mu.bind, Mr = mu.call, So = Du && Ao.bind(Mr, Mr);
        du.exports = Du ? function(e2) {
          return e2 && So(e2);
        } : function(e2) {
          return e2 && function() {
            return Mr.apply(e2, arguments);
          };
        };
      });
      var or = Ne((Og, yu) => {
        var gu = ct(), xo = gu({}.toString), bo = gu("".slice);
        yu.exports = function(e2) {
          return bo(xo(e2), 8, -1);
        };
      });
      var vu = Ne((qg, hu) => {
        var To = Qe(), Bo = ct(), No = dt(), wo = or(), Rr = To.Object, _o = Bo("".split);
        hu.exports = No(function() {
          return !Rr("z").propertyIsEnumerable(0);
        }) ? function(e2) {
          return wo(e2) == "String" ? _o(e2, "") : Rr(e2);
        } : Rr;
      });
      var $r = Ne((Mg, Cu) => {
        var Po = Qe(), Io = Po.TypeError;
        Cu.exports = function(e2) {
          if (e2 == null)
            throw Io("Can't call method on " + e2);
          return e2;
        };
      });
      var lr = Ne((Rg, Eu) => {
        var ko = vu(), Lo = $r();
        Eu.exports = function(e2) {
          return ko(Lo(e2));
        };
      });
      var pt = Ne(($g, Fu) => {
        Fu.exports = function(e2) {
          return typeof e2 == "function";
        };
      });
      var St = Ne((Vg, Au) => {
        var jo = pt();
        Au.exports = function(e2) {
          return typeof e2 == "object" ? e2 !== null : jo(e2);
        };
      });
      var $t = Ne((Wg, Su) => {
        var Vr = Qe(), Oo = pt(), qo = /* @__PURE__ */ __name(function(e2) {
          return Oo(e2) ? e2 : void 0;
        }, "qo");
        Su.exports = function(e2, n2) {
          return arguments.length < 2 ? qo(Vr[e2]) : Vr[e2] && Vr[e2][n2];
        };
      });
      var Wr = Ne((Hg, xu) => {
        var Mo = ct();
        xu.exports = Mo({}.isPrototypeOf);
      });
      var Tu = Ne((Gg, bu) => {
        var Ro = $t();
        bu.exports = Ro("navigator", "userAgent") || "";
      });
      var ku = Ne((Ug, Iu) => {
        var Pu = Qe(), Hr = Tu(), Bu = Pu.process, Nu = Pu.Deno, wu = Bu && Bu.versions || Nu && Nu.version, _u = wu && wu.v8, mt, cr;
        _u && (mt = _u.split("."), cr = mt[0] > 0 && mt[0] < 4 ? 1 : +(mt[0] + mt[1]));
        !cr && Hr && (mt = Hr.match(/Edge\/(\d+)/), (!mt || mt[1] >= 74) && (mt = Hr.match(/Chrome\/(\d+)/), mt && (cr = +mt[1])));
        Iu.exports = cr;
      });
      var Gr = Ne((Jg, ju) => {
        var Lu = ku(), $o = dt();
        ju.exports = !!Object.getOwnPropertySymbols && !$o(function() {
          var e2 = Symbol();
          return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && Lu && Lu < 41;
        });
      });
      var Ur = Ne((zg, Ou) => {
        var Vo = Gr();
        Ou.exports = Vo && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Jr = Ne((Xg, qu) => {
        var Wo = Qe(), Ho = $t(), Go = pt(), Uo = Wr(), Jo = Ur(), zo = Wo.Object;
        qu.exports = Jo ? function(e2) {
          return typeof e2 == "symbol";
        } : function(e2) {
          var n2 = Ho("Symbol");
          return Go(n2) && Uo(n2.prototype, zo(e2));
        };
      });
      var pr = Ne((Kg, Mu) => {
        var Xo = Qe(), Ko = Xo.String;
        Mu.exports = function(e2) {
          try {
            return Ko(e2);
          } catch {
            return "Object";
          }
        };
      });
      var Vt = Ne((Yg, Ru) => {
        var Yo = Qe(), Qo = pt(), Zo = pr(), el = Yo.TypeError;
        Ru.exports = function(e2) {
          if (Qo(e2))
            return e2;
          throw el(Zo(e2) + " is not a function");
        };
      });
      var fr = Ne((Qg, $u) => {
        var tl = Vt();
        $u.exports = function(e2, n2) {
          var t2 = e2[n2];
          return t2 == null ? void 0 : tl(t2);
        };
      });
      var Wu = Ne((Zg, Vu) => {
        var rl = Qe(), zr = At(), Xr = pt(), Kr = St(), nl = rl.TypeError;
        Vu.exports = function(e2, n2) {
          var t2, s2;
          if (n2 === "string" && Xr(t2 = e2.toString) && !Kr(s2 = zr(t2, e2)) || Xr(t2 = e2.valueOf) && !Kr(s2 = zr(t2, e2)) || n2 !== "string" && Xr(t2 = e2.toString) && !Kr(s2 = zr(t2, e2)))
            return s2;
          throw nl("Can't convert object to primitive value");
        };
      });
      var Gu = Ne((e0, Hu) => {
        Hu.exports = false;
      });
      var Dr = Ne((t0, Ju) => {
        var Uu = Qe(), ul = Object.defineProperty;
        Ju.exports = function(e2, n2) {
          try {
            ul(Uu, e2, { value: n2, configurable: true, writable: true });
          } catch {
            Uu[e2] = n2;
          }
          return n2;
        };
      });
      var mr = Ne((r0, Xu) => {
        var sl = Qe(), il = Dr(), zu = "__core-js_shared__", al = sl[zu] || il(zu, {});
        Xu.exports = al;
      });
      var Yr = Ne((n0, Yu) => {
        var ol = Gu(), Ku = mr();
        (Yu.exports = function(e2, n2) {
          return Ku[e2] || (Ku[e2] = n2 !== void 0 ? n2 : {});
        })("versions", []).push({ version: "3.22.2", mode: ol ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var dr = Ne((u0, Qu) => {
        var ll = Qe(), cl = $r(), pl = ll.Object;
        Qu.exports = function(e2) {
          return pl(cl(e2));
        };
      });
      var ht = Ne((s0, Zu) => {
        var fl = ct(), Dl = dr(), ml = fl({}.hasOwnProperty);
        Zu.exports = Object.hasOwn || function(n2, t2) {
          return ml(Dl(n2), t2);
        };
      });
      var Qr = Ne((i0, es) => {
        var dl = ct(), gl = 0, yl = Math.random(), hl = dl(1 .toString);
        es.exports = function(e2) {
          return "Symbol(" + (e2 === void 0 ? "" : e2) + ")_" + hl(++gl + yl, 36);
        };
      });
      var bt = Ne((a0, ss) => {
        var vl = Qe(), Cl = Yr(), ts = ht(), El = Qr(), rs = Gr(), us = Ur(), _t = Cl("wks"), xt = vl.Symbol, ns = xt && xt.for, Fl = us ? xt : xt && xt.withoutSetter || El;
        ss.exports = function(e2) {
          if (!ts(_t, e2) || !(rs || typeof _t[e2] == "string")) {
            var n2 = "Symbol." + e2;
            rs && ts(xt, e2) ? _t[e2] = xt[e2] : us && ns ? _t[e2] = ns(n2) : _t[e2] = Fl(n2);
          }
          return _t[e2];
        };
      });
      var ls = Ne((o0, os) => {
        var Al = Qe(), Sl = At(), is = St(), as = Jr(), xl = fr(), bl = Wu(), Tl = bt(), Bl = Al.TypeError, Nl = Tl("toPrimitive");
        os.exports = function(e2, n2) {
          if (!is(e2) || as(e2))
            return e2;
          var t2 = xl(e2, Nl), s2;
          if (t2) {
            if (n2 === void 0 && (n2 = "default"), s2 = Sl(t2, e2, n2), !is(s2) || as(s2))
              return s2;
            throw Bl("Can't convert object to primitive value");
          }
          return n2 === void 0 && (n2 = "number"), bl(e2, n2);
        };
      });
      var gr = Ne((l0, cs) => {
        var wl = ls(), _l = Jr();
        cs.exports = function(e2) {
          var n2 = wl(e2, "string");
          return _l(n2) ? n2 : n2 + "";
        };
      });
      var Ds = Ne((c0, fs) => {
        var Pl = Qe(), ps = St(), Zr = Pl.document, Il = ps(Zr) && ps(Zr.createElement);
        fs.exports = function(e2) {
          return Il ? Zr.createElement(e2) : {};
        };
      });
      var en = Ne((p0, ms) => {
        var kl = Ft(), Ll = dt(), jl = Ds();
        ms.exports = !kl && !Ll(function() {
          return Object.defineProperty(jl("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var tn = Ne((gs) => {
        var Ol = Ft(), ql = At(), Ml = pu(), Rl = ar(), $l = lr(), Vl = gr(), Wl = ht(), Hl = en(), ds = Object.getOwnPropertyDescriptor;
        gs.f = Ol ? ds : function(n2, t2) {
          if (n2 = $l(n2), t2 = Vl(t2), Hl)
            try {
              return ds(n2, t2);
            } catch {
            }
          if (Wl(n2, t2))
            return Rl(!ql(Ml.f, n2, t2), n2[t2]);
        };
      });
      var hs = Ne((D0, ys) => {
        var Gl = Ft(), Ul = dt();
        ys.exports = Gl && Ul(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Pt = Ne((m0, Cs) => {
        var vs = Qe(), Jl = St(), zl = vs.String, Xl = vs.TypeError;
        Cs.exports = function(e2) {
          if (Jl(e2))
            return e2;
          throw Xl(zl(e2) + " is not an object");
        };
      });
      var hr = Ne((Fs) => {
        var Kl = Qe(), Yl = Ft(), Ql = en(), Zl = hs(), yr = Pt(), Es = gr(), ec = Kl.TypeError, rn = Object.defineProperty, tc = Object.getOwnPropertyDescriptor, nn = "enumerable", un = "configurable", sn = "writable";
        Fs.f = Yl ? Zl ? function(n2, t2, s2) {
          if (yr(n2), t2 = Es(t2), yr(s2), typeof n2 == "function" && t2 === "prototype" && "value" in s2 && sn in s2 && !s2[sn]) {
            var a2 = tc(n2, t2);
            a2 && a2[sn] && (n2[t2] = s2.value, s2 = { configurable: un in s2 ? s2[un] : a2[un], enumerable: nn in s2 ? s2[nn] : a2[nn], writable: false });
          }
          return rn(n2, t2, s2);
        } : rn : function(n2, t2, s2) {
          if (yr(n2), t2 = Es(t2), yr(s2), Ql)
            try {
              return rn(n2, t2, s2);
            } catch {
            }
          if ("get" in s2 || "set" in s2)
            throw ec("Accessors not supported");
          return "value" in s2 && (n2[t2] = s2.value), n2;
        };
      });
      var vr = Ne((g0, As) => {
        var rc = Ft(), nc = hr(), uc = ar();
        As.exports = rc ? function(e2, n2, t2) {
          return nc.f(e2, n2, uc(1, t2));
        } : function(e2, n2, t2) {
          return e2[n2] = t2, e2;
        };
      });
      var Cr = Ne((y0, Ss) => {
        var sc = ct(), ic = pt(), an = mr(), ac = sc(Function.toString);
        ic(an.inspectSource) || (an.inspectSource = function(e2) {
          return ac(e2);
        });
        Ss.exports = an.inspectSource;
      });
      var Ts = Ne((h0, bs) => {
        var oc = Qe(), lc = pt(), cc = Cr(), xs = oc.WeakMap;
        bs.exports = lc(xs) && /native code/.test(cc(xs));
      });
      var ws2 = Ne((v0, Ns) => {
        var pc = Yr(), fc = Qr(), Bs = pc("keys");
        Ns.exports = function(e2) {
          return Bs[e2] || (Bs[e2] = fc(e2));
        };
      });
      var on = Ne((C0, _s) => {
        _s.exports = {};
      });
      var Os = Ne((E0, js) => {
        var Dc = Ts(), Ls = Qe(), ln = ct(), mc = St(), dc = vr(), cn = ht(), pn = mr(), gc = ws2(), yc = on(), Ps = "Object already initialized", Dn = Ls.TypeError, hc = Ls.WeakMap, Er, Wt, Fr, vc = /* @__PURE__ */ __name(function(e2) {
          return Fr(e2) ? Wt(e2) : Er(e2, {});
        }, "vc"), Cc = /* @__PURE__ */ __name(function(e2) {
          return function(n2) {
            var t2;
            if (!mc(n2) || (t2 = Wt(n2)).type !== e2)
              throw Dn("Incompatible receiver, " + e2 + " required");
            return t2;
          };
        }, "Cc");
        Dc || pn.state ? (vt = pn.state || (pn.state = new hc()), Is = ln(vt.get), fn = ln(vt.has), ks = ln(vt.set), Er = /* @__PURE__ */ __name(function(e2, n2) {
          if (fn(vt, e2))
            throw new Dn(Ps);
          return n2.facade = e2, ks(vt, e2, n2), n2;
        }, "Er"), Wt = /* @__PURE__ */ __name(function(e2) {
          return Is(vt, e2) || {};
        }, "Wt"), Fr = /* @__PURE__ */ __name(function(e2) {
          return fn(vt, e2);
        }, "Fr")) : (Tt = gc("state"), yc[Tt] = true, Er = /* @__PURE__ */ __name(function(e2, n2) {
          if (cn(e2, Tt))
            throw new Dn(Ps);
          return n2.facade = e2, dc(e2, Tt, n2), n2;
        }, "Er"), Wt = /* @__PURE__ */ __name(function(e2) {
          return cn(e2, Tt) ? e2[Tt] : {};
        }, "Wt"), Fr = /* @__PURE__ */ __name(function(e2) {
          return cn(e2, Tt);
        }, "Fr"));
        var vt, Is, fn, ks, Tt;
        js.exports = { set: Er, get: Wt, has: Fr, enforce: vc, getterFor: Cc };
      });
      var Rs = Ne((F0, Ms) => {
        var mn = Ft(), Ec = ht(), qs = Function.prototype, Fc = mn && Object.getOwnPropertyDescriptor, dn = Ec(qs, "name"), Ac = dn && function() {
        }.name === "something", Sc = dn && (!mn || mn && Fc(qs, "name").configurable);
        Ms.exports = { EXISTS: dn, PROPER: Ac, CONFIGURABLE: Sc };
      });
      var Gs = Ne((A0, Hs) => {
        var xc = Qe(), $s = pt(), bc2 = ht(), Vs = vr(), Tc = Dr(), Bc = Cr(), Ws = Os(), Nc = Rs().CONFIGURABLE, wc = Ws.get, _c = Ws.enforce, Pc = String(String).split("String");
        (Hs.exports = function(e2, n2, t2, s2) {
          var a2 = s2 ? !!s2.unsafe : false, r2 = s2 ? !!s2.enumerable : false, u2 = s2 ? !!s2.noTargetGet : false, i2 = s2 && s2.name !== void 0 ? s2.name : n2, l2;
          if ($s(t2) && (String(i2).slice(0, 7) === "Symbol(" && (i2 = "[" + String(i2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!bc2(t2, "name") || Nc && t2.name !== i2) && Vs(t2, "name", i2), l2 = _c(t2), l2.source || (l2.source = Pc.join(typeof i2 == "string" ? i2 : ""))), e2 === xc) {
            r2 ? e2[n2] = t2 : Tc(n2, t2);
            return;
          } else
            a2 ? !u2 && e2[n2] && (r2 = true) : delete e2[n2];
          r2 ? e2[n2] = t2 : Vs(e2, n2, t2);
        })(Function.prototype, "toString", function() {
          return $s(this) && wc(this).source || Bc(this);
        });
      });
      var Ar = Ne((S0, Us) => {
        var Ic = Math.ceil, kc = Math.floor;
        Us.exports = function(e2) {
          var n2 = +e2;
          return n2 !== n2 || n2 === 0 ? 0 : (n2 > 0 ? kc : Ic)(n2);
        };
      });
      var zs = Ne((x0, Js) => {
        var Lc = Ar(), jc = Math.max, Oc = Math.min;
        Js.exports = function(e2, n2) {
          var t2 = Lc(e2);
          return t2 < 0 ? jc(t2 + n2, 0) : Oc(t2, n2);
        };
      });
      var Ks = Ne((b0, Xs) => {
        var qc = Ar(), Mc = Math.min;
        Xs.exports = function(e2) {
          return e2 > 0 ? Mc(qc(e2), 9007199254740991) : 0;
        };
      });
      var It = Ne((T0, Ys) => {
        var Rc = Ks();
        Ys.exports = function(e2) {
          return Rc(e2.length);
        };
      });
      var ei = Ne((B0, Zs) => {
        var $c = lr(), Vc = zs(), Wc = It(), Qs = /* @__PURE__ */ __name(function(e2) {
          return function(n2, t2, s2) {
            var a2 = $c(n2), r2 = Wc(a2), u2 = Vc(s2, r2), i2;
            if (e2 && t2 != t2) {
              for (; r2 > u2; )
                if (i2 = a2[u2++], i2 != i2)
                  return true;
            } else
              for (; r2 > u2; u2++)
                if ((e2 || u2 in a2) && a2[u2] === t2)
                  return e2 || u2 || 0;
            return !e2 && -1;
          };
        }, "Qs");
        Zs.exports = { includes: Qs(true), indexOf: Qs(false) };
      });
      var ni = Ne((N0, ri) => {
        var Hc = ct(), gn = ht(), Gc = lr(), Uc = ei().indexOf, Jc = on(), ti = Hc([].push);
        ri.exports = function(e2, n2) {
          var t2 = Gc(e2), s2 = 0, a2 = [], r2;
          for (r2 in t2)
            !gn(Jc, r2) && gn(t2, r2) && ti(a2, r2);
          for (; n2.length > s2; )
            gn(t2, r2 = n2[s2++]) && (~Uc(a2, r2) || ti(a2, r2));
          return a2;
        };
      });
      var si = Ne((w0, ui) => {
        ui.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var ai = Ne((ii) => {
        var zc = ni(), Xc = si(), Kc = Xc.concat("length", "prototype");
        ii.f = Object.getOwnPropertyNames || function(n2) {
          return zc(n2, Kc);
        };
      });
      var li = Ne((oi) => {
        oi.f = Object.getOwnPropertySymbols;
      });
      var pi = Ne((I0, ci) => {
        var Yc = $t(), Qc = ct(), Zc = ai(), ep = li(), tp = Pt(), rp = Qc([].concat);
        ci.exports = Yc("Reflect", "ownKeys") || function(n2) {
          var t2 = Zc.f(tp(n2)), s2 = ep.f;
          return s2 ? rp(t2, s2(n2)) : t2;
        };
      });
      var mi = Ne((k0, Di) => {
        var fi = ht(), np = pi(), up = tn(), sp = hr();
        Di.exports = function(e2, n2, t2) {
          for (var s2 = np(n2), a2 = sp.f, r2 = up.f, u2 = 0; u2 < s2.length; u2++) {
            var i2 = s2[u2];
            !fi(e2, i2) && !(t2 && fi(t2, i2)) && a2(e2, i2, r2(n2, i2));
          }
        };
      });
      var gi = Ne((L0, di) => {
        var ip = dt(), ap = pt(), op = /#|\.prototype\./, Ht = /* @__PURE__ */ __name(function(e2, n2) {
          var t2 = cp[lp(e2)];
          return t2 == fp ? true : t2 == pp ? false : ap(n2) ? ip(n2) : !!n2;
        }, "Ht"), lp = Ht.normalize = function(e2) {
          return String(e2).replace(op, ".").toLowerCase();
        }, cp = Ht.data = {}, pp = Ht.NATIVE = "N", fp = Ht.POLYFILL = "P";
        di.exports = Ht;
      });
      var Gt = Ne((j0, yi) => {
        var yn = Qe(), Dp = tn().f, mp = vr(), dp = Gs(), gp = Dr(), yp = mi(), hp = gi();
        yi.exports = function(e2, n2) {
          var t2 = e2.target, s2 = e2.global, a2 = e2.stat, r2, u2, i2, l2, c2, y2;
          if (s2 ? u2 = yn : a2 ? u2 = yn[t2] || gp(t2, {}) : u2 = (yn[t2] || {}).prototype, u2)
            for (i2 in n2) {
              if (c2 = n2[i2], e2.noTargetGet ? (y2 = Dp(u2, i2), l2 = y2 && y2.value) : l2 = u2[i2], r2 = hp(s2 ? i2 : t2 + (a2 ? "." : "#") + i2, e2.forced), !r2 && l2 !== void 0) {
                if (typeof c2 == typeof l2)
                  continue;
                yp(c2, l2);
              }
              (e2.sham || l2 && l2.sham) && mp(c2, "sham", true), dp(u2, i2, c2, e2);
            }
        };
      });
      var hn = Ne((O0, hi) => {
        var vp = or();
        hi.exports = Array.isArray || function(n2) {
          return vp(n2) == "Array";
        };
      });
      var vn = Ne((q0, Ci) => {
        var vi = ct(), Cp = Vt(), Ep = sr(), Fp = vi(vi.bind);
        Ci.exports = function(e2, n2) {
          return Cp(e2), n2 === void 0 ? e2 : Ep ? Fp(e2, n2) : function() {
            return e2.apply(n2, arguments);
          };
        };
      });
      var Cn = Ne((M0, Fi) => {
        "use strict";
        var Ap = Qe(), Sp = hn(), xp = It(), bp = vn(), Tp = Ap.TypeError, Ei = /* @__PURE__ */ __name(function(e2, n2, t2, s2, a2, r2, u2, i2) {
          for (var l2 = a2, c2 = 0, y2 = u2 ? bp(u2, i2) : false, h3, g2; c2 < s2; ) {
            if (c2 in t2) {
              if (h3 = y2 ? y2(t2[c2], c2, n2) : t2[c2], r2 > 0 && Sp(h3))
                g2 = xp(h3), l2 = Ei(e2, n2, h3, g2, l2, r2 - 1) - 1;
              else {
                if (l2 >= 9007199254740991)
                  throw Tp("Exceed the acceptable array length");
                e2[l2] = h3;
              }
              l2++;
            }
            c2++;
          }
          return l2;
        }, "Ei");
        Fi.exports = Ei;
      });
      var xi = Ne((R0, Si) => {
        var Bp = bt(), Np = Bp("toStringTag"), Ai = {};
        Ai[Np] = "z";
        Si.exports = String(Ai) === "[object z]";
      });
      var En = Ne(($0, bi) => {
        var wp = Qe(), _p = xi(), Pp = pt(), Sr = or(), Ip = bt(), kp = Ip("toStringTag"), Lp = wp.Object, jp = Sr(function() {
          return arguments;
        }()) == "Arguments", Op = /* @__PURE__ */ __name(function(e2, n2) {
          try {
            return e2[n2];
          } catch {
          }
        }, "Op");
        bi.exports = _p ? Sr : function(e2) {
          var n2, t2, s2;
          return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (t2 = Op(n2 = Lp(e2), kp)) == "string" ? t2 : jp ? Sr(n2) : (s2 = Sr(n2)) == "Object" && Pp(n2.callee) ? "Arguments" : s2;
        };
      });
      var Pi = Ne((V0, _i) => {
        var qp = ct(), Mp = dt(), Ti = pt(), Rp = En(), $p = $t(), Vp = Cr(), Bi = /* @__PURE__ */ __name(function() {
        }, "Bi"), Wp = [], Ni = $p("Reflect", "construct"), Fn = /^\s*(?:class|function)\b/, Hp = qp(Fn.exec), Gp = !Fn.exec(Bi), Ut = /* @__PURE__ */ __name(function(n2) {
          if (!Ti(n2))
            return false;
          try {
            return Ni(Bi, Wp, n2), true;
          } catch {
            return false;
          }
        }, "Ut"), wi = /* @__PURE__ */ __name(function(n2) {
          if (!Ti(n2))
            return false;
          switch (Rp(n2)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Gp || !!Hp(Fn, Vp(n2));
          } catch {
            return true;
          }
        }, "wi");
        wi.sham = true;
        _i.exports = !Ni || Mp(function() {
          var e2;
          return Ut(Ut.call) || !Ut(Object) || !Ut(function() {
            e2 = true;
          }) || e2;
        }) ? wi : Ut;
      });
      var ji = Ne((W0, Li) => {
        var Up = Qe(), Ii = hn(), Jp = Pi(), zp = St(), Xp = bt(), Kp = Xp("species"), ki = Up.Array;
        Li.exports = function(e2) {
          var n2;
          return Ii(e2) && (n2 = e2.constructor, Jp(n2) && (n2 === ki || Ii(n2.prototype)) ? n2 = void 0 : zp(n2) && (n2 = n2[Kp], n2 === null && (n2 = void 0))), n2 === void 0 ? ki : n2;
        };
      });
      var An = Ne((H0, Oi) => {
        var Yp = ji();
        Oi.exports = function(e2, n2) {
          return new (Yp(e2))(n2 === 0 ? 0 : n2);
        };
      });
      var qi = Ne(() => {
        "use strict";
        var Qp = Gt(), Zp = Cn(), ef = Vt(), tf = dr(), rf = It(), nf = An();
        Qp({ target: "Array", proto: true }, { flatMap: function(n2) {
          var t2 = tf(this), s2 = rf(t2), a2;
          return ef(n2), a2 = nf(t2, 0), a2.length = Zp(a2, t2, t2, s2, 0, 1, n2, arguments.length > 1 ? arguments[1] : void 0), a2;
        } });
      });
      var Sn = Ne((J0, Mi) => {
        Mi.exports = {};
      });
      var $i = Ne((z0, Ri) => {
        var uf = bt(), sf = Sn(), af = uf("iterator"), of = Array.prototype;
        Ri.exports = function(e2) {
          return e2 !== void 0 && (sf.Array === e2 || of[af] === e2);
        };
      });
      var xn = Ne((X0, Wi) => {
        var lf = En(), Vi = fr(), cf = Sn(), pf = bt(), ff = pf("iterator");
        Wi.exports = function(e2) {
          if (e2 != null)
            return Vi(e2, ff) || Vi(e2, "@@iterator") || cf[lf(e2)];
        };
      });
      var Gi = Ne((K0, Hi) => {
        var Df = Qe(), mf = At(), df = Vt(), gf = Pt(), yf = pr(), hf = xn(), vf = Df.TypeError;
        Hi.exports = function(e2, n2) {
          var t2 = arguments.length < 2 ? hf(e2) : n2;
          if (df(t2))
            return gf(mf(t2, e2));
          throw vf(yf(e2) + " is not iterable");
        };
      });
      var zi = Ne((Y0, Ji) => {
        var Cf = At(), Ui = Pt(), Ef = fr();
        Ji.exports = function(e2, n2, t2) {
          var s2, a2;
          Ui(e2);
          try {
            if (s2 = Ef(e2, "return"), !s2) {
              if (n2 === "throw")
                throw t2;
              return t2;
            }
            s2 = Cf(s2, e2);
          } catch (r2) {
            a2 = true, s2 = r2;
          }
          if (n2 === "throw")
            throw t2;
          if (a2)
            throw s2;
          return Ui(s2), t2;
        };
      });
      var Zi = Ne((Q0, Qi) => {
        var Ff = Qe(), Af = vn(), Sf = At(), xf = Pt(), bf = pr(), Tf = $i(), Bf = It(), Xi = Wr(), Nf = Gi(), wf = xn(), Ki = zi(), _f = Ff.TypeError, xr = /* @__PURE__ */ __name(function(e2, n2) {
          this.stopped = e2, this.result = n2;
        }, "xr"), Yi = xr.prototype;
        Qi.exports = function(e2, n2, t2) {
          var s2 = t2 && t2.that, a2 = !!(t2 && t2.AS_ENTRIES), r2 = !!(t2 && t2.IS_ITERATOR), u2 = !!(t2 && t2.INTERRUPTED), i2 = Af(n2, s2), l2, c2, y2, h3, g2, p2, D, v2 = /* @__PURE__ */ __name(function(T2) {
            return l2 && Ki(l2, "normal", T2), new xr(true, T2);
          }, "v"), w2 = /* @__PURE__ */ __name(function(T2) {
            return a2 ? (xf(T2), u2 ? i2(T2[0], T2[1], v2) : i2(T2[0], T2[1])) : u2 ? i2(T2, v2) : i2(T2);
          }, "w");
          if (r2)
            l2 = e2;
          else {
            if (c2 = wf(e2), !c2)
              throw _f(bf(e2) + " is not iterable");
            if (Tf(c2)) {
              for (y2 = 0, h3 = Bf(e2); h3 > y2; y2++)
                if (g2 = w2(e2[y2]), g2 && Xi(Yi, g2))
                  return g2;
              return new xr(false);
            }
            l2 = Nf(e2, c2);
          }
          for (p2 = l2.next; !(D = Sf(p2, l2)).done; ) {
            try {
              g2 = w2(D.value);
            } catch (T2) {
              Ki(l2, "throw", T2);
            }
            if (typeof g2 == "object" && g2 && Xi(Yi, g2))
              return g2;
          }
          return new xr(false);
        };
      });
      var ta = Ne((Z0, ea) => {
        "use strict";
        var Pf = gr(), If = hr(), kf = ar();
        ea.exports = function(e2, n2, t2) {
          var s2 = Pf(n2);
          s2 in e2 ? If.f(e2, s2, kf(0, t2)) : e2[s2] = t2;
        };
      });
      var ra = Ne(() => {
        var Lf = Gt(), jf = Zi(), Of = ta();
        Lf({ target: "Object", stat: true }, { fromEntries: function(n2) {
          var t2 = {};
          return jf(n2, function(s2, a2) {
            Of(t2, s2, a2);
          }, { AS_ENTRIES: true }), t2;
        } });
      });
      var na = Ne(() => {
        var qf = Gt(), Mf = Qe();
        qf({ global: true }, { globalThis: Mf });
      });
      var ua = Ne(() => {
        na();
      });
      var sa = Ne(() => {
        "use strict";
        var Rf = Gt(), $f = Cn(), Vf = dr(), Wf = It(), Hf = Ar(), Gf = An();
        Rf({ target: "Array", proto: true }, { flat: function() {
          var n2 = arguments.length ? arguments[0] : void 0, t2 = Vf(this), s2 = Wf(t2), a2 = Gf(t2, 0);
          return a2.length = $f(a2, t2, t2, s2, 0, n2 === void 0 ? 1 : Hf(n2)), a2;
        } });
      });
      var Tg = Ne((ly, mo) => {
        var Uf = ["cliName", "cliCategory", "cliDescription"], Jf = ["_"], zf = ["languageId"];
        function Ln(e2, n2) {
          if (e2 == null)
            return {};
          var t2 = Xf(e2, n2), s2, a2;
          if (Object.getOwnPropertySymbols) {
            var r2 = Object.getOwnPropertySymbols(e2);
            for (a2 = 0; a2 < r2.length; a2++)
              s2 = r2[a2], !(n2.indexOf(s2) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e2, s2) || (t2[s2] = e2[s2]));
          }
          return t2;
        }
        __name(Ln, "Ln");
        function Xf(e2, n2) {
          if (e2 == null)
            return {};
          var t2 = {}, s2 = Object.keys(e2), a2, r2;
          for (r2 = 0; r2 < s2.length; r2++)
            a2 = s2[r2], !(n2.indexOf(a2) >= 0) && (t2[a2] = e2[a2]);
          return t2;
        }
        __name(Xf, "Xf");
        qi();
        ra();
        ua();
        sa();
        var Kf = Object.create, wr = Object.defineProperty, Yf = Object.getOwnPropertyDescriptor, jn = Object.getOwnPropertyNames, Qf = Object.getPrototypeOf, Zf = Object.prototype.hasOwnProperty, gt = /* @__PURE__ */ __name((e2, n2) => function() {
          return e2 && (n2 = (0, e2[jn(e2)[0]])(e2 = 0)), n2;
        }, "gt"), ee = /* @__PURE__ */ __name((e2, n2) => function() {
          return n2 || (0, e2[jn(e2)[0]])((n2 = { exports: {} }).exports, n2), n2.exports;
        }, "ee"), zt = /* @__PURE__ */ __name((e2, n2) => {
          for (var t2 in n2)
            wr(e2, t2, { get: n2[t2], enumerable: true });
        }, "zt"), pa = /* @__PURE__ */ __name((e2, n2, t2, s2) => {
          if (n2 && typeof n2 == "object" || typeof n2 == "function")
            for (let a2 of jn(n2))
              !Zf.call(e2, a2) && a2 !== t2 && wr(e2, a2, { get: () => n2[a2], enumerable: !(s2 = Yf(n2, a2)) || s2.enumerable });
          return e2;
        }, "pa"), eD = /* @__PURE__ */ __name((e2, n2, t2) => (t2 = e2 != null ? Kf(Qf(e2)) : {}, pa(n2 || !e2 || !e2.__esModule ? wr(t2, "default", { value: e2, enumerable: true }) : t2, e2)), "eD"), ft = /* @__PURE__ */ __name((e2) => pa(wr({}, "__esModule", { value: true }), e2), "ft"), ia, aa, Nt, re = gt({ "<define:process>"() {
          ia = {}, aa = [], Nt = { env: ia, argv: aa };
        } }), fa = ee({ "package.json"(e2, n2) {
          n2.exports = { version: "2.8.0" };
        } }), tD = ee({ "node_modules/diff/lib/diff/base.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true }), e2.default = n2;
          function n2() {
          }
          __name(n2, "n");
          n2.prototype = { diff: function(r2, u2) {
            var i2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l2 = i2.callback;
            typeof i2 == "function" && (l2 = i2, i2 = {}), this.options = i2;
            var c2 = this;
            function y2(A2) {
              return l2 ? (setTimeout(function() {
                l2(void 0, A2);
              }, 0), true) : A2;
            }
            __name(y2, "y");
            r2 = this.castInput(r2), u2 = this.castInput(u2), r2 = this.removeEmpty(this.tokenize(r2)), u2 = this.removeEmpty(this.tokenize(u2));
            var h3 = u2.length, g2 = r2.length, p2 = 1, D = h3 + g2, v2 = [{ newPos: -1, components: [] }], w2 = this.extractCommon(v2[0], u2, r2, 0);
            if (v2[0].newPos + 1 >= h3 && w2 + 1 >= g2)
              return y2([{ value: this.join(u2), count: u2.length }]);
            function T2() {
              for (var A2 = -1 * p2; A2 <= p2; A2 += 2) {
                var B = void 0, I = v2[A2 - 1], P2 = v2[A2 + 1], R2 = (P2 ? P2.newPos : 0) - A2;
                I && (v2[A2 - 1] = void 0);
                var f2 = I && I.newPos + 1 < h3, x2 = P2 && 0 <= R2 && R2 < g2;
                if (!f2 && !x2) {
                  v2[A2] = void 0;
                  continue;
                }
                if (!f2 || x2 && I.newPos < P2.newPos ? (B = s2(P2), c2.pushComponent(B.components, void 0, true)) : (B = I, B.newPos++, c2.pushComponent(B.components, true, void 0)), R2 = c2.extractCommon(B, u2, r2, A2), B.newPos + 1 >= h3 && R2 + 1 >= g2)
                  return y2(t2(c2, B.components, u2, r2, c2.useLongestToken));
                v2[A2] = B;
              }
              p2++;
            }
            __name(T2, "T");
            if (l2)
              (/* @__PURE__ */ __name(function A2() {
                setTimeout(function() {
                  if (p2 > D)
                    return l2();
                  T2() || A2();
                }, 0);
              }, "A"))();
            else
              for (; p2 <= D; ) {
                var F = T2();
                if (F)
                  return F;
              }
          }, pushComponent: function(r2, u2, i2) {
            var l2 = r2[r2.length - 1];
            l2 && l2.added === u2 && l2.removed === i2 ? r2[r2.length - 1] = { count: l2.count + 1, added: u2, removed: i2 } : r2.push({ count: 1, added: u2, removed: i2 });
          }, extractCommon: function(r2, u2, i2, l2) {
            for (var c2 = u2.length, y2 = i2.length, h3 = r2.newPos, g2 = h3 - l2, p2 = 0; h3 + 1 < c2 && g2 + 1 < y2 && this.equals(u2[h3 + 1], i2[g2 + 1]); )
              h3++, g2++, p2++;
            return p2 && r2.components.push({ count: p2 }), r2.newPos = h3, g2;
          }, equals: function(r2, u2) {
            return this.options.comparator ? this.options.comparator(r2, u2) : r2 === u2 || this.options.ignoreCase && r2.toLowerCase() === u2.toLowerCase();
          }, removeEmpty: function(r2) {
            for (var u2 = [], i2 = 0; i2 < r2.length; i2++)
              r2[i2] && u2.push(r2[i2]);
            return u2;
          }, castInput: function(r2) {
            return r2;
          }, tokenize: function(r2) {
            return r2.split("");
          }, join: function(r2) {
            return r2.join("");
          } };
          function t2(a2, r2, u2, i2, l2) {
            for (var c2 = 0, y2 = r2.length, h3 = 0, g2 = 0; c2 < y2; c2++) {
              var p2 = r2[c2];
              if (p2.removed) {
                if (p2.value = a2.join(i2.slice(g2, g2 + p2.count)), g2 += p2.count, c2 && r2[c2 - 1].added) {
                  var v2 = r2[c2 - 1];
                  r2[c2 - 1] = r2[c2], r2[c2] = v2;
                }
              } else {
                if (!p2.added && l2) {
                  var D = u2.slice(h3, h3 + p2.count);
                  D = D.map(function(T2, F) {
                    var A2 = i2[g2 + F];
                    return A2.length > T2.length ? A2 : T2;
                  }), p2.value = a2.join(D);
                } else
                  p2.value = a2.join(u2.slice(h3, h3 + p2.count));
                h3 += p2.count, p2.added || (g2 += p2.count);
              }
            }
            var w2 = r2[y2 - 1];
            return y2 > 1 && typeof w2.value == "string" && (w2.added || w2.removed) && a2.equals("", w2.value) && (r2[y2 - 2].value += w2.value, r2.pop()), r2;
          }
          __name(t2, "t");
          function s2(a2) {
            return { newPos: a2.newPos, components: a2.components.slice(0) };
          }
          __name(s2, "s");
        } }), rD = ee({ "node_modules/diff/lib/diff/array.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true }), e2.diffArrays = a2, e2.arrayDiff = void 0;
          var n2 = t2(tD());
          function t2(r2) {
            return r2 && r2.__esModule ? r2 : { default: r2 };
          }
          __name(t2, "t");
          var s2 = new n2.default();
          e2.arrayDiff = s2, s2.tokenize = function(r2) {
            return r2.slice();
          }, s2.join = s2.removeEmpty = function(r2) {
            return r2;
          };
          function a2(r2, u2, i2) {
            return s2.diff(r2, u2, i2);
          }
          __name(a2, "a");
        } }), On = ee({ "src/document/doc-builders.js"(e2, n2) {
          "use strict";
          re();
          function t2(E2) {
            return { type: "concat", parts: E2 };
          }
          __name(t2, "t");
          function s2(E2) {
            return { type: "indent", contents: E2 };
          }
          __name(s2, "s");
          function a2(E2, o2) {
            return { type: "align", contents: o2, n: E2 };
          }
          __name(a2, "a");
          function r2(E2) {
            let o2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return { type: "group", id: o2.id, contents: E2, break: Boolean(o2.shouldBreak), expandedStates: o2.expandedStates };
          }
          __name(r2, "r");
          function u2(E2) {
            return a2(Number.NEGATIVE_INFINITY, E2);
          }
          __name(u2, "u");
          function i2(E2) {
            return a2({ type: "root" }, E2);
          }
          __name(i2, "i");
          function l2(E2) {
            return a2(-1, E2);
          }
          __name(l2, "l");
          function c2(E2, o2) {
            return r2(E2[0], Object.assign(Object.assign({}, o2), {}, { expandedStates: E2 }));
          }
          __name(c2, "c");
          function y2(E2) {
            return { type: "fill", parts: E2 };
          }
          __name(y2, "y");
          function h3(E2, o2) {
            let d2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return { type: "if-break", breakContents: E2, flatContents: o2, groupId: d2.groupId };
          }
          __name(h3, "h");
          function g2(E2, o2) {
            return { type: "indent-if-break", contents: E2, groupId: o2.groupId, negate: o2.negate };
          }
          __name(g2, "g");
          function p2(E2) {
            return { type: "line-suffix", contents: E2 };
          }
          __name(p2, "p");
          var D = { type: "line-suffix-boundary" }, v2 = { type: "break-parent" }, w2 = { type: "trim" }, T2 = { type: "line", hard: true }, F = { type: "line", hard: true, literal: true }, A2 = { type: "line" }, B = { type: "line", soft: true }, I = t2([T2, v2]), P2 = t2([F, v2]), R2 = { type: "cursor", placeholder: Symbol("cursor") };
          function f2(E2, o2) {
            let d2 = [];
            for (let C2 = 0; C2 < o2.length; C2++)
              C2 !== 0 && d2.push(E2), d2.push(o2[C2]);
            return t2(d2);
          }
          __name(f2, "f");
          function x2(E2, o2, d2) {
            let C2 = E2;
            if (o2 > 0) {
              for (let _2 = 0; _2 < Math.floor(o2 / d2); ++_2)
                C2 = s2(C2);
              C2 = a2(o2 % d2, C2), C2 = a2(Number.NEGATIVE_INFINITY, C2);
            }
            return C2;
          }
          __name(x2, "x");
          function m2(E2, o2) {
            return { type: "label", label: E2, contents: o2 };
          }
          __name(m2, "m");
          n2.exports = { concat: t2, join: f2, line: A2, softline: B, hardline: I, literalline: P2, group: r2, conditionalGroup: c2, fill: y2, lineSuffix: p2, lineSuffixBoundary: D, cursor: R2, breakParent: v2, ifBreak: h3, trim: w2, indent: s2, indentIfBreak: g2, align: a2, addAlignmentToDoc: x2, markAsRoot: i2, dedentToRoot: u2, dedent: l2, hardlineWithoutBreakParent: T2, literallineWithoutBreakParent: F, label: m2 };
        } }), qn = ee({ "src/common/end-of-line.js"(e2, n2) {
          "use strict";
          re();
          function t2(u2) {
            let i2 = u2.indexOf("\r");
            return i2 >= 0 ? u2.charAt(i2 + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          __name(t2, "t");
          function s2(u2) {
            switch (u2) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          __name(s2, "s");
          function a2(u2, i2) {
            let l2;
            switch (i2) {
              case `
`:
                l2 = /\n/g;
                break;
              case "\r":
                l2 = /\r/g;
                break;
              case `\r
`:
                l2 = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(i2)}.`);
            }
            let c2 = u2.match(l2);
            return c2 ? c2.length : 0;
          }
          __name(a2, "a");
          function r2(u2) {
            return u2.replace(/\r\n?/g, `
`);
          }
          __name(r2, "r");
          n2.exports = { guessEndOfLine: t2, convertEndOfLineToChars: s2, countEndOfLineChars: a2, normalizeEndOfLine: r2 };
        } }), lt = ee({ "src/utils/get-last.js"(e2, n2) {
          "use strict";
          re();
          var t2 = /* @__PURE__ */ __name((s2) => s2[s2.length - 1], "t");
          n2.exports = t2;
        } });
        function nD() {
          let { onlyFirst: e2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(n2, e2 ? void 0 : "g");
        }
        __name(nD, "nD");
        var uD = gt({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
          re();
        } });
        function sD(e2) {
          if (typeof e2 != "string")
            throw new TypeError(`Expected a \`string\`, got \`${typeof e2}\``);
          return e2.replace(nD(), "");
        }
        __name(sD, "sD");
        var iD = gt({ "node_modules/strip-ansi/index.js"() {
          re(), uD();
        } });
        function aD(e2) {
          return Number.isInteger(e2) ? e2 >= 4352 && (e2 <= 4447 || e2 === 9001 || e2 === 9002 || 11904 <= e2 && e2 <= 12871 && e2 !== 12351 || 12880 <= e2 && e2 <= 19903 || 19968 <= e2 && e2 <= 42182 || 43360 <= e2 && e2 <= 43388 || 44032 <= e2 && e2 <= 55203 || 63744 <= e2 && e2 <= 64255 || 65040 <= e2 && e2 <= 65049 || 65072 <= e2 && e2 <= 65131 || 65281 <= e2 && e2 <= 65376 || 65504 <= e2 && e2 <= 65510 || 110592 <= e2 && e2 <= 110593 || 127488 <= e2 && e2 <= 127569 || 131072 <= e2 && e2 <= 262141) : false;
        }
        __name(aD, "aD");
        var oD = gt({ "node_modules/is-fullwidth-code-point/index.js"() {
          re();
        } }), lD = ee({ "node_modules/emoji-regex/index.js"(e2, n2) {
          "use strict";
          re(), n2.exports = function() {
            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
          };
        } }), Da = {};
        zt(Da, { default: () => cD });
        function cD(e2) {
          if (typeof e2 != "string" || e2.length === 0 || (e2 = sD(e2), e2.length === 0))
            return 0;
          e2 = e2.replace((0, ma.default)(), "  ");
          let n2 = 0;
          for (let t2 = 0; t2 < e2.length; t2++) {
            let s2 = e2.codePointAt(t2);
            s2 <= 31 || s2 >= 127 && s2 <= 159 || s2 >= 768 && s2 <= 879 || (s2 > 65535 && t2++, n2 += aD(s2) ? 2 : 1);
          }
          return n2;
        }
        __name(cD, "cD");
        var ma, pD = gt({ "node_modules/string-width/index.js"() {
          re(), iD(), oD(), ma = eD(lD());
        } }), da = ee({ "src/utils/get-string-width.js"(e2, n2) {
          "use strict";
          re();
          var t2 = (pD(), ft(Da)).default, s2 = /[^\x20-\x7F]/;
          function a2(r2) {
            return r2 ? s2.test(r2) ? t2(r2) : r2.length : 0;
          }
          __name(a2, "a");
          n2.exports = a2;
        } }), Xt = ee({ "src/document/doc-utils.js"(e2, n2) {
          "use strict";
          re();
          var t2 = lt(), { literalline: s2, join: a2 } = On(), r2 = /* @__PURE__ */ __name((o2) => Array.isArray(o2) || o2 && o2.type === "concat", "r"), u2 = /* @__PURE__ */ __name((o2) => {
            if (Array.isArray(o2))
              return o2;
            if (o2.type !== "concat" && o2.type !== "fill")
              throw new Error("Expect doc type to be `concat` or `fill`.");
            return o2.parts;
          }, "u"), i2 = {};
          function l2(o2, d2, C2, _2) {
            let b2 = [o2];
            for (; b2.length > 0; ) {
              let N2 = b2.pop();
              if (N2 === i2) {
                C2(b2.pop());
                continue;
              }
              if (C2 && b2.push(N2, i2), !d2 || d2(N2) !== false)
                if (r2(N2) || N2.type === "fill") {
                  let k2 = u2(N2);
                  for (let $ = k2.length, M2 = $ - 1; M2 >= 0; --M2)
                    b2.push(k2[M2]);
                } else if (N2.type === "if-break")
                  N2.flatContents && b2.push(N2.flatContents), N2.breakContents && b2.push(N2.breakContents);
                else if (N2.type === "group" && N2.expandedStates)
                  if (_2)
                    for (let k2 = N2.expandedStates.length, $ = k2 - 1; $ >= 0; --$)
                      b2.push(N2.expandedStates[$]);
                  else
                    b2.push(N2.contents);
                else
                  N2.contents && b2.push(N2.contents);
            }
          }
          __name(l2, "l");
          function c2(o2, d2) {
            let C2 = /* @__PURE__ */ new Map();
            return _2(o2);
            function _2(N2) {
              if (C2.has(N2))
                return C2.get(N2);
              let k2 = b2(N2);
              return C2.set(N2, k2), k2;
            }
            __name(_2, "_");
            function b2(N2) {
              if (Array.isArray(N2))
                return d2(N2.map(_2));
              if (N2.type === "concat" || N2.type === "fill") {
                let k2 = N2.parts.map(_2);
                return d2(Object.assign(Object.assign({}, N2), {}, { parts: k2 }));
              }
              if (N2.type === "if-break") {
                let k2 = N2.breakContents && _2(N2.breakContents), $ = N2.flatContents && _2(N2.flatContents);
                return d2(Object.assign(Object.assign({}, N2), {}, { breakContents: k2, flatContents: $ }));
              }
              if (N2.type === "group" && N2.expandedStates) {
                let k2 = N2.expandedStates.map(_2), $ = k2[0];
                return d2(Object.assign(Object.assign({}, N2), {}, { contents: $, expandedStates: k2 }));
              }
              if (N2.contents) {
                let k2 = _2(N2.contents);
                return d2(Object.assign(Object.assign({}, N2), {}, { contents: k2 }));
              }
              return d2(N2);
            }
            __name(b2, "b");
          }
          __name(c2, "c");
          function y2(o2, d2, C2) {
            let _2 = C2, b2 = false;
            function N2(k2) {
              let $ = d2(k2);
              if ($ !== void 0 && (b2 = true, _2 = $), b2)
                return false;
            }
            __name(N2, "N");
            return l2(o2, N2), _2;
          }
          __name(y2, "y");
          function h3(o2) {
            if (o2.type === "group" && o2.break || o2.type === "line" && o2.hard || o2.type === "break-parent")
              return true;
          }
          __name(h3, "h");
          function g2(o2) {
            return y2(o2, h3, false);
          }
          __name(g2, "g");
          function p2(o2) {
            if (o2.length > 0) {
              let d2 = t2(o2);
              !d2.expandedStates && !d2.break && (d2.break = "propagated");
            }
            return null;
          }
          __name(p2, "p");
          function D(o2) {
            let d2 = /* @__PURE__ */ new Set(), C2 = [];
            function _2(N2) {
              if (N2.type === "break-parent" && p2(C2), N2.type === "group") {
                if (C2.push(N2), d2.has(N2))
                  return false;
                d2.add(N2);
              }
            }
            __name(_2, "_");
            function b2(N2) {
              N2.type === "group" && C2.pop().break && p2(C2);
            }
            __name(b2, "b");
            l2(o2, _2, b2, true);
          }
          __name(D, "D");
          function v2(o2) {
            return o2.type === "line" && !o2.hard ? o2.soft ? "" : " " : o2.type === "if-break" ? o2.flatContents || "" : o2;
          }
          __name(v2, "v");
          function w2(o2) {
            return c2(o2, v2);
          }
          __name(w2, "w");
          var T2 = /* @__PURE__ */ __name((o2, d2) => o2 && o2.type === "line" && o2.hard && d2 && d2.type === "break-parent", "T");
          function F(o2) {
            if (!o2)
              return o2;
            if (r2(o2) || o2.type === "fill") {
              let d2 = u2(o2);
              for (; d2.length > 1 && T2(...d2.slice(-2)); )
                d2.length -= 2;
              if (d2.length > 0) {
                let C2 = F(t2(d2));
                d2[d2.length - 1] = C2;
              }
              return Array.isArray(o2) ? d2 : Object.assign(Object.assign({}, o2), {}, { parts: d2 });
            }
            switch (o2.type) {
              case "align":
              case "indent":
              case "indent-if-break":
              case "group":
              case "line-suffix":
              case "label": {
                let d2 = F(o2.contents);
                return Object.assign(Object.assign({}, o2), {}, { contents: d2 });
              }
              case "if-break": {
                let d2 = F(o2.breakContents), C2 = F(o2.flatContents);
                return Object.assign(Object.assign({}, o2), {}, { breakContents: d2, flatContents: C2 });
              }
            }
            return o2;
          }
          __name(F, "F");
          function A2(o2) {
            return F(I(o2));
          }
          __name(A2, "A");
          function B(o2) {
            switch (o2.type) {
              case "fill":
                if (o2.parts.every((C2) => C2 === ""))
                  return "";
                break;
              case "group":
                if (!o2.contents && !o2.id && !o2.break && !o2.expandedStates)
                  return "";
                if (o2.contents.type === "group" && o2.contents.id === o2.id && o2.contents.break === o2.break && o2.contents.expandedStates === o2.expandedStates)
                  return o2.contents;
                break;
              case "align":
              case "indent":
              case "indent-if-break":
              case "line-suffix":
                if (!o2.contents)
                  return "";
                break;
              case "if-break":
                if (!o2.flatContents && !o2.breakContents)
                  return "";
                break;
            }
            if (!r2(o2))
              return o2;
            let d2 = [];
            for (let C2 of u2(o2)) {
              if (!C2)
                continue;
              let [_2, ...b2] = r2(C2) ? u2(C2) : [C2];
              typeof _2 == "string" && typeof t2(d2) == "string" ? d2[d2.length - 1] += _2 : d2.push(_2), d2.push(...b2);
            }
            return d2.length === 0 ? "" : d2.length === 1 ? d2[0] : Array.isArray(o2) ? d2 : Object.assign(Object.assign({}, o2), {}, { parts: d2 });
          }
          __name(B, "B");
          function I(o2) {
            return c2(o2, (d2) => B(d2));
          }
          __name(I, "I");
          function P2(o2) {
            let d2 = [], C2 = o2.filter(Boolean);
            for (; C2.length > 0; ) {
              let _2 = C2.shift();
              if (!!_2) {
                if (r2(_2)) {
                  C2.unshift(...u2(_2));
                  continue;
                }
                if (d2.length > 0 && typeof t2(d2) == "string" && typeof _2 == "string") {
                  d2[d2.length - 1] += _2;
                  continue;
                }
                d2.push(_2);
              }
            }
            return d2;
          }
          __name(P2, "P");
          function R2(o2) {
            return c2(o2, (d2) => Array.isArray(d2) ? P2(d2) : d2.parts ? Object.assign(Object.assign({}, d2), {}, { parts: P2(d2.parts) }) : d2);
          }
          __name(R2, "R");
          function f2(o2) {
            return c2(o2, (d2) => typeof d2 == "string" && d2.includes(`
`) ? x2(d2) : d2);
          }
          __name(f2, "f");
          function x2(o2) {
            let d2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s2;
            return a2(d2, o2.split(`
`)).parts;
          }
          __name(x2, "x");
          function m2(o2) {
            if (o2.type === "line")
              return true;
          }
          __name(m2, "m");
          function E2(o2) {
            return y2(o2, m2, false);
          }
          __name(E2, "E");
          n2.exports = { isConcat: r2, getDocParts: u2, willBreak: g2, traverseDoc: l2, findInDoc: y2, mapDoc: c2, propagateBreaks: D, removeLines: w2, stripTrailingHardline: A2, normalizeParts: P2, normalizeDoc: R2, cleanDoc: I, replaceTextEndOfLine: x2, replaceEndOfLine: f2, canBreak: E2 };
        } }), fD = ee({ "src/document/doc-printer.js"(e2, n2) {
          "use strict";
          re();
          var { convertEndOfLineToChars: t2 } = qn(), s2 = lt(), a2 = da(), { fill: r2, cursor: u2, indent: i2 } = On(), { isConcat: l2, getDocParts: c2 } = Xt(), y2, h3 = 1, g2 = 2;
          function p2() {
            return { value: "", length: 0, queue: [] };
          }
          __name(p2, "p");
          function D(B, I) {
            return w2(B, { type: "indent" }, I);
          }
          __name(D, "D");
          function v2(B, I, P2) {
            return I === Number.NEGATIVE_INFINITY ? B.root || p2() : I < 0 ? w2(B, { type: "dedent" }, P2) : I ? I.type === "root" ? Object.assign(Object.assign({}, B), {}, { root: B }) : w2(B, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, P2) : B;
          }
          __name(v2, "v");
          function w2(B, I, P2) {
            let R2 = I.type === "dedent" ? B.queue.slice(0, -1) : [...B.queue, I], f2 = "", x2 = 0, m2 = 0, E2 = 0;
            for (let k2 of R2)
              switch (k2.type) {
                case "indent":
                  C2(), P2.useTabs ? o2(1) : d2(P2.tabWidth);
                  break;
                case "stringAlign":
                  C2(), f2 += k2.n, x2 += k2.n.length;
                  break;
                case "numberAlign":
                  m2 += 1, E2 += k2.n;
                  break;
                default:
                  throw new Error(`Unexpected type '${k2.type}'`);
              }
            return b2(), Object.assign(Object.assign({}, B), {}, { value: f2, length: x2, queue: R2 });
            function o2(k2) {
              f2 += "	".repeat(k2), x2 += P2.tabWidth * k2;
            }
            __name(o2, "o");
            function d2(k2) {
              f2 += " ".repeat(k2), x2 += k2;
            }
            __name(d2, "d");
            function C2() {
              P2.useTabs ? _2() : b2();
            }
            __name(C2, "C");
            function _2() {
              m2 > 0 && o2(m2), N2();
            }
            __name(_2, "_");
            function b2() {
              E2 > 0 && d2(E2), N2();
            }
            __name(b2, "b");
            function N2() {
              m2 = 0, E2 = 0;
            }
            __name(N2, "N");
          }
          __name(w2, "w");
          function T2(B) {
            if (B.length === 0)
              return 0;
            let I = 0;
            for (; B.length > 0 && typeof s2(B) == "string" && /^[\t ]*$/.test(s2(B)); )
              I += B.pop().length;
            if (B.length > 0 && typeof s2(B) == "string") {
              let P2 = s2(B).replace(/[\t ]*$/, "");
              I += s2(B).length - P2.length, B[B.length - 1] = P2;
            }
            return I;
          }
          __name(T2, "T");
          function F(B, I, P2, R2, f2) {
            let x2 = I.length, m2 = [B], E2 = [];
            for (; P2 >= 0; ) {
              if (m2.length === 0) {
                if (x2 === 0)
                  return true;
                m2.push(I[--x2]);
                continue;
              }
              let { mode: o2, doc: d2 } = m2.pop();
              if (typeof d2 == "string")
                E2.push(d2), P2 -= a2(d2);
              else if (l2(d2) || d2.type === "fill") {
                let C2 = c2(d2);
                for (let _2 = C2.length - 1; _2 >= 0; _2--)
                  m2.push({ mode: o2, doc: C2[_2] });
              } else
                switch (d2.type) {
                  case "indent":
                  case "align":
                  case "indent-if-break":
                  case "label":
                    m2.push({ mode: o2, doc: d2.contents });
                    break;
                  case "trim":
                    P2 += T2(E2);
                    break;
                  case "group": {
                    if (f2 && d2.break)
                      return false;
                    let C2 = d2.break ? h3 : o2, _2 = d2.expandedStates && C2 === h3 ? s2(d2.expandedStates) : d2.contents;
                    m2.push({ mode: C2, doc: _2 });
                    break;
                  }
                  case "if-break": {
                    let _2 = (d2.groupId ? y2[d2.groupId] || g2 : o2) === h3 ? d2.breakContents : d2.flatContents;
                    _2 && m2.push({ mode: o2, doc: _2 });
                    break;
                  }
                  case "line":
                    if (o2 === h3 || d2.hard)
                      return true;
                    d2.soft || (E2.push(" "), P2--);
                    break;
                  case "line-suffix":
                    R2 = true;
                    break;
                  case "line-suffix-boundary":
                    if (R2)
                      return false;
                    break;
                }
            }
            return false;
          }
          __name(F, "F");
          function A2(B, I) {
            y2 = {};
            let P2 = I.printWidth, R2 = t2(I.endOfLine), f2 = 0, x2 = [{ ind: p2(), mode: h3, doc: B }], m2 = [], E2 = false, o2 = [];
            for (; x2.length > 0; ) {
              let { ind: C2, mode: _2, doc: b2 } = x2.pop();
              if (typeof b2 == "string") {
                let N2 = R2 !== `
` ? b2.replace(/\n/g, R2) : b2;
                m2.push(N2), f2 += a2(N2);
              } else if (l2(b2)) {
                let N2 = c2(b2);
                for (let k2 = N2.length - 1; k2 >= 0; k2--)
                  x2.push({ ind: C2, mode: _2, doc: N2[k2] });
              } else
                switch (b2.type) {
                  case "cursor":
                    m2.push(u2.placeholder);
                    break;
                  case "indent":
                    x2.push({ ind: D(C2, I), mode: _2, doc: b2.contents });
                    break;
                  case "align":
                    x2.push({ ind: v2(C2, b2.n, I), mode: _2, doc: b2.contents });
                    break;
                  case "trim":
                    f2 -= T2(m2);
                    break;
                  case "group":
                    switch (_2) {
                      case g2:
                        if (!E2) {
                          x2.push({ ind: C2, mode: b2.break ? h3 : g2, doc: b2.contents });
                          break;
                        }
                      case h3: {
                        E2 = false;
                        let N2 = { ind: C2, mode: g2, doc: b2.contents }, k2 = P2 - f2, $ = o2.length > 0;
                        if (!b2.break && F(N2, x2, k2, $))
                          x2.push(N2);
                        else if (b2.expandedStates) {
                          let M2 = s2(b2.expandedStates);
                          if (b2.break) {
                            x2.push({ ind: C2, mode: h3, doc: M2 });
                            break;
                          } else
                            for (let q = 1; q < b2.expandedStates.length + 1; q++)
                              if (q >= b2.expandedStates.length) {
                                x2.push({ ind: C2, mode: h3, doc: M2 });
                                break;
                              } else {
                                let J = b2.expandedStates[q], L2 = { ind: C2, mode: g2, doc: J };
                                if (F(L2, x2, k2, $)) {
                                  x2.push(L2);
                                  break;
                                }
                              }
                        } else
                          x2.push({ ind: C2, mode: h3, doc: b2.contents });
                        break;
                      }
                    }
                    b2.id && (y2[b2.id] = s2(x2).mode);
                    break;
                  case "fill": {
                    let N2 = P2 - f2, { parts: k2 } = b2;
                    if (k2.length === 0)
                      break;
                    let [$, M2] = k2, q = { ind: C2, mode: g2, doc: $ }, J = { ind: C2, mode: h3, doc: $ }, L2 = F(q, [], N2, o2.length > 0, true);
                    if (k2.length === 1) {
                      L2 ? x2.push(q) : x2.push(J);
                      break;
                    }
                    let Y = { ind: C2, mode: g2, doc: M2 }, V = { ind: C2, mode: h3, doc: M2 };
                    if (k2.length === 2) {
                      L2 ? x2.push(Y, q) : x2.push(V, J);
                      break;
                    }
                    k2.splice(0, 2);
                    let O2 = { ind: C2, mode: _2, doc: r2(k2) }, K = k2[0];
                    F({ ind: C2, mode: g2, doc: [$, M2, K] }, [], N2, o2.length > 0, true) ? x2.push(O2, Y, q) : L2 ? x2.push(O2, V, q) : x2.push(O2, V, J);
                    break;
                  }
                  case "if-break":
                  case "indent-if-break": {
                    let N2 = b2.groupId ? y2[b2.groupId] : _2;
                    if (N2 === h3) {
                      let k2 = b2.type === "if-break" ? b2.breakContents : b2.negate ? b2.contents : i2(b2.contents);
                      k2 && x2.push({ ind: C2, mode: _2, doc: k2 });
                    }
                    if (N2 === g2) {
                      let k2 = b2.type === "if-break" ? b2.flatContents : b2.negate ? i2(b2.contents) : b2.contents;
                      k2 && x2.push({ ind: C2, mode: _2, doc: k2 });
                    }
                    break;
                  }
                  case "line-suffix":
                    o2.push({ ind: C2, mode: _2, doc: b2.contents });
                    break;
                  case "line-suffix-boundary":
                    o2.length > 0 && x2.push({ ind: C2, mode: _2, doc: { type: "line", hard: true } });
                    break;
                  case "line":
                    switch (_2) {
                      case g2:
                        if (b2.hard)
                          E2 = true;
                        else {
                          b2.soft || (m2.push(" "), f2 += 1);
                          break;
                        }
                      case h3:
                        if (o2.length > 0) {
                          x2.push({ ind: C2, mode: _2, doc: b2 }, ...o2.reverse()), o2.length = 0;
                          break;
                        }
                        b2.literal ? C2.root ? (m2.push(R2, C2.root.value), f2 = C2.root.length) : (m2.push(R2), f2 = 0) : (f2 -= T2(m2), m2.push(R2 + C2.value), f2 = C2.length);
                        break;
                    }
                    break;
                  case "label":
                    x2.push({ ind: C2, mode: _2, doc: b2.contents });
                    break;
                  default:
                }
              x2.length === 0 && o2.length > 0 && (x2.push(...o2.reverse()), o2.length = 0);
            }
            let d2 = m2.indexOf(u2.placeholder);
            if (d2 !== -1) {
              let C2 = m2.indexOf(u2.placeholder, d2 + 1), _2 = m2.slice(0, d2).join(""), b2 = m2.slice(d2 + 1, C2).join(""), N2 = m2.slice(C2 + 1).join("");
              return { formatted: _2 + b2 + N2, cursorNodeStart: _2.length, cursorNodeText: b2 };
            }
            return { formatted: m2.join("") };
          }
          __name(A2, "A");
          n2.exports = { printDocToString: A2 };
        } }), DD = ee({ "src/document/doc-debug.js"(e2, n2) {
          "use strict";
          re();
          var { isConcat: t2, getDocParts: s2 } = Xt();
          function a2(u2) {
            if (!u2)
              return "";
            if (t2(u2)) {
              let i2 = [];
              for (let l2 of s2(u2))
                if (t2(l2))
                  i2.push(...a2(l2).parts);
                else {
                  let c2 = a2(l2);
                  c2 !== "" && i2.push(c2);
                }
              return { type: "concat", parts: i2 };
            }
            return u2.type === "if-break" ? Object.assign(Object.assign({}, u2), {}, { breakContents: a2(u2.breakContents), flatContents: a2(u2.flatContents) }) : u2.type === "group" ? Object.assign(Object.assign({}, u2), {}, { contents: a2(u2.contents), expandedStates: u2.expandedStates && u2.expandedStates.map(a2) }) : u2.type === "fill" ? { type: "fill", parts: u2.parts.map(a2) } : u2.contents ? Object.assign(Object.assign({}, u2), {}, { contents: a2(u2.contents) }) : u2;
          }
          __name(a2, "a");
          function r2(u2) {
            let i2 = /* @__PURE__ */ Object.create(null), l2 = /* @__PURE__ */ new Set();
            return c2(a2(u2));
            function c2(h3, g2, p2) {
              if (typeof h3 == "string")
                return JSON.stringify(h3);
              if (t2(h3)) {
                let D = s2(h3).map(c2).filter(Boolean);
                return D.length === 1 ? D[0] : `[${D.join(", ")}]`;
              }
              if (h3.type === "line") {
                let D = Array.isArray(p2) && p2[g2 + 1] && p2[g2 + 1].type === "break-parent";
                return h3.literal ? D ? "literalline" : "literallineWithoutBreakParent" : h3.hard ? D ? "hardline" : "hardlineWithoutBreakParent" : h3.soft ? "softline" : "line";
              }
              if (h3.type === "break-parent")
                return Array.isArray(p2) && p2[g2 - 1] && p2[g2 - 1].type === "line" && p2[g2 - 1].hard ? void 0 : "breakParent";
              if (h3.type === "trim")
                return "trim";
              if (h3.type === "indent")
                return "indent(" + c2(h3.contents) + ")";
              if (h3.type === "align")
                return h3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + c2(h3.contents) + ")" : h3.n < 0 ? "dedent(" + c2(h3.contents) + ")" : h3.n.type === "root" ? "markAsRoot(" + c2(h3.contents) + ")" : "align(" + JSON.stringify(h3.n) + ", " + c2(h3.contents) + ")";
              if (h3.type === "if-break")
                return "ifBreak(" + c2(h3.breakContents) + (h3.flatContents ? ", " + c2(h3.flatContents) : "") + (h3.groupId ? (h3.flatContents ? "" : ', ""') + `, { groupId: ${y2(h3.groupId)} }` : "") + ")";
              if (h3.type === "indent-if-break") {
                let D = [];
                h3.negate && D.push("negate: true"), h3.groupId && D.push(`groupId: ${y2(h3.groupId)}`);
                let v2 = D.length > 0 ? `, { ${D.join(", ")} }` : "";
                return `indentIfBreak(${c2(h3.contents)}${v2})`;
              }
              if (h3.type === "group") {
                let D = [];
                h3.break && h3.break !== "propagated" && D.push("shouldBreak: true"), h3.id && D.push(`id: ${y2(h3.id)}`);
                let v2 = D.length > 0 ? `, { ${D.join(", ")} }` : "";
                return h3.expandedStates ? `conditionalGroup([${h3.expandedStates.map((w2) => c2(w2)).join(",")}]${v2})` : `group(${c2(h3.contents)}${v2})`;
              }
              if (h3.type === "fill")
                return `fill([${h3.parts.map((D) => c2(D)).join(", ")}])`;
              if (h3.type === "line-suffix")
                return "lineSuffix(" + c2(h3.contents) + ")";
              if (h3.type === "line-suffix-boundary")
                return "lineSuffixBoundary";
              if (h3.type === "label")
                return `label(${JSON.stringify(h3.label)}, ${c2(h3.contents)})`;
              throw new Error("Unknown doc type " + h3.type);
            }
            __name(c2, "c");
            function y2(h3) {
              if (typeof h3 != "symbol")
                return JSON.stringify(String(h3));
              if (h3 in i2)
                return i2[h3];
              let g2 = String(h3).slice(7, -1) || "symbol";
              for (let p2 = 0; ; p2++) {
                let D = g2 + (p2 > 0 ? ` #${p2}` : "");
                if (!l2.has(D))
                  return l2.add(D), i2[h3] = `Symbol.for(${JSON.stringify(D)})`;
              }
            }
            __name(y2, "y");
          }
          __name(r2, "r");
          n2.exports = { printDocToDebug: r2 };
        } }), qe = ee({ "src/document/index.js"(e2, n2) {
          "use strict";
          re(), n2.exports = { builders: On(), printer: fD(), utils: Xt(), debug: DD() };
        } }), ga = {};
        zt(ga, { default: () => mD });
        function mD(e2) {
          if (typeof e2 != "string")
            throw new TypeError("Expected a string");
          return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        __name(mD, "mD");
        var dD = gt({ "node_modules/escape-string-regexp/index.js"() {
          re();
        } }), ya = ee({ "node_modules/semver/internal/debug.js"(e2, n2) {
          re();
          var t2 = typeof Nt == "object" && Nt.env && Nt.env.NODE_DEBUG && /\bsemver\b/i.test(Nt.env.NODE_DEBUG) ? function() {
            for (var s2 = arguments.length, a2 = new Array(s2), r2 = 0; r2 < s2; r2++)
              a2[r2] = arguments[r2];
            return console.error("SEMVER", ...a2);
          } : () => {
          };
          n2.exports = t2;
        } }), ha = ee({ "node_modules/semver/internal/constants.js"(e2, n2) {
          re();
          var t2 = "2.0.0", s2 = 256, a2 = Number.MAX_SAFE_INTEGER || 9007199254740991, r2 = 16;
          n2.exports = { SEMVER_SPEC_VERSION: t2, MAX_LENGTH: s2, MAX_SAFE_INTEGER: a2, MAX_SAFE_COMPONENT_LENGTH: r2 };
        } }), gD = ee({ "node_modules/semver/internal/re.js"(e2, n2) {
          re();
          var { MAX_SAFE_COMPONENT_LENGTH: t2 } = ha(), s2 = ya();
          e2 = n2.exports = {};
          var a2 = e2.re = [], r2 = e2.src = [], u2 = e2.t = {}, i2 = 0, l2 = /* @__PURE__ */ __name((c2, y2, h3) => {
            let g2 = i2++;
            s2(c2, g2, y2), u2[c2] = g2, r2[g2] = y2, a2[g2] = new RegExp(y2, h3 ? "g" : void 0);
          }, "l");
          l2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l2("MAINVERSION", `(${r2[u2.NUMERICIDENTIFIER]})\\.(${r2[u2.NUMERICIDENTIFIER]})\\.(${r2[u2.NUMERICIDENTIFIER]})`), l2("MAINVERSIONLOOSE", `(${r2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${r2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${r2[u2.NUMERICIDENTIFIERLOOSE]})`), l2("PRERELEASEIDENTIFIER", `(?:${r2[u2.NUMERICIDENTIFIER]}|${r2[u2.NONNUMERICIDENTIFIER]})`), l2("PRERELEASEIDENTIFIERLOOSE", `(?:${r2[u2.NUMERICIDENTIFIERLOOSE]}|${r2[u2.NONNUMERICIDENTIFIER]})`), l2("PRERELEASE", `(?:-(${r2[u2.PRERELEASEIDENTIFIER]}(?:\\.${r2[u2.PRERELEASEIDENTIFIER]})*))`), l2("PRERELEASELOOSE", `(?:-?(${r2[u2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${r2[u2.PRERELEASEIDENTIFIERLOOSE]})*))`), l2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l2("BUILD", `(?:\\+(${r2[u2.BUILDIDENTIFIER]}(?:\\.${r2[u2.BUILDIDENTIFIER]})*))`), l2("FULLPLAIN", `v?${r2[u2.MAINVERSION]}${r2[u2.PRERELEASE]}?${r2[u2.BUILD]}?`), l2("FULL", `^${r2[u2.FULLPLAIN]}$`), l2("LOOSEPLAIN", `[v=\\s]*${r2[u2.MAINVERSIONLOOSE]}${r2[u2.PRERELEASELOOSE]}?${r2[u2.BUILD]}?`), l2("LOOSE", `^${r2[u2.LOOSEPLAIN]}$`), l2("GTLT", "((?:<|>)?=?)"), l2("XRANGEIDENTIFIERLOOSE", `${r2[u2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l2("XRANGEIDENTIFIER", `${r2[u2.NUMERICIDENTIFIER]}|x|X|\\*`), l2("XRANGEPLAIN", `[v=\\s]*(${r2[u2.XRANGEIDENTIFIER]})(?:\\.(${r2[u2.XRANGEIDENTIFIER]})(?:\\.(${r2[u2.XRANGEIDENTIFIER]})(?:${r2[u2.PRERELEASE]})?${r2[u2.BUILD]}?)?)?`), l2("XRANGEPLAINLOOSE", `[v=\\s]*(${r2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${r2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${r2[u2.XRANGEIDENTIFIERLOOSE]})(?:${r2[u2.PRERELEASELOOSE]})?${r2[u2.BUILD]}?)?)?`), l2("XRANGE", `^${r2[u2.GTLT]}\\s*${r2[u2.XRANGEPLAIN]}$`), l2("XRANGELOOSE", `^${r2[u2.GTLT]}\\s*${r2[u2.XRANGEPLAINLOOSE]}$`), l2("COERCE", `(^|[^\\d])(\\d{1,${t2}})(?:\\.(\\d{1,${t2}}))?(?:\\.(\\d{1,${t2}}))?(?:$|[^\\d])`), l2("COERCERTL", r2[u2.COERCE], true), l2("LONETILDE", "(?:~>?)"), l2("TILDETRIM", `(\\s*)${r2[u2.LONETILDE]}\\s+`, true), e2.tildeTrimReplace = "$1~", l2("TILDE", `^${r2[u2.LONETILDE]}${r2[u2.XRANGEPLAIN]}$`), l2("TILDELOOSE", `^${r2[u2.LONETILDE]}${r2[u2.XRANGEPLAINLOOSE]}$`), l2("LONECARET", "(?:\\^)"), l2("CARETTRIM", `(\\s*)${r2[u2.LONECARET]}\\s+`, true), e2.caretTrimReplace = "$1^", l2("CARET", `^${r2[u2.LONECARET]}${r2[u2.XRANGEPLAIN]}$`), l2("CARETLOOSE", `^${r2[u2.LONECARET]}${r2[u2.XRANGEPLAINLOOSE]}$`), l2("COMPARATORLOOSE", `^${r2[u2.GTLT]}\\s*(${r2[u2.LOOSEPLAIN]})$|^$`), l2("COMPARATOR", `^${r2[u2.GTLT]}\\s*(${r2[u2.FULLPLAIN]})$|^$`), l2("COMPARATORTRIM", `(\\s*)${r2[u2.GTLT]}\\s*(${r2[u2.LOOSEPLAIN]}|${r2[u2.XRANGEPLAIN]})`, true), e2.comparatorTrimReplace = "$1$2$3", l2("HYPHENRANGE", `^\\s*(${r2[u2.XRANGEPLAIN]})\\s+-\\s+(${r2[u2.XRANGEPLAIN]})\\s*$`), l2("HYPHENRANGELOOSE", `^\\s*(${r2[u2.XRANGEPLAINLOOSE]})\\s+-\\s+(${r2[u2.XRANGEPLAINLOOSE]})\\s*$`), l2("STAR", "(<|>)?=?\\s*\\*"), l2("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l2("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        } }), yD = ee({ "node_modules/semver/internal/parse-options.js"(e2, n2) {
          re();
          var t2 = ["includePrerelease", "loose", "rtl"], s2 = /* @__PURE__ */ __name((a2) => a2 ? typeof a2 != "object" ? { loose: true } : t2.filter((r2) => a2[r2]).reduce((r2, u2) => (r2[u2] = true, r2), {}) : {}, "s");
          n2.exports = s2;
        } }), hD = ee({ "node_modules/semver/internal/identifiers.js"(e2, n2) {
          re();
          var t2 = /^[0-9]+$/, s2 = /* @__PURE__ */ __name((r2, u2) => {
            let i2 = t2.test(r2), l2 = t2.test(u2);
            return i2 && l2 && (r2 = +r2, u2 = +u2), r2 === u2 ? 0 : i2 && !l2 ? -1 : l2 && !i2 ? 1 : r2 < u2 ? -1 : 1;
          }, "s"), a2 = /* @__PURE__ */ __name((r2, u2) => s2(u2, r2), "a");
          n2.exports = { compareIdentifiers: s2, rcompareIdentifiers: a2 };
        } }), vD = ee({ "node_modules/semver/classes/semver.js"(e2, n2) {
          re();
          var t2 = ya(), { MAX_LENGTH: s2, MAX_SAFE_INTEGER: a2 } = ha(), { re: r2, t: u2 } = gD(), i2 = yD(), { compareIdentifiers: l2 } = hD(), c2 = /* @__PURE__ */ __name(class {
            constructor(y2, h3) {
              if (h3 = i2(h3), y2 instanceof c2) {
                if (y2.loose === !!h3.loose && y2.includePrerelease === !!h3.includePrerelease)
                  return y2;
                y2 = y2.version;
              } else if (typeof y2 != "string")
                throw new TypeError(`Invalid Version: ${y2}`);
              if (y2.length > s2)
                throw new TypeError(`version is longer than ${s2} characters`);
              t2("SemVer", y2, h3), this.options = h3, this.loose = !!h3.loose, this.includePrerelease = !!h3.includePrerelease;
              let g2 = y2.trim().match(h3.loose ? r2[u2.LOOSE] : r2[u2.FULL]);
              if (!g2)
                throw new TypeError(`Invalid Version: ${y2}`);
              if (this.raw = y2, this.major = +g2[1], this.minor = +g2[2], this.patch = +g2[3], this.major > a2 || this.major < 0)
                throw new TypeError("Invalid major version");
              if (this.minor > a2 || this.minor < 0)
                throw new TypeError("Invalid minor version");
              if (this.patch > a2 || this.patch < 0)
                throw new TypeError("Invalid patch version");
              g2[4] ? this.prerelease = g2[4].split(".").map((p2) => {
                if (/^[0-9]+$/.test(p2)) {
                  let D = +p2;
                  if (D >= 0 && D < a2)
                    return D;
                }
                return p2;
              }) : this.prerelease = [], this.build = g2[5] ? g2[5].split(".") : [], this.format();
            }
            format() {
              return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
            }
            toString() {
              return this.version;
            }
            compare(y2) {
              if (t2("SemVer.compare", this.version, this.options, y2), !(y2 instanceof c2)) {
                if (typeof y2 == "string" && y2 === this.version)
                  return 0;
                y2 = new c2(y2, this.options);
              }
              return y2.version === this.version ? 0 : this.compareMain(y2) || this.comparePre(y2);
            }
            compareMain(y2) {
              return y2 instanceof c2 || (y2 = new c2(y2, this.options)), l2(this.major, y2.major) || l2(this.minor, y2.minor) || l2(this.patch, y2.patch);
            }
            comparePre(y2) {
              if (y2 instanceof c2 || (y2 = new c2(y2, this.options)), this.prerelease.length && !y2.prerelease.length)
                return -1;
              if (!this.prerelease.length && y2.prerelease.length)
                return 1;
              if (!this.prerelease.length && !y2.prerelease.length)
                return 0;
              let h3 = 0;
              do {
                let g2 = this.prerelease[h3], p2 = y2.prerelease[h3];
                if (t2("prerelease compare", h3, g2, p2), g2 === void 0 && p2 === void 0)
                  return 0;
                if (p2 === void 0)
                  return 1;
                if (g2 === void 0)
                  return -1;
                if (g2 === p2)
                  continue;
                return l2(g2, p2);
              } while (++h3);
            }
            compareBuild(y2) {
              y2 instanceof c2 || (y2 = new c2(y2, this.options));
              let h3 = 0;
              do {
                let g2 = this.build[h3], p2 = y2.build[h3];
                if (t2("prerelease compare", h3, g2, p2), g2 === void 0 && p2 === void 0)
                  return 0;
                if (p2 === void 0)
                  return 1;
                if (g2 === void 0)
                  return -1;
                if (g2 === p2)
                  continue;
                return l2(g2, p2);
              } while (++h3);
            }
            inc(y2, h3) {
              switch (y2) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", h3);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", h3);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", h3), this.inc("pre", h3);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", h3), this.inc("pre", h3);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0)
                    this.prerelease = [0];
                  else {
                    let g2 = this.prerelease.length;
                    for (; --g2 >= 0; )
                      typeof this.prerelease[g2] == "number" && (this.prerelease[g2]++, g2 = -2);
                    g2 === -1 && this.prerelease.push(0);
                  }
                  h3 && (l2(this.prerelease[0], h3) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [h3, 0]) : this.prerelease = [h3, 0]);
                  break;
                default:
                  throw new Error(`invalid increment argument: ${y2}`);
              }
              return this.format(), this.raw = this.version, this;
            }
          }, "c");
          n2.exports = c2;
        } }), Mn = ee({ "node_modules/semver/functions/compare.js"(e2, n2) {
          re();
          var t2 = vD(), s2 = /* @__PURE__ */ __name((a2, r2, u2) => new t2(a2, u2).compare(new t2(r2, u2)), "s");
          n2.exports = s2;
        } }), CD = ee({ "node_modules/semver/functions/lt.js"(e2, n2) {
          re();
          var t2 = Mn(), s2 = /* @__PURE__ */ __name((a2, r2, u2) => t2(a2, r2, u2) < 0, "s");
          n2.exports = s2;
        } }), ED = ee({ "node_modules/semver/functions/gte.js"(e2, n2) {
          re();
          var t2 = Mn(), s2 = /* @__PURE__ */ __name((a2, r2, u2) => t2(a2, r2, u2) >= 0, "s");
          n2.exports = s2;
        } }), FD = ee({ "src/utils/arrayify.js"(e2, n2) {
          "use strict";
          re(), n2.exports = (t2, s2) => Object.entries(t2).map((a2) => {
            let [r2, u2] = a2;
            return Object.assign({ [s2]: r2 }, u2);
          });
        } }), AD = ee({ "node_modules/outdent/lib/index.js"(e2, n2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true }), e2.outdent = void 0;
          function t2() {
            for (var F = [], A2 = 0; A2 < arguments.length; A2++)
              F[A2] = arguments[A2];
          }
          __name(t2, "t");
          function s2() {
            return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a2();
          }
          __name(s2, "s");
          function a2() {
            return { add: t2, delete: t2, get: t2, set: t2, has: function(F) {
              return false;
            } };
          }
          __name(a2, "a");
          var r2 = Object.prototype.hasOwnProperty, u2 = /* @__PURE__ */ __name(function(F, A2) {
            return r2.call(F, A2);
          }, "u");
          function i2(F, A2) {
            for (var B in A2)
              u2(A2, B) && (F[B] = A2[B]);
            return F;
          }
          __name(i2, "i");
          var l2 = /^[ \t]*(?:\r\n|\r|\n)/, c2 = /(?:\r\n|\r|\n)[ \t]*$/, y2 = /^(?:[\r\n]|$)/, h3 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function p2(F, A2, B) {
            var I = 0, P2 = F[0].match(h3);
            P2 && (I = P2[1].length);
            var R2 = "(\\r\\n|\\r|\\n).{0," + I + "}", f2 = new RegExp(R2, "g");
            A2 && (F = F.slice(1));
            var x2 = B.newline, m2 = B.trimLeadingNewline, E2 = B.trimTrailingNewline, o2 = typeof x2 == "string", d2 = F.length, C2 = F.map(function(_2, b2) {
              return _2 = _2.replace(f2, "$1"), b2 === 0 && m2 && (_2 = _2.replace(l2, "")), b2 === d2 - 1 && E2 && (_2 = _2.replace(c2, "")), o2 && (_2 = _2.replace(/\r\n|\n|\r/g, function(N2) {
                return x2;
              })), _2;
            });
            return C2;
          }
          __name(p2, "p");
          function D(F, A2) {
            for (var B = "", I = 0, P2 = F.length; I < P2; I++)
              B += F[I], I < P2 - 1 && (B += A2[I]);
            return B;
          }
          __name(D, "D");
          function v2(F) {
            return u2(F, "raw") && u2(F, "length");
          }
          __name(v2, "v");
          function w2(F) {
            var A2 = s2(), B = s2();
            function I(R2) {
              for (var f2 = [], x2 = 1; x2 < arguments.length; x2++)
                f2[x2 - 1] = arguments[x2];
              if (v2(R2)) {
                var m2 = R2, E2 = (f2[0] === I || f2[0] === T2) && g2.test(m2[0]) && y2.test(m2[1]), o2 = E2 ? B : A2, d2 = o2.get(m2);
                if (d2 || (d2 = p2(m2, E2, F), o2.set(m2, d2)), f2.length === 0)
                  return d2[0];
                var C2 = D(d2, E2 ? f2.slice(1) : f2);
                return C2;
              } else
                return w2(i2(i2({}, F), R2 || {}));
            }
            __name(I, "I");
            var P2 = i2(I, { string: function(R2) {
              return p2([R2], false, F)[0];
            } });
            return P2;
          }
          __name(w2, "w");
          var T2 = w2({ trimLeadingNewline: true, trimTrailingNewline: true });
          if (e2.outdent = T2, e2.default = T2, typeof n2 < "u")
            try {
              n2.exports = T2, Object.defineProperty(T2, "__esModule", { value: true }), T2.default = T2, T2.outdent = T2;
            } catch {
            }
        } }), SD = ee({ "src/main/core-options.js"(e2, n2) {
          "use strict";
          re();
          var { outdent: t2 } = AD(), s2 = "Config", a2 = "Editor", r2 = "Format", u2 = "Other", i2 = "Output", l2 = "Global", c2 = "Special", y2 = { cursorOffset: { since: "1.4.0", category: c2, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t2`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a2 }, endOfLine: { since: "1.15.0", category: l2, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t2`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: c2, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u2, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: c2, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u2 }, parser: { since: "0.0.10", category: l2, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (h3) => typeof h3 == "string" || typeof h3 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l2, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (h3) => typeof h3 == "string" || typeof h3 == "object", cliName: "plugin", cliCategory: s2 }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l2, description: t2`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (h3) => typeof h3 == "string" || typeof h3 == "object", cliName: "plugin-search-dir", cliCategory: s2 }, printWidth: { since: "0.0.0", category: l2, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: c2, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t2`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a2 }, rangeStart: { since: "1.4.0", category: c2, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t2`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a2 }, requirePragma: { since: "1.7.0", category: c2, type: "boolean", default: false, description: t2`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u2 }, tabWidth: { type: "int", category: l2, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l2, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l2, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
          n2.exports = { CATEGORY_CONFIG: s2, CATEGORY_EDITOR: a2, CATEGORY_FORMAT: r2, CATEGORY_OTHER: u2, CATEGORY_OUTPUT: i2, CATEGORY_GLOBAL: l2, CATEGORY_SPECIAL: c2, options: y2 };
        } }), Rn = ee({ "src/main/support.js"(e2, n2) {
          "use strict";
          re();
          var t2 = { compare: Mn(), lt: CD(), gte: ED() }, s2 = FD(), a2 = fa().version, r2 = SD().options;
          function u2() {
            let { plugins: l2 = [], showUnreleased: c2 = false, showDeprecated: y2 = false, showInternal: h3 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g2 = a2.split("-", 1)[0], p2 = l2.flatMap((F) => F.languages || []).filter(v2), D = s2(Object.assign({}, ...l2.map((F) => {
              let { options: A2 } = F;
              return A2;
            }), r2), "name").filter((F) => v2(F) && w2(F)).sort((F, A2) => F.name === A2.name ? 0 : F.name < A2.name ? -1 : 1).map(T2).map((F) => {
              F = Object.assign({}, F), Array.isArray(F.default) && (F.default = F.default.length === 1 ? F.default[0].value : F.default.filter(v2).sort((B, I) => t2.compare(I.since, B.since))[0].value), Array.isArray(F.choices) && (F.choices = F.choices.filter((B) => v2(B) && w2(B)), F.name === "parser" && i2(F, p2, l2));
              let A2 = Object.fromEntries(l2.filter((B) => B.defaultOptions && B.defaultOptions[F.name] !== void 0).map((B) => [B.name, B.defaultOptions[F.name]]));
              return Object.assign(Object.assign({}, F), {}, { pluginDefaults: A2 });
            });
            return { languages: p2, options: D };
            function v2(F) {
              return c2 || !("since" in F) || F.since && t2.gte(g2, F.since);
            }
            __name(v2, "v");
            function w2(F) {
              return y2 || !("deprecated" in F) || F.deprecated && t2.lt(g2, F.deprecated);
            }
            __name(w2, "w");
            function T2(F) {
              if (h3)
                return F;
              let { cliName: A2, cliCategory: B, cliDescription: I } = F;
              return Ln(F, Uf);
            }
            __name(T2, "T");
          }
          __name(u2, "u");
          function i2(l2, c2, y2) {
            let h3 = new Set(l2.choices.map((g2) => g2.value));
            for (let g2 of c2)
              if (g2.parsers) {
                for (let p2 of g2.parsers)
                  if (!h3.has(p2)) {
                    h3.add(p2);
                    let D = y2.find((w2) => w2.parsers && w2.parsers[p2]), v2 = g2.name;
                    D && D.name && (v2 += ` (plugin: ${D.name})`), l2.choices.push({ value: p2, description: v2 });
                  }
              }
          }
          __name(i2, "i");
          n2.exports = { getSupportInfo: u2 };
        } }), $n = ee({ "src/utils/is-non-empty-array.js"(e2, n2) {
          "use strict";
          re();
          function t2(s2) {
            return Array.isArray(s2) && s2.length > 0;
          }
          __name(t2, "t");
          n2.exports = t2;
        } }), _r = ee({ "src/utils/text/skip.js"(e2, n2) {
          "use strict";
          re();
          function t2(i2) {
            return (l2, c2, y2) => {
              let h3 = y2 && y2.backwards;
              if (c2 === false)
                return false;
              let { length: g2 } = l2, p2 = c2;
              for (; p2 >= 0 && p2 < g2; ) {
                let D = l2.charAt(p2);
                if (i2 instanceof RegExp) {
                  if (!i2.test(D))
                    return p2;
                } else if (!i2.includes(D))
                  return p2;
                h3 ? p2-- : p2++;
              }
              return p2 === -1 || p2 === g2 ? p2 : false;
            };
          }
          __name(t2, "t");
          var s2 = t2(/\s/), a2 = t2(" 	"), r2 = t2(",; 	"), u2 = t2(/[^\n\r]/);
          n2.exports = { skipWhitespace: s2, skipSpaces: a2, skipToLineEnd: r2, skipEverythingButNewLine: u2 };
        } }), va = ee({ "src/utils/text/skip-inline-comment.js"(e2, n2) {
          "use strict";
          re();
          function t2(s2, a2) {
            if (a2 === false)
              return false;
            if (s2.charAt(a2) === "/" && s2.charAt(a2 + 1) === "*") {
              for (let r2 = a2 + 2; r2 < s2.length; ++r2)
                if (s2.charAt(r2) === "*" && s2.charAt(r2 + 1) === "/")
                  return r2 + 2;
            }
            return a2;
          }
          __name(t2, "t");
          n2.exports = t2;
        } }), Ca = ee({ "src/utils/text/skip-trailing-comment.js"(e2, n2) {
          "use strict";
          re();
          var { skipEverythingButNewLine: t2 } = _r();
          function s2(a2, r2) {
            return r2 === false ? false : a2.charAt(r2) === "/" && a2.charAt(r2 + 1) === "/" ? t2(a2, r2) : r2;
          }
          __name(s2, "s");
          n2.exports = s2;
        } }), Ea = ee({ "src/utils/text/skip-newline.js"(e2, n2) {
          "use strict";
          re();
          function t2(s2, a2, r2) {
            let u2 = r2 && r2.backwards;
            if (a2 === false)
              return false;
            let i2 = s2.charAt(a2);
            if (u2) {
              if (s2.charAt(a2 - 1) === "\r" && i2 === `
`)
                return a2 - 2;
              if (i2 === `
` || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
                return a2 - 1;
            } else {
              if (i2 === "\r" && s2.charAt(a2 + 1) === `
`)
                return a2 + 2;
              if (i2 === `
` || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
                return a2 + 1;
            }
            return a2;
          }
          __name(t2, "t");
          n2.exports = t2;
        } }), xD = ee({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e2, n2) {
          "use strict";
          re();
          var t2 = va(), s2 = Ea(), a2 = Ca(), { skipSpaces: r2 } = _r();
          function u2(i2, l2) {
            let c2 = null, y2 = l2;
            for (; y2 !== c2; )
              c2 = y2, y2 = r2(i2, y2), y2 = t2(i2, y2), y2 = a2(i2, y2), y2 = s2(i2, y2);
            return y2;
          }
          __name(u2, "u");
          n2.exports = u2;
        } }), Ge = ee({ "src/common/util.js"(e2, n2) {
          "use strict";
          re();
          var { default: t2 } = (dD(), ft(ga)), s2 = lt(), { getSupportInfo: a2 } = Rn(), r2 = $n(), u2 = da(), { skipWhitespace: i2, skipSpaces: l2, skipToLineEnd: c2, skipEverythingButNewLine: y2 } = _r(), h3 = va(), g2 = Ca(), p2 = Ea(), D = xD(), v2 = /* @__PURE__ */ __name((V) => V[V.length - 2], "v");
          function w2(V) {
            return (O2, K, se) => {
              let Q = se && se.backwards;
              if (K === false)
                return false;
              let { length: le } = O2, W2 = K;
              for (; W2 >= 0 && W2 < le; ) {
                let X = O2.charAt(W2);
                if (V instanceof RegExp) {
                  if (!V.test(X))
                    return W2;
                } else if (!V.includes(X))
                  return W2;
                Q ? W2-- : W2++;
              }
              return W2 === -1 || W2 === le ? W2 : false;
            };
          }
          __name(w2, "w");
          function T2(V, O2) {
            let K = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, se = l2(V, K.backwards ? O2 - 1 : O2, K), Q = p2(V, se, K);
            return se !== Q;
          }
          __name(T2, "T");
          function F(V, O2, K) {
            for (let se = O2; se < K; ++se)
              if (V.charAt(se) === `
`)
                return true;
            return false;
          }
          __name(F, "F");
          function A2(V, O2, K) {
            let se = K(O2) - 1;
            se = l2(V, se, { backwards: true }), se = p2(V, se, { backwards: true }), se = l2(V, se, { backwards: true });
            let Q = p2(V, se, { backwards: true });
            return se !== Q;
          }
          __name(A2, "A");
          function B(V, O2) {
            let K = null, se = O2;
            for (; se !== K; )
              K = se, se = c2(V, se), se = h3(V, se), se = l2(V, se);
            return se = g2(V, se), se = p2(V, se), se !== false && T2(V, se);
          }
          __name(B, "B");
          function I(V, O2, K) {
            return B(V, K(O2));
          }
          __name(I, "I");
          function P2(V, O2, K) {
            return D(V, K(O2));
          }
          __name(P2, "P");
          function R2(V, O2, K) {
            return V.charAt(P2(V, O2, K));
          }
          __name(R2, "R");
          function f2(V, O2) {
            let K = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return l2(V, K.backwards ? O2 - 1 : O2, K) !== O2;
          }
          __name(f2, "f");
          function x2(V, O2) {
            let K = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, se = 0;
            for (let Q = K; Q < V.length; ++Q)
              V[Q] === "	" ? se = se + O2 - se % O2 : se++;
            return se;
          }
          __name(x2, "x");
          function m2(V, O2) {
            let K = V.lastIndexOf(`
`);
            return K === -1 ? 0 : x2(V.slice(K + 1).match(/^[\t ]*/)[0], O2);
          }
          __name(m2, "m");
          function E2(V, O2) {
            let K = { quote: '"', regex: /"/g, escaped: "&quot;" }, se = { quote: "'", regex: /'/g, escaped: "&apos;" }, Q = O2 === "'" ? se : K, le = Q === se ? K : se, W2 = Q;
            if (V.includes(Q.quote) || V.includes(le.quote)) {
              let X = (V.match(Q.regex) || []).length, oe = (V.match(le.regex) || []).length;
              W2 = X > oe ? le : Q;
            }
            return W2;
          }
          __name(E2, "E");
          function o2(V, O2) {
            let K = V.slice(1, -1), se = O2.parser === "json" || O2.parser === "json5" && O2.quoteProps === "preserve" && !O2.singleQuote ? '"' : O2.__isInHtmlAttribute ? "'" : E2(K, O2.singleQuote ? "'" : '"').quote;
            return d2(K, se, !(O2.parser === "css" || O2.parser === "less" || O2.parser === "scss" || O2.__embeddedInHtml));
          }
          __name(o2, "o");
          function d2(V, O2, K) {
            let se = O2 === '"' ? "'" : '"', Q = /\\(.)|(["'])/gs, le = V.replace(Q, (W2, X, oe) => X === se ? X : oe === O2 ? "\\" + oe : oe || (K && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(X) ? X : "\\" + X));
            return O2 + le + O2;
          }
          __name(d2, "d");
          function C2(V) {
            return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          }
          __name(C2, "C");
          function _2(V, O2) {
            let K = V.match(new RegExp(`(${t2(O2)})+`, "g"));
            return K === null ? 0 : K.reduce((se, Q) => Math.max(se, Q.length / O2.length), 0);
          }
          __name(_2, "_");
          function b2(V, O2) {
            let K = V.match(new RegExp(`(${t2(O2)})+`, "g"));
            if (K === null)
              return 0;
            let se = /* @__PURE__ */ new Map(), Q = 0;
            for (let le of K) {
              let W2 = le.length / O2.length;
              se.set(W2, true), W2 > Q && (Q = W2);
            }
            for (let le = 1; le < Q; le++)
              if (!se.get(le))
                return le;
            return Q + 1;
          }
          __name(b2, "b");
          function N2(V, O2) {
            (V.comments || (V.comments = [])).push(O2), O2.printed = false, O2.nodeDescription = Y(V);
          }
          __name(N2, "N");
          function k2(V, O2) {
            O2.leading = true, O2.trailing = false, N2(V, O2);
          }
          __name(k2, "k");
          function $(V, O2, K) {
            O2.leading = false, O2.trailing = false, K && (O2.marker = K), N2(V, O2);
          }
          __name($, "$");
          function M2(V, O2) {
            O2.leading = false, O2.trailing = true, N2(V, O2);
          }
          __name(M2, "M");
          function q(V, O2) {
            let { languages: K } = a2({ plugins: O2.plugins }), se = K.find((Q) => {
              let { name: le } = Q;
              return le.toLowerCase() === V;
            }) || K.find((Q) => {
              let { aliases: le } = Q;
              return Array.isArray(le) && le.includes(V);
            }) || K.find((Q) => {
              let { extensions: le } = Q;
              return Array.isArray(le) && le.includes(`.${V}`);
            });
            return se && se.parsers[0];
          }
          __name(q, "q");
          function J(V) {
            return V && V.type === "front-matter";
          }
          __name(J, "J");
          function L2(V) {
            let O2 = /* @__PURE__ */ new WeakMap();
            return function(K) {
              return O2.has(K) || O2.set(K, Symbol(V)), O2.get(K);
            };
          }
          __name(L2, "L");
          function Y(V) {
            let O2 = V.type || V.kind || "(unknown type)", K = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
            return K.length > 20 && (K = K.slice(0, 19) + "\u2026"), O2 + (K ? " " + K : "");
          }
          __name(Y, "Y");
          n2.exports = { inferParserByLanguage: q, getStringWidth: u2, getMaxContinuousCount: _2, getMinNotPresentContinuousCount: b2, getPenultimate: v2, getLast: s2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: D, getNextNonSpaceNonCommentCharacterIndex: P2, getNextNonSpaceNonCommentCharacter: R2, skip: w2, skipWhitespace: i2, skipSpaces: l2, skipToLineEnd: c2, skipEverythingButNewLine: y2, skipInlineComment: h3, skipTrailingComment: g2, skipNewline: p2, isNextLineEmptyAfterIndex: B, isNextLineEmpty: I, isPreviousLineEmpty: A2, hasNewline: T2, hasNewlineInRange: F, hasSpaces: f2, getAlignmentSize: x2, getIndentSize: m2, getPreferredQuote: E2, printString: o2, printNumber: C2, makeString: d2, addLeadingComment: k2, addDanglingComment: $, addTrailingComment: M2, isFrontMatterNode: J, isNonEmptyArray: r2, createGroupIdMapper: L2 };
        } }), Fa = {};
        zt(Fa, { basename: () => Ta, default: () => Na, delimiter: () => wn, dirname: () => ba, extname: () => Ba, isAbsolute: () => Wn, join: () => Sa, normalize: () => Vn, relative: () => xa, resolve: () => Nr, sep: () => Nn });
        function Aa(e2, n2) {
          for (var t2 = 0, s2 = e2.length - 1; s2 >= 0; s2--) {
            var a2 = e2[s2];
            a2 === "." ? e2.splice(s2, 1) : a2 === ".." ? (e2.splice(s2, 1), t2++) : t2 && (e2.splice(s2, 1), t2--);
          }
          if (n2)
            for (; t2--; t2)
              e2.unshift("..");
          return e2;
        }
        __name(Aa, "Aa");
        function Nr() {
          for (var e2 = "", n2 = false, t2 = arguments.length - 1; t2 >= -1 && !n2; t2--) {
            var s2 = t2 >= 0 ? arguments[t2] : "/";
            if (typeof s2 != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!s2)
              continue;
            e2 = s2 + "/" + e2, n2 = s2.charAt(0) === "/";
          }
          return e2 = Aa(Hn(e2.split("/"), function(a2) {
            return !!a2;
          }), !n2).join("/"), (n2 ? "/" : "") + e2 || ".";
        }
        __name(Nr, "Nr");
        function Vn(e2) {
          var n2 = Wn(e2), t2 = wa(e2, -1) === "/";
          return e2 = Aa(Hn(e2.split("/"), function(s2) {
            return !!s2;
          }), !n2).join("/"), !e2 && !n2 && (e2 = "."), e2 && t2 && (e2 += "/"), (n2 ? "/" : "") + e2;
        }
        __name(Vn, "Vn");
        function Wn(e2) {
          return e2.charAt(0) === "/";
        }
        __name(Wn, "Wn");
        function Sa() {
          var e2 = Array.prototype.slice.call(arguments, 0);
          return Vn(Hn(e2, function(n2, t2) {
            if (typeof n2 != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return n2;
          }).join("/"));
        }
        __name(Sa, "Sa");
        function xa(e2, n2) {
          e2 = Nr(e2).substr(1), n2 = Nr(n2).substr(1);
          function t2(c2) {
            for (var y2 = 0; y2 < c2.length && c2[y2] === ""; y2++)
              ;
            for (var h3 = c2.length - 1; h3 >= 0 && c2[h3] === ""; h3--)
              ;
            return y2 > h3 ? [] : c2.slice(y2, h3 - y2 + 1);
          }
          __name(t2, "t");
          for (var s2 = t2(e2.split("/")), a2 = t2(n2.split("/")), r2 = Math.min(s2.length, a2.length), u2 = r2, i2 = 0; i2 < r2; i2++)
            if (s2[i2] !== a2[i2]) {
              u2 = i2;
              break;
            }
          for (var l2 = [], i2 = u2; i2 < s2.length; i2++)
            l2.push("..");
          return l2 = l2.concat(a2.slice(u2)), l2.join("/");
        }
        __name(xa, "xa");
        function ba(e2) {
          var n2 = Pr(e2), t2 = n2[0], s2 = n2[1];
          return !t2 && !s2 ? "." : (s2 && (s2 = s2.substr(0, s2.length - 1)), t2 + s2);
        }
        __name(ba, "ba");
        function Ta(e2, n2) {
          var t2 = Pr(e2)[2];
          return n2 && t2.substr(-1 * n2.length) === n2 && (t2 = t2.substr(0, t2.length - n2.length)), t2;
        }
        __name(Ta, "Ta");
        function Ba(e2) {
          return Pr(e2)[3];
        }
        __name(Ba, "Ba");
        function Hn(e2, n2) {
          if (e2.filter)
            return e2.filter(n2);
          for (var t2 = [], s2 = 0; s2 < e2.length; s2++)
            n2(e2[s2], s2, e2) && t2.push(e2[s2]);
          return t2;
        }
        __name(Hn, "Hn");
        var oa, Pr, Nn, wn, Na, wa, bD = gt({ "node-modules-polyfills:path"() {
          re(), oa = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Pr = /* @__PURE__ */ __name(function(e2) {
            return oa.exec(e2).slice(1);
          }, "Pr"), Nn = "/", wn = ":", Na = { extname: Ba, basename: Ta, dirname: ba, sep: Nn, delimiter: wn, relative: xa, join: Sa, isAbsolute: Wn, normalize: Vn, resolve: Nr }, wa = "ab".substr(-1) === "b" ? function(e2, n2, t2) {
            return e2.substr(n2, t2);
          } : function(e2, n2, t2) {
            return n2 < 0 && (n2 = e2.length + n2), e2.substr(n2, t2);
          };
        } }), TD = ee({ "node-modules-polyfills-commonjs:path"(e2, n2) {
          re();
          var t2 = (bD(), ft(Fa));
          if (t2 && t2.default) {
            n2.exports = t2.default;
            for (let s2 in t2)
              n2.exports[s2] = t2[s2];
          } else
            t2 && (n2.exports = t2);
        } }), Kt = ee({ "src/common/errors.js"(e2, n2) {
          "use strict";
          re();
          var t2 = /* @__PURE__ */ __name(class extends Error {
          }, "t"), s2 = /* @__PURE__ */ __name(class extends Error {
          }, "s"), a2 = /* @__PURE__ */ __name(class extends Error {
          }, "a"), r2 = /* @__PURE__ */ __name(class extends Error {
          }, "r");
          n2.exports = { ConfigError: t2, DebugError: s2, UndefinedParserError: a2, ArgExpansionBailout: r2 };
        } }), yt = {};
        zt(yt, { __assign: () => Br, __asyncDelegator: () => RD, __asyncGenerator: () => MD, __asyncValues: () => $D, __await: () => Jt, __awaiter: () => ID, __classPrivateFieldGet: () => GD, __classPrivateFieldSet: () => UD, __createBinding: () => LD, __decorate: () => wD, __exportStar: () => jD, __extends: () => BD, __generator: () => kD, __importDefault: () => HD, __importStar: () => WD, __makeTemplateObject: () => VD, __metadata: () => PD, __param: () => _D, __read: () => _a, __rest: () => ND, __spread: () => OD, __spreadArrays: () => qD, __values: () => _n });
        function BD(e2, n2) {
          Tr(e2, n2);
          function t2() {
            this.constructor = e2;
          }
          __name(t2, "t");
          e2.prototype = n2 === null ? Object.create(n2) : (t2.prototype = n2.prototype, new t2());
        }
        __name(BD, "BD");
        function ND(e2, n2) {
          var t2 = {};
          for (var s2 in e2)
            Object.prototype.hasOwnProperty.call(e2, s2) && n2.indexOf(s2) < 0 && (t2[s2] = e2[s2]);
          if (e2 != null && typeof Object.getOwnPropertySymbols == "function")
            for (var a2 = 0, s2 = Object.getOwnPropertySymbols(e2); a2 < s2.length; a2++)
              n2.indexOf(s2[a2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, s2[a2]) && (t2[s2[a2]] = e2[s2[a2]]);
          return t2;
        }
        __name(ND, "ND");
        function wD(e2, n2, t2, s2) {
          var a2 = arguments.length, r2 = a2 < 3 ? n2 : s2 === null ? s2 = Object.getOwnPropertyDescriptor(n2, t2) : s2, u2;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            r2 = Reflect.decorate(e2, n2, t2, s2);
          else
            for (var i2 = e2.length - 1; i2 >= 0; i2--)
              (u2 = e2[i2]) && (r2 = (a2 < 3 ? u2(r2) : a2 > 3 ? u2(n2, t2, r2) : u2(n2, t2)) || r2);
          return a2 > 3 && r2 && Object.defineProperty(n2, t2, r2), r2;
        }
        __name(wD, "wD");
        function _D(e2, n2) {
          return function(t2, s2) {
            n2(t2, s2, e2);
          };
        }
        __name(_D, "_D");
        function PD(e2, n2) {
          if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
            return Reflect.metadata(e2, n2);
        }
        __name(PD, "PD");
        function ID(e2, n2, t2, s2) {
          function a2(r2) {
            return r2 instanceof t2 ? r2 : new t2(function(u2) {
              u2(r2);
            });
          }
          __name(a2, "a");
          return new (t2 || (t2 = Promise))(function(r2, u2) {
            function i2(y2) {
              try {
                c2(s2.next(y2));
              } catch (h3) {
                u2(h3);
              }
            }
            __name(i2, "i");
            function l2(y2) {
              try {
                c2(s2.throw(y2));
              } catch (h3) {
                u2(h3);
              }
            }
            __name(l2, "l");
            function c2(y2) {
              y2.done ? r2(y2.value) : a2(y2.value).then(i2, l2);
            }
            __name(c2, "c");
            c2((s2 = s2.apply(e2, n2 || [])).next());
          });
        }
        __name(ID, "ID");
        function kD(e2, n2) {
          var t2 = { label: 0, sent: function() {
            if (r2[0] & 1)
              throw r2[1];
            return r2[1];
          }, trys: [], ops: [] }, s2, a2, r2, u2;
          return u2 = { next: i2(0), throw: i2(1), return: i2(2) }, typeof Symbol == "function" && (u2[Symbol.iterator] = function() {
            return this;
          }), u2;
          function i2(c2) {
            return function(y2) {
              return l2([c2, y2]);
            };
          }
          __name(i2, "i");
          function l2(c2) {
            if (s2)
              throw new TypeError("Generator is already executing.");
            for (; t2; )
              try {
                if (s2 = 1, a2 && (r2 = c2[0] & 2 ? a2.return : c2[0] ? a2.throw || ((r2 = a2.return) && r2.call(a2), 0) : a2.next) && !(r2 = r2.call(a2, c2[1])).done)
                  return r2;
                switch (a2 = 0, r2 && (c2 = [c2[0] & 2, r2.value]), c2[0]) {
                  case 0:
                  case 1:
                    r2 = c2;
                    break;
                  case 4:
                    return t2.label++, { value: c2[1], done: false };
                  case 5:
                    t2.label++, a2 = c2[1], c2 = [0];
                    continue;
                  case 7:
                    c2 = t2.ops.pop(), t2.trys.pop();
                    continue;
                  default:
                    if (r2 = t2.trys, !(r2 = r2.length > 0 && r2[r2.length - 1]) && (c2[0] === 6 || c2[0] === 2)) {
                      t2 = 0;
                      continue;
                    }
                    if (c2[0] === 3 && (!r2 || c2[1] > r2[0] && c2[1] < r2[3])) {
                      t2.label = c2[1];
                      break;
                    }
                    if (c2[0] === 6 && t2.label < r2[1]) {
                      t2.label = r2[1], r2 = c2;
                      break;
                    }
                    if (r2 && t2.label < r2[2]) {
                      t2.label = r2[2], t2.ops.push(c2);
                      break;
                    }
                    r2[2] && t2.ops.pop(), t2.trys.pop();
                    continue;
                }
                c2 = n2.call(e2, t2);
              } catch (y2) {
                c2 = [6, y2], a2 = 0;
              } finally {
                s2 = r2 = 0;
              }
            if (c2[0] & 5)
              throw c2[1];
            return { value: c2[0] ? c2[1] : void 0, done: true };
          }
          __name(l2, "l");
        }
        __name(kD, "kD");
        function LD(e2, n2, t2, s2) {
          s2 === void 0 && (s2 = t2), e2[s2] = n2[t2];
        }
        __name(LD, "LD");
        function jD(e2, n2) {
          for (var t2 in e2)
            t2 !== "default" && !n2.hasOwnProperty(t2) && (n2[t2] = e2[t2]);
        }
        __name(jD, "jD");
        function _n(e2) {
          var n2 = typeof Symbol == "function" && Symbol.iterator, t2 = n2 && e2[n2], s2 = 0;
          if (t2)
            return t2.call(e2);
          if (e2 && typeof e2.length == "number")
            return { next: function() {
              return e2 && s2 >= e2.length && (e2 = void 0), { value: e2 && e2[s2++], done: !e2 };
            } };
          throw new TypeError(n2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        __name(_n, "_n");
        function _a(e2, n2) {
          var t2 = typeof Symbol == "function" && e2[Symbol.iterator];
          if (!t2)
            return e2;
          var s2 = t2.call(e2), a2, r2 = [], u2;
          try {
            for (; (n2 === void 0 || n2-- > 0) && !(a2 = s2.next()).done; )
              r2.push(a2.value);
          } catch (i2) {
            u2 = { error: i2 };
          } finally {
            try {
              a2 && !a2.done && (t2 = s2.return) && t2.call(s2);
            } finally {
              if (u2)
                throw u2.error;
            }
          }
          return r2;
        }
        __name(_a, "_a");
        function OD() {
          for (var e2 = [], n2 = 0; n2 < arguments.length; n2++)
            e2 = e2.concat(_a(arguments[n2]));
          return e2;
        }
        __name(OD, "OD");
        function qD() {
          for (var e2 = 0, n2 = 0, t2 = arguments.length; n2 < t2; n2++)
            e2 += arguments[n2].length;
          for (var s2 = Array(e2), a2 = 0, n2 = 0; n2 < t2; n2++)
            for (var r2 = arguments[n2], u2 = 0, i2 = r2.length; u2 < i2; u2++, a2++)
              s2[a2] = r2[u2];
          return s2;
        }
        __name(qD, "qD");
        function Jt(e2) {
          return this instanceof Jt ? (this.v = e2, this) : new Jt(e2);
        }
        __name(Jt, "Jt");
        function MD(e2, n2, t2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var s2 = t2.apply(e2, n2 || []), a2, r2 = [];
          return a2 = {}, u2("next"), u2("throw"), u2("return"), a2[Symbol.asyncIterator] = function() {
            return this;
          }, a2;
          function u2(g2) {
            s2[g2] && (a2[g2] = function(p2) {
              return new Promise(function(D, v2) {
                r2.push([g2, p2, D, v2]) > 1 || i2(g2, p2);
              });
            });
          }
          __name(u2, "u");
          function i2(g2, p2) {
            try {
              l2(s2[g2](p2));
            } catch (D) {
              h3(r2[0][3], D);
            }
          }
          __name(i2, "i");
          function l2(g2) {
            g2.value instanceof Jt ? Promise.resolve(g2.value.v).then(c2, y2) : h3(r2[0][2], g2);
          }
          __name(l2, "l");
          function c2(g2) {
            i2("next", g2);
          }
          __name(c2, "c");
          function y2(g2) {
            i2("throw", g2);
          }
          __name(y2, "y");
          function h3(g2, p2) {
            g2(p2), r2.shift(), r2.length && i2(r2[0][0], r2[0][1]);
          }
          __name(h3, "h");
        }
        __name(MD, "MD");
        function RD(e2) {
          var n2, t2;
          return n2 = {}, s2("next"), s2("throw", function(a2) {
            throw a2;
          }), s2("return"), n2[Symbol.iterator] = function() {
            return this;
          }, n2;
          function s2(a2, r2) {
            n2[a2] = e2[a2] ? function(u2) {
              return (t2 = !t2) ? { value: Jt(e2[a2](u2)), done: a2 === "return" } : r2 ? r2(u2) : u2;
            } : r2;
          }
          __name(s2, "s");
        }
        __name(RD, "RD");
        function $D(e2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var n2 = e2[Symbol.asyncIterator], t2;
          return n2 ? n2.call(e2) : (e2 = typeof _n == "function" ? _n(e2) : e2[Symbol.iterator](), t2 = {}, s2("next"), s2("throw"), s2("return"), t2[Symbol.asyncIterator] = function() {
            return this;
          }, t2);
          function s2(r2) {
            t2[r2] = e2[r2] && function(u2) {
              return new Promise(function(i2, l2) {
                u2 = e2[r2](u2), a2(i2, l2, u2.done, u2.value);
              });
            };
          }
          __name(s2, "s");
          function a2(r2, u2, i2, l2) {
            Promise.resolve(l2).then(function(c2) {
              r2({ value: c2, done: i2 });
            }, u2);
          }
          __name(a2, "a");
        }
        __name($D, "$D");
        function VD(e2, n2) {
          return Object.defineProperty ? Object.defineProperty(e2, "raw", { value: n2 }) : e2.raw = n2, e2;
        }
        __name(VD, "VD");
        function WD(e2) {
          if (e2 && e2.__esModule)
            return e2;
          var n2 = {};
          if (e2 != null)
            for (var t2 in e2)
              Object.hasOwnProperty.call(e2, t2) && (n2[t2] = e2[t2]);
          return n2.default = e2, n2;
        }
        __name(WD, "WD");
        function HD(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        __name(HD, "HD");
        function GD(e2, n2) {
          if (!n2.has(e2))
            throw new TypeError("attempted to get private field on non-instance");
          return n2.get(e2);
        }
        __name(GD, "GD");
        function UD(e2, n2, t2) {
          if (!n2.has(e2))
            throw new TypeError("attempted to set private field on non-instance");
          return n2.set(e2, t2), t2;
        }
        __name(UD, "UD");
        var Tr, Br, Ct = gt({ "node_modules/tslib/tslib.es6.js"() {
          re(), Tr = /* @__PURE__ */ __name(function(e2, n2) {
            return Tr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t2, s2) {
              t2.__proto__ = s2;
            } || function(t2, s2) {
              for (var a2 in s2)
                s2.hasOwnProperty(a2) && (t2[a2] = s2[a2]);
            }, Tr(e2, n2);
          }, "Tr"), Br = /* @__PURE__ */ __name(function() {
            return Br = Object.assign || function(n2) {
              for (var t2, s2 = 1, a2 = arguments.length; s2 < a2; s2++) {
                t2 = arguments[s2];
                for (var r2 in t2)
                  Object.prototype.hasOwnProperty.call(t2, r2) && (n2[r2] = t2[r2]);
              }
              return n2;
            }, Br.apply(this, arguments);
          }, "Br");
        } }), Pa = ee({ "node_modules/vnopts/lib/descriptors/api.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true }), e2.apiDescriptor = { key: (n2) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n2) ? n2 : JSON.stringify(n2), value(n2) {
            if (n2 === null || typeof n2 != "object")
              return JSON.stringify(n2);
            if (Array.isArray(n2))
              return `[${n2.map((s2) => e2.apiDescriptor.value(s2)).join(", ")}]`;
            let t2 = Object.keys(n2);
            return t2.length === 0 ? "{}" : `{ ${t2.map((s2) => `${e2.apiDescriptor.key(s2)}: ${e2.apiDescriptor.value(n2[s2])}`).join(", ")} }`;
          }, pair: (n2) => {
            let { key: t2, value: s2 } = n2;
            return e2.apiDescriptor.value({ [t2]: s2 });
          } };
        } }), JD = ee({ "node_modules/vnopts/lib/descriptors/index.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = (Ct(), ft(yt));
          n2.__exportStar(Pa(), e2);
        } }), Ir = ee({ "scripts/build/shims/chalk.cjs"(e2, n2) {
          "use strict";
          re();
          var t2 = /* @__PURE__ */ __name((s2) => s2, "t");
          t2.grey = t2, t2.red = t2, t2.bold = t2, t2.yellow = t2, t2.blue = t2, t2.default = t2, n2.exports = t2;
        } }), Ia = ee({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Ir();
          e2.commonDeprecatedHandler = (t2, s2, a2) => {
            let { descriptor: r2 } = a2, u2 = [`${n2.default.yellow(typeof t2 == "string" ? r2.key(t2) : r2.pair(t2))} is deprecated`];
            return s2 && u2.push(`we now treat it as ${n2.default.blue(typeof s2 == "string" ? r2.key(s2) : r2.pair(s2))}`), u2.join("; ") + ".";
          };
        } }), zD = ee({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = (Ct(), ft(yt));
          n2.__exportStar(Ia(), e2);
        } }), XD = ee({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Ir();
          e2.commonInvalidHandler = (t2, s2, a2) => [`Invalid ${n2.default.red(a2.descriptor.key(t2))} value.`, `Expected ${n2.default.blue(a2.schemas[t2].expected(a2))},`, `but received ${n2.default.red(a2.descriptor.value(s2))}.`].join(" ");
        } }), ka = ee({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = (Ct(), ft(yt));
          n2.__exportStar(XD(), e2);
        } }), KD = ee({ "node_modules/vnopts/node_modules/leven/index.js"(e2, n2) {
          "use strict";
          re();
          var t2 = [], s2 = [];
          n2.exports = function(a2, r2) {
            if (a2 === r2)
              return 0;
            var u2 = a2;
            a2.length > r2.length && (a2 = r2, r2 = u2);
            var i2 = a2.length, l2 = r2.length;
            if (i2 === 0)
              return l2;
            if (l2 === 0)
              return i2;
            for (; i2 > 0 && a2.charCodeAt(~-i2) === r2.charCodeAt(~-l2); )
              i2--, l2--;
            if (i2 === 0)
              return l2;
            for (var c2 = 0; c2 < i2 && a2.charCodeAt(c2) === r2.charCodeAt(c2); )
              c2++;
            if (i2 -= c2, l2 -= c2, i2 === 0)
              return l2;
            for (var y2, h3, g2, p2, D = 0, v2 = 0; D < i2; )
              s2[c2 + D] = a2.charCodeAt(c2 + D), t2[D] = ++D;
            for (; v2 < l2; )
              for (y2 = r2.charCodeAt(c2 + v2), g2 = v2++, h3 = v2, D = 0; D < i2; D++)
                p2 = y2 === s2[c2 + D] ? g2 : g2 + 1, g2 = t2[D], h3 = t2[D] = g2 > h3 ? p2 > h3 ? h3 + 1 : p2 : p2 > g2 ? g2 + 1 : p2;
            return h3;
          };
        } }), La = ee({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Ir(), t2 = KD();
          e2.levenUnknownHandler = (s2, a2, r2) => {
            let { descriptor: u2, logger: i2, schemas: l2 } = r2, c2 = [`Ignored unknown option ${n2.default.yellow(u2.pair({ key: s2, value: a2 }))}.`], y2 = Object.keys(l2).sort().find((h3) => t2(s2, h3) < 3);
            y2 && c2.push(`Did you mean ${n2.default.blue(u2.key(y2))}?`), i2.warn(c2.join(" "));
          };
        } }), YD = ee({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = (Ct(), ft(yt));
          n2.__exportStar(La(), e2);
        } }), QD = ee({ "node_modules/vnopts/lib/handlers/index.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = (Ct(), ft(yt));
          n2.__exportStar(zD(), e2), n2.__exportStar(ka(), e2), n2.__exportStar(YD(), e2);
        } }), Et = ee({ "node_modules/vnopts/lib/schema.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
          function t2(r2, u2) {
            let i2 = new r2(u2), l2 = Object.create(i2);
            for (let c2 of n2)
              c2 in u2 && (l2[c2] = a2(u2[c2], i2, s2.prototype[c2].length));
            return l2;
          }
          __name(t2, "t");
          e2.createSchema = t2;
          var s2 = /* @__PURE__ */ __name(class {
            constructor(r2) {
              this.name = r2.name;
            }
            static create(r2) {
              return t2(this, r2);
            }
            default(r2) {
            }
            expected(r2) {
              return "nothing";
            }
            validate(r2, u2) {
              return false;
            }
            deprecated(r2, u2) {
              return false;
            }
            forward(r2, u2) {
            }
            redirect(r2, u2) {
            }
            overlap(r2, u2, i2) {
              return r2;
            }
            preprocess(r2, u2) {
              return r2;
            }
            postprocess(r2, u2) {
              return r2;
            }
          }, "s");
          e2.Schema = s2;
          function a2(r2, u2, i2) {
            return typeof r2 == "function" ? function() {
              for (var l2 = arguments.length, c2 = new Array(l2), y2 = 0; y2 < l2; y2++)
                c2[y2] = arguments[y2];
              return r2(...c2.slice(0, i2 - 1), u2, ...c2.slice(i2 - 1));
            } : () => r2;
          }
          __name(a2, "a");
        } }), ZD = ee({ "node_modules/vnopts/lib/schemas/alias.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Et(), t2 = /* @__PURE__ */ __name(class extends n2.Schema {
            constructor(s2) {
              super(s2), this._sourceName = s2.sourceName;
            }
            expected(s2) {
              return s2.schemas[this._sourceName].expected(s2);
            }
            validate(s2, a2) {
              return a2.schemas[this._sourceName].validate(s2, a2);
            }
            redirect(s2, a2) {
              return this._sourceName;
            }
          }, "t");
          e2.AliasSchema = t2;
        } }), em = ee({ "node_modules/vnopts/lib/schemas/any.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Et(), t2 = /* @__PURE__ */ __name(class extends n2.Schema {
            expected() {
              return "anything";
            }
            validate() {
              return true;
            }
          }, "t");
          e2.AnySchema = t2;
        } }), tm = ee({ "node_modules/vnopts/lib/schemas/array.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = (Ct(), ft(yt)), t2 = Et(), s2 = /* @__PURE__ */ __name(class extends t2.Schema {
            constructor(r2) {
              var { valueSchema: u2, name: i2 = u2.name } = r2, l2 = n2.__rest(r2, ["valueSchema", "name"]);
              super(Object.assign({}, l2, { name: i2 })), this._valueSchema = u2;
            }
            expected(r2) {
              return `an array of ${this._valueSchema.expected(r2)}`;
            }
            validate(r2, u2) {
              if (!Array.isArray(r2))
                return false;
              let i2 = [];
              for (let l2 of r2) {
                let c2 = u2.normalizeValidateResult(this._valueSchema.validate(l2, u2), l2);
                c2 !== true && i2.push(c2.value);
              }
              return i2.length === 0 ? true : { value: i2 };
            }
            deprecated(r2, u2) {
              let i2 = [];
              for (let l2 of r2) {
                let c2 = u2.normalizeDeprecatedResult(this._valueSchema.deprecated(l2, u2), l2);
                c2 !== false && i2.push(...c2.map((y2) => {
                  let { value: h3 } = y2;
                  return { value: [h3] };
                }));
              }
              return i2;
            }
            forward(r2, u2) {
              let i2 = [];
              for (let l2 of r2) {
                let c2 = u2.normalizeForwardResult(this._valueSchema.forward(l2, u2), l2);
                i2.push(...c2.map(a2));
              }
              return i2;
            }
            redirect(r2, u2) {
              let i2 = [], l2 = [];
              for (let c2 of r2) {
                let y2 = u2.normalizeRedirectResult(this._valueSchema.redirect(c2, u2), c2);
                "remain" in y2 && i2.push(y2.remain), l2.push(...y2.redirect.map(a2));
              }
              return i2.length === 0 ? { redirect: l2 } : { redirect: l2, remain: i2 };
            }
            overlap(r2, u2) {
              return r2.concat(u2);
            }
          }, "s");
          e2.ArraySchema = s2;
          function a2(r2) {
            let { from: u2, to: i2 } = r2;
            return { from: [u2], to: i2 };
          }
          __name(a2, "a");
        } }), rm = ee({ "node_modules/vnopts/lib/schemas/boolean.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Et(), t2 = /* @__PURE__ */ __name(class extends n2.Schema {
            expected() {
              return "true or false";
            }
            validate(s2) {
              return typeof s2 == "boolean";
            }
          }, "t");
          e2.BooleanSchema = t2;
        } }), Gn = ee({ "node_modules/vnopts/lib/utils.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          function n2(p2, D) {
            let v2 = /* @__PURE__ */ Object.create(null);
            for (let w2 of p2) {
              let T2 = w2[D];
              if (v2[T2])
                throw new Error(`Duplicate ${D} ${JSON.stringify(T2)}`);
              v2[T2] = w2;
            }
            return v2;
          }
          __name(n2, "n");
          e2.recordFromArray = n2;
          function t2(p2, D) {
            let v2 = /* @__PURE__ */ new Map();
            for (let w2 of p2) {
              let T2 = w2[D];
              if (v2.has(T2))
                throw new Error(`Duplicate ${D} ${JSON.stringify(T2)}`);
              v2.set(T2, w2);
            }
            return v2;
          }
          __name(t2, "t");
          e2.mapFromArray = t2;
          function s2() {
            let p2 = /* @__PURE__ */ Object.create(null);
            return (D) => {
              let v2 = JSON.stringify(D);
              return p2[v2] ? true : (p2[v2] = true, false);
            };
          }
          __name(s2, "s");
          e2.createAutoChecklist = s2;
          function a2(p2, D) {
            let v2 = [], w2 = [];
            for (let T2 of p2)
              D(T2) ? v2.push(T2) : w2.push(T2);
            return [v2, w2];
          }
          __name(a2, "a");
          e2.partition = a2;
          function r2(p2) {
            return p2 === Math.floor(p2);
          }
          __name(r2, "r");
          e2.isInt = r2;
          function u2(p2, D) {
            if (p2 === D)
              return 0;
            let v2 = typeof p2, w2 = typeof D, T2 = ["undefined", "object", "boolean", "number", "string"];
            return v2 !== w2 ? T2.indexOf(v2) - T2.indexOf(w2) : v2 !== "string" ? Number(p2) - Number(D) : p2.localeCompare(D);
          }
          __name(u2, "u");
          e2.comparePrimitive = u2;
          function i2(p2) {
            return p2 === void 0 ? {} : p2;
          }
          __name(i2, "i");
          e2.normalizeDefaultResult = i2;
          function l2(p2, D) {
            return p2 === true ? true : p2 === false ? { value: D } : p2;
          }
          __name(l2, "l");
          e2.normalizeValidateResult = l2;
          function c2(p2, D) {
            let v2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            return p2 === false ? false : p2 === true ? v2 ? true : [{ value: D }] : "value" in p2 ? [p2] : p2.length === 0 ? false : p2;
          }
          __name(c2, "c");
          e2.normalizeDeprecatedResult = c2;
          function y2(p2, D) {
            return typeof p2 == "string" || "key" in p2 ? { from: D, to: p2 } : "from" in p2 ? { from: p2.from, to: p2.to } : { from: D, to: p2.to };
          }
          __name(y2, "y");
          e2.normalizeTransferResult = y2;
          function h3(p2, D) {
            return p2 === void 0 ? [] : Array.isArray(p2) ? p2.map((v2) => y2(v2, D)) : [y2(p2, D)];
          }
          __name(h3, "h");
          e2.normalizeForwardResult = h3;
          function g2(p2, D) {
            let v2 = h3(typeof p2 == "object" && "redirect" in p2 ? p2.redirect : p2, D);
            return v2.length === 0 ? { remain: D, redirect: v2 } : typeof p2 == "object" && "remain" in p2 ? { remain: p2.remain, redirect: v2 } : { redirect: v2 };
          }
          __name(g2, "g");
          e2.normalizeRedirectResult = g2;
        } }), nm = ee({ "node_modules/vnopts/lib/schemas/choice.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Et(), t2 = Gn(), s2 = /* @__PURE__ */ __name(class extends n2.Schema {
            constructor(a2) {
              super(a2), this._choices = t2.mapFromArray(a2.choices.map((r2) => r2 && typeof r2 == "object" ? r2 : { value: r2 }), "value");
            }
            expected(a2) {
              let { descriptor: r2 } = a2, u2 = Array.from(this._choices.keys()).map((c2) => this._choices.get(c2)).filter((c2) => !c2.deprecated).map((c2) => c2.value).sort(t2.comparePrimitive).map(r2.value), i2 = u2.slice(0, -2), l2 = u2.slice(-2);
              return i2.concat(l2.join(" or ")).join(", ");
            }
            validate(a2) {
              return this._choices.has(a2);
            }
            deprecated(a2) {
              let r2 = this._choices.get(a2);
              return r2 && r2.deprecated ? { value: a2 } : false;
            }
            forward(a2) {
              let r2 = this._choices.get(a2);
              return r2 ? r2.forward : void 0;
            }
            redirect(a2) {
              let r2 = this._choices.get(a2);
              return r2 ? r2.redirect : void 0;
            }
          }, "s");
          e2.ChoiceSchema = s2;
        } }), ja = ee({ "node_modules/vnopts/lib/schemas/number.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Et(), t2 = /* @__PURE__ */ __name(class extends n2.Schema {
            expected() {
              return "a number";
            }
            validate(s2, a2) {
              return typeof s2 == "number";
            }
          }, "t");
          e2.NumberSchema = t2;
        } }), um = ee({ "node_modules/vnopts/lib/schemas/integer.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Gn(), t2 = ja(), s2 = /* @__PURE__ */ __name(class extends t2.NumberSchema {
            expected() {
              return "an integer";
            }
            validate(a2, r2) {
              return r2.normalizeValidateResult(super.validate(a2, r2), a2) === true && n2.isInt(a2);
            }
          }, "s");
          e2.IntegerSchema = s2;
        } }), sm = ee({ "node_modules/vnopts/lib/schemas/string.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Et(), t2 = /* @__PURE__ */ __name(class extends n2.Schema {
            expected() {
              return "a string";
            }
            validate(s2) {
              return typeof s2 == "string";
            }
          }, "t");
          e2.StringSchema = t2;
        } }), im = ee({ "node_modules/vnopts/lib/schemas/index.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = (Ct(), ft(yt));
          n2.__exportStar(ZD(), e2), n2.__exportStar(em(), e2), n2.__exportStar(tm(), e2), n2.__exportStar(rm(), e2), n2.__exportStar(nm(), e2), n2.__exportStar(um(), e2), n2.__exportStar(ja(), e2), n2.__exportStar(sm(), e2);
        } }), am = ee({ "node_modules/vnopts/lib/defaults.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Pa(), t2 = Ia(), s2 = ka(), a2 = La();
          e2.defaultDescriptor = n2.apiDescriptor, e2.defaultUnknownHandler = a2.levenUnknownHandler, e2.defaultInvalidHandler = s2.commonInvalidHandler, e2.defaultDeprecatedHandler = t2.commonDeprecatedHandler;
        } }), om = ee({ "node_modules/vnopts/lib/normalize.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = am(), t2 = Gn();
          e2.normalize = (a2, r2, u2) => new s2(r2, u2).normalize(a2);
          var s2 = /* @__PURE__ */ __name(class {
            constructor(a2, r2) {
              let { logger: u2 = console, descriptor: i2 = n2.defaultDescriptor, unknown: l2 = n2.defaultUnknownHandler, invalid: c2 = n2.defaultInvalidHandler, deprecated: y2 = n2.defaultDeprecatedHandler } = r2 || {};
              this._utils = { descriptor: i2, logger: u2 || { warn: () => {
              } }, schemas: t2.recordFromArray(a2, "name"), normalizeDefaultResult: t2.normalizeDefaultResult, normalizeDeprecatedResult: t2.normalizeDeprecatedResult, normalizeForwardResult: t2.normalizeForwardResult, normalizeRedirectResult: t2.normalizeRedirectResult, normalizeValidateResult: t2.normalizeValidateResult }, this._unknownHandler = l2, this._invalidHandler = c2, this._deprecatedHandler = y2, this.cleanHistory();
            }
            cleanHistory() {
              this._hasDeprecationWarned = t2.createAutoChecklist();
            }
            normalize(a2) {
              let r2 = {}, u2 = [a2], i2 = /* @__PURE__ */ __name(() => {
                for (; u2.length !== 0; ) {
                  let l2 = u2.shift(), c2 = this._applyNormalization(l2, r2);
                  u2.push(...c2);
                }
              }, "i");
              i2();
              for (let l2 of Object.keys(this._utils.schemas)) {
                let c2 = this._utils.schemas[l2];
                if (!(l2 in r2)) {
                  let y2 = t2.normalizeDefaultResult(c2.default(this._utils));
                  "value" in y2 && u2.push({ [l2]: y2.value });
                }
              }
              i2();
              for (let l2 of Object.keys(this._utils.schemas)) {
                let c2 = this._utils.schemas[l2];
                l2 in r2 && (r2[l2] = c2.postprocess(r2[l2], this._utils));
              }
              return r2;
            }
            _applyNormalization(a2, r2) {
              let u2 = [], [i2, l2] = t2.partition(Object.keys(a2), (c2) => c2 in this._utils.schemas);
              for (let c2 of i2) {
                let y2 = this._utils.schemas[c2], h3 = y2.preprocess(a2[c2], this._utils), g2 = t2.normalizeValidateResult(y2.validate(h3, this._utils), h3);
                if (g2 !== true) {
                  let { value: T2 } = g2, F = this._invalidHandler(c2, T2, this._utils);
                  throw typeof F == "string" ? new Error(F) : F;
                }
                let p2 = /* @__PURE__ */ __name((T2) => {
                  let { from: F, to: A2 } = T2;
                  u2.push(typeof A2 == "string" ? { [A2]: F } : { [A2.key]: A2.value });
                }, "p"), D = /* @__PURE__ */ __name((T2) => {
                  let { value: F, redirectTo: A2 } = T2, B = t2.normalizeDeprecatedResult(y2.deprecated(F, this._utils), h3, true);
                  if (B !== false)
                    if (B === true)
                      this._hasDeprecationWarned(c2) || this._utils.logger.warn(this._deprecatedHandler(c2, A2, this._utils));
                    else
                      for (let { value: I } of B) {
                        let P2 = { key: c2, value: I };
                        if (!this._hasDeprecationWarned(P2)) {
                          let R2 = typeof A2 == "string" ? { key: A2, value: I } : A2;
                          this._utils.logger.warn(this._deprecatedHandler(P2, R2, this._utils));
                        }
                      }
                }, "D");
                t2.normalizeForwardResult(y2.forward(h3, this._utils), h3).forEach(p2);
                let w2 = t2.normalizeRedirectResult(y2.redirect(h3, this._utils), h3);
                if (w2.redirect.forEach(p2), "remain" in w2) {
                  let T2 = w2.remain;
                  r2[c2] = c2 in r2 ? y2.overlap(r2[c2], T2, this._utils) : T2, D({ value: T2 });
                }
                for (let { from: T2, to: F } of w2.redirect)
                  D({ value: T2, redirectTo: F });
              }
              for (let c2 of l2) {
                let y2 = a2[c2], h3 = this._unknownHandler(c2, y2, this._utils);
                if (h3)
                  for (let g2 of Object.keys(h3)) {
                    let p2 = { [g2]: h3[g2] };
                    g2 in this._utils.schemas ? u2.push(p2) : Object.assign(r2, p2);
                  }
              }
              return u2;
            }
          }, "s");
          e2.Normalizer = s2;
        } }), lm = ee({ "node_modules/vnopts/lib/index.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = (Ct(), ft(yt));
          n2.__exportStar(JD(), e2), n2.__exportStar(QD(), e2), n2.__exportStar(im(), e2), n2.__exportStar(om(), e2), n2.__exportStar(Et(), e2);
        } }), cm = ee({ "src/main/options-normalizer.js"(e2, n2) {
          "use strict";
          re();
          var t2 = lm(), s2 = lt(), a2 = { key: (g2) => g2.length === 1 ? `-${g2}` : `--${g2}`, value: (g2) => t2.apiDescriptor.value(g2), pair: (g2) => {
            let { key: p2, value: D } = g2;
            return D === false ? `--no-${p2}` : D === true ? a2.key(p2) : D === "" ? `${a2.key(p2)} without an argument` : `${a2.key(p2)}=${D}`;
          } }, r2 = /* @__PURE__ */ __name((g2) => {
            let { colorsModule: p2, levenshteinDistance: D } = g2;
            return class extends t2.ChoiceSchema {
              constructor(w2) {
                let { name: T2, flags: F } = w2;
                super({ name: T2, choices: F }), this._flags = [...F].sort();
              }
              preprocess(w2, T2) {
                if (typeof w2 == "string" && w2.length > 0 && !this._flags.includes(w2)) {
                  let F = this._flags.find((A2) => D(A2, w2) < 3);
                  if (F)
                    return T2.logger.warn([`Unknown flag ${p2.yellow(T2.descriptor.value(w2))},`, `did you mean ${p2.blue(T2.descriptor.value(F))}?`].join(" ")), F;
                }
                return w2;
              }
              expected() {
                return "a flag";
              }
            };
          }, "r"), u2;
          function i2(g2, p2) {
            let { logger: D = false, isCLI: v2 = false, passThrough: w2 = false, colorsModule: T2 = null, levenshteinDistance: F = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, A2 = w2 ? Array.isArray(w2) ? (x2, m2) => w2.includes(x2) ? { [x2]: m2 } : void 0 : (x2, m2) => ({ [x2]: m2 }) : (x2, m2, E2) => {
              let o2 = E2.schemas, { _: d2 } = o2, C2 = Ln(o2, Jf);
              return t2.levenUnknownHandler(x2, m2, Object.assign(Object.assign({}, E2), {}, { schemas: C2 }));
            }, B = v2 ? a2 : t2.apiDescriptor, I = l2(p2, { isCLI: v2, colorsModule: T2, levenshteinDistance: F }), P2 = new t2.Normalizer(I, { logger: D, unknown: A2, descriptor: B }), R2 = D !== false;
            R2 && u2 && (P2._hasDeprecationWarned = u2);
            let f2 = P2.normalize(g2);
            return R2 && (u2 = P2._hasDeprecationWarned), v2 && f2["plugin-search"] === false && (f2["plugin-search-dir"] = false), f2;
          }
          __name(i2, "i");
          function l2(g2, p2) {
            let { isCLI: D, colorsModule: v2, levenshteinDistance: w2 } = p2, T2 = [];
            D && T2.push(t2.AnySchema.create({ name: "_" }));
            for (let F of g2)
              T2.push(c2(F, { isCLI: D, optionInfos: g2, colorsModule: v2, levenshteinDistance: w2 })), F.alias && D && T2.push(t2.AliasSchema.create({ name: F.alias, sourceName: F.name }));
            return T2;
          }
          __name(l2, "l");
          function c2(g2, p2) {
            let { isCLI: D, optionInfos: v2, colorsModule: w2, levenshteinDistance: T2 } = p2, { name: F } = g2;
            if (F === "plugin-search-dir" || F === "pluginSearchDirs")
              return t2.AnySchema.create({ name: F, preprocess(P2) {
                return P2 === false || (P2 = Array.isArray(P2) ? P2 : [P2]), P2;
              }, validate(P2) {
                return P2 === false ? true : P2.every((R2) => typeof R2 == "string");
              }, expected() {
                return "false or paths to plugin search dir";
              } });
            let A2 = { name: F }, B, I = {};
            switch (g2.type) {
              case "int":
                B = t2.IntegerSchema, D && (A2.preprocess = Number);
                break;
              case "string":
                B = t2.StringSchema;
                break;
              case "choice":
                B = t2.ChoiceSchema, A2.choices = g2.choices.map((P2) => typeof P2 == "object" && P2.redirect ? Object.assign(Object.assign({}, P2), {}, { redirect: { to: { key: g2.name, value: P2.redirect } } }) : P2);
                break;
              case "boolean":
                B = t2.BooleanSchema;
                break;
              case "flag":
                B = r2({ colorsModule: w2, levenshteinDistance: T2 }), A2.flags = v2.flatMap((P2) => [P2.alias, P2.description && P2.name, P2.oppositeDescription && `no-${P2.name}`].filter(Boolean));
                break;
              case "path":
                B = t2.StringSchema;
                break;
              default:
                throw new Error(`Unexpected type ${g2.type}`);
            }
            if (g2.exception ? A2.validate = (P2, R2, f2) => g2.exception(P2) || R2.validate(P2, f2) : A2.validate = (P2, R2, f2) => P2 === void 0 || R2.validate(P2, f2), g2.redirect && (I.redirect = (P2) => P2 ? { to: { key: g2.redirect.option, value: g2.redirect.value } } : void 0), g2.deprecated && (I.deprecated = true), D && !g2.array) {
              let P2 = A2.preprocess || ((R2) => R2);
              A2.preprocess = (R2, f2, x2) => f2.preprocess(P2(Array.isArray(R2) ? s2(R2) : R2), x2);
            }
            return g2.array ? t2.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, D ? { preprocess: (P2) => Array.isArray(P2) ? P2 : [P2] } : {}), I), {}, { valueSchema: B.create(A2) })) : B.create(Object.assign(Object.assign({}, A2), I));
          }
          __name(c2, "c");
          function y2(g2, p2, D) {
            return i2(g2, p2, D);
          }
          __name(y2, "y");
          function h3(g2, p2, D) {
            return i2(g2, p2, Object.assign({ isCLI: true }, D));
          }
          __name(h3, "h");
          n2.exports = { normalizeApiOptions: y2, normalizeCliOptions: h3 };
        } }), it = ee({ "src/language-js/loc.js"(e2, n2) {
          "use strict";
          re();
          var t2 = $n();
          function s2(l2) {
            var c2, y2;
            let h3 = l2.range ? l2.range[0] : l2.start, g2 = (c2 = (y2 = l2.declaration) === null || y2 === void 0 ? void 0 : y2.decorators) !== null && c2 !== void 0 ? c2 : l2.decorators;
            return t2(g2) ? Math.min(s2(g2[0]), h3) : h3;
          }
          __name(s2, "s");
          function a2(l2) {
            return l2.range ? l2.range[1] : l2.end;
          }
          __name(a2, "a");
          function r2(l2, c2) {
            let y2 = s2(l2);
            return Number.isInteger(y2) && y2 === s2(c2);
          }
          __name(r2, "r");
          function u2(l2, c2) {
            let y2 = a2(l2);
            return Number.isInteger(y2) && y2 === a2(c2);
          }
          __name(u2, "u");
          function i2(l2, c2) {
            return r2(l2, c2) && u2(l2, c2);
          }
          __name(i2, "i");
          n2.exports = { locStart: s2, locEnd: a2, hasSameLocStart: r2, hasSameLoc: i2 };
        } }), pm = ee({ "src/main/load-parser.js"(e2, n2) {
          re(), n2.exports = () => {
          };
        } }), fm = ee({ "scripts/build/shims/babel-highlight.cjs"(e2, n2) {
          "use strict";
          re();
          var t2 = Ir(), s2 = { shouldHighlight: () => false, getChalk: () => t2 };
          n2.exports = s2;
        } }), Dm = ee({ "node_modules/@babel/code-frame/lib/index.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true }), e2.codeFrameColumns = u2, e2.default = i2;
          var n2 = fm(), t2 = false;
          function s2(l2) {
            return { gutter: l2.grey, marker: l2.red.bold, message: l2.red.bold };
          }
          __name(s2, "s");
          var a2 = /\r\n|[\n\r\u2028\u2029]/;
          function r2(l2, c2, y2) {
            let h3 = Object.assign({ column: 0, line: -1 }, l2.start), g2 = Object.assign({}, h3, l2.end), { linesAbove: p2 = 2, linesBelow: D = 3 } = y2 || {}, v2 = h3.line, w2 = h3.column, T2 = g2.line, F = g2.column, A2 = Math.max(v2 - (p2 + 1), 0), B = Math.min(c2.length, T2 + D);
            v2 === -1 && (A2 = 0), T2 === -1 && (B = c2.length);
            let I = T2 - v2, P2 = {};
            if (I)
              for (let R2 = 0; R2 <= I; R2++) {
                let f2 = R2 + v2;
                if (!w2)
                  P2[f2] = true;
                else if (R2 === 0) {
                  let x2 = c2[f2 - 1].length;
                  P2[f2] = [w2, x2 - w2 + 1];
                } else if (R2 === I)
                  P2[f2] = [0, F];
                else {
                  let x2 = c2[f2 - R2].length;
                  P2[f2] = [0, x2];
                }
              }
            else
              w2 === F ? w2 ? P2[v2] = [w2, 0] : P2[v2] = true : P2[v2] = [w2, F - w2];
            return { start: A2, end: B, markerLines: P2 };
          }
          __name(r2, "r");
          function u2(l2, c2) {
            let y2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h3 = (y2.highlightCode || y2.forceColor) && (0, n2.shouldHighlight)(y2), g2 = (0, n2.getChalk)(y2), p2 = s2(g2), D = /* @__PURE__ */ __name((R2, f2) => h3 ? R2(f2) : f2, "D"), v2 = l2.split(a2), { start: w2, end: T2, markerLines: F } = r2(c2, v2, y2), A2 = c2.start && typeof c2.start.column == "number", B = String(T2).length, P2 = (h3 ? (0, n2.default)(l2, y2) : l2).split(a2, T2).slice(w2, T2).map((R2, f2) => {
              let x2 = w2 + 1 + f2, E2 = ` ${` ${x2}`.slice(-B)} |`, o2 = F[x2], d2 = !F[x2 + 1];
              if (o2) {
                let C2 = "";
                if (Array.isArray(o2)) {
                  let _2 = R2.slice(0, Math.max(o2[0] - 1, 0)).replace(/[^\t]/g, " "), b2 = o2[1] || 1;
                  C2 = [`
 `, D(p2.gutter, E2.replace(/\d/g, " ")), " ", _2, D(p2.marker, "^").repeat(b2)].join(""), d2 && y2.message && (C2 += " " + D(p2.message, y2.message));
                }
                return [D(p2.marker, ">"), D(p2.gutter, E2), R2.length > 0 ? ` ${R2}` : "", C2].join("");
              } else
                return ` ${D(p2.gutter, E2)}${R2.length > 0 ? ` ${R2}` : ""}`;
            }).join(`
`);
            return y2.message && !A2 && (P2 = `${" ".repeat(B + 1)}${y2.message}
${P2}`), h3 ? g2.reset(P2) : P2;
          }
          __name(u2, "u");
          function i2(l2, c2, y2) {
            let h3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            if (!t2) {
              t2 = true;
              let p2 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
              if (Nt.emitWarning)
                Nt.emitWarning(p2, "DeprecationWarning");
              else {
                let D = new Error(p2);
                D.name = "DeprecationWarning", console.warn(new Error(p2));
              }
            }
            return y2 = Math.max(y2, 0), u2(l2, { start: { column: y2, line: c2 } }, h3);
          }
          __name(i2, "i");
        } }), Un = ee({ "src/main/parser.js"(e2, n2) {
          "use strict";
          re();
          var { ConfigError: t2 } = Kt(), s2 = it(), a2 = pm(), { locStart: r2, locEnd: u2 } = s2, i2 = Object.getOwnPropertyNames, l2 = Object.getOwnPropertyDescriptor;
          function c2(g2) {
            let p2 = {};
            for (let D of g2.plugins)
              if (!!D.parsers)
                for (let v2 of i2(D.parsers))
                  Object.defineProperty(p2, v2, l2(D.parsers, v2));
            return p2;
          }
          __name(c2, "c");
          function y2(g2) {
            let p2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c2(g2);
            if (typeof g2.parser == "function")
              return { parse: g2.parser, astFormat: "estree", locStart: r2, locEnd: u2 };
            if (typeof g2.parser == "string") {
              if (Object.prototype.hasOwnProperty.call(p2, g2.parser))
                return p2[g2.parser];
              throw new t2(`Couldn't resolve parser "${g2.parser}". Parsers must be explicitly added to the standalone bundle.`);
            }
          }
          __name(y2, "y");
          function h3(g2, p2) {
            let D = c2(p2), v2 = Object.defineProperties({}, Object.fromEntries(Object.keys(D).map((T2) => [T2, { enumerable: true, get() {
              return D[T2].parse;
            } }]))), w2 = y2(p2, D);
            try {
              return w2.preprocess && (g2 = w2.preprocess(g2, p2)), { text: g2, ast: w2.parse(g2, v2, p2) };
            } catch (T2) {
              let { loc: F } = T2;
              if (F) {
                let { codeFrameColumns: A2 } = Dm();
                throw T2.codeFrame = A2(g2, F, { highlightCode: true }), T2.message += `
` + T2.codeFrame, T2;
              }
              throw T2;
            }
          }
          __name(h3, "h");
          n2.exports = { parse: h3, resolveParser: y2 };
        } }), Oa = ee({ "src/main/options.js"(e2, n2) {
          "use strict";
          re();
          var t2 = TD(), { UndefinedParserError: s2 } = Kt(), { getSupportInfo: a2 } = Rn(), r2 = cm(), { resolveParser: u2 } = Un(), i2 = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
          function l2(h3) {
            let g2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p2 = Object.assign({}, h3), D = a2({ plugins: h3.plugins, showUnreleased: true, showDeprecated: true }).options, v2 = Object.assign(Object.assign({}, i2), Object.fromEntries(D.filter((B) => B.default !== void 0).map((B) => [B.name, B.default])));
            if (!p2.parser) {
              if (!p2.filepath)
                (g2.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), p2.parser = "babel";
              else if (p2.parser = y2(p2.filepath, p2.plugins), !p2.parser)
                throw new s2(`No parser could be inferred for file: ${p2.filepath}`);
            }
            let w2 = u2(r2.normalizeApiOptions(p2, [D.find((B) => B.name === "parser")], { passThrough: true, logger: false }));
            p2.astFormat = w2.astFormat, p2.locEnd = w2.locEnd, p2.locStart = w2.locStart;
            let T2 = c2(p2);
            p2.printer = T2.printers[p2.astFormat];
            let F = Object.fromEntries(D.filter((B) => B.pluginDefaults && B.pluginDefaults[T2.name] !== void 0).map((B) => [B.name, B.pluginDefaults[T2.name]])), A2 = Object.assign(Object.assign({}, v2), F);
            for (let [B, I] of Object.entries(A2))
              (p2[B] === null || p2[B] === void 0) && (p2[B] = I);
            return p2.parser === "json" && (p2.trailingComma = "none"), r2.normalizeApiOptions(p2, D, Object.assign({ passThrough: Object.keys(i2) }, g2));
          }
          __name(l2, "l");
          function c2(h3) {
            let { astFormat: g2 } = h3;
            if (!g2)
              throw new Error("getPlugin() requires astFormat to be set");
            let p2 = h3.plugins.find((D) => D.printers && D.printers[g2]);
            if (!p2)
              throw new Error(`Couldn't find plugin for AST format "${g2}"`);
            return p2;
          }
          __name(c2, "c");
          function y2(h3, g2) {
            let p2 = t2.basename(h3).toLowerCase(), v2 = a2({ plugins: g2 }).languages.filter((w2) => w2.since !== null).find((w2) => w2.extensions && w2.extensions.some((T2) => p2.endsWith(T2)) || w2.filenames && w2.filenames.some((T2) => T2.toLowerCase() === p2));
            return v2 && v2.parsers[0];
          }
          __name(y2, "y");
          n2.exports = { normalize: l2, hiddenDefaults: i2, inferParser: y2 };
        } }), mm = ee({ "src/main/massage-ast.js"(e2, n2) {
          "use strict";
          re();
          function t2(s2, a2, r2) {
            if (Array.isArray(s2))
              return s2.map((c2) => t2(c2, a2, r2)).filter(Boolean);
            if (!s2 || typeof s2 != "object")
              return s2;
            let u2 = a2.printer.massageAstNode, i2;
            u2 && u2.ignoredProperties ? i2 = u2.ignoredProperties : i2 = /* @__PURE__ */ new Set();
            let l2 = {};
            for (let [c2, y2] of Object.entries(s2))
              !i2.has(c2) && typeof y2 != "function" && (l2[c2] = t2(y2, a2, s2));
            if (u2) {
              let c2 = u2(s2, l2, r2);
              if (c2 === null)
                return;
              if (c2)
                return c2;
            }
            return l2;
          }
          __name(t2, "t");
          n2.exports = t2;
        } }), Yt = ee({ "scripts/build/shims/assert.cjs"(e2, n2) {
          "use strict";
          re();
          var t2 = /* @__PURE__ */ __name(() => {
          }, "t");
          t2.ok = t2, t2.strictEqual = t2, n2.exports = t2;
        } }), et = ee({ "src/main/comments.js"(e2, n2) {
          "use strict";
          re();
          var t2 = Yt(), { builders: { line: s2, hardline: a2, breakParent: r2, indent: u2, lineSuffix: i2, join: l2, cursor: c2 } } = qe(), { hasNewline: y2, skipNewline: h3, skipSpaces: g2, isPreviousLineEmpty: p2, addLeadingComment: D, addDanglingComment: v2, addTrailingComment: w2 } = Ge(), T2 = /* @__PURE__ */ new WeakMap();
          function F(k2, $, M2) {
            if (!k2)
              return;
            let { printer: q, locStart: J, locEnd: L2 } = $;
            if (M2) {
              if (q.canAttachComment && q.canAttachComment(k2)) {
                let V;
                for (V = M2.length - 1; V >= 0 && !(J(M2[V]) <= J(k2) && L2(M2[V]) <= L2(k2)); --V)
                  ;
                M2.splice(V + 1, 0, k2);
                return;
              }
            } else if (T2.has(k2))
              return T2.get(k2);
            let Y = q.getCommentChildNodes && q.getCommentChildNodes(k2, $) || typeof k2 == "object" && Object.entries(k2).filter((V) => {
              let [O2] = V;
              return O2 !== "enclosingNode" && O2 !== "precedingNode" && O2 !== "followingNode" && O2 !== "tokens" && O2 !== "comments" && O2 !== "parent";
            }).map((V) => {
              let [, O2] = V;
              return O2;
            });
            if (!!Y) {
              M2 || (M2 = [], T2.set(k2, M2));
              for (let V of Y)
                F(V, $, M2);
              return M2;
            }
          }
          __name(F, "F");
          function A2(k2, $, M2, q) {
            let { locStart: J, locEnd: L2 } = M2, Y = J($), V = L2($), O2 = F(k2, M2), K, se, Q = 0, le = O2.length;
            for (; Q < le; ) {
              let W2 = Q + le >> 1, X = O2[W2], oe = J(X), ae = L2(X);
              if (oe <= Y && V <= ae)
                return A2(X, $, M2, X);
              if (ae <= Y) {
                K = X, Q = W2 + 1;
                continue;
              }
              if (V <= oe) {
                se = X, le = W2;
                continue;
              }
              throw new Error("Comment location overlaps with node location");
            }
            if (q && q.type === "TemplateLiteral") {
              let { quasis: W2 } = q, X = E2(W2, $, M2);
              K && E2(W2, K, M2) !== X && (K = null), se && E2(W2, se, M2) !== X && (se = null);
            }
            return { enclosingNode: q, precedingNode: K, followingNode: se };
          }
          __name(A2, "A");
          var B = /* @__PURE__ */ __name(() => false, "B");
          function I(k2, $, M2, q) {
            if (!Array.isArray(k2))
              return;
            let J = [], { locStart: L2, locEnd: Y, printer: { handleComments: V = {} } } = q, { avoidAstMutation: O2, ownLine: K = B, endOfLine: se = B, remaining: Q = B } = V, le = k2.map((W2, X) => Object.assign(Object.assign({}, A2($, W2, q)), {}, { comment: W2, text: M2, options: q, ast: $, isLastComment: k2.length - 1 === X }));
            for (let [W2, X] of le.entries()) {
              let { comment: oe, precedingNode: ae, enclosingNode: Ae, followingNode: z, text: H, options: Z, ast: ne, isLastComment: fe } = X;
              if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
                if (L2(oe) - L2(ne) <= 0) {
                  D(ne, oe);
                  continue;
                }
                if (Y(oe) - Y(ne) >= 0) {
                  w2(ne, oe);
                  continue;
                }
              }
              let ge;
              if (O2 ? ge = [X] : (oe.enclosingNode = Ae, oe.precedingNode = ae, oe.followingNode = z, ge = [oe, H, Z, ne, fe]), R2(H, Z, le, W2))
                oe.placement = "ownLine", K(...ge) || (z ? D(z, oe) : ae ? w2(ae, oe) : v2(Ae || ne, oe));
              else if (f2(H, Z, le, W2))
                oe.placement = "endOfLine", se(...ge) || (ae ? w2(ae, oe) : z ? D(z, oe) : v2(Ae || ne, oe));
              else if (oe.placement = "remaining", !Q(...ge))
                if (ae && z) {
                  let Ce = J.length;
                  Ce > 0 && J[Ce - 1].followingNode !== z && x2(J, H, Z), J.push(X);
                } else
                  ae ? w2(ae, oe) : z ? D(z, oe) : v2(Ae || ne, oe);
            }
            if (x2(J, M2, q), !O2)
              for (let W2 of k2)
                delete W2.precedingNode, delete W2.enclosingNode, delete W2.followingNode;
          }
          __name(I, "I");
          var P2 = /* @__PURE__ */ __name((k2) => !/[\S\n\u2028\u2029]/.test(k2), "P");
          function R2(k2, $, M2, q) {
            let { comment: J, precedingNode: L2 } = M2[q], { locStart: Y, locEnd: V } = $, O2 = Y(J);
            if (L2)
              for (let K = q - 1; K >= 0; K--) {
                let { comment: se, precedingNode: Q } = M2[K];
                if (Q !== L2 || !P2(k2.slice(V(se), O2)))
                  break;
                O2 = Y(se);
              }
            return y2(k2, O2, { backwards: true });
          }
          __name(R2, "R");
          function f2(k2, $, M2, q) {
            let { comment: J, followingNode: L2 } = M2[q], { locStart: Y, locEnd: V } = $, O2 = V(J);
            if (L2)
              for (let K = q + 1; K < M2.length; K++) {
                let { comment: se, followingNode: Q } = M2[K];
                if (Q !== L2 || !P2(k2.slice(O2, Y(se))))
                  break;
                O2 = V(se);
              }
            return y2(k2, O2);
          }
          __name(f2, "f");
          function x2(k2, $, M2) {
            let q = k2.length;
            if (q === 0)
              return;
            let { precedingNode: J, followingNode: L2, enclosingNode: Y } = k2[0], V = M2.printer.getGapRegex && M2.printer.getGapRegex(Y) || /^[\s(]*$/, O2 = M2.locStart(L2), K;
            for (K = q; K > 0; --K) {
              let { comment: se, precedingNode: Q, followingNode: le } = k2[K - 1];
              t2.strictEqual(Q, J), t2.strictEqual(le, L2);
              let W2 = $.slice(M2.locEnd(se), O2);
              if (V.test(W2))
                O2 = M2.locStart(se);
              else
                break;
            }
            for (let [se, { comment: Q }] of k2.entries())
              se < K ? w2(J, Q) : D(L2, Q);
            for (let se of [J, L2])
              se.comments && se.comments.length > 1 && se.comments.sort((Q, le) => M2.locStart(Q) - M2.locStart(le));
            k2.length = 0;
          }
          __name(x2, "x");
          function m2(k2, $) {
            let M2 = k2.getValue();
            return M2.printed = true, $.printer.printComment(k2, $);
          }
          __name(m2, "m");
          function E2(k2, $, M2) {
            let q = M2.locStart($) - 1;
            for (let J = 1; J < k2.length; ++J)
              if (q < M2.locStart(k2[J]))
                return J - 1;
            return 0;
          }
          __name(E2, "E");
          function o2(k2, $) {
            let M2 = k2.getValue(), q = [m2(k2, $)], { printer: J, originalText: L2, locStart: Y, locEnd: V } = $;
            if (J.isBlockComment && J.isBlockComment(M2)) {
              let se = y2(L2, V(M2)) ? y2(L2, Y(M2), { backwards: true }) ? a2 : s2 : " ";
              q.push(se);
            } else
              q.push(a2);
            let K = h3(L2, g2(L2, V(M2)));
            return K !== false && y2(L2, K) && q.push(a2), q;
          }
          __name(o2, "o");
          function d2(k2, $) {
            let M2 = k2.getValue(), q = m2(k2, $), { printer: J, originalText: L2, locStart: Y } = $, V = J.isBlockComment && J.isBlockComment(M2);
            if (y2(L2, Y(M2), { backwards: true })) {
              let K = p2(L2, M2, Y);
              return i2([a2, K ? a2 : "", q]);
            }
            let O2 = [" ", q];
            return V || (O2 = [i2(O2), r2]), O2;
          }
          __name(d2, "d");
          function C2(k2, $, M2, q) {
            let J = [], L2 = k2.getValue();
            return !L2 || !L2.comments || (k2.each(() => {
              let Y = k2.getValue();
              !Y.leading && !Y.trailing && (!q || q(Y)) && J.push(m2(k2, $));
            }, "comments"), J.length === 0) ? "" : M2 ? l2(a2, J) : u2([a2, l2(a2, J)]);
          }
          __name(C2, "C");
          function _2(k2, $, M2) {
            let q = k2.getValue();
            if (!q)
              return {};
            let J = q.comments || [];
            M2 && (J = J.filter((O2) => !M2.has(O2)));
            let L2 = q === $.cursorNode;
            if (J.length === 0) {
              let O2 = L2 ? c2 : "";
              return { leading: O2, trailing: O2 };
            }
            let Y = [], V = [];
            return k2.each(() => {
              let O2 = k2.getValue();
              if (M2 && M2.has(O2))
                return;
              let { leading: K, trailing: se } = O2;
              K ? Y.push(o2(k2, $)) : se && V.push(d2(k2, $));
            }, "comments"), L2 && (Y.unshift(c2), V.push(c2)), { leading: Y, trailing: V };
          }
          __name(_2, "_");
          function b2(k2, $, M2, q) {
            let { leading: J, trailing: L2 } = _2(k2, M2, q);
            return !J && !L2 ? $ : [J, $, L2];
          }
          __name(b2, "b");
          function N2(k2) {
            if (!!k2)
              for (let $ of k2) {
                if (!$.printed)
                  throw new Error('Comment "' + $.value.trim() + '" was not printed. Please report this error!');
                delete $.printed;
              }
          }
          __name(N2, "N");
          n2.exports = { attach: I, printComments: b2, printCommentsSeparately: _2, printDanglingComments: C2, getSortedChildNodes: F, ensureAllCommentsPrinted: N2 };
        } }), dm = ee({ "src/common/ast-path.js"(e2, n2) {
          "use strict";
          re();
          var t2 = lt();
          function s2(u2, i2) {
            let l2 = a2(u2.stack, i2);
            return l2 === -1 ? null : u2.stack[l2];
          }
          __name(s2, "s");
          function a2(u2, i2) {
            for (let l2 = u2.length - 1; l2 >= 0; l2 -= 2) {
              let c2 = u2[l2];
              if (c2 && !Array.isArray(c2) && --i2 < 0)
                return l2;
            }
            return -1;
          }
          __name(a2, "a");
          var r2 = /* @__PURE__ */ __name(class {
            constructor(u2) {
              this.stack = [u2];
            }
            getName() {
              let { stack: u2 } = this, { length: i2 } = u2;
              return i2 > 1 ? u2[i2 - 2] : null;
            }
            getValue() {
              return t2(this.stack);
            }
            getNode() {
              let u2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s2(this, u2);
            }
            getParentNode() {
              let u2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s2(this, u2 + 1);
            }
            call(u2) {
              let { stack: i2 } = this, { length: l2 } = i2, c2 = t2(i2);
              for (var y2 = arguments.length, h3 = new Array(y2 > 1 ? y2 - 1 : 0), g2 = 1; g2 < y2; g2++)
                h3[g2 - 1] = arguments[g2];
              for (let D of h3)
                c2 = c2[D], i2.push(D, c2);
              let p2 = u2(this);
              return i2.length = l2, p2;
            }
            callParent(u2) {
              let i2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l2 = a2(this.stack, i2 + 1), c2 = this.stack.splice(l2 + 1), y2 = u2(this);
              return this.stack.push(...c2), y2;
            }
            each(u2) {
              let { stack: i2 } = this, { length: l2 } = i2, c2 = t2(i2);
              for (var y2 = arguments.length, h3 = new Array(y2 > 1 ? y2 - 1 : 0), g2 = 1; g2 < y2; g2++)
                h3[g2 - 1] = arguments[g2];
              for (let p2 of h3)
                c2 = c2[p2], i2.push(p2, c2);
              for (let p2 = 0; p2 < c2.length; ++p2)
                i2.push(p2, c2[p2]), u2(this, p2, c2), i2.length -= 2;
              i2.length = l2;
            }
            map(u2) {
              let i2 = [];
              for (var l2 = arguments.length, c2 = new Array(l2 > 1 ? l2 - 1 : 0), y2 = 1; y2 < l2; y2++)
                c2[y2 - 1] = arguments[y2];
              return this.each((h3, g2, p2) => {
                i2[g2] = u2(h3, g2, p2);
              }, ...c2), i2;
            }
            try(u2) {
              let { stack: i2 } = this, l2 = [...i2];
              try {
                return u2();
              } finally {
                i2.length = 0, i2.push(...l2);
              }
            }
            match() {
              let u2 = this.stack.length - 1, i2 = null, l2 = this.stack[u2--];
              for (var c2 = arguments.length, y2 = new Array(c2), h3 = 0; h3 < c2; h3++)
                y2[h3] = arguments[h3];
              for (let g2 of y2) {
                if (l2 === void 0)
                  return false;
                let p2 = null;
                if (typeof i2 == "number" && (p2 = i2, i2 = this.stack[u2--], l2 = this.stack[u2--]), g2 && !g2(l2, i2, p2))
                  return false;
                i2 = this.stack[u2--], l2 = this.stack[u2--];
              }
              return true;
            }
            findAncestor(u2) {
              let i2 = this.stack.length - 1, l2 = null, c2 = this.stack[i2--];
              for (; c2; ) {
                let y2 = null;
                if (typeof l2 == "number" && (y2 = l2, l2 = this.stack[i2--], c2 = this.stack[i2--]), l2 !== null && u2(c2, l2, y2))
                  return c2;
                l2 = this.stack[i2--], c2 = this.stack[i2--];
              }
            }
          }, "r");
          n2.exports = r2;
        } }), gm = ee({ "src/main/multiparser.js"(e2, n2) {
          "use strict";
          re();
          var { utils: { stripTrailingHardline: t2 } } = qe(), { normalize: s2 } = Oa(), a2 = et();
          function r2(i2, l2, c2, y2) {
            if (c2.printer.embed && c2.embeddedLanguageFormatting === "auto")
              return c2.printer.embed(i2, l2, (h3, g2, p2) => u2(h3, g2, c2, y2, p2), c2);
          }
          __name(r2, "r");
          function u2(i2, l2, c2, y2) {
            let { stripTrailingHardline: h3 = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g2 = s2(Object.assign(Object.assign(Object.assign({}, c2), l2), {}, { parentParser: c2.parser, originalText: i2 }), { passThrough: true }), p2 = Un().parse(i2, g2), { ast: D } = p2;
            i2 = p2.text;
            let v2 = D.comments;
            delete D.comments, a2.attach(v2, D, i2, g2), g2[Symbol.for("comments")] = v2 || [], g2[Symbol.for("tokens")] = D.tokens || [];
            let w2 = y2(D, g2);
            return a2.ensureAllCommentsPrinted(v2), h3 ? typeof w2 == "string" ? w2.replace(/(?:\r?\n)*$/, "") : t2(w2) : w2;
          }
          __name(u2, "u");
          n2.exports = { printSubtree: r2 };
        } }), ym = ee({ "src/main/ast-to-doc.js"(e2, n2) {
          "use strict";
          re();
          var t2 = dm(), { builders: { hardline: s2, addAlignmentToDoc: a2 }, utils: { propagateBreaks: r2 } } = qe(), { printComments: u2 } = et(), i2 = gm();
          function l2(h3, g2) {
            let p2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: D } = g2;
            D.preprocess && (h3 = D.preprocess(h3, g2));
            let v2 = /* @__PURE__ */ new Map(), w2 = new t2(h3), T2 = F();
            return p2 > 0 && (T2 = a2([s2, T2], p2, g2.tabWidth)), r2(T2), T2;
            function F(B, I) {
              return B === void 0 || B === w2 ? A2(I) : Array.isArray(B) ? w2.call(() => A2(I), ...B) : w2.call(() => A2(I), B);
            }
            __name(F, "F");
            function A2(B) {
              let I = w2.getValue(), P2 = I && typeof I == "object" && B === void 0;
              if (P2 && v2.has(I))
                return v2.get(I);
              let R2 = y2(w2, g2, F, B);
              return P2 && v2.set(I, R2), R2;
            }
            __name(A2, "A");
          }
          __name(l2, "l");
          function c2(h3, g2) {
            let { originalText: p2, [Symbol.for("comments")]: D, locStart: v2, locEnd: w2 } = g2, T2 = v2(h3), F = w2(h3), A2 = /* @__PURE__ */ new Set();
            for (let B of D)
              v2(B) >= T2 && w2(B) <= F && (B.printed = true, A2.add(B));
            return { doc: p2.slice(T2, F), printedComments: A2 };
          }
          __name(c2, "c");
          function y2(h3, g2, p2, D) {
            let v2 = h3.getValue(), { printer: w2 } = g2, T2, F;
            if (w2.hasPrettierIgnore && w2.hasPrettierIgnore(h3))
              ({ doc: T2, printedComments: F } = c2(v2, g2));
            else {
              if (v2)
                try {
                  T2 = i2.printSubtree(h3, p2, g2, l2);
                } catch (A2) {
                  if (globalThis.PRETTIER_DEBUG)
                    throw A2;
                }
              T2 || (T2 = w2.print(h3, g2, p2, D));
            }
            return (!w2.willPrintOwnComments || !w2.willPrintOwnComments(h3, g2)) && (T2 = u2(h3, T2, g2, F)), T2;
          }
          __name(y2, "y");
          n2.exports = l2;
        } }), hm = ee({ "src/main/range-util.js"(e2, n2) {
          "use strict";
          re();
          var t2 = Yt(), s2 = et(), a2 = /* @__PURE__ */ __name((D) => {
            let { parser: v2 } = D;
            return v2 === "json" || v2 === "json5" || v2 === "json-stringify";
          }, "a");
          function r2(D, v2) {
            let w2 = [D.node, ...D.parentNodes], T2 = /* @__PURE__ */ new Set([v2.node, ...v2.parentNodes]);
            return w2.find((F) => y2.has(F.type) && T2.has(F));
          }
          __name(r2, "r");
          function u2(D) {
            let v2 = D.length - 1;
            for (; ; ) {
              let w2 = D[v2];
              if (w2 && (w2.type === "Program" || w2.type === "File"))
                v2--;
              else
                break;
            }
            return D.slice(0, v2 + 1);
          }
          __name(u2, "u");
          function i2(D, v2, w2) {
            let { locStart: T2, locEnd: F } = w2, A2 = D.node, B = v2.node;
            if (A2 === B)
              return { startNode: A2, endNode: B };
            let I = T2(D.node);
            for (let R2 of u2(v2.parentNodes))
              if (T2(R2) >= I)
                B = R2;
              else
                break;
            let P2 = F(v2.node);
            for (let R2 of u2(D.parentNodes)) {
              if (F(R2) <= P2)
                A2 = R2;
              else
                break;
              if (A2 === B)
                break;
            }
            return { startNode: A2, endNode: B };
          }
          __name(i2, "i");
          function l2(D, v2, w2, T2) {
            let F = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], A2 = arguments.length > 5 ? arguments[5] : void 0, { locStart: B, locEnd: I } = w2, P2 = B(D), R2 = I(D);
            if (!(v2 > R2 || v2 < P2 || A2 === "rangeEnd" && v2 === P2 || A2 === "rangeStart" && v2 === R2)) {
              for (let f2 of s2.getSortedChildNodes(D, w2)) {
                let x2 = l2(f2, v2, w2, T2, [D, ...F], A2);
                if (x2)
                  return x2;
              }
              if (!T2 || T2(D, F[0]))
                return { node: D, parentNodes: F };
            }
          }
          __name(l2, "l");
          function c2(D, v2) {
            return v2 !== "DeclareExportDeclaration" && D !== "TypeParameterDeclaration" && (D === "Directive" || D === "TypeAlias" || D === "TSExportAssignment" || D.startsWith("Declare") || D.startsWith("TSDeclare") || D.endsWith("Statement") || D.endsWith("Declaration"));
          }
          __name(c2, "c");
          var y2 = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), h3 = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
          function g2(D, v2, w2) {
            if (!v2)
              return false;
            switch (D.parser) {
              case "flow":
              case "babel":
              case "babel-flow":
              case "babel-ts":
              case "typescript":
              case "acorn":
              case "espree":
              case "meriyah":
              case "__babel_estree":
                return c2(v2.type, w2 && w2.type);
              case "json":
              case "json5":
              case "json-stringify":
                return y2.has(v2.type);
              case "graphql":
                return h3.has(v2.kind);
              case "vue":
                return v2.tag !== "root";
            }
            return false;
          }
          __name(g2, "g");
          function p2(D, v2, w2) {
            let { rangeStart: T2, rangeEnd: F, locStart: A2, locEnd: B } = v2;
            t2.ok(F > T2);
            let I = D.slice(T2, F).search(/\S/), P2 = I === -1;
            if (!P2)
              for (T2 += I; F > T2 && !/\S/.test(D[F - 1]); --F)
                ;
            let R2 = l2(w2, T2, v2, (E2, o2) => g2(v2, E2, o2), [], "rangeStart"), f2 = P2 ? R2 : l2(w2, F, v2, (E2) => g2(v2, E2), [], "rangeEnd");
            if (!R2 || !f2)
              return { rangeStart: 0, rangeEnd: 0 };
            let x2, m2;
            if (a2(v2)) {
              let E2 = r2(R2, f2);
              x2 = E2, m2 = E2;
            } else
              ({ startNode: x2, endNode: m2 } = i2(R2, f2, v2));
            return { rangeStart: Math.min(A2(x2), A2(m2)), rangeEnd: Math.max(B(x2), B(m2)) };
          }
          __name(p2, "p");
          n2.exports = { calculateRange: p2, findNodeAtOffset: l2 };
        } }), vm = ee({ "src/main/core.js"(e2, n2) {
          "use strict";
          re();
          var { diffArrays: t2 } = rD(), { printer: { printDocToString: s2 }, debug: { printDocToDebug: a2 } } = qe(), { getAlignmentSize: r2 } = Ge(), { guessEndOfLine: u2, convertEndOfLineToChars: i2, countEndOfLineChars: l2, normalizeEndOfLine: c2 } = qn(), y2 = Oa().normalize, h3 = mm(), g2 = et(), p2 = Un(), D = ym(), v2 = hm(), w2 = "\uFEFF", T2 = Symbol("cursor");
          function F(m2, E2, o2) {
            let d2 = E2.comments;
            return d2 && (delete E2.comments, g2.attach(d2, E2, m2, o2)), o2[Symbol.for("comments")] = d2 || [], o2[Symbol.for("tokens")] = E2.tokens || [], o2.originalText = m2, d2;
          }
          __name(F, "F");
          function A2(m2, E2) {
            let o2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            if (!m2 || m2.trim().length === 0)
              return { formatted: "", cursorOffset: -1, comments: [] };
            let { ast: d2, text: C2 } = p2.parse(m2, E2);
            if (E2.cursorOffset >= 0) {
              let k2 = v2.findNodeAtOffset(d2, E2.cursorOffset, E2);
              k2 && k2.node && (E2.cursorNode = k2.node);
            }
            let _2 = F(C2, d2, E2), b2 = D(d2, E2, o2), N2 = s2(b2, E2);
            if (g2.ensureAllCommentsPrinted(_2), o2 > 0) {
              let k2 = N2.formatted.trim();
              N2.cursorNodeStart !== void 0 && (N2.cursorNodeStart -= N2.formatted.indexOf(k2)), N2.formatted = k2 + i2(E2.endOfLine);
            }
            if (E2.cursorOffset >= 0) {
              let k2, $, M2, q, J;
              if (E2.cursorNode && N2.cursorNodeText ? (k2 = E2.locStart(E2.cursorNode), $ = C2.slice(k2, E2.locEnd(E2.cursorNode)), M2 = E2.cursorOffset - k2, q = N2.cursorNodeStart, J = N2.cursorNodeText) : (k2 = 0, $ = C2, M2 = E2.cursorOffset, q = 0, J = N2.formatted), $ === J)
                return { formatted: N2.formatted, cursorOffset: q + M2, comments: _2 };
              let L2 = [...$];
              L2.splice(M2, 0, T2);
              let Y = [...J], V = t2(L2, Y), O2 = q;
              for (let K of V)
                if (K.removed) {
                  if (K.value.includes(T2))
                    break;
                } else
                  O2 += K.count;
              return { formatted: N2.formatted, cursorOffset: O2, comments: _2 };
            }
            return { formatted: N2.formatted, cursorOffset: -1, comments: _2 };
          }
          __name(A2, "A");
          function B(m2, E2) {
            let { ast: o2, text: d2 } = p2.parse(m2, E2), { rangeStart: C2, rangeEnd: _2 } = v2.calculateRange(d2, E2, o2), b2 = d2.slice(C2, _2), N2 = Math.min(C2, d2.lastIndexOf(`
`, C2) + 1), k2 = d2.slice(N2, C2).match(/^\s*/)[0], $ = r2(k2, E2.tabWidth), M2 = A2(b2, Object.assign(Object.assign({}, E2), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: E2.cursorOffset > C2 && E2.cursorOffset <= _2 ? E2.cursorOffset - C2 : -1, endOfLine: "lf" }), $), q = M2.formatted.trimEnd(), { cursorOffset: J } = E2;
            J > _2 ? J += q.length - b2.length : M2.cursorOffset >= 0 && (J = M2.cursorOffset + C2);
            let L2 = d2.slice(0, C2) + q + d2.slice(_2);
            if (E2.endOfLine !== "lf") {
              let Y = i2(E2.endOfLine);
              J >= 0 && Y === `\r
` && (J += l2(L2.slice(0, J), `
`)), L2 = L2.replace(/\n/g, Y);
            }
            return { formatted: L2, cursorOffset: J, comments: M2.comments };
          }
          __name(B, "B");
          function I(m2, E2, o2) {
            return typeof E2 != "number" || Number.isNaN(E2) || E2 < 0 || E2 > m2.length ? o2 : E2;
          }
          __name(I, "I");
          function P2(m2, E2) {
            let { cursorOffset: o2, rangeStart: d2, rangeEnd: C2 } = E2;
            return o2 = I(m2, o2, -1), d2 = I(m2, d2, 0), C2 = I(m2, C2, m2.length), Object.assign(Object.assign({}, E2), {}, { cursorOffset: o2, rangeStart: d2, rangeEnd: C2 });
          }
          __name(P2, "P");
          function R2(m2, E2) {
            let { cursorOffset: o2, rangeStart: d2, rangeEnd: C2, endOfLine: _2 } = P2(m2, E2), b2 = m2.charAt(0) === w2;
            if (b2 && (m2 = m2.slice(1), o2--, d2--, C2--), _2 === "auto" && (_2 = u2(m2)), m2.includes("\r")) {
              let N2 = /* @__PURE__ */ __name((k2) => l2(m2.slice(0, Math.max(k2, 0)), `\r
`), "N");
              o2 -= N2(o2), d2 -= N2(d2), C2 -= N2(C2), m2 = c2(m2);
            }
            return { hasBOM: b2, text: m2, options: P2(m2, Object.assign(Object.assign({}, E2), {}, { cursorOffset: o2, rangeStart: d2, rangeEnd: C2, endOfLine: _2 })) };
          }
          __name(R2, "R");
          function f2(m2, E2) {
            let o2 = p2.resolveParser(E2);
            return !o2.hasPragma || o2.hasPragma(m2);
          }
          __name(f2, "f");
          function x2(m2, E2) {
            let { hasBOM: o2, text: d2, options: C2 } = R2(m2, y2(E2));
            if (C2.rangeStart >= C2.rangeEnd && d2 !== "" || C2.requirePragma && !f2(d2, C2))
              return { formatted: m2, cursorOffset: E2.cursorOffset, comments: [] };
            let _2;
            return C2.rangeStart > 0 || C2.rangeEnd < d2.length ? _2 = B(d2, C2) : (!C2.requirePragma && C2.insertPragma && C2.printer.insertPragma && !f2(d2, C2) && (d2 = C2.printer.insertPragma(d2)), _2 = A2(d2, C2)), o2 && (_2.formatted = w2 + _2.formatted, _2.cursorOffset >= 0 && _2.cursorOffset++), _2;
          }
          __name(x2, "x");
          n2.exports = { formatWithCursor: x2, parse(m2, E2, o2) {
            let { text: d2, options: C2 } = R2(m2, y2(E2)), _2 = p2.parse(d2, C2);
            return o2 && (_2.ast = h3(_2.ast, C2)), _2;
          }, formatAST(m2, E2) {
            E2 = y2(E2);
            let o2 = D(m2, E2);
            return s2(o2, E2);
          }, formatDoc(m2, E2) {
            return x2(a2(m2), Object.assign(Object.assign({}, E2), {}, { parser: "__js_expression" })).formatted;
          }, printToDoc(m2, E2) {
            E2 = y2(E2);
            let { ast: o2, text: d2 } = p2.parse(m2, E2);
            return F(d2, o2, E2), D(o2, E2);
          }, printDocToString(m2, E2) {
            return s2(m2, y2(E2));
          } };
        } }), Cm = ee({ "src/common/util-shared.js"(e2, n2) {
          "use strict";
          re();
          var { getMaxContinuousCount: t2, getStringWidth: s2, getAlignmentSize: a2, getIndentSize: r2, skip: u2, skipWhitespace: i2, skipSpaces: l2, skipNewline: c2, skipToLineEnd: y2, skipEverythingButNewLine: h3, skipInlineComment: g2, skipTrailingComment: p2, hasNewline: D, hasNewlineInRange: v2, hasSpaces: w2, isNextLineEmpty: T2, isNextLineEmptyAfterIndex: F, isPreviousLineEmpty: A2, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I, addLeadingComment: P2, addDanglingComment: R2, addTrailingComment: f2 } = Ge();
          n2.exports = { getMaxContinuousCount: t2, getStringWidth: s2, getAlignmentSize: a2, getIndentSize: r2, skip: u2, skipWhitespace: i2, skipSpaces: l2, skipNewline: c2, skipToLineEnd: y2, skipEverythingButNewLine: h3, skipInlineComment: g2, skipTrailingComment: p2, hasNewline: D, hasNewlineInRange: v2, hasSpaces: w2, isNextLineEmpty: T2, isNextLineEmptyAfterIndex: F, isPreviousLineEmpty: A2, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I, addLeadingComment: P2, addDanglingComment: R2, addTrailingComment: f2 };
        } }), wt = ee({ "src/utils/create-language.js"(e2, n2) {
          "use strict";
          re(), n2.exports = function(t2, s2) {
            let { languageId: a2 } = t2, r2 = Ln(t2, zf);
            return Object.assign(Object.assign({ linguistLanguageId: a2 }, r2), s2(t2));
          };
        } }), Em = ee({ "node_modules/esutils/lib/ast.js"(e2, n2) {
          re(), function() {
            "use strict";
            function t2(l2) {
              if (l2 == null)
                return false;
              switch (l2.type) {
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "Literal":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                  return true;
              }
              return false;
            }
            __name(t2, "t");
            function s2(l2) {
              if (l2 == null)
                return false;
              switch (l2.type) {
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                  return true;
              }
              return false;
            }
            __name(s2, "s");
            function a2(l2) {
              if (l2 == null)
                return false;
              switch (l2.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                  return true;
              }
              return false;
            }
            __name(a2, "a");
            function r2(l2) {
              return a2(l2) || l2 != null && l2.type === "FunctionDeclaration";
            }
            __name(r2, "r");
            function u2(l2) {
              switch (l2.type) {
                case "IfStatement":
                  return l2.alternate != null ? l2.alternate : l2.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                  return l2.body;
              }
              return null;
            }
            __name(u2, "u");
            function i2(l2) {
              var c2;
              if (l2.type !== "IfStatement" || l2.alternate == null)
                return false;
              c2 = l2.consequent;
              do {
                if (c2.type === "IfStatement" && c2.alternate == null)
                  return true;
                c2 = u2(c2);
              } while (c2);
              return false;
            }
            __name(i2, "i");
            n2.exports = { isExpression: t2, isStatement: a2, isIterationStatement: s2, isSourceElement: r2, isProblematicIfStatement: i2, trailingStatement: u2 };
          }();
        } }), qa = ee({ "node_modules/esutils/lib/code.js"(e2, n2) {
          re(), function() {
            "use strict";
            var t2, s2, a2, r2, u2, i2;
            s2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
            function l2(F) {
              return 48 <= F && F <= 57;
            }
            __name(l2, "l");
            function c2(F) {
              return 48 <= F && F <= 57 || 97 <= F && F <= 102 || 65 <= F && F <= 70;
            }
            __name(c2, "c");
            function y2(F) {
              return F >= 48 && F <= 55;
            }
            __name(y2, "y");
            a2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
            function h3(F) {
              return F === 32 || F === 9 || F === 11 || F === 12 || F === 160 || F >= 5760 && a2.indexOf(F) >= 0;
            }
            __name(h3, "h");
            function g2(F) {
              return F === 10 || F === 13 || F === 8232 || F === 8233;
            }
            __name(g2, "g");
            function p2(F) {
              if (F <= 65535)
                return String.fromCharCode(F);
              var A2 = String.fromCharCode(Math.floor((F - 65536) / 1024) + 55296), B = String.fromCharCode((F - 65536) % 1024 + 56320);
              return A2 + B;
            }
            __name(p2, "p");
            for (r2 = new Array(128), i2 = 0; i2 < 128; ++i2)
              r2[i2] = i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 === 36 || i2 === 95;
            for (u2 = new Array(128), i2 = 0; i2 < 128; ++i2)
              u2[i2] = i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 >= 48 && i2 <= 57 || i2 === 36 || i2 === 95;
            function D(F) {
              return F < 128 ? r2[F] : s2.NonAsciiIdentifierStart.test(p2(F));
            }
            __name(D, "D");
            function v2(F) {
              return F < 128 ? u2[F] : s2.NonAsciiIdentifierPart.test(p2(F));
            }
            __name(v2, "v");
            function w2(F) {
              return F < 128 ? r2[F] : t2.NonAsciiIdentifierStart.test(p2(F));
            }
            __name(w2, "w");
            function T2(F) {
              return F < 128 ? u2[F] : t2.NonAsciiIdentifierPart.test(p2(F));
            }
            __name(T2, "T");
            n2.exports = { isDecimalDigit: l2, isHexDigit: c2, isOctalDigit: y2, isWhiteSpace: h3, isLineTerminator: g2, isIdentifierStartES5: D, isIdentifierPartES5: v2, isIdentifierStartES6: w2, isIdentifierPartES6: T2 };
          }();
        } }), Fm = ee({ "node_modules/esutils/lib/keyword.js"(e2, n2) {
          re(), function() {
            "use strict";
            var t2 = qa();
            function s2(D) {
              switch (D) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }
            __name(s2, "s");
            function a2(D, v2) {
              return !v2 && D === "yield" ? false : r2(D, v2);
            }
            __name(a2, "a");
            function r2(D, v2) {
              if (v2 && s2(D))
                return true;
              switch (D.length) {
                case 2:
                  return D === "if" || D === "in" || D === "do";
                case 3:
                  return D === "var" || D === "for" || D === "new" || D === "try";
                case 4:
                  return D === "this" || D === "else" || D === "case" || D === "void" || D === "with" || D === "enum";
                case 5:
                  return D === "while" || D === "break" || D === "catch" || D === "throw" || D === "const" || D === "yield" || D === "class" || D === "super";
                case 6:
                  return D === "return" || D === "typeof" || D === "delete" || D === "switch" || D === "export" || D === "import";
                case 7:
                  return D === "default" || D === "finally" || D === "extends";
                case 8:
                  return D === "function" || D === "continue" || D === "debugger";
                case 10:
                  return D === "instanceof";
                default:
                  return false;
              }
            }
            __name(r2, "r");
            function u2(D, v2) {
              return D === "null" || D === "true" || D === "false" || a2(D, v2);
            }
            __name(u2, "u");
            function i2(D, v2) {
              return D === "null" || D === "true" || D === "false" || r2(D, v2);
            }
            __name(i2, "i");
            function l2(D) {
              return D === "eval" || D === "arguments";
            }
            __name(l2, "l");
            function c2(D) {
              var v2, w2, T2;
              if (D.length === 0 || (T2 = D.charCodeAt(0), !t2.isIdentifierStartES5(T2)))
                return false;
              for (v2 = 1, w2 = D.length; v2 < w2; ++v2)
                if (T2 = D.charCodeAt(v2), !t2.isIdentifierPartES5(T2))
                  return false;
              return true;
            }
            __name(c2, "c");
            function y2(D, v2) {
              return (D - 55296) * 1024 + (v2 - 56320) + 65536;
            }
            __name(y2, "y");
            function h3(D) {
              var v2, w2, T2, F, A2;
              if (D.length === 0)
                return false;
              for (A2 = t2.isIdentifierStartES6, v2 = 0, w2 = D.length; v2 < w2; ++v2) {
                if (T2 = D.charCodeAt(v2), 55296 <= T2 && T2 <= 56319) {
                  if (++v2, v2 >= w2 || (F = D.charCodeAt(v2), !(56320 <= F && F <= 57343)))
                    return false;
                  T2 = y2(T2, F);
                }
                if (!A2(T2))
                  return false;
                A2 = t2.isIdentifierPartES6;
              }
              return true;
            }
            __name(h3, "h");
            function g2(D, v2) {
              return c2(D) && !u2(D, v2);
            }
            __name(g2, "g");
            function p2(D, v2) {
              return h3(D) && !i2(D, v2);
            }
            __name(p2, "p");
            n2.exports = { isKeywordES5: a2, isKeywordES6: r2, isReservedWordES5: u2, isReservedWordES6: i2, isRestrictedWord: l2, isIdentifierNameES5: c2, isIdentifierNameES6: h3, isIdentifierES5: g2, isIdentifierES6: p2 };
          }();
        } }), Am = ee({ "node_modules/esutils/lib/utils.js"(e2) {
          re(), function() {
            "use strict";
            e2.ast = Em(), e2.code = qa(), e2.keyword = Fm();
          }();
        } }), Lt = ee({ "src/language-js/utils/is-block-comment.js"(e2, n2) {
          "use strict";
          re();
          var t2 = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s2 = /* @__PURE__ */ __name((a2) => t2.has(a2 == null ? void 0 : a2.type), "s");
          n2.exports = s2;
        } }), Sm = ee({ "src/language-js/utils/is-node-matches.js"(e2, n2) {
          "use strict";
          re();
          function t2(a2, r2) {
            let u2 = r2.split(".");
            for (let i2 = u2.length - 1; i2 >= 0; i2--) {
              let l2 = u2[i2];
              if (i2 === 0)
                return a2.type === "Identifier" && a2.name === l2;
              if (a2.type !== "MemberExpression" || a2.optional || a2.computed || a2.property.type !== "Identifier" || a2.property.name !== l2)
                return false;
              a2 = a2.object;
            }
          }
          __name(t2, "t");
          function s2(a2, r2) {
            return r2.some((u2) => t2(a2, u2));
          }
          __name(s2, "s");
          n2.exports = s2;
        } }), Ke = ee({ "src/language-js/utils/index.js"(e2, n2) {
          "use strict";
          re();
          var t2 = Am().keyword.isIdentifierNameES5, { getLast: s2, hasNewline: a2, skipWhitespace: r2, isNonEmptyArray: u2, isNextLineEmptyAfterIndex: i2, getStringWidth: l2 } = Ge(), { locStart: c2, locEnd: y2, hasSameLocStart: h3 } = it(), g2 = Lt(), p2 = Sm(), D = "(?:(?=.)\\s)", v2 = new RegExp(`^${D}*:`), w2 = new RegExp(`^${D}*::`);
          function T2(j2) {
            var me, Ie;
            return ((me = j2.extra) === null || me === void 0 ? void 0 : me.parenthesized) && g2((Ie = j2.trailingComments) === null || Ie === void 0 ? void 0 : Ie[0]) && v2.test(j2.trailingComments[0].value);
          }
          __name(T2, "T");
          function F(j2) {
            let me = j2 == null ? void 0 : j2[0];
            return g2(me) && w2.test(me.value);
          }
          __name(F, "F");
          function A2(j2, me) {
            if (!j2 || typeof j2 != "object")
              return false;
            if (Array.isArray(j2))
              return j2.some((je) => A2(je, me));
            let Ie = me(j2);
            return typeof Ie == "boolean" ? Ie : Object.values(j2).some((je) => A2(je, me));
          }
          __name(A2, "A");
          function B(j2) {
            return j2.type === "AssignmentExpression" || j2.type === "BinaryExpression" || j2.type === "LogicalExpression" || j2.type === "NGPipeExpression" || j2.type === "ConditionalExpression" || oe(j2) || ae(j2) || j2.type === "SequenceExpression" || j2.type === "TaggedTemplateExpression" || j2.type === "BindExpression" || j2.type === "UpdateExpression" && !j2.prefix || nt(j2) || j2.type === "TSNonNullExpression";
          }
          __name(B, "B");
          function I(j2) {
            var me, Ie, je, Ye, ut, ze;
            return j2.expressions ? j2.expressions[0] : (me = (Ie = (je = (Ye = (ut = (ze = j2.left) !== null && ze !== void 0 ? ze : j2.test) !== null && ut !== void 0 ? ut : j2.callee) !== null && Ye !== void 0 ? Ye : j2.object) !== null && je !== void 0 ? je : j2.tag) !== null && Ie !== void 0 ? Ie : j2.argument) !== null && me !== void 0 ? me : j2.expression;
          }
          __name(I, "I");
          function P2(j2, me) {
            if (me.expressions)
              return ["expressions", 0];
            if (me.left)
              return ["left"];
            if (me.test)
              return ["test"];
            if (me.object)
              return ["object"];
            if (me.callee)
              return ["callee"];
            if (me.tag)
              return ["tag"];
            if (me.argument)
              return ["argument"];
            if (me.expression)
              return ["expression"];
            throw new Error("Unexpected node has no left side.");
          }
          __name(P2, "P");
          function R2(j2) {
            return j2 = new Set(j2), (me) => j2.has(me == null ? void 0 : me.type);
          }
          __name(R2, "R");
          var f2 = R2(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), x2 = R2(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
          function m2(j2) {
            let me = j2.getParentNode();
            return j2.getName() === "declaration" && x2(me) ? me : null;
          }
          __name(m2, "m");
          var E2 = R2(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
          function o2(j2) {
            return j2.type === "NumericLiteral" || j2.type === "Literal" && typeof j2.value == "number";
          }
          __name(o2, "o");
          function d2(j2) {
            return j2.type === "UnaryExpression" && (j2.operator === "+" || j2.operator === "-") && o2(j2.argument);
          }
          __name(d2, "d");
          function C2(j2) {
            return j2.type === "StringLiteral" || j2.type === "Literal" && typeof j2.value == "string";
          }
          __name(C2, "C");
          var _2 = R2(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b2 = R2(["FunctionExpression", "ArrowFunctionExpression"]);
          function N2(j2) {
            return j2.type === "FunctionExpression" || j2.type === "ArrowFunctionExpression" && j2.body.type === "BlockStatement";
          }
          __name(N2, "N");
          function k2(j2) {
            return oe(j2) && j2.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(j2.callee.name);
          }
          __name(k2, "k");
          var $ = R2(["JSXElement", "JSXFragment"]);
          function M2(j2, me) {
            if (j2.parentParser !== "markdown" && j2.parentParser !== "mdx")
              return false;
            let Ie = me.getNode();
            if (!Ie.expression || !$(Ie.expression))
              return false;
            let je = me.getParentNode();
            return je.type === "Program" && je.body.length === 1;
          }
          __name(M2, "M");
          function q(j2) {
            return j2.kind === "get" || j2.kind === "set";
          }
          __name(q, "q");
          function J(j2) {
            return q(j2) || h3(j2, j2.value);
          }
          __name(J, "J");
          function L2(j2) {
            return (j2.type === "ObjectTypeProperty" || j2.type === "ObjectTypeInternalSlot") && j2.value.type === "FunctionTypeAnnotation" && !j2.static && !J(j2);
          }
          __name(L2, "L");
          function Y(j2) {
            return (j2.type === "TypeAnnotation" || j2.type === "TSTypeAnnotation") && j2.typeAnnotation.type === "FunctionTypeAnnotation" && !j2.static && !h3(j2, j2.typeAnnotation);
          }
          __name(Y, "Y");
          var V = R2(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
          function O2(j2) {
            return ae(j2) || j2.type === "BindExpression" && Boolean(j2.object);
          }
          __name(O2, "O");
          var K = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
          function se(j2) {
            return j2 ? !!((j2.type === "GenericTypeAnnotation" || j2.type === "TSTypeReference") && !j2.typeParameters || K.has(j2.type)) : false;
          }
          __name(se, "se");
          function Q(j2) {
            let me = /^(?:before|after)(?:Each|All)$/;
            return j2.callee.type === "Identifier" && me.test(j2.callee.name) && j2.arguments.length === 1;
          }
          __name(Q, "Q");
          var le = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
          function W2(j2) {
            return p2(j2, le);
          }
          __name(W2, "W");
          function X(j2, me) {
            if (j2.type !== "CallExpression")
              return false;
            if (j2.arguments.length === 1) {
              if (k2(j2) && me && X(me))
                return b2(j2.arguments[0]);
              if (Q(j2))
                return k2(j2.arguments[0]);
            } else if ((j2.arguments.length === 2 || j2.arguments.length === 3) && (j2.arguments[0].type === "TemplateLiteral" || C2(j2.arguments[0])) && W2(j2.callee))
              return j2.arguments[2] && !o2(j2.arguments[2]) ? false : (j2.arguments.length === 2 ? b2(j2.arguments[1]) : N2(j2.arguments[1]) && Fe(j2.arguments[1]).length <= 1) || k2(j2.arguments[1]);
            return false;
          }
          __name(X, "X");
          var oe = R2(["CallExpression", "OptionalCallExpression"]), ae = R2(["MemberExpression", "OptionalMemberExpression"]);
          function Ae(j2) {
            let me = "expressions";
            j2.type === "TSTemplateLiteralType" && (me = "types");
            let Ie = j2[me];
            return Ie.length === 0 ? false : Ie.every((je) => {
              if (ue(je))
                return false;
              if (je.type === "Identifier" || je.type === "ThisExpression")
                return true;
              if (ae(je)) {
                let Ye = je;
                for (; ae(Ye); )
                  if (Ye.property.type !== "Identifier" && Ye.property.type !== "Literal" && Ye.property.type !== "StringLiteral" && Ye.property.type !== "NumericLiteral" || (Ye = Ye.object, ue(Ye)))
                    return false;
                return Ye.type === "Identifier" || Ye.type === "ThisExpression";
              }
              return false;
            });
          }
          __name(Ae, "Ae");
          function z(j2, me) {
            return j2 === "+" || j2 === "-" ? j2 + me : me;
          }
          __name(z, "z");
          function H(j2, me) {
            let Ie = c2(me), je = r2(j2, y2(me));
            return je !== false && j2.slice(Ie, Ie + 2) === "/*" && j2.slice(je, je + 2) === "*/";
          }
          __name(H, "H");
          function Z(j2, me) {
            return $(me) ? Ve(me) : ue(me, ke.Leading, (Ie) => a2(j2, y2(Ie)));
          }
          __name(Z, "Z");
          function ne(j2, me) {
            return me.parser !== "json" && C2(j2.key) && ce(j2.key).slice(1, -1) === j2.key.value && (t2(j2.key.value) && !(me.parser === "babel-ts" && j2.type === "ClassProperty" || me.parser === "typescript" && j2.type === "PropertyDefinition") || fe(j2.key.value) && String(Number(j2.key.value)) === j2.key.value && (me.parser === "babel" || me.parser === "acorn" || me.parser === "espree" || me.parser === "meriyah" || me.parser === "__babel_estree"));
          }
          __name(ne, "ne");
          function fe(j2) {
            return /^(?:\d+|\d+\.\d+)$/.test(j2);
          }
          __name(fe, "fe");
          function ge(j2, me) {
            let Ie = /^[fx]?(?:describe|it|test)$/;
            return me.type === "TaggedTemplateExpression" && me.quasi === j2 && me.tag.type === "MemberExpression" && me.tag.property.type === "Identifier" && me.tag.property.name === "each" && (me.tag.object.type === "Identifier" && Ie.test(me.tag.object.name) || me.tag.object.type === "MemberExpression" && me.tag.object.property.type === "Identifier" && (me.tag.object.property.name === "only" || me.tag.object.property.name === "skip") && me.tag.object.object.type === "Identifier" && Ie.test(me.tag.object.object.name));
          }
          __name(ge, "ge");
          function Ce(j2) {
            return j2.quasis.some((me) => me.value.raw.includes(`
`));
          }
          __name(Ce, "Ce");
          function _e(j2, me) {
            return (j2.type === "TemplateLiteral" && Ce(j2) || j2.type === "TaggedTemplateExpression" && Ce(j2.quasi)) && !a2(me, c2(j2), { backwards: true });
          }
          __name(_e, "_e");
          function Oe(j2) {
            if (!ue(j2))
              return false;
            let me = s2(st(j2, ke.Dangling));
            return me && !g2(me);
          }
          __name(Oe, "Oe");
          function pe(j2) {
            if (j2.length <= 1)
              return false;
            let me = 0;
            for (let Ie of j2)
              if (b2(Ie)) {
                if (me += 1, me > 1)
                  return true;
              } else if (oe(Ie)) {
                for (let je of Ie.arguments)
                  if (b2(je))
                    return true;
              }
            return false;
          }
          __name(pe, "pe");
          function ie(j2) {
            let me = j2.getValue(), Ie = j2.getParentNode();
            return oe(me) && oe(Ie) && Ie.callee === me && me.arguments.length > Ie.arguments.length && Ie.arguments.length > 0;
          }
          __name(ie, "ie");
          function ve(j2, me) {
            if (me >= 2)
              return false;
            let Ie = /* @__PURE__ */ __name((ze) => ve(ze, me + 1), "Ie"), je = j2.type === "Literal" && "regex" in j2 && j2.regex.pattern || j2.type === "RegExpLiteral" && j2.pattern;
            if (je && l2(je) > 5)
              return false;
            if (j2.type === "Literal" || j2.type === "BigIntLiteral" || j2.type === "DecimalLiteral" || j2.type === "BooleanLiteral" || j2.type === "NullLiteral" || j2.type === "NumericLiteral" || j2.type === "RegExpLiteral" || j2.type === "StringLiteral" || j2.type === "Identifier" || j2.type === "ThisExpression" || j2.type === "Super" || j2.type === "PrivateName" || j2.type === "PrivateIdentifier" || j2.type === "ArgumentPlaceholder" || j2.type === "Import")
              return true;
            if (j2.type === "TemplateLiteral")
              return j2.quasis.every((ze) => !ze.value.raw.includes(`
`)) && j2.expressions.every(Ie);
            if (j2.type === "ObjectExpression")
              return j2.properties.every((ze) => !ze.computed && (ze.shorthand || ze.value && Ie(ze.value)));
            if (j2.type === "ArrayExpression")
              return j2.elements.every((ze) => ze === null || Ie(ze));
            if (He(j2))
              return (j2.type === "ImportExpression" || ve(j2.callee, me)) && Je(j2).every(Ie);
            if (ae(j2))
              return ve(j2.object, me) && ve(j2.property, me);
            let Ye = { "!": true, "-": true, "+": true, "~": true };
            if (j2.type === "UnaryExpression" && Ye[j2.operator])
              return ve(j2.argument, me);
            let ut = { "++": true, "--": true };
            return j2.type === "UpdateExpression" && ut[j2.operator] ? ve(j2.argument, me) : j2.type === "TSNonNullExpression" ? ve(j2.expression, me) : false;
          }
          __name(ve, "ve");
          function ce(j2) {
            var me, Ie;
            return (me = (Ie = j2.extra) === null || Ie === void 0 ? void 0 : Ie.raw) !== null && me !== void 0 ? me : j2.raw;
          }
          __name(ce, "ce");
          function U2(j2) {
            return j2;
          }
          __name(U2, "U");
          function de(j2) {
            return j2.filepath && /\.tsx$/i.test(j2.filepath);
          }
          __name(de, "de");
          function De(j2) {
            let me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
            return j2.trailingComma === "es5" && me === "es5" || j2.trailingComma === "all" && (me === "all" || me === "es5");
          }
          __name(De, "De");
          function he(j2, me) {
            switch (j2 = Ee(j2), j2.type) {
              case "FunctionExpression":
              case "ClassExpression":
              case "DoExpression":
                return me;
              case "ObjectExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return he(j2.object, me);
              case "TaggedTemplateExpression":
                return j2.tag.type === "FunctionExpression" ? false : he(j2.tag, me);
              case "CallExpression":
              case "OptionalCallExpression":
                return j2.callee.type === "FunctionExpression" ? false : he(j2.callee, me);
              case "ConditionalExpression":
                return he(j2.test, me);
              case "UpdateExpression":
                return !j2.prefix && he(j2.argument, me);
              case "BindExpression":
                return j2.object && he(j2.object, me);
              case "SequenceExpression":
                return he(j2.expressions[0], me);
              case "TSSatisfiesExpression":
              case "TSAsExpression":
              case "TSNonNullExpression":
                return he(j2.expression, me);
              default:
                return false;
            }
          }
          __name(he, "he");
          var Be = { "==": true, "!=": true, "===": true, "!==": true }, Se = { "*": true, "/": true, "%": true }, ye = { ">>": true, ">>>": true, "<<": true };
          function S2(j2, me) {
            return !(te(me) !== te(j2) || j2 === "**" || Be[j2] && Be[me] || me === "%" && Se[j2] || j2 === "%" && Se[me] || me !== j2 && Se[me] && Se[j2] || ye[j2] && ye[me]);
          }
          __name(S2, "S");
          var G = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((j2, me) => j2.map((Ie) => [Ie, me])));
          function te(j2) {
            return G.get(j2);
          }
          __name(te, "te");
          function Ee(j2) {
            for (; j2.left; )
              j2 = j2.left;
            return j2;
          }
          __name(Ee, "Ee");
          function Re(j2) {
            return Boolean(ye[j2]) || j2 === "|" || j2 === "^" || j2 === "&";
          }
          __name(Re, "Re");
          function Te(j2) {
            var me;
            if (j2.rest)
              return true;
            let Ie = Fe(j2);
            return ((me = s2(Ie)) === null || me === void 0 ? void 0 : me.type) === "RestElement";
          }
          __name(Te, "Te");
          var Pe = /* @__PURE__ */ new WeakMap();
          function Fe(j2) {
            if (Pe.has(j2))
              return Pe.get(j2);
            let me = [];
            return j2.this && me.push(j2.this), Array.isArray(j2.parameters) ? me.push(...j2.parameters) : Array.isArray(j2.params) && me.push(...j2.params), j2.rest && me.push(j2.rest), Pe.set(j2, me), me;
          }
          __name(Fe, "Fe");
          function Ze(j2, me) {
            let Ie = j2.getValue(), je = 0, Ye = /* @__PURE__ */ __name((ut) => me(ut, je++), "Ye");
            Ie.this && j2.call(Ye, "this"), Array.isArray(Ie.parameters) ? j2.each(Ye, "parameters") : Array.isArray(Ie.params) && j2.each(Ye, "params"), Ie.rest && j2.call(Ye, "rest");
          }
          __name(Ze, "Ze");
          var xe = /* @__PURE__ */ new WeakMap();
          function Je(j2) {
            if (xe.has(j2))
              return xe.get(j2);
            let me = j2.arguments;
            return j2.type === "ImportExpression" && (me = [j2.source], j2.attributes && me.push(j2.attributes)), xe.set(j2, me), me;
          }
          __name(Je, "Je");
          function we(j2, me) {
            let Ie = j2.getValue();
            Ie.type === "ImportExpression" ? (j2.call((je) => me(je, 0), "source"), Ie.attributes && j2.call((je) => me(je, 1), "attributes")) : j2.each(me, "arguments");
          }
          __name(we, "we");
          function Le(j2) {
            return j2.value.trim() === "prettier-ignore" && !j2.unignore;
          }
          __name(Le, "Le");
          function Ve(j2) {
            return j2 && (j2.prettierIgnore || ue(j2, ke.PrettierIgnore));
          }
          __name(Ve, "Ve");
          function be(j2) {
            let me = j2.getValue();
            return Ve(me);
          }
          __name(be, "be");
          var ke = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, Me = /* @__PURE__ */ __name((j2, me) => {
            if (typeof j2 == "function" && (me = j2, j2 = 0), j2 || me)
              return (Ie, je, Ye) => !(j2 & ke.Leading && !Ie.leading || j2 & ke.Trailing && !Ie.trailing || j2 & ke.Dangling && (Ie.leading || Ie.trailing) || j2 & ke.Block && !g2(Ie) || j2 & ke.Line && !f2(Ie) || j2 & ke.First && je !== 0 || j2 & ke.Last && je !== Ye.length - 1 || j2 & ke.PrettierIgnore && !Le(Ie) || me && !me(Ie));
          }, "Me");
          function ue(j2, me, Ie) {
            if (!u2(j2 == null ? void 0 : j2.comments))
              return false;
            let je = Me(me, Ie);
            return je ? j2.comments.some(je) : true;
          }
          __name(ue, "ue");
          function st(j2, me, Ie) {
            if (!Array.isArray(j2 == null ? void 0 : j2.comments))
              return [];
            let je = Me(me, Ie);
            return je ? j2.comments.filter(je) : j2.comments;
          }
          __name(st, "st");
          var rt = /* @__PURE__ */ __name((j2, me) => {
            let { originalText: Ie } = me;
            return i2(Ie, y2(j2));
          }, "rt");
          function He(j2) {
            return oe(j2) || j2.type === "NewExpression" || j2.type === "ImportExpression";
          }
          __name(He, "He");
          function Ue(j2) {
            return j2 && (j2.type === "ObjectProperty" || j2.type === "Property" && !j2.method && j2.kind === "init");
          }
          __name(Ue, "Ue");
          function Xe(j2) {
            return Boolean(j2.__isUsingHackPipeline);
          }
          __name(Xe, "Xe");
          var at = Symbol("ifWithoutBlockAndSameLineComment");
          function nt(j2) {
            return j2.type === "TSAsExpression" || j2.type === "TSSatisfiesExpression";
          }
          __name(nt, "nt");
          n2.exports = { getFunctionParameters: Fe, iterateFunctionParametersPath: Ze, getCallArguments: Je, iterateCallArgumentsPath: we, hasRestParameter: Te, getLeftSide: I, getLeftSidePathName: P2, getParentExportDeclaration: m2, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: F, hasFlowShorthandAnnotationComment: T2, hasLeadingOwnLineComment: Z, hasNakedLeftSide: B, hasNode: A2, hasIgnoreComment: be, hasNodeIgnoreComment: Ve, identity: U2, isBinaryish: V, isCallLikeExpression: He, isEnabledHackPipeline: Xe, isLineComment: f2, isPrettierIgnoreComment: Le, isCallExpression: oe, isMemberExpression: ae, isExportDeclaration: x2, isFlowAnnotationComment: H, isFunctionCompositionArgs: pe, isFunctionNotation: J, isFunctionOrArrowExpression: b2, isGetterOrSetter: q, isJestEachTemplateLiteral: ge, isJsxNode: $, isLiteral: E2, isLongCurriedCallExpression: ie, isSimpleCallArgument: ve, isMemberish: O2, isNumericLiteral: o2, isSignedNumericLiteral: d2, isObjectProperty: Ue, isObjectType: _2, isObjectTypePropertyAFunction: L2, isSimpleType: se, isSimpleNumber: fe, isSimpleTemplateLiteral: Ae, isStringLiteral: C2, isStringPropSafeToUnquote: ne, isTemplateOnItsOwnLine: _e, isTestCall: X, isTheOnlyJsxElementInMarkdown: M2, isTSXFile: de, isTypeAnnotationAFunction: Y, isNextLineEmpty: rt, needsHardlineAfterDanglingComment: Oe, rawText: ce, shouldPrintComma: De, isBitwiseOperator: Re, shouldFlatten: S2, startsWithNoLookaheadToken: he, getPrecedence: te, hasComment: ue, getComments: st, CommentCheckFlags: ke, markerForIfWithoutBlockAndSameLineComment: at, isTSTypeExpression: nt };
        } }), jt = ee({ "src/language-js/print/template-literal.js"(e2, n2) {
          "use strict";
          re();
          var t2 = lt(), { getStringWidth: s2, getIndentSize: a2 } = Ge(), { builders: { join: r2, hardline: u2, softline: i2, group: l2, indent: c2, align: y2, lineSuffixBoundary: h3, addAlignmentToDoc: g2 }, printer: { printDocToString: p2 }, utils: { mapDoc: D } } = qe(), { isBinaryish: v2, isJestEachTemplateLiteral: w2, isSimpleTemplateLiteral: T2, hasComment: F, isMemberExpression: A2, isTSTypeExpression: B } = Ke();
          function I(E2, o2, d2) {
            let C2 = E2.getValue();
            if (C2.type === "TemplateLiteral" && w2(C2, E2.getParentNode())) {
              let M2 = P2(E2, d2, o2);
              if (M2)
                return M2;
            }
            let b2 = "expressions";
            C2.type === "TSTemplateLiteralType" && (b2 = "types");
            let N2 = [], k2 = E2.map(o2, b2), $ = T2(C2);
            return $ && (k2 = k2.map((M2) => p2(M2, Object.assign(Object.assign({}, d2), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), N2.push(h3, "`"), E2.each((M2) => {
              let q = M2.getName();
              if (N2.push(o2()), q < k2.length) {
                let { tabWidth: J } = d2, L2 = M2.getValue(), Y = a2(L2.value.raw, J), V = k2[q];
                if (!$) {
                  let K = C2[b2][q];
                  (F(K) || A2(K) || K.type === "ConditionalExpression" || K.type === "SequenceExpression" || B(K) || v2(K)) && (V = [c2([i2, V]), i2]);
                }
                let O2 = Y === 0 && L2.value.raw.endsWith(`
`) ? y2(Number.NEGATIVE_INFINITY, V) : g2(V, Y, J);
                N2.push(l2(["${", O2, h3, "}"]));
              }
            }, "quasis"), N2.push("`"), N2;
          }
          __name(I, "I");
          function P2(E2, o2, d2) {
            let C2 = E2.getNode(), _2 = C2.quasis[0].value.raw.trim().split(/\s*\|\s*/);
            if (_2.length > 1 || _2.some((b2) => b2.length > 0)) {
              o2.__inJestEach = true;
              let b2 = E2.map(d2, "expressions");
              o2.__inJestEach = false;
              let N2 = [], k2 = b2.map((L2) => "${" + p2(L2, Object.assign(Object.assign({}, o2), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), $ = [{ hasLineBreak: false, cells: [] }];
              for (let L2 = 1; L2 < C2.quasis.length; L2++) {
                let Y = t2($), V = k2[L2 - 1];
                Y.cells.push(V), V.includes(`
`) && (Y.hasLineBreak = true), C2.quasis[L2].value.raw.includes(`
`) && $.push({ hasLineBreak: false, cells: [] });
              }
              let M2 = Math.max(_2.length, ...$.map((L2) => L2.cells.length)), q = Array.from({ length: M2 }).fill(0), J = [{ cells: _2 }, ...$.filter((L2) => L2.cells.length > 0)];
              for (let { cells: L2 } of J.filter((Y) => !Y.hasLineBreak))
                for (let [Y, V] of L2.entries())
                  q[Y] = Math.max(q[Y], s2(V));
              return N2.push(h3, "`", c2([u2, r2(u2, J.map((L2) => r2(" | ", L2.cells.map((Y, V) => L2.hasLineBreak ? Y : Y + " ".repeat(q[V] - s2(Y))))))]), u2, "`"), N2;
            }
          }
          __name(P2, "P");
          function R2(E2, o2) {
            let d2 = E2.getValue(), C2 = o2();
            return F(d2) && (C2 = l2([c2([i2, C2]), i2])), ["${", C2, h3, "}"];
          }
          __name(R2, "R");
          function f2(E2, o2) {
            return E2.map((d2) => R2(d2, o2), "expressions");
          }
          __name(f2, "f");
          function x2(E2, o2) {
            return D(E2, (d2) => typeof d2 == "string" ? o2 ? d2.replace(/(\\*)`/g, "$1$1\\`") : m2(d2) : d2);
          }
          __name(x2, "x");
          function m2(E2) {
            return E2.replace(/([\\`]|\${)/g, "\\$1");
          }
          __name(m2, "m");
          n2.exports = { printTemplateLiteral: I, printTemplateExpressions: f2, escapeTemplateCharacters: x2, uncookTemplateElementValue: m2 };
        } }), xm = ee({ "src/language-js/embed/markdown.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { indent: t2, softline: s2, literalline: a2, dedentToRoot: r2 } } = qe(), { escapeTemplateCharacters: u2 } = jt();
          function i2(c2, y2, h3) {
            let p2 = c2.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (T2, F) => "\\".repeat(F.length / 2) + "`"), D = l2(p2), v2 = D !== "";
            v2 && (p2 = p2.replace(new RegExp(`^${D}`, "gm"), ""));
            let w2 = u2(h3(p2, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
            return ["`", v2 ? t2([s2, w2]) : [a2, r2(w2)], s2, "`"];
          }
          __name(i2, "i");
          function l2(c2) {
            let y2 = c2.match(/^([^\S\n]*)\S/m);
            return y2 === null ? "" : y2[1];
          }
          __name(l2, "l");
          n2.exports = i2;
        } }), bm = ee({ "src/language-js/embed/css.js"(e2, n2) {
          "use strict";
          re();
          var { isNonEmptyArray: t2 } = Ge(), { builders: { indent: s2, hardline: a2, softline: r2 }, utils: { mapDoc: u2, replaceEndOfLine: i2, cleanDoc: l2 } } = qe(), { printTemplateExpressions: c2 } = jt();
          function y2(p2, D, v2) {
            let w2 = p2.getValue(), T2 = w2.quasis.map((P2) => P2.value.raw), F = 0, A2 = T2.reduce((P2, R2, f2) => f2 === 0 ? R2 : P2 + "@prettier-placeholder-" + F++ + "-id" + R2, ""), B = v2(A2, { parser: "scss" }, { stripTrailingHardline: true }), I = c2(p2, D);
            return h3(B, w2, I);
          }
          __name(y2, "y");
          function h3(p2, D, v2) {
            if (D.quasis.length === 1 && !D.quasis[0].value.raw.trim())
              return "``";
            let T2 = g2(p2, v2);
            if (!T2)
              throw new Error("Couldn't insert all the expressions");
            return ["`", s2([a2, T2]), r2, "`"];
          }
          __name(h3, "h");
          function g2(p2, D) {
            if (!t2(D))
              return p2;
            let v2 = 0, w2 = u2(l2(p2), (T2) => typeof T2 != "string" || !T2.includes("@prettier-placeholder") ? T2 : T2.split(/@prettier-placeholder-(\d+)-id/).map((F, A2) => A2 % 2 === 0 ? i2(F) : (v2++, D[F])));
            return D.length === v2 ? w2 : null;
          }
          __name(g2, "g");
          n2.exports = y2;
        } }), Tm = ee({ "src/language-js/embed/graphql.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { indent: t2, join: s2, hardline: a2 } } = qe(), { escapeTemplateCharacters: r2, printTemplateExpressions: u2 } = jt();
          function i2(c2, y2, h3) {
            let g2 = c2.getValue(), p2 = g2.quasis.length;
            if (p2 === 1 && g2.quasis[0].value.raw.trim() === "")
              return "``";
            let D = u2(c2, y2), v2 = [];
            for (let w2 = 0; w2 < p2; w2++) {
              let T2 = g2.quasis[w2], F = w2 === 0, A2 = w2 === p2 - 1, B = T2.value.cooked, I = B.split(`
`), P2 = I.length, R2 = D[w2], f2 = P2 > 2 && I[0].trim() === "" && I[1].trim() === "", x2 = P2 > 2 && I[P2 - 1].trim() === "" && I[P2 - 2].trim() === "", m2 = I.every((o2) => /^\s*(?:#[^\n\r]*)?$/.test(o2));
              if (!A2 && /#[^\n\r]*$/.test(I[P2 - 1]))
                return null;
              let E2 = null;
              m2 ? E2 = l2(I) : E2 = h3(B, { parser: "graphql" }, { stripTrailingHardline: true }), E2 ? (E2 = r2(E2, false), !F && f2 && v2.push(""), v2.push(E2), !A2 && x2 && v2.push("")) : !F && !A2 && f2 && v2.push(""), R2 && v2.push(R2);
            }
            return ["`", t2([a2, s2(a2, v2)]), a2, "`"];
          }
          __name(i2, "i");
          function l2(c2) {
            let y2 = [], h3 = false, g2 = c2.map((p2) => p2.trim());
            for (let [p2, D] of g2.entries())
              D !== "" && (g2[p2 - 1] === "" && h3 ? y2.push([a2, D]) : y2.push(D), h3 = true);
            return y2.length === 0 ? null : s2(a2, y2);
          }
          __name(l2, "l");
          n2.exports = i2;
        } }), Bm = ee({ "src/language-js/embed/html.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { indent: t2, line: s2, hardline: a2, group: r2 }, utils: { mapDoc: u2 } } = qe(), { printTemplateExpressions: i2, uncookTemplateElementValue: l2 } = jt(), c2 = 0;
          function y2(h3, g2, p2, D, v2) {
            let { parser: w2 } = v2, T2 = h3.getValue(), F = c2;
            c2 = c2 + 1 >>> 0;
            let A2 = /* @__PURE__ */ __name((d2) => `PRETTIER_HTML_PLACEHOLDER_${d2}_${F}_IN_JS`, "A"), B = T2.quasis.map((d2, C2, _2) => C2 === _2.length - 1 ? d2.value.cooked : d2.value.cooked + A2(C2)).join(""), I = i2(h3, g2);
            if (I.length === 0 && B.trim().length === 0)
              return "``";
            let P2 = new RegExp(A2("(\\d+)"), "g"), R2 = 0, f2 = p2(B, { parser: w2, __onHtmlRoot(d2) {
              R2 = d2.children.length;
            } }, { stripTrailingHardline: true }), x2 = u2(f2, (d2) => {
              if (typeof d2 != "string")
                return d2;
              let C2 = [], _2 = d2.split(P2);
              for (let b2 = 0; b2 < _2.length; b2++) {
                let N2 = _2[b2];
                if (b2 % 2 === 0) {
                  N2 && (N2 = l2(N2), D.__embeddedInHtml && (N2 = N2.replace(/<\/(script)\b/gi, "<\\/$1")), C2.push(N2));
                  continue;
                }
                let k2 = Number(N2);
                C2.push(I[k2]);
              }
              return C2;
            }), m2 = /^\s/.test(B) ? " " : "", E2 = /\s$/.test(B) ? " " : "", o2 = D.htmlWhitespaceSensitivity === "ignore" ? a2 : m2 && E2 ? s2 : null;
            return r2(o2 ? ["`", t2([o2, r2(x2)]), o2, "`"] : ["`", m2, R2 > 1 ? t2(r2(x2)) : r2(x2), E2, "`"]);
          }
          __name(y2, "y");
          n2.exports = y2;
        } }), Nm = ee({ "src/language-js/embed.js"(e2, n2) {
          "use strict";
          re();
          var { hasComment: t2, CommentCheckFlags: s2, isObjectProperty: a2 } = Ke(), r2 = xm(), u2 = bm(), i2 = Tm(), l2 = Bm();
          function c2(f2) {
            if (g2(f2) || w2(f2) || T2(f2) || p2(f2))
              return "css";
            if (B(f2))
              return "graphql";
            if (P2(f2))
              return "html";
            if (D(f2))
              return "angular";
            if (h3(f2))
              return "markdown";
          }
          __name(c2, "c");
          function y2(f2, x2, m2, E2) {
            let o2 = f2.getValue();
            if (o2.type !== "TemplateLiteral" || R2(o2))
              return;
            let d2 = c2(f2);
            if (!!d2) {
              if (d2 === "markdown")
                return r2(f2, x2, m2);
              if (d2 === "css")
                return u2(f2, x2, m2);
              if (d2 === "graphql")
                return i2(f2, x2, m2);
              if (d2 === "html" || d2 === "angular")
                return l2(f2, x2, m2, E2, { parser: d2 });
            }
          }
          __name(y2, "y");
          function h3(f2) {
            let x2 = f2.getValue(), m2 = f2.getParentNode();
            return m2 && m2.type === "TaggedTemplateExpression" && x2.quasis.length === 1 && m2.tag.type === "Identifier" && (m2.tag.name === "md" || m2.tag.name === "markdown");
          }
          __name(h3, "h");
          function g2(f2) {
            let x2 = f2.getValue(), m2 = f2.getParentNode(), E2 = f2.getParentNode(1);
            return E2 && x2.quasis && m2.type === "JSXExpressionContainer" && E2.type === "JSXElement" && E2.openingElement.name.name === "style" && E2.openingElement.attributes.some((o2) => o2.name.name === "jsx") || m2 && m2.type === "TaggedTemplateExpression" && m2.tag.type === "Identifier" && m2.tag.name === "css" || m2 && m2.type === "TaggedTemplateExpression" && m2.tag.type === "MemberExpression" && m2.tag.object.name === "css" && (m2.tag.property.name === "global" || m2.tag.property.name === "resolve");
          }
          __name(g2, "g");
          function p2(f2) {
            return f2.match((x2) => x2.type === "TemplateLiteral", (x2, m2) => x2.type === "ArrayExpression" && m2 === "elements", (x2, m2) => a2(x2) && x2.key.type === "Identifier" && x2.key.name === "styles" && m2 === "value", ...v2);
          }
          __name(p2, "p");
          function D(f2) {
            return f2.match((x2) => x2.type === "TemplateLiteral", (x2, m2) => a2(x2) && x2.key.type === "Identifier" && x2.key.name === "template" && m2 === "value", ...v2);
          }
          __name(D, "D");
          var v2 = [(f2, x2) => f2.type === "ObjectExpression" && x2 === "properties", (f2, x2) => f2.type === "CallExpression" && f2.callee.type === "Identifier" && f2.callee.name === "Component" && x2 === "arguments", (f2, x2) => f2.type === "Decorator" && x2 === "expression"];
          function w2(f2) {
            let x2 = f2.getParentNode();
            if (!x2 || x2.type !== "TaggedTemplateExpression")
              return false;
            let m2 = x2.tag.type === "ParenthesizedExpression" ? x2.tag.expression : x2.tag;
            switch (m2.type) {
              case "MemberExpression":
                return F(m2.object) || A2(m2);
              case "CallExpression":
                return F(m2.callee) || m2.callee.type === "MemberExpression" && (m2.callee.object.type === "MemberExpression" && (F(m2.callee.object.object) || A2(m2.callee.object)) || m2.callee.object.type === "CallExpression" && F(m2.callee.object.callee));
              case "Identifier":
                return m2.name === "css";
              default:
                return false;
            }
          }
          __name(w2, "w");
          function T2(f2) {
            let x2 = f2.getParentNode(), m2 = f2.getParentNode(1);
            return m2 && x2.type === "JSXExpressionContainer" && m2.type === "JSXAttribute" && m2.name.type === "JSXIdentifier" && m2.name.name === "css";
          }
          __name(T2, "T");
          function F(f2) {
            return f2.type === "Identifier" && f2.name === "styled";
          }
          __name(F, "F");
          function A2(f2) {
            return /^[A-Z]/.test(f2.object.name) && f2.property.name === "extend";
          }
          __name(A2, "A");
          function B(f2) {
            let x2 = f2.getValue(), m2 = f2.getParentNode();
            return I(x2, "GraphQL") || m2 && (m2.type === "TaggedTemplateExpression" && (m2.tag.type === "MemberExpression" && m2.tag.object.name === "graphql" && m2.tag.property.name === "experimental" || m2.tag.type === "Identifier" && (m2.tag.name === "gql" || m2.tag.name === "graphql")) || m2.type === "CallExpression" && m2.callee.type === "Identifier" && m2.callee.name === "graphql");
          }
          __name(B, "B");
          function I(f2, x2) {
            return t2(f2, s2.Block | s2.Leading, (m2) => {
              let { value: E2 } = m2;
              return E2 === ` ${x2} `;
            });
          }
          __name(I, "I");
          function P2(f2) {
            return I(f2.getValue(), "HTML") || f2.match((x2) => x2.type === "TemplateLiteral", (x2, m2) => x2.type === "TaggedTemplateExpression" && x2.tag.type === "Identifier" && x2.tag.name === "html" && m2 === "quasi");
          }
          __name(P2, "P");
          function R2(f2) {
            let { quasis: x2 } = f2;
            return x2.some((m2) => {
              let { value: { cooked: E2 } } = m2;
              return E2 === null;
            });
          }
          __name(R2, "R");
          n2.exports = y2;
        } }), wm = ee({ "src/language-js/clean.js"(e2, n2) {
          "use strict";
          re();
          var t2 = Lt(), s2 = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a2 = /* @__PURE__ */ __name((u2) => {
            for (let i2 of u2.quasis)
              delete i2.value;
          }, "a");
          function r2(u2, i2, l2) {
            if (u2.type === "Program" && delete i2.sourceType, (u2.type === "BigIntLiteral" || u2.type === "BigIntLiteralTypeAnnotation") && i2.value && (i2.value = i2.value.toLowerCase()), (u2.type === "BigIntLiteral" || u2.type === "Literal") && i2.bigint && (i2.bigint = i2.bigint.toLowerCase()), u2.type === "DecimalLiteral" && (i2.value = Number(i2.value)), u2.type === "Literal" && i2.decimal && (i2.decimal = Number(i2.decimal)), u2.type === "EmptyStatement" || u2.type === "JSXText" || u2.type === "JSXExpressionContainer" && (u2.expression.type === "Literal" || u2.expression.type === "StringLiteral") && u2.expression.value === " ")
              return null;
            if ((u2.type === "Property" || u2.type === "ObjectProperty" || u2.type === "MethodDefinition" || u2.type === "ClassProperty" || u2.type === "ClassMethod" || u2.type === "PropertyDefinition" || u2.type === "TSDeclareMethod" || u2.type === "TSPropertySignature" || u2.type === "ObjectTypeProperty") && typeof u2.key == "object" && u2.key && (u2.key.type === "Literal" || u2.key.type === "NumericLiteral" || u2.key.type === "StringLiteral" || u2.key.type === "Identifier") && delete i2.key, u2.type === "JSXElement" && u2.openingElement.name.name === "style" && u2.openingElement.attributes.some((h3) => h3.name.name === "jsx"))
              for (let { type: h3, expression: g2 } of i2.children)
                h3 === "JSXExpressionContainer" && g2.type === "TemplateLiteral" && a2(g2);
            u2.type === "JSXAttribute" && u2.name.name === "css" && u2.value.type === "JSXExpressionContainer" && u2.value.expression.type === "TemplateLiteral" && a2(i2.value.expression), u2.type === "JSXAttribute" && u2.value && u2.value.type === "Literal" && /["']|&quot;|&apos;/.test(u2.value.value) && (i2.value.value = i2.value.value.replace(/["']|&quot;|&apos;/g, '"'));
            let c2 = u2.expression || u2.callee;
            if (u2.type === "Decorator" && c2.type === "CallExpression" && c2.callee.name === "Component" && c2.arguments.length === 1) {
              let h3 = u2.expression.arguments[0].properties;
              for (let [g2, p2] of i2.expression.arguments[0].properties.entries())
                switch (h3[g2].key.name) {
                  case "styles":
                    p2.value.type === "ArrayExpression" && a2(p2.value.elements[0]);
                    break;
                  case "template":
                    p2.value.type === "TemplateLiteral" && a2(p2.value);
                    break;
                }
            }
            if (u2.type === "TaggedTemplateExpression" && (u2.tag.type === "MemberExpression" || u2.tag.type === "Identifier" && (u2.tag.name === "gql" || u2.tag.name === "graphql" || u2.tag.name === "css" || u2.tag.name === "md" || u2.tag.name === "markdown" || u2.tag.name === "html") || u2.tag.type === "CallExpression") && a2(i2.quasi), u2.type === "TemplateLiteral") {
              var y2;
              (((y2 = u2.leadingComments) === null || y2 === void 0 ? void 0 : y2.some((g2) => t2(g2) && ["GraphQL", "HTML"].some((p2) => g2.value === ` ${p2} `))) || l2.type === "CallExpression" && l2.callee.name === "graphql" || !u2.leadingComments) && a2(i2);
            }
            if (u2.type === "InterpreterDirective" && (i2.value = i2.value.trimEnd()), (u2.type === "TSIntersectionType" || u2.type === "TSUnionType") && u2.types.length === 1)
              return i2.types[0];
          }
          __name(r2, "r");
          r2.ignoredProperties = s2, n2.exports = r2;
        } }), Ma = {};
        zt(Ma, { EOL: () => kn, arch: () => _m, cpus: () => Ua, default: () => Ya, endianness: () => Ra, freemem: () => Ha, getNetworkInterfaces: () => Ka, hostname: () => $a, loadavg: () => Va, networkInterfaces: () => Xa, platform: () => Pm, release: () => za, tmpDir: () => Pn, tmpdir: () => In, totalmem: () => Ga, type: () => Ja, uptime: () => Wa });
        function Ra() {
          if (typeof br > "u") {
            var e2 = new ArrayBuffer(2), n2 = new Uint8Array(e2), t2 = new Uint16Array(e2);
            if (n2[0] = 1, n2[1] = 2, t2[0] === 258)
              br = "BE";
            else if (t2[0] === 513)
              br = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return br;
        }
        __name(Ra, "Ra");
        function $a() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        __name($a, "$a");
        function Va() {
          return [];
        }
        __name(Va, "Va");
        function Wa() {
          return 0;
        }
        __name(Wa, "Wa");
        function Ha() {
          return Number.MAX_VALUE;
        }
        __name(Ha, "Ha");
        function Ga() {
          return Number.MAX_VALUE;
        }
        __name(Ga, "Ga");
        function Ua() {
          return [];
        }
        __name(Ua, "Ua");
        function Ja() {
          return "Browser";
        }
        __name(Ja, "Ja");
        function za() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        __name(za, "za");
        function Xa() {
        }
        __name(Xa, "Xa");
        function Ka() {
        }
        __name(Ka, "Ka");
        function _m() {
          return "javascript";
        }
        __name(_m, "_m");
        function Pm() {
          return "browser";
        }
        __name(Pm, "Pm");
        function Pn() {
          return "/tmp";
        }
        __name(Pn, "Pn");
        var br, In, kn, Ya, Im = gt({ "node-modules-polyfills:os"() {
          re(), In = Pn, kn = `
`, Ya = { EOL: kn, tmpdir: In, tmpDir: Pn, networkInterfaces: Xa, getNetworkInterfaces: Ka, release: za, type: Ja, cpus: Ua, totalmem: Ga, freemem: Ha, uptime: Wa, loadavg: Va, hostname: $a, endianness: Ra };
        } }), km = ee({ "node-modules-polyfills-commonjs:os"(e2, n2) {
          re();
          var t2 = (Im(), ft(Ma));
          if (t2 && t2.default) {
            n2.exports = t2.default;
            for (let s2 in t2)
              n2.exports[s2] = t2[s2];
          } else
            t2 && (n2.exports = t2);
        } }), Lm = ee({ "node_modules/detect-newline/index.js"(e2, n2) {
          "use strict";
          re();
          var t2 = /* @__PURE__ */ __name((s2) => {
            if (typeof s2 != "string")
              throw new TypeError("Expected a string");
            let a2 = s2.match(/(?:\r?\n)/g) || [];
            if (a2.length === 0)
              return;
            let r2 = a2.filter((i2) => i2 === `\r
`).length, u2 = a2.length - r2;
            return r2 > u2 ? `\r
` : `
`;
          }, "t");
          n2.exports = t2, n2.exports.graceful = (s2) => typeof s2 == "string" && t2(s2) || `
`;
        } }), jm = ee({ "node_modules/jest-docblock/build/index.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true }), e2.extract = p2, e2.parse = v2, e2.parseWithComments = w2, e2.print = T2, e2.strip = D;
          function n2() {
            let A2 = km();
            return n2 = /* @__PURE__ */ __name(function() {
              return A2;
            }, "n"), A2;
          }
          __name(n2, "n");
          function t2() {
            let A2 = s2(Lm());
            return t2 = /* @__PURE__ */ __name(function() {
              return A2;
            }, "t"), A2;
          }
          __name(t2, "t");
          function s2(A2) {
            return A2 && A2.__esModule ? A2 : { default: A2 };
          }
          __name(s2, "s");
          var a2 = /\*\/$/, r2 = /^\/\*\*?/, u2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i2 = /(^|\s+)\/\/([^\r\n]*)/g, l2 = /^(\r?\n)+/, c2 = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, y2 = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, h3 = /(\r?\n|^) *\* ?/g, g2 = [];
          function p2(A2) {
            let B = A2.match(u2);
            return B ? B[0].trimLeft() : "";
          }
          __name(p2, "p");
          function D(A2) {
            let B = A2.match(u2);
            return B && B[0] ? A2.substring(B[0].length) : A2;
          }
          __name(D, "D");
          function v2(A2) {
            return w2(A2).pragmas;
          }
          __name(v2, "v");
          function w2(A2) {
            let B = (0, t2().default)(A2) || n2().EOL;
            A2 = A2.replace(r2, "").replace(a2, "").replace(h3, "$1");
            let I = "";
            for (; I !== A2; )
              I = A2, A2 = A2.replace(c2, `${B}$1 $2${B}`);
            A2 = A2.replace(l2, "").trimRight();
            let P2 = /* @__PURE__ */ Object.create(null), R2 = A2.replace(y2, "").replace(l2, "").trimRight(), f2;
            for (; f2 = y2.exec(A2); ) {
              let x2 = f2[2].replace(i2, "");
              typeof P2[f2[1]] == "string" || Array.isArray(P2[f2[1]]) ? P2[f2[1]] = g2.concat(P2[f2[1]], x2) : P2[f2[1]] = x2;
            }
            return { comments: R2, pragmas: P2 };
          }
          __name(w2, "w");
          function T2(A2) {
            let { comments: B = "", pragmas: I = {} } = A2, P2 = (0, t2().default)(B) || n2().EOL, R2 = "/**", f2 = " *", x2 = " */", m2 = Object.keys(I), E2 = m2.map((d2) => F(d2, I[d2])).reduce((d2, C2) => d2.concat(C2), []).map((d2) => `${f2} ${d2}${P2}`).join("");
            if (!B) {
              if (m2.length === 0)
                return "";
              if (m2.length === 1 && !Array.isArray(I[m2[0]])) {
                let d2 = I[m2[0]];
                return `${R2} ${F(m2[0], d2)[0]}${x2}`;
              }
            }
            let o2 = B.split(P2).map((d2) => `${f2} ${d2}`).join(P2) + P2;
            return R2 + P2 + (B ? o2 : "") + (B && m2.length ? f2 + P2 : "") + E2 + x2;
          }
          __name(T2, "T");
          function F(A2, B) {
            return g2.concat(B).map((I) => `@${A2} ${I}`.trim());
          }
          __name(F, "F");
        } }), Om = ee({ "src/language-js/utils/get-shebang.js"(e2, n2) {
          "use strict";
          re();
          function t2(s2) {
            if (!s2.startsWith("#!"))
              return "";
            let a2 = s2.indexOf(`
`);
            return a2 === -1 ? s2 : s2.slice(0, a2);
          }
          __name(t2, "t");
          n2.exports = t2;
        } }), Qa = ee({ "src/language-js/pragma.js"(e2, n2) {
          "use strict";
          re();
          var { parseWithComments: t2, strip: s2, extract: a2, print: r2 } = jm(), { normalizeEndOfLine: u2 } = qn(), i2 = Om();
          function l2(h3) {
            let g2 = i2(h3);
            g2 && (h3 = h3.slice(g2.length + 1));
            let p2 = a2(h3), { pragmas: D, comments: v2 } = t2(p2);
            return { shebang: g2, text: h3, pragmas: D, comments: v2 };
          }
          __name(l2, "l");
          function c2(h3) {
            let g2 = Object.keys(l2(h3).pragmas);
            return g2.includes("prettier") || g2.includes("format");
          }
          __name(c2, "c");
          function y2(h3) {
            let { shebang: g2, text: p2, pragmas: D, comments: v2 } = l2(h3), w2 = s2(p2), T2 = r2({ pragmas: Object.assign({ format: "" }, D), comments: v2.trimStart() });
            return (g2 ? `${g2}
` : "") + u2(T2) + (w2.startsWith(`
`) ? `
` : `

`) + w2;
          }
          __name(y2, "y");
          n2.exports = { hasPragma: c2, insertPragma: y2 };
        } }), Za = ee({ "src/language-js/comments.js"(e2, n2) {
          "use strict";
          re();
          var { getLast: t2, hasNewline: s2, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a2, getNextNonSpaceNonCommentCharacter: r2, hasNewlineInRange: u2, addLeadingComment: i2, addTrailingComment: l2, addDanglingComment: c2, getNextNonSpaceNonCommentCharacterIndex: y2, isNonEmptyArray: h3 } = Ge(), { getFunctionParameters: g2, isPrettierIgnoreComment: p2, isJsxNode: D, hasFlowShorthandAnnotationComment: v2, hasFlowAnnotationComment: w2, hasIgnoreComment: T2, isCallLikeExpression: F, getCallArguments: A2, isCallExpression: B, isMemberExpression: I, isObjectProperty: P2, isLineComment: R2, getComments: f2, CommentCheckFlags: x2, markerForIfWithoutBlockAndSameLineComment: m2 } = Ke(), { locStart: E2, locEnd: o2 } = it(), d2 = Lt();
          function C2(ye) {
            return [ce, ae, L2, M2, q, J, K, ge, Z, fe, Ce, _e, Q, Ae, z].some((S2) => S2(ye));
          }
          __name(C2, "C");
          function _2(ye) {
            return [$, ae, Y, Ce, M2, q, J, K, Ae, H, ne, fe, ie, z, de].some((S2) => S2(ye));
          }
          __name(_2, "_");
          function b2(ye) {
            return [ce, M2, q, V, oe, Q, fe, X, W2, U2, z, ve].some((S2) => S2(ye));
          }
          __name(b2, "b");
          function N2(ye, S2) {
            let G = (ye.body || ye.properties).find((te) => {
              let { type: Ee } = te;
              return Ee !== "EmptyStatement";
            });
            G ? i2(G, S2) : c2(ye, S2);
          }
          __name(N2, "N");
          function k2(ye, S2) {
            ye.type === "BlockStatement" ? N2(ye, S2) : i2(ye, S2);
          }
          __name(k2, "k");
          function $(ye) {
            let { comment: S2, followingNode: G } = ye;
            return G && Be(S2) ? (i2(G, S2), true) : false;
          }
          __name($, "$");
          function M2(ye) {
            let { comment: S2, precedingNode: G, enclosingNode: te, followingNode: Ee, text: Re } = ye;
            if ((te == null ? void 0 : te.type) !== "IfStatement" || !Ee)
              return false;
            if (r2(Re, S2, o2) === ")")
              return l2(G, S2), true;
            if (G === te.consequent && Ee === te.alternate) {
              if (G.type === "BlockStatement")
                l2(G, S2);
              else {
                let Pe = S2.type === "SingleLine" || S2.loc.start.line === S2.loc.end.line, Fe = S2.loc.start.line === G.loc.start.line;
                Pe && Fe ? c2(G, S2, m2) : c2(te, S2);
              }
              return true;
            }
            return Ee.type === "BlockStatement" ? (N2(Ee, S2), true) : Ee.type === "IfStatement" ? (k2(Ee.consequent, S2), true) : te.consequent === Ee ? (i2(Ee, S2), true) : false;
          }
          __name(M2, "M");
          function q(ye) {
            let { comment: S2, precedingNode: G, enclosingNode: te, followingNode: Ee, text: Re } = ye;
            return (te == null ? void 0 : te.type) !== "WhileStatement" || !Ee ? false : r2(Re, S2, o2) === ")" ? (l2(G, S2), true) : Ee.type === "BlockStatement" ? (N2(Ee, S2), true) : te.body === Ee ? (i2(Ee, S2), true) : false;
          }
          __name(q, "q");
          function J(ye) {
            let { comment: S2, precedingNode: G, enclosingNode: te, followingNode: Ee } = ye;
            return (te == null ? void 0 : te.type) !== "TryStatement" && (te == null ? void 0 : te.type) !== "CatchClause" || !Ee ? false : te.type === "CatchClause" && G ? (l2(G, S2), true) : Ee.type === "BlockStatement" ? (N2(Ee, S2), true) : Ee.type === "TryStatement" ? (k2(Ee.finalizer, S2), true) : Ee.type === "CatchClause" ? (k2(Ee.body, S2), true) : false;
          }
          __name(J, "J");
          function L2(ye) {
            let { comment: S2, enclosingNode: G, followingNode: te } = ye;
            return I(G) && (te == null ? void 0 : te.type) === "Identifier" ? (i2(G, S2), true) : false;
          }
          __name(L2, "L");
          function Y(ye) {
            let { comment: S2, precedingNode: G, enclosingNode: te, followingNode: Ee, text: Re } = ye, Te = G && !u2(Re, o2(G), E2(S2));
            return (!G || !Te) && ((te == null ? void 0 : te.type) === "ConditionalExpression" || (te == null ? void 0 : te.type) === "TSConditionalType") && Ee ? (i2(Ee, S2), true) : false;
          }
          __name(Y, "Y");
          function V(ye) {
            let { comment: S2, precedingNode: G, enclosingNode: te } = ye;
            return P2(te) && te.shorthand && te.key === G && te.value.type === "AssignmentPattern" ? (l2(te.value.left, S2), true) : false;
          }
          __name(V, "V");
          var O2 = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
          function K(ye) {
            let { comment: S2, precedingNode: G, enclosingNode: te, followingNode: Ee } = ye;
            if (O2.has(te == null ? void 0 : te.type)) {
              if (h3(te.decorators) && !(Ee && Ee.type === "Decorator"))
                return l2(t2(te.decorators), S2), true;
              if (te.body && Ee === te.body)
                return N2(te.body, S2), true;
              if (Ee) {
                if (te.superClass && Ee === te.superClass && G && (G === te.id || G === te.typeParameters))
                  return l2(G, S2), true;
                for (let Re of ["implements", "extends", "mixins"])
                  if (te[Re] && Ee === te[Re][0])
                    return G && (G === te.id || G === te.typeParameters || G === te.superClass) ? l2(G, S2) : c2(te, S2, Re), true;
              }
            }
            return false;
          }
          __name(K, "K");
          var se = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition"]);
          function Q(ye) {
            let { comment: S2, precedingNode: G, enclosingNode: te, text: Ee } = ye;
            return te && G && r2(Ee, S2, o2) === "(" && (te.type === "Property" || te.type === "TSDeclareMethod" || te.type === "TSAbstractMethodDefinition") && G.type === "Identifier" && te.key === G && r2(Ee, G, o2) !== ":" || (G == null ? void 0 : G.type) === "Decorator" && se.has(te == null ? void 0 : te.type) ? (l2(G, S2), true) : false;
          }
          __name(Q, "Q");
          var le = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
          function W2(ye) {
            let { comment: S2, precedingNode: G, enclosingNode: te, text: Ee } = ye;
            return r2(Ee, S2, o2) !== "(" ? false : G && le.has(te == null ? void 0 : te.type) ? (l2(G, S2), true) : false;
          }
          __name(W2, "W");
          function X(ye) {
            let { comment: S2, enclosingNode: G, text: te } = ye;
            if ((G == null ? void 0 : G.type) !== "ArrowFunctionExpression")
              return false;
            let Ee = y2(te, S2, o2);
            return Ee !== false && te.slice(Ee, Ee + 2) === "=>" ? (c2(G, S2), true) : false;
          }
          __name(X, "X");
          function oe(ye) {
            let { comment: S2, enclosingNode: G, text: te } = ye;
            return r2(te, S2, o2) !== ")" ? false : G && (De(G) && g2(G).length === 0 || F(G) && A2(G).length === 0) ? (c2(G, S2), true) : ((G == null ? void 0 : G.type) === "MethodDefinition" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && g2(G.value).length === 0 ? (c2(G.value, S2), true) : false;
          }
          __name(oe, "oe");
          function ae(ye) {
            let { comment: S2, precedingNode: G, enclosingNode: te, followingNode: Ee, text: Re } = ye;
            if ((G == null ? void 0 : G.type) === "FunctionTypeParam" && (te == null ? void 0 : te.type) === "FunctionTypeAnnotation" && (Ee == null ? void 0 : Ee.type) !== "FunctionTypeParam" || ((G == null ? void 0 : G.type) === "Identifier" || (G == null ? void 0 : G.type) === "AssignmentPattern") && te && De(te) && r2(Re, S2, o2) === ")")
              return l2(G, S2), true;
            if ((te == null ? void 0 : te.type) === "FunctionDeclaration" && (Ee == null ? void 0 : Ee.type) === "BlockStatement") {
              let Te = (() => {
                let Pe = g2(te);
                if (Pe.length > 0)
                  return a2(Re, o2(t2(Pe)));
                let Fe = a2(Re, o2(te.id));
                return Fe !== false && a2(Re, Fe + 1);
              })();
              if (E2(S2) > Te)
                return N2(Ee, S2), true;
            }
            return false;
          }
          __name(ae, "ae");
          function Ae(ye) {
            let { comment: S2, enclosingNode: G } = ye;
            return (G == null ? void 0 : G.type) === "LabeledStatement" ? (i2(G, S2), true) : false;
          }
          __name(Ae, "Ae");
          function z(ye) {
            let { comment: S2, enclosingNode: G } = ye;
            return ((G == null ? void 0 : G.type) === "ContinueStatement" || (G == null ? void 0 : G.type) === "BreakStatement") && !G.label ? (l2(G, S2), true) : false;
          }
          __name(z, "z");
          function H(ye) {
            let { comment: S2, precedingNode: G, enclosingNode: te } = ye;
            return B(te) && G && te.callee === G && te.arguments.length > 0 ? (i2(te.arguments[0], S2), true) : false;
          }
          __name(H, "H");
          function Z(ye) {
            let { comment: S2, precedingNode: G, enclosingNode: te, followingNode: Ee } = ye;
            return (te == null ? void 0 : te.type) === "UnionTypeAnnotation" || (te == null ? void 0 : te.type) === "TSUnionType" ? (p2(S2) && (Ee.prettierIgnore = true, S2.unignore = true), G ? (l2(G, S2), true) : false) : (((Ee == null ? void 0 : Ee.type) === "UnionTypeAnnotation" || (Ee == null ? void 0 : Ee.type) === "TSUnionType") && p2(S2) && (Ee.types[0].prettierIgnore = true, S2.unignore = true), false);
          }
          __name(Z, "Z");
          function ne(ye) {
            let { comment: S2, enclosingNode: G } = ye;
            return P2(G) ? (i2(G, S2), true) : false;
          }
          __name(ne, "ne");
          function fe(ye) {
            let { comment: S2, enclosingNode: G, followingNode: te, ast: Ee, isLastComment: Re } = ye;
            return Ee && Ee.body && Ee.body.length === 0 ? (Re ? c2(Ee, S2) : i2(Ee, S2), true) : (G == null ? void 0 : G.type) === "Program" && (G == null ? void 0 : G.body.length) === 0 && !h3(G.directives) ? (Re ? c2(G, S2) : i2(G, S2), true) : (te == null ? void 0 : te.type) === "Program" && (te == null ? void 0 : te.body.length) === 0 && (G == null ? void 0 : G.type) === "ModuleExpression" ? (c2(te, S2), true) : false;
          }
          __name(fe, "fe");
          function ge(ye) {
            let { comment: S2, enclosingNode: G } = ye;
            return (G == null ? void 0 : G.type) === "ForInStatement" || (G == null ? void 0 : G.type) === "ForOfStatement" ? (i2(G, S2), true) : false;
          }
          __name(ge, "ge");
          function Ce(ye) {
            let { comment: S2, precedingNode: G, enclosingNode: te, text: Ee } = ye;
            if ((te == null ? void 0 : te.type) === "ImportSpecifier" || (te == null ? void 0 : te.type) === "ExportSpecifier")
              return i2(te, S2), true;
            let Re = (G == null ? void 0 : G.type) === "ImportSpecifier" && (te == null ? void 0 : te.type) === "ImportDeclaration", Te = (G == null ? void 0 : G.type) === "ExportSpecifier" && (te == null ? void 0 : te.type) === "ExportNamedDeclaration";
            return (Re || Te) && s2(Ee, o2(S2)) ? (l2(G, S2), true) : false;
          }
          __name(Ce, "Ce");
          function _e(ye) {
            let { comment: S2, enclosingNode: G } = ye;
            return (G == null ? void 0 : G.type) === "AssignmentPattern" ? (i2(G, S2), true) : false;
          }
          __name(_e, "_e");
          var Oe = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), pe = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
          function ie(ye) {
            let { comment: S2, enclosingNode: G, followingNode: te } = ye;
            return Oe.has(G == null ? void 0 : G.type) && te && (pe.has(te.type) || d2(S2)) ? (i2(te, S2), true) : false;
          }
          __name(ie, "ie");
          function ve(ye) {
            let { comment: S2, enclosingNode: G, followingNode: te, text: Ee } = ye;
            return !te && ((G == null ? void 0 : G.type) === "TSMethodSignature" || (G == null ? void 0 : G.type) === "TSDeclareFunction" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && r2(Ee, S2, o2) === ";" ? (l2(G, S2), true) : false;
          }
          __name(ve, "ve");
          function ce(ye) {
            let { comment: S2, enclosingNode: G, followingNode: te } = ye;
            if (p2(S2) && (G == null ? void 0 : G.type) === "TSMappedType" && (te == null ? void 0 : te.type) === "TSTypeParameter" && te.constraint)
              return G.prettierIgnore = true, S2.unignore = true, true;
          }
          __name(ce, "ce");
          function U2(ye) {
            let { comment: S2, precedingNode: G, enclosingNode: te, followingNode: Ee } = ye;
            return (te == null ? void 0 : te.type) !== "TSMappedType" ? false : (Ee == null ? void 0 : Ee.type) === "TSTypeParameter" && Ee.name ? (i2(Ee.name, S2), true) : (G == null ? void 0 : G.type) === "TSTypeParameter" && G.constraint ? (l2(G.constraint, S2), true) : false;
          }
          __name(U2, "U");
          function de(ye) {
            let { comment: S2, enclosingNode: G, followingNode: te } = ye;
            return !G || G.type !== "SwitchCase" || G.test ? false : (te.type === "BlockStatement" && R2(S2) ? N2(te, S2) : c2(G, S2), true);
          }
          __name(de, "de");
          function De(ye) {
            return ye.type === "ArrowFunctionExpression" || ye.type === "FunctionExpression" || ye.type === "FunctionDeclaration" || ye.type === "ObjectMethod" || ye.type === "ClassMethod" || ye.type === "TSDeclareFunction" || ye.type === "TSCallSignatureDeclaration" || ye.type === "TSConstructSignatureDeclaration" || ye.type === "TSMethodSignature" || ye.type === "TSConstructorType" || ye.type === "TSFunctionType" || ye.type === "TSDeclareMethod";
          }
          __name(De, "De");
          function he(ye, S2) {
            if ((S2.parser === "typescript" || S2.parser === "flow" || S2.parser === "acorn" || S2.parser === "espree" || S2.parser === "meriyah" || S2.parser === "__babel_estree") && ye.type === "MethodDefinition" && ye.value && ye.value.type === "FunctionExpression" && g2(ye.value).length === 0 && !ye.value.returnType && !h3(ye.value.typeParameters) && ye.value.body)
              return [...ye.decorators || [], ye.key, ye.value.body];
          }
          __name(he, "he");
          function Be(ye) {
            return d2(ye) && ye.value[0] === "*" && /@type\b/.test(ye.value);
          }
          __name(Be, "Be");
          function Se(ye) {
            let S2 = ye.getValue(), G = ye.getParentNode(), te = /* @__PURE__ */ __name((Ee) => w2(f2(Ee, x2.Leading)) || w2(f2(Ee, x2.Trailing)), "te");
            return (S2 && (D(S2) || v2(S2) || B(G) && te(S2)) || G && (G.type === "JSXSpreadAttribute" || G.type === "JSXSpreadChild" || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType" || (G.type === "ClassDeclaration" || G.type === "ClassExpression") && G.superClass === S2)) && (!T2(ye) || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType");
          }
          __name(Se, "Se");
          n2.exports = { handleOwnLineComment: C2, handleEndOfLineComment: _2, handleRemainingComment: b2, isTypeCastComment: Be, getCommentChildNodes: he, willPrintOwnComments: Se };
        } }), Ot = ee({ "src/language-js/needs-parens.js"(e2, n2) {
          "use strict";
          re();
          var t2 = lt(), s2 = $n(), { getFunctionParameters: a2, getLeftSidePathName: r2, hasFlowShorthandAnnotationComment: u2, hasNakedLeftSide: i2, hasNode: l2, isBitwiseOperator: c2, startsWithNoLookaheadToken: y2, shouldFlatten: h3, getPrecedence: g2, isCallExpression: p2, isMemberExpression: D, isObjectProperty: v2, isTSTypeExpression: w2 } = Ke();
          function T2(f2, x2) {
            let m2 = f2.getParentNode();
            if (!m2)
              return false;
            let E2 = f2.getName(), o2 = f2.getNode();
            if (x2.__isInHtmlInterpolation && !x2.bracketSpacing && I(o2) && P2(f2))
              return true;
            if (F(o2))
              return false;
            if (x2.parser !== "flow" && u2(f2.getValue()))
              return true;
            if (o2.type === "Identifier")
              return !!(o2.extra && o2.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o2.name) || E2 === "left" && o2.name === "async" && m2.type === "ForOfStatement" && !m2.await);
            switch (m2.type) {
              case "ParenthesizedExpression":
                return false;
              case "ClassDeclaration":
              case "ClassExpression": {
                if (E2 === "superClass" && (o2.type === "ArrowFunctionExpression" || o2.type === "AssignmentExpression" || o2.type === "AwaitExpression" || o2.type === "BinaryExpression" || o2.type === "ConditionalExpression" || o2.type === "LogicalExpression" || o2.type === "NewExpression" || o2.type === "ObjectExpression" || o2.type === "SequenceExpression" || o2.type === "TaggedTemplateExpression" || o2.type === "UnaryExpression" || o2.type === "UpdateExpression" || o2.type === "YieldExpression" || o2.type === "TSNonNullExpression"))
                  return true;
                break;
              }
              case "ExportDefaultDeclaration":
                return R2(f2, x2) || o2.type === "SequenceExpression";
              case "Decorator": {
                if (E2 === "expression") {
                  let d2 = false, C2 = false, _2 = o2;
                  for (; _2; )
                    switch (_2.type) {
                      case "MemberExpression":
                        C2 = true, _2 = _2.object;
                        break;
                      case "CallExpression":
                        if (C2 || d2)
                          return x2.parser !== "typescript";
                        d2 = true, _2 = _2.callee;
                        break;
                      case "Identifier":
                        return false;
                      case "TaggedTemplateExpression":
                        return x2.parser !== "typescript";
                      default:
                        return true;
                    }
                  return true;
                }
                break;
              }
              case "ExpressionStatement": {
                if (y2(o2, true))
                  return true;
                break;
              }
              case "ArrowFunctionExpression": {
                if (E2 === "body" && o2.type !== "SequenceExpression" && y2(o2, false))
                  return true;
                break;
              }
            }
            switch (o2.type) {
              case "UpdateExpression":
                if (m2.type === "UnaryExpression")
                  return o2.prefix && (o2.operator === "++" && m2.operator === "+" || o2.operator === "--" && m2.operator === "-");
              case "UnaryExpression":
                switch (m2.type) {
                  case "UnaryExpression":
                    return o2.operator === m2.operator && (o2.operator === "+" || o2.operator === "-");
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return E2 === "object";
                  case "TaggedTemplateExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return E2 === "callee";
                  case "BinaryExpression":
                    return E2 === "left" && m2.operator === "**";
                  case "TSNonNullExpression":
                    return true;
                  default:
                    return false;
                }
              case "BinaryExpression": {
                if (m2.type === "UpdateExpression" || o2.operator === "in" && A2(f2))
                  return true;
                if (o2.operator === "|>" && o2.extra && o2.extra.parenthesized) {
                  let d2 = f2.getParentNode(1);
                  if (d2.type === "BinaryExpression" && d2.operator === "|>")
                    return true;
                }
              }
              case "TSTypeAssertion":
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "LogicalExpression":
                switch (m2.type) {
                  case "TSSatisfiesExpression":
                  case "TSAsExpression":
                    return !w2(o2);
                  case "ConditionalExpression":
                    return w2(o2);
                  case "CallExpression":
                  case "NewExpression":
                  case "OptionalCallExpression":
                    return E2 === "callee";
                  case "ClassExpression":
                  case "ClassDeclaration":
                    return E2 === "superClass";
                  case "TSTypeAssertion":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "JSXSpreadAttribute":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BindExpression":
                  case "AwaitExpression":
                  case "TSNonNullExpression":
                  case "UpdateExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return E2 === "object";
                  case "AssignmentExpression":
                  case "AssignmentPattern":
                    return E2 === "left" && (o2.type === "TSTypeAssertion" || w2(o2));
                  case "LogicalExpression":
                    if (o2.type === "LogicalExpression")
                      return m2.operator !== o2.operator;
                  case "BinaryExpression": {
                    let { operator: d2, type: C2 } = o2;
                    if (!d2 && C2 !== "TSTypeAssertion")
                      return true;
                    let _2 = g2(d2), b2 = m2.operator, N2 = g2(b2);
                    return N2 > _2 || E2 === "right" && N2 === _2 || N2 === _2 && !h3(b2, d2) ? true : N2 < _2 && d2 === "%" ? b2 === "+" || b2 === "-" : !!c2(b2);
                  }
                  default:
                    return false;
                }
              case "SequenceExpression":
                switch (m2.type) {
                  case "ReturnStatement":
                    return false;
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return E2 !== "expression";
                  case "ArrowFunctionExpression":
                    return E2 !== "body";
                  default:
                    return true;
                }
              case "YieldExpression":
                if (m2.type === "UnaryExpression" || m2.type === "AwaitExpression" || w2(m2) || m2.type === "TSNonNullExpression")
                  return true;
              case "AwaitExpression":
                switch (m2.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return E2 === "object";
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return E2 === "callee";
                  case "ConditionalExpression":
                    return E2 === "test";
                  case "BinaryExpression":
                    return !(!o2.argument && m2.operator === "|>");
                  default:
                    return false;
                }
              case "TSConditionalType":
                if (E2 === "extendsType" && m2.type === "TSConditionalType")
                  return true;
              case "TSFunctionType":
              case "TSConstructorType":
                if (E2 === "extendsType" && m2.type === "TSConditionalType") {
                  let d2 = (o2.returnType || o2.typeAnnotation).typeAnnotation;
                  if (d2.type === "TSInferType" && d2.typeParameter.constraint)
                    return true;
                }
                if (E2 === "checkType" && m2.type === "TSConditionalType")
                  return true;
              case "TSUnionType":
              case "TSIntersectionType":
                if ((m2.type === "TSUnionType" || m2.type === "TSIntersectionType") && m2.types.length > 1 && (!o2.types || o2.types.length > 1))
                  return true;
              case "TSInferType":
                if (o2.type === "TSInferType" && m2.type === "TSRestType")
                  return false;
              case "TSTypeOperator":
                return m2.type === "TSArrayType" || m2.type === "TSOptionalType" || m2.type === "TSRestType" || E2 === "objectType" && m2.type === "TSIndexedAccessType" || m2.type === "TSTypeOperator" || m2.type === "TSTypeAnnotation" && f2.getParentNode(1).type.startsWith("TSJSDoc");
              case "ArrayTypeAnnotation":
                return m2.type === "NullableTypeAnnotation";
              case "IntersectionTypeAnnotation":
              case "UnionTypeAnnotation":
                return m2.type === "ArrayTypeAnnotation" || m2.type === "NullableTypeAnnotation" || m2.type === "IntersectionTypeAnnotation" || m2.type === "UnionTypeAnnotation" || E2 === "objectType" && (m2.type === "IndexedAccessType" || m2.type === "OptionalIndexedAccessType");
              case "NullableTypeAnnotation":
                return m2.type === "ArrayTypeAnnotation" || E2 === "objectType" && (m2.type === "IndexedAccessType" || m2.type === "OptionalIndexedAccessType");
              case "FunctionTypeAnnotation": {
                let d2 = m2.type === "NullableTypeAnnotation" ? f2.getParentNode(1) : m2;
                return d2.type === "UnionTypeAnnotation" || d2.type === "IntersectionTypeAnnotation" || d2.type === "ArrayTypeAnnotation" || E2 === "objectType" && (d2.type === "IndexedAccessType" || d2.type === "OptionalIndexedAccessType") || d2.type === "NullableTypeAnnotation" || m2.type === "FunctionTypeParam" && m2.name === null && a2(o2).some((C2) => C2.typeAnnotation && C2.typeAnnotation.type === "NullableTypeAnnotation");
              }
              case "OptionalIndexedAccessType":
                return E2 === "objectType" && m2.type === "IndexedAccessType";
              case "TypeofTypeAnnotation":
                return E2 === "objectType" && (m2.type === "IndexedAccessType" || m2.type === "OptionalIndexedAccessType");
              case "StringLiteral":
              case "NumericLiteral":
              case "Literal":
                if (typeof o2.value == "string" && m2.type === "ExpressionStatement" && !m2.directive) {
                  let d2 = f2.getParentNode(1);
                  return d2.type === "Program" || d2.type === "BlockStatement";
                }
                return E2 === "object" && m2.type === "MemberExpression" && typeof o2.value == "number";
              case "AssignmentExpression": {
                let d2 = f2.getParentNode(1);
                return E2 === "body" && m2.type === "ArrowFunctionExpression" ? true : E2 === "key" && (m2.type === "ClassProperty" || m2.type === "PropertyDefinition") && m2.computed || (E2 === "init" || E2 === "update") && m2.type === "ForStatement" ? false : m2.type === "ExpressionStatement" ? o2.left.type === "ObjectPattern" : !(E2 === "key" && m2.type === "TSPropertySignature" || m2.type === "AssignmentExpression" || m2.type === "SequenceExpression" && d2 && d2.type === "ForStatement" && (d2.init === m2 || d2.update === m2) || E2 === "value" && m2.type === "Property" && d2 && d2.type === "ObjectPattern" && d2.properties.includes(m2) || m2.type === "NGChainedExpression");
              }
              case "ConditionalExpression":
                switch (m2.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "NGPipeExpression":
                  case "ExportDefaultDeclaration":
                  case "AwaitExpression":
                  case "JSXSpreadAttribute":
                  case "TSTypeAssertion":
                  case "TypeCastExpression":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return E2 === "callee";
                  case "ConditionalExpression":
                    return E2 === "test";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return E2 === "object";
                  default:
                    return false;
                }
              case "FunctionExpression":
                switch (m2.type) {
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return E2 === "callee";
                  case "TaggedTemplateExpression":
                    return true;
                  default:
                    return false;
                }
              case "ArrowFunctionExpression":
                switch (m2.type) {
                  case "BinaryExpression":
                    return m2.operator !== "|>" || o2.extra && o2.extra.parenthesized;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return E2 === "callee";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return E2 === "object";
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "AwaitExpression":
                  case "TSTypeAssertion":
                    return true;
                  case "ConditionalExpression":
                    return E2 === "test";
                  default:
                    return false;
                }
              case "ClassExpression":
                if (s2(o2.decorators))
                  return true;
                switch (m2.type) {
                  case "NewExpression":
                    return E2 === "callee";
                  default:
                    return false;
                }
              case "OptionalMemberExpression":
              case "OptionalCallExpression": {
                let d2 = f2.getParentNode(1);
                if (E2 === "object" && m2.type === "MemberExpression" || E2 === "callee" && (m2.type === "CallExpression" || m2.type === "NewExpression") || m2.type === "TSNonNullExpression" && d2.type === "MemberExpression" && d2.object === m2)
                  return true;
              }
              case "CallExpression":
              case "MemberExpression":
              case "TaggedTemplateExpression":
              case "TSNonNullExpression":
                if (E2 === "callee" && (m2.type === "BindExpression" || m2.type === "NewExpression")) {
                  let d2 = o2;
                  for (; d2; )
                    switch (d2.type) {
                      case "CallExpression":
                      case "OptionalCallExpression":
                        return true;
                      case "MemberExpression":
                      case "OptionalMemberExpression":
                      case "BindExpression":
                        d2 = d2.object;
                        break;
                      case "TaggedTemplateExpression":
                        d2 = d2.tag;
                        break;
                      case "TSNonNullExpression":
                        d2 = d2.expression;
                        break;
                      default:
                        return false;
                    }
                }
                return false;
              case "BindExpression":
                return E2 === "callee" && (m2.type === "BindExpression" || m2.type === "NewExpression") || E2 === "object" && D(m2);
              case "NGPipeExpression":
                return !(m2.type === "NGRoot" || m2.type === "NGMicrosyntaxExpression" || m2.type === "ObjectProperty" && !(o2.extra && o2.extra.parenthesized) || m2.type === "ArrayExpression" || p2(m2) && m2.arguments[E2] === o2 || E2 === "right" && m2.type === "NGPipeExpression" || E2 === "property" && m2.type === "MemberExpression" || m2.type === "AssignmentExpression");
              case "JSXFragment":
              case "JSXElement":
                return E2 === "callee" || E2 === "left" && m2.type === "BinaryExpression" && m2.operator === "<" || m2.type !== "ArrayExpression" && m2.type !== "ArrowFunctionExpression" && m2.type !== "AssignmentExpression" && m2.type !== "AssignmentPattern" && m2.type !== "BinaryExpression" && m2.type !== "NewExpression" && m2.type !== "ConditionalExpression" && m2.type !== "ExpressionStatement" && m2.type !== "JsExpressionRoot" && m2.type !== "JSXAttribute" && m2.type !== "JSXElement" && m2.type !== "JSXExpressionContainer" && m2.type !== "JSXFragment" && m2.type !== "LogicalExpression" && !p2(m2) && !v2(m2) && m2.type !== "ReturnStatement" && m2.type !== "ThrowStatement" && m2.type !== "TypeCastExpression" && m2.type !== "VariableDeclarator" && m2.type !== "YieldExpression";
              case "TypeAnnotation":
                return E2 === "returnType" && m2.type === "ArrowFunctionExpression" && B(o2);
            }
            return false;
          }
          __name(T2, "T");
          function F(f2) {
            return f2.type === "BlockStatement" || f2.type === "BreakStatement" || f2.type === "ClassBody" || f2.type === "ClassDeclaration" || f2.type === "ClassMethod" || f2.type === "ClassProperty" || f2.type === "PropertyDefinition" || f2.type === "ClassPrivateProperty" || f2.type === "ContinueStatement" || f2.type === "DebuggerStatement" || f2.type === "DeclareClass" || f2.type === "DeclareExportAllDeclaration" || f2.type === "DeclareExportDeclaration" || f2.type === "DeclareFunction" || f2.type === "DeclareInterface" || f2.type === "DeclareModule" || f2.type === "DeclareModuleExports" || f2.type === "DeclareVariable" || f2.type === "DoWhileStatement" || f2.type === "EnumDeclaration" || f2.type === "ExportAllDeclaration" || f2.type === "ExportDefaultDeclaration" || f2.type === "ExportNamedDeclaration" || f2.type === "ExpressionStatement" || f2.type === "ForInStatement" || f2.type === "ForOfStatement" || f2.type === "ForStatement" || f2.type === "FunctionDeclaration" || f2.type === "IfStatement" || f2.type === "ImportDeclaration" || f2.type === "InterfaceDeclaration" || f2.type === "LabeledStatement" || f2.type === "MethodDefinition" || f2.type === "ReturnStatement" || f2.type === "SwitchStatement" || f2.type === "ThrowStatement" || f2.type === "TryStatement" || f2.type === "TSDeclareFunction" || f2.type === "TSEnumDeclaration" || f2.type === "TSImportEqualsDeclaration" || f2.type === "TSInterfaceDeclaration" || f2.type === "TSModuleDeclaration" || f2.type === "TSNamespaceExportDeclaration" || f2.type === "TypeAlias" || f2.type === "VariableDeclaration" || f2.type === "WhileStatement" || f2.type === "WithStatement";
          }
          __name(F, "F");
          function A2(f2) {
            let x2 = 0, m2 = f2.getValue();
            for (; m2; ) {
              let E2 = f2.getParentNode(x2++);
              if (E2 && E2.type === "ForStatement" && E2.init === m2)
                return true;
              m2 = E2;
            }
            return false;
          }
          __name(A2, "A");
          function B(f2) {
            return l2(f2, (x2) => x2.type === "ObjectTypeAnnotation" && l2(x2, (m2) => m2.type === "FunctionTypeAnnotation" || void 0) || void 0);
          }
          __name(B, "B");
          function I(f2) {
            switch (f2.type) {
              case "ObjectExpression":
                return true;
              default:
                return false;
            }
          }
          __name(I, "I");
          function P2(f2) {
            let x2 = f2.getValue(), m2 = f2.getParentNode(), E2 = f2.getName();
            switch (m2.type) {
              case "NGPipeExpression":
                if (typeof E2 == "number" && m2.arguments[E2] === x2 && m2.arguments.length - 1 === E2)
                  return f2.callParent(P2);
                break;
              case "ObjectProperty":
                if (E2 === "value") {
                  let o2 = f2.getParentNode(1);
                  return t2(o2.properties) === m2;
                }
                break;
              case "BinaryExpression":
              case "LogicalExpression":
                if (E2 === "right")
                  return f2.callParent(P2);
                break;
              case "ConditionalExpression":
                if (E2 === "alternate")
                  return f2.callParent(P2);
                break;
              case "UnaryExpression":
                if (m2.prefix)
                  return f2.callParent(P2);
                break;
            }
            return false;
          }
          __name(P2, "P");
          function R2(f2, x2) {
            let m2 = f2.getValue(), E2 = f2.getParentNode();
            return m2.type === "FunctionExpression" || m2.type === "ClassExpression" ? E2.type === "ExportDefaultDeclaration" || !T2(f2, x2) : !i2(m2) || E2.type !== "ExportDefaultDeclaration" && T2(f2, x2) ? false : f2.call((o2) => R2(o2, x2), ...r2(f2, m2));
          }
          __name(R2, "R");
          n2.exports = T2;
        } }), eo = ee({ "src/language-js/print-preprocess.js"(e2, n2) {
          "use strict";
          re();
          function t2(s2, a2) {
            switch (a2.parser) {
              case "json":
              case "json5":
              case "json-stringify":
              case "__js_expression":
              case "__vue_expression":
              case "__vue_ts_expression":
                return Object.assign(Object.assign({}, s2), {}, { type: a2.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s2, comments: [], rootMarker: a2.rootMarker });
              default:
                return s2;
            }
          }
          __name(t2, "t");
          n2.exports = t2;
        } }), qm = ee({ "src/language-js/print/html-binding.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { join: t2, line: s2, group: a2, softline: r2, indent: u2 } } = qe();
          function i2(c2, y2, h3) {
            let g2 = c2.getValue();
            if (y2.__onHtmlBindingRoot && c2.getName() === null && y2.__onHtmlBindingRoot(g2, y2), g2.type === "File") {
              if (y2.__isVueForBindingLeft)
                return c2.call((p2) => {
                  let D = t2([",", s2], p2.map(h3, "params")), { params: v2 } = p2.getValue();
                  return v2.length === 1 ? D : ["(", u2([r2, a2(D)]), r2, ")"];
                }, "program", "body", 0);
              if (y2.__isVueBindings)
                return c2.call((p2) => t2([",", s2], p2.map(h3, "params")), "program", "body", 0);
            }
          }
          __name(i2, "i");
          function l2(c2) {
            switch (c2.type) {
              case "MemberExpression":
                switch (c2.property.type) {
                  case "Identifier":
                  case "NumericLiteral":
                  case "StringLiteral":
                    return l2(c2.object);
                }
                return false;
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          __name(l2, "l");
          n2.exports = { isVueEventBindingExpression: l2, printHtmlBinding: i2 };
        } }), Jn = ee({ "src/language-js/print/binaryish.js"(e2, n2) {
          "use strict";
          re();
          var { printComments: t2 } = et(), { getLast: s2 } = Ge(), { builders: { join: a2, line: r2, softline: u2, group: i2, indent: l2, align: c2, indentIfBreak: y2 }, utils: { cleanDoc: h3, getDocParts: g2, isConcat: p2 } } = qe(), { hasLeadingOwnLineComment: D, isBinaryish: v2, isJsxNode: w2, shouldFlatten: T2, hasComment: F, CommentCheckFlags: A2, isCallExpression: B, isMemberExpression: I, isObjectProperty: P2, isEnabledHackPipeline: R2 } = Ke(), f2 = 0;
          function x2(o2, d2, C2) {
            let _2 = o2.getValue(), b2 = o2.getParentNode(), N2 = o2.getParentNode(1), k2 = _2 !== b2.body && (b2.type === "IfStatement" || b2.type === "WhileStatement" || b2.type === "SwitchStatement" || b2.type === "DoWhileStatement"), $ = R2(d2) && _2.operator === "|>", M2 = m2(o2, C2, d2, false, k2);
            if (k2)
              return M2;
            if ($)
              return i2(M2);
            if (B(b2) && b2.callee === _2 || b2.type === "UnaryExpression" || I(b2) && !b2.computed)
              return i2([l2([u2, ...M2]), u2]);
            let q = b2.type === "ReturnStatement" || b2.type === "ThrowStatement" || b2.type === "JSXExpressionContainer" && N2.type === "JSXAttribute" || _2.operator !== "|" && b2.type === "JsExpressionRoot" || _2.type !== "NGPipeExpression" && (b2.type === "NGRoot" && d2.parser === "__ng_binding" || b2.type === "NGMicrosyntaxExpression" && N2.type === "NGMicrosyntax" && N2.body.length === 1) || _2 === b2.body && b2.type === "ArrowFunctionExpression" || _2 !== b2.body && b2.type === "ForStatement" || b2.type === "ConditionalExpression" && N2.type !== "ReturnStatement" && N2.type !== "ThrowStatement" && !B(N2) || b2.type === "TemplateLiteral", J = b2.type === "AssignmentExpression" || b2.type === "VariableDeclarator" || b2.type === "ClassProperty" || b2.type === "PropertyDefinition" || b2.type === "TSAbstractPropertyDefinition" || b2.type === "ClassPrivateProperty" || P2(b2), L2 = v2(_2.left) && T2(_2.operator, _2.left.operator);
            if (q || E2(_2) && !L2 || !E2(_2) && J)
              return i2(M2);
            if (M2.length === 0)
              return "";
            let Y = w2(_2.right), V = M2.findIndex((W2) => typeof W2 != "string" && !Array.isArray(W2) && W2.type === "group"), O2 = M2.slice(0, V === -1 ? 1 : V + 1), K = M2.slice(O2.length, Y ? -1 : void 0), se = Symbol("logicalChain-" + ++f2), Q = i2([...O2, l2(K)], { id: se });
            if (!Y)
              return Q;
            let le = s2(M2);
            return i2([Q, y2(le, { groupId: se })]);
          }
          __name(x2, "x");
          function m2(o2, d2, C2, _2, b2) {
            let N2 = o2.getValue();
            if (!v2(N2))
              return [i2(d2())];
            let k2 = [];
            T2(N2.operator, N2.left.operator) ? k2 = o2.call((K) => m2(K, d2, C2, true, b2), "left") : k2.push(i2(d2("left")));
            let $ = E2(N2), M2 = (N2.operator === "|>" || N2.type === "NGPipeExpression" || N2.operator === "|" && C2.parser === "__vue_expression") && !D(C2.originalText, N2.right), q = N2.type === "NGPipeExpression" ? "|" : N2.operator, J = N2.type === "NGPipeExpression" && N2.arguments.length > 0 ? i2(l2([r2, ": ", a2([r2, ": "], o2.map(d2, "arguments").map((K) => c2(2, i2(K))))])) : "", L2;
            if ($)
              L2 = [q, " ", d2("right"), J];
            else {
              let se = R2(C2) && q === "|>" ? o2.call((Q) => m2(Q, d2, C2, true, b2), "right") : d2("right");
              L2 = [M2 ? r2 : "", q, M2 ? " " : r2, se, J];
            }
            let Y = o2.getParentNode(), V = F(N2.left, A2.Trailing | A2.Line), O2 = V || !(b2 && N2.type === "LogicalExpression") && Y.type !== N2.type && N2.left.type !== N2.type && N2.right.type !== N2.type;
            if (k2.push(M2 ? "" : " ", O2 ? i2(L2, { shouldBreak: V }) : L2), _2 && F(N2)) {
              let K = h3(t2(o2, k2, C2));
              return p2(K) || K.type === "fill" ? g2(K) : [K];
            }
            return k2;
          }
          __name(m2, "m");
          function E2(o2) {
            return o2.type !== "LogicalExpression" ? false : !!(o2.right.type === "ObjectExpression" && o2.right.properties.length > 0 || o2.right.type === "ArrayExpression" && o2.right.elements.length > 0 || w2(o2.right));
          }
          __name(E2, "E");
          n2.exports = { printBinaryishExpression: x2, shouldInlineLogicalExpression: E2 };
        } }), Mm = ee({ "src/language-js/print/angular.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { join: t2, line: s2, group: a2 } } = qe(), { hasNode: r2, hasComment: u2, getComments: i2 } = Ke(), { printBinaryishExpression: l2 } = Jn();
          function c2(g2, p2, D) {
            let v2 = g2.getValue();
            if (!!v2.type.startsWith("NG"))
              switch (v2.type) {
                case "NGRoot":
                  return [D("node"), u2(v2.node) ? " //" + i2(v2.node)[0].value.trimEnd() : ""];
                case "NGPipeExpression":
                  return l2(g2, p2, D);
                case "NGChainedExpression":
                  return a2(t2([";", s2], g2.map((w2) => h3(w2) ? D() : ["(", D(), ")"], "expressions")));
                case "NGEmptyExpression":
                  return "";
                case "NGQuotedExpression":
                  return [v2.prefix, ": ", v2.value.trim()];
                case "NGMicrosyntax":
                  return g2.map((w2, T2) => [T2 === 0 ? "" : y2(w2.getValue(), T2, v2) ? " " : [";", s2], D()], "body");
                case "NGMicrosyntaxKey":
                  return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(v2.name) ? v2.name : JSON.stringify(v2.name);
                case "NGMicrosyntaxExpression":
                  return [D("expression"), v2.alias === null ? "" : [" as ", D("alias")]];
                case "NGMicrosyntaxKeyedExpression": {
                  let w2 = g2.getName(), T2 = g2.getParentNode(), F = y2(v2, w2, T2) || (w2 === 1 && (v2.key.name === "then" || v2.key.name === "else") || w2 === 2 && v2.key.name === "else" && T2.body[w2 - 1].type === "NGMicrosyntaxKeyedExpression" && T2.body[w2 - 1].key.name === "then") && T2.body[0].type === "NGMicrosyntaxExpression";
                  return [D("key"), F ? " " : ": ", D("expression")];
                }
                case "NGMicrosyntaxLet":
                  return ["let ", D("key"), v2.value === null ? "" : [" = ", D("value")]];
                case "NGMicrosyntaxAs":
                  return [D("key"), " as ", D("alias")];
                default:
                  throw new Error(`Unknown Angular node type: ${JSON.stringify(v2.type)}.`);
              }
          }
          __name(c2, "c");
          function y2(g2, p2, D) {
            return g2.type === "NGMicrosyntaxKeyedExpression" && g2.key.name === "of" && p2 === 1 && D.body[0].type === "NGMicrosyntaxLet" && D.body[0].value === null;
          }
          __name(y2, "y");
          function h3(g2) {
            return r2(g2.getValue(), (p2) => {
              switch (p2.type) {
                case void 0:
                  return false;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return true;
              }
            });
          }
          __name(h3, "h");
          n2.exports = { printAngular: c2 };
        } }), Rm = ee({ "src/language-js/print/jsx.js"(e2, n2) {
          "use strict";
          re();
          var { printComments: t2, printDanglingComments: s2 } = et(), { builders: { line: a2, hardline: r2, softline: u2, group: i2, indent: l2, conditionalGroup: c2, fill: y2, ifBreak: h3, lineSuffixBoundary: g2, join: p2 }, utils: { willBreak: D } } = qe(), { getLast: v2, getPreferredQuote: w2 } = Ge(), { isJsxNode: T2, rawText: F, isLiteral: A2, isCallExpression: B, isStringLiteral: I, isBinaryish: P2, hasComment: R2, CommentCheckFlags: f2, hasNodeIgnoreComment: x2 } = Ke(), m2 = Ot(), { willPrintOwnComments: E2 } = Za(), o2 = /* @__PURE__ */ __name((H) => H === "" || H === a2 || H === r2 || H === u2, "o");
          function d2(H, Z, ne) {
            let fe = H.getValue();
            if (fe.type === "JSXElement" && oe(fe))
              return [ne("openingElement"), ne("closingElement")];
            let ge = fe.type === "JSXElement" ? ne("openingElement") : ne("openingFragment"), Ce = fe.type === "JSXElement" ? ne("closingElement") : ne("closingFragment");
            if (fe.children.length === 1 && fe.children[0].type === "JSXExpressionContainer" && (fe.children[0].expression.type === "TemplateLiteral" || fe.children[0].expression.type === "TaggedTemplateExpression"))
              return [ge, ...H.map(ne, "children"), Ce];
            fe.children = fe.children.map((S2) => Ae(S2) ? { type: "JSXText", value: " ", raw: " " } : S2);
            let _e = fe.children.some(T2), Oe = fe.children.filter((S2) => S2.type === "JSXExpressionContainer").length > 1, pe = fe.type === "JSXElement" && fe.openingElement.attributes.length > 1, ie = D(ge) || _e || pe || Oe, ve = H.getParentNode().rootMarker === "mdx", ce = Z.singleQuote ? "{' '}" : '{" "}', U2 = ve ? " " : h3([ce, u2], " "), de = fe.openingElement && fe.openingElement.name && fe.openingElement.name.name === "fbt", De = C2(H, Z, ne, U2, de), he = fe.children.some((S2) => ae(S2));
            for (let S2 = De.length - 2; S2 >= 0; S2--) {
              let G = De[S2] === "" && De[S2 + 1] === "", te = De[S2] === r2 && De[S2 + 1] === "" && De[S2 + 2] === r2, Ee = (De[S2] === u2 || De[S2] === r2) && De[S2 + 1] === "" && De[S2 + 2] === U2, Re = De[S2] === U2 && De[S2 + 1] === "" && (De[S2 + 2] === u2 || De[S2 + 2] === r2), Te = De[S2] === U2 && De[S2 + 1] === "" && De[S2 + 2] === U2, Pe = De[S2] === u2 && De[S2 + 1] === "" && De[S2 + 2] === r2 || De[S2] === r2 && De[S2 + 1] === "" && De[S2 + 2] === u2;
              te && he || G || Ee || Te || Pe ? De.splice(S2, 2) : Re && De.splice(S2 + 1, 2);
            }
            for (; De.length > 0 && o2(v2(De)); )
              De.pop();
            for (; De.length > 1 && o2(De[0]) && o2(De[1]); )
              De.shift(), De.shift();
            let Be = [];
            for (let [S2, G] of De.entries()) {
              if (G === U2) {
                if (S2 === 1 && De[S2 - 1] === "") {
                  if (De.length === 2) {
                    Be.push(ce);
                    continue;
                  }
                  Be.push([ce, r2]);
                  continue;
                } else if (S2 === De.length - 1) {
                  Be.push(ce);
                  continue;
                } else if (De[S2 - 1] === "" && De[S2 - 2] === r2) {
                  Be.push(ce);
                  continue;
                }
              }
              Be.push(G), D(G) && (ie = true);
            }
            let Se = he ? y2(Be) : i2(Be, { shouldBreak: true });
            if (ve)
              return Se;
            let ye = i2([ge, l2([r2, Se]), r2, Ce]);
            return ie ? ye : c2([i2([ge, ...De, Ce]), ye]);
          }
          __name(d2, "d");
          function C2(H, Z, ne, fe, ge) {
            let Ce = [];
            return H.each((_e, Oe, pe) => {
              let ie = _e.getValue();
              if (A2(ie)) {
                let ve = F(ie);
                if (ae(ie)) {
                  let ce = ve.split(le);
                  if (ce[0] === "") {
                    if (Ce.push(""), ce.shift(), /\n/.test(ce[0])) {
                      let de = pe[Oe + 1];
                      Ce.push(b2(ge, ce[1], ie, de));
                    } else
                      Ce.push(fe);
                    ce.shift();
                  }
                  let U2;
                  if (v2(ce) === "" && (ce.pop(), U2 = ce.pop()), ce.length === 0)
                    return;
                  for (let [de, De] of ce.entries())
                    de % 2 === 1 ? Ce.push(a2) : Ce.push(De);
                  if (U2 !== void 0)
                    if (/\n/.test(U2)) {
                      let de = pe[Oe + 1];
                      Ce.push(b2(ge, v2(Ce), ie, de));
                    } else
                      Ce.push(fe);
                  else {
                    let de = pe[Oe + 1];
                    Ce.push(_2(ge, v2(Ce), ie, de));
                  }
                } else
                  /\n/.test(ve) ? ve.match(/\n/g).length > 1 && Ce.push("", r2) : Ce.push("", fe);
              } else {
                let ve = ne();
                Ce.push(ve);
                let ce = pe[Oe + 1];
                if (ce && ae(ce)) {
                  let de = X(F(ce)).split(le)[0];
                  Ce.push(_2(ge, de, ie, ce));
                } else
                  Ce.push(r2);
              }
            }, "children"), Ce;
          }
          __name(C2, "C");
          function _2(H, Z, ne, fe) {
            return H ? "" : ne.type === "JSXElement" && !ne.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? Z.length === 1 ? u2 : r2 : u2;
          }
          __name(_2, "_");
          function b2(H, Z, ne, fe) {
            return H ? r2 : Z.length === 1 ? ne.type === "JSXElement" && !ne.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? r2 : u2 : r2;
          }
          __name(b2, "b");
          function N2(H, Z, ne) {
            let fe = H.getParentNode();
            if (!fe || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe.type])
              return Z;
            let Ce = H.match(void 0, (Oe) => Oe.type === "ArrowFunctionExpression", B, (Oe) => Oe.type === "JSXExpressionContainer"), _e = m2(H, ne);
            return i2([_e ? "" : h3("("), l2([u2, Z]), u2, _e ? "" : h3(")")], { shouldBreak: Ce });
          }
          __name(N2, "N");
          function k2(H, Z, ne) {
            let fe = H.getValue(), ge = [];
            if (ge.push(ne("name")), fe.value) {
              let Ce;
              if (I(fe.value)) {
                let Oe = F(fe.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: pe, quote: ie, regex: ve } = w2(Oe, Z.jsxSingleQuote ? "'" : '"');
                Oe = Oe.replace(ve, pe), Ce = [ie, Oe, ie];
              } else
                Ce = ne("value");
              ge.push("=", Ce);
            }
            return ge;
          }
          __name(k2, "k");
          function $(H, Z, ne) {
            let fe = H.getValue(), ge = /* @__PURE__ */ __name((Ce, _e) => Ce.type === "JSXEmptyExpression" || !R2(Ce) && (Ce.type === "ArrayExpression" || Ce.type === "ObjectExpression" || Ce.type === "ArrowFunctionExpression" || Ce.type === "AwaitExpression" && (ge(Ce.argument, Ce) || Ce.argument.type === "JSXElement") || B(Ce) || Ce.type === "FunctionExpression" || Ce.type === "TemplateLiteral" || Ce.type === "TaggedTemplateExpression" || Ce.type === "DoExpression" || T2(_e) && (Ce.type === "ConditionalExpression" || P2(Ce))), "ge");
            return ge(fe.expression, H.getParentNode(0)) ? i2(["{", ne("expression"), g2, "}"]) : i2(["{", l2([u2, ne("expression")]), u2, g2, "}"]);
          }
          __name($, "$");
          function M2(H, Z, ne) {
            let fe = H.getValue(), ge = fe.name && R2(fe.name) || fe.typeParameters && R2(fe.typeParameters);
            if (fe.selfClosing && fe.attributes.length === 0 && !ge)
              return ["<", ne("name"), ne("typeParameters"), " />"];
            if (fe.attributes && fe.attributes.length === 1 && fe.attributes[0].value && I(fe.attributes[0].value) && !fe.attributes[0].value.value.includes(`
`) && !ge && !R2(fe.attributes[0]))
              return i2(["<", ne("name"), ne("typeParameters"), " ", ...H.map(ne, "attributes"), fe.selfClosing ? " />" : ">"]);
            let Ce = fe.attributes && fe.attributes.some((Oe) => Oe.value && I(Oe.value) && Oe.value.value.includes(`
`)), _e = Z.singleAttributePerLine && fe.attributes.length > 1 ? r2 : a2;
            return i2(["<", ne("name"), ne("typeParameters"), l2(H.map(() => [_e, ne()], "attributes")), ...q(fe, Z, ge)], { shouldBreak: Ce });
          }
          __name(M2, "M");
          function q(H, Z, ne) {
            return H.selfClosing ? [a2, "/>"] : J(H, Z, ne) ? [">"] : [u2, ">"];
          }
          __name(q, "q");
          function J(H, Z, ne) {
            let fe = H.attributes.length > 0 && R2(v2(H.attributes), f2.Trailing);
            return H.attributes.length === 0 && !ne || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!ne || H.attributes.length > 0) && !fe;
          }
          __name(J, "J");
          function L2(H, Z, ne) {
            let fe = H.getValue(), ge = [];
            ge.push("</");
            let Ce = ne("name");
            return R2(fe.name, f2.Leading | f2.Line) ? ge.push(l2([r2, Ce]), r2) : R2(fe.name, f2.Leading | f2.Block) ? ge.push(" ", Ce) : ge.push(Ce), ge.push(">"), ge;
          }
          __name(L2, "L");
          function Y(H, Z) {
            let ne = H.getValue(), fe = R2(ne), ge = R2(ne, f2.Line), Ce = ne.type === "JSXOpeningFragment";
            return [Ce ? "<" : "</", l2([ge ? r2 : fe && !Ce ? " " : "", s2(H, Z, true)]), ge ? r2 : "", ">"];
          }
          __name(Y, "Y");
          function V(H, Z, ne) {
            let fe = t2(H, d2(H, Z, ne), Z);
            return N2(H, fe, Z);
          }
          __name(V, "V");
          function O2(H, Z) {
            let ne = H.getValue(), fe = R2(ne, f2.Line);
            return [s2(H, Z, !fe), fe ? r2 : ""];
          }
          __name(O2, "O");
          function K(H, Z, ne) {
            let fe = H.getValue();
            return ["{", H.call((ge) => {
              let Ce = ["...", ne()], _e = ge.getValue();
              return !R2(_e) || !E2(ge) ? Ce : [l2([u2, t2(ge, Ce, Z)]), u2];
            }, fe.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
          }
          __name(K, "K");
          function se(H, Z, ne) {
            let fe = H.getValue();
            if (!!fe.type.startsWith("JSX"))
              switch (fe.type) {
                case "JSXAttribute":
                  return k2(H, Z, ne);
                case "JSXIdentifier":
                  return String(fe.name);
                case "JSXNamespacedName":
                  return p2(":", [ne("namespace"), ne("name")]);
                case "JSXMemberExpression":
                  return p2(".", [ne("object"), ne("property")]);
                case "JSXSpreadAttribute":
                  return K(H, Z, ne);
                case "JSXSpreadChild":
                  return K(H, Z, ne);
                case "JSXExpressionContainer":
                  return $(H, Z, ne);
                case "JSXFragment":
                case "JSXElement":
                  return V(H, Z, ne);
                case "JSXOpeningElement":
                  return M2(H, Z, ne);
                case "JSXClosingElement":
                  return L2(H, Z, ne);
                case "JSXOpeningFragment":
                case "JSXClosingFragment":
                  return Y(H, Z);
                case "JSXEmptyExpression":
                  return O2(H, Z);
                case "JSXText":
                  throw new Error("JSXTest should be handled by JSXElement");
                default:
                  throw new Error(`Unknown JSX node type: ${JSON.stringify(fe.type)}.`);
              }
          }
          __name(se, "se");
          var Q = ` 
\r	`, le = new RegExp("([" + Q + "]+)"), W2 = new RegExp("[^" + Q + "]"), X = /* @__PURE__ */ __name((H) => H.replace(new RegExp("(?:^" + le.source + "|" + le.source + "$)"), ""), "X");
          function oe(H) {
            if (H.children.length === 0)
              return true;
            if (H.children.length > 1)
              return false;
            let Z = H.children[0];
            return A2(Z) && !ae(Z);
          }
          __name(oe, "oe");
          function ae(H) {
            return A2(H) && (W2.test(F(H)) || !/\n/.test(F(H)));
          }
          __name(ae, "ae");
          function Ae(H) {
            return H.type === "JSXExpressionContainer" && A2(H.expression) && H.expression.value === " " && !R2(H.expression);
          }
          __name(Ae, "Ae");
          function z(H) {
            let Z = H.getValue(), ne = H.getParentNode();
            if (!ne || !Z || !T2(Z) || !T2(ne))
              return false;
            let fe = ne.children.indexOf(Z), ge = null;
            for (let Ce = fe; Ce > 0; Ce--) {
              let _e = ne.children[Ce - 1];
              if (!(_e.type === "JSXText" && !ae(_e))) {
                ge = _e;
                break;
              }
            }
            return ge && ge.type === "JSXExpressionContainer" && ge.expression.type === "JSXEmptyExpression" && x2(ge.expression);
          }
          __name(z, "z");
          n2.exports = { hasJsxIgnoreComment: z, printJsx: se };
        } }), Dt = ee({ "src/language-js/print/misc.js"(e2, n2) {
          "use strict";
          re();
          var { isNonEmptyArray: t2 } = Ge(), { builders: { indent: s2, join: a2, line: r2 } } = qe(), { isFlowAnnotationComment: u2 } = Ke();
          function i2(v2) {
            let w2 = v2.getValue();
            return !w2.optional || w2.type === "Identifier" && w2 === v2.getParentNode().key ? "" : w2.type === "OptionalCallExpression" || w2.type === "OptionalMemberExpression" && w2.computed ? "?." : "?";
          }
          __name(i2, "i");
          function l2(v2) {
            return v2.getValue().definite || v2.match(void 0, (w2, T2) => T2 === "id" && w2.type === "VariableDeclarator" && w2.definite) ? "!" : "";
          }
          __name(l2, "l");
          function c2(v2, w2, T2) {
            let F = v2.getValue();
            return F.typeArguments ? T2("typeArguments") : F.typeParameters ? T2("typeParameters") : "";
          }
          __name(c2, "c");
          function y2(v2, w2, T2) {
            let F = v2.getValue();
            if (!F.typeAnnotation)
              return "";
            let A2 = v2.getParentNode(), B = A2.type === "DeclareFunction" && A2.id === F;
            return u2(w2.originalText, F.typeAnnotation) ? [" /*: ", T2("typeAnnotation"), " */"] : [B ? "" : ": ", T2("typeAnnotation")];
          }
          __name(y2, "y");
          function h3(v2, w2, T2) {
            return ["::", T2("callee")];
          }
          __name(h3, "h");
          function g2(v2, w2, T2) {
            let F = v2.getValue();
            return t2(F.modifiers) ? [a2(" ", v2.map(T2, "modifiers")), " "] : "";
          }
          __name(g2, "g");
          function p2(v2, w2, T2) {
            return v2.type === "EmptyStatement" ? ";" : v2.type === "BlockStatement" || T2 ? [" ", w2] : s2([r2, w2]);
          }
          __name(p2, "p");
          function D(v2, w2, T2) {
            return ["...", T2("argument"), y2(v2, w2, T2)];
          }
          __name(D, "D");
          n2.exports = { printOptionalToken: i2, printDefiniteToken: l2, printFunctionTypeParameters: c2, printBindExpressionCallee: h3, printTypeScriptModifiers: g2, printTypeAnnotation: y2, printRestSpread: D, adjustClause: p2 };
        } }), Qt = ee({ "src/language-js/print/array.js"(e2, n2) {
          "use strict";
          re();
          var { printDanglingComments: t2 } = et(), { builders: { line: s2, softline: a2, hardline: r2, group: u2, indent: i2, ifBreak: l2, fill: c2 } } = qe(), { getLast: y2, hasNewline: h3 } = Ge(), { shouldPrintComma: g2, hasComment: p2, CommentCheckFlags: D, isNextLineEmpty: v2, isNumericLiteral: w2, isSignedNumericLiteral: T2 } = Ke(), { locStart: F } = it(), { printOptionalToken: A2, printTypeAnnotation: B } = Dt();
          function I(x2, m2, E2) {
            let o2 = x2.getValue(), d2 = [], C2 = o2.type === "TupleExpression" ? "#[" : "[", _2 = "]";
            if (o2.elements.length === 0)
              p2(o2, D.Dangling) ? d2.push(u2([C2, t2(x2, m2), a2, _2])) : d2.push(C2, _2);
            else {
              let b2 = y2(o2.elements), N2 = !(b2 && b2.type === "RestElement"), k2 = b2 === null, $ = Symbol("array"), M2 = !m2.__inJestEach && o2.elements.length > 1 && o2.elements.every((L2, Y, V) => {
                let O2 = L2 && L2.type;
                if (O2 !== "ArrayExpression" && O2 !== "ObjectExpression")
                  return false;
                let K = V[Y + 1];
                if (K && O2 !== K.type)
                  return false;
                let se = O2 === "ArrayExpression" ? "elements" : "properties";
                return L2[se] && L2[se].length > 1;
              }), q = P2(o2, m2), J = N2 ? k2 ? "," : g2(m2) ? q ? l2(",", "", { groupId: $ }) : l2(",") : "" : "";
              d2.push(u2([C2, i2([a2, q ? f2(x2, m2, E2, J) : [R2(x2, m2, "elements", E2), J], t2(x2, m2, true)]), a2, _2], { shouldBreak: M2, id: $ }));
            }
            return d2.push(A2(x2), B(x2, m2, E2)), d2;
          }
          __name(I, "I");
          function P2(x2, m2) {
            return x2.elements.length > 1 && x2.elements.every((E2) => E2 && (w2(E2) || T2(E2) && !p2(E2.argument)) && !p2(E2, D.Trailing | D.Line, (o2) => !h3(m2.originalText, F(o2), { backwards: true })));
          }
          __name(P2, "P");
          function R2(x2, m2, E2, o2) {
            let d2 = [], C2 = [];
            return x2.each((_2) => {
              d2.push(C2, u2(o2())), C2 = [",", s2], _2.getValue() && v2(_2.getValue(), m2) && C2.push(a2);
            }, E2), d2;
          }
          __name(R2, "R");
          function f2(x2, m2, E2, o2) {
            let d2 = [];
            return x2.each((C2, _2, b2) => {
              let N2 = _2 === b2.length - 1;
              d2.push([E2(), N2 ? o2 : ","]), N2 || d2.push(v2(C2.getValue(), m2) ? [r2, r2] : p2(b2[_2 + 1], D.Leading | D.Line) ? r2 : s2);
            }, "elements"), c2(d2);
          }
          __name(f2, "f");
          n2.exports = { printArray: I, printArrayItems: R2, isConciselyPrintedArray: P2 };
        } }), to = ee({ "src/language-js/print/call-arguments.js"(e2, n2) {
          "use strict";
          re();
          var { printDanglingComments: t2 } = et(), { getLast: s2, getPenultimate: a2 } = Ge(), { getFunctionParameters: r2, hasComment: u2, CommentCheckFlags: i2, isFunctionCompositionArgs: l2, isJsxNode: c2, isLongCurriedCallExpression: y2, shouldPrintComma: h3, getCallArguments: g2, iterateCallArgumentsPath: p2, isNextLineEmpty: D, isCallExpression: v2, isStringLiteral: w2, isObjectProperty: T2, isTSTypeExpression: F } = Ke(), { builders: { line: A2, hardline: B, softline: I, group: P2, indent: R2, conditionalGroup: f2, ifBreak: x2, breakParent: m2 }, utils: { willBreak: E2 } } = qe(), { ArgExpansionBailout: o2 } = Kt(), { isConciselyPrintedArray: d2 } = Qt();
          function C2(q, J, L2) {
            let Y = q.getValue(), V = Y.type === "ImportExpression", O2 = g2(Y);
            if (O2.length === 0)
              return ["(", t2(q, J, true), ")"];
            if (k2(O2))
              return ["(", L2(["arguments", 0]), ", ", L2(["arguments", 1]), ")"];
            let K = false, se = false, Q = O2.length - 1, le = [];
            p2(q, (z, H) => {
              let Z = z.getNode(), ne = [L2()];
              H === Q || (D(Z, J) ? (H === 0 && (se = true), K = true, ne.push(",", B, B)) : ne.push(",", A2)), le.push(ne);
            });
            let W2 = !(V || Y.callee && Y.callee.type === "Import") && h3(J, "all") ? "," : "";
            function X() {
              return P2(["(", R2([A2, ...le]), W2, A2, ")"], { shouldBreak: true });
            }
            __name(X, "X");
            if (K || q.getParentNode().type !== "Decorator" && l2(O2))
              return X();
            let oe = N2(O2), ae = b2(O2, J);
            if (oe || ae) {
              if (oe ? le.slice(1).some(E2) : le.slice(0, -1).some(E2))
                return X();
              let z = [];
              try {
                q.try(() => {
                  p2(q, (H, Z) => {
                    oe && Z === 0 && (z = [[L2([], { expandFirstArg: true }), le.length > 1 ? "," : "", se ? B : A2, se ? B : ""], ...le.slice(1)]), ae && Z === Q && (z = [...le.slice(0, -1), L2([], { expandLastArg: true })]);
                  });
                });
              } catch (H) {
                if (H instanceof o2)
                  return X();
                throw H;
              }
              return [le.some(E2) ? m2 : "", f2([["(", ...z, ")"], oe ? ["(", P2(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...le.slice(0, -1), P2(s2(z), { shouldBreak: true }), ")"], X()])];
            }
            let Ae = ["(", R2([I, ...le]), x2(W2), I, ")"];
            return y2(q) ? Ae : P2(Ae, { shouldBreak: le.some(E2) || K });
          }
          __name(C2, "C");
          function _2(q) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return q.type === "ObjectExpression" && (q.properties.length > 0 || u2(q)) || q.type === "ArrayExpression" && (q.elements.length > 0 || u2(q)) || q.type === "TSTypeAssertion" && _2(q.expression) || F(q) && _2(q.expression) || q.type === "FunctionExpression" || q.type === "ArrowFunctionExpression" && (!q.returnType || !q.returnType.typeAnnotation || q.returnType.typeAnnotation.type !== "TSTypeReference" || $(q.body)) && (q.body.type === "BlockStatement" || q.body.type === "ArrowFunctionExpression" && _2(q.body, true) || q.body.type === "ObjectExpression" || q.body.type === "ArrayExpression" || !J && (v2(q.body) || q.body.type === "ConditionalExpression") || c2(q.body)) || q.type === "DoExpression" || q.type === "ModuleExpression";
          }
          __name(_2, "_");
          function b2(q, J) {
            let L2 = s2(q), Y = a2(q);
            return !u2(L2, i2.Leading) && !u2(L2, i2.Trailing) && _2(L2) && (!Y || Y.type !== L2.type) && (q.length !== 2 || Y.type !== "ArrowFunctionExpression" || L2.type !== "ArrayExpression") && !(q.length > 1 && L2.type === "ArrayExpression" && d2(L2, J));
          }
          __name(b2, "b");
          function N2(q) {
            if (q.length !== 2)
              return false;
            let [J, L2] = q;
            return J.type === "ModuleExpression" && M2(L2) ? true : !u2(J) && (J.type === "FunctionExpression" || J.type === "ArrowFunctionExpression" && J.body.type === "BlockStatement") && L2.type !== "FunctionExpression" && L2.type !== "ArrowFunctionExpression" && L2.type !== "ConditionalExpression" && !_2(L2);
          }
          __name(N2, "N");
          function k2(q) {
            return q.length === 2 && q[0].type === "ArrowFunctionExpression" && r2(q[0]).length === 0 && q[0].body.type === "BlockStatement" && q[1].type === "ArrayExpression" && !q.some((J) => u2(J));
          }
          __name(k2, "k");
          function $(q) {
            return q.type === "BlockStatement" && (q.body.some((J) => J.type !== "EmptyStatement") || u2(q, i2.Dangling));
          }
          __name($, "$");
          function M2(q) {
            return q.type === "ObjectExpression" && q.properties.length === 1 && T2(q.properties[0]) && q.properties[0].key.type === "Identifier" && q.properties[0].key.name === "type" && w2(q.properties[0].value) && q.properties[0].value.value === "module";
          }
          __name(M2, "M");
          n2.exports = C2;
        } }), ro = ee({ "src/language-js/print/member.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { softline: t2, group: s2, indent: a2, label: r2 } } = qe(), { isNumericLiteral: u2, isMemberExpression: i2, isCallExpression: l2 } = Ke(), { printOptionalToken: c2 } = Dt();
          function y2(g2, p2, D) {
            let v2 = g2.getValue(), w2 = g2.getParentNode(), T2, F = 0;
            do
              T2 = g2.getParentNode(F), F++;
            while (T2 && (i2(T2) || T2.type === "TSNonNullExpression"));
            let A2 = D("object"), B = h3(g2, p2, D), I = T2 && (T2.type === "NewExpression" || T2.type === "BindExpression" || T2.type === "AssignmentExpression" && T2.left.type !== "Identifier") || v2.computed || v2.object.type === "Identifier" && v2.property.type === "Identifier" && !i2(w2) || (w2.type === "AssignmentExpression" || w2.type === "VariableDeclarator") && (l2(v2.object) && v2.object.arguments.length > 0 || v2.object.type === "TSNonNullExpression" && l2(v2.object.expression) && v2.object.expression.arguments.length > 0 || A2.label === "member-chain");
            return r2(A2.label === "member-chain" ? "member-chain" : "member", [A2, I ? B : s2(a2([t2, B]))]);
          }
          __name(y2, "y");
          function h3(g2, p2, D) {
            let v2 = D("property"), w2 = g2.getValue(), T2 = c2(g2);
            return w2.computed ? !w2.property || u2(w2.property) ? [T2, "[", v2, "]"] : s2([T2, "[", a2([t2, v2]), t2, "]"]) : [T2, ".", v2];
          }
          __name(h3, "h");
          n2.exports = { printMemberExpression: y2, printMemberLookup: h3 };
        } }), $m = ee({ "src/language-js/print/member-chain.js"(e2, n2) {
          "use strict";
          re();
          var { printComments: t2 } = et(), { getLast: s2, isNextLineEmptyAfterIndex: a2, getNextNonSpaceNonCommentCharacterIndex: r2 } = Ge(), u2 = Ot(), { isCallExpression: i2, isMemberExpression: l2, isFunctionOrArrowExpression: c2, isLongCurriedCallExpression: y2, isMemberish: h3, isNumericLiteral: g2, isSimpleCallArgument: p2, hasComment: D, CommentCheckFlags: v2, isNextLineEmpty: w2 } = Ke(), { locEnd: T2 } = it(), { builders: { join: F, hardline: A2, group: B, indent: I, conditionalGroup: P2, breakParent: R2, label: f2 }, utils: { willBreak: x2 } } = qe(), m2 = to(), { printMemberLookup: E2 } = ro(), { printOptionalToken: o2, printFunctionTypeParameters: d2, printBindExpressionCallee: C2 } = Dt();
          function _2(b2, N2, k2) {
            let $ = b2.getParentNode(), M2 = !$ || $.type === "ExpressionStatement", q = [];
            function J(ie) {
              let { originalText: ve } = N2, ce = r2(ve, ie, T2);
              return ve.charAt(ce) === ")" ? ce !== false && a2(ve, ce + 1) : w2(ie, N2);
            }
            __name(J, "J");
            function L2(ie) {
              let ve = ie.getValue();
              i2(ve) && (h3(ve.callee) || i2(ve.callee)) ? (q.unshift({ node: ve, printed: [t2(ie, [o2(ie), d2(ie, N2, k2), m2(ie, N2, k2)], N2), J(ve) ? A2 : ""] }), ie.call((ce) => L2(ce), "callee")) : h3(ve) ? (q.unshift({ node: ve, needsParens: u2(ie, N2), printed: t2(ie, l2(ve) ? E2(ie, N2, k2) : C2(ie, N2, k2), N2) }), ie.call((ce) => L2(ce), "object")) : ve.type === "TSNonNullExpression" ? (q.unshift({ node: ve, printed: t2(ie, "!", N2) }), ie.call((ce) => L2(ce), "expression")) : q.unshift({ node: ve, printed: k2() });
            }
            __name(L2, "L");
            let Y = b2.getValue();
            q.unshift({ node: Y, printed: [o2(b2), d2(b2, N2, k2), m2(b2, N2, k2)] }), Y.callee && b2.call((ie) => L2(ie), "callee");
            let V = [], O2 = [q[0]], K = 1;
            for (; K < q.length && (q[K].node.type === "TSNonNullExpression" || i2(q[K].node) || l2(q[K].node) && q[K].node.computed && g2(q[K].node.property)); ++K)
              O2.push(q[K]);
            if (!i2(q[0].node))
              for (; K + 1 < q.length && (h3(q[K].node) && h3(q[K + 1].node)); ++K)
                O2.push(q[K]);
            V.push(O2), O2 = [];
            let se = false;
            for (; K < q.length; ++K) {
              if (se && h3(q[K].node)) {
                if (q[K].node.computed && g2(q[K].node.property)) {
                  O2.push(q[K]);
                  continue;
                }
                V.push(O2), O2 = [], se = false;
              }
              (i2(q[K].node) || q[K].node.type === "ImportExpression") && (se = true), O2.push(q[K]), D(q[K].node, v2.Trailing) && (V.push(O2), O2 = [], se = false);
            }
            O2.length > 0 && V.push(O2);
            function Q(ie) {
              return /^[A-Z]|^[$_]+$/.test(ie);
            }
            __name(Q, "Q");
            function le(ie) {
              return ie.length <= N2.tabWidth;
            }
            __name(le, "le");
            function W2(ie) {
              let ve = ie[1].length > 0 && ie[1][0].node.computed;
              if (ie[0].length === 1) {
                let U2 = ie[0][0].node;
                return U2.type === "ThisExpression" || U2.type === "Identifier" && (Q(U2.name) || M2 && le(U2.name) || ve);
              }
              let ce = s2(ie[0]).node;
              return l2(ce) && ce.property.type === "Identifier" && (Q(ce.property.name) || ve);
            }
            __name(W2, "W");
            let X = V.length >= 2 && !D(V[1][0].node) && W2(V);
            function oe(ie) {
              let ve = ie.map((ce) => ce.printed);
              return ie.length > 0 && s2(ie).needsParens ? ["(", ...ve, ")"] : ve;
            }
            __name(oe, "oe");
            function ae(ie) {
              return ie.length === 0 ? "" : I(B([A2, F(A2, ie.map(oe))]));
            }
            __name(ae, "ae");
            let Ae = V.map(oe), z = Ae, H = X ? 3 : 2, Z = V.flat(), ne = Z.slice(1, -1).some((ie) => D(ie.node, v2.Leading)) || Z.slice(0, -1).some((ie) => D(ie.node, v2.Trailing)) || V[H] && D(V[H][0].node, v2.Leading);
            if (V.length <= H && !ne)
              return y2(b2) ? z : B(z);
            let fe = s2(V[X ? 1 : 0]).node, ge = !i2(fe) && J(fe), Ce = [oe(V[0]), X ? V.slice(1, 2).map(oe) : "", ge ? A2 : "", ae(V.slice(X ? 2 : 1))], _e = q.map((ie) => {
              let { node: ve } = ie;
              return ve;
            }).filter(i2);
            function Oe() {
              let ie = s2(s2(V)).node, ve = s2(Ae);
              return i2(ie) && x2(ve) && _e.slice(0, -1).some((ce) => ce.arguments.some(c2));
            }
            __name(Oe, "Oe");
            let pe;
            return ne || _e.length > 2 && _e.some((ie) => !ie.arguments.every((ve) => p2(ve, 0))) || Ae.slice(0, -1).some(x2) || Oe() ? pe = B(Ce) : pe = [x2(z) || ge ? R2 : "", P2([z, Ce])], f2("member-chain", pe);
          }
          __name(_2, "_");
          n2.exports = _2;
        } }), no = ee({ "src/language-js/print/call-expression.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { join: t2, group: s2 } } = qe(), a2 = Ot(), { getCallArguments: r2, hasFlowAnnotationComment: u2, isCallExpression: i2, isMemberish: l2, isStringLiteral: c2, isTemplateOnItsOwnLine: y2, isTestCall: h3, iterateCallArgumentsPath: g2 } = Ke(), p2 = $m(), D = to(), { printOptionalToken: v2, printFunctionTypeParameters: w2 } = Dt();
          function T2(A2, B, I) {
            let P2 = A2.getValue(), R2 = A2.getParentNode(), f2 = P2.type === "NewExpression", x2 = P2.type === "ImportExpression", m2 = v2(A2), E2 = r2(P2);
            if (E2.length > 0 && (!x2 && !f2 && F(P2, R2) || E2.length === 1 && y2(E2[0], B.originalText) || !f2 && h3(P2, R2))) {
              let C2 = [];
              return g2(A2, () => {
                C2.push(I());
              }), [f2 ? "new " : "", I("callee"), m2, w2(A2, B, I), "(", t2(", ", C2), ")"];
            }
            let o2 = (B.parser === "babel" || B.parser === "babel-flow") && P2.callee && P2.callee.type === "Identifier" && u2(P2.callee.trailingComments);
            if (o2 && (P2.callee.trailingComments[0].printed = true), !x2 && !f2 && l2(P2.callee) && !A2.call((C2) => a2(C2, B), "callee"))
              return p2(A2, B, I);
            let d2 = [f2 ? "new " : "", x2 ? "import" : I("callee"), m2, o2 ? `/*:: ${P2.callee.trailingComments[0].value.slice(2).trim()} */` : "", w2(A2, B, I), D(A2, B, I)];
            return x2 || i2(P2.callee) ? s2(d2) : d2;
          }
          __name(T2, "T");
          function F(A2, B) {
            if (A2.callee.type !== "Identifier")
              return false;
            if (A2.callee.name === "require")
              return true;
            if (A2.callee.name === "define") {
              let I = r2(A2);
              return B.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && c2(I[0]) && I[1].type === "ArrayExpression");
            }
            return false;
          }
          __name(F, "F");
          n2.exports = { printCallExpression: T2 };
        } }), Zt = ee({ "src/language-js/print/assignment.js"(e2, n2) {
          "use strict";
          re();
          var { isNonEmptyArray: t2, getStringWidth: s2 } = Ge(), { builders: { line: a2, group: r2, indent: u2, indentIfBreak: i2, lineSuffixBoundary: l2 }, utils: { cleanDoc: c2, willBreak: y2, canBreak: h3 } } = qe(), { hasLeadingOwnLineComment: g2, isBinaryish: p2, isStringLiteral: D, isLiteral: v2, isNumericLiteral: w2, isCallExpression: T2, isMemberExpression: F, getCallArguments: A2, rawText: B, hasComment: I, isSignedNumericLiteral: P2, isObjectProperty: R2 } = Ke(), { shouldInlineLogicalExpression: f2 } = Jn(), { printCallExpression: x2 } = no();
          function m2(W2, X, oe, ae, Ae, z) {
            let H = d2(W2, X, oe, ae, z), Z = oe(z, { assignmentLayout: H });
            switch (H) {
              case "break-after-operator":
                return r2([r2(ae), Ae, r2(u2([a2, Z]))]);
              case "never-break-after-operator":
                return r2([r2(ae), Ae, " ", Z]);
              case "fluid": {
                let ne = Symbol("assignment");
                return r2([r2(ae), Ae, r2(u2(a2), { id: ne }), l2, i2(Z, { groupId: ne })]);
              }
              case "break-lhs":
                return r2([ae, Ae, " ", r2(Z)]);
              case "chain":
                return [r2(ae), Ae, a2, Z];
              case "chain-tail":
                return [r2(ae), Ae, u2([a2, Z])];
              case "chain-tail-arrow-chain":
                return [r2(ae), Ae, Z];
              case "only-left":
                return ae;
            }
          }
          __name(m2, "m");
          function E2(W2, X, oe) {
            let ae = W2.getValue();
            return m2(W2, X, oe, oe("left"), [" ", ae.operator], "right");
          }
          __name(E2, "E");
          function o2(W2, X, oe) {
            return m2(W2, X, oe, oe("id"), " =", "init");
          }
          __name(o2, "o");
          function d2(W2, X, oe, ae, Ae) {
            let z = W2.getValue(), H = z[Ae];
            if (!H)
              return "only-left";
            let Z = !b2(H);
            if (W2.match(b2, N2, (Ce) => !Z || Ce.type !== "ExpressionStatement" && Ce.type !== "VariableDeclaration"))
              return Z ? H.type === "ArrowFunctionExpression" && H.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
            if (!Z && b2(H.right) || g2(X.originalText, H))
              return "break-after-operator";
            if (H.type === "CallExpression" && H.callee.name === "require" || X.parser === "json5" || X.parser === "json")
              return "never-break-after-operator";
            if (_2(z) || k2(z) || q(z) || J(z) && h3(ae))
              return "break-lhs";
            let ge = se(z, ae, X);
            return W2.call(() => C2(W2, X, oe, ge), Ae) ? "break-after-operator" : ge || H.type === "TemplateLiteral" || H.type === "TaggedTemplateExpression" || H.type === "BooleanLiteral" || w2(H) || H.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
          }
          __name(d2, "d");
          function C2(W2, X, oe, ae) {
            let Ae = W2.getValue();
            if (p2(Ae) && !f2(Ae))
              return true;
            switch (Ae.type) {
              case "StringLiteralTypeAnnotation":
              case "SequenceExpression":
                return true;
              case "ConditionalExpression": {
                let { test: Z } = Ae;
                return p2(Z) && !f2(Z);
              }
              case "ClassExpression":
                return t2(Ae.decorators);
            }
            if (ae)
              return false;
            let z = Ae, H = [];
            for (; ; )
              if (z.type === "UnaryExpression")
                z = z.argument, H.push("argument");
              else if (z.type === "TSNonNullExpression")
                z = z.expression, H.push("expression");
              else
                break;
            return !!(D(z) || W2.call(() => V(W2, X, oe), ...H));
          }
          __name(C2, "C");
          function _2(W2) {
            if (N2(W2)) {
              let X = W2.left || W2.id;
              return X.type === "ObjectPattern" && X.properties.length > 2 && X.properties.some((oe) => R2(oe) && (!oe.shorthand || oe.value && oe.value.type === "AssignmentPattern"));
            }
            return false;
          }
          __name(_2, "_");
          function b2(W2) {
            return W2.type === "AssignmentExpression";
          }
          __name(b2, "b");
          function N2(W2) {
            return b2(W2) || W2.type === "VariableDeclarator";
          }
          __name(N2, "N");
          function k2(W2) {
            let X = $(W2);
            if (t2(X)) {
              let oe = W2.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
              if (X.length > 1 && X.some((ae) => ae[oe] || ae.default))
                return true;
            }
            return false;
          }
          __name(k2, "k");
          function $(W2) {
            return M2(W2) && W2.typeParameters && W2.typeParameters.params ? W2.typeParameters.params : null;
          }
          __name($, "$");
          function M2(W2) {
            return W2.type === "TSTypeAliasDeclaration" || W2.type === "TypeAlias";
          }
          __name(M2, "M");
          function q(W2) {
            if (W2.type !== "VariableDeclarator")
              return false;
            let { typeAnnotation: X } = W2.id;
            if (!X || !X.typeAnnotation)
              return false;
            let oe = L2(X.typeAnnotation);
            return t2(oe) && oe.length > 1 && oe.some((ae) => t2(L2(ae)) || ae.type === "TSConditionalType");
          }
          __name(q, "q");
          function J(W2) {
            return W2.type === "VariableDeclarator" && W2.init && W2.init.type === "ArrowFunctionExpression";
          }
          __name(J, "J");
          function L2(W2) {
            return Y(W2) && W2.typeParameters && W2.typeParameters.params ? W2.typeParameters.params : null;
          }
          __name(L2, "L");
          function Y(W2) {
            return W2.type === "TSTypeReference" || W2.type === "GenericTypeAnnotation";
          }
          __name(Y, "Y");
          function V(W2, X, oe) {
            let ae = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Ae = W2.getValue(), z = /* @__PURE__ */ __name(() => V(W2, X, oe, true), "z");
            if (Ae.type === "TSNonNullExpression")
              return W2.call(z, "expression");
            if (T2(Ae)) {
              if (x2(W2, X, oe).label === "member-chain")
                return false;
              let Z = A2(Ae);
              return !(Z.length === 0 || Z.length === 1 && K(Z[0], X)) || Q(Ae, oe) ? false : W2.call(z, "callee");
            }
            return F(Ae) ? W2.call(z, "object") : ae && (Ae.type === "Identifier" || Ae.type === "ThisExpression");
          }
          __name(V, "V");
          var O2 = 0.25;
          function K(W2, X) {
            let { printWidth: oe } = X;
            if (I(W2))
              return false;
            let ae = oe * O2;
            if (W2.type === "ThisExpression" || W2.type === "Identifier" && W2.name.length <= ae || P2(W2) && !I(W2.argument))
              return true;
            let Ae = W2.type === "Literal" && "regex" in W2 && W2.regex.pattern || W2.type === "RegExpLiteral" && W2.pattern;
            return Ae ? Ae.length <= ae : D(W2) ? B(W2).length <= ae : W2.type === "TemplateLiteral" ? W2.expressions.length === 0 && W2.quasis[0].value.raw.length <= ae && !W2.quasis[0].value.raw.includes(`
`) : v2(W2);
          }
          __name(K, "K");
          function se(W2, X, oe) {
            if (!R2(W2))
              return false;
            X = c2(X);
            let ae = 3;
            return typeof X == "string" && s2(X) < oe.tabWidth + ae;
          }
          __name(se, "se");
          function Q(W2, X) {
            let oe = le(W2);
            if (t2(oe)) {
              if (oe.length > 1)
                return true;
              if (oe.length === 1) {
                let Ae = oe[0];
                if (Ae.type === "TSUnionType" || Ae.type === "UnionTypeAnnotation" || Ae.type === "TSIntersectionType" || Ae.type === "IntersectionTypeAnnotation" || Ae.type === "TSTypeLiteral" || Ae.type === "ObjectTypeAnnotation")
                  return true;
              }
              let ae = W2.typeParameters ? "typeParameters" : "typeArguments";
              if (y2(X(ae)))
                return true;
            }
            return false;
          }
          __name(Q, "Q");
          function le(W2) {
            return W2.typeParameters && W2.typeParameters.params || W2.typeArguments && W2.typeArguments.params;
          }
          __name(le, "le");
          n2.exports = { printVariableDeclarator: o2, printAssignmentExpression: E2, printAssignment: m2, isArrowFunctionVariableDeclarator: J };
        } }), kr = ee({ "src/language-js/print/function-parameters.js"(e2, n2) {
          "use strict";
          re();
          var { getNextNonSpaceNonCommentCharacter: t2 } = Ge(), { printDanglingComments: s2 } = et(), { builders: { line: a2, hardline: r2, softline: u2, group: i2, indent: l2, ifBreak: c2 }, utils: { removeLines: y2, willBreak: h3 } } = qe(), { getFunctionParameters: g2, iterateFunctionParametersPath: p2, isSimpleType: D, isTestCall: v2, isTypeAnnotationAFunction: w2, isObjectType: T2, isObjectTypePropertyAFunction: F, hasRestParameter: A2, shouldPrintComma: B, hasComment: I, isNextLineEmpty: P2 } = Ke(), { locEnd: R2 } = it(), { ArgExpansionBailout: f2 } = Kt(), { printFunctionTypeParameters: x2 } = Dt();
          function m2(C2, _2, b2, N2, k2) {
            let $ = C2.getValue(), M2 = g2($), q = k2 ? x2(C2, b2, _2) : "";
            if (M2.length === 0)
              return [q, "(", s2(C2, b2, true, (se) => t2(b2.originalText, se, R2) === ")"), ")"];
            let J = C2.getParentNode(), L2 = v2(J), Y = E2($), V = [];
            if (p2(C2, (se, Q) => {
              let le = Q === M2.length - 1;
              le && $.rest && V.push("..."), V.push(_2()), !le && (V.push(","), L2 || Y ? V.push(" ") : P2(M2[Q], b2) ? V.push(r2, r2) : V.push(a2));
            }), N2) {
              if (h3(q) || h3(V))
                throw new f2();
              return i2([y2(q), "(", y2(V), ")"]);
            }
            let O2 = M2.every((se) => !se.decorators);
            return Y && O2 ? [q, "(", ...V, ")"] : L2 ? [q, "(", ...V, ")"] : (F(J) || w2(J) || J.type === "TypeAlias" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || J.type === "IntersectionTypeAnnotation" || J.type === "FunctionTypeAnnotation" && J.returnType === $) && M2.length === 1 && M2[0].name === null && $.this !== M2[0] && M2[0].typeAnnotation && $.typeParameters === null && D(M2[0].typeAnnotation) && !$.rest ? b2.arrowParens === "always" ? ["(", ...V, ")"] : V : [q, "(", l2([u2, ...V]), c2(!A2($) && B(b2, "all") ? "," : ""), u2, ")"];
          }
          __name(m2, "m");
          function E2(C2) {
            if (!C2)
              return false;
            let _2 = g2(C2);
            if (_2.length !== 1)
              return false;
            let [b2] = _2;
            return !I(b2) && (b2.type === "ObjectPattern" || b2.type === "ArrayPattern" || b2.type === "Identifier" && b2.typeAnnotation && (b2.typeAnnotation.type === "TypeAnnotation" || b2.typeAnnotation.type === "TSTypeAnnotation") && T2(b2.typeAnnotation.typeAnnotation) || b2.type === "FunctionTypeParam" && T2(b2.typeAnnotation) || b2.type === "AssignmentPattern" && (b2.left.type === "ObjectPattern" || b2.left.type === "ArrayPattern") && (b2.right.type === "Identifier" || b2.right.type === "ObjectExpression" && b2.right.properties.length === 0 || b2.right.type === "ArrayExpression" && b2.right.elements.length === 0));
          }
          __name(E2, "E");
          function o2(C2) {
            let _2;
            return C2.returnType ? (_2 = C2.returnType, _2.typeAnnotation && (_2 = _2.typeAnnotation)) : C2.typeAnnotation && (_2 = C2.typeAnnotation), _2;
          }
          __name(o2, "o");
          function d2(C2, _2) {
            let b2 = o2(C2);
            if (!b2)
              return false;
            let N2 = C2.typeParameters && C2.typeParameters.params;
            if (N2) {
              if (N2.length > 1)
                return false;
              if (N2.length === 1) {
                let k2 = N2[0];
                if (k2.constraint || k2.default)
                  return false;
              }
            }
            return g2(C2).length === 1 && (T2(b2) || h3(_2));
          }
          __name(d2, "d");
          n2.exports = { printFunctionParameters: m2, shouldHugFunctionParameters: E2, shouldGroupFunctionParameters: d2 };
        } }), Lr = ee({ "src/language-js/print/type-annotation.js"(e2, n2) {
          "use strict";
          re();
          var { printComments: t2, printDanglingComments: s2 } = et(), { isNonEmptyArray: a2 } = Ge(), { builders: { group: r2, join: u2, line: i2, softline: l2, indent: c2, align: y2, ifBreak: h3 } } = qe(), g2 = Ot(), { locStart: p2 } = it(), { isSimpleType: D, isObjectType: v2, hasLeadingOwnLineComment: w2, isObjectTypePropertyAFunction: T2, shouldPrintComma: F } = Ke(), { printAssignment: A2 } = Zt(), { printFunctionParameters: B, shouldGroupFunctionParameters: I } = kr(), { printArrayItems: P2 } = Qt();
          function R2(b2) {
            if (D(b2) || v2(b2))
              return true;
            if (b2.type === "UnionTypeAnnotation" || b2.type === "TSUnionType") {
              let N2 = b2.types.filter(($) => $.type === "VoidTypeAnnotation" || $.type === "TSVoidKeyword" || $.type === "NullLiteralTypeAnnotation" || $.type === "TSNullKeyword").length, k2 = b2.types.some(($) => $.type === "ObjectTypeAnnotation" || $.type === "TSTypeLiteral" || $.type === "GenericTypeAnnotation" || $.type === "TSTypeReference");
              if (b2.types.length - 1 === N2 && k2)
                return true;
            }
            return false;
          }
          __name(R2, "R");
          function f2(b2, N2, k2) {
            let $ = N2.semi ? ";" : "", M2 = b2.getValue(), q = [];
            return q.push("opaque type ", k2("id"), k2("typeParameters")), M2.supertype && q.push(": ", k2("supertype")), M2.impltype && q.push(" = ", k2("impltype")), q.push($), q;
          }
          __name(f2, "f");
          function x2(b2, N2, k2) {
            let $ = N2.semi ? ";" : "", M2 = b2.getValue(), q = [];
            M2.declare && q.push("declare "), q.push("type ", k2("id"), k2("typeParameters"));
            let J = M2.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
            return [A2(b2, N2, k2, q, " =", J), $];
          }
          __name(x2, "x");
          function m2(b2, N2, k2) {
            let $ = b2.getValue(), M2 = b2.map(k2, "types"), q = [], J = false;
            for (let L2 = 0; L2 < M2.length; ++L2)
              L2 === 0 ? q.push(M2[L2]) : v2($.types[L2 - 1]) && v2($.types[L2]) ? q.push([" & ", J ? c2(M2[L2]) : M2[L2]]) : !v2($.types[L2 - 1]) && !v2($.types[L2]) ? q.push(c2([" &", i2, M2[L2]])) : (L2 > 1 && (J = true), q.push(" & ", L2 > 1 ? c2(M2[L2]) : M2[L2]));
            return r2(q);
          }
          __name(m2, "m");
          function E2(b2, N2, k2) {
            let $ = b2.getValue(), M2 = b2.getParentNode(), q = M2.type !== "TypeParameterInstantiation" && M2.type !== "TSTypeParameterInstantiation" && M2.type !== "GenericTypeAnnotation" && M2.type !== "TSTypeReference" && M2.type !== "TSTypeAssertion" && M2.type !== "TupleTypeAnnotation" && M2.type !== "TSTupleType" && !(M2.type === "FunctionTypeParam" && !M2.name && b2.getParentNode(1).this !== M2) && !((M2.type === "TypeAlias" || M2.type === "VariableDeclarator" || M2.type === "TSTypeAliasDeclaration") && w2(N2.originalText, $)), J = R2($), L2 = b2.map((O2) => {
              let K = k2();
              return J || (K = y2(2, K)), t2(O2, K, N2);
            }, "types");
            if (J)
              return u2(" | ", L2);
            let Y = q && !w2(N2.originalText, $), V = [h3([Y ? i2 : "", "| "]), u2([i2, "| "], L2)];
            return g2(b2, N2) ? r2([c2(V), l2]) : M2.type === "TupleTypeAnnotation" && M2.types.length > 1 || M2.type === "TSTupleType" && M2.elementTypes.length > 1 ? r2([c2([h3(["(", l2]), V]), l2, h3(")")]) : r2(q ? c2(V) : V);
          }
          __name(E2, "E");
          function o2(b2, N2, k2) {
            let $ = b2.getValue(), M2 = [], q = b2.getParentNode(0), J = b2.getParentNode(1), L2 = b2.getParentNode(2), Y = $.type === "TSFunctionType" || !((q.type === "ObjectTypeProperty" || q.type === "ObjectTypeInternalSlot") && !q.variance && !q.optional && p2(q) === p2($) || q.type === "ObjectTypeCallProperty" || L2 && L2.type === "DeclareFunction"), V = Y && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation"), O2 = V && Y && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation") && J.type === "ArrowFunctionExpression";
            T2(q) && (Y = true, V = true), O2 && M2.push("(");
            let K = B(b2, k2, N2, false, true), se = $.returnType || $.predicate || $.typeAnnotation ? [Y ? " => " : ": ", k2("returnType"), k2("predicate"), k2("typeAnnotation")] : "", Q = I($, se);
            return M2.push(Q ? r2(K) : K), se && M2.push(se), O2 && M2.push(")"), r2(M2);
          }
          __name(o2, "o");
          function d2(b2, N2, k2) {
            let $ = b2.getValue(), M2 = $.type === "TSTupleType" ? "elementTypes" : "types", q = $[M2], J = a2(q), L2 = J ? l2 : "";
            return r2(["[", c2([L2, P2(b2, N2, M2, k2)]), h3(J && F(N2, "all") ? "," : ""), s2(b2, N2, true), L2, "]"]);
          }
          __name(d2, "d");
          function C2(b2, N2, k2) {
            let $ = b2.getValue(), M2 = $.type === "OptionalIndexedAccessType" && $.optional ? "?.[" : "[";
            return [k2("objectType"), M2, k2("indexType"), "]"];
          }
          __name(C2, "C");
          function _2(b2, N2, k2) {
            let $ = b2.getValue();
            return [$.postfix ? "" : k2, N2("typeAnnotation"), $.postfix ? k2 : ""];
          }
          __name(_2, "_");
          n2.exports = { printOpaqueType: f2, printTypeAlias: x2, printIntersectionType: m2, printUnionType: E2, printFunctionType: o2, printTupleType: d2, printIndexedAccessType: C2, shouldHugType: R2, printJSDocType: _2 };
        } }), jr = ee({ "src/language-js/print/type-parameters.js"(e2, n2) {
          "use strict";
          re();
          var { printDanglingComments: t2 } = et(), { builders: { join: s2, line: a2, hardline: r2, softline: u2, group: i2, indent: l2, ifBreak: c2 } } = qe(), { isTestCall: y2, hasComment: h3, CommentCheckFlags: g2, isTSXFile: p2, shouldPrintComma: D, getFunctionParameters: v2, isObjectType: w2 } = Ke(), { createGroupIdMapper: T2 } = Ge(), { shouldHugType: F } = Lr(), { isArrowFunctionVariableDeclarator: A2 } = Zt(), B = T2("typeParameters");
          function I(f2, x2, m2, E2) {
            let o2 = f2.getValue();
            if (!o2[E2])
              return "";
            if (!Array.isArray(o2[E2]))
              return m2(E2);
            let d2 = f2.getNode(2), C2 = d2 && y2(d2);
            if (!f2.match((k2) => !(k2[E2].length === 1 && w2(k2[E2][0])), void 0, (k2, $) => $ === "typeAnnotation", (k2) => k2.type === "Identifier", A2) && (C2 || o2[E2].length === 0 || o2[E2].length === 1 && (o2[E2][0].type === "NullableTypeAnnotation" || F(o2[E2][0]))))
              return ["<", s2(", ", f2.map(m2, E2)), P2(f2, x2), ">"];
            let N2 = o2.type === "TSTypeParameterInstantiation" ? "" : v2(o2).length === 1 && p2(x2) && !o2[E2][0].constraint && f2.getParentNode().type === "ArrowFunctionExpression" ? "," : D(x2, "all") ? c2(",") : "";
            return i2(["<", l2([u2, s2([",", a2], f2.map(m2, E2))]), N2, u2, ">"], { id: B(o2) });
          }
          __name(I, "I");
          function P2(f2, x2) {
            let m2 = f2.getValue();
            if (!h3(m2, g2.Dangling))
              return "";
            let E2 = !h3(m2, g2.Line), o2 = t2(f2, x2, E2);
            return E2 ? o2 : [o2, r2];
          }
          __name(P2, "P");
          function R2(f2, x2, m2) {
            let E2 = f2.getValue(), o2 = [], d2 = f2.getParentNode();
            return d2.type === "TSMappedType" ? (o2.push("[", m2("name")), E2.constraint && o2.push(" in ", m2("constraint")), d2.nameType && o2.push(" as ", f2.callParent(() => m2("nameType"))), o2.push("]"), o2) : (E2.variance && o2.push(m2("variance")), E2.in && o2.push("in "), E2.out && o2.push("out "), o2.push(m2("name")), E2.bound && o2.push(": ", m2("bound")), E2.constraint && o2.push(" extends ", m2("constraint")), E2.default && o2.push(" = ", m2("default")), o2);
          }
          __name(R2, "R");
          n2.exports = { printTypeParameter: R2, printTypeParameters: I, getTypeParametersGroupId: B };
        } }), er = ee({ "src/language-js/print/property.js"(e2, n2) {
          "use strict";
          re();
          var { printComments: t2 } = et(), { printString: s2, printNumber: a2 } = Ge(), { isNumericLiteral: r2, isSimpleNumber: u2, isStringLiteral: i2, isStringPropSafeToUnquote: l2, rawText: c2 } = Ke(), { printAssignment: y2 } = Zt(), h3 = /* @__PURE__ */ new WeakMap();
          function g2(D, v2, w2) {
            let T2 = D.getNode();
            if (T2.computed)
              return ["[", w2("key"), "]"];
            let F = D.getParentNode(), { key: A2 } = T2;
            if (T2.type === "ClassPrivateProperty" && A2.type === "Identifier")
              return ["#", w2("key")];
            if (v2.quoteProps === "consistent" && !h3.has(F)) {
              let B = (F.properties || F.body || F.members).some((I) => !I.computed && I.key && i2(I.key) && !l2(I, v2));
              h3.set(F, B);
            }
            if ((A2.type === "Identifier" || r2(A2) && u2(a2(c2(A2))) && String(A2.value) === a2(c2(A2)) && !(v2.parser === "typescript" || v2.parser === "babel-ts")) && (v2.parser === "json" || v2.quoteProps === "consistent" && h3.get(F))) {
              let B = s2(JSON.stringify(A2.type === "Identifier" ? A2.name : A2.value.toString()), v2);
              return D.call((I) => t2(I, B, v2), "key");
            }
            return l2(T2, v2) && (v2.quoteProps === "as-needed" || v2.quoteProps === "consistent" && !h3.get(F)) ? D.call((B) => t2(B, /^\d/.test(A2.value) ? a2(A2.value) : A2.value, v2), "key") : w2("key");
          }
          __name(g2, "g");
          function p2(D, v2, w2) {
            return D.getValue().shorthand ? w2("value") : y2(D, v2, w2, g2(D, v2, w2), ":", "value");
          }
          __name(p2, "p");
          n2.exports = { printProperty: p2, printPropertyKey: g2 };
        } }), Or = ee({ "src/language-js/print/function.js"(e2, n2) {
          "use strict";
          re();
          var t2 = Yt(), { printDanglingComments: s2, printCommentsSeparately: a2 } = et(), r2 = lt(), { getNextNonSpaceNonCommentCharacterIndex: u2 } = Ge(), { builders: { line: i2, softline: l2, group: c2, indent: y2, ifBreak: h3, hardline: g2, join: p2, indentIfBreak: D }, utils: { removeLines: v2, willBreak: w2 } } = qe(), { ArgExpansionBailout: T2 } = Kt(), { getFunctionParameters: F, hasLeadingOwnLineComment: A2, isFlowAnnotationComment: B, isJsxNode: I, isTemplateOnItsOwnLine: P2, shouldPrintComma: R2, startsWithNoLookaheadToken: f2, isBinaryish: x2, isLineComment: m2, hasComment: E2, getComments: o2, CommentCheckFlags: d2, isCallLikeExpression: C2, isCallExpression: _2, getCallArguments: b2, hasNakedLeftSide: N2, getLeftSide: k2 } = Ke(), { locEnd: $ } = it(), { printFunctionParameters: M2, shouldGroupFunctionParameters: q } = kr(), { printPropertyKey: J } = er(), { printFunctionTypeParameters: L2 } = Dt();
          function Y(H, Z, ne, fe) {
            let ge = H.getValue(), Ce = false;
            if ((ge.type === "FunctionDeclaration" || ge.type === "FunctionExpression") && fe && fe.expandLastArg) {
              let ve = H.getParentNode();
              _2(ve) && b2(ve).length > 1 && (Ce = true);
            }
            let _e = [];
            ge.type === "TSDeclareFunction" && ge.declare && _e.push("declare "), ge.async && _e.push("async "), ge.generator ? _e.push("function* ") : _e.push("function "), ge.id && _e.push(Z("id"));
            let Oe = M2(H, Z, ne, Ce), pe = X(H, Z, ne), ie = q(ge, pe);
            return _e.push(L2(H, ne, Z), c2([ie ? c2(Oe) : Oe, pe]), ge.body ? " " : "", Z("body")), ne.semi && (ge.declare || !ge.body) && _e.push(";"), _e;
          }
          __name(Y, "Y");
          function V(H, Z, ne) {
            let fe = H.getNode(), { kind: ge } = fe, Ce = fe.value || fe, _e = [];
            return !ge || ge === "init" || ge === "method" || ge === "constructor" ? Ce.async && _e.push("async ") : (t2.ok(ge === "get" || ge === "set"), _e.push(ge, " ")), Ce.generator && _e.push("*"), _e.push(J(H, Z, ne), fe.optional || fe.key.optional ? "?" : ""), fe === Ce ? _e.push(O2(H, Z, ne)) : Ce.type === "FunctionExpression" ? _e.push(H.call((Oe) => O2(Oe, Z, ne), "value")) : _e.push(ne("value")), _e;
          }
          __name(V, "V");
          function O2(H, Z, ne) {
            let fe = H.getNode(), ge = M2(H, ne, Z), Ce = X(H, ne, Z), _e = q(fe, Ce), Oe = [L2(H, Z, ne), c2([_e ? c2(ge) : ge, Ce])];
            return fe.body ? Oe.push(" ", ne("body")) : Oe.push(Z.semi ? ";" : ""), Oe;
          }
          __name(O2, "O");
          function K(H, Z, ne, fe) {
            let ge = H.getValue(), Ce = [];
            if (ge.async && Ce.push("async "), W2(H, Z))
              Ce.push(ne(["params", 0]));
            else {
              let Oe = fe && (fe.expandLastArg || fe.expandFirstArg), pe = X(H, ne, Z);
              if (Oe) {
                if (w2(pe))
                  throw new T2();
                pe = c2(v2(pe));
              }
              Ce.push(c2([M2(H, ne, Z, Oe, true), pe]));
            }
            let _e = s2(H, Z, true, (Oe) => {
              let pe = u2(Z.originalText, Oe, $);
              return pe !== false && Z.originalText.slice(pe, pe + 2) === "=>";
            });
            return _e && Ce.push(" ", _e), Ce;
          }
          __name(K, "K");
          function se(H, Z, ne, fe, ge, Ce) {
            let _e = H.getName(), Oe = H.getParentNode(), pe = C2(Oe) && _e === "callee", ie = Boolean(Z && Z.assignmentLayout), ve = Ce.body.type !== "BlockStatement" && Ce.body.type !== "ObjectExpression" && Ce.body.type !== "SequenceExpression", ce = pe && ve || Z && Z.assignmentLayout === "chain-tail-arrow-chain", U2 = Symbol("arrow-chain");
            return Ce.body.type === "SequenceExpression" && (ge = c2(["(", y2([l2, ge]), l2, ")"])), c2([c2(y2([pe || ie ? l2 : "", c2(p2([" =>", i2], ne), { shouldBreak: fe })]), { id: U2, shouldBreak: ce }), " =>", D(ve ? y2([i2, ge]) : [" ", ge], { groupId: U2 }), pe ? h3(l2, "", { groupId: U2 }) : ""]);
          }
          __name(se, "se");
          function Q(H, Z, ne, fe) {
            let ge = H.getValue(), Ce = [], _e = [], Oe = false;
            if ((/* @__PURE__ */ __name(function U2() {
              let de = K(H, Z, ne, fe);
              if (Ce.length === 0)
                Ce.push(de);
              else {
                let { leading: De, trailing: he } = a2(H, Z);
                Ce.push([De, de]), _e.unshift(he);
              }
              Oe = Oe || ge.returnType && F(ge).length > 0 || ge.typeParameters || F(ge).some((De) => De.type !== "Identifier"), ge.body.type !== "ArrowFunctionExpression" || fe && fe.expandLastArg ? _e.unshift(ne("body", fe)) : (ge = ge.body, H.call(U2, "body"));
            }, "U"))(), Ce.length > 1)
              return se(H, fe, Ce, Oe, _e, ge);
            let pe = Ce;
            if (pe.push(" =>"), !A2(Z.originalText, ge.body) && (ge.body.type === "ArrayExpression" || ge.body.type === "ObjectExpression" || ge.body.type === "BlockStatement" || I(ge.body) || P2(ge.body, Z.originalText) || ge.body.type === "ArrowFunctionExpression" || ge.body.type === "DoExpression"))
              return c2([...pe, " ", _e]);
            if (ge.body.type === "SequenceExpression")
              return c2([...pe, c2([" (", y2([l2, _e]), l2, ")"])]);
            let ie = (fe && fe.expandLastArg || H.getParentNode().type === "JSXExpressionContainer") && !E2(ge), ve = fe && fe.expandLastArg && R2(Z, "all"), ce = ge.body.type === "ConditionalExpression" && !f2(ge.body, false);
            return c2([...pe, c2([y2([i2, ce ? h3("", "(") : "", _e, ce ? h3("", ")") : ""]), ie ? [h3(ve ? "," : ""), l2] : ""])]);
          }
          __name(Q, "Q");
          function le(H) {
            let Z = F(H);
            return Z.length === 1 && !H.typeParameters && !E2(H, d2.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !E2(Z[0]) && !Z[0].optional && !H.predicate && !H.returnType;
          }
          __name(le, "le");
          function W2(H, Z) {
            if (Z.arrowParens === "always")
              return false;
            if (Z.arrowParens === "avoid") {
              let ne = H.getValue();
              return le(ne);
            }
            return false;
          }
          __name(W2, "W");
          function X(H, Z, ne) {
            let fe = H.getValue(), ge = Z("returnType");
            if (fe.returnType && B(ne.originalText, fe.returnType))
              return [" /*: ", ge, " */"];
            let Ce = [ge];
            return fe.returnType && fe.returnType.typeAnnotation && Ce.unshift(": "), fe.predicate && Ce.push(fe.returnType ? " " : ": ", Z("predicate")), Ce;
          }
          __name(X, "X");
          function oe(H, Z, ne) {
            let fe = H.getValue(), ge = Z.semi ? ";" : "", Ce = [];
            fe.argument && (z(Z, fe.argument) ? Ce.push([" (", y2([g2, ne("argument")]), g2, ")"]) : x2(fe.argument) || fe.argument.type === "SequenceExpression" ? Ce.push(c2([h3(" (", " "), y2([l2, ne("argument")]), l2, h3(")")])) : Ce.push(" ", ne("argument")));
            let _e = o2(fe), Oe = r2(_e), pe = Oe && m2(Oe);
            return pe && Ce.push(ge), E2(fe, d2.Dangling) && Ce.push(" ", s2(H, Z, true)), pe || Ce.push(ge), Ce;
          }
          __name(oe, "oe");
          function ae(H, Z, ne) {
            return ["return", oe(H, Z, ne)];
          }
          __name(ae, "ae");
          function Ae(H, Z, ne) {
            return ["throw", oe(H, Z, ne)];
          }
          __name(Ae, "Ae");
          function z(H, Z) {
            if (A2(H.originalText, Z))
              return true;
            if (N2(Z)) {
              let ne = Z, fe;
              for (; fe = k2(ne); )
                if (ne = fe, A2(H.originalText, ne))
                  return true;
            }
            return false;
          }
          __name(z, "z");
          n2.exports = { printFunction: Y, printArrowFunction: Q, printMethod: V, printReturnStatement: ae, printThrowStatement: Ae, printMethodInternal: O2, shouldPrintParamsWithoutParens: W2 };
        } }), zn = ee({ "src/language-js/print/decorators.js"(e2, n2) {
          "use strict";
          re();
          var { isNonEmptyArray: t2, hasNewline: s2 } = Ge(), { builders: { line: a2, hardline: r2, join: u2, breakParent: i2, group: l2 } } = qe(), { locStart: c2, locEnd: y2 } = it(), { getParentExportDeclaration: h3 } = Ke();
          function g2(T2, F, A2) {
            let B = T2.getValue();
            return l2([u2(a2, T2.map(A2, "decorators")), v2(B, F) ? r2 : a2]);
          }
          __name(g2, "g");
          function p2(T2, F, A2) {
            return [u2(r2, T2.map(A2, "declaration", "decorators")), r2];
          }
          __name(p2, "p");
          function D(T2, F, A2) {
            let B = T2.getValue(), { decorators: I } = B;
            if (!t2(I) || w2(T2.getParentNode()))
              return;
            let P2 = B.type === "ClassExpression" || B.type === "ClassDeclaration" || v2(B, F);
            return [h3(T2) ? r2 : P2 ? i2 : "", u2(a2, T2.map(A2, "decorators")), a2];
          }
          __name(D, "D");
          function v2(T2, F) {
            return T2.decorators.some((A2) => s2(F.originalText, y2(A2)));
          }
          __name(v2, "v");
          function w2(T2) {
            if (T2.type !== "ExportDefaultDeclaration" && T2.type !== "ExportNamedDeclaration" && T2.type !== "DeclareExportDeclaration")
              return false;
            let F = T2.declaration && T2.declaration.decorators;
            return t2(F) && c2(T2) === c2(F[0]);
          }
          __name(w2, "w");
          n2.exports = { printDecorators: D, printClassMemberDecorators: g2, printDecoratorsBeforeExport: p2, hasDecoratorsBeforeExport: w2 };
        } }), tr = ee({ "src/language-js/print/class.js"(e2, n2) {
          "use strict";
          re();
          var { isNonEmptyArray: t2, createGroupIdMapper: s2 } = Ge(), { printComments: a2, printDanglingComments: r2 } = et(), { builders: { join: u2, line: i2, hardline: l2, softline: c2, group: y2, indent: h3, ifBreak: g2 } } = qe(), { hasComment: p2, CommentCheckFlags: D } = Ke(), { getTypeParametersGroupId: v2 } = jr(), { printMethod: w2 } = Or(), { printOptionalToken: T2, printTypeAnnotation: F, printDefiniteToken: A2 } = Dt(), { printPropertyKey: B } = er(), { printAssignment: I } = Zt(), { printClassMemberDecorators: P2 } = zn();
          function R2(b2, N2, k2) {
            let $ = b2.getValue(), M2 = [];
            $.declare && M2.push("declare "), $.abstract && M2.push("abstract "), M2.push("class");
            let q = $.id && p2($.id, D.Trailing) || $.typeParameters && p2($.typeParameters, D.Trailing) || $.superClass && p2($.superClass) || t2($.extends) || t2($.mixins) || t2($.implements), J = [], L2 = [];
            if ($.id && J.push(" ", k2("id")), J.push(k2("typeParameters")), $.superClass) {
              let Y = [d2(b2, N2, k2), k2("superTypeParameters")], V = b2.call((O2) => ["extends ", a2(O2, Y, N2)], "superClass");
              q ? L2.push(i2, y2(V)) : L2.push(" ", V);
            } else
              L2.push(o2(b2, N2, k2, "extends"));
            if (L2.push(o2(b2, N2, k2, "mixins"), o2(b2, N2, k2, "implements")), q) {
              let Y;
              E2($) ? Y = [...J, h3(L2)] : Y = h3([...J, L2]), M2.push(y2(Y, { id: f2($) }));
            } else
              M2.push(...J, ...L2);
            return M2.push(" ", k2("body")), M2;
          }
          __name(R2, "R");
          var f2 = s2("heritageGroup");
          function x2(b2) {
            return g2(l2, "", { groupId: f2(b2) });
          }
          __name(x2, "x");
          function m2(b2) {
            return ["superClass", "extends", "mixins", "implements"].filter((N2) => Boolean(b2[N2])).length > 1;
          }
          __name(m2, "m");
          function E2(b2) {
            return b2.typeParameters && !p2(b2.typeParameters, D.Trailing | D.Line) && !m2(b2);
          }
          __name(E2, "E");
          function o2(b2, N2, k2, $) {
            let M2 = b2.getValue();
            if (!t2(M2[$]))
              return "";
            let q = r2(b2, N2, true, (J) => {
              let { marker: L2 } = J;
              return L2 === $;
            });
            return [E2(M2) ? g2(" ", i2, { groupId: v2(M2.typeParameters) }) : i2, q, q && l2, $, y2(h3([i2, u2([",", i2], b2.map(k2, $))]))];
          }
          __name(o2, "o");
          function d2(b2, N2, k2) {
            let $ = k2("superClass");
            return b2.getParentNode().type === "AssignmentExpression" ? y2(g2(["(", h3([c2, $]), c2, ")"], $)) : $;
          }
          __name(d2, "d");
          function C2(b2, N2, k2) {
            let $ = b2.getValue(), M2 = [];
            return t2($.decorators) && M2.push(P2(b2, N2, k2)), $.accessibility && M2.push($.accessibility + " "), $.readonly && M2.push("readonly "), $.declare && M2.push("declare "), $.static && M2.push("static "), ($.type === "TSAbstractMethodDefinition" || $.abstract) && M2.push("abstract "), $.override && M2.push("override "), M2.push(w2(b2, N2, k2)), M2;
          }
          __name(C2, "C");
          function _2(b2, N2, k2) {
            let $ = b2.getValue(), M2 = [], q = N2.semi ? ";" : "";
            return t2($.decorators) && M2.push(P2(b2, N2, k2)), $.accessibility && M2.push($.accessibility + " "), $.declare && M2.push("declare "), $.static && M2.push("static "), ($.type === "TSAbstractPropertyDefinition" || $.abstract) && M2.push("abstract "), $.override && M2.push("override "), $.readonly && M2.push("readonly "), $.variance && M2.push(k2("variance")), $.type === "ClassAccessorProperty" && M2.push("accessor "), M2.push(B(b2, N2, k2), T2(b2), A2(b2), F(b2, N2, k2)), [I(b2, N2, k2, M2, " =", "value"), q];
          }
          __name(_2, "_");
          n2.exports = { printClass: R2, printClassMethod: C2, printClassProperty: _2, printHardlineAfterHeritage: x2 };
        } }), uo = ee({ "src/language-js/print/interface.js"(e2, n2) {
          "use strict";
          re();
          var { isNonEmptyArray: t2 } = Ge(), { builders: { join: s2, line: a2, group: r2, indent: u2, ifBreak: i2 } } = qe(), { hasComment: l2, identity: c2, CommentCheckFlags: y2 } = Ke(), { getTypeParametersGroupId: h3 } = jr(), { printTypeScriptModifiers: g2 } = Dt();
          function p2(D, v2, w2) {
            let T2 = D.getValue(), F = [];
            T2.declare && F.push("declare "), T2.type === "TSInterfaceDeclaration" && F.push(T2.abstract ? "abstract " : "", g2(D, v2, w2)), F.push("interface");
            let A2 = [], B = [];
            T2.type !== "InterfaceTypeAnnotation" && A2.push(" ", w2("id"), w2("typeParameters"));
            let I = T2.typeParameters && !l2(T2.typeParameters, y2.Trailing | y2.Line);
            return t2(T2.extends) && B.push(I ? i2(" ", a2, { groupId: h3(T2.typeParameters) }) : a2, "extends ", (T2.extends.length === 1 ? c2 : u2)(s2([",", a2], D.map(w2, "extends")))), T2.id && l2(T2.id, y2.Trailing) || t2(T2.extends) ? I ? F.push(r2([...A2, u2(B)])) : F.push(r2(u2([...A2, ...B]))) : F.push(...A2, ...B), F.push(" ", w2("body")), r2(F);
          }
          __name(p2, "p");
          n2.exports = { printInterface: p2 };
        } }), so = ee({ "src/language-js/print/module.js"(e2, n2) {
          "use strict";
          re();
          var { isNonEmptyArray: t2 } = Ge(), { builders: { softline: s2, group: a2, indent: r2, join: u2, line: i2, ifBreak: l2, hardline: c2 } } = qe(), { printDanglingComments: y2 } = et(), { hasComment: h3, CommentCheckFlags: g2, shouldPrintComma: p2, needsHardlineAfterDanglingComment: D, isStringLiteral: v2, rawText: w2 } = Ke(), { locStart: T2, hasSameLoc: F } = it(), { hasDecoratorsBeforeExport: A2, printDecoratorsBeforeExport: B } = zn();
          function I(_2, b2, N2) {
            let k2 = _2.getValue(), $ = b2.semi ? ";" : "", M2 = [], { importKind: q } = k2;
            return M2.push("import"), q && q !== "value" && M2.push(" ", q), M2.push(m2(_2, b2, N2), x2(_2, b2, N2), o2(_2, b2, N2), $), M2;
          }
          __name(I, "I");
          function P2(_2, b2, N2) {
            let k2 = _2.getValue(), $ = [];
            A2(k2) && $.push(B(_2, b2, N2));
            let { type: M2, exportKind: q, declaration: J } = k2;
            return $.push("export"), (k2.default || M2 === "ExportDefaultDeclaration") && $.push(" default"), h3(k2, g2.Dangling) && ($.push(" ", y2(_2, b2, true)), D(k2) && $.push(c2)), J ? $.push(" ", N2("declaration")) : $.push(q === "type" ? " type" : "", m2(_2, b2, N2), x2(_2, b2, N2), o2(_2, b2, N2)), f2(k2, b2) && $.push(";"), $;
          }
          __name(P2, "P");
          function R2(_2, b2, N2) {
            let k2 = _2.getValue(), $ = b2.semi ? ";" : "", M2 = [], { exportKind: q, exported: J } = k2;
            return M2.push("export"), q === "type" && M2.push(" type"), M2.push(" *"), J && M2.push(" as ", N2("exported")), M2.push(x2(_2, b2, N2), o2(_2, b2, N2), $), M2;
          }
          __name(R2, "R");
          function f2(_2, b2) {
            if (!b2.semi)
              return false;
            let { type: N2, declaration: k2 } = _2, $ = _2.default || N2 === "ExportDefaultDeclaration";
            if (!k2)
              return true;
            let { type: M2 } = k2;
            return !!($ && M2 !== "ClassDeclaration" && M2 !== "FunctionDeclaration" && M2 !== "TSInterfaceDeclaration" && M2 !== "DeclareClass" && M2 !== "DeclareFunction" && M2 !== "TSDeclareFunction" && M2 !== "EnumDeclaration");
          }
          __name(f2, "f");
          function x2(_2, b2, N2) {
            let k2 = _2.getValue();
            if (!k2.source)
              return "";
            let $ = [];
            return E2(k2, b2) || $.push(" from"), $.push(" ", N2("source")), $;
          }
          __name(x2, "x");
          function m2(_2, b2, N2) {
            let k2 = _2.getValue();
            if (E2(k2, b2))
              return "";
            let $ = [" "];
            if (t2(k2.specifiers)) {
              let M2 = [], q = [];
              _2.each(() => {
                let J = _2.getValue().type;
                if (J === "ExportNamespaceSpecifier" || J === "ExportDefaultSpecifier" || J === "ImportNamespaceSpecifier" || J === "ImportDefaultSpecifier")
                  M2.push(N2());
                else if (J === "ExportSpecifier" || J === "ImportSpecifier")
                  q.push(N2());
                else
                  throw new Error(`Unknown specifier type ${JSON.stringify(J)}`);
              }, "specifiers"), $.push(u2(", ", M2)), q.length > 0 && (M2.length > 0 && $.push(", "), q.length > 1 || M2.length > 0 || k2.specifiers.some((L2) => h3(L2)) ? $.push(a2(["{", r2([b2.bracketSpacing ? i2 : s2, u2([",", i2], q)]), l2(p2(b2) ? "," : ""), b2.bracketSpacing ? i2 : s2, "}"])) : $.push(["{", b2.bracketSpacing ? " " : "", ...q, b2.bracketSpacing ? " " : "", "}"]));
            } else
              $.push("{}");
            return $;
          }
          __name(m2, "m");
          function E2(_2, b2) {
            let { type: N2, importKind: k2, source: $, specifiers: M2 } = _2;
            return N2 !== "ImportDeclaration" || t2(M2) || k2 === "type" ? false : !/{\s*}/.test(b2.originalText.slice(T2(_2), T2($)));
          }
          __name(E2, "E");
          function o2(_2, b2, N2) {
            let k2 = _2.getNode();
            return t2(k2.assertions) ? [" assert {", b2.bracketSpacing ? " " : "", u2(", ", _2.map(N2, "assertions")), b2.bracketSpacing ? " " : "", "}"] : "";
          }
          __name(o2, "o");
          function d2(_2, b2, N2) {
            let k2 = _2.getNode(), { type: $ } = k2, M2 = [], q = $ === "ImportSpecifier" ? k2.importKind : k2.exportKind;
            q && q !== "value" && M2.push(q, " ");
            let J = $.startsWith("Import"), L2 = J ? "imported" : "local", Y = J ? "local" : "exported", V = k2[L2], O2 = k2[Y], K = "", se = "";
            return $ === "ExportNamespaceSpecifier" || $ === "ImportNamespaceSpecifier" ? K = "*" : V && (K = N2(L2)), O2 && !C2(k2) && (se = N2(Y)), M2.push(K, K && se ? " as " : "", se), M2;
          }
          __name(d2, "d");
          function C2(_2) {
            if (_2.type !== "ImportSpecifier" && _2.type !== "ExportSpecifier")
              return false;
            let { local: b2, [_2.type === "ImportSpecifier" ? "imported" : "exported"]: N2 } = _2;
            if (b2.type !== N2.type || !F(b2, N2))
              return false;
            if (v2(b2))
              return b2.value === N2.value && w2(b2) === w2(N2);
            switch (b2.type) {
              case "Identifier":
                return b2.name === N2.name;
              default:
                return false;
            }
          }
          __name(C2, "C");
          n2.exports = { printImportDeclaration: I, printExportDeclaration: P2, printExportAllDeclaration: R2, printModuleSpecifier: d2 };
        } }), Xn = ee({ "src/language-js/print/object.js"(e2, n2) {
          "use strict";
          re();
          var { printDanglingComments: t2 } = et(), { builders: { line: s2, softline: a2, group: r2, indent: u2, ifBreak: i2, hardline: l2 } } = qe(), { getLast: c2, hasNewlineInRange: y2, hasNewline: h3, isNonEmptyArray: g2 } = Ge(), { shouldPrintComma: p2, hasComment: D, getComments: v2, CommentCheckFlags: w2, isNextLineEmpty: T2 } = Ke(), { locStart: F, locEnd: A2 } = it(), { printOptionalToken: B, printTypeAnnotation: I } = Dt(), { shouldHugFunctionParameters: P2 } = kr(), { shouldHugType: R2 } = Lr(), { printHardlineAfterHeritage: f2 } = tr();
          function x2(m2, E2, o2) {
            let d2 = E2.semi ? ";" : "", C2 = m2.getValue(), _2;
            C2.type === "TSTypeLiteral" ? _2 = "members" : C2.type === "TSInterfaceBody" ? _2 = "body" : _2 = "properties";
            let b2 = C2.type === "ObjectTypeAnnotation", N2 = [_2];
            b2 && N2.push("indexers", "callProperties", "internalSlots");
            let k2 = N2.map((W2) => C2[W2][0]).sort((W2, X) => F(W2) - F(X))[0], $ = m2.getParentNode(0), M2 = b2 && $ && ($.type === "InterfaceDeclaration" || $.type === "DeclareInterface" || $.type === "DeclareClass") && m2.getName() === "body", q = C2.type === "TSInterfaceBody" || M2 || C2.type === "ObjectPattern" && $.type !== "FunctionDeclaration" && $.type !== "FunctionExpression" && $.type !== "ArrowFunctionExpression" && $.type !== "ObjectMethod" && $.type !== "ClassMethod" && $.type !== "ClassPrivateMethod" && $.type !== "AssignmentPattern" && $.type !== "CatchClause" && C2.properties.some((W2) => W2.value && (W2.value.type === "ObjectPattern" || W2.value.type === "ArrayPattern")) || C2.type !== "ObjectPattern" && k2 && y2(E2.originalText, F(C2), F(k2)), J = M2 ? ";" : C2.type === "TSInterfaceBody" || C2.type === "TSTypeLiteral" ? i2(d2, ";") : ",", L2 = C2.type === "RecordExpression" ? "#{" : C2.exact ? "{|" : "{", Y = C2.exact ? "|}" : "}", V = [];
            for (let W2 of N2)
              m2.each((X) => {
                let oe = X.getValue();
                V.push({ node: oe, printed: o2(), loc: F(oe) });
              }, W2);
            N2.length > 1 && V.sort((W2, X) => W2.loc - X.loc);
            let O2 = [], K = V.map((W2) => {
              let X = [...O2, r2(W2.printed)];
              return O2 = [J, s2], (W2.node.type === "TSPropertySignature" || W2.node.type === "TSMethodSignature" || W2.node.type === "TSConstructSignatureDeclaration") && D(W2.node, w2.PrettierIgnore) && O2.shift(), T2(W2.node, E2) && O2.push(l2), X;
            });
            if (C2.inexact) {
              let W2;
              if (D(C2, w2.Dangling)) {
                let X = D(C2, w2.Line);
                W2 = [t2(m2, E2, true), X || h3(E2.originalText, A2(c2(v2(C2)))) ? l2 : s2, "..."];
              } else
                W2 = ["..."];
              K.push([...O2, ...W2]);
            }
            let se = c2(C2[_2]), Q = !(C2.inexact || se && se.type === "RestElement" || se && (se.type === "TSPropertySignature" || se.type === "TSCallSignatureDeclaration" || se.type === "TSMethodSignature" || se.type === "TSConstructSignatureDeclaration") && D(se, w2.PrettierIgnore)), le;
            if (K.length === 0) {
              if (!D(C2, w2.Dangling))
                return [L2, Y, I(m2, E2, o2)];
              le = r2([L2, t2(m2, E2), a2, Y, B(m2), I(m2, E2, o2)]);
            } else
              le = [M2 && g2(C2.properties) ? f2($) : "", L2, u2([E2.bracketSpacing ? s2 : a2, ...K]), i2(Q && (J !== "," || p2(E2)) ? J : ""), E2.bracketSpacing ? s2 : a2, Y, B(m2), I(m2, E2, o2)];
            return m2.match((W2) => W2.type === "ObjectPattern" && !W2.decorators, (W2, X, oe) => P2(W2) && (X === "params" || X === "parameters" || X === "this" || X === "rest") && oe === 0) || m2.match(R2, (W2, X) => X === "typeAnnotation", (W2, X) => X === "typeAnnotation", (W2, X, oe) => P2(W2) && (X === "params" || X === "parameters" || X === "this" || X === "rest") && oe === 0) || !q && m2.match((W2) => W2.type === "ObjectPattern", (W2) => W2.type === "AssignmentExpression" || W2.type === "VariableDeclarator") ? le : r2(le, { shouldBreak: q });
          }
          __name(x2, "x");
          n2.exports = { printObject: x2 };
        } }), Vm = ee({ "src/language-js/print/flow.js"(e2, n2) {
          "use strict";
          re();
          var t2 = Yt(), { printDanglingComments: s2 } = et(), { printString: a2, printNumber: r2 } = Ge(), { builders: { hardline: u2, softline: i2, group: l2, indent: c2 } } = qe(), { getParentExportDeclaration: y2, isFunctionNotation: h3, isGetterOrSetter: g2, rawText: p2, shouldPrintComma: D } = Ke(), { locStart: v2, locEnd: w2 } = it(), { replaceTextEndOfLine: T2 } = Xt(), { printClass: F } = tr(), { printOpaqueType: A2, printTypeAlias: B, printIntersectionType: I, printUnionType: P2, printFunctionType: R2, printTupleType: f2, printIndexedAccessType: x2 } = Lr(), { printInterface: m2 } = uo(), { printTypeParameter: E2, printTypeParameters: o2 } = jr(), { printExportDeclaration: d2, printExportAllDeclaration: C2 } = so(), { printArrayItems: _2 } = Qt(), { printObject: b2 } = Xn(), { printPropertyKey: N2 } = er(), { printOptionalToken: k2, printTypeAnnotation: $, printRestSpread: M2 } = Dt();
          function q(L2, Y, V) {
            let O2 = L2.getValue(), K = Y.semi ? ";" : "", se = [];
            switch (O2.type) {
              case "DeclareClass":
                return J(L2, F(L2, Y, V));
              case "DeclareFunction":
                return J(L2, ["function ", V("id"), O2.predicate ? " " : "", V("predicate"), K]);
              case "DeclareModule":
                return J(L2, ["module ", V("id"), " ", V("body")]);
              case "DeclareModuleExports":
                return J(L2, ["module.exports", ": ", V("typeAnnotation"), K]);
              case "DeclareVariable":
                return J(L2, ["var ", V("id"), K]);
              case "DeclareOpaqueType":
                return J(L2, A2(L2, Y, V));
              case "DeclareInterface":
                return J(L2, m2(L2, Y, V));
              case "DeclareTypeAlias":
                return J(L2, B(L2, Y, V));
              case "DeclareExportDeclaration":
                return J(L2, d2(L2, Y, V));
              case "DeclareExportAllDeclaration":
                return J(L2, C2(L2, Y, V));
              case "OpaqueType":
                return A2(L2, Y, V);
              case "TypeAlias":
                return B(L2, Y, V);
              case "IntersectionTypeAnnotation":
                return I(L2, Y, V);
              case "UnionTypeAnnotation":
                return P2(L2, Y, V);
              case "FunctionTypeAnnotation":
                return R2(L2, Y, V);
              case "TupleTypeAnnotation":
                return f2(L2, Y, V);
              case "GenericTypeAnnotation":
                return [V("id"), o2(L2, Y, V, "typeParameters")];
              case "IndexedAccessType":
              case "OptionalIndexedAccessType":
                return x2(L2, Y, V);
              case "TypeAnnotation":
                return V("typeAnnotation");
              case "TypeParameter":
                return E2(L2, Y, V);
              case "TypeofTypeAnnotation":
                return ["typeof ", V("argument")];
              case "ExistsTypeAnnotation":
                return "*";
              case "EmptyTypeAnnotation":
                return "empty";
              case "MixedTypeAnnotation":
                return "mixed";
              case "ArrayTypeAnnotation":
                return [V("elementType"), "[]"];
              case "BooleanLiteralTypeAnnotation":
                return String(O2.value);
              case "EnumDeclaration":
                return ["enum ", V("id"), " ", V("body")];
              case "EnumBooleanBody":
              case "EnumNumberBody":
              case "EnumStringBody":
              case "EnumSymbolBody": {
                if (O2.type === "EnumSymbolBody" || O2.explicitType) {
                  let Q = null;
                  switch (O2.type) {
                    case "EnumBooleanBody":
                      Q = "boolean";
                      break;
                    case "EnumNumberBody":
                      Q = "number";
                      break;
                    case "EnumStringBody":
                      Q = "string";
                      break;
                    case "EnumSymbolBody":
                      Q = "symbol";
                      break;
                  }
                  se.push("of ", Q, " ");
                }
                if (O2.members.length === 0 && !O2.hasUnknownMembers)
                  se.push(l2(["{", s2(L2, Y), i2, "}"]));
                else {
                  let Q = O2.members.length > 0 ? [u2, _2(L2, Y, "members", V), O2.hasUnknownMembers || D(Y) ? "," : ""] : [];
                  se.push(l2(["{", c2([...Q, ...O2.hasUnknownMembers ? [u2, "..."] : []]), s2(L2, Y, true), u2, "}"]));
                }
                return se;
              }
              case "EnumBooleanMember":
              case "EnumNumberMember":
              case "EnumStringMember":
                return [V("id"), " = ", typeof O2.init == "object" ? V("init") : String(O2.init)];
              case "EnumDefaultedMember":
                return V("id");
              case "FunctionTypeParam": {
                let Q = O2.name ? V("name") : L2.getParentNode().this === O2 ? "this" : "";
                return [Q, k2(L2), Q ? ": " : "", V("typeAnnotation")];
              }
              case "InterfaceDeclaration":
              case "InterfaceTypeAnnotation":
                return m2(L2, Y, V);
              case "ClassImplements":
              case "InterfaceExtends":
                return [V("id"), V("typeParameters")];
              case "NullableTypeAnnotation":
                return ["?", V("typeAnnotation")];
              case "Variance": {
                let { kind: Q } = O2;
                return t2.ok(Q === "plus" || Q === "minus"), Q === "plus" ? "+" : "-";
              }
              case "ObjectTypeCallProperty":
                return O2.static && se.push("static "), se.push(V("value")), se;
              case "ObjectTypeIndexer":
                return [O2.static ? "static " : "", O2.variance ? V("variance") : "", "[", V("id"), O2.id ? ": " : "", V("key"), "]: ", V("value")];
              case "ObjectTypeProperty": {
                let Q = "";
                return O2.proto ? Q = "proto " : O2.static && (Q = "static "), [Q, g2(O2) ? O2.kind + " " : "", O2.variance ? V("variance") : "", N2(L2, Y, V), k2(L2), h3(O2) ? "" : ": ", V("value")];
              }
              case "ObjectTypeAnnotation":
                return b2(L2, Y, V);
              case "ObjectTypeInternalSlot":
                return [O2.static ? "static " : "", "[[", V("id"), "]]", k2(L2), O2.method ? "" : ": ", V("value")];
              case "ObjectTypeSpreadProperty":
                return M2(L2, Y, V);
              case "QualifiedTypeofIdentifier":
              case "QualifiedTypeIdentifier":
                return [V("qualification"), ".", V("id")];
              case "StringLiteralTypeAnnotation":
                return T2(a2(p2(O2), Y));
              case "NumberLiteralTypeAnnotation":
                t2.strictEqual(typeof O2.value, "number");
              case "BigIntLiteralTypeAnnotation":
                return O2.extra ? r2(O2.extra.raw) : r2(O2.raw);
              case "TypeCastExpression":
                return ["(", V("expression"), $(L2, Y, V), ")"];
              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation": {
                let Q = o2(L2, Y, V, "params");
                if (Y.parser === "flow") {
                  let le = v2(O2), W2 = w2(O2), X = Y.originalText.lastIndexOf("/*", le), oe = Y.originalText.indexOf("*/", W2);
                  if (X !== -1 && oe !== -1) {
                    let ae = Y.originalText.slice(X + 2, oe).trim();
                    if (ae.startsWith("::") && !ae.includes("/*") && !ae.includes("*/"))
                      return ["/*:: ", Q, " */"];
                  }
                }
                return Q;
              }
              case "InferredPredicate":
                return "%checks";
              case "DeclaredPredicate":
                return ["%checks(", V("value"), ")"];
              case "AnyTypeAnnotation":
                return "any";
              case "BooleanTypeAnnotation":
                return "boolean";
              case "BigIntTypeAnnotation":
                return "bigint";
              case "NullLiteralTypeAnnotation":
                return "null";
              case "NumberTypeAnnotation":
                return "number";
              case "SymbolTypeAnnotation":
                return "symbol";
              case "StringTypeAnnotation":
                return "string";
              case "VoidTypeAnnotation":
                return "void";
              case "ThisTypeAnnotation":
                return "this";
              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "MemberTypeAnnotation":
              case "Type":
                throw new Error("unprintable type: " + JSON.stringify(O2.type));
            }
          }
          __name(q, "q");
          function J(L2, Y) {
            let V = y2(L2);
            return V ? (t2.strictEqual(V.type, "DeclareExportDeclaration"), Y) : ["declare ", Y];
          }
          __name(J, "J");
          n2.exports = { printFlow: q };
        } }), Wm = ee({ "src/language-js/utils/is-ts-keyword-type.js"(e2, n2) {
          "use strict";
          re();
          function t2(s2) {
            let { type: a2 } = s2;
            return a2.startsWith("TS") && a2.endsWith("Keyword");
          }
          __name(t2, "t");
          n2.exports = t2;
        } }), io = ee({ "src/language-js/print/ternary.js"(e2, n2) {
          "use strict";
          re();
          var { hasNewlineInRange: t2 } = Ge(), { isJsxNode: s2, getComments: a2, isCallExpression: r2, isMemberExpression: u2, isTSTypeExpression: i2 } = Ke(), { locStart: l2, locEnd: c2 } = it(), y2 = Lt(), { builders: { line: h3, softline: g2, group: p2, indent: D, align: v2, ifBreak: w2, dedent: T2, breakParent: F } } = qe();
          function A2(f2) {
            let x2 = [f2];
            for (let m2 = 0; m2 < x2.length; m2++) {
              let E2 = x2[m2];
              for (let o2 of ["test", "consequent", "alternate"]) {
                let d2 = E2[o2];
                if (s2(d2))
                  return true;
                d2.type === "ConditionalExpression" && x2.push(d2);
              }
            }
            return false;
          }
          __name(A2, "A");
          function B(f2, x2, m2) {
            let E2 = f2.getValue(), o2 = E2.type === "ConditionalExpression", d2 = o2 ? "alternate" : "falseType", C2 = f2.getParentNode(), _2 = o2 ? m2("test") : [m2("checkType"), " ", "extends", " ", m2("extendsType")];
            return C2.type === E2.type && C2[d2] === E2 ? v2(2, _2) : _2;
          }
          __name(B, "B");
          var I = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
          function P2(f2) {
            let x2 = f2.getValue();
            if (x2.type !== "ConditionalExpression")
              return false;
            let m2, E2 = x2;
            for (let o2 = 0; !m2; o2++) {
              let d2 = f2.getParentNode(o2);
              if (r2(d2) && d2.callee === E2 || u2(d2) && d2.object === E2 || d2.type === "TSNonNullExpression" && d2.expression === E2) {
                E2 = d2;
                continue;
              }
              d2.type === "NewExpression" && d2.callee === E2 || i2(d2) && d2.expression === E2 ? (m2 = f2.getParentNode(o2 + 1), E2 = d2) : m2 = d2;
            }
            return E2 === x2 ? false : m2[I.get(m2.type)] === E2;
          }
          __name(P2, "P");
          function R2(f2, x2, m2) {
            let E2 = f2.getValue(), o2 = E2.type === "ConditionalExpression", d2 = o2 ? "consequent" : "trueType", C2 = o2 ? "alternate" : "falseType", _2 = o2 ? ["test"] : ["checkType", "extendsType"], b2 = E2[d2], N2 = E2[C2], k2 = [], $ = false, M2 = f2.getParentNode(), q = M2.type === E2.type && _2.some((ae) => M2[ae] === E2), J = M2.type === E2.type && !q, L2, Y, V = 0;
            do
              Y = L2 || E2, L2 = f2.getParentNode(V), V++;
            while (L2 && L2.type === E2.type && _2.every((ae) => L2[ae] !== Y));
            let O2 = L2 || M2, K = Y;
            if (o2 && (s2(E2[_2[0]]) || s2(b2) || s2(N2) || A2(K))) {
              $ = true, J = true;
              let ae = /* @__PURE__ */ __name((z) => [w2("("), D([g2, z]), g2, w2(")")], "ae"), Ae = /* @__PURE__ */ __name((z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined", "Ae");
              k2.push(" ? ", Ae(b2) ? m2(d2) : ae(m2(d2)), " : ", N2.type === E2.type || Ae(N2) ? m2(C2) : ae(m2(C2)));
            } else {
              let ae = [h3, "? ", b2.type === E2.type ? w2("", "(") : "", v2(2, m2(d2)), b2.type === E2.type ? w2("", ")") : "", h3, ": ", N2.type === E2.type ? m2(C2) : v2(2, m2(C2))];
              k2.push(M2.type !== E2.type || M2[C2] === E2 || q ? ae : x2.useTabs ? T2(D(ae)) : v2(Math.max(0, x2.tabWidth - 2), ae));
            }
            let Q = [..._2.map((ae) => a2(E2[ae])), a2(b2), a2(N2)].flat().some((ae) => y2(ae) && t2(x2.originalText, l2(ae), c2(ae))), le = /* @__PURE__ */ __name((ae) => M2 === O2 ? p2(ae, { shouldBreak: Q }) : Q ? [ae, F] : ae, "le"), W2 = !$ && (u2(M2) || M2.type === "NGPipeExpression" && M2.left === E2) && !M2.computed, X = P2(f2), oe = le([B(f2, x2, m2), J ? k2 : D(k2), o2 && W2 && !X ? g2 : ""]);
            return q || X ? p2([D([g2, oe]), g2]) : oe;
          }
          __name(R2, "R");
          n2.exports = { printTernary: R2 };
        } }), ao = ee({ "src/language-js/print/statement.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { hardline: t2 } } = qe(), s2 = Ot(), { getLeftSidePathName: a2, hasNakedLeftSide: r2, isJsxNode: u2, isTheOnlyJsxElementInMarkdown: i2, hasComment: l2, CommentCheckFlags: c2, isNextLineEmpty: y2 } = Ke(), { shouldPrintParamsWithoutParens: h3 } = Or();
          function g2(B, I, P2, R2) {
            let f2 = B.getValue(), x2 = [], m2 = f2.type === "ClassBody", E2 = p2(f2[R2]);
            return B.each((o2, d2, C2) => {
              let _2 = o2.getValue();
              if (_2.type === "EmptyStatement")
                return;
              let b2 = P2();
              !I.semi && !m2 && !i2(I, o2) && D(o2, I) ? l2(_2, c2.Leading) ? x2.push(P2([], { needsSemi: true })) : x2.push(";", b2) : x2.push(b2), !I.semi && m2 && F(_2) && A2(_2, C2[d2 + 1]) && x2.push(";"), _2 !== E2 && (x2.push(t2), y2(_2, I) && x2.push(t2));
            }, R2), x2;
          }
          __name(g2, "g");
          function p2(B) {
            for (let I = B.length - 1; I >= 0; I--) {
              let P2 = B[I];
              if (P2.type !== "EmptyStatement")
                return P2;
            }
          }
          __name(p2, "p");
          function D(B, I) {
            return B.getNode().type !== "ExpressionStatement" ? false : B.call((R2) => v2(R2, I), "expression");
          }
          __name(D, "D");
          function v2(B, I) {
            let P2 = B.getValue();
            switch (P2.type) {
              case "ParenthesizedExpression":
              case "TypeCastExpression":
              case "ArrayExpression":
              case "ArrayPattern":
              case "TemplateLiteral":
              case "TemplateElement":
              case "RegExpLiteral":
                return true;
              case "ArrowFunctionExpression": {
                if (!h3(B, I))
                  return true;
                break;
              }
              case "UnaryExpression": {
                let { prefix: R2, operator: f2 } = P2;
                if (R2 && (f2 === "+" || f2 === "-"))
                  return true;
                break;
              }
              case "BindExpression": {
                if (!P2.object)
                  return true;
                break;
              }
              case "Literal": {
                if (P2.regex)
                  return true;
                break;
              }
              default:
                if (u2(P2))
                  return true;
            }
            return s2(B, I) ? true : r2(P2) ? B.call((R2) => v2(R2, I), ...a2(B, P2)) : false;
          }
          __name(v2, "v");
          function w2(B, I, P2) {
            return g2(B, I, P2, "body");
          }
          __name(w2, "w");
          function T2(B, I, P2) {
            return g2(B, I, P2, "consequent");
          }
          __name(T2, "T");
          var F = /* @__PURE__ */ __name((B) => {
            let { type: I } = B;
            return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty";
          }, "F");
          function A2(B, I) {
            let P2 = B.key && B.key.name;
            if ((P2 === "static" || P2 === "get" || P2 === "set") && !B.value && !B.typeAnnotation)
              return true;
            if (!I || I.static || I.accessibility)
              return false;
            if (!I.computed) {
              let R2 = I.key && I.key.name;
              if (R2 === "in" || R2 === "instanceof")
                return true;
            }
            if (F(I) && I.variance && !I.static && !I.declare)
              return true;
            switch (I.type) {
              case "ClassProperty":
              case "PropertyDefinition":
              case "TSAbstractPropertyDefinition":
                return I.computed;
              case "MethodDefinition":
              case "TSAbstractMethodDefinition":
              case "ClassMethod":
              case "ClassPrivateMethod": {
                if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set")
                  return false;
                let f2 = I.value ? I.value.generator : I.generator;
                return !!(I.computed || f2);
              }
              case "TSIndexSignature":
                return true;
            }
            return false;
          }
          __name(A2, "A");
          n2.exports = { printBody: w2, printSwitchCaseConsequent: T2 };
        } }), oo = ee({ "src/language-js/print/block.js"(e2, n2) {
          "use strict";
          re();
          var { printDanglingComments: t2 } = et(), { isNonEmptyArray: s2 } = Ge(), { builders: { hardline: a2, indent: r2 } } = qe(), { hasComment: u2, CommentCheckFlags: i2, isNextLineEmpty: l2 } = Ke(), { printHardlineAfterHeritage: c2 } = tr(), { printBody: y2 } = ao();
          function h3(p2, D, v2) {
            let w2 = p2.getValue(), T2 = [];
            if (w2.type === "StaticBlock" && T2.push("static "), w2.type === "ClassBody" && s2(w2.body)) {
              let A2 = p2.getParentNode();
              T2.push(c2(A2));
            }
            T2.push("{");
            let F = g2(p2, D, v2);
            if (F)
              T2.push(r2([a2, F]), a2);
            else {
              let A2 = p2.getParentNode(), B = p2.getParentNode(1);
              A2.type === "ArrowFunctionExpression" || A2.type === "FunctionExpression" || A2.type === "FunctionDeclaration" || A2.type === "ObjectMethod" || A2.type === "ClassMethod" || A2.type === "ClassPrivateMethod" || A2.type === "ForStatement" || A2.type === "WhileStatement" || A2.type === "DoWhileStatement" || A2.type === "DoExpression" || A2.type === "CatchClause" && !B.finalizer || A2.type === "TSModuleDeclaration" || A2.type === "TSDeclareFunction" || w2.type === "StaticBlock" || w2.type === "ClassBody" || T2.push(a2);
            }
            return T2.push("}"), T2;
          }
          __name(h3, "h");
          function g2(p2, D, v2) {
            let w2 = p2.getValue(), T2 = s2(w2.directives), F = w2.body.some((I) => I.type !== "EmptyStatement"), A2 = u2(w2, i2.Dangling);
            if (!T2 && !F && !A2)
              return "";
            let B = [];
            if (T2 && p2.each((I, P2, R2) => {
              B.push(v2()), (P2 < R2.length - 1 || F || A2) && (B.push(a2), l2(I.getValue(), D) && B.push(a2));
            }, "directives"), F && B.push(y2(p2, D, v2)), A2 && B.push(t2(p2, D, true)), w2.type === "Program") {
              let I = p2.getParentNode();
              (!I || I.type !== "ModuleExpression") && B.push(a2);
            }
            return B;
          }
          __name(g2, "g");
          n2.exports = { printBlock: h3, printBlockBody: g2 };
        } }), Hm = ee({ "src/language-js/print/typescript.js"(e2, n2) {
          "use strict";
          re();
          var { printDanglingComments: t2 } = et(), { hasNewlineInRange: s2 } = Ge(), { builders: { join: a2, line: r2, hardline: u2, softline: i2, group: l2, indent: c2, conditionalGroup: y2, ifBreak: h3 } } = qe(), { isLiteral: g2, getTypeScriptMappedTypeModifier: p2, shouldPrintComma: D, isCallExpression: v2, isMemberExpression: w2 } = Ke(), T2 = Wm(), { locStart: F, locEnd: A2 } = it(), { printOptionalToken: B, printTypeScriptModifiers: I } = Dt(), { printTernary: P2 } = io(), { printFunctionParameters: R2, shouldGroupFunctionParameters: f2 } = kr(), { printTemplateLiteral: x2 } = jt(), { printArrayItems: m2 } = Qt(), { printObject: E2 } = Xn(), { printClassProperty: o2, printClassMethod: d2 } = tr(), { printTypeParameter: C2, printTypeParameters: _2 } = jr(), { printPropertyKey: b2 } = er(), { printFunction: N2, printMethodInternal: k2 } = Or(), { printInterface: $ } = uo(), { printBlock: M2 } = oo(), { printTypeAlias: q, printIntersectionType: J, printUnionType: L2, printFunctionType: Y, printTupleType: V, printIndexedAccessType: O2, printJSDocType: K } = Lr();
          function se(Q, le, W2) {
            let X = Q.getValue();
            if (!X.type.startsWith("TS"))
              return;
            if (T2(X))
              return X.type.slice(2, -7).toLowerCase();
            let oe = le.semi ? ";" : "", ae = [];
            switch (X.type) {
              case "TSThisType":
                return "this";
              case "TSTypeAssertion": {
                let Ae = !(X.expression.type === "ArrayExpression" || X.expression.type === "ObjectExpression"), z = l2(["<", c2([i2, W2("typeAnnotation")]), i2, ">"]), H = [h3("("), c2([i2, W2("expression")]), i2, h3(")")];
                return Ae ? y2([[z, W2("expression")], [z, l2(H, { shouldBreak: true })], [z, W2("expression")]]) : l2([z, W2("expression")]);
              }
              case "TSDeclareFunction":
                return N2(Q, W2, le);
              case "TSExportAssignment":
                return ["export = ", W2("expression"), oe];
              case "TSModuleBlock":
                return M2(Q, le, W2);
              case "TSInterfaceBody":
              case "TSTypeLiteral":
                return E2(Q, le, W2);
              case "TSTypeAliasDeclaration":
                return q(Q, le, W2);
              case "TSQualifiedName":
                return a2(".", [W2("left"), W2("right")]);
              case "TSAbstractMethodDefinition":
              case "TSDeclareMethod":
                return d2(Q, le, W2);
              case "TSAbstractPropertyDefinition":
                return o2(Q, le, W2);
              case "TSInterfaceHeritage":
              case "TSExpressionWithTypeArguments":
                return ae.push(W2("expression")), X.typeParameters && ae.push(W2("typeParameters")), ae;
              case "TSTemplateLiteralType":
                return x2(Q, W2, le);
              case "TSNamedTupleMember":
                return [W2("label"), X.optional ? "?" : "", ": ", W2("elementType")];
              case "TSRestType":
                return ["...", W2("typeAnnotation")];
              case "TSOptionalType":
                return [W2("typeAnnotation"), "?"];
              case "TSInterfaceDeclaration":
                return $(Q, le, W2);
              case "TSClassImplements":
                return [W2("expression"), W2("typeParameters")];
              case "TSTypeParameterDeclaration":
              case "TSTypeParameterInstantiation":
                return _2(Q, le, W2, "params");
              case "TSTypeParameter":
                return C2(Q, le, W2);
              case "TSSatisfiesExpression":
              case "TSAsExpression": {
                let Ae = X.type === "TSAsExpression" ? "as" : "satisfies";
                ae.push(W2("expression"), ` ${Ae} `, W2("typeAnnotation"));
                let z = Q.getParentNode();
                return v2(z) && z.callee === X || w2(z) && z.object === X ? l2([c2([i2, ...ae]), i2]) : ae;
              }
              case "TSArrayType":
                return [W2("elementType"), "[]"];
              case "TSPropertySignature":
                return X.readonly && ae.push("readonly "), ae.push(b2(Q, le, W2), B(Q)), X.typeAnnotation && ae.push(": ", W2("typeAnnotation")), X.initializer && ae.push(" = ", W2("initializer")), ae;
              case "TSParameterProperty":
                return X.accessibility && ae.push(X.accessibility + " "), X.export && ae.push("export "), X.static && ae.push("static "), X.override && ae.push("override "), X.readonly && ae.push("readonly "), ae.push(W2("parameter")), ae;
              case "TSTypeQuery":
                return ["typeof ", W2("exprName"), W2("typeParameters")];
              case "TSIndexSignature": {
                let Ae = Q.getParentNode(), z = X.parameters.length > 1 ? h3(D(le) ? "," : "") : "", H = l2([c2([i2, a2([", ", i2], Q.map(W2, "parameters"))]), z, i2]);
                return [X.export ? "export " : "", X.accessibility ? [X.accessibility, " "] : "", X.static ? "static " : "", X.readonly ? "readonly " : "", X.declare ? "declare " : "", "[", X.parameters ? H : "", X.typeAnnotation ? "]: " : "]", X.typeAnnotation ? W2("typeAnnotation") : "", Ae.type === "ClassBody" ? oe : ""];
              }
              case "TSTypePredicate":
                return [X.asserts ? "asserts " : "", W2("parameterName"), X.typeAnnotation ? [" is ", W2("typeAnnotation")] : ""];
              case "TSNonNullExpression":
                return [W2("expression"), "!"];
              case "TSImportType":
                return [X.isTypeOf ? "typeof " : "", "import(", W2(X.parameter ? "parameter" : "argument"), ")", X.qualifier ? [".", W2("qualifier")] : "", _2(Q, le, W2, "typeParameters")];
              case "TSLiteralType":
                return W2("literal");
              case "TSIndexedAccessType":
                return O2(Q, le, W2);
              case "TSConstructSignatureDeclaration":
              case "TSCallSignatureDeclaration":
              case "TSConstructorType": {
                if (X.type === "TSConstructorType" && X.abstract && ae.push("abstract "), X.type !== "TSCallSignatureDeclaration" && ae.push("new "), ae.push(l2(R2(Q, W2, le, false, true))), X.returnType || X.typeAnnotation) {
                  let Ae = X.type === "TSConstructorType";
                  ae.push(Ae ? " => " : ": ", W2("returnType"), W2("typeAnnotation"));
                }
                return ae;
              }
              case "TSTypeOperator":
                return [X.operator, " ", W2("typeAnnotation")];
              case "TSMappedType": {
                let Ae = s2(le.originalText, F(X), A2(X));
                return l2(["{", c2([le.bracketSpacing ? r2 : i2, X.readonly ? [p2(X.readonly, "readonly"), " "] : "", I(Q, le, W2), W2("typeParameter"), X.optional ? p2(X.optional, "?") : "", X.typeAnnotation ? ": " : "", W2("typeAnnotation"), h3(oe)]), t2(Q, le, true), le.bracketSpacing ? r2 : i2, "}"], { shouldBreak: Ae });
              }
              case "TSMethodSignature": {
                let Ae = X.kind && X.kind !== "method" ? `${X.kind} ` : "";
                ae.push(X.accessibility ? [X.accessibility, " "] : "", Ae, X.export ? "export " : "", X.static ? "static " : "", X.readonly ? "readonly " : "", X.abstract ? "abstract " : "", X.declare ? "declare " : "", X.computed ? "[" : "", W2("key"), X.computed ? "]" : "", B(Q));
                let z = R2(Q, W2, le, false, true), H = X.returnType ? "returnType" : "typeAnnotation", Z = X[H], ne = Z ? W2(H) : "", fe = f2(X, ne);
                return ae.push(fe ? l2(z) : z), Z && ae.push(": ", l2(ne)), l2(ae);
              }
              case "TSNamespaceExportDeclaration":
                return ae.push("export as namespace ", W2("id")), le.semi && ae.push(";"), l2(ae);
              case "TSEnumDeclaration":
                return X.declare && ae.push("declare "), X.modifiers && ae.push(I(Q, le, W2)), X.const && ae.push("const "), ae.push("enum ", W2("id"), " "), X.members.length === 0 ? ae.push(l2(["{", t2(Q, le), i2, "}"])) : ae.push(l2(["{", c2([u2, m2(Q, le, "members", W2), D(le, "es5") ? "," : ""]), t2(Q, le, true), u2, "}"])), ae;
              case "TSEnumMember":
                return X.computed ? ae.push("[", W2("id"), "]") : ae.push(W2("id")), X.initializer && ae.push(" = ", W2("initializer")), ae;
              case "TSImportEqualsDeclaration":
                return X.isExport && ae.push("export "), ae.push("import "), X.importKind && X.importKind !== "value" && ae.push(X.importKind, " "), ae.push(W2("id"), " = ", W2("moduleReference")), le.semi && ae.push(";"), l2(ae);
              case "TSExternalModuleReference":
                return ["require(", W2("expression"), ")"];
              case "TSModuleDeclaration": {
                let Ae = Q.getParentNode(), z = g2(X.id), H = Ae.type === "TSModuleDeclaration", Z = X.body && X.body.type === "TSModuleDeclaration";
                if (H)
                  ae.push(".");
                else {
                  X.declare && ae.push("declare "), ae.push(I(Q, le, W2));
                  let ne = le.originalText.slice(F(X), F(X.id));
                  X.id.type === "Identifier" && X.id.name === "global" && !/namespace|module/.test(ne) || ae.push(z || /(?:^|\s)module(?:\s|$)/.test(ne) ? "module " : "namespace ");
                }
                return ae.push(W2("id")), Z ? ae.push(W2("body")) : X.body ? ae.push(" ", l2(W2("body"))) : ae.push(oe), ae;
              }
              case "TSConditionalType":
                return P2(Q, le, W2);
              case "TSInferType":
                return ["infer", " ", W2("typeParameter")];
              case "TSIntersectionType":
                return J(Q, le, W2);
              case "TSUnionType":
                return L2(Q, le, W2);
              case "TSFunctionType":
                return Y(Q, le, W2);
              case "TSTupleType":
                return V(Q, le, W2);
              case "TSTypeReference":
                return [W2("typeName"), _2(Q, le, W2, "typeParameters")];
              case "TSTypeAnnotation":
                return W2("typeAnnotation");
              case "TSEmptyBodyFunctionExpression":
                return k2(Q, le, W2);
              case "TSJSDocAllType":
                return "*";
              case "TSJSDocUnknownType":
                return "?";
              case "TSJSDocNullableType":
                return K(Q, W2, "?");
              case "TSJSDocNonNullableType":
                return K(Q, W2, "!");
              case "TSInstantiationExpression":
                return [W2("expression"), W2("typeParameters")];
              default:
                throw new Error(`Unknown TypeScript node type: ${JSON.stringify(X.type)}.`);
            }
          }
          __name(se, "se");
          n2.exports = { printTypescript: se };
        } }), Gm = ee({ "src/language-js/print/comment.js"(e2, n2) {
          "use strict";
          re();
          var { hasNewline: t2 } = Ge(), { builders: { join: s2, hardline: a2 }, utils: { replaceTextEndOfLine: r2 } } = qe(), { isLineComment: u2 } = Ke(), { locStart: i2, locEnd: l2 } = it(), c2 = Lt();
          function y2(p2, D) {
            let v2 = p2.getValue();
            if (u2(v2))
              return D.originalText.slice(i2(v2), l2(v2)).trimEnd();
            if (c2(v2)) {
              if (h3(v2)) {
                let F = g2(v2);
                return v2.trailing && !t2(D.originalText, i2(v2), { backwards: true }) ? [a2, F] : F;
              }
              let w2 = l2(v2), T2 = D.originalText.slice(w2 - 3, w2) === "*-/";
              return ["/*", r2(v2.value), T2 ? "*-/" : "*/"];
            }
            throw new Error("Not a comment: " + JSON.stringify(v2));
          }
          __name(y2, "y");
          function h3(p2) {
            let D = `*${p2.value}*`.split(`
`);
            return D.length > 1 && D.every((v2) => v2.trim()[0] === "*");
          }
          __name(h3, "h");
          function g2(p2) {
            let D = p2.value.split(`
`);
            return ["/*", s2(a2, D.map((v2, w2) => w2 === 0 ? v2.trimEnd() : " " + (w2 < D.length - 1 ? v2.trim() : v2.trimStart()))), "*/"];
          }
          __name(g2, "g");
          n2.exports = { printComment: y2 };
        } }), Um = ee({ "src/language-js/print/literal.js"(e2, n2) {
          "use strict";
          re();
          var { printString: t2, printNumber: s2 } = Ge(), { replaceTextEndOfLine: a2 } = Xt();
          function r2(l2, c2) {
            let y2 = l2.getNode();
            switch (y2.type) {
              case "RegExpLiteral":
                return i2(y2);
              case "BigIntLiteral":
                return u2(y2.bigint || y2.extra.raw);
              case "NumericLiteral":
                return s2(y2.extra.raw);
              case "StringLiteral":
                return a2(t2(y2.extra.raw, c2));
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return String(y2.value);
              case "DecimalLiteral":
                return s2(y2.value) + "m";
              case "Literal": {
                if (y2.regex)
                  return i2(y2.regex);
                if (y2.bigint)
                  return u2(y2.raw);
                if (y2.decimal)
                  return s2(y2.decimal) + "m";
                let { value: h3 } = y2;
                return typeof h3 == "number" ? s2(y2.raw) : typeof h3 == "string" ? a2(t2(y2.raw, c2)) : String(h3);
              }
            }
          }
          __name(r2, "r");
          function u2(l2) {
            return l2.toLowerCase();
          }
          __name(u2, "u");
          function i2(l2) {
            let { pattern: c2, flags: y2 } = l2;
            return y2 = [...y2].sort().join(""), `/${c2}/${y2}`;
          }
          __name(i2, "i");
          n2.exports = { printLiteral: r2 };
        } }), Jm = ee({ "src/language-js/printer-estree.js"(e2, n2) {
          "use strict";
          re();
          var { printDanglingComments: t2 } = et(), { hasNewline: s2 } = Ge(), { builders: { join: a2, line: r2, hardline: u2, softline: i2, group: l2, indent: c2 }, utils: { replaceTextEndOfLine: y2 } } = qe(), h3 = Nm(), g2 = wm(), { insertPragma: p2 } = Qa(), D = Za(), v2 = Ot(), w2 = eo(), { hasFlowShorthandAnnotationComment: T2, hasComment: F, CommentCheckFlags: A2, isTheOnlyJsxElementInMarkdown: B, isLineComment: I, isNextLineEmpty: P2, needsHardlineAfterDanglingComment: R2, rawText: f2, hasIgnoreComment: x2, isCallExpression: m2, isMemberExpression: E2, markerForIfWithoutBlockAndSameLineComment: o2 } = Ke(), { locStart: d2, locEnd: C2 } = it(), _2 = Lt(), { printHtmlBinding: b2, isVueEventBindingExpression: N2 } = qm(), { printAngular: k2 } = Mm(), { printJsx: $, hasJsxIgnoreComment: M2 } = Rm(), { printFlow: q } = Vm(), { printTypescript: J } = Hm(), { printOptionalToken: L2, printBindExpressionCallee: Y, printTypeAnnotation: V, adjustClause: O2, printRestSpread: K, printDefiniteToken: se } = Dt(), { printImportDeclaration: Q, printExportDeclaration: le, printExportAllDeclaration: W2, printModuleSpecifier: X } = so(), { printTernary: oe } = io(), { printTemplateLiteral: ae } = jt(), { printArray: Ae } = Qt(), { printObject: z } = Xn(), { printClass: H, printClassMethod: Z, printClassProperty: ne } = tr(), { printProperty: fe } = er(), { printFunction: ge, printArrowFunction: Ce, printMethod: _e, printReturnStatement: Oe, printThrowStatement: pe } = Or(), { printCallExpression: ie } = no(), { printVariableDeclarator: ve, printAssignmentExpression: ce } = Zt(), { printBinaryishExpression: U2 } = Jn(), { printSwitchCaseConsequent: de } = ao(), { printMemberExpression: De } = ro(), { printBlock: he, printBlockBody: Be } = oo(), { printComment: Se } = Gm(), { printLiteral: ye } = Um(), { printDecorators: S2 } = zn();
          function G(Te, Pe, Fe, Ze) {
            let xe = te(Te, Pe, Fe, Ze);
            if (!xe)
              return "";
            let Je = Te.getValue(), { type: we } = Je;
            if (we === "ClassMethod" || we === "ClassPrivateMethod" || we === "ClassProperty" || we === "ClassAccessorProperty" || we === "PropertyDefinition" || we === "TSAbstractPropertyDefinition" || we === "ClassPrivateProperty" || we === "MethodDefinition" || we === "TSAbstractMethodDefinition" || we === "TSDeclareMethod")
              return xe;
            let Le = [xe], Ve = S2(Te, Pe, Fe), be = Je.type === "ClassExpression" && Ve;
            if (Ve && (Le = [...Ve, xe], !be))
              return l2(Le);
            if (!v2(Te, Pe))
              return Ze && Ze.needsSemi && Le.unshift(";"), Le.length === 1 && Le[0] === xe ? xe : Le;
            if (be && (Le = [c2([r2, ...Le])]), Le.unshift("("), Ze && Ze.needsSemi && Le.unshift(";"), T2(Je)) {
              let [Me] = Je.trailingComments;
              Le.push(" /*", Me.value.trimStart(), "*/"), Me.printed = true;
            }
            return be && Le.push(r2), Le.push(")"), Le;
          }
          __name(G, "G");
          function te(Te, Pe, Fe, Ze) {
            let xe = Te.getValue(), Je = Pe.semi ? ";" : "";
            if (!xe)
              return "";
            if (typeof xe == "string")
              return xe;
            for (let Le of [ye, b2, k2, $, q, J]) {
              let Ve = Le(Te, Pe, Fe);
              if (typeof Ve < "u")
                return Ve;
            }
            let we = [];
            switch (xe.type) {
              case "JsExpressionRoot":
                return Fe("node");
              case "JsonRoot":
                return [Fe("node"), u2];
              case "File":
                return xe.program && xe.program.interpreter && we.push(Fe(["program", "interpreter"])), we.push(Fe("program")), we;
              case "Program":
                return Be(Te, Pe, Fe);
              case "EmptyStatement":
                return "";
              case "ExpressionStatement": {
                if (xe.directive)
                  return [Ee(xe.expression, Pe), Je];
                if (Pe.parser === "__vue_event_binding" || Pe.parser === "__vue_ts_event_binding") {
                  let Ve = Te.getParentNode();
                  if (Ve.type === "Program" && Ve.body.length === 1 && Ve.body[0] === xe)
                    return [Fe("expression"), N2(xe.expression) ? ";" : ""];
                }
                let Le = t2(Te, Pe, true, (Ve) => {
                  let { marker: be } = Ve;
                  return be === o2;
                });
                return [Fe("expression"), B(Pe, Te) ? "" : Je, Le ? [" ", Le] : ""];
              }
              case "ParenthesizedExpression":
                return !F(xe.expression) && (xe.expression.type === "ObjectExpression" || xe.expression.type === "ArrayExpression") ? ["(", Fe("expression"), ")"] : l2(["(", c2([i2, Fe("expression")]), i2, ")"]);
              case "AssignmentExpression":
                return ce(Te, Pe, Fe);
              case "VariableDeclarator":
                return ve(Te, Pe, Fe);
              case "BinaryExpression":
              case "LogicalExpression":
                return U2(Te, Pe, Fe);
              case "AssignmentPattern":
                return [Fe("left"), " = ", Fe("right")];
              case "OptionalMemberExpression":
              case "MemberExpression":
                return De(Te, Pe, Fe);
              case "MetaProperty":
                return [Fe("meta"), ".", Fe("property")];
              case "BindExpression":
                return xe.object && we.push(Fe("object")), we.push(l2(c2([i2, Y(Te, Pe, Fe)]))), we;
              case "Identifier":
                return [xe.name, L2(Te), se(Te), V(Te, Pe, Fe)];
              case "V8IntrinsicIdentifier":
                return ["%", xe.name];
              case "SpreadElement":
              case "SpreadElementPattern":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "RestElement":
                return K(Te, Pe, Fe);
              case "FunctionDeclaration":
              case "FunctionExpression":
                return ge(Te, Fe, Pe, Ze);
              case "ArrowFunctionExpression":
                return Ce(Te, Pe, Fe, Ze);
              case "YieldExpression":
                return we.push("yield"), xe.delegate && we.push("*"), xe.argument && we.push(" ", Fe("argument")), we;
              case "AwaitExpression": {
                if (we.push("await"), xe.argument) {
                  we.push(" ", Fe("argument"));
                  let Le = Te.getParentNode();
                  if (m2(Le) && Le.callee === xe || E2(Le) && Le.object === xe) {
                    we = [c2([i2, ...we]), i2];
                    let Ve = Te.findAncestor((be) => be.type === "AwaitExpression" || be.type === "BlockStatement");
                    if (!Ve || Ve.type !== "AwaitExpression")
                      return l2(we);
                  }
                }
                return we;
              }
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return le(Te, Pe, Fe);
              case "ExportAllDeclaration":
                return W2(Te, Pe, Fe);
              case "ImportDeclaration":
                return Q(Te, Pe, Fe);
              case "ImportSpecifier":
              case "ExportSpecifier":
              case "ImportNamespaceSpecifier":
              case "ExportNamespaceSpecifier":
              case "ImportDefaultSpecifier":
              case "ExportDefaultSpecifier":
                return X(Te, Pe, Fe);
              case "ImportAttribute":
                return [Fe("key"), ": ", Fe("value")];
              case "Import":
                return "import";
              case "BlockStatement":
              case "StaticBlock":
              case "ClassBody":
                return he(Te, Pe, Fe);
              case "ThrowStatement":
                return pe(Te, Pe, Fe);
              case "ReturnStatement":
                return Oe(Te, Pe, Fe);
              case "NewExpression":
              case "ImportExpression":
              case "OptionalCallExpression":
              case "CallExpression":
                return ie(Te, Pe, Fe);
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                return z(Te, Pe, Fe);
              case "ObjectProperty":
              case "Property":
                return xe.method || xe.kind === "get" || xe.kind === "set" ? _e(Te, Pe, Fe) : fe(Te, Pe, Fe);
              case "ObjectMethod":
                return _e(Te, Pe, Fe);
              case "Decorator":
                return ["@", Fe("expression")];
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                return Ae(Te, Pe, Fe);
              case "SequenceExpression": {
                let Le = Te.getParentNode(0);
                if (Le.type === "ExpressionStatement" || Le.type === "ForStatement") {
                  let Ve = [];
                  return Te.each((be, ke) => {
                    ke === 0 ? Ve.push(Fe()) : Ve.push(",", c2([r2, Fe()]));
                  }, "expressions"), l2(Ve);
                }
                return l2(a2([",", r2], Te.map(Fe, "expressions")));
              }
              case "ThisExpression":
                return "this";
              case "Super":
                return "super";
              case "Directive":
                return [Fe("value"), Je];
              case "DirectiveLiteral":
                return Ee(xe, Pe);
              case "UnaryExpression":
                return we.push(xe.operator), /[a-z]$/.test(xe.operator) && we.push(" "), F(xe.argument) ? we.push(l2(["(", c2([i2, Fe("argument")]), i2, ")"])) : we.push(Fe("argument")), we;
              case "UpdateExpression":
                return we.push(Fe("argument"), xe.operator), xe.prefix && we.reverse(), we;
              case "ConditionalExpression":
                return oe(Te, Pe, Fe);
              case "VariableDeclaration": {
                let Le = Te.map(Fe, "declarations"), Ve = Te.getParentNode(), be = Ve.type === "ForStatement" || Ve.type === "ForInStatement" || Ve.type === "ForOfStatement", ke = xe.declarations.some((ue) => ue.init), Me;
                return Le.length === 1 && !F(xe.declarations[0]) ? Me = Le[0] : Le.length > 0 && (Me = c2(Le[0])), we = [xe.declare ? "declare " : "", xe.kind, Me ? [" ", Me] : "", c2(Le.slice(1).map((ue) => [",", ke && !be ? u2 : r2, ue]))], be && Ve.body !== xe || we.push(Je), l2(we);
              }
              case "WithStatement":
                return l2(["with (", Fe("object"), ")", O2(xe.body, Fe("body"))]);
              case "IfStatement": {
                let Le = O2(xe.consequent, Fe("consequent")), Ve = l2(["if (", l2([c2([i2, Fe("test")]), i2]), ")", Le]);
                if (we.push(Ve), xe.alternate) {
                  let be = F(xe.consequent, A2.Trailing | A2.Line) || R2(xe), ke = xe.consequent.type === "BlockStatement" && !be;
                  we.push(ke ? " " : u2), F(xe, A2.Dangling) && we.push(t2(Te, Pe, true), be ? u2 : " "), we.push("else", l2(O2(xe.alternate, Fe("alternate"), xe.alternate.type === "IfStatement")));
                }
                return we;
              }
              case "ForStatement": {
                let Le = O2(xe.body, Fe("body")), Ve = t2(Te, Pe, true), be = Ve ? [Ve, i2] : "";
                return !xe.init && !xe.test && !xe.update ? [be, l2(["for (;;)", Le])] : [be, l2(["for (", l2([c2([i2, Fe("init"), ";", r2, Fe("test"), ";", r2, Fe("update")]), i2]), ")", Le])];
              }
              case "WhileStatement":
                return l2(["while (", l2([c2([i2, Fe("test")]), i2]), ")", O2(xe.body, Fe("body"))]);
              case "ForInStatement":
                return l2(["for (", Fe("left"), " in ", Fe("right"), ")", O2(xe.body, Fe("body"))]);
              case "ForOfStatement":
                return l2(["for", xe.await ? " await" : "", " (", Fe("left"), " of ", Fe("right"), ")", O2(xe.body, Fe("body"))]);
              case "DoWhileStatement": {
                let Le = O2(xe.body, Fe("body"));
                return we = [l2(["do", Le])], xe.body.type === "BlockStatement" ? we.push(" ") : we.push(u2), we.push("while (", l2([c2([i2, Fe("test")]), i2]), ")", Je), we;
              }
              case "DoExpression":
                return [xe.async ? "async " : "", "do ", Fe("body")];
              case "BreakStatement":
                return we.push("break"), xe.label && we.push(" ", Fe("label")), we.push(Je), we;
              case "ContinueStatement":
                return we.push("continue"), xe.label && we.push(" ", Fe("label")), we.push(Je), we;
              case "LabeledStatement":
                return xe.body.type === "EmptyStatement" ? [Fe("label"), ":;"] : [Fe("label"), ": ", Fe("body")];
              case "TryStatement":
                return ["try ", Fe("block"), xe.handler ? [" ", Fe("handler")] : "", xe.finalizer ? [" finally ", Fe("finalizer")] : ""];
              case "CatchClause":
                if (xe.param) {
                  let Le = F(xe.param, (be) => !_2(be) || be.leading && s2(Pe.originalText, C2(be)) || be.trailing && s2(Pe.originalText, d2(be), { backwards: true })), Ve = Fe("param");
                  return ["catch ", Le ? ["(", c2([i2, Ve]), i2, ") "] : ["(", Ve, ") "], Fe("body")];
                }
                return ["catch ", Fe("body")];
              case "SwitchStatement":
                return [l2(["switch (", c2([i2, Fe("discriminant")]), i2, ")"]), " {", xe.cases.length > 0 ? c2([u2, a2(u2, Te.map((Le, Ve, be) => {
                  let ke = Le.getValue();
                  return [Fe(), Ve !== be.length - 1 && P2(ke, Pe) ? u2 : ""];
                }, "cases"))]) : "", u2, "}"];
              case "SwitchCase": {
                xe.test ? we.push("case ", Fe("test"), ":") : we.push("default:"), F(xe, A2.Dangling) && we.push(" ", t2(Te, Pe, true));
                let Le = xe.consequent.filter((Ve) => Ve.type !== "EmptyStatement");
                if (Le.length > 0) {
                  let Ve = de(Te, Pe, Fe);
                  we.push(Le.length === 1 && Le[0].type === "BlockStatement" ? [" ", Ve] : c2([u2, Ve]));
                }
                return we;
              }
              case "DebuggerStatement":
                return ["debugger", Je];
              case "ClassDeclaration":
              case "ClassExpression":
                return H(Te, Pe, Fe);
              case "ClassMethod":
              case "ClassPrivateMethod":
              case "MethodDefinition":
                return Z(Te, Pe, Fe);
              case "ClassProperty":
              case "PropertyDefinition":
              case "ClassPrivateProperty":
              case "ClassAccessorProperty":
                return ne(Te, Pe, Fe);
              case "TemplateElement":
                return y2(xe.value.raw);
              case "TemplateLiteral":
                return ae(Te, Fe, Pe);
              case "TaggedTemplateExpression":
                return [Fe("tag"), Fe("typeParameters"), Fe("quasi")];
              case "PrivateIdentifier":
                return ["#", Fe("name")];
              case "PrivateName":
                return ["#", Fe("id")];
              case "InterpreterDirective":
                return we.push("#!", xe.value, u2), P2(xe, Pe) && we.push(u2), we;
              case "TopicReference":
                return "%";
              case "ArgumentPlaceholder":
                return "?";
              case "ModuleExpression": {
                we.push("module {");
                let Le = Fe("body");
                return Le && we.push(c2([u2, Le]), u2), we.push("}"), we;
              }
              default:
                throw new Error("unknown type: " + JSON.stringify(xe.type));
            }
          }
          __name(te, "te");
          function Ee(Te, Pe) {
            let Fe = f2(Te), Ze = Fe.slice(1, -1);
            if (Ze.includes('"') || Ze.includes("'"))
              return Fe;
            let xe = Pe.singleQuote ? "'" : '"';
            return xe + Ze + xe;
          }
          __name(Ee, "Ee");
          function Re(Te) {
            return Te.type && !_2(Te) && !I(Te) && Te.type !== "EmptyStatement" && Te.type !== "TemplateElement" && Te.type !== "Import" && Te.type !== "TSEmptyBodyFunctionExpression";
          }
          __name(Re, "Re");
          n2.exports = { preprocess: w2, print: G, embed: h3, insertPragma: p2, massageAstNode: g2, hasPrettierIgnore(Te) {
            return x2(Te) || M2(Te);
          }, willPrintOwnComments: D.willPrintOwnComments, canAttachComment: Re, printComment: Se, isBlockComment: _2, handleComments: { avoidAstMutation: true, ownLine: D.handleOwnLineComment, endOfLine: D.handleEndOfLineComment, remaining: D.handleRemainingComment }, getCommentChildNodes: D.getCommentChildNodes };
        } }), zm = ee({ "src/language-js/printer-estree-json.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { hardline: t2, indent: s2, join: a2 } } = qe(), r2 = eo();
          function u2(c2, y2, h3) {
            let g2 = c2.getValue();
            switch (g2.type) {
              case "JsonRoot":
                return [h3("node"), t2];
              case "ArrayExpression": {
                if (g2.elements.length === 0)
                  return "[]";
                let p2 = c2.map(() => c2.getValue() === null ? "null" : h3(), "elements");
                return ["[", s2([t2, a2([",", t2], p2)]), t2, "]"];
              }
              case "ObjectExpression":
                return g2.properties.length === 0 ? "{}" : ["{", s2([t2, a2([",", t2], c2.map(h3, "properties"))]), t2, "}"];
              case "ObjectProperty":
                return [h3("key"), ": ", h3("value")];
              case "UnaryExpression":
                return [g2.operator === "+" ? "" : g2.operator, h3("argument")];
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return g2.value ? "true" : "false";
              case "StringLiteral":
              case "NumericLiteral":
                return JSON.stringify(g2.value);
              case "Identifier": {
                let p2 = c2.getParentNode();
                return p2 && p2.type === "ObjectProperty" && p2.key === g2 ? JSON.stringify(g2.name) : g2.name;
              }
              case "TemplateLiteral":
                return h3(["quasis", 0]);
              case "TemplateElement":
                return JSON.stringify(g2.value.cooked);
              default:
                throw new Error("unknown type: " + JSON.stringify(g2.type));
            }
          }
          __name(u2, "u");
          var i2 = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
          function l2(c2, y2) {
            let { type: h3 } = c2;
            if (h3 === "ObjectProperty" && c2.key.type === "Identifier") {
              y2.key = { type: "StringLiteral", value: c2.key.name };
              return;
            }
            if (h3 === "UnaryExpression" && c2.operator === "+")
              return y2.argument;
            if (h3 === "ArrayExpression") {
              for (let [g2, p2] of c2.elements.entries())
                p2 === null && y2.elements.splice(g2, 0, { type: "NullLiteral" });
              return;
            }
            if (h3 === "TemplateLiteral")
              return { type: "StringLiteral", value: c2.quasis[0].value.cooked };
          }
          __name(l2, "l");
          l2.ignoredProperties = i2, n2.exports = { preprocess: r2, print: u2, massageAstNode: l2 };
        } }), qt = ee({ "src/common/common-options.js"(e2, n2) {
          "use strict";
          re();
          var t2 = "Common";
          n2.exports = { bracketSpacing: { since: "0.0.0", category: t2, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t2, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t2, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t2, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t2, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
        } }), Xm = ee({ "src/language-js/options.js"(e2, n2) {
          "use strict";
          re();
          var t2 = qt(), s2 = "JavaScript";
          n2.exports = { arrowParens: { since: "1.9.0", category: s2, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t2.bracketSameLine, bracketSpacing: t2.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s2, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s2, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t2.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s2, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s2, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s2, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t2.singleAttributePerLine };
        } }), Km = ee({ "src/language-js/parse/parsers.js"() {
          re();
        } }), bn = ee({ "node_modules/linguist-languages/data/JavaScript.json"(e2, n2) {
          n2.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
        } }), Ym = ee({ "node_modules/linguist-languages/data/TypeScript.json"(e2, n2) {
          n2.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
        } }), Qm = ee({ "node_modules/linguist-languages/data/TSX.json"(e2, n2) {
          n2.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
        } }), la = ee({ "node_modules/linguist-languages/data/JSON.json"(e2, n2) {
          n2.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
        } }), Zm = ee({ "node_modules/linguist-languages/data/JSON with Comments.json"(e2, n2) {
          n2.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
        } }), ed = ee({ "node_modules/linguist-languages/data/JSON5.json"(e2, n2) {
          n2.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
        } }), td = ee({ "src/language-js/index.js"(e2, n2) {
          "use strict";
          re();
          var t2 = wt(), s2 = Jm(), a2 = zm(), r2 = Xm(), u2 = Km(), i2 = [t2(bn(), (c2) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...c2.interpreters, "zx"], extensions: [...c2.extensions.filter((y2) => y2 !== ".jsx"), ".wxs"] })), t2(bn(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t2(bn(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t2(Ym(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t2(Qm(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t2(la(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t2(la(), (c2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: c2.extensions.filter((y2) => y2 !== ".jsonl") })), t2(Zm(), (c2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...c2.filenames, ".eslintrc", ".swcrc"] })), t2(ed(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l2 = { estree: s2, "estree-json": a2 };
          n2.exports = { languages: i2, options: r2, printers: l2, parsers: u2 };
        } }), rd = ee({ "src/language-css/clean.js"(e2, n2) {
          "use strict";
          re();
          var { isFrontMatterNode: t2 } = Ge(), s2 = lt(), a2 = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
          function r2(i2, l2, c2) {
            if (t2(i2) && i2.lang === "yaml" && delete l2.value, i2.type === "css-comment" && c2.type === "css-root" && c2.nodes.length > 0 && ((c2.nodes[0] === i2 || t2(c2.nodes[0]) && c2.nodes[1] === i2) && (delete l2.text, /^\*\s*@(?:format|prettier)\s*$/.test(i2.text)) || c2.type === "css-root" && s2(c2.nodes) === i2))
              return null;
            if (i2.type === "value-root" && delete l2.text, (i2.type === "media-query" || i2.type === "media-query-list" || i2.type === "media-feature-expression") && delete l2.value, i2.type === "css-rule" && delete l2.params, i2.type === "selector-combinator" && (l2.value = l2.value.replace(/\s+/g, " ")), i2.type === "media-feature" && (l2.value = l2.value.replace(/ /g, "")), (i2.type === "value-word" && (i2.isColor && i2.isHex || ["initial", "inherit", "unset", "revert"].includes(l2.value.replace().toLowerCase())) || i2.type === "media-feature" || i2.type === "selector-root-invalid" || i2.type === "selector-pseudo") && (l2.value = l2.value.toLowerCase()), i2.type === "css-decl" && (l2.prop = l2.prop.toLowerCase()), (i2.type === "css-atrule" || i2.type === "css-import") && (l2.name = l2.name.toLowerCase()), i2.type === "value-number" && (l2.unit = l2.unit.toLowerCase()), (i2.type === "media-feature" || i2.type === "media-keyword" || i2.type === "media-type" || i2.type === "media-unknown" || i2.type === "media-url" || i2.type === "media-value" || i2.type === "selector-attribute" || i2.type === "selector-string" || i2.type === "selector-class" || i2.type === "selector-combinator" || i2.type === "value-string") && l2.value && (l2.value = u2(l2.value)), i2.type === "selector-attribute" && (l2.attribute = l2.attribute.trim(), l2.namespace && typeof l2.namespace == "string" && (l2.namespace = l2.namespace.trim(), l2.namespace.length === 0 && (l2.namespace = true)), l2.value && (l2.value = l2.value.trim().replace(/^["']|["']$/g, ""), delete l2.quoted)), (i2.type === "media-value" || i2.type === "media-type" || i2.type === "value-number" || i2.type === "selector-root-invalid" || i2.type === "selector-class" || i2.type === "selector-combinator" || i2.type === "selector-tag") && l2.value && (l2.value = l2.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (y2, h3, g2) => {
              let p2 = Number(h3);
              return Number.isNaN(p2) ? y2 : p2 + g2.toLowerCase();
            })), i2.type === "selector-tag") {
              let y2 = i2.value.toLowerCase();
              ["from", "to"].includes(y2) && (l2.value = y2);
            }
            if (i2.type === "css-atrule" && i2.name.toLowerCase() === "supports" && delete l2.value, i2.type === "selector-unknown" && delete l2.value, i2.type === "value-comma_group") {
              let y2 = i2.groups.findIndex((h3) => h3.type === "value-number" && h3.unit === "...");
              y2 !== -1 && (l2.groups[y2].unit = "", l2.groups.splice(y2 + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
            }
          }
          __name(r2, "r");
          r2.ignoredProperties = a2;
          function u2(i2) {
            return i2.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
          }
          __name(u2, "u");
          n2.exports = r2;
        } }), Kn = ee({ "src/utils/front-matter/print.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { hardline: t2, markAsRoot: s2 } } = qe();
          function a2(r2, u2) {
            if (r2.lang === "yaml") {
              let i2 = r2.value.trim(), l2 = i2 ? u2(i2, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
              return s2([r2.startDelimiter, t2, l2, l2 ? t2 : "", r2.endDelimiter]);
            }
          }
          __name(a2, "a");
          n2.exports = a2;
        } }), nd = ee({ "src/language-css/embed.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { hardline: t2 } } = qe(), s2 = Kn();
          function a2(r2, u2, i2) {
            let l2 = r2.getValue();
            if (l2.type === "front-matter") {
              let c2 = s2(l2, i2);
              return c2 ? [c2, t2] : "";
            }
          }
          __name(a2, "a");
          n2.exports = a2;
        } }), lo = ee({ "src/utils/front-matter/parse.js"(e2, n2) {
          "use strict";
          re();
          var t2 = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function s2(a2) {
            let r2 = a2.match(t2);
            if (!r2)
              return { content: a2 };
            let { startDelimiter: u2, language: i2, value: l2 = "", endDelimiter: c2 } = r2.groups, y2 = i2.trim() || "yaml";
            if (u2 === "+++" && (y2 = "toml"), y2 !== "yaml" && u2 !== c2)
              return { content: a2 };
            let [h3] = r2;
            return { frontMatter: { type: "front-matter", lang: y2, value: l2, startDelimiter: u2, endDelimiter: c2, raw: h3.replace(/\n$/, "") }, content: h3.replace(/[^\n]/g, " ") + a2.slice(h3.length) };
          }
          __name(s2, "s");
          n2.exports = s2;
        } }), ud = ee({ "src/language-css/pragma.js"(e2, n2) {
          "use strict";
          re();
          var t2 = Qa(), s2 = lo();
          function a2(u2) {
            return t2.hasPragma(s2(u2).content);
          }
          __name(a2, "a");
          function r2(u2) {
            let { frontMatter: i2, content: l2 } = s2(u2);
            return (i2 ? i2.raw + `

` : "") + t2.insertPragma(l2);
          }
          __name(r2, "r");
          n2.exports = { hasPragma: a2, insertPragma: r2 };
        } }), sd = ee({ "src/language-css/utils/index.js"(e2, n2) {
          "use strict";
          re();
          var t2 = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
          function s2(z, H) {
            let Z = Array.isArray(H) ? H : [H], ne = -1, fe;
            for (; fe = z.getParentNode(++ne); )
              if (Z.includes(fe.type))
                return ne;
            return -1;
          }
          __name(s2, "s");
          function a2(z, H) {
            let Z = s2(z, H);
            return Z === -1 ? null : z.getParentNode(Z);
          }
          __name(a2, "a");
          function r2(z) {
            var H;
            let Z = a2(z, "css-decl");
            return Z == null || (H = Z.prop) === null || H === void 0 ? void 0 : H.toLowerCase();
          }
          __name(r2, "r");
          var u2 = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
          function i2(z) {
            return u2.has(z.toLowerCase());
          }
          __name(i2, "i");
          function l2(z, H) {
            let Z = a2(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(H.toLowerCase());
          }
          __name(l2, "l");
          function c2(z) {
            return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
          }
          __name(c2, "c");
          function y2(z, H) {
            var Z;
            let ne = a2(z, "value-func");
            return (ne == null || (Z = ne.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === H;
          }
          __name(y2, "y");
          function h3(z) {
            var H;
            let Z = a2(z, "css-rule"), ne = Z == null || (H = Z.raws) === null || H === void 0 ? void 0 : H.selector;
            return ne && (ne.startsWith(":import") || ne.startsWith(":export"));
          }
          __name(h3, "h");
          function g2(z, H) {
            let Z = Array.isArray(H) ? H : [H], ne = a2(z, "css-atrule");
            return ne && Z.includes(ne.name.toLowerCase());
          }
          __name(g2, "g");
          function p2(z) {
            let H = z.getValue(), Z = a2(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) === "import" && H.groups[0].value === "url" && H.groups.length === 2;
          }
          __name(p2, "p");
          function D(z) {
            return z.type === "value-func" && z.value.toLowerCase() === "url";
          }
          __name(D, "D");
          function v2(z, H) {
            var Z;
            let ne = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
            return ne && ne.indexOf(H) === ne.length - 1;
          }
          __name(v2, "v");
          function w2(z) {
            let { selector: H } = z;
            return H ? typeof H == "string" && /^@.+:.*$/.test(H) || H.value && /^@.+:.*$/.test(H.value) : false;
          }
          __name(w2, "w");
          function T2(z) {
            return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
          }
          __name(T2, "T");
          function F(z) {
            return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
          }
          __name(F, "F");
          function A2(z) {
            return z.type === "value-word" && z.value === "in";
          }
          __name(A2, "A");
          function B(z) {
            return z.type === "value-operator" && z.value === "*";
          }
          __name(B, "B");
          function I(z) {
            return z.type === "value-operator" && z.value === "/";
          }
          __name(I, "I");
          function P2(z) {
            return z.type === "value-operator" && z.value === "+";
          }
          __name(P2, "P");
          function R2(z) {
            return z.type === "value-operator" && z.value === "-";
          }
          __name(R2, "R");
          function f2(z) {
            return z.type === "value-operator" && z.value === "%";
          }
          __name(f2, "f");
          function x2(z) {
            return B(z) || I(z) || P2(z) || R2(z) || f2(z);
          }
          __name(x2, "x");
          function m2(z) {
            return z.type === "value-word" && ["==", "!="].includes(z.value);
          }
          __name(m2, "m");
          function E2(z) {
            return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
          }
          __name(E2, "E");
          function o2(z) {
            return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
          }
          __name(o2, "o");
          function d2(z) {
            var H;
            return ((H = z.raws) === null || H === void 0 ? void 0 : H.params) && /^\(\s*\)$/.test(z.raws.params);
          }
          __name(d2, "d");
          function C2(z) {
            return z.name.startsWith("prettier-placeholder");
          }
          __name(C2, "C");
          function _2(z) {
            return z.prop.startsWith("@prettier-placeholder");
          }
          __name(_2, "_");
          function b2(z, H) {
            return z.value === "$$" && z.type === "value-func" && (H == null ? void 0 : H.type) === "value-word" && !H.raws.before;
          }
          __name(b2, "b");
          function N2(z) {
            var H, Z;
            return ((H = z.value) === null || H === void 0 ? void 0 : H.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
          }
          __name(N2, "N");
          function k2(z) {
            var H, Z, ne;
            return ((H = z.value) === null || H === void 0 || (Z = H.group) === null || Z === void 0 || (ne = Z.group) === null || ne === void 0 ? void 0 : ne.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
          }
          __name(k2, "k");
          function $(z) {
            var H;
            return ((H = z.raws) === null || H === void 0 ? void 0 : H.before) === "";
          }
          __name($, "$");
          function M2(z) {
            var H, Z;
            return z.type === "value-comma_group" && ((H = z.groups) === null || H === void 0 || (Z = H[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
          }
          __name(M2, "M");
          function q(z) {
            var H;
            return z.type === "value-paren_group" && ((H = z.groups) === null || H === void 0 ? void 0 : H[0]) && M2(z.groups[0]);
          }
          __name(q, "q");
          function J(z) {
            var H;
            let Z = z.getValue();
            if (Z.groups.length === 0)
              return false;
            let ne = z.getParentNode(1);
            if (!q(Z) && !(ne && q(ne)))
              return false;
            let fe = a2(z, "css-decl");
            return !!(fe != null && (H = fe.prop) !== null && H !== void 0 && H.startsWith("$") || q(ne) || ne.type === "value-func");
          }
          __name(J, "J");
          function L2(z) {
            return z.type === "value-comment" && z.inline;
          }
          __name(L2, "L");
          function Y(z) {
            return z.type === "value-word" && z.value === "#";
          }
          __name(Y, "Y");
          function V(z) {
            return z.type === "value-word" && z.value === "{";
          }
          __name(V, "V");
          function O2(z) {
            return z.type === "value-word" && z.value === "}";
          }
          __name(O2, "O");
          function K(z) {
            return ["value-word", "value-atword"].includes(z.type);
          }
          __name(K, "K");
          function se(z) {
            return (z == null ? void 0 : z.type) === "value-colon";
          }
          __name(se, "se");
          function Q(z, H) {
            if (!M2(H))
              return false;
            let { groups: Z } = H, ne = Z.indexOf(z);
            return ne === -1 ? false : se(Z[ne + 1]);
          }
          __name(Q, "Q");
          function le(z) {
            return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
          }
          __name(le, "le");
          function W2(z) {
            return z.type !== "value-func" ? false : t2.has(z.value.toLowerCase());
          }
          __name(W2, "W");
          function X(z) {
            return /\/\//.test(z.split(/[\n\r]/).pop());
          }
          __name(X, "X");
          function oe(z) {
            return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
          }
          __name(oe, "oe");
          function ae(z, H) {
            var Z, ne;
            if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((ne = z.close) === null || ne === void 0 ? void 0 : ne.value) !== ")" || z.groups.some((fe) => fe.type !== "value-comma_group"))
              return false;
            if (H.type === "value-comma_group") {
              let fe = H.groups.indexOf(z) - 1, ge = H.groups[fe];
              if ((ge == null ? void 0 : ge.type) === "value-word" && ge.value === "with")
                return true;
            }
            return false;
          }
          __name(ae, "ae");
          function Ae(z) {
            var H, Z;
            return z.type === "value-paren_group" && ((H = z.open) === null || H === void 0 ? void 0 : H.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
          }
          __name(Ae, "Ae");
          n2.exports = { getAncestorCounter: s2, getAncestorNode: a2, getPropOfDeclNode: r2, maybeToLowerCase: c2, insideValueFunctionNode: y2, insideICSSRuleNode: h3, insideAtRuleNode: g2, insideURLFunctionInImportAtRuleNode: p2, isKeyframeAtRuleKeywords: l2, isWideKeywords: i2, isLastNode: v2, isSCSSControlDirectiveNode: o2, isDetachedRulesetDeclarationNode: w2, isRelationalOperatorNode: E2, isEqualityOperatorNode: m2, isMultiplicationNode: B, isDivisionNode: I, isAdditionNode: P2, isSubtractionNode: R2, isModuloNode: f2, isMathOperatorNode: x2, isEachKeywordNode: A2, isForKeywordNode: T2, isURLFunctionNode: D, isIfElseKeywordNode: F, hasComposesNode: N2, hasParensAroundNode: k2, hasEmptyRawBefore: $, isDetachedRulesetCallNode: d2, isTemplatePlaceholderNode: C2, isTemplatePropNode: _2, isPostcssSimpleVarNode: b2, isKeyValuePairNode: M2, isKeyValuePairInParenGroupNode: q, isKeyInValuePairNode: Q, isSCSSMapItemNode: J, isInlineValueCommentNode: L2, isHashNode: Y, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: O2, isWordNode: K, isColonNode: se, isMediaAndSupportsKeywords: le, isColorAdjusterFuncNode: W2, lastLineHasInlineComment: X, isAtWordPlaceholderNode: oe, isConfigurationNode: ae, isParenGroupNode: Ae };
        } }), id = ee({ "src/utils/line-column-to-index.js"(e2, n2) {
          "use strict";
          re(), n2.exports = function(t2, s2) {
            let a2 = 0;
            for (let r2 = 0; r2 < t2.line - 1; ++r2)
              a2 = s2.indexOf(`
`, a2) + 1;
            return a2 + t2.column;
          };
        } }), ad = ee({ "src/language-css/loc.js"(e2, n2) {
          "use strict";
          re();
          var { skipEverythingButNewLine: t2 } = _r(), s2 = lt(), a2 = id();
          function r2(p2, D) {
            return typeof p2.sourceIndex == "number" ? p2.sourceIndex : p2.source ? a2(p2.source.start, D) - 1 : null;
          }
          __name(r2, "r");
          function u2(p2, D) {
            if (p2.type === "css-comment" && p2.inline)
              return t2(D, p2.source.startOffset);
            let v2 = p2.nodes && s2(p2.nodes);
            return v2 && p2.source && !p2.source.end && (p2 = v2), p2.source && p2.source.end ? a2(p2.source.end, D) : null;
          }
          __name(u2, "u");
          function i2(p2, D) {
            p2.source && (p2.source.startOffset = r2(p2, D), p2.source.endOffset = u2(p2, D));
            for (let v2 in p2) {
              let w2 = p2[v2];
              v2 === "source" || !w2 || typeof w2 != "object" || (w2.type === "value-root" || w2.type === "value-unknown" ? l2(w2, c2(p2), w2.text || w2.value) : i2(w2, D));
            }
          }
          __name(i2, "i");
          function l2(p2, D, v2) {
            p2.source && (p2.source.startOffset = r2(p2, v2) + D, p2.source.endOffset = u2(p2, v2) + D);
            for (let w2 in p2) {
              let T2 = p2[w2];
              w2 === "source" || !T2 || typeof T2 != "object" || l2(T2, D, v2);
            }
          }
          __name(l2, "l");
          function c2(p2) {
            let D = p2.source.startOffset;
            return typeof p2.prop == "string" && (D += p2.prop.length), p2.type === "css-atrule" && typeof p2.name == "string" && (D += 1 + p2.name.length + p2.raws.afterName.match(/^\s*:?\s*/)[0].length), p2.type !== "css-atrule" && p2.raws && typeof p2.raws.between == "string" && (D += p2.raws.between.length), D;
          }
          __name(c2, "c");
          function y2(p2) {
            let D = "initial", v2 = "initial", w2, T2 = false, F = [];
            for (let A2 = 0; A2 < p2.length; A2++) {
              let B = p2[A2];
              switch (D) {
                case "initial":
                  if (B === "'") {
                    D = "single-quotes";
                    continue;
                  }
                  if (B === '"') {
                    D = "double-quotes";
                    continue;
                  }
                  if ((B === "u" || B === "U") && p2.slice(A2, A2 + 4).toLowerCase() === "url(") {
                    D = "url", A2 += 3;
                    continue;
                  }
                  if (B === "*" && p2[A2 - 1] === "/") {
                    D = "comment-block";
                    continue;
                  }
                  if (B === "/" && p2[A2 - 1] === "/") {
                    D = "comment-inline", w2 = A2 - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (B === "'" && p2[A2 - 1] !== "\\" && (D = v2, v2 = "initial"), B === `
` || B === "\r")
                    return p2;
                  continue;
                case "double-quotes":
                  if (B === '"' && p2[A2 - 1] !== "\\" && (D = v2, v2 = "initial"), B === `
` || B === "\r")
                    return p2;
                  continue;
                case "url":
                  if (B === ")" && (D = "initial"), B === `
` || B === "\r")
                    return p2;
                  if (B === "'") {
                    D = "single-quotes", v2 = "url";
                    continue;
                  }
                  if (B === '"') {
                    D = "double-quotes", v2 = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  B === "/" && p2[A2 - 1] === "*" && (D = "initial");
                  continue;
                case "comment-inline":
                  (B === '"' || B === "'" || B === "*") && (T2 = true), (B === `
` || B === "\r") && (T2 && F.push([w2, A2]), D = "initial", T2 = false);
                  continue;
              }
            }
            for (let [A2, B] of F)
              p2 = p2.slice(0, A2) + p2.slice(A2, B).replace(/["'*]/g, " ") + p2.slice(B);
            return p2;
          }
          __name(y2, "y");
          function h3(p2) {
            return p2.source.startOffset;
          }
          __name(h3, "h");
          function g2(p2) {
            return p2.source.endOffset;
          }
          __name(g2, "g");
          n2.exports = { locStart: h3, locEnd: g2, calculateLoc: i2, replaceQuotesInInlineComments: y2 };
        } }), od = ee({ "src/language-css/utils/is-less-parser.js"(e2, n2) {
          "use strict";
          re();
          function t2(s2) {
            return s2.parser === "css" || s2.parser === "less";
          }
          __name(t2, "t");
          n2.exports = t2;
        } }), ld = ee({ "src/language-css/utils/is-scss.js"(e2, n2) {
          "use strict";
          re();
          function t2(s2, a2) {
            return s2 === "less" || s2 === "scss" ? s2 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a2);
          }
          __name(t2, "t");
          n2.exports = t2;
        } }), cd = ee({ "src/language-css/utils/css-units.evaluate.js"(e2, n2) {
          n2.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
        } }), pd = ee({ "src/language-css/utils/print-unit.js"(e2, n2) {
          "use strict";
          re();
          var t2 = cd();
          function s2(a2) {
            let r2 = a2.toLowerCase();
            return Object.prototype.hasOwnProperty.call(t2, r2) ? t2[r2] : a2;
          }
          __name(s2, "s");
          n2.exports = s2;
        } }), fd = ee({ "src/language-css/printer-postcss.js"(e2, n2) {
          "use strict";
          re();
          var t2 = lt(), { printNumber: s2, printString: a2, hasNewline: r2, isFrontMatterNode: u2, isNextLineEmpty: i2, isNonEmptyArray: l2 } = Ge(), { builders: { join: c2, line: y2, hardline: h3, softline: g2, group: p2, fill: D, indent: v2, dedent: w2, ifBreak: T2, breakParent: F }, utils: { removeLines: A2, getDocParts: B } } = qe(), I = rd(), P2 = nd(), { insertPragma: R2 } = ud(), { getAncestorNode: f2, getPropOfDeclNode: x2, maybeToLowerCase: m2, insideValueFunctionNode: E2, insideICSSRuleNode: o2, insideAtRuleNode: d2, insideURLFunctionInImportAtRuleNode: C2, isKeyframeAtRuleKeywords: _2, isWideKeywords: b2, isLastNode: N2, isSCSSControlDirectiveNode: k2, isDetachedRulesetDeclarationNode: $, isRelationalOperatorNode: M2, isEqualityOperatorNode: q, isMultiplicationNode: J, isDivisionNode: L2, isAdditionNode: Y, isSubtractionNode: V, isMathOperatorNode: O2, isEachKeywordNode: K, isForKeywordNode: se, isURLFunctionNode: Q, isIfElseKeywordNode: le, hasComposesNode: W2, hasParensAroundNode: X, hasEmptyRawBefore: oe, isKeyValuePairNode: ae, isKeyInValuePairNode: Ae, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: H, isTemplatePropNode: Z, isPostcssSimpleVarNode: ne, isSCSSMapItemNode: fe, isInlineValueCommentNode: ge, isHashNode: Ce, isLeftCurlyBraceNode: _e, isRightCurlyBraceNode: Oe, isWordNode: pe, isColonNode: ie, isMediaAndSupportsKeywords: ve, isColorAdjusterFuncNode: ce, lastLineHasInlineComment: U2, isAtWordPlaceholderNode: de, isConfigurationNode: De, isParenGroupNode: he } = sd(), { locStart: Be, locEnd: Se } = ad(), ye = od(), S2 = ld(), G = pd();
          function te(be) {
            return be.trailingComma === "es5" || be.trailingComma === "all";
          }
          __name(te, "te");
          function Ee(be, ke, Me) {
            let ue = be.getValue();
            if (!ue)
              return "";
            if (typeof ue == "string")
              return ue;
            switch (ue.type) {
              case "front-matter":
                return [ue.raw, h3];
              case "css-root": {
                let He = Re(be, ke, Me), Ue = ue.raws.after.trim();
                return [He, Ue ? ` ${Ue}` : "", B(He).length > 0 ? h3 : ""];
              }
              case "css-comment": {
                let He = ue.inline || ue.raws.inline, Ue = ke.originalText.slice(Be(ue), Se(ue));
                return He ? Ue.trimEnd() : Ue;
              }
              case "css-rule":
                return [Me("selector"), ue.important ? " !important" : "", ue.nodes ? [ue.selector && ue.selector.type === "selector-unknown" && U2(ue.selector.value) ? y2 : " ", "{", ue.nodes.length > 0 ? v2([h3, Re(be, ke, Me)]) : "", h3, "}", $(ue) ? ";" : ""] : ";"];
              case "css-decl": {
                let He = be.getParentNode(), { between: Ue } = ue.raws, Xe = Ue.trim(), at = Xe === ":", nt = W2(ue) ? A2(Me("value")) : Me("value");
                return !at && U2(Xe) && (nt = v2([h3, w2(nt)])), [ue.raws.before.replace(/[\s;]/g, ""), o2(be) ? ue.prop : m2(ue.prop), Xe.startsWith("//") ? " " : "", Xe, ue.extend ? "" : " ", ye(ke) && ue.extend && ue.selector ? ["extend(", Me("selector"), ")"] : "", nt, ue.raws.important ? ue.raws.important.replace(/\s*!\s*important/i, " !important") : ue.important ? " !important" : "", ue.raws.scssDefault ? ue.raws.scssDefault.replace(/\s*!default/i, " !default") : ue.scssDefault ? " !default" : "", ue.raws.scssGlobal ? ue.raws.scssGlobal.replace(/\s*!global/i, " !global") : ue.scssGlobal ? " !global" : "", ue.nodes ? [" {", v2([g2, Re(be, ke, Me)]), g2, "}"] : Z(ue) && !He.raws.semicolon && ke.originalText[Se(ue) - 1] !== ";" ? "" : ke.__isHTMLStyleAttribute && N2(be, ue) ? T2(";") : ";"];
              }
              case "css-atrule": {
                let He = be.getParentNode(), Ue = H(ue) && !He.raws.semicolon && ke.originalText[Se(ue) - 1] !== ";";
                if (ye(ke)) {
                  if (ue.mixin)
                    return [Me("selector"), ue.important ? " !important" : "", Ue ? "" : ";"];
                  if (ue.function)
                    return [ue.name, Me("params"), Ue ? "" : ";"];
                  if (ue.variable)
                    return ["@", ue.name, ": ", ue.value ? Me("value") : "", ue.raws.between.trim() ? ue.raws.between.trim() + " " : "", ue.nodes ? ["{", v2([ue.nodes.length > 0 ? g2 : "", Re(be, ke, Me)]), g2, "}"] : "", Ue ? "" : ";"];
                }
                return ["@", z(ue) || ue.name.endsWith(":") ? ue.name : m2(ue.name), ue.params ? [z(ue) ? "" : H(ue) ? ue.raws.afterName === "" ? "" : ue.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ue.raws.afterName) ? [h3, h3] : /^\s*\n/.test(ue.raws.afterName) ? h3 : " " : " ", Me("params")] : "", ue.selector ? v2([" ", Me("selector")]) : "", ue.value ? p2([" ", Me("value"), k2(ue) ? X(ue) ? " " : y2 : ""]) : ue.name === "else" ? " " : "", ue.nodes ? [k2(ue) ? "" : ue.selector && !ue.selector.nodes && typeof ue.selector.value == "string" && U2(ue.selector.value) || !ue.selector && typeof ue.params == "string" && U2(ue.params) ? y2 : " ", "{", v2([ue.nodes.length > 0 ? g2 : "", Re(be, ke, Me)]), g2, "}"] : Ue ? "" : ";"];
              }
              case "media-query-list": {
                let He = [];
                return be.each((Ue) => {
                  let Xe = Ue.getValue();
                  Xe.type === "media-query" && Xe.value === "" || He.push(Me());
                }, "nodes"), p2(v2(c2(y2, He)));
              }
              case "media-query":
                return [c2(" ", be.map(Me, "nodes")), N2(be, ue) ? "" : ","];
              case "media-type":
                return Le(Je(ue.value, ke));
              case "media-feature-expression":
                return ue.nodes ? ["(", ...be.map(Me, "nodes"), ")"] : ue.value;
              case "media-feature":
                return m2(Je(ue.value.replace(/ +/g, " "), ke));
              case "media-colon":
                return [ue.value, " "];
              case "media-value":
                return Le(Je(ue.value, ke));
              case "media-keyword":
                return Je(ue.value, ke);
              case "media-url":
                return Je(ue.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), ke);
              case "media-unknown":
                return ue.value;
              case "selector-root":
                return p2([d2(be, "custom-selector") ? [f2(be, "css-atrule").customSelector, y2] : "", c2([",", d2(be, ["extend", "custom-selector", "nest"]) ? y2 : h3], be.map(Me, "nodes"))]);
              case "selector-selector":
                return p2(v2(be.map(Me, "nodes")));
              case "selector-comment":
                return ue.value;
              case "selector-string":
                return Je(ue.value, ke);
              case "selector-tag": {
                let He = be.getParentNode(), Ue = He && He.nodes.indexOf(ue), Xe = Ue && He.nodes[Ue - 1];
                return [ue.namespace ? [ue.namespace === true ? "" : ue.namespace.trim(), "|"] : "", Xe.type === "selector-nesting" ? ue.value : Le(_2(be, ue.value) ? ue.value.toLowerCase() : ue.value)];
              }
              case "selector-id":
                return ["#", ue.value];
              case "selector-class":
                return [".", Le(Je(ue.value, ke))];
              case "selector-attribute": {
                var st;
                return ["[", ue.namespace ? [ue.namespace === true ? "" : ue.namespace.trim(), "|"] : "", ue.attribute.trim(), (st = ue.operator) !== null && st !== void 0 ? st : "", ue.value ? we(Je(ue.value.trim(), ke), ke) : "", ue.insensitive ? " i" : "", "]"];
              }
              case "selector-combinator": {
                if (ue.value === "+" || ue.value === ">" || ue.value === "~" || ue.value === ">>>") {
                  let Xe = be.getParentNode();
                  return [Xe.type === "selector-selector" && Xe.nodes[0] === ue ? "" : y2, ue.value, N2(be, ue) ? "" : " "];
                }
                let He = ue.value.trim().startsWith("(") ? y2 : "", Ue = Le(Je(ue.value.trim(), ke)) || y2;
                return [He, Ue];
              }
              case "selector-universal":
                return [ue.namespace ? [ue.namespace === true ? "" : ue.namespace.trim(), "|"] : "", ue.value];
              case "selector-pseudo":
                return [m2(ue.value), l2(ue.nodes) ? p2(["(", v2([g2, c2([",", y2], be.map(Me, "nodes"))]), g2, ")"]) : ""];
              case "selector-nesting":
                return ue.value;
              case "selector-unknown": {
                let He = f2(be, "css-rule");
                if (He && He.isSCSSNesterProperty)
                  return Le(Je(m2(ue.value), ke));
                let Ue = be.getParentNode();
                if (Ue.raws && Ue.raws.selector) {
                  let at = Be(Ue), nt = at + Ue.raws.selector.length;
                  return ke.originalText.slice(at, nt).trim();
                }
                let Xe = be.getParentNode(1);
                if (Ue.type === "value-paren_group" && Xe && Xe.type === "value-func" && Xe.value === "selector") {
                  let at = Se(Ue.open) + 1, nt = Be(Ue.close), j2 = ke.originalText.slice(at, nt).trim();
                  return U2(j2) ? [F, j2] : j2;
                }
                return ue.value;
              }
              case "value-value":
              case "value-root":
                return Me("group");
              case "value-comment":
                return ke.originalText.slice(Be(ue), Se(ue));
              case "value-comma_group": {
                let He = be.getParentNode(), Ue = be.getParentNode(1), Xe = x2(be), at = Xe && He.type === "value-value" && (Xe === "grid" || Xe.startsWith("grid-template")), nt = f2(be, "css-atrule"), j2 = nt && k2(nt), me = ue.groups.some((ot) => ge(ot)), Ie = be.map(Me, "groups"), je = [], Ye = E2(be, "url"), ut = false, ze = false;
                for (let ot = 0; ot < ue.groups.length; ++ot) {
                  var rt;
                  je.push(Ie[ot]);
                  let tt = ue.groups[ot - 1], $e = ue.groups[ot], We = ue.groups[ot + 1], nr = ue.groups[ot + 2];
                  if (Ye) {
                    (We && Y(We) || Y($e)) && je.push(" ");
                    continue;
                  }
                  if (d2(be, "forward") && $e.type === "value-word" && $e.value && tt !== void 0 && tt.type === "value-word" && tt.value === "as" && We.type === "value-operator" && We.value === "*" || !We || $e.type === "value-word" && $e.value.endsWith("-") && de(We))
                    continue;
                  let go = $e.type === "value-string" && $e.value.startsWith("#{"), yo = ut && We.type === "value-string" && We.value.endsWith("}");
                  if (go || yo) {
                    ut = !ut;
                    continue;
                  }
                  if (ut || ie($e) || ie(We) || $e.type === "value-atword" && $e.value === "" || $e.value === "~" || $e.value && $e.value.includes("\\") && We && We.type !== "value-comment" || tt && tt.value && tt.value.indexOf("\\") === tt.value.length - 1 && $e.type === "value-operator" && $e.value === "/" || $e.value === "\\" || ne($e, We) || Ce($e) || _e($e) || Oe(We) || _e(We) && oe(We) || Oe($e) && oe(We) || $e.value === "--" && Ce(We))
                    continue;
                  let Zn = O2($e), eu = O2(We);
                  if ((Zn && Ce(We) || eu && Oe($e)) && oe(We) || !tt && L2($e) || E2(be, "calc") && (Y($e) || Y(We) || V($e) || V(We)) && oe(We))
                    continue;
                  let ho = (Y($e) || V($e)) && ot === 0 && (We.type === "value-number" || We.isHex) && Ue && ce(Ue) && !oe(We), tu = nr && nr.type === "value-func" || nr && pe(nr) || $e.type === "value-func" || pe($e), ru = We.type === "value-func" || pe(We) || tt && tt.type === "value-func" || tt && pe(tt);
                  if (!(!(J(We) || J($e)) && !E2(be, "calc") && !ho && (L2(We) && !tu || L2($e) && !ru || Y(We) && !tu || Y($e) && !ru || V(We) || V($e)) && (oe(We) || Zn && (!tt || tt && O2(tt))))) {
                    if (ge($e)) {
                      if (He.type === "value-paren_group") {
                        je.push(w2(h3));
                        continue;
                      }
                      je.push(h3);
                      continue;
                    }
                    if (j2 && (q(We) || M2(We) || le(We) || K($e) || se($e))) {
                      je.push(" ");
                      continue;
                    }
                    if (nt && nt.name.toLowerCase() === "namespace") {
                      je.push(" ");
                      continue;
                    }
                    if (at) {
                      $e.source && We.source && $e.source.start.line !== We.source.start.line ? (je.push(h3), ze = true) : je.push(" ");
                      continue;
                    }
                    if (eu) {
                      je.push(" ");
                      continue;
                    }
                    if (!(We && We.value === "...") && !(de($e) && de(We) && Se($e) === Be(We))) {
                      if (de($e) && he(We) && Se($e) === Be(We.open)) {
                        je.push(g2);
                        continue;
                      }
                      if ($e.value === "with" && he(We)) {
                        je.push(" ");
                        continue;
                      }
                      (rt = $e.value) !== null && rt !== void 0 && rt.endsWith("#") && We.value === "{" && he(We.group) || je.push(y2);
                    }
                  }
                }
                return me && je.push(F), ze && je.unshift(h3), j2 ? p2(v2(je)) : C2(be) ? p2(D(je)) : p2(v2(D(je)));
              }
              case "value-paren_group": {
                let He = be.getParentNode();
                if (He && Q(He) && (ue.groups.length === 1 || ue.groups.length > 0 && ue.groups[0].type === "value-comma_group" && ue.groups[0].groups.length > 0 && ue.groups[0].groups[0].type === "value-word" && ue.groups[0].groups[0].value.startsWith("data:")))
                  return [ue.open ? Me("open") : "", c2(",", be.map(Me, "groups")), ue.close ? Me("close") : ""];
                if (!ue.open) {
                  let Ye = be.map(Me, "groups"), ut = [];
                  for (let ze = 0; ze < Ye.length; ze++)
                    ze !== 0 && ut.push([",", y2]), ut.push(Ye[ze]);
                  return p2(v2(D(ut)));
                }
                let Ue = fe(be), Xe = t2(ue.groups), at = Xe && Xe.type === "value-comment", nt = Ae(ue, He), j2 = De(ue, He), me = j2 || Ue && !nt, Ie = j2 || nt, je = p2([ue.open ? Me("open") : "", v2([g2, c2([y2], be.map((Ye, ut) => {
                  let ze = Ye.getValue(), ot = ut === ue.groups.length - 1, tt = [Me(), ot ? "" : ","];
                  if (ae(ze) && ze.type === "value-comma_group" && ze.groups && ze.groups[0].type !== "value-paren_group" && ze.groups[2] && ze.groups[2].type === "value-paren_group") {
                    let $e = B(tt[0].contents.contents);
                    return $e[1] = p2($e[1]), p2(w2(tt));
                  }
                  if (!ot && ze.type === "value-comma_group" && l2(ze.groups)) {
                    let $e = t2(ze.groups);
                    $e.source && i2(ke.originalText, $e, Se) && tt.push(h3);
                  }
                  return tt;
                }, "groups"))]), T2(!at && S2(ke.parser, ke.originalText) && Ue && te(ke) ? "," : ""), g2, ue.close ? Me("close") : ""], { shouldBreak: me });
                return Ie ? w2(je) : je;
              }
              case "value-func":
                return [ue.value, d2(be, "supports") && ve(ue) ? " " : "", Me("group")];
              case "value-paren":
                return ue.value;
              case "value-number":
                return [Ve(ue.value), G(ue.unit)];
              case "value-operator":
                return ue.value;
              case "value-word":
                return ue.isColor && ue.isHex || b2(ue.value) ? ue.value.toLowerCase() : ue.value;
              case "value-colon": {
                let He = be.getParentNode(), Ue = He && He.groups.indexOf(ue), Xe = Ue && He.groups[Ue - 1];
                return [ue.value, Xe && typeof Xe.value == "string" && t2(Xe.value) === "\\" || E2(be, "url") ? "" : y2];
              }
              case "value-comma":
                return [ue.value, " "];
              case "value-string":
                return a2(ue.raws.quote + ue.value + ue.raws.quote, ke);
              case "value-atword":
                return ["@", ue.value];
              case "value-unicode-range":
                return ue.value;
              case "value-unknown":
                return ue.value;
              default:
                throw new Error(`Unknown postcss type ${JSON.stringify(ue.type)}`);
            }
          }
          __name(Ee, "Ee");
          function Re(be, ke, Me) {
            let ue = [];
            return be.each((st, rt, He) => {
              let Ue = He[rt - 1];
              if (Ue && Ue.type === "css-comment" && Ue.text.trim() === "prettier-ignore") {
                let Xe = st.getValue();
                ue.push(ke.originalText.slice(Be(Xe), Se(Xe)));
              } else
                ue.push(Me());
              rt !== He.length - 1 && (He[rt + 1].type === "css-comment" && !r2(ke.originalText, Be(He[rt + 1]), { backwards: true }) && !u2(He[rt]) || He[rt + 1].type === "css-atrule" && He[rt + 1].name === "else" && He[rt].type !== "css-comment" ? ue.push(" ") : (ue.push(ke.__isHTMLStyleAttribute ? y2 : h3), i2(ke.originalText, st.getValue(), Se) && !u2(He[rt]) && ue.push(h3)));
            }, "nodes"), ue;
          }
          __name(Re, "Re");
          var Te = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, Pe = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, Fe = /[A-Za-z]+/g, Ze = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, xe = new RegExp(Te.source + `|(${Ze.source})?(${Pe.source})(${Fe.source})?`, "g");
          function Je(be, ke) {
            return be.replace(Te, (Me) => a2(Me, ke));
          }
          __name(Je, "Je");
          function we(be, ke) {
            let Me = ke.singleQuote ? "'" : '"';
            return be.includes('"') || be.includes("'") ? be : Me + be + Me;
          }
          __name(we, "we");
          function Le(be) {
            return be.replace(xe, (ke, Me, ue, st, rt) => !ue && st ? Ve(st) + m2(rt || "") : ke);
          }
          __name(Le, "Le");
          function Ve(be) {
            return s2(be).replace(/\.0(?=$|e)/, "");
          }
          __name(Ve, "Ve");
          n2.exports = { print: Ee, embed: P2, insertPragma: R2, massageAstNode: I };
        } }), Dd = ee({ "src/language-css/options.js"(e2, n2) {
          "use strict";
          re();
          var t2 = qt();
          n2.exports = { singleQuote: t2.singleQuote };
        } }), md = ee({ "src/language-css/parsers.js"() {
          re();
        } }), dd = ee({ "node_modules/linguist-languages/data/CSS.json"(e2, n2) {
          n2.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
        } }), gd = ee({ "node_modules/linguist-languages/data/PostCSS.json"(e2, n2) {
          n2.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
        } }), yd = ee({ "node_modules/linguist-languages/data/Less.json"(e2, n2) {
          n2.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
        } }), hd = ee({ "node_modules/linguist-languages/data/SCSS.json"(e2, n2) {
          n2.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
        } }), vd = ee({ "src/language-css/index.js"(e2, n2) {
          "use strict";
          re();
          var t2 = wt(), s2 = fd(), a2 = Dd(), r2 = md(), u2 = [t2(dd(), (l2) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l2.extensions, ".wxss"] })), t2(gd(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t2(yd(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t2(hd(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i2 = { postcss: s2 };
          n2.exports = { languages: u2, options: a2, printers: i2, parsers: r2 };
        } }), Cd = ee({ "src/language-handlebars/loc.js"(e2, n2) {
          "use strict";
          re();
          function t2(a2) {
            return a2.loc.start.offset;
          }
          __name(t2, "t");
          function s2(a2) {
            return a2.loc.end.offset;
          }
          __name(s2, "s");
          n2.exports = { locStart: t2, locEnd: s2 };
        } }), Ed = ee({ "src/language-handlebars/clean.js"(e2, n2) {
          "use strict";
          re();
          function t2(s2, a2) {
            if (s2.type === "TextNode") {
              let r2 = s2.chars.trim();
              if (!r2)
                return null;
              a2.chars = r2.replace(/[\t\n\f\r ]+/g, " ");
            }
            s2.type === "AttrNode" && s2.name.toLowerCase() === "class" && delete a2.value;
          }
          __name(t2, "t");
          t2.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), n2.exports = t2;
        } }), Fd = ee({ "vendors/html-void-elements.json"(e2, n2) {
          n2.exports = { htmlVoidElements: ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"] };
        } }), Ad = ee({ "src/language-handlebars/utils.js"(e2, n2) {
          "use strict";
          re();
          var { htmlVoidElements: t2 } = Fd(), s2 = lt();
          function a2(A2) {
            let B = A2.getValue(), I = A2.getParentNode(0);
            return !!(h3(A2, ["ElementNode"]) && s2(I.children) === B || h3(A2, ["Block"]) && s2(I.body) === B);
          }
          __name(a2, "a");
          function r2(A2) {
            return A2.toUpperCase() === A2;
          }
          __name(r2, "r");
          function u2(A2) {
            return y2(A2, ["ElementNode"]) && typeof A2.tag == "string" && !A2.tag.startsWith(":") && (r2(A2.tag[0]) || A2.tag.includes("."));
          }
          __name(u2, "u");
          var i2 = new Set(t2);
          function l2(A2) {
            return i2.has(A2.tag) || u2(A2) && A2.children.every((B) => c2(B));
          }
          __name(l2, "l");
          function c2(A2) {
            return y2(A2, ["TextNode"]) && !/\S/.test(A2.chars);
          }
          __name(c2, "c");
          function y2(A2, B) {
            return A2 && B.includes(A2.type);
          }
          __name(y2, "y");
          function h3(A2, B) {
            let I = A2.getParentNode(0);
            return y2(I, B);
          }
          __name(h3, "h");
          function g2(A2, B) {
            let I = v2(A2);
            return y2(I, B);
          }
          __name(g2, "g");
          function p2(A2, B) {
            let I = w2(A2);
            return y2(I, B);
          }
          __name(p2, "p");
          function D(A2, B) {
            var I, P2, R2, f2;
            let x2 = A2.getValue(), m2 = (I = A2.getParentNode(0)) !== null && I !== void 0 ? I : {}, E2 = (P2 = (R2 = (f2 = m2.children) !== null && f2 !== void 0 ? f2 : m2.body) !== null && R2 !== void 0 ? R2 : m2.parts) !== null && P2 !== void 0 ? P2 : [], o2 = E2.indexOf(x2);
            return o2 !== -1 && E2[o2 + B];
          }
          __name(D, "D");
          function v2(A2) {
            let B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return D(A2, -B);
          }
          __name(v2, "v");
          function w2(A2) {
            return D(A2, 1);
          }
          __name(w2, "w");
          function T2(A2) {
            return y2(A2, ["MustacheCommentStatement"]) && typeof A2.value == "string" && A2.value.trim() === "prettier-ignore";
          }
          __name(T2, "T");
          function F(A2) {
            let B = A2.getValue(), I = v2(A2, 2);
            return T2(B) || T2(I);
          }
          __name(F, "F");
          n2.exports = { getNextNode: w2, getPreviousNode: v2, hasPrettierIgnore: F, isLastNodeOfSiblings: a2, isNextNodeOfSomeType: p2, isNodeOfSomeType: y2, isParentOfSomeType: h3, isPreviousNodeOfSomeType: g2, isVoid: l2, isWhitespaceNode: c2 };
        } }), Sd = ee({ "src/language-handlebars/printer-glimmer.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { dedent: t2, fill: s2, group: a2, hardline: r2, ifBreak: u2, indent: i2, join: l2, line: c2, softline: y2 }, utils: { getDocParts: h3, replaceTextEndOfLine: g2 } } = qe(), { getPreferredQuote: p2, isNonEmptyArray: D } = Ge(), { locStart: v2, locEnd: w2 } = Cd(), T2 = Ed(), { getNextNode: F, getPreviousNode: A2, hasPrettierIgnore: B, isLastNodeOfSiblings: I, isNextNodeOfSomeType: P2, isNodeOfSomeType: R2, isParentOfSomeType: f2, isPreviousNodeOfSomeType: x2, isVoid: m2, isWhitespaceNode: E2 } = Ad(), o2 = 2;
          function d2(U2, de, De) {
            let he = U2.getValue();
            if (!he)
              return "";
            if (B(U2))
              return de.originalText.slice(v2(he), w2(he));
            let Be = de.singleQuote ? "'" : '"';
            switch (he.type) {
              case "Block":
              case "Program":
              case "Template":
                return a2(U2.map(De, "body"));
              case "ElementNode": {
                let Se = a2(_2(U2, De)), ye = de.htmlWhitespaceSensitivity === "ignore" && P2(U2, ["ElementNode"]) ? y2 : "";
                if (m2(he))
                  return [Se, ye];
                let S2 = ["</", he.tag, ">"];
                return he.children.length === 0 ? [Se, i2(S2), ye] : de.htmlWhitespaceSensitivity === "ignore" ? [Se, i2(b2(U2, de, De)), r2, i2(S2), ye] : [Se, i2(a2(b2(U2, de, De))), i2(S2), ye];
              }
              case "BlockStatement": {
                let Se = U2.getParentNode(1);
                return Se && Se.inverse && Se.inverse.body.length === 1 && Se.inverse.body[0] === he && Se.inverse.body[0].path.parts[0] === Se.path.parts[0] ? [se(U2, De, Se.inverse.body[0].path.parts[0]), oe(U2, De, de), ae(U2, De, de)] : [O2(U2, De), a2([oe(U2, De, de), ae(U2, De, de), Q(U2, De, de)])];
              }
              case "ElementModifierStatement":
                return a2(["{{", pe(U2, De), "}}"]);
              case "MustacheStatement":
                return a2([k2(he), pe(U2, De), $(he)]);
              case "SubExpression":
                return a2(["(", Oe(U2, De), y2, ")"]);
              case "AttrNode": {
                let Se = he.value.type === "TextNode";
                if (Se && he.value.chars === "" && v2(he.value) === w2(he.value))
                  return he.name;
                let S2 = Se ? p2(he.value.chars, Be).quote : he.value.type === "ConcatStatement" ? p2(he.value.parts.filter((te) => te.type === "TextNode").map((te) => te.chars).join(""), Be).quote : "", G = De("value");
                return [he.name, "=", S2, he.name === "class" && S2 ? a2(i2(G)) : G, S2];
              }
              case "ConcatStatement":
                return U2.map(De, "parts");
              case "Hash":
                return l2(c2, U2.map(De, "pairs"));
              case "HashPair":
                return [he.key, "=", De("value")];
              case "TextNode": {
                let Se = he.chars.replace(/{{/g, "\\{{"), ye = H(U2);
                if (ye) {
                  if (ye === "class") {
                    let xe = Se.trim().split(/\s+/).join(" "), Je = false, we = false;
                    return f2(U2, ["ConcatStatement"]) && (x2(U2, ["MustacheStatement"]) && /^\s/.test(Se) && (Je = true), P2(U2, ["MustacheStatement"]) && /\s$/.test(Se) && xe !== "" && (we = true)), [Je ? c2 : "", xe, we ? c2 : ""];
                  }
                  return g2(Se);
                }
                let G = /^[\t\n\f\r ]*$/.test(Se), te = !A2(U2), Ee = !F(U2);
                if (de.htmlWhitespaceSensitivity !== "ignore") {
                  let xe = /^[\t\n\f\r ]*/, Je = /[\t\n\f\r ]*$/, we = Ee && f2(U2, ["Template"]), Le = te && f2(U2, ["Template"]);
                  if (G) {
                    if (Le || we)
                      return "";
                    let ue = [c2], st = Z(Se);
                    return st && (ue = ge(st)), I(U2) && (ue = ue.map((rt) => t2(rt))), ue;
                  }
                  let [Ve] = Se.match(xe), [be] = Se.match(Je), ke = [];
                  if (Ve) {
                    ke = [c2];
                    let ue = Z(Ve);
                    ue && (ke = ge(ue)), Se = Se.replace(xe, "");
                  }
                  let Me = [];
                  if (be) {
                    if (!we) {
                      Me = [c2];
                      let ue = Z(be);
                      ue && (Me = ge(ue)), I(U2) && (Me = Me.map((st) => t2(st)));
                    }
                    Se = Se.replace(Je, "");
                  }
                  return [...ke, s2(Ae(Se)), ...Me];
                }
                let Re = Z(Se), Te = ne(Se), Pe = fe(Se);
                if ((te || Ee) && G && f2(U2, ["Block", "ElementNode", "Template"]))
                  return "";
                G && Re ? (Te = Math.min(Re, o2), Pe = 0) : (P2(U2, ["BlockStatement", "ElementNode"]) && (Pe = Math.max(Pe, 1)), x2(U2, ["BlockStatement", "ElementNode"]) && (Te = Math.max(Te, 1)));
                let Fe = "", Ze = "";
                return Pe === 0 && P2(U2, ["MustacheStatement"]) && (Ze = " "), Te === 0 && x2(U2, ["MustacheStatement"]) && (Fe = " "), te && (Te = 0, Fe = ""), Ee && (Pe = 0, Ze = ""), Se = Se.replace(/^[\t\n\f\r ]+/g, Fe).replace(/[\t\n\f\r ]+$/, Ze), [...ge(Te), s2(Ae(Se)), ...ge(Pe)];
              }
              case "MustacheCommentStatement": {
                let Se = v2(he), ye = w2(he), S2 = de.originalText.charAt(Se + 2) === "~", G = de.originalText.charAt(ye - 3) === "~", te = he.value.includes("}}") ? "--" : "";
                return ["{{", S2 ? "~" : "", "!", te, he.value, te, G ? "~" : "", "}}"];
              }
              case "PathExpression":
                return he.original;
              case "BooleanLiteral":
                return String(he.value);
              case "CommentStatement":
                return ["<!--", he.value, "-->"];
              case "StringLiteral": {
                if (_e(U2)) {
                  let Se = de.singleQuote ? '"' : "'";
                  return Ce(he.value, Se);
                }
                return Ce(he.value, Be);
              }
              case "NumberLiteral":
                return String(he.value);
              case "UndefinedLiteral":
                return "undefined";
              case "NullLiteral":
                return "null";
              default:
                throw new Error("unknown glimmer type: " + JSON.stringify(he.type));
            }
          }
          __name(d2, "d");
          function C2(U2, de) {
            return v2(U2) - v2(de);
          }
          __name(C2, "C");
          function _2(U2, de) {
            let De = U2.getValue(), he = ["attributes", "modifiers", "comments"].filter((Se) => D(De[Se])), Be = he.flatMap((Se) => De[Se]).sort(C2);
            for (let Se of he)
              U2.each((ye) => {
                let S2 = Be.indexOf(ye.getValue());
                Be.splice(S2, 1, [c2, de()]);
              }, Se);
            return D(De.blockParams) && Be.push(c2, ce(De)), ["<", De.tag, i2(Be), N2(De)];
          }
          __name(_2, "_");
          function b2(U2, de, De) {
            let Be = U2.getValue().children.every((Se) => E2(Se));
            return de.htmlWhitespaceSensitivity === "ignore" && Be ? "" : U2.map((Se, ye) => {
              let S2 = De();
              return ye === 0 && de.htmlWhitespaceSensitivity === "ignore" ? [y2, S2] : S2;
            }, "children");
          }
          __name(b2, "b");
          function N2(U2) {
            return m2(U2) ? u2([y2, "/>"], [" />", y2]) : u2([y2, ">"], ">");
          }
          __name(N2, "N");
          function k2(U2) {
            let de = U2.escaped === false ? "{{{" : "{{", De = U2.strip && U2.strip.open ? "~" : "";
            return [de, De];
          }
          __name(k2, "k");
          function $(U2) {
            let de = U2.escaped === false ? "}}}" : "}}";
            return [U2.strip && U2.strip.close ? "~" : "", de];
          }
          __name($, "$");
          function M2(U2) {
            let de = k2(U2), De = U2.openStrip.open ? "~" : "";
            return [de, De, "#"];
          }
          __name(M2, "M");
          function q(U2) {
            let de = $(U2);
            return [U2.openStrip.close ? "~" : "", de];
          }
          __name(q, "q");
          function J(U2) {
            let de = k2(U2), De = U2.closeStrip.open ? "~" : "";
            return [de, De, "/"];
          }
          __name(J, "J");
          function L2(U2) {
            let de = $(U2);
            return [U2.closeStrip.close ? "~" : "", de];
          }
          __name(L2, "L");
          function Y(U2) {
            let de = k2(U2), De = U2.inverseStrip.open ? "~" : "";
            return [de, De];
          }
          __name(Y, "Y");
          function V(U2) {
            let de = $(U2);
            return [U2.inverseStrip.close ? "~" : "", de];
          }
          __name(V, "V");
          function O2(U2, de) {
            let De = U2.getValue(), he = M2(De), Be = q(De), Se = [ie(U2, de)], ye = ve(U2, de);
            if (ye && Se.push(c2, ye), D(De.program.blockParams)) {
              let S2 = ce(De.program);
              Se.push(c2, S2);
            }
            return a2([he, i2(Se), y2, Be]);
          }
          __name(O2, "O");
          function K(U2, de) {
            return [de.htmlWhitespaceSensitivity === "ignore" ? r2 : "", Y(U2), "else", V(U2)];
          }
          __name(K, "K");
          function se(U2, de, De) {
            let he = U2.getParentNode(1);
            return [Y(he), "else ", De, " ", ve(U2, de), V(he)];
          }
          __name(se, "se");
          function Q(U2, de, De) {
            let he = U2.getValue();
            return De.htmlWhitespaceSensitivity === "ignore" ? [le(he) ? y2 : r2, J(he), de("path"), L2(he)] : [J(he), de("path"), L2(he)];
          }
          __name(Q, "Q");
          function le(U2) {
            return R2(U2, ["BlockStatement"]) && U2.program.body.every((de) => E2(de));
          }
          __name(le, "le");
          function W2(U2) {
            return X(U2) && U2.inverse.body.length === 1 && R2(U2.inverse.body[0], ["BlockStatement"]) && U2.inverse.body[0].path.parts[0] === U2.path.parts[0];
          }
          __name(W2, "W");
          function X(U2) {
            return R2(U2, ["BlockStatement"]) && U2.inverse;
          }
          __name(X, "X");
          function oe(U2, de, De) {
            let he = U2.getValue();
            if (le(he))
              return "";
            let Be = de("program");
            return De.htmlWhitespaceSensitivity === "ignore" ? i2([r2, Be]) : i2(Be);
          }
          __name(oe, "oe");
          function ae(U2, de, De) {
            let he = U2.getValue(), Be = de("inverse"), Se = De.htmlWhitespaceSensitivity === "ignore" ? [r2, Be] : Be;
            return W2(he) ? Se : X(he) ? [K(he, De), i2(Se)] : "";
          }
          __name(ae, "ae");
          function Ae(U2) {
            return h3(l2(c2, z(U2)));
          }
          __name(Ae, "Ae");
          function z(U2) {
            return U2.split(/[\t\n\f\r ]+/);
          }
          __name(z, "z");
          function H(U2) {
            for (let de = 0; de < 2; de++) {
              let De = U2.getParentNode(de);
              if (De && De.type === "AttrNode")
                return De.name.toLowerCase();
            }
          }
          __name(H, "H");
          function Z(U2) {
            return U2 = typeof U2 == "string" ? U2 : "", U2.split(`
`).length - 1;
          }
          __name(Z, "Z");
          function ne(U2) {
            U2 = typeof U2 == "string" ? U2 : "";
            let de = (U2.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
            return Z(de);
          }
          __name(ne, "ne");
          function fe(U2) {
            U2 = typeof U2 == "string" ? U2 : "";
            let de = (U2.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
            return Z(de);
          }
          __name(fe, "fe");
          function ge() {
            let U2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return Array.from({ length: Math.min(U2, o2) }).fill(r2);
          }
          __name(ge, "ge");
          function Ce(U2, de) {
            let { quote: De, regex: he } = p2(U2, de);
            return [De, U2.replace(he, `\\${De}`), De];
          }
          __name(Ce, "Ce");
          function _e(U2) {
            let de = 0, De = U2.getParentNode(de);
            for (; De && R2(De, ["SubExpression"]); )
              de++, De = U2.getParentNode(de);
            return !!(De && R2(U2.getParentNode(de + 1), ["ConcatStatement"]) && R2(U2.getParentNode(de + 2), ["AttrNode"]));
          }
          __name(_e, "_e");
          function Oe(U2, de) {
            let De = ie(U2, de), he = ve(U2, de);
            return he ? i2([De, c2, a2(he)]) : De;
          }
          __name(Oe, "Oe");
          function pe(U2, de) {
            let De = ie(U2, de), he = ve(U2, de);
            return he ? [i2([De, c2, he]), y2] : De;
          }
          __name(pe, "pe");
          function ie(U2, de) {
            return de("path");
          }
          __name(ie, "ie");
          function ve(U2, de) {
            let De = U2.getValue(), he = [];
            if (De.params.length > 0) {
              let Be = U2.map(de, "params");
              he.push(...Be);
            }
            if (De.hash && De.hash.pairs.length > 0) {
              let Be = de("hash");
              he.push(Be);
            }
            return he.length === 0 ? "" : l2(c2, he);
          }
          __name(ve, "ve");
          function ce(U2) {
            return ["as |", U2.blockParams.join(" "), "|"];
          }
          __name(ce, "ce");
          n2.exports = { print: d2, massageAstNode: T2 };
        } }), xd = ee({ "src/language-handlebars/parsers.js"() {
          re();
        } }), bd = ee({ "node_modules/linguist-languages/data/Handlebars.json"(e2, n2) {
          n2.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
        } }), Td = ee({ "src/language-handlebars/index.js"(e2, n2) {
          "use strict";
          re();
          var t2 = wt(), s2 = Sd(), a2 = xd(), r2 = [t2(bd(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u2 = { glimmer: s2 };
          n2.exports = { languages: r2, printers: u2, parsers: a2 };
        } }), Bd = ee({ "src/language-graphql/pragma.js"(e2, n2) {
          "use strict";
          re();
          function t2(a2) {
            return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a2);
          }
          __name(t2, "t");
          function s2(a2) {
            return `# @format

` + a2;
          }
          __name(s2, "s");
          n2.exports = { hasPragma: t2, insertPragma: s2 };
        } }), Nd = ee({ "src/language-graphql/loc.js"(e2, n2) {
          "use strict";
          re();
          function t2(a2) {
            return typeof a2.start == "number" ? a2.start : a2.loc && a2.loc.start;
          }
          __name(t2, "t");
          function s2(a2) {
            return typeof a2.end == "number" ? a2.end : a2.loc && a2.loc.end;
          }
          __name(s2, "s");
          n2.exports = { locStart: t2, locEnd: s2 };
        } }), wd = ee({ "src/language-graphql/printer-graphql.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { join: t2, hardline: s2, line: a2, softline: r2, group: u2, indent: i2, ifBreak: l2 } } = qe(), { isNextLineEmpty: c2, isNonEmptyArray: y2 } = Ge(), { insertPragma: h3 } = Bd(), { locStart: g2, locEnd: p2 } = Nd();
          function D(P2, R2, f2) {
            let x2 = P2.getValue();
            if (!x2)
              return "";
            if (typeof x2 == "string")
              return x2;
            switch (x2.kind) {
              case "Document": {
                let m2 = [];
                return P2.each((E2, o2, d2) => {
                  m2.push(f2()), o2 !== d2.length - 1 && (m2.push(s2), c2(R2.originalText, E2.getValue(), p2) && m2.push(s2));
                }, "definitions"), [...m2, s2];
              }
              case "OperationDefinition": {
                let m2 = R2.originalText[g2(x2)] !== "{", E2 = Boolean(x2.name);
                return [m2 ? x2.operation : "", m2 && E2 ? [" ", f2("name")] : "", m2 && !E2 && y2(x2.variableDefinitions) ? " " : "", y2(x2.variableDefinitions) ? u2(["(", i2([r2, t2([l2("", ", "), r2], P2.map(f2, "variableDefinitions"))]), r2, ")"]) : "", v2(P2, f2, x2), x2.selectionSet ? !m2 && !E2 ? "" : " " : "", f2("selectionSet")];
              }
              case "FragmentDefinition":
                return ["fragment ", f2("name"), y2(x2.variableDefinitions) ? u2(["(", i2([r2, t2([l2("", ", "), r2], P2.map(f2, "variableDefinitions"))]), r2, ")"]) : "", " on ", f2("typeCondition"), v2(P2, f2, x2), " ", f2("selectionSet")];
              case "SelectionSet":
                return ["{", i2([s2, t2(s2, w2(P2, R2, f2, "selections"))]), s2, "}"];
              case "Field":
                return u2([x2.alias ? [f2("alias"), ": "] : "", f2("name"), x2.arguments.length > 0 ? u2(["(", i2([r2, t2([l2("", ", "), r2], w2(P2, R2, f2, "arguments"))]), r2, ")"]) : "", v2(P2, f2, x2), x2.selectionSet ? " " : "", f2("selectionSet")]);
              case "Name":
                return x2.value;
              case "StringValue": {
                if (x2.block) {
                  let m2 = x2.value.replace(/"""/g, "\\$&").split(`
`);
                  return m2.length === 1 && (m2[0] = m2[0].trim()), m2.every((E2) => E2 === "") && (m2.length = 0), t2(s2, ['"""', ...m2, '"""']);
                }
                return ['"', x2.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
              }
              case "IntValue":
              case "FloatValue":
              case "EnumValue":
                return x2.value;
              case "BooleanValue":
                return x2.value ? "true" : "false";
              case "NullValue":
                return "null";
              case "Variable":
                return ["$", f2("name")];
              case "ListValue":
                return u2(["[", i2([r2, t2([l2("", ", "), r2], P2.map(f2, "values"))]), r2, "]"]);
              case "ObjectValue":
                return u2(["{", R2.bracketSpacing && x2.fields.length > 0 ? " " : "", i2([r2, t2([l2("", ", "), r2], P2.map(f2, "fields"))]), r2, l2("", R2.bracketSpacing && x2.fields.length > 0 ? " " : ""), "}"]);
              case "ObjectField":
              case "Argument":
                return [f2("name"), ": ", f2("value")];
              case "Directive":
                return ["@", f2("name"), x2.arguments.length > 0 ? u2(["(", i2([r2, t2([l2("", ", "), r2], w2(P2, R2, f2, "arguments"))]), r2, ")"]) : ""];
              case "NamedType":
                return f2("name");
              case "VariableDefinition":
                return [f2("variable"), ": ", f2("type"), x2.defaultValue ? [" = ", f2("defaultValue")] : "", v2(P2, f2, x2)];
              case "ObjectTypeExtension":
              case "ObjectTypeDefinition":
                return [f2("description"), x2.description ? s2 : "", x2.kind === "ObjectTypeExtension" ? "extend " : "", "type ", f2("name"), x2.interfaces.length > 0 ? [" implements ", ...A2(P2, R2, f2)] : "", v2(P2, f2, x2), x2.fields.length > 0 ? [" {", i2([s2, t2(s2, w2(P2, R2, f2, "fields"))]), s2, "}"] : ""];
              case "FieldDefinition":
                return [f2("description"), x2.description ? s2 : "", f2("name"), x2.arguments.length > 0 ? u2(["(", i2([r2, t2([l2("", ", "), r2], w2(P2, R2, f2, "arguments"))]), r2, ")"]) : "", ": ", f2("type"), v2(P2, f2, x2)];
              case "DirectiveDefinition":
                return [f2("description"), x2.description ? s2 : "", "directive ", "@", f2("name"), x2.arguments.length > 0 ? u2(["(", i2([r2, t2([l2("", ", "), r2], w2(P2, R2, f2, "arguments"))]), r2, ")"]) : "", x2.repeatable ? " repeatable" : "", " on ", t2(" | ", P2.map(f2, "locations"))];
              case "EnumTypeExtension":
              case "EnumTypeDefinition":
                return [f2("description"), x2.description ? s2 : "", x2.kind === "EnumTypeExtension" ? "extend " : "", "enum ", f2("name"), v2(P2, f2, x2), x2.values.length > 0 ? [" {", i2([s2, t2(s2, w2(P2, R2, f2, "values"))]), s2, "}"] : ""];
              case "EnumValueDefinition":
                return [f2("description"), x2.description ? s2 : "", f2("name"), v2(P2, f2, x2)];
              case "InputValueDefinition":
                return [f2("description"), x2.description ? x2.description.block ? s2 : a2 : "", f2("name"), ": ", f2("type"), x2.defaultValue ? [" = ", f2("defaultValue")] : "", v2(P2, f2, x2)];
              case "InputObjectTypeExtension":
              case "InputObjectTypeDefinition":
                return [f2("description"), x2.description ? s2 : "", x2.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", f2("name"), v2(P2, f2, x2), x2.fields.length > 0 ? [" {", i2([s2, t2(s2, w2(P2, R2, f2, "fields"))]), s2, "}"] : ""];
              case "SchemaExtension":
                return ["extend schema", v2(P2, f2, x2), ...x2.operationTypes.length > 0 ? [" {", i2([s2, t2(s2, w2(P2, R2, f2, "operationTypes"))]), s2, "}"] : []];
              case "SchemaDefinition":
                return [f2("description"), x2.description ? s2 : "", "schema", v2(P2, f2, x2), " {", x2.operationTypes.length > 0 ? i2([s2, t2(s2, w2(P2, R2, f2, "operationTypes"))]) : "", s2, "}"];
              case "OperationTypeDefinition":
                return [f2("operation"), ": ", f2("type")];
              case "InterfaceTypeExtension":
              case "InterfaceTypeDefinition":
                return [f2("description"), x2.description ? s2 : "", x2.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", f2("name"), x2.interfaces.length > 0 ? [" implements ", ...A2(P2, R2, f2)] : "", v2(P2, f2, x2), x2.fields.length > 0 ? [" {", i2([s2, t2(s2, w2(P2, R2, f2, "fields"))]), s2, "}"] : ""];
              case "FragmentSpread":
                return ["...", f2("name"), v2(P2, f2, x2)];
              case "InlineFragment":
                return ["...", x2.typeCondition ? [" on ", f2("typeCondition")] : "", v2(P2, f2, x2), " ", f2("selectionSet")];
              case "UnionTypeExtension":
              case "UnionTypeDefinition":
                return u2([f2("description"), x2.description ? s2 : "", u2([x2.kind === "UnionTypeExtension" ? "extend " : "", "union ", f2("name"), v2(P2, f2, x2), x2.types.length > 0 ? [" =", l2("", " "), i2([l2([a2, "  "]), t2([a2, "| "], P2.map(f2, "types"))])] : ""])]);
              case "ScalarTypeExtension":
              case "ScalarTypeDefinition":
                return [f2("description"), x2.description ? s2 : "", x2.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", f2("name"), v2(P2, f2, x2)];
              case "NonNullType":
                return [f2("type"), "!"];
              case "ListType":
                return ["[", f2("type"), "]"];
              default:
                throw new Error("unknown graphql type: " + JSON.stringify(x2.kind));
            }
          }
          __name(D, "D");
          function v2(P2, R2, f2) {
            if (f2.directives.length === 0)
              return "";
            let x2 = t2(a2, P2.map(R2, "directives"));
            return f2.kind === "FragmentDefinition" || f2.kind === "OperationDefinition" ? u2([a2, x2]) : [" ", u2(i2([r2, x2]))];
          }
          __name(v2, "v");
          function w2(P2, R2, f2, x2) {
            return P2.map((m2, E2, o2) => {
              let d2 = f2();
              return E2 < o2.length - 1 && c2(R2.originalText, m2.getValue(), p2) ? [d2, s2] : d2;
            }, x2);
          }
          __name(w2, "w");
          function T2(P2) {
            return P2.kind && P2.kind !== "Comment";
          }
          __name(T2, "T");
          function F(P2) {
            let R2 = P2.getValue();
            if (R2.kind === "Comment")
              return "#" + R2.value.trimEnd();
            throw new Error("Not a comment: " + JSON.stringify(R2));
          }
          __name(F, "F");
          function A2(P2, R2, f2) {
            let x2 = P2.getNode(), m2 = [], { interfaces: E2 } = x2, o2 = P2.map((d2) => f2(d2), "interfaces");
            for (let d2 = 0; d2 < E2.length; d2++) {
              let C2 = E2[d2];
              m2.push(o2[d2]);
              let _2 = E2[d2 + 1];
              if (_2) {
                let b2 = R2.originalText.slice(C2.loc.end, _2.loc.start), N2 = b2.includes("#"), k2 = b2.replace(/#.*/g, "").trim();
                m2.push(k2 === "," ? "," : " &", N2 ? a2 : " ");
              }
            }
            return m2;
          }
          __name(A2, "A");
          function B(P2, R2) {
            P2.kind === "StringValue" && P2.block && !P2.value.includes(`
`) && (R2.value = R2.value.trim());
          }
          __name(B, "B");
          B.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
          function I(P2) {
            var R2;
            let f2 = P2.getValue();
            return f2 == null || (R2 = f2.comments) === null || R2 === void 0 ? void 0 : R2.some((x2) => x2.value.trim() === "prettier-ignore");
          }
          __name(I, "I");
          n2.exports = { print: D, massageAstNode: B, hasPrettierIgnore: I, insertPragma: h3, printComment: F, canAttachComment: T2 };
        } }), _d = ee({ "src/language-graphql/options.js"(e2, n2) {
          "use strict";
          re();
          var t2 = qt();
          n2.exports = { bracketSpacing: t2.bracketSpacing };
        } }), Pd = ee({ "src/language-graphql/parsers.js"() {
          re();
        } }), Id = ee({ "node_modules/linguist-languages/data/GraphQL.json"(e2, n2) {
          n2.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
        } }), kd = ee({ "src/language-graphql/index.js"(e2, n2) {
          "use strict";
          re();
          var t2 = wt(), s2 = wd(), a2 = _d(), r2 = Pd(), u2 = [t2(Id(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i2 = { graphql: s2 };
          n2.exports = { languages: u2, options: a2, printers: i2, parsers: r2 };
        } }), co = ee({ "src/language-markdown/loc.js"(e2, n2) {
          "use strict";
          re();
          function t2(a2) {
            return a2.position.start.offset;
          }
          __name(t2, "t");
          function s2(a2) {
            return a2.position.end.offset;
          }
          __name(s2, "s");
          n2.exports = { locStart: t2, locEnd: s2 };
        } }), Ld = ee({ "src/language-markdown/constants.evaluate.js"(e2, n2) {
          n2.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
        } }), Yn = ee({ "src/language-markdown/utils.js"(e2, n2) {
          "use strict";
          re();
          var { getLast: t2 } = Ge(), { locStart: s2, locEnd: a2 } = co(), { cjkPattern: r2, kPattern: u2, punctuationPattern: i2 } = Ld(), l2 = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], c2 = [...l2, "tableCell", "paragraph", "heading"], y2 = new RegExp(u2), h3 = new RegExp(i2);
          function g2(F, A2) {
            let B = "non-cjk", I = "cj-letter", P2 = "k-letter", R2 = "cjk-punctuation", f2 = [], x2 = (A2.proseWrap === "preserve" ? F : F.replace(new RegExp(`(${r2})
(${r2})`, "g"), "$1$2")).split(/([\t\n ]+)/);
            for (let [E2, o2] of x2.entries()) {
              if (E2 % 2 === 1) {
                f2.push({ type: "whitespace", value: /\n/.test(o2) ? `
` : " " });
                continue;
              }
              if ((E2 === 0 || E2 === x2.length - 1) && o2 === "")
                continue;
              let d2 = o2.split(new RegExp(`(${r2})`));
              for (let [C2, _2] of d2.entries())
                if (!((C2 === 0 || C2 === d2.length - 1) && _2 === "")) {
                  if (C2 % 2 === 0) {
                    _2 !== "" && m2({ type: "word", value: _2, kind: B, hasLeadingPunctuation: h3.test(_2[0]), hasTrailingPunctuation: h3.test(t2(_2)) });
                    continue;
                  }
                  m2(h3.test(_2) ? { type: "word", value: _2, kind: R2, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: _2, kind: y2.test(_2) ? P2 : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                }
            }
            return f2;
            function m2(E2) {
              let o2 = t2(f2);
              o2 && o2.type === "word" && (o2.kind === B && E2.kind === I && !o2.hasTrailingPunctuation || o2.kind === I && E2.kind === B && !E2.hasLeadingPunctuation ? f2.push({ type: "whitespace", value: " " }) : !d2(B, R2) && ![o2.value, E2.value].some((C2) => /\u3000/.test(C2)) && f2.push({ type: "whitespace", value: "" })), f2.push(E2);
              function d2(C2, _2) {
                return o2.kind === C2 && E2.kind === _2 || o2.kind === _2 && E2.kind === C2;
              }
              __name(d2, "d");
            }
            __name(m2, "m");
          }
          __name(g2, "g");
          function p2(F, A2) {
            let [, B, I, P2] = A2.slice(F.position.start.offset, F.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
            return { numberText: B, marker: I, leadingSpaces: P2 };
          }
          __name(p2, "p");
          function D(F, A2) {
            if (!F.ordered || F.children.length < 2)
              return false;
            let B = Number(p2(F.children[0], A2.originalText).numberText), I = Number(p2(F.children[1], A2.originalText).numberText);
            if (B === 0 && F.children.length > 2) {
              let P2 = Number(p2(F.children[2], A2.originalText).numberText);
              return I === 1 && P2 === 1;
            }
            return I === 1;
          }
          __name(D, "D");
          function v2(F, A2) {
            let { value: B } = F;
            return F.position.end.offset === A2.length && B.endsWith(`
`) && A2.endsWith(`
`) ? B.slice(0, -1) : B;
          }
          __name(v2, "v");
          function w2(F, A2) {
            return (/* @__PURE__ */ __name(function B(I, P2, R2) {
              let f2 = Object.assign({}, A2(I, P2, R2));
              return f2.children && (f2.children = f2.children.map((x2, m2) => B(x2, m2, [f2, ...R2]))), f2;
            }, "B"))(F, null, []);
          }
          __name(w2, "w");
          function T2(F) {
            if ((F == null ? void 0 : F.type) !== "link" || F.children.length !== 1)
              return false;
            let [A2] = F.children;
            return s2(F) === s2(A2) && a2(F) === a2(A2);
          }
          __name(T2, "T");
          n2.exports = { mapAst: w2, splitText: g2, punctuationPattern: i2, getFencedCodeBlockValue: v2, getOrderedListItemInfo: p2, hasGitDiffFriendlyOrderedList: D, INLINE_NODE_TYPES: l2, INLINE_NODE_WRAPPER_TYPES: c2, isAutolink: T2 };
        } }), jd = ee({ "src/language-markdown/embed.js"(e2, n2) {
          "use strict";
          re();
          var { inferParserByLanguage: t2, getMaxContinuousCount: s2 } = Ge(), { builders: { hardline: a2, markAsRoot: r2 }, utils: { replaceEndOfLine: u2 } } = qe(), i2 = Kn(), { getFencedCodeBlockValue: l2 } = Yn();
          function c2(y2, h3, g2, p2) {
            let D = y2.getValue();
            if (D.type === "code" && D.lang !== null) {
              let v2 = t2(D.lang, p2);
              if (v2) {
                let w2 = p2.__inJsTemplate ? "~" : "`", T2 = w2.repeat(Math.max(3, s2(D.value, w2) + 1)), F = { parser: v2 };
                D.lang === "tsx" && (F.filepath = "dummy.tsx");
                let A2 = g2(l2(D, p2.originalText), F, { stripTrailingHardline: true });
                return r2([T2, D.lang, D.meta ? " " + D.meta : "", a2, u2(A2), a2, T2]);
              }
            }
            switch (D.type) {
              case "front-matter":
                return i2(D, g2);
              case "importExport":
                return [g2(D.value, { parser: "babel" }, { stripTrailingHardline: true }), a2];
              case "jsx":
                return g2(`<$>${D.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
            }
            return null;
          }
          __name(c2, "c");
          n2.exports = c2;
        } }), po = ee({ "src/language-markdown/pragma.js"(e2, n2) {
          "use strict";
          re();
          var t2 = lo(), s2 = ["format", "prettier"];
          function a2(r2) {
            let u2 = `@(${s2.join("|")})`, i2 = new RegExp([`<!--\\s*${u2}\\s*-->`, `{\\s*\\/\\*\\s*${u2}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u2}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l2 = r2.match(i2);
            return (l2 == null ? void 0 : l2.index) === 0;
          }
          __name(a2, "a");
          n2.exports = { startWithPragma: a2, hasPragma: (r2) => a2(t2(r2).content.trimStart()), insertPragma: (r2) => {
            let u2 = t2(r2), i2 = `<!-- @${s2[0]} -->`;
            return u2.frontMatter ? `${u2.frontMatter.raw}

${i2}

${u2.content}` : `${i2}

${u2.content}`;
          } };
        } }), Od = ee({ "src/language-markdown/print-preprocess.js"(e2, n2) {
          "use strict";
          re();
          var t2 = lt(), { getOrderedListItemInfo: s2, mapAst: a2, splitText: r2 } = Yn(), u2 = /^.$/su;
          function i2(T2, F) {
            return T2 = y2(T2, F), T2 = p2(T2), T2 = c2(T2, F), T2 = v2(T2, F), T2 = w2(T2, F), T2 = D(T2, F), T2 = l2(T2), T2 = h3(T2), T2;
          }
          __name(i2, "i");
          function l2(T2) {
            return a2(T2, (F) => F.type !== "import" && F.type !== "export" ? F : Object.assign(Object.assign({}, F), {}, { type: "importExport" }));
          }
          __name(l2, "l");
          function c2(T2, F) {
            return a2(T2, (A2) => A2.type !== "inlineCode" || F.proseWrap === "preserve" ? A2 : Object.assign(Object.assign({}, A2), {}, { value: A2.value.replace(/\s+/g, " ") }));
          }
          __name(c2, "c");
          function y2(T2, F) {
            return a2(T2, (A2) => A2.type !== "text" || A2.value === "*" || A2.value === "_" || !u2.test(A2.value) || A2.position.end.offset - A2.position.start.offset === A2.value.length ? A2 : Object.assign(Object.assign({}, A2), {}, { value: F.originalText.slice(A2.position.start.offset, A2.position.end.offset) }));
          }
          __name(y2, "y");
          function h3(T2) {
            return g2(T2, (F, A2) => F.type === "importExport" && A2.type === "importExport", (F, A2) => ({ type: "importExport", value: F.value + `

` + A2.value, position: { start: F.position.start, end: A2.position.end } }));
          }
          __name(h3, "h");
          function g2(T2, F, A2) {
            return a2(T2, (B) => {
              if (!B.children)
                return B;
              let I = B.children.reduce((P2, R2) => {
                let f2 = t2(P2);
                return f2 && F(f2, R2) ? P2.splice(-1, 1, A2(f2, R2)) : P2.push(R2), P2;
              }, []);
              return Object.assign(Object.assign({}, B), {}, { children: I });
            });
          }
          __name(g2, "g");
          function p2(T2) {
            return g2(T2, (F, A2) => F.type === "text" && A2.type === "text", (F, A2) => ({ type: "text", value: F.value + A2.value, position: { start: F.position.start, end: A2.position.end } }));
          }
          __name(p2, "p");
          function D(T2, F) {
            return a2(T2, (A2, B, I) => {
              let [P2] = I;
              if (A2.type !== "text")
                return A2;
              let { value: R2 } = A2;
              return P2.type === "paragraph" && (B === 0 && (R2 = R2.trimStart()), B === P2.children.length - 1 && (R2 = R2.trimEnd())), { type: "sentence", position: A2.position, children: r2(R2, F) };
            });
          }
          __name(D, "D");
          function v2(T2, F) {
            return a2(T2, (A2, B, I) => {
              if (A2.type === "code") {
                let P2 = /^\n?(?: {4,}|\t)/.test(F.originalText.slice(A2.position.start.offset, A2.position.end.offset));
                if (A2.isIndented = P2, P2)
                  for (let R2 = 0; R2 < I.length; R2++) {
                    let f2 = I[R2];
                    if (f2.hasIndentedCodeblock)
                      break;
                    f2.type === "list" && (f2.hasIndentedCodeblock = true);
                  }
              }
              return A2;
            });
          }
          __name(v2, "v");
          function w2(T2, F) {
            return a2(T2, (I, P2, R2) => {
              if (I.type === "list" && I.children.length > 0) {
                for (let f2 = 0; f2 < R2.length; f2++) {
                  let x2 = R2[f2];
                  if (x2.type === "list" && !x2.isAligned)
                    return I.isAligned = false, I;
                }
                I.isAligned = B(I);
              }
              return I;
            });
            function A2(I) {
              return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
            }
            __name(A2, "A");
            function B(I) {
              if (!I.ordered)
                return true;
              let [P2, R2] = I.children;
              if (s2(P2, F.originalText).leadingSpaces.length > 1)
                return true;
              let x2 = A2(P2);
              if (x2 === -1)
                return false;
              if (I.children.length === 1)
                return x2 % F.tabWidth === 0;
              let m2 = A2(R2);
              return x2 !== m2 ? false : x2 % F.tabWidth === 0 ? true : s2(R2, F.originalText).leadingSpaces.length > 1;
            }
            __name(B, "B");
          }
          __name(w2, "w");
          n2.exports = i2;
        } }), qd = ee({ "src/language-markdown/clean.js"(e2, n2) {
          "use strict";
          re();
          var { isFrontMatterNode: t2 } = Ge(), { startWithPragma: s2 } = po(), a2 = /* @__PURE__ */ new Set(["position", "raw"]);
          function r2(u2, i2, l2) {
            if ((u2.type === "front-matter" || u2.type === "code" || u2.type === "yaml" || u2.type === "import" || u2.type === "export" || u2.type === "jsx") && delete i2.value, u2.type === "list" && delete i2.isAligned, (u2.type === "list" || u2.type === "listItem") && (delete i2.spread, delete i2.loose), u2.type === "text" || (u2.type === "inlineCode" && (i2.value = u2.value.replace(/[\t\n ]+/g, " ")), u2.type === "wikiLink" && (i2.value = u2.value.trim().replace(/[\t\n]+/g, " ")), (u2.type === "definition" || u2.type === "linkReference") && (i2.label = u2.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), (u2.type === "definition" || u2.type === "link" || u2.type === "image") && u2.title && (i2.title = u2.title.replace(/\\(["')])/g, "$1")), l2 && l2.type === "root" && l2.children.length > 0 && (l2.children[0] === u2 || t2(l2.children[0]) && l2.children[1] === u2) && u2.type === "html" && s2(u2.value)))
              return null;
          }
          __name(r2, "r");
          r2.ignoredProperties = a2, n2.exports = r2;
        } }), Md = ee({ "src/language-markdown/printer-markdown.js"(e2, n2) {
          "use strict";
          re();
          var { getLast: t2, getMinNotPresentContinuousCount: s2, getMaxContinuousCount: a2, getStringWidth: r2, isNonEmptyArray: u2 } = Ge(), { builders: { breakParent: i2, join: l2, line: c2, literalline: y2, markAsRoot: h3, hardline: g2, softline: p2, ifBreak: D, fill: v2, align: w2, indent: T2, group: F, hardlineWithoutBreakParent: A2 }, utils: { normalizeDoc: B, replaceTextEndOfLine: I }, printer: { printDocToString: P2 } } = qe(), R2 = jd(), { insertPragma: f2 } = po(), { locStart: x2, locEnd: m2 } = co(), E2 = Od(), o2 = qd(), { getFencedCodeBlockValue: d2, hasGitDiffFriendlyOrderedList: C2, splitText: _2, punctuationPattern: b2, INLINE_NODE_TYPES: N2, INLINE_NODE_WRAPPER_TYPES: k2, isAutolink: $ } = Yn(), M2 = /* @__PURE__ */ new Set(["importExport"]), q = ["heading", "tableCell", "link", "wikiLink"], J = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
          function L2(pe, ie, ve) {
            let ce = pe.getValue();
            if (fe(pe))
              return _2(ie.originalText.slice(ce.position.start.offset, ce.position.end.offset), ie).map((U2) => U2.type === "word" ? U2.value : U2.value === "" ? "" : le(pe, U2.value, ie));
            switch (ce.type) {
              case "front-matter":
                return ie.originalText.slice(ce.position.start.offset, ce.position.end.offset);
              case "root":
                return ce.children.length === 0 ? "" : [B(X(pe, ie, ve)), M2.has(Ae(ce).type) ? "" : g2];
              case "paragraph":
                return oe(pe, ie, ve, { postprocessor: v2 });
              case "sentence":
                return oe(pe, ie, ve);
              case "word": {
                let U2 = ce.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${b2})(_+)`, `(_+)(${b2}|$)`].join("|"), "g"), (he, Be, Se, ye, S2) => (Se ? `${Be}${Se}` : `${ye}${S2}`).replace(/_/g, "\\_")), de = /* @__PURE__ */ __name((he, Be, Se) => he.type === "sentence" && Se === 0, "de"), De = /* @__PURE__ */ __name((he, Be, Se) => $(he.children[Se - 1]), "De");
                return U2 !== ce.value && (pe.match(void 0, de, De) || pe.match(void 0, de, (he, Be, Se) => he.type === "emphasis" && Se === 0, De)) && (U2 = U2.replace(/^(\\?[*_])+/, (he) => he.replace(/\\/g, ""))), U2;
              }
              case "whitespace": {
                let U2 = pe.getParentNode(), de = U2.children.indexOf(ce), De = U2.children[de + 1], he = De && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(De.value) ? "never" : ie.proseWrap;
                return le(pe, ce.value, { proseWrap: he });
              }
              case "emphasis": {
                let U2;
                if ($(ce.children[0]))
                  U2 = ie.originalText[ce.position.start.offset];
                else {
                  let de = pe.getParentNode(), De = de.children.indexOf(ce), he = de.children[De - 1], Be = de.children[De + 1];
                  U2 = he && he.type === "sentence" && he.children.length > 0 && t2(he.children).type === "word" && !t2(he.children).hasTrailingPunctuation || Be && Be.type === "sentence" && Be.children.length > 0 && Be.children[0].type === "word" && !Be.children[0].hasLeadingPunctuation || Q(pe, "emphasis") ? "*" : "_";
                }
                return [U2, oe(pe, ie, ve), U2];
              }
              case "strong":
                return ["**", oe(pe, ie, ve), "**"];
              case "delete":
                return ["~~", oe(pe, ie, ve), "~~"];
              case "inlineCode": {
                let U2 = s2(ce.value, "`"), de = "`".repeat(U2 || 1), De = U2 && !/^\s/.test(ce.value) ? " " : "";
                return [de, De, ce.value, De, de];
              }
              case "wikiLink": {
                let U2 = "";
                return ie.proseWrap === "preserve" ? U2 = ce.value : U2 = ce.value.replace(/[\t\n]+/g, " "), ["[[", U2, "]]"];
              }
              case "link":
                switch (ie.originalText[ce.position.start.offset]) {
                  case "<": {
                    let U2 = "mailto:", de = ce.url.startsWith(U2) && ie.originalText.slice(ce.position.start.offset + 1, ce.position.start.offset + 1 + U2.length) !== U2 ? ce.url.slice(U2.length) : ce.url;
                    return ["<", de, ">"];
                  }
                  case "[":
                    return ["[", oe(pe, ie, ve), "](", ge(ce.url, ")"), Ce(ce.title, ie), ")"];
                  default:
                    return ie.originalText.slice(ce.position.start.offset, ce.position.end.offset);
                }
              case "image":
                return ["![", ce.alt || "", "](", ge(ce.url, ")"), Ce(ce.title, ie), ")"];
              case "blockquote":
                return ["> ", w2("> ", oe(pe, ie, ve))];
              case "heading":
                return ["#".repeat(ce.depth) + " ", oe(pe, ie, ve)];
              case "code": {
                if (ce.isIndented) {
                  let De = " ".repeat(4);
                  return w2(De, [De, ...I(ce.value, g2)]);
                }
                let U2 = ie.__inJsTemplate ? "~" : "`", de = U2.repeat(Math.max(3, a2(ce.value, U2) + 1));
                return [de, ce.lang || "", ce.meta ? " " + ce.meta : "", g2, ...I(d2(ce, ie.originalText), g2), g2, de];
              }
              case "html": {
                let U2 = pe.getParentNode(), de = U2.type === "root" && t2(U2.children) === ce ? ce.value.trimEnd() : ce.value, De = /^<!--.*-->$/s.test(de);
                return I(de, De ? g2 : h3(y2));
              }
              case "list": {
                let U2 = O2(ce, pe.getParentNode()), de = C2(ce, ie);
                return oe(pe, ie, ve, { processor: (De, he) => {
                  let Be = ye(), Se = De.getValue();
                  if (Se.children.length === 2 && Se.children[1].type === "html" && Se.children[0].position.start.column !== Se.children[1].position.start.column)
                    return [Be, Y(De, ie, ve, Be)];
                  return [Be, w2(" ".repeat(Be.length), Y(De, ie, ve, Be))];
                  function ye() {
                    let S2 = ce.ordered ? (he === 0 ? ce.start : de ? 1 : ce.start + he) + (U2 % 2 === 0 ? ". " : ") ") : U2 % 2 === 0 ? "- " : "* ";
                    return ce.isAligned || ce.hasIndentedCodeblock ? V(S2, ie) : S2;
                  }
                  __name(ye, "ye");
                } });
              }
              case "thematicBreak": {
                let U2 = se(pe, "list");
                return U2 === -1 ? "---" : O2(pe.getParentNode(U2), pe.getParentNode(U2 + 1)) % 2 === 0 ? "***" : "---";
              }
              case "linkReference":
                return ["[", oe(pe, ie, ve), "]", ce.referenceType === "full" ? ["[", ce.identifier, "]"] : ce.referenceType === "collapsed" ? "[]" : ""];
              case "imageReference":
                switch (ce.referenceType) {
                  case "full":
                    return ["![", ce.alt || "", "][", ce.identifier, "]"];
                  default:
                    return ["![", ce.alt, "]", ce.referenceType === "collapsed" ? "[]" : ""];
                }
              case "definition": {
                let U2 = ie.proseWrap === "always" ? c2 : " ";
                return F(["[", ce.identifier, "]:", T2([U2, ge(ce.url), ce.title === null ? "" : [U2, Ce(ce.title, ie, false)]])]);
              }
              case "footnote":
                return ["[^", oe(pe, ie, ve), "]"];
              case "footnoteReference":
                return ["[^", ce.identifier, "]"];
              case "footnoteDefinition": {
                let U2 = pe.getParentNode().children[pe.getName() + 1], de = ce.children.length === 1 && ce.children[0].type === "paragraph" && (ie.proseWrap === "never" || ie.proseWrap === "preserve" && ce.children[0].position.start.line === ce.children[0].position.end.line);
                return ["[^", ce.identifier, "]: ", de ? oe(pe, ie, ve) : F([w2(" ".repeat(4), oe(pe, ie, ve, { processor: (De, he) => he === 0 ? F([p2, ve()]) : ve() })), U2 && U2.type === "footnoteDefinition" ? p2 : ""])];
              }
              case "table":
                return W2(pe, ie, ve);
              case "tableCell":
                return oe(pe, ie, ve);
              case "break":
                return /\s/.test(ie.originalText[ce.position.start.offset]) ? ["  ", h3(y2)] : ["\\", g2];
              case "liquidNode":
                return I(ce.value, g2);
              case "importExport":
                return [ce.value, g2];
              case "esComment":
                return ["{/* ", ce.value, " */}"];
              case "jsx":
                return ce.value;
              case "math":
                return ["$$", g2, ce.value ? [...I(ce.value, g2), g2] : "", "$$"];
              case "inlineMath":
                return ie.originalText.slice(x2(ce), m2(ce));
              case "tableRow":
              case "listItem":
              default:
                throw new Error(`Unknown markdown type ${JSON.stringify(ce.type)}`);
            }
          }
          __name(L2, "L");
          function Y(pe, ie, ve, ce) {
            let U2 = pe.getValue(), de = U2.checked === null ? "" : U2.checked ? "[x] " : "[ ] ";
            return [de, oe(pe, ie, ve, { processor: (De, he) => {
              if (he === 0 && De.getValue().type !== "list")
                return w2(" ".repeat(de.length), ve());
              let Be = " ".repeat(_e(ie.tabWidth - ce.length, 0, 3));
              return [Be, w2(Be, ve())];
            } })];
          }
          __name(Y, "Y");
          function V(pe, ie) {
            let ve = ce();
            return pe + " ".repeat(ve >= 4 ? 0 : ve);
            function ce() {
              let U2 = pe.length % ie.tabWidth;
              return U2 === 0 ? 0 : ie.tabWidth - U2;
            }
            __name(ce, "ce");
          }
          __name(V, "V");
          function O2(pe, ie) {
            return K(pe, ie, (ve) => ve.ordered === pe.ordered);
          }
          __name(O2, "O");
          function K(pe, ie, ve) {
            let ce = -1;
            for (let U2 of ie.children)
              if (U2.type === pe.type && ve(U2) ? ce++ : ce = -1, U2 === pe)
                return ce;
          }
          __name(K, "K");
          function se(pe, ie) {
            let ve = Array.isArray(ie) ? ie : [ie], ce = -1, U2;
            for (; U2 = pe.getParentNode(++ce); )
              if (ve.includes(U2.type))
                return ce;
            return -1;
          }
          __name(se, "se");
          function Q(pe, ie) {
            let ve = se(pe, ie);
            return ve === -1 ? null : pe.getParentNode(ve);
          }
          __name(Q, "Q");
          function le(pe, ie, ve) {
            if (ve.proseWrap === "preserve" && ie === `
`)
              return g2;
            let ce = ve.proseWrap === "always" && !Q(pe, q);
            return ie !== "" ? ce ? c2 : " " : ce ? p2 : "";
          }
          __name(le, "le");
          function W2(pe, ie, ve) {
            let ce = pe.getValue(), U2 = [], de = pe.map((S2) => S2.map((G, te) => {
              let Ee = P2(ve(), ie).formatted, Re = r2(Ee);
              return U2[te] = Math.max(U2[te] || 3, Re), { text: Ee, width: Re };
            }, "children"), "children"), De = Be(false);
            if (ie.proseWrap !== "never")
              return [i2, De];
            let he = Be(true);
            return [i2, F(D(he, De))];
            function Be(S2) {
              let G = [ye(de[0], S2), Se(S2)];
              return de.length > 1 && G.push(l2(A2, de.slice(1).map((te) => ye(te, S2)))), l2(A2, G);
            }
            __name(Be, "Be");
            function Se(S2) {
              return `| ${U2.map((te, Ee) => {
                let Re = ce.align[Ee], Te = Re === "center" || Re === "left" ? ":" : "-", Pe = Re === "center" || Re === "right" ? ":" : "-", Fe = S2 ? "-" : "-".repeat(te - 2);
                return `${Te}${Fe}${Pe}`;
              }).join(" | ")} |`;
            }
            __name(Se, "Se");
            function ye(S2, G) {
              return `| ${S2.map((Ee, Re) => {
                let { text: Te, width: Pe } = Ee;
                if (G)
                  return Te;
                let Fe = U2[Re] - Pe, Ze = ce.align[Re], xe = 0;
                Ze === "right" ? xe = Fe : Ze === "center" && (xe = Math.floor(Fe / 2));
                let Je = Fe - xe;
                return `${" ".repeat(xe)}${Te}${" ".repeat(Je)}`;
              }).join(" | ")} |`;
            }
            __name(ye, "ye");
          }
          __name(W2, "W");
          function X(pe, ie, ve) {
            let ce = [], U2 = null, { children: de } = pe.getValue();
            for (let [De, he] of de.entries())
              switch (z(he)) {
                case "start":
                  U2 === null && (U2 = { index: De, offset: he.position.end.offset });
                  break;
                case "end":
                  U2 !== null && (ce.push({ start: U2, end: { index: De, offset: he.position.start.offset } }), U2 = null);
                  break;
                default:
                  break;
              }
            return oe(pe, ie, ve, { processor: (De, he) => {
              if (ce.length > 0) {
                let Be = ce[0];
                if (he === Be.start.index)
                  return [ae(de[Be.start.index]), ie.originalText.slice(Be.start.offset, Be.end.offset), ae(de[Be.end.index])];
                if (Be.start.index < he && he < Be.end.index)
                  return false;
                if (he === Be.end.index)
                  return ce.shift(), false;
              }
              return ve();
            } });
          }
          __name(X, "X");
          function oe(pe, ie, ve) {
            let ce = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: U2 } = ce, de = ce.processor || (() => ve()), De = pe.getValue(), he = [], Be;
            return pe.each((Se, ye) => {
              let S2 = Se.getValue(), G = de(Se, ye);
              if (G !== false) {
                let te = { parts: he, prevNode: Be, parentNode: De, options: ie };
                H(S2, te) && (he.push(g2), Be && M2.has(Be.type) || (Z(S2, te) || ne(S2, te)) && he.push(g2), ne(S2, te) && he.push(g2)), he.push(G), Be = S2;
              }
            }, "children"), U2 ? U2(he) : he;
          }
          __name(oe, "oe");
          function ae(pe) {
            if (pe.type === "html")
              return pe.value;
            if (pe.type === "paragraph" && Array.isArray(pe.children) && pe.children.length === 1 && pe.children[0].type === "esComment")
              return ["{/* ", pe.children[0].value, " */}"];
          }
          __name(ae, "ae");
          function Ae(pe) {
            let ie = pe;
            for (; u2(ie.children); )
              ie = t2(ie.children);
            return ie;
          }
          __name(Ae, "Ae");
          function z(pe) {
            let ie;
            if (pe.type === "html")
              ie = pe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
            else {
              let ve;
              pe.type === "esComment" ? ve = pe : pe.type === "paragraph" && pe.children.length === 1 && pe.children[0].type === "esComment" && (ve = pe.children[0]), ve && (ie = ve.value.match(/^prettier-ignore(?:-(start|end))?$/));
            }
            return ie ? ie[1] || "next" : false;
          }
          __name(z, "z");
          function H(pe, ie) {
            let ve = ie.parts.length === 0, ce = N2.includes(pe.type), U2 = pe.type === "html" && k2.includes(ie.parentNode.type);
            return !ve && !ce && !U2;
          }
          __name(H, "H");
          function Z(pe, ie) {
            var ve, ce, U2;
            let De = (ie.prevNode && ie.prevNode.type) === pe.type && J.has(pe.type), he = ie.parentNode.type === "listItem" && !ie.parentNode.loose, Be = ((ve = ie.prevNode) === null || ve === void 0 ? void 0 : ve.type) === "listItem" && ie.prevNode.loose, Se = z(ie.prevNode) === "next", ye = pe.type === "html" && ((ce = ie.prevNode) === null || ce === void 0 ? void 0 : ce.type) === "html" && ie.prevNode.position.end.line + 1 === pe.position.start.line, S2 = pe.type === "html" && ie.parentNode.type === "listItem" && ((U2 = ie.prevNode) === null || U2 === void 0 ? void 0 : U2.type) === "paragraph" && ie.prevNode.position.end.line + 1 === pe.position.start.line;
            return Be || !(De || he || Se || ye || S2);
          }
          __name(Z, "Z");
          function ne(pe, ie) {
            let ve = ie.prevNode && ie.prevNode.type === "list", ce = pe.type === "code" && pe.isIndented;
            return ve && ce;
          }
          __name(ne, "ne");
          function fe(pe) {
            let ie = Q(pe, ["linkReference", "imageReference"]);
            return ie && (ie.type !== "linkReference" || ie.referenceType !== "full");
          }
          __name(fe, "fe");
          function ge(pe) {
            let ie = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], ve = [" ", ...Array.isArray(ie) ? ie : [ie]];
            return new RegExp(ve.map((ce) => `\\${ce}`).join("|")).test(pe) ? `<${pe}>` : pe;
          }
          __name(ge, "ge");
          function Ce(pe, ie) {
            let ve = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            if (!pe)
              return "";
            if (ve)
              return " " + Ce(pe, ie, false);
            if (pe = pe.replace(/\\(["')])/g, "$1"), pe.includes('"') && pe.includes("'") && !pe.includes(")"))
              return `(${pe})`;
            let ce = pe.split("'").length - 1, U2 = pe.split('"').length - 1, de = ce > U2 ? '"' : U2 > ce || ie.singleQuote ? "'" : '"';
            return pe = pe.replace(/\\/, "\\\\"), pe = pe.replace(new RegExp(`(${de})`, "g"), "\\$1"), `${de}${pe}${de}`;
          }
          __name(Ce, "Ce");
          function _e(pe, ie, ve) {
            return pe < ie ? ie : pe > ve ? ve : pe;
          }
          __name(_e, "_e");
          function Oe(pe) {
            let ie = Number(pe.getName());
            if (ie === 0)
              return false;
            let ve = pe.getParentNode().children[ie - 1];
            return z(ve) === "next";
          }
          __name(Oe, "Oe");
          n2.exports = { preprocess: E2, print: L2, embed: R2, massageAstNode: o2, hasPrettierIgnore: Oe, insertPragma: f2 };
        } }), Rd = ee({ "src/language-markdown/options.js"(e2, n2) {
          "use strict";
          re();
          var t2 = qt();
          n2.exports = { proseWrap: t2.proseWrap, singleQuote: t2.singleQuote };
        } }), $d = ee({ "src/language-markdown/parsers.js"() {
          re();
        } }), ca = ee({ "node_modules/linguist-languages/data/Markdown.json"(e2, n2) {
          n2.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
        } }), Vd = ee({ "src/language-markdown/index.js"(e2, n2) {
          "use strict";
          re();
          var t2 = wt(), s2 = Md(), a2 = Rd(), r2 = $d(), u2 = [t2(ca(), (l2) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l2.filenames, "README"], extensions: l2.extensions.filter((c2) => c2 !== ".mdx") })), t2(ca(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i2 = { mdast: s2 };
          n2.exports = { languages: u2, options: a2, printers: i2, parsers: r2 };
        } }), Wd = ee({ "src/language-html/clean.js"(e2, n2) {
          "use strict";
          re();
          var { isFrontMatterNode: t2 } = Ge(), s2 = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
          function a2(r2, u2) {
            if (r2.type === "text" || r2.type === "comment" || t2(r2) || r2.type === "yaml" || r2.type === "toml")
              return null;
            r2.type === "attribute" && delete u2.value, r2.type === "docType" && delete u2.value;
          }
          __name(a2, "a");
          a2.ignoredProperties = s2, n2.exports = a2;
        } }), Hd = ee({ "src/language-html/constants.evaluate.js"(e2, n2) {
          n2.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
        } }), Gd = ee({ "src/language-html/utils/is-unknown-namespace.js"(e2, n2) {
          "use strict";
          re();
          function t2(s2) {
            return s2.type === "element" && !s2.hasExplicitNamespace && !["html", "svg"].includes(s2.namespace);
          }
          __name(t2, "t");
          n2.exports = t2;
        } }), Mt = ee({ "src/language-html/utils/index.js"(e2, n2) {
          "use strict";
          re();
          var { inferParserByLanguage: t2, isFrontMatterNode: s2 } = Ge(), { builders: { line: a2, hardline: r2, join: u2 }, utils: { getDocParts: i2, replaceTextEndOfLine: l2 } } = qe(), { CSS_DISPLAY_TAGS: c2, CSS_DISPLAY_DEFAULT: y2, CSS_WHITE_SPACE_TAGS: h3, CSS_WHITE_SPACE_DEFAULT: g2 } = Hd(), p2 = Gd(), D = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), v2 = /* @__PURE__ */ __name((S2) => S2.replace(/^[\t\n\f\r ]+/, ""), "v"), w2 = /* @__PURE__ */ __name((S2) => S2.replace(/[\t\n\f\r ]+$/, ""), "w"), T2 = /* @__PURE__ */ __name((S2) => v2(w2(S2)), "T"), F = /* @__PURE__ */ __name((S2) => S2.replace(/^[\t\f\r ]*\n/g, ""), "F"), A2 = /* @__PURE__ */ __name((S2) => F(w2(S2)), "A"), B = /* @__PURE__ */ __name((S2) => S2.split(/[\t\n\f\r ]+/), "B"), I = /* @__PURE__ */ __name((S2) => S2.match(/^[\t\n\f\r ]*/)[0], "I"), P2 = /* @__PURE__ */ __name((S2) => {
            let [, G, te, Ee] = S2.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
            return { leadingWhitespace: G, trailingWhitespace: Ee, text: te };
          }, "P"), R2 = /* @__PURE__ */ __name((S2) => /[\t\n\f\r ]/.test(S2), "R");
          function f2(S2, G) {
            return !!(S2.type === "ieConditionalComment" && S2.lastChild && !S2.lastChild.isSelfClosing && !S2.lastChild.endSourceSpan || S2.type === "ieConditionalComment" && !S2.complete || ne(S2) && S2.children.some((te) => te.type !== "text" && te.type !== "interpolation") || De(S2, G) && !o2(S2) && S2.type !== "interpolation");
          }
          __name(f2, "f");
          function x2(S2) {
            return S2.type === "attribute" || !S2.parent || !S2.prev ? false : m2(S2.prev);
          }
          __name(x2, "x");
          function m2(S2) {
            return S2.type === "comment" && S2.value.trim() === "prettier-ignore";
          }
          __name(m2, "m");
          function E2(S2) {
            return S2.type === "text" || S2.type === "comment";
          }
          __name(E2, "E");
          function o2(S2) {
            return S2.type === "element" && (S2.fullName === "script" || S2.fullName === "style" || S2.fullName === "svg:style" || p2(S2) && (S2.name === "script" || S2.name === "style"));
          }
          __name(o2, "o");
          function d2(S2) {
            return S2.children && !o2(S2);
          }
          __name(d2, "d");
          function C2(S2) {
            return o2(S2) || S2.type === "interpolation" || _2(S2);
          }
          __name(C2, "C");
          function _2(S2) {
            return _e(S2).startsWith("pre");
          }
          __name(_2, "_");
          function b2(S2, G) {
            let te = Ee();
            if (te && !S2.prev && S2.parent && S2.parent.tagDefinition && S2.parent.tagDefinition.ignoreFirstLf)
              return S2.type === "interpolation";
            return te;
            function Ee() {
              return s2(S2) ? false : (S2.type === "text" || S2.type === "interpolation") && S2.prev && (S2.prev.type === "text" || S2.prev.type === "interpolation") ? true : !S2.parent || S2.parent.cssDisplay === "none" ? false : ne(S2.parent) ? true : !(!S2.prev && (S2.parent.type === "root" || ne(S2) && S2.parent || o2(S2.parent) || U2(S2.parent, G) || !ae(S2.parent.cssDisplay)) || S2.prev && !H(S2.prev.cssDisplay));
            }
            __name(Ee, "Ee");
          }
          __name(b2, "b");
          function N2(S2, G) {
            return s2(S2) ? false : (S2.type === "text" || S2.type === "interpolation") && S2.next && (S2.next.type === "text" || S2.next.type === "interpolation") ? true : !S2.parent || S2.parent.cssDisplay === "none" ? false : ne(S2.parent) ? true : !(!S2.next && (S2.parent.type === "root" || ne(S2) && S2.parent || o2(S2.parent) || U2(S2.parent, G) || !Ae(S2.parent.cssDisplay)) || S2.next && !z(S2.next.cssDisplay));
          }
          __name(N2, "N");
          function k2(S2) {
            return Z(S2.cssDisplay) && !o2(S2);
          }
          __name(k2, "k");
          function $(S2) {
            return s2(S2) || S2.next && S2.sourceSpan.end && S2.sourceSpan.end.line + 1 < S2.next.sourceSpan.start.line;
          }
          __name($, "$");
          function M2(S2) {
            return q(S2) || S2.type === "element" && S2.children.length > 0 && (["body", "script", "style"].includes(S2.name) || S2.children.some((G) => Q(G))) || S2.firstChild && S2.firstChild === S2.lastChild && S2.firstChild.type !== "text" && V(S2.firstChild) && (!S2.lastChild.isTrailingSpaceSensitive || O2(S2.lastChild));
          }
          __name(M2, "M");
          function q(S2) {
            return S2.type === "element" && S2.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(S2.name) || S2.cssDisplay.startsWith("table") && S2.cssDisplay !== "table-cell");
          }
          __name(q, "q");
          function J(S2) {
            return K(S2) || S2.prev && L2(S2.prev) || Y(S2);
          }
          __name(J, "J");
          function L2(S2) {
            return K(S2) || S2.type === "element" && S2.fullName === "br" || Y(S2);
          }
          __name(L2, "L");
          function Y(S2) {
            return V(S2) && O2(S2);
          }
          __name(Y, "Y");
          function V(S2) {
            return S2.hasLeadingSpaces && (S2.prev ? S2.prev.sourceSpan.end.line < S2.sourceSpan.start.line : S2.parent.type === "root" || S2.parent.startSourceSpan.end.line < S2.sourceSpan.start.line);
          }
          __name(V, "V");
          function O2(S2) {
            return S2.hasTrailingSpaces && (S2.next ? S2.next.sourceSpan.start.line > S2.sourceSpan.end.line : S2.parent.type === "root" || S2.parent.endSourceSpan && S2.parent.endSourceSpan.start.line > S2.sourceSpan.end.line);
          }
          __name(O2, "O");
          function K(S2) {
            switch (S2.type) {
              case "ieConditionalComment":
              case "comment":
              case "directive":
                return true;
              case "element":
                return ["script", "select"].includes(S2.name);
            }
            return false;
          }
          __name(K, "K");
          function se(S2) {
            return S2.lastChild ? se(S2.lastChild) : S2;
          }
          __name(se, "se");
          function Q(S2) {
            return S2.children && S2.children.some((G) => G.type !== "text");
          }
          __name(Q, "Q");
          function le(S2) {
            let { type: G, lang: te } = S2.attrMap;
            if (G === "module" || G === "text/javascript" || G === "text/babel" || G === "application/javascript" || te === "jsx")
              return "babel";
            if (G === "application/x-typescript" || te === "ts" || te === "tsx")
              return "typescript";
            if (G === "text/markdown")
              return "markdown";
            if (G === "text/html")
              return "html";
            if (G && (G.endsWith("json") || G.endsWith("importmap")) || G === "speculationrules")
              return "json";
            if (G === "text/x-handlebars-template")
              return "glimmer";
          }
          __name(le, "le");
          function W2(S2, G) {
            let { lang: te } = S2.attrMap;
            if (!te || te === "postcss" || te === "css")
              return "css";
            if (te === "scss")
              return "scss";
            if (te === "less")
              return "less";
            if (te === "stylus")
              return t2("stylus", G);
          }
          __name(W2, "W");
          function X(S2, G) {
            if (S2.name === "script" && !S2.attrMap.src)
              return !S2.attrMap.lang && !S2.attrMap.type ? "babel" : le(S2);
            if (S2.name === "style")
              return W2(S2, G);
            if (G && De(S2, G))
              return le(S2) || !("src" in S2.attrMap) && t2(S2.attrMap.lang, G);
          }
          __name(X, "X");
          function oe(S2) {
            return S2 === "block" || S2 === "list-item" || S2.startsWith("table");
          }
          __name(oe, "oe");
          function ae(S2) {
            return !oe(S2) && S2 !== "inline-block";
          }
          __name(ae, "ae");
          function Ae(S2) {
            return !oe(S2) && S2 !== "inline-block";
          }
          __name(Ae, "Ae");
          function z(S2) {
            return !oe(S2);
          }
          __name(z, "z");
          function H(S2) {
            return !oe(S2);
          }
          __name(H, "H");
          function Z(S2) {
            return !oe(S2) && S2 !== "inline-block";
          }
          __name(Z, "Z");
          function ne(S2) {
            return _e(S2).startsWith("pre");
          }
          __name(ne, "ne");
          function fe(S2, G) {
            let te = 0;
            for (let Ee = S2.stack.length - 1; Ee >= 0; Ee--) {
              let Re = S2.stack[Ee];
              Re && typeof Re == "object" && !Array.isArray(Re) && G(Re) && te++;
            }
            return te;
          }
          __name(fe, "fe");
          function ge(S2, G) {
            let te = S2;
            for (; te; ) {
              if (G(te))
                return true;
              te = te.parent;
            }
            return false;
          }
          __name(ge, "ge");
          function Ce(S2, G) {
            if (S2.prev && S2.prev.type === "comment") {
              let Ee = S2.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
              if (Ee)
                return Ee[1];
            }
            let te = false;
            if (S2.type === "element" && S2.namespace === "svg")
              if (ge(S2, (Ee) => Ee.fullName === "svg:foreignObject"))
                te = true;
              else
                return S2.name === "svg" ? "inline-block" : "block";
            switch (G.htmlWhitespaceSensitivity) {
              case "strict":
                return "inline";
              case "ignore":
                return "block";
              default:
                return G.parser === "vue" && S2.parent && S2.parent.type === "root" ? "block" : S2.type === "element" && (!S2.namespace || te || p2(S2)) && c2[S2.name] || y2;
            }
          }
          __name(Ce, "Ce");
          function _e(S2) {
            return S2.type === "element" && (!S2.namespace || p2(S2)) && h3[S2.name] || g2;
          }
          __name(_e, "_e");
          function Oe(S2) {
            let G = Number.POSITIVE_INFINITY;
            for (let te of S2.split(`
`)) {
              if (te.length === 0)
                continue;
              if (!D.has(te[0]))
                return 0;
              let Ee = I(te).length;
              te.length !== Ee && Ee < G && (G = Ee);
            }
            return G === Number.POSITIVE_INFINITY ? 0 : G;
          }
          __name(Oe, "Oe");
          function pe(S2) {
            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Oe(S2);
            return G === 0 ? S2 : S2.split(`
`).map((te) => te.slice(G)).join(`
`);
          }
          __name(pe, "pe");
          function ie(S2, G) {
            let te = 0;
            for (let Ee = 0; Ee < S2.length; Ee++)
              S2[Ee] === G && te++;
            return te;
          }
          __name(ie, "ie");
          function ve(S2) {
            return S2.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
          }
          __name(ve, "ve");
          var ce = /* @__PURE__ */ new Set(["template", "style", "script"]);
          function U2(S2, G) {
            return de(S2, G) && !ce.has(S2.fullName);
          }
          __name(U2, "U");
          function de(S2, G) {
            return G.parser === "vue" && S2.type === "element" && S2.parent.type === "root" && S2.fullName.toLowerCase() !== "html";
          }
          __name(de, "de");
          function De(S2, G) {
            return de(S2, G) && (U2(S2, G) || S2.attrMap.lang && S2.attrMap.lang !== "html");
          }
          __name(De, "De");
          function he(S2) {
            let G = S2.fullName;
            return G.charAt(0) === "#" || G === "slot-scope" || G === "v-slot" || G.startsWith("v-slot:");
          }
          __name(he, "he");
          function Be(S2, G) {
            let te = S2.parent;
            if (!de(te, G))
              return false;
            let Ee = te.fullName, Re = S2.fullName;
            return Ee === "script" && Re === "setup" || Ee === "style" && Re === "vars";
          }
          __name(Be, "Be");
          function Se(S2) {
            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : S2.value;
            return S2.parent.isWhitespaceSensitive ? S2.parent.isIndentationSensitive ? l2(G) : l2(pe(A2(G)), r2) : i2(u2(a2, B(G)));
          }
          __name(Se, "Se");
          function ye(S2, G) {
            return de(S2, G) && S2.name === "script";
          }
          __name(ye, "ye");
          n2.exports = { htmlTrim: T2, htmlTrimPreserveIndentation: A2, hasHtmlWhitespace: R2, getLeadingAndTrailingHtmlWhitespace: P2, canHaveInterpolation: d2, countChars: ie, countParents: fe, dedentString: pe, forceBreakChildren: q, forceBreakContent: M2, forceNextEmptyLine: $, getLastDescendant: se, getNodeCssStyleDisplay: Ce, getNodeCssStyleWhiteSpace: _e, hasPrettierIgnore: x2, inferScriptParser: X, isVueCustomBlock: U2, isVueNonHtmlBlock: De, isVueScriptTag: ye, isVueSlotAttribute: he, isVueSfcBindingsAttribute: Be, isVueSfcBlock: de, isDanglingSpaceSensitiveNode: k2, isIndentationSensitiveNode: _2, isLeadingSpaceSensitiveNode: b2, isPreLikeNode: ne, isScriptLikeTag: o2, isTextLikeNode: E2, isTrailingSpaceSensitiveNode: N2, isWhitespaceSensitiveNode: C2, isUnknownNamespace: p2, preferHardlineAsLeadingSpaces: J, preferHardlineAsTrailingSpaces: L2, shouldPreserveContent: f2, unescapeQuoteEntities: ve, getTextValueParts: Se };
        } }), Ud = ee({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true }), e2.$EOF = 0, e2.$BSPACE = 8, e2.$TAB = 9, e2.$LF = 10, e2.$VTAB = 11, e2.$FF = 12, e2.$CR = 13, e2.$SPACE = 32, e2.$BANG = 33, e2.$DQ = 34, e2.$HASH = 35, e2.$$ = 36, e2.$PERCENT = 37, e2.$AMPERSAND = 38, e2.$SQ = 39, e2.$LPAREN = 40, e2.$RPAREN = 41, e2.$STAR = 42, e2.$PLUS = 43, e2.$COMMA = 44, e2.$MINUS = 45, e2.$PERIOD = 46, e2.$SLASH = 47, e2.$COLON = 58, e2.$SEMICOLON = 59, e2.$LT = 60, e2.$EQ = 61, e2.$GT = 62, e2.$QUESTION = 63, e2.$0 = 48, e2.$7 = 55, e2.$9 = 57, e2.$A = 65, e2.$E = 69, e2.$F = 70, e2.$X = 88, e2.$Z = 90, e2.$LBRACKET = 91, e2.$BACKSLASH = 92, e2.$RBRACKET = 93, e2.$CARET = 94, e2.$_ = 95, e2.$a = 97, e2.$b = 98, e2.$e = 101, e2.$f = 102, e2.$n = 110, e2.$r = 114, e2.$t = 116, e2.$u = 117, e2.$v = 118, e2.$x = 120, e2.$z = 122, e2.$LBRACE = 123, e2.$BAR = 124, e2.$RBRACE = 125, e2.$NBSP = 160, e2.$PIPE = 124, e2.$TILDA = 126, e2.$AT = 64, e2.$BT = 96;
          function n2(i2) {
            return i2 >= e2.$TAB && i2 <= e2.$SPACE || i2 == e2.$NBSP;
          }
          __name(n2, "n");
          e2.isWhitespace = n2;
          function t2(i2) {
            return e2.$0 <= i2 && i2 <= e2.$9;
          }
          __name(t2, "t");
          e2.isDigit = t2;
          function s2(i2) {
            return i2 >= e2.$a && i2 <= e2.$z || i2 >= e2.$A && i2 <= e2.$Z;
          }
          __name(s2, "s");
          e2.isAsciiLetter = s2;
          function a2(i2) {
            return i2 >= e2.$a && i2 <= e2.$f || i2 >= e2.$A && i2 <= e2.$F || t2(i2);
          }
          __name(a2, "a");
          e2.isAsciiHexDigit = a2;
          function r2(i2) {
            return i2 === e2.$LF || i2 === e2.$CR;
          }
          __name(r2, "r");
          e2.isNewLine = r2;
          function u2(i2) {
            return e2.$0 <= i2 && i2 <= e2.$7;
          }
          __name(u2, "u");
          e2.isOctalDigit = u2;
        } }), Jd = ee({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = /* @__PURE__ */ __name(class {
            constructor(s2, a2, r2) {
              this.filePath = s2, this.name = a2, this.members = r2;
            }
            assertNoMembers() {
              if (this.members.length)
                throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
            }
          }, "n");
          e2.StaticSymbol = n2;
          var t2 = /* @__PURE__ */ __name(class {
            constructor() {
              this.cache = /* @__PURE__ */ new Map();
            }
            get(s2, a2, r2) {
              r2 = r2 || [];
              let u2 = r2.length ? `.${r2.join(".")}` : "", i2 = `"${s2}".${a2}${u2}`, l2 = this.cache.get(i2);
              return l2 || (l2 = new n2(s2, a2, r2), this.cache.set(i2, l2)), l2;
            }
          }, "t");
          e2.StaticSymbolCache = t2;
        } }), zd = ee({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = /-+([a-z0-9])/g;
          function t2(o2) {
            return o2.replace(n2, function() {
              for (var d2 = arguments.length, C2 = new Array(d2), _2 = 0; _2 < d2; _2++)
                C2[_2] = arguments[_2];
              return C2[1].toUpperCase();
            });
          }
          __name(t2, "t");
          e2.dashCaseToCamelCase = t2;
          function s2(o2, d2) {
            return r2(o2, ":", d2);
          }
          __name(s2, "s");
          e2.splitAtColon = s2;
          function a2(o2, d2) {
            return r2(o2, ".", d2);
          }
          __name(a2, "a");
          e2.splitAtPeriod = a2;
          function r2(o2, d2, C2) {
            let _2 = o2.indexOf(d2);
            return _2 == -1 ? C2 : [o2.slice(0, _2).trim(), o2.slice(_2 + 1).trim()];
          }
          __name(r2, "r");
          function u2(o2, d2, C2) {
            return Array.isArray(o2) ? d2.visitArray(o2, C2) : F(o2) ? d2.visitStringMap(o2, C2) : o2 == null || typeof o2 == "string" || typeof o2 == "number" || typeof o2 == "boolean" ? d2.visitPrimitive(o2, C2) : d2.visitOther(o2, C2);
          }
          __name(u2, "u");
          e2.visitValue = u2;
          function i2(o2) {
            return o2 != null;
          }
          __name(i2, "i");
          e2.isDefined = i2;
          function l2(o2) {
            return o2 === void 0 ? null : o2;
          }
          __name(l2, "l");
          e2.noUndefined = l2;
          var c2 = /* @__PURE__ */ __name(class {
            visitArray(o2, d2) {
              return o2.map((C2) => u2(C2, this, d2));
            }
            visitStringMap(o2, d2) {
              let C2 = {};
              return Object.keys(o2).forEach((_2) => {
                C2[_2] = u2(o2[_2], this, d2);
              }), C2;
            }
            visitPrimitive(o2, d2) {
              return o2;
            }
            visitOther(o2, d2) {
              return o2;
            }
          }, "c");
          e2.ValueTransformer = c2, e2.SyncAsync = { assertSync: (o2) => {
            if (P2(o2))
              throw new Error("Illegal state: value cannot be a promise");
            return o2;
          }, then: (o2, d2) => P2(o2) ? o2.then(d2) : d2(o2), all: (o2) => o2.some(P2) ? Promise.all(o2) : o2 };
          function y2(o2) {
            throw new Error(`Internal Error: ${o2}`);
          }
          __name(y2, "y");
          e2.error = y2;
          function h3(o2, d2) {
            let C2 = Error(o2);
            return C2[g2] = true, d2 && (C2[p2] = d2), C2;
          }
          __name(h3, "h");
          e2.syntaxError = h3;
          var g2 = "ngSyntaxError", p2 = "ngParseErrors";
          function D(o2) {
            return o2[g2];
          }
          __name(D, "D");
          e2.isSyntaxError = D;
          function v2(o2) {
            return o2[p2] || [];
          }
          __name(v2, "v");
          e2.getParseErrors = v2;
          function w2(o2) {
            return o2.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          __name(w2, "w");
          e2.escapeRegExp = w2;
          var T2 = Object.getPrototypeOf({});
          function F(o2) {
            return typeof o2 == "object" && o2 !== null && Object.getPrototypeOf(o2) === T2;
          }
          __name(F, "F");
          function A2(o2) {
            let d2 = "";
            for (let C2 = 0; C2 < o2.length; C2++) {
              let _2 = o2.charCodeAt(C2);
              if (_2 >= 55296 && _2 <= 56319 && o2.length > C2 + 1) {
                let b2 = o2.charCodeAt(C2 + 1);
                b2 >= 56320 && b2 <= 57343 && (C2++, _2 = (_2 - 55296 << 10) + b2 - 56320 + 65536);
              }
              _2 <= 127 ? d2 += String.fromCharCode(_2) : _2 <= 2047 ? d2 += String.fromCharCode(_2 >> 6 & 31 | 192, _2 & 63 | 128) : _2 <= 65535 ? d2 += String.fromCharCode(_2 >> 12 | 224, _2 >> 6 & 63 | 128, _2 & 63 | 128) : _2 <= 2097151 && (d2 += String.fromCharCode(_2 >> 18 & 7 | 240, _2 >> 12 & 63 | 128, _2 >> 6 & 63 | 128, _2 & 63 | 128));
            }
            return d2;
          }
          __name(A2, "A");
          e2.utf8Encode = A2;
          function B(o2) {
            if (typeof o2 == "string")
              return o2;
            if (o2 instanceof Array)
              return "[" + o2.map(B).join(", ") + "]";
            if (o2 == null)
              return "" + o2;
            if (o2.overriddenName)
              return `${o2.overriddenName}`;
            if (o2.name)
              return `${o2.name}`;
            if (!o2.toString)
              return "object";
            let d2 = o2.toString();
            if (d2 == null)
              return "" + d2;
            let C2 = d2.indexOf(`
`);
            return C2 === -1 ? d2 : d2.substring(0, C2);
          }
          __name(B, "B");
          e2.stringify = B;
          function I(o2) {
            return typeof o2 == "function" && o2.hasOwnProperty("__forward_ref__") ? o2() : o2;
          }
          __name(I, "I");
          e2.resolveForwardRef = I;
          function P2(o2) {
            return !!o2 && typeof o2.then == "function";
          }
          __name(P2, "P");
          e2.isPromise = P2;
          var R2 = /* @__PURE__ */ __name(class {
            constructor(o2) {
              this.full = o2;
              let d2 = o2.split(".");
              this.major = d2[0], this.minor = d2[1], this.patch = d2.slice(2).join(".");
            }
          }, "R");
          e2.Version = R2;
          var f2 = typeof window < "u" && window, x2 = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m2 = typeof globalThis < "u" && globalThis, E2 = m2 || f2 || x2;
          e2.global = E2;
        } }), Xd = ee({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Jd(), t2 = zd(), s2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function a2(C2) {
            return C2.replace(/\W/g, "_");
          }
          __name(a2, "a");
          e2.sanitizeIdentifier = a2;
          var r2 = 0;
          function u2(C2) {
            if (!C2 || !C2.reference)
              return null;
            let _2 = C2.reference;
            if (_2 instanceof n2.StaticSymbol)
              return _2.name;
            if (_2.__anonymousType)
              return _2.__anonymousType;
            let b2 = t2.stringify(_2);
            return b2.indexOf("(") >= 0 ? (b2 = `anonymous_${r2++}`, _2.__anonymousType = b2) : b2 = a2(b2), b2;
          }
          __name(u2, "u");
          e2.identifierName = u2;
          function i2(C2) {
            let _2 = C2.reference;
            return _2 instanceof n2.StaticSymbol ? _2.filePath : `./${t2.stringify(_2)}`;
          }
          __name(i2, "i");
          e2.identifierModuleUrl = i2;
          function l2(C2, _2) {
            return `View_${u2({ reference: C2 })}_${_2}`;
          }
          __name(l2, "l");
          e2.viewClassName = l2;
          function c2(C2) {
            return `RenderType_${u2({ reference: C2 })}`;
          }
          __name(c2, "c");
          e2.rendererTypeName = c2;
          function y2(C2) {
            return `HostView_${u2({ reference: C2 })}`;
          }
          __name(y2, "y");
          e2.hostViewClassName = y2;
          function h3(C2) {
            return `${u2({ reference: C2 })}NgFactory`;
          }
          __name(h3, "h");
          e2.componentFactoryName = h3;
          var g2;
          (function(C2) {
            C2[C2.Pipe = 0] = "Pipe", C2[C2.Directive = 1] = "Directive", C2[C2.NgModule = 2] = "NgModule", C2[C2.Injectable = 3] = "Injectable";
          })(g2 = e2.CompileSummaryKind || (e2.CompileSummaryKind = {}));
          function p2(C2) {
            return C2.value != null ? a2(C2.value) : u2(C2.identifier);
          }
          __name(p2, "p");
          e2.tokenName = p2;
          function D(C2) {
            return C2.identifier != null ? C2.identifier.reference : C2.value;
          }
          __name(D, "D");
          e2.tokenReference = D;
          var v2 = /* @__PURE__ */ __name(class {
            constructor() {
              let { moduleUrl: C2, styles: _2, styleUrls: b2 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.moduleUrl = C2 || null, this.styles = P2(_2), this.styleUrls = P2(b2);
            }
          }, "v");
          e2.CompileStylesheetMetadata = v2;
          var w2 = /* @__PURE__ */ __name(class {
            constructor(C2) {
              let { encapsulation: _2, template: b2, templateUrl: N2, htmlAst: k2, styles: $, styleUrls: M2, externalStylesheets: q, animations: J, ngContentSelectors: L2, interpolation: Y, isInline: V, preserveWhitespaces: O2 } = C2;
              if (this.encapsulation = _2, this.template = b2, this.templateUrl = N2, this.htmlAst = k2, this.styles = P2($), this.styleUrls = P2(M2), this.externalStylesheets = P2(q), this.animations = J ? f2(J) : [], this.ngContentSelectors = L2 || [], Y && Y.length != 2)
                throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = Y, this.isInline = V, this.preserveWhitespaces = O2;
            }
            toSummary() {
              return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
            }
          }, "w");
          e2.CompileTemplateMetadata = w2;
          var T2 = /* @__PURE__ */ __name(class {
            static create(C2) {
              let { isHost: _2, type: b2, isComponent: N2, selector: k2, exportAs: $, changeDetection: M2, inputs: q, outputs: J, host: L2, providers: Y, viewProviders: V, queries: O2, guards: K, viewQueries: se, entryComponents: Q, template: le, componentViewType: W2, rendererType: X, componentFactory: oe } = C2, ae = {}, Ae = {}, z = {};
              L2 != null && Object.keys(L2).forEach((ne) => {
                let fe = L2[ne], ge = ne.match(s2);
                ge === null ? z[ne] = fe : ge[1] != null ? Ae[ge[1]] = fe : ge[2] != null && (ae[ge[2]] = fe);
              });
              let H = {};
              q != null && q.forEach((ne) => {
                let fe = t2.splitAtColon(ne, [ne, ne]);
                H[fe[0]] = fe[1];
              });
              let Z = {};
              return J != null && J.forEach((ne) => {
                let fe = t2.splitAtColon(ne, [ne, ne]);
                Z[fe[0]] = fe[1];
              }), new T2({ isHost: _2, type: b2, isComponent: !!N2, selector: k2, exportAs: $, changeDetection: M2, inputs: H, outputs: Z, hostListeners: ae, hostProperties: Ae, hostAttributes: z, providers: Y, viewProviders: V, queries: O2, guards: K, viewQueries: se, entryComponents: Q, template: le, componentViewType: W2, rendererType: X, componentFactory: oe });
            }
            constructor(C2) {
              let { isHost: _2, type: b2, isComponent: N2, selector: k2, exportAs: $, changeDetection: M2, inputs: q, outputs: J, hostListeners: L2, hostProperties: Y, hostAttributes: V, providers: O2, viewProviders: K, queries: se, guards: Q, viewQueries: le, entryComponents: W2, template: X, componentViewType: oe, rendererType: ae, componentFactory: Ae } = C2;
              this.isHost = !!_2, this.type = b2, this.isComponent = N2, this.selector = k2, this.exportAs = $, this.changeDetection = M2, this.inputs = q, this.outputs = J, this.hostListeners = L2, this.hostProperties = Y, this.hostAttributes = V, this.providers = P2(O2), this.viewProviders = P2(K), this.queries = P2(se), this.guards = Q, this.viewQueries = P2(le), this.entryComponents = P2(W2), this.template = X, this.componentViewType = oe, this.rendererType = ae, this.componentFactory = Ae;
            }
            toSummary() {
              return { summaryKind: g2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
            }
          }, "T");
          e2.CompileDirectiveMetadata = T2;
          var F = /* @__PURE__ */ __name(class {
            constructor(C2) {
              let { type: _2, name: b2, pure: N2 } = C2;
              this.type = _2, this.name = b2, this.pure = !!N2;
            }
            toSummary() {
              return { summaryKind: g2.Pipe, type: this.type, name: this.name, pure: this.pure };
            }
          }, "F");
          e2.CompilePipeMetadata = F;
          var A2 = /* @__PURE__ */ __name(class {
          }, "A");
          e2.CompileShallowModuleMetadata = A2;
          var B = /* @__PURE__ */ __name(class {
            constructor(C2) {
              let { type: _2, providers: b2, declaredDirectives: N2, exportedDirectives: k2, declaredPipes: $, exportedPipes: M2, entryComponents: q, bootstrapComponents: J, importedModules: L2, exportedModules: Y, schemas: V, transitiveModule: O2, id: K } = C2;
              this.type = _2 || null, this.declaredDirectives = P2(N2), this.exportedDirectives = P2(k2), this.declaredPipes = P2($), this.exportedPipes = P2(M2), this.providers = P2(b2), this.entryComponents = P2(q), this.bootstrapComponents = P2(J), this.importedModules = P2(L2), this.exportedModules = P2(Y), this.schemas = P2(V), this.id = K || null, this.transitiveModule = O2 || null;
            }
            toSummary() {
              let C2 = this.transitiveModule;
              return { summaryKind: g2.NgModule, type: this.type, entryComponents: C2.entryComponents, providers: C2.providers, modules: C2.modules, exportedDirectives: C2.exportedDirectives, exportedPipes: C2.exportedPipes };
            }
          }, "B");
          e2.CompileNgModuleMetadata = B;
          var I = /* @__PURE__ */ __name(class {
            constructor() {
              this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
            }
            addProvider(C2, _2) {
              this.providers.push({ provider: C2, module: _2 });
            }
            addDirective(C2) {
              this.directivesSet.has(C2.reference) || (this.directivesSet.add(C2.reference), this.directives.push(C2));
            }
            addExportedDirective(C2) {
              this.exportedDirectivesSet.has(C2.reference) || (this.exportedDirectivesSet.add(C2.reference), this.exportedDirectives.push(C2));
            }
            addPipe(C2) {
              this.pipesSet.has(C2.reference) || (this.pipesSet.add(C2.reference), this.pipes.push(C2));
            }
            addExportedPipe(C2) {
              this.exportedPipesSet.has(C2.reference) || (this.exportedPipesSet.add(C2.reference), this.exportedPipes.push(C2));
            }
            addModule(C2) {
              this.modulesSet.has(C2.reference) || (this.modulesSet.add(C2.reference), this.modules.push(C2));
            }
            addEntryComponent(C2) {
              this.entryComponentsSet.has(C2.componentType) || (this.entryComponentsSet.add(C2.componentType), this.entryComponents.push(C2));
            }
          }, "I");
          e2.TransitiveCompileNgModuleMetadata = I;
          function P2(C2) {
            return C2 || [];
          }
          __name(P2, "P");
          var R2 = /* @__PURE__ */ __name(class {
            constructor(C2, _2) {
              let { useClass: b2, useValue: N2, useExisting: k2, useFactory: $, deps: M2, multi: q } = _2;
              this.token = C2, this.useClass = b2 || null, this.useValue = N2, this.useExisting = k2, this.useFactory = $ || null, this.dependencies = M2 || null, this.multi = !!q;
            }
          }, "R");
          e2.ProviderMeta = R2;
          function f2(C2) {
            return C2.reduce((_2, b2) => {
              let N2 = Array.isArray(b2) ? f2(b2) : b2;
              return _2.concat(N2);
            }, []);
          }
          __name(f2, "f");
          e2.flatten = f2;
          function x2(C2) {
            return C2.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          __name(x2, "x");
          function m2(C2, _2, b2) {
            let N2;
            return b2.isInline ? _2.type.reference instanceof n2.StaticSymbol ? N2 = `${_2.type.reference.filePath}.${_2.type.reference.name}.html` : N2 = `${u2(C2)}/${u2(_2.type)}.html` : N2 = b2.templateUrl, _2.type.reference instanceof n2.StaticSymbol ? N2 : x2(N2);
          }
          __name(m2, "m");
          e2.templateSourceUrl = m2;
          function E2(C2, _2) {
            let b2 = C2.moduleUrl.split(/\/\\/g), N2 = b2[b2.length - 1];
            return x2(`css/${_2}${N2}.ngstyle.js`);
          }
          __name(E2, "E");
          e2.sharedStylesheetJitUrl = E2;
          function o2(C2) {
            return x2(`${u2(C2.type)}/module.ngfactory.js`);
          }
          __name(o2, "o");
          e2.ngModuleJitUrl = o2;
          function d2(C2, _2) {
            return x2(`${u2(C2)}/${u2(_2.type)}.ngfactory.js`);
          }
          __name(d2, "d");
          e2.templateJitUrl = d2;
        } }), Kd = ee({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e2) {
          "use strict";
          re(), Object.defineProperty(e2, "__esModule", { value: true });
          var n2 = Ud(), t2 = Xd(), s2 = /* @__PURE__ */ __name(class {
            constructor(y2, h3, g2, p2) {
              this.file = y2, this.offset = h3, this.line = g2, this.col = p2;
            }
            toString() {
              return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
            }
            moveBy(y2) {
              let h3 = this.file.content, g2 = h3.length, p2 = this.offset, D = this.line, v2 = this.col;
              for (; p2 > 0 && y2 < 0; )
                if (p2--, y2++, h3.charCodeAt(p2) == n2.$LF) {
                  D--;
                  let T2 = h3.substr(0, p2 - 1).lastIndexOf(String.fromCharCode(n2.$LF));
                  v2 = T2 > 0 ? p2 - T2 : p2;
                } else
                  v2--;
              for (; p2 < g2 && y2 > 0; ) {
                let w2 = h3.charCodeAt(p2);
                p2++, y2--, w2 == n2.$LF ? (D++, v2 = 0) : v2++;
              }
              return new s2(this.file, p2, D, v2);
            }
            getContext(y2, h3) {
              let g2 = this.file.content, p2 = this.offset;
              if (p2 != null) {
                p2 > g2.length - 1 && (p2 = g2.length - 1);
                let D = p2, v2 = 0, w2 = 0;
                for (; v2 < y2 && p2 > 0 && (p2--, v2++, !(g2[p2] == `
` && ++w2 == h3)); )
                  ;
                for (v2 = 0, w2 = 0; v2 < y2 && D < g2.length - 1 && (D++, v2++, !(g2[D] == `
` && ++w2 == h3)); )
                  ;
                return { before: g2.substring(p2, this.offset), after: g2.substring(this.offset, D + 1) };
              }
              return null;
            }
          }, "s");
          e2.ParseLocation = s2;
          var a2 = /* @__PURE__ */ __name(class {
            constructor(y2, h3) {
              this.content = y2, this.url = h3;
            }
          }, "a");
          e2.ParseSourceFile = a2;
          var r2 = /* @__PURE__ */ __name(class {
            constructor(y2, h3) {
              let g2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = y2, this.end = h3, this.details = g2;
            }
            toString() {
              return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
          }, "r");
          e2.ParseSourceSpan = r2, e2.EMPTY_PARSE_LOCATION = new s2(new a2("", ""), 0, 0, 0), e2.EMPTY_SOURCE_SPAN = new r2(e2.EMPTY_PARSE_LOCATION, e2.EMPTY_PARSE_LOCATION);
          var u2;
          (function(y2) {
            y2[y2.WARNING = 0] = "WARNING", y2[y2.ERROR = 1] = "ERROR";
          })(u2 = e2.ParseErrorLevel || (e2.ParseErrorLevel = {}));
          var i2 = /* @__PURE__ */ __name(class {
            constructor(y2, h3) {
              let g2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u2.ERROR;
              this.span = y2, this.msg = h3, this.level = g2;
            }
            contextualMessage() {
              let y2 = this.span.start.getContext(100, 3);
              return y2 ? `${this.msg} ("${y2.before}[${u2[this.level]} ->]${y2.after}")` : this.msg;
            }
            toString() {
              let y2 = this.span.details ? `, ${this.span.details}` : "";
              return `${this.contextualMessage()}: ${this.span.start}${y2}`;
            }
          }, "i");
          e2.ParseError = i2;
          function l2(y2, h3) {
            let g2 = t2.identifierModuleUrl(h3), p2 = g2 != null ? `in ${y2} ${t2.identifierName(h3)} in ${g2}` : `in ${y2} ${t2.identifierName(h3)}`, D = new a2("", p2);
            return new r2(new s2(D, -1, -1, -1), new s2(D, -1, -1, -1));
          }
          __name(l2, "l");
          e2.typeSourceSpan = l2;
          function c2(y2, h3, g2) {
            let p2 = `in ${y2} ${h3} in ${g2}`, D = new a2("", p2);
            return new r2(new s2(D, -1, -1, -1), new s2(D, -1, -1, -1));
          }
          __name(c2, "c");
          e2.r3JitTypeSourceSpan = c2;
        } }), Yd = ee({ "src/language-html/print-preprocess.js"(e2, n2) {
          "use strict";
          re();
          var { ParseSourceSpan: t2 } = Kd(), { htmlTrim: s2, getLeadingAndTrailingHtmlWhitespace: a2, hasHtmlWhitespace: r2, canHaveInterpolation: u2, getNodeCssStyleDisplay: i2, isDanglingSpaceSensitiveNode: l2, isIndentationSensitiveNode: c2, isLeadingSpaceSensitiveNode: y2, isTrailingSpaceSensitiveNode: h3, isWhitespaceSensitiveNode: g2, isVueScriptTag: p2 } = Mt(), D = [w2, T2, A2, I, P2, x2, R2, f2, m2, B, E2];
          function v2(o2, d2) {
            for (let C2 of D)
              C2(o2, d2);
            return o2;
          }
          __name(v2, "v");
          function w2(o2) {
            o2.walk((d2) => {
              if (d2.type === "element" && d2.tagDefinition.ignoreFirstLf && d2.children.length > 0 && d2.children[0].type === "text" && d2.children[0].value[0] === `
`) {
                let C2 = d2.children[0];
                C2.value.length === 1 ? d2.removeChild(C2) : C2.value = C2.value.slice(1);
              }
            });
          }
          __name(w2, "w");
          function T2(o2) {
            let d2 = /* @__PURE__ */ __name((C2) => C2.type === "element" && C2.prev && C2.prev.type === "ieConditionalStartComment" && C2.prev.sourceSpan.end.offset === C2.startSourceSpan.start.offset && C2.firstChild && C2.firstChild.type === "ieConditionalEndComment" && C2.firstChild.sourceSpan.start.offset === C2.startSourceSpan.end.offset, "d");
            o2.walk((C2) => {
              if (C2.children)
                for (let _2 = 0; _2 < C2.children.length; _2++) {
                  let b2 = C2.children[_2];
                  if (!d2(b2))
                    continue;
                  let N2 = b2.prev, k2 = b2.firstChild;
                  C2.removeChild(N2), _2--;
                  let $ = new t2(N2.sourceSpan.start, k2.sourceSpan.end), M2 = new t2($.start, b2.sourceSpan.end);
                  b2.condition = N2.condition, b2.sourceSpan = M2, b2.startSourceSpan = $, b2.removeChild(k2);
                }
            });
          }
          __name(T2, "T");
          function F(o2, d2, C2) {
            o2.walk((_2) => {
              if (_2.children)
                for (let b2 = 0; b2 < _2.children.length; b2++) {
                  let N2 = _2.children[b2];
                  if (N2.type !== "text" && !d2(N2))
                    continue;
                  N2.type !== "text" && (N2.type = "text", N2.value = C2(N2));
                  let k2 = N2.prev;
                  !k2 || k2.type !== "text" || (k2.value += N2.value, k2.sourceSpan = new t2(k2.sourceSpan.start, N2.sourceSpan.end), _2.removeChild(N2), b2--);
                }
            });
          }
          __name(F, "F");
          function A2(o2) {
            return F(o2, (d2) => d2.type === "cdata", (d2) => `<![CDATA[${d2.value}]]>`);
          }
          __name(A2, "A");
          function B(o2) {
            let d2 = /* @__PURE__ */ __name((C2) => C2.type === "element" && C2.attrs.length === 0 && C2.children.length === 1 && C2.firstChild.type === "text" && !r2(C2.children[0].value) && !C2.firstChild.hasLeadingSpaces && !C2.firstChild.hasTrailingSpaces && C2.isLeadingSpaceSensitive && !C2.hasLeadingSpaces && C2.isTrailingSpaceSensitive && !C2.hasTrailingSpaces && C2.prev && C2.prev.type === "text" && C2.next && C2.next.type === "text", "d");
            o2.walk((C2) => {
              if (C2.children)
                for (let _2 = 0; _2 < C2.children.length; _2++) {
                  let b2 = C2.children[_2];
                  if (!d2(b2))
                    continue;
                  let N2 = b2.prev, k2 = b2.next;
                  N2.value += `<${b2.rawName}>` + b2.firstChild.value + `</${b2.rawName}>` + k2.value, N2.sourceSpan = new t2(N2.sourceSpan.start, k2.sourceSpan.end), N2.isTrailingSpaceSensitive = k2.isTrailingSpaceSensitive, N2.hasTrailingSpaces = k2.hasTrailingSpaces, C2.removeChild(b2), _2--, C2.removeChild(k2);
                }
            });
          }
          __name(B, "B");
          function I(o2, d2) {
            if (d2.parser === "html")
              return;
            let C2 = /{{(.+?)}}/s;
            o2.walk((_2) => {
              if (!!u2(_2))
                for (let b2 of _2.children) {
                  if (b2.type !== "text")
                    continue;
                  let N2 = b2.sourceSpan.start, k2 = null, $ = b2.value.split(C2);
                  for (let M2 = 0; M2 < $.length; M2++, N2 = k2) {
                    let q = $[M2];
                    if (M2 % 2 === 0) {
                      k2 = N2.moveBy(q.length), q.length > 0 && _2.insertChildBefore(b2, { type: "text", value: q, sourceSpan: new t2(N2, k2) });
                      continue;
                    }
                    k2 = N2.moveBy(q.length + 4), _2.insertChildBefore(b2, { type: "interpolation", sourceSpan: new t2(N2, k2), children: q.length === 0 ? [] : [{ type: "text", value: q, sourceSpan: new t2(N2.moveBy(2), k2.moveBy(-2)) }] });
                  }
                  _2.removeChild(b2);
                }
            });
          }
          __name(I, "I");
          function P2(o2) {
            o2.walk((d2) => {
              if (!d2.children)
                return;
              if (d2.children.length === 0 || d2.children.length === 1 && d2.children[0].type === "text" && s2(d2.children[0].value).length === 0) {
                d2.hasDanglingSpaces = d2.children.length > 0, d2.children = [];
                return;
              }
              let C2 = g2(d2), _2 = c2(d2);
              if (!C2)
                for (let b2 = 0; b2 < d2.children.length; b2++) {
                  let N2 = d2.children[b2];
                  if (N2.type !== "text")
                    continue;
                  let { leadingWhitespace: k2, text: $, trailingWhitespace: M2 } = a2(N2.value), q = N2.prev, J = N2.next;
                  $ ? (N2.value = $, N2.sourceSpan = new t2(N2.sourceSpan.start.moveBy(k2.length), N2.sourceSpan.end.moveBy(-M2.length)), k2 && (q && (q.hasTrailingSpaces = true), N2.hasLeadingSpaces = true), M2 && (N2.hasTrailingSpaces = true, J && (J.hasLeadingSpaces = true))) : (d2.removeChild(N2), b2--, (k2 || M2) && (q && (q.hasTrailingSpaces = true), J && (J.hasLeadingSpaces = true)));
                }
              d2.isWhitespaceSensitive = C2, d2.isIndentationSensitive = _2;
            });
          }
          __name(P2, "P");
          function R2(o2) {
            o2.walk((d2) => {
              d2.isSelfClosing = !d2.children || d2.type === "element" && (d2.tagDefinition.isVoid || d2.startSourceSpan === d2.endSourceSpan);
            });
          }
          __name(R2, "R");
          function f2(o2, d2) {
            o2.walk((C2) => {
              C2.type === "element" && (C2.hasHtmComponentClosingTag = C2.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(d2.originalText.slice(C2.endSourceSpan.start.offset, C2.endSourceSpan.end.offset)));
            });
          }
          __name(f2, "f");
          function x2(o2, d2) {
            o2.walk((C2) => {
              C2.cssDisplay = i2(C2, d2);
            });
          }
          __name(x2, "x");
          function m2(o2, d2) {
            o2.walk((C2) => {
              let { children: _2 } = C2;
              if (!!_2) {
                if (_2.length === 0) {
                  C2.isDanglingSpaceSensitive = l2(C2);
                  return;
                }
                for (let b2 of _2)
                  b2.isLeadingSpaceSensitive = y2(b2, d2), b2.isTrailingSpaceSensitive = h3(b2, d2);
                for (let b2 = 0; b2 < _2.length; b2++) {
                  let N2 = _2[b2];
                  N2.isLeadingSpaceSensitive = (b2 === 0 || N2.prev.isTrailingSpaceSensitive) && N2.isLeadingSpaceSensitive, N2.isTrailingSpaceSensitive = (b2 === _2.length - 1 || N2.next.isLeadingSpaceSensitive) && N2.isTrailingSpaceSensitive;
                }
              }
            });
          }
          __name(m2, "m");
          function E2(o2, d2) {
            if (d2.parser === "vue") {
              let C2 = o2.children.find((b2) => p2(b2, d2));
              if (!C2)
                return;
              let { lang: _2 } = C2.attrMap;
              (_2 === "ts" || _2 === "typescript") && (d2.__should_parse_vue_template_with_ts = true);
            }
          }
          __name(E2, "E");
          n2.exports = v2;
        } }), Qd = ee({ "src/language-html/pragma.js"(e2, n2) {
          "use strict";
          re();
          function t2(a2) {
            return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a2);
          }
          __name(t2, "t");
          function s2(a2) {
            return `<!-- @format -->

` + a2.replace(/^\s*\n/, "");
          }
          __name(s2, "s");
          n2.exports = { hasPragma: t2, insertPragma: s2 };
        } }), Qn = ee({ "src/language-html/loc.js"(e2, n2) {
          "use strict";
          re();
          function t2(a2) {
            return a2.sourceSpan.start.offset;
          }
          __name(t2, "t");
          function s2(a2) {
            return a2.sourceSpan.end.offset;
          }
          __name(s2, "s");
          n2.exports = { locStart: t2, locEnd: s2 };
        } }), rr = ee({ "src/language-html/print/tag.js"(e2, n2) {
          "use strict";
          re();
          var t2 = Yt(), { isNonEmptyArray: s2 } = Ge(), { builders: { indent: a2, join: r2, line: u2, softline: i2, hardline: l2 }, utils: { replaceTextEndOfLine: c2 } } = qe(), { locStart: y2, locEnd: h3 } = Qn(), { isTextLikeNode: g2, getLastDescendant: p2, isPreLikeNode: D, hasPrettierIgnore: v2, shouldPreserveContent: w2, isVueSfcBlock: T2 } = Mt();
          function F(L2, Y) {
            return [L2.isSelfClosing ? "" : A2(L2, Y), B(L2, Y)];
          }
          __name(F, "F");
          function A2(L2, Y) {
            return L2.lastChild && o2(L2.lastChild) ? "" : [I(L2, Y), R2(L2, Y)];
          }
          __name(A2, "A");
          function B(L2, Y) {
            return (L2.next ? m2(L2.next) : E2(L2.parent)) ? "" : [f2(L2, Y), P2(L2, Y)];
          }
          __name(B, "B");
          function I(L2, Y) {
            return E2(L2) ? f2(L2.lastChild, Y) : "";
          }
          __name(I, "I");
          function P2(L2, Y) {
            return o2(L2) ? R2(L2.parent, Y) : d2(L2) ? q(L2.next) : "";
          }
          __name(P2, "P");
          function R2(L2, Y) {
            if (t2(!L2.isSelfClosing), x2(L2, Y))
              return "";
            switch (L2.type) {
              case "ieConditionalComment":
                return "<!";
              case "element":
                if (L2.hasHtmComponentClosingTag)
                  return "<//";
              default:
                return `</${L2.rawName}`;
            }
          }
          __name(R2, "R");
          function f2(L2, Y) {
            if (x2(L2, Y))
              return "";
            switch (L2.type) {
              case "ieConditionalComment":
              case "ieConditionalEndComment":
                return "[endif]-->";
              case "ieConditionalStartComment":
                return "]><!-->";
              case "interpolation":
                return "}}";
              case "element":
                if (L2.isSelfClosing)
                  return "/>";
              default:
                return ">";
            }
          }
          __name(f2, "f");
          function x2(L2, Y) {
            return !L2.isSelfClosing && !L2.endSourceSpan && (v2(L2) || w2(L2.parent, Y));
          }
          __name(x2, "x");
          function m2(L2) {
            return L2.prev && L2.prev.type !== "docType" && !g2(L2.prev) && L2.isLeadingSpaceSensitive && !L2.hasLeadingSpaces;
          }
          __name(m2, "m");
          function E2(L2) {
            return L2.lastChild && L2.lastChild.isTrailingSpaceSensitive && !L2.lastChild.hasTrailingSpaces && !g2(p2(L2.lastChild)) && !D(L2);
          }
          __name(E2, "E");
          function o2(L2) {
            return !L2.next && !L2.hasTrailingSpaces && L2.isTrailingSpaceSensitive && g2(p2(L2));
          }
          __name(o2, "o");
          function d2(L2) {
            return L2.next && !g2(L2.next) && g2(L2) && L2.isTrailingSpaceSensitive && !L2.hasTrailingSpaces;
          }
          __name(d2, "d");
          function C2(L2) {
            let Y = L2.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
            return Y ? Y[1] ? Y[1].split(/\s+/) : true : false;
          }
          __name(C2, "C");
          function _2(L2) {
            return !L2.prev && L2.isLeadingSpaceSensitive && !L2.hasLeadingSpaces;
          }
          __name(_2, "_");
          function b2(L2, Y, V) {
            let O2 = L2.getValue();
            if (!s2(O2.attrs))
              return O2.isSelfClosing ? " " : "";
            let K = O2.prev && O2.prev.type === "comment" && C2(O2.prev.value), se = typeof K == "boolean" ? () => K : Array.isArray(K) ? (ae) => K.includes(ae.rawName) : () => false, Q = L2.map((ae) => {
              let Ae = ae.getValue();
              return se(Ae) ? c2(Y.originalText.slice(y2(Ae), h3(Ae))) : V();
            }, "attrs"), le = O2.type === "element" && O2.fullName === "script" && O2.attrs.length === 1 && O2.attrs[0].fullName === "src" && O2.children.length === 0, X = Y.singleAttributePerLine && O2.attrs.length > 1 && !T2(O2, Y) ? l2 : u2, oe = [a2([le ? " " : u2, r2(X, Q)])];
            return O2.firstChild && _2(O2.firstChild) || O2.isSelfClosing && E2(O2.parent) || le ? oe.push(O2.isSelfClosing ? " " : "") : oe.push(Y.bracketSameLine ? O2.isSelfClosing ? " " : "" : O2.isSelfClosing ? u2 : i2), oe;
          }
          __name(b2, "b");
          function N2(L2) {
            return L2.firstChild && _2(L2.firstChild) ? "" : J(L2);
          }
          __name(N2, "N");
          function k2(L2, Y, V) {
            let O2 = L2.getValue();
            return [$(O2, Y), b2(L2, Y, V), O2.isSelfClosing ? "" : N2(O2)];
          }
          __name(k2, "k");
          function $(L2, Y) {
            return L2.prev && d2(L2.prev) ? "" : [M2(L2, Y), q(L2)];
          }
          __name($, "$");
          function M2(L2, Y) {
            return _2(L2) ? J(L2.parent) : m2(L2) ? f2(L2.prev, Y) : "";
          }
          __name(M2, "M");
          function q(L2) {
            switch (L2.type) {
              case "ieConditionalComment":
              case "ieConditionalStartComment":
                return `<!--[if ${L2.condition}`;
              case "ieConditionalEndComment":
                return "<!--<!";
              case "interpolation":
                return "{{";
              case "docType":
                return "<!DOCTYPE";
              case "element":
                if (L2.condition)
                  return `<!--[if ${L2.condition}]><!--><${L2.rawName}`;
              default:
                return `<${L2.rawName}`;
            }
          }
          __name(q, "q");
          function J(L2) {
            switch (t2(!L2.isSelfClosing), L2.type) {
              case "ieConditionalComment":
                return "]>";
              case "element":
                if (L2.condition)
                  return "><!--<![endif]-->";
              default:
                return ">";
            }
          }
          __name(J, "J");
          n2.exports = { printClosingTag: F, printClosingTagStart: A2, printClosingTagStartMarker: R2, printClosingTagEndMarker: f2, printClosingTagSuffix: P2, printClosingTagEnd: B, needsToBorrowLastChildClosingTagEndMarker: E2, needsToBorrowParentClosingTagStartMarker: o2, needsToBorrowPrevClosingTagEndMarker: m2, printOpeningTag: k2, printOpeningTagStart: $, printOpeningTagPrefix: M2, printOpeningTagStartMarker: q, printOpeningTagEndMarker: J, needsToBorrowNextOpeningTagStartMarker: d2, needsToBorrowParentOpeningTagEndMarker: _2 };
        } }), Zd = ee({ "node_modules/parse-srcset/src/parse-srcset.js"(e2, n2) {
          re(), function(t2, s2) {
            typeof define == "function" && define.amd ? define([], s2) : typeof n2 == "object" && n2.exports ? n2.exports = s2() : t2.parseSrcset = s2();
          }(e2, function() {
            return function(t2, s2) {
              var a2 = s2 && s2.logger || console;
              function r2(R2) {
                return R2 === " " || R2 === "	" || R2 === `
` || R2 === "\f" || R2 === "\r";
              }
              __name(r2, "r");
              function u2(R2) {
                var f2, x2 = R2.exec(t2.substring(A2));
                if (x2)
                  return f2 = x2[0], A2 += f2.length, f2;
              }
              __name(u2, "u");
              for (var i2 = t2.length, l2 = /^[ \t\n\r\u000c]+/, c2 = /^[, \t\n\r\u000c]+/, y2 = /^[^ \t\n\r\u000c]+/, h3 = /[,]+$/, g2 = /^\d+$/, p2 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, D, v2, w2, T2, F, A2 = 0, B = []; ; ) {
                if (u2(c2), A2 >= i2)
                  return B;
                D = u2(y2), v2 = [], D.slice(-1) === "," ? (D = D.replace(h3, ""), P2()) : I();
              }
              function I() {
                for (u2(l2), w2 = "", T2 = "in descriptor"; ; ) {
                  if (F = t2.charAt(A2), T2 === "in descriptor")
                    if (r2(F))
                      w2 && (v2.push(w2), w2 = "", T2 = "after descriptor");
                    else if (F === ",") {
                      A2 += 1, w2 && v2.push(w2), P2();
                      return;
                    } else if (F === "(")
                      w2 = w2 + F, T2 = "in parens";
                    else if (F === "") {
                      w2 && v2.push(w2), P2();
                      return;
                    } else
                      w2 = w2 + F;
                  else if (T2 === "in parens")
                    if (F === ")")
                      w2 = w2 + F, T2 = "in descriptor";
                    else if (F === "") {
                      v2.push(w2), P2();
                      return;
                    } else
                      w2 = w2 + F;
                  else if (T2 === "after descriptor" && !r2(F))
                    if (F === "") {
                      P2();
                      return;
                    } else
                      T2 = "in descriptor", A2 -= 1;
                  A2 += 1;
                }
              }
              __name(I, "I");
              function P2() {
                var R2 = false, f2, x2, m2, E2, o2 = {}, d2, C2, _2, b2, N2;
                for (E2 = 0; E2 < v2.length; E2++)
                  d2 = v2[E2], C2 = d2[d2.length - 1], _2 = d2.substring(0, d2.length - 1), b2 = parseInt(_2, 10), N2 = parseFloat(_2), g2.test(_2) && C2 === "w" ? ((f2 || x2) && (R2 = true), b2 === 0 ? R2 = true : f2 = b2) : p2.test(_2) && C2 === "x" ? ((f2 || x2 || m2) && (R2 = true), N2 < 0 ? R2 = true : x2 = N2) : g2.test(_2) && C2 === "h" ? ((m2 || x2) && (R2 = true), b2 === 0 ? R2 = true : m2 = b2) : R2 = true;
                R2 ? a2 && a2.error && a2.error("Invalid srcset descriptor found in '" + t2 + "' at '" + d2 + "'.") : (o2.url = D, f2 && (o2.w = f2), x2 && (o2.d = x2), m2 && (o2.h = m2), B.push(o2));
              }
              __name(P2, "P");
            };
          });
        } }), eg = ee({ "src/language-html/syntax-attribute.js"(e2, n2) {
          "use strict";
          re();
          var t2 = Zd(), { builders: { ifBreak: s2, join: a2, line: r2 } } = qe();
          function u2(l2) {
            let c2 = t2(l2, { logger: { error(I) {
              throw new Error(I);
            } } }), y2 = c2.some((I) => {
              let { w: P2 } = I;
              return P2;
            }), h3 = c2.some((I) => {
              let { h: P2 } = I;
              return P2;
            }), g2 = c2.some((I) => {
              let { d: P2 } = I;
              return P2;
            });
            if (y2 + h3 + g2 > 1)
              throw new Error("Mixed descriptor in srcset is not supported");
            let p2 = y2 ? "w" : h3 ? "h" : "d", D = y2 ? "w" : h3 ? "h" : "x", v2 = /* @__PURE__ */ __name((I) => Math.max(...I), "v"), w2 = c2.map((I) => I.url), T2 = v2(w2.map((I) => I.length)), F = c2.map((I) => I[p2]).map((I) => I ? I.toString() : ""), A2 = F.map((I) => {
              let P2 = I.indexOf(".");
              return P2 === -1 ? I.length : P2;
            }), B = v2(A2);
            return a2([",", r2], w2.map((I, P2) => {
              let R2 = [I], f2 = F[P2];
              if (f2) {
                let x2 = T2 - I.length + 1, m2 = B - A2[P2], E2 = " ".repeat(x2 + m2);
                R2.push(s2(E2, " "), f2 + D);
              }
              return R2;
            }));
          }
          __name(u2, "u");
          function i2(l2) {
            return l2.trim().split(/\s+/).join(" ");
          }
          __name(i2, "i");
          n2.exports = { printImgSrcset: u2, printClassNames: i2 };
        } }), tg = ee({ "src/language-html/syntax-vue.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { group: t2 } } = qe();
          function s2(i2, l2) {
            let { left: c2, operator: y2, right: h3 } = a2(i2);
            return [t2(l2(`function _(${c2}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", y2, " ", l2(h3, { parser: "__js_expression" }, { stripTrailingHardline: true })];
          }
          __name(s2, "s");
          function a2(i2) {
            let l2 = /(.*?)\s+(in|of)\s+(.*)/s, c2 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, y2 = /^\(|\)$/g, h3 = i2.match(l2);
            if (!h3)
              return;
            let g2 = {};
            if (g2.for = h3[3].trim(), !g2.for)
              return;
            let p2 = h3[1].trim().replace(y2, ""), D = p2.match(c2);
            D ? (g2.alias = p2.replace(c2, ""), g2.iterator1 = D[1].trim(), D[2] && (g2.iterator2 = D[2].trim())) : g2.alias = p2;
            let v2 = [g2.alias, g2.iterator1, g2.iterator2];
            if (!v2.some((w2, T2) => !w2 && (T2 === 0 || v2.slice(T2 + 1).some(Boolean))))
              return { left: v2.filter(Boolean).join(","), operator: h3[2], right: g2.for };
          }
          __name(a2, "a");
          function r2(i2, l2) {
            return l2(`function _(${i2}) {}`, { parser: "babel", __isVueBindings: true });
          }
          __name(r2, "r");
          function u2(i2) {
            let l2 = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, c2 = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, y2 = i2.trim();
            return l2.test(y2) || c2.test(y2);
          }
          __name(u2, "u");
          n2.exports = { isVueEventBindingExpression: u2, printVueFor: s2, printVueBindings: r2 };
        } }), fo = ee({ "src/language-html/get-node-content.js"(e2, n2) {
          "use strict";
          re();
          var { needsToBorrowParentClosingTagStartMarker: t2, printClosingTagStartMarker: s2, needsToBorrowLastChildClosingTagEndMarker: a2, printClosingTagEndMarker: r2, needsToBorrowParentOpeningTagEndMarker: u2, printOpeningTagEndMarker: i2 } = rr();
          function l2(c2, y2) {
            let h3 = c2.startSourceSpan.end.offset;
            c2.firstChild && u2(c2.firstChild) && (h3 -= i2(c2).length);
            let g2 = c2.endSourceSpan.start.offset;
            return c2.lastChild && t2(c2.lastChild) ? g2 += s2(c2, y2).length : a2(c2) && (g2 -= r2(c2.lastChild, y2).length), y2.originalText.slice(h3, g2);
          }
          __name(l2, "l");
          n2.exports = l2;
        } }), rg = ee({ "src/language-html/embed.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { breakParent: t2, group: s2, hardline: a2, indent: r2, line: u2, fill: i2, softline: l2 }, utils: { mapDoc: c2, replaceTextEndOfLine: y2 } } = qe(), h3 = Kn(), { printClosingTag: g2, printClosingTagSuffix: p2, needsToBorrowPrevClosingTagEndMarker: D, printOpeningTagPrefix: v2, printOpeningTag: w2 } = rr(), { printImgSrcset: T2, printClassNames: F } = eg(), { printVueFor: A2, printVueBindings: B, isVueEventBindingExpression: I } = tg(), { isScriptLikeTag: P2, isVueNonHtmlBlock: R2, inferScriptParser: f2, htmlTrimPreserveIndentation: x2, dedentString: m2, unescapeQuoteEntities: E2, isVueSlotAttribute: o2, isVueSfcBindingsAttribute: d2, getTextValueParts: C2 } = Mt(), _2 = fo();
          function b2(k2, $, M2) {
            let q = /* @__PURE__ */ __name((Q) => new RegExp(Q.join("|")).test(k2.fullName), "q"), J = /* @__PURE__ */ __name(() => E2(k2.value), "J"), L2 = false, Y = /* @__PURE__ */ __name((Q, le) => {
              let W2 = Q.type === "NGRoot" ? Q.node.type === "NGMicrosyntax" && Q.node.body.length === 1 && Q.node.body[0].type === "NGMicrosyntaxExpression" ? Q.node.body[0].expression : Q.node : Q.type === "JsExpressionRoot" ? Q.node : Q;
              W2 && (W2.type === "ObjectExpression" || W2.type === "ArrayExpression" || le.parser === "__vue_expression" && (W2.type === "TemplateLiteral" || W2.type === "StringLiteral")) && (L2 = true);
            }, "Y"), V = /* @__PURE__ */ __name((Q) => s2(Q), "V"), O2 = /* @__PURE__ */ __name(function(Q) {
              let le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              return s2([r2([l2, Q]), le ? l2 : ""]);
            }, "O"), K = /* @__PURE__ */ __name((Q) => L2 ? V(Q) : O2(Q), "K"), se = /* @__PURE__ */ __name((Q, le) => $(Q, Object.assign({ __onHtmlBindingRoot: Y, __embeddedInHtml: true }, le)), "se");
            if (k2.fullName === "srcset" && (k2.parent.fullName === "img" || k2.parent.fullName === "source"))
              return O2(T2(J()));
            if (k2.fullName === "class" && !M2.parentParser) {
              let Q = J();
              if (!Q.includes("{{"))
                return F(Q);
            }
            if (k2.fullName === "style" && !M2.parentParser) {
              let Q = J();
              if (!Q.includes("{{"))
                return O2(se(Q, { parser: "css", __isHTMLStyleAttribute: true }));
            }
            if (M2.parser === "vue") {
              if (k2.fullName === "v-for")
                return A2(J(), se);
              if (o2(k2) || d2(k2, M2))
                return B(J(), se);
              let Q = ["^@", "^v-on:"], le = ["^:", "^v-bind:"], W2 = ["^v-"];
              if (q(Q)) {
                let X = J(), oe = I(X) ? "__js_expression" : M2.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                return K(se(X, { parser: oe }));
              }
              if (q(le))
                return K(se(J(), { parser: "__vue_expression" }));
              if (q(W2))
                return K(se(J(), { parser: "__js_expression" }));
            }
            if (M2.parser === "angular") {
              let Q = /* @__PURE__ */ __name((z, H) => se(z, Object.assign(Object.assign({}, H), {}, { trailingComma: "none" })), "Q"), le = ["^\\*"], W2 = ["^\\(.+\\)$", "^on-"], X = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], oe = ["^i18n(-.+)?$"];
              if (q(W2))
                return K(Q(J(), { parser: "__ng_action" }));
              if (q(X))
                return K(Q(J(), { parser: "__ng_binding" }));
              if (q(oe)) {
                let z = J().trim();
                return O2(i2(C2(k2, z)), !z.includes("@@"));
              }
              if (q(le))
                return K(Q(J(), { parser: "__ng_directive" }));
              let ae = /{{(.+?)}}/s, Ae = J();
              if (ae.test(Ae)) {
                let z = [];
                for (let [H, Z] of Ae.split(ae).entries())
                  if (H % 2 === 0)
                    z.push(y2(Z));
                  else
                    try {
                      z.push(s2(["{{", r2([u2, Q(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u2, "}}"]));
                    } catch {
                      z.push("{{", y2(Z), "}}");
                    }
                return s2(z);
              }
            }
            return null;
          }
          __name(b2, "b");
          function N2(k2, $, M2, q) {
            let J = k2.getValue();
            switch (J.type) {
              case "element": {
                if (P2(J) || J.type === "interpolation")
                  return;
                if (!J.isSelfClosing && R2(J, q)) {
                  let L2 = f2(J, q);
                  if (!L2)
                    return;
                  let Y = _2(J, q), V = /^\s*$/.test(Y), O2 = "";
                  return V || (O2 = M2(x2(Y), { parser: L2, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = O2 === ""), [v2(J, q), s2(w2(k2, q, $)), V ? "" : a2, O2, V ? "" : a2, g2(J, q), p2(J, q)];
                }
                break;
              }
              case "text": {
                if (P2(J.parent)) {
                  let L2 = f2(J.parent, q);
                  if (L2) {
                    let Y = L2 === "markdown" ? m2(J.value.replace(/^[^\S\n]*\n/, "")) : J.value, V = { parser: L2, __embeddedInHtml: true };
                    if (q.parser === "html" && L2 === "babel") {
                      let O2 = "script", { attrMap: K } = J.parent;
                      K && (K.type === "module" || K.type === "text/babel" && K["data-type"] === "module") && (O2 = "module"), V.__babelSourceType = O2;
                    }
                    return [t2, v2(J, q), M2(Y, V, { stripTrailingHardline: true }), p2(J, q)];
                  }
                } else if (J.parent.type === "interpolation") {
                  let L2 = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                  return q.parser === "angular" ? (L2.parser = "__ng_interpolation", L2.trailingComma = "none") : q.parser === "vue" ? L2.parser = q.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L2.parser = "__js_expression", [r2([u2, M2(J.value, L2, { stripTrailingHardline: true })]), J.parent.next && D(J.parent.next) ? " " : u2];
                }
                break;
              }
              case "attribute": {
                if (!J.value)
                  break;
                if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                  return [J.rawName, "=", J.value];
                if (q.parser === "lwc" && /^{.*}$/s.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                  return [J.rawName, "=", J.value];
                let L2 = b2(J, (Y, V) => M2(Y, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q);
                if (L2)
                  return [J.rawName, '="', s2(c2(L2, (Y) => typeof Y == "string" ? Y.replace(/"/g, "&quot;") : Y)), '"'];
                break;
              }
              case "front-matter":
                return h3(J, M2);
            }
          }
          __name(N2, "N");
          n2.exports = N2;
        } }), Do = ee({ "src/language-html/print/children.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { breakParent: t2, group: s2, ifBreak: a2, line: r2, softline: u2, hardline: i2 }, utils: { replaceTextEndOfLine: l2 } } = qe(), { locStart: c2, locEnd: y2 } = Qn(), { forceBreakChildren: h3, forceNextEmptyLine: g2, isTextLikeNode: p2, hasPrettierIgnore: D, preferHardlineAsLeadingSpaces: v2 } = Mt(), { printOpeningTagPrefix: w2, needsToBorrowNextOpeningTagStartMarker: T2, printOpeningTagStartMarker: F, needsToBorrowPrevClosingTagEndMarker: A2, printClosingTagEndMarker: B, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: P2 } = rr();
          function R2(m2, E2, o2) {
            let d2 = m2.getValue();
            return D(d2) ? [w2(d2, E2), ...l2(E2.originalText.slice(c2(d2) + (d2.prev && T2(d2.prev) ? F(d2).length : 0), y2(d2) - (d2.next && A2(d2.next) ? B(d2, E2).length : 0))), I(d2, E2)] : o2();
          }
          __name(R2, "R");
          function f2(m2, E2) {
            return p2(m2) && p2(E2) ? m2.isTrailingSpaceSensitive ? m2.hasTrailingSpaces ? v2(E2) ? i2 : r2 : "" : v2(E2) ? i2 : u2 : T2(m2) && (D(E2) || E2.firstChild || E2.isSelfClosing || E2.type === "element" && E2.attrs.length > 0) || m2.type === "element" && m2.isSelfClosing && A2(E2) ? "" : !E2.isLeadingSpaceSensitive || v2(E2) || A2(E2) && m2.lastChild && P2(m2.lastChild) && m2.lastChild.lastChild && P2(m2.lastChild.lastChild) ? i2 : E2.hasLeadingSpaces ? r2 : u2;
          }
          __name(f2, "f");
          function x2(m2, E2, o2) {
            let d2 = m2.getValue();
            if (h3(d2))
              return [t2, ...m2.map((_2) => {
                let b2 = _2.getValue(), N2 = b2.prev ? f2(b2.prev, b2) : "";
                return [N2 ? [N2, g2(b2.prev) ? i2 : ""] : "", R2(_2, E2, o2)];
              }, "children")];
            let C2 = d2.children.map(() => Symbol(""));
            return m2.map((_2, b2) => {
              let N2 = _2.getValue();
              if (p2(N2)) {
                if (N2.prev && p2(N2.prev)) {
                  let Y = f2(N2.prev, N2);
                  if (Y)
                    return g2(N2.prev) ? [i2, i2, R2(_2, E2, o2)] : [Y, R2(_2, E2, o2)];
                }
                return R2(_2, E2, o2);
              }
              let k2 = [], $ = [], M2 = [], q = [], J = N2.prev ? f2(N2.prev, N2) : "", L2 = N2.next ? f2(N2, N2.next) : "";
              return J && (g2(N2.prev) ? k2.push(i2, i2) : J === i2 ? k2.push(i2) : p2(N2.prev) ? $.push(J) : $.push(a2("", u2, { groupId: C2[b2 - 1] }))), L2 && (g2(N2) ? p2(N2.next) && q.push(i2, i2) : L2 === i2 ? p2(N2.next) && q.push(i2) : M2.push(L2)), [...k2, s2([...$, s2([R2(_2, E2, o2), ...M2], { id: C2[b2] })]), ...q];
            }, "children");
          }
          __name(x2, "x");
          n2.exports = { printChildren: x2 };
        } }), ng = ee({ "src/language-html/print/element.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { breakParent: t2, dedentToRoot: s2, group: a2, ifBreak: r2, indentIfBreak: u2, indent: i2, line: l2, softline: c2 }, utils: { replaceTextEndOfLine: y2 } } = qe(), h3 = fo(), { shouldPreserveContent: g2, isScriptLikeTag: p2, isVueCustomBlock: D, countParents: v2, forceBreakContent: w2 } = Mt(), { printOpeningTagPrefix: T2, printOpeningTag: F, printClosingTagSuffix: A2, printClosingTag: B, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: P2 } = rr(), { printChildren: R2 } = Do();
          function f2(x2, m2, E2) {
            let o2 = x2.getValue();
            if (g2(o2, m2))
              return [T2(o2, m2), a2(F(x2, m2, E2)), ...y2(h3(o2, m2)), ...B(o2, m2), A2(o2, m2)];
            let d2 = o2.children.length === 1 && o2.firstChild.type === "interpolation" && o2.firstChild.isLeadingSpaceSensitive && !o2.firstChild.hasLeadingSpaces && o2.lastChild.isTrailingSpaceSensitive && !o2.lastChild.hasTrailingSpaces, C2 = Symbol("element-attr-group-id"), _2 = /* @__PURE__ */ __name(($) => a2([a2(F(x2, m2, E2), { id: C2 }), $, B(o2, m2)]), "_"), b2 = /* @__PURE__ */ __name(($) => d2 ? u2($, { groupId: C2 }) : (p2(o2) || D(o2, m2)) && o2.parent.type === "root" && m2.parser === "vue" && !m2.vueIndentScriptAndStyle ? $ : i2($), "b"), N2 = /* @__PURE__ */ __name(() => d2 ? r2(c2, "", { groupId: C2 }) : o2.firstChild.hasLeadingSpaces && o2.firstChild.isLeadingSpaceSensitive ? l2 : o2.firstChild.type === "text" && o2.isWhitespaceSensitive && o2.isIndentationSensitive ? s2(c2) : c2, "N"), k2 = /* @__PURE__ */ __name(() => (o2.next ? I(o2.next) : P2(o2.parent)) ? o2.lastChild.hasTrailingSpaces && o2.lastChild.isTrailingSpaceSensitive ? " " : "" : d2 ? r2(c2, "", { groupId: C2 }) : o2.lastChild.hasTrailingSpaces && o2.lastChild.isTrailingSpaceSensitive ? l2 : (o2.lastChild.type === "comment" || o2.lastChild.type === "text" && o2.isWhitespaceSensitive && o2.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m2.tabWidth * v2(x2, (M2) => M2.parent && M2.parent.type !== "root")}}$`).test(o2.lastChild.value) ? "" : c2, "k");
            return o2.children.length === 0 ? _2(o2.hasDanglingSpaces && o2.isDanglingSpaceSensitive ? l2 : "") : _2([w2(o2) ? t2 : "", b2([N2(), R2(x2, m2, E2)]), k2()]);
          }
          __name(f2, "f");
          n2.exports = { printElement: f2 };
        } }), ug = ee({ "src/language-html/printer-html.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { fill: t2, group: s2, hardline: a2, literalline: r2 }, utils: { cleanDoc: u2, getDocParts: i2, isConcat: l2, replaceTextEndOfLine: c2 } } = qe(), y2 = Wd(), { countChars: h3, unescapeQuoteEntities: g2, getTextValueParts: p2 } = Mt(), D = Yd(), { insertPragma: v2 } = Qd(), { locStart: w2, locEnd: T2 } = Qn(), F = rg(), { printClosingTagSuffix: A2, printClosingTagEnd: B, printOpeningTagPrefix: I, printOpeningTagStart: P2 } = rr(), { printElement: R2 } = ng(), { printChildren: f2 } = Do();
          function x2(m2, E2, o2) {
            let d2 = m2.getValue();
            switch (d2.type) {
              case "front-matter":
                return c2(d2.raw);
              case "root":
                return E2.__onHtmlRoot && E2.__onHtmlRoot(d2), [s2(f2(m2, E2, o2)), a2];
              case "element":
              case "ieConditionalComment":
                return R2(m2, E2, o2);
              case "ieConditionalStartComment":
              case "ieConditionalEndComment":
                return [P2(d2), B(d2)];
              case "interpolation":
                return [P2(d2, E2), ...m2.map(o2, "children"), B(d2, E2)];
              case "text": {
                if (d2.parent.type === "interpolation") {
                  let _2 = /\n[^\S\n]*$/, b2 = _2.test(d2.value), N2 = b2 ? d2.value.replace(_2, "") : d2.value;
                  return [...c2(N2), b2 ? a2 : ""];
                }
                let C2 = u2([I(d2, E2), ...p2(d2), A2(d2, E2)]);
                return l2(C2) || C2.type === "fill" ? t2(i2(C2)) : C2;
              }
              case "docType":
                return [s2([P2(d2, E2), " ", d2.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), B(d2, E2)];
              case "comment":
                return [I(d2, E2), ...c2(E2.originalText.slice(w2(d2), T2(d2)), r2), A2(d2, E2)];
              case "attribute": {
                if (d2.value === null)
                  return d2.rawName;
                let C2 = g2(d2.value), _2 = h3(C2, "'"), b2 = h3(C2, '"'), N2 = _2 < b2 ? "'" : '"';
                return [d2.rawName, "=", N2, ...c2(N2 === '"' ? C2.replace(/"/g, "&quot;") : C2.replace(/'/g, "&apos;")), N2];
              }
              default:
                throw new Error(`Unexpected node type ${d2.type}`);
            }
          }
          __name(x2, "x");
          n2.exports = { preprocess: D, print: x2, insertPragma: v2, massageAstNode: y2, embed: F };
        } }), sg = ee({ "src/language-html/options.js"(e2, n2) {
          "use strict";
          re();
          var t2 = qt(), s2 = "HTML";
          n2.exports = { bracketSameLine: t2.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s2, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t2.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s2, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
        } }), ig = ee({ "src/language-html/parsers.js"() {
          re();
        } }), Tn = ee({ "node_modules/linguist-languages/data/HTML.json"(e2, n2) {
          n2.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
        } }), ag = ee({ "node_modules/linguist-languages/data/Vue.json"(e2, n2) {
          n2.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
        } }), og = ee({ "src/language-html/index.js"(e2, n2) {
          "use strict";
          re();
          var t2 = wt(), s2 = ug(), a2 = sg(), r2 = ig(), u2 = [t2(Tn(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t2(Tn(), (l2) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l2.extensions, ".mjml"] })), t2(Tn(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t2(ag(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i2 = { html: s2 };
          n2.exports = { languages: u2, printers: i2, options: a2, parsers: r2 };
        } }), lg = ee({ "src/language-yaml/pragma.js"(e2, n2) {
          "use strict";
          re();
          function t2(r2) {
            return /^\s*@(?:prettier|format)\s*$/.test(r2);
          }
          __name(t2, "t");
          function s2(r2) {
            return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(r2);
          }
          __name(s2, "s");
          function a2(r2) {
            return `# @format

${r2}`;
          }
          __name(a2, "a");
          n2.exports = { isPragma: t2, hasPragma: s2, insertPragma: a2 };
        } }), cg = ee({ "src/language-yaml/loc.js"(e2, n2) {
          "use strict";
          re();
          function t2(a2) {
            return a2.position.start.offset;
          }
          __name(t2, "t");
          function s2(a2) {
            return a2.position.end.offset;
          }
          __name(s2, "s");
          n2.exports = { locStart: t2, locEnd: s2 };
        } }), pg = ee({ "src/language-yaml/embed.js"(e2, n2) {
          "use strict";
          re();
          function t2(s2, a2, r2, u2) {
            if (s2.getValue().type === "root" && u2.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u2.filepath))
              return r2(u2.originalText, Object.assign(Object.assign({}, u2), {}, { parser: "json" }));
          }
          __name(t2, "t");
          n2.exports = t2;
        } }), Rt = ee({ "src/language-yaml/utils.js"(e2, n2) {
          "use strict";
          re();
          var { getLast: t2, isNonEmptyArray: s2 } = Ge();
          function a2(f2, x2) {
            let m2 = 0, E2 = f2.stack.length - 1;
            for (let o2 = 0; o2 < E2; o2++) {
              let d2 = f2.stack[o2];
              r2(d2) && x2(d2) && m2++;
            }
            return m2;
          }
          __name(a2, "a");
          function r2(f2, x2) {
            return f2 && typeof f2.type == "string" && (!x2 || x2.includes(f2.type));
          }
          __name(r2, "r");
          function u2(f2, x2, m2) {
            return x2("children" in f2 ? Object.assign(Object.assign({}, f2), {}, { children: f2.children.map((E2) => u2(E2, x2, f2)) }) : f2, m2);
          }
          __name(u2, "u");
          function i2(f2, x2, m2) {
            Object.defineProperty(f2, x2, { get: m2, enumerable: false });
          }
          __name(i2, "i");
          function l2(f2, x2) {
            let m2 = 0, E2 = x2.length;
            for (let o2 = f2.position.end.offset - 1; o2 < E2; o2++) {
              let d2 = x2[o2];
              if (d2 === `
` && m2++, m2 === 1 && /\S/.test(d2))
                return false;
              if (m2 === 2)
                return true;
            }
            return false;
          }
          __name(l2, "l");
          function c2(f2) {
            switch (f2.getValue().type) {
              case "tag":
              case "anchor":
              case "comment":
                return false;
            }
            let m2 = f2.stack.length;
            for (let E2 = 1; E2 < m2; E2++) {
              let o2 = f2.stack[E2], d2 = f2.stack[E2 - 1];
              if (Array.isArray(d2) && typeof o2 == "number" && o2 !== d2.length - 1)
                return false;
            }
            return true;
          }
          __name(c2, "c");
          function y2(f2) {
            return s2(f2.children) ? y2(t2(f2.children)) : f2;
          }
          __name(y2, "y");
          function h3(f2) {
            return f2.value.trim() === "prettier-ignore";
          }
          __name(h3, "h");
          function g2(f2) {
            let x2 = f2.getValue();
            if (x2.type === "documentBody") {
              let m2 = f2.getParentNode();
              return A2(m2.head) && h3(t2(m2.head.endComments));
            }
            return v2(x2) && h3(t2(x2.leadingComments));
          }
          __name(g2, "g");
          function p2(f2) {
            return !s2(f2.children) && !D(f2);
          }
          __name(p2, "p");
          function D(f2) {
            return v2(f2) || w2(f2) || T2(f2) || F(f2) || A2(f2);
          }
          __name(D, "D");
          function v2(f2) {
            return s2(f2 == null ? void 0 : f2.leadingComments);
          }
          __name(v2, "v");
          function w2(f2) {
            return s2(f2 == null ? void 0 : f2.middleComments);
          }
          __name(w2, "w");
          function T2(f2) {
            return f2 == null ? void 0 : f2.indicatorComment;
          }
          __name(T2, "T");
          function F(f2) {
            return f2 == null ? void 0 : f2.trailingComment;
          }
          __name(F, "F");
          function A2(f2) {
            return s2(f2 == null ? void 0 : f2.endComments);
          }
          __name(A2, "A");
          function B(f2) {
            let x2 = [], m2;
            for (let E2 of f2.split(/( +)/))
              E2 !== " " ? m2 === " " ? x2.push(E2) : x2.push((x2.pop() || "") + E2) : m2 === void 0 && x2.unshift(""), m2 = E2;
            return m2 === " " && x2.push((x2.pop() || "") + " "), x2[0] === "" && (x2.shift(), x2.unshift(" " + (x2.shift() || ""))), x2;
          }
          __name(B, "B");
          function I(f2, x2, m2) {
            let E2 = x2.split(`
`).map((o2, d2, C2) => d2 === 0 && d2 === C2.length - 1 ? o2 : d2 !== 0 && d2 !== C2.length - 1 ? o2.trim() : d2 === 0 ? o2.trimEnd() : o2.trimStart());
            return m2.proseWrap === "preserve" ? E2.map((o2) => o2.length === 0 ? [] : [o2]) : E2.map((o2) => o2.length === 0 ? [] : B(o2)).reduce((o2, d2, C2) => C2 !== 0 && E2[C2 - 1].length > 0 && d2.length > 0 && !(f2 === "quoteDouble" && t2(t2(o2)).endsWith("\\")) ? [...o2.slice(0, -1), [...t2(o2), ...d2]] : [...o2, d2], []).map((o2) => m2.proseWrap === "never" ? [o2.join(" ")] : o2);
          }
          __name(I, "I");
          function P2(f2, x2) {
            let { parentIndent: m2, isLastDescendant: E2, options: o2 } = x2, d2 = f2.position.start.line === f2.position.end.line ? "" : o2.originalText.slice(f2.position.start.offset, f2.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], C2;
            if (f2.indent === null) {
              let N2 = d2.match(/^(?<leadingSpace> *)[^\n\r ]/m);
              C2 = N2 ? N2.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
            } else
              C2 = f2.indent - 1 + m2;
            let _2 = d2.split(`
`).map((N2) => N2.slice(C2));
            if (o2.proseWrap === "preserve" || f2.type === "blockLiteral")
              return b2(_2.map((N2) => N2.length === 0 ? [] : [N2]));
            return b2(_2.map((N2) => N2.length === 0 ? [] : B(N2)).reduce((N2, k2, $) => $ !== 0 && _2[$ - 1].length > 0 && k2.length > 0 && !/^\s/.test(k2[0]) && !/^\s|\s$/.test(t2(N2)) ? [...N2.slice(0, -1), [...t2(N2), ...k2]] : [...N2, k2], []).map((N2) => N2.reduce((k2, $) => k2.length > 0 && /\s$/.test(t2(k2)) ? [...k2.slice(0, -1), t2(k2) + " " + $] : [...k2, $], [])).map((N2) => o2.proseWrap === "never" ? [N2.join(" ")] : N2));
            function b2(N2) {
              if (f2.chomping === "keep")
                return t2(N2).length === 0 ? N2.slice(0, -1) : N2;
              let k2 = 0;
              for (let $ = N2.length - 1; $ >= 0 && N2[$].length === 0; $--)
                k2++;
              return k2 === 0 ? N2 : k2 >= 2 && !E2 ? N2.slice(0, -(k2 - 1)) : N2.slice(0, -k2);
            }
            __name(b2, "b");
          }
          __name(P2, "P");
          function R2(f2) {
            if (!f2)
              return true;
            switch (f2.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
              case "alias":
              case "flowMapping":
              case "flowSequence":
                return true;
              default:
                return false;
            }
          }
          __name(R2, "R");
          n2.exports = { getLast: t2, getAncestorCount: a2, isNode: r2, isEmptyNode: p2, isInlineNode: R2, mapNode: u2, defineShortcut: i2, isNextLineEmpty: l2, isLastDescendantNode: c2, getBlockValueLineContents: P2, getFlowScalarLineContents: I, getLastDescendantNode: y2, hasPrettierIgnore: g2, hasLeadingComments: v2, hasMiddleComments: w2, hasIndicatorComment: T2, hasTrailingComment: F, hasEndComments: A2 };
        } }), fg = ee({ "src/language-yaml/print-preprocess.js"(e2, n2) {
          "use strict";
          re();
          var { defineShortcut: t2, mapNode: s2 } = Rt();
          function a2(u2) {
            return s2(u2, r2);
          }
          __name(a2, "a");
          function r2(u2) {
            switch (u2.type) {
              case "document":
                t2(u2, "head", () => u2.children[0]), t2(u2, "body", () => u2.children[1]);
                break;
              case "documentBody":
              case "sequenceItem":
              case "flowSequenceItem":
              case "mappingKey":
              case "mappingValue":
                t2(u2, "content", () => u2.children[0]);
                break;
              case "mappingItem":
              case "flowMappingItem":
                t2(u2, "key", () => u2.children[0]), t2(u2, "value", () => u2.children[1]);
                break;
            }
            return u2;
          }
          __name(r2, "r");
          n2.exports = a2;
        } }), qr = ee({ "src/language-yaml/print/misc.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { softline: t2, align: s2 } } = qe(), { hasEndComments: a2, isNextLineEmpty: r2, isNode: u2 } = Rt(), i2 = /* @__PURE__ */ new WeakMap();
          function l2(h3, g2) {
            let p2 = h3.getValue(), D = h3.stack[0], v2;
            return i2.has(D) ? v2 = i2.get(D) : (v2 = /* @__PURE__ */ new Set(), i2.set(D, v2)), !v2.has(p2.position.end.line) && (v2.add(p2.position.end.line), r2(p2, g2) && !c2(h3.getParentNode())) ? t2 : "";
          }
          __name(l2, "l");
          function c2(h3) {
            return a2(h3) && !u2(h3, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
          }
          __name(c2, "c");
          function y2(h3, g2) {
            return s2(" ".repeat(h3), g2);
          }
          __name(y2, "y");
          n2.exports = { alignWithSpaces: y2, shouldPrintEndComments: c2, printNextEmptyLine: l2 };
        } }), Dg = ee({ "src/language-yaml/print/flow-mapping-sequence.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { ifBreak: t2, line: s2, softline: a2, hardline: r2, join: u2 } } = qe(), { isEmptyNode: i2, getLast: l2, hasEndComments: c2 } = Rt(), { printNextEmptyLine: y2, alignWithSpaces: h3 } = qr();
          function g2(D, v2, w2) {
            let T2 = D.getValue(), F = T2.type === "flowMapping", A2 = F ? "{" : "[", B = F ? "}" : "]", I = a2;
            F && T2.children.length > 0 && w2.bracketSpacing && (I = s2);
            let P2 = l2(T2.children), R2 = P2 && P2.type === "flowMappingItem" && i2(P2.key) && i2(P2.value);
            return [A2, h3(w2.tabWidth, [I, p2(D, v2, w2), w2.trailingComma === "none" ? "" : t2(","), c2(T2) ? [r2, u2(r2, D.map(v2, "endComments"))] : ""]), R2 ? "" : I, B];
          }
          __name(g2, "g");
          function p2(D, v2, w2) {
            let T2 = D.getValue();
            return D.map((A2, B) => [v2(), B === T2.children.length - 1 ? "" : [",", s2, T2.children[B].position.start.line !== T2.children[B + 1].position.start.line ? y2(A2, w2.originalText) : ""]], "children");
          }
          __name(p2, "p");
          n2.exports = { printFlowMapping: g2, printFlowSequence: g2 };
        } }), mg = ee({ "src/language-yaml/print/mapping-item.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { conditionalGroup: t2, group: s2, hardline: a2, ifBreak: r2, join: u2, line: i2 } } = qe(), { hasLeadingComments: l2, hasMiddleComments: c2, hasTrailingComment: y2, hasEndComments: h3, isNode: g2, isEmptyNode: p2, isInlineNode: D } = Rt(), { alignWithSpaces: v2 } = qr();
          function w2(B, I, P2, R2, f2) {
            let { key: x2, value: m2 } = B, E2 = p2(x2), o2 = p2(m2);
            if (E2 && o2)
              return ": ";
            let d2 = R2("key"), C2 = F(B) ? " " : "";
            if (o2)
              return B.type === "flowMappingItem" && I.type === "flowMapping" ? d2 : B.type === "mappingItem" && T2(x2.content, f2) && !y2(x2.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [d2, C2, ":"] : ["? ", v2(2, d2)];
            let _2 = R2("value");
            if (E2)
              return [": ", v2(2, _2)];
            if (l2(m2) || !D(x2.content))
              return ["? ", v2(2, d2), a2, u2("", P2.map(R2, "value", "leadingComments").map((q) => [q, a2])), ": ", v2(2, _2)];
            if (A2(x2.content) && !l2(x2.content) && !c2(x2.content) && !y2(x2.content) && !h3(x2) && !l2(m2.content) && !c2(m2.content) && !h3(m2) && T2(m2.content, f2))
              return [d2, C2, ": ", _2];
            let b2 = Symbol("mappingKey"), N2 = s2([r2("? "), s2(v2(2, d2), { id: b2 })]), k2 = [a2, ": ", v2(2, _2)], $ = [C2, ":"];
            l2(m2.content) || h3(m2) && m2.content && !g2(m2.content, ["mapping", "sequence"]) || I.type === "mapping" && y2(x2.content) && D(m2.content) || g2(m2.content, ["mapping", "sequence"]) && m2.content.tag === null && m2.content.anchor === null ? $.push(a2) : m2.content && $.push(i2), $.push(_2);
            let M2 = v2(f2.tabWidth, $);
            return T2(x2.content, f2) && !l2(x2.content) && !c2(x2.content) && !h3(x2) ? t2([[d2, M2]]) : t2([[N2, r2(k2, M2, { groupId: b2 })]]);
          }
          __name(w2, "w");
          function T2(B, I) {
            if (!B)
              return true;
            switch (B.type) {
              case "plain":
              case "quoteSingle":
              case "quoteDouble":
                break;
              case "alias":
                return true;
              default:
                return false;
            }
            if (I.proseWrap === "preserve")
              return B.position.start.line === B.position.end.line;
            if (/\\$/m.test(I.originalText.slice(B.position.start.offset, B.position.end.offset)))
              return false;
            switch (I.proseWrap) {
              case "never":
                return !B.value.includes(`
`);
              case "always":
                return !/[\n ]/.test(B.value);
              default:
                return false;
            }
          }
          __name(T2, "T");
          function F(B) {
            return B.key.content && B.key.content.type === "alias";
          }
          __name(F, "F");
          function A2(B) {
            if (!B)
              return true;
            switch (B.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
                return B.position.start.line === B.position.end.line;
              case "alias":
                return true;
              default:
                return false;
            }
          }
          __name(A2, "A");
          n2.exports = w2;
        } }), dg = ee({ "src/language-yaml/print/block.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { dedent: t2, dedentToRoot: s2, fill: a2, hardline: r2, join: u2, line: i2, literalline: l2, markAsRoot: c2 }, utils: { getDocParts: y2 } } = qe(), { getAncestorCount: h3, getBlockValueLineContents: g2, hasIndicatorComment: p2, isLastDescendantNode: D, isNode: v2 } = Rt(), { alignWithSpaces: w2 } = qr();
          function T2(F, A2, B) {
            let I = F.getValue(), P2 = h3(F, (E2) => v2(E2, ["sequence", "mapping"])), R2 = D(F), f2 = [I.type === "blockFolded" ? ">" : "|"];
            I.indent !== null && f2.push(I.indent.toString()), I.chomping !== "clip" && f2.push(I.chomping === "keep" ? "+" : "-"), p2(I) && f2.push(" ", A2("indicatorComment"));
            let x2 = g2(I, { parentIndent: P2, isLastDescendant: R2, options: B }), m2 = [];
            for (let [E2, o2] of x2.entries())
              E2 === 0 && m2.push(r2), m2.push(a2(y2(u2(i2, o2)))), E2 !== x2.length - 1 ? m2.push(o2.length === 0 ? r2 : c2(l2)) : I.chomping === "keep" && R2 && m2.push(s2(o2.length === 0 ? r2 : l2));
            return I.indent === null ? f2.push(t2(w2(B.tabWidth, m2))) : f2.push(s2(w2(I.indent - 1 + P2, m2))), f2;
          }
          __name(T2, "T");
          n2.exports = T2;
        } }), gg = ee({ "src/language-yaml/printer-yaml.js"(e2, n2) {
          "use strict";
          re();
          var { builders: { breakParent: t2, fill: s2, group: a2, hardline: r2, join: u2, line: i2, lineSuffix: l2, literalline: c2 }, utils: { getDocParts: y2, replaceTextEndOfLine: h3 } } = qe(), { isPreviousLineEmpty: g2 } = Ge(), { insertPragma: p2, isPragma: D } = lg(), { locStart: v2 } = cg(), w2 = pg(), { getFlowScalarLineContents: T2, getLastDescendantNode: F, hasLeadingComments: A2, hasMiddleComments: B, hasTrailingComment: I, hasEndComments: P2, hasPrettierIgnore: R2, isLastDescendantNode: f2, isNode: x2, isInlineNode: m2 } = Rt(), E2 = fg(), { alignWithSpaces: o2, printNextEmptyLine: d2, shouldPrintEndComments: C2 } = qr(), { printFlowMapping: _2, printFlowSequence: b2 } = Dg(), N2 = mg(), k2 = dg();
          function $(O2, K, se) {
            let Q = O2.getValue(), le = [];
            Q.type !== "mappingValue" && A2(Q) && le.push([u2(r2, O2.map(se, "leadingComments")), r2]);
            let { tag: W2, anchor: X } = Q;
            W2 && le.push(se("tag")), W2 && X && le.push(" "), X && le.push(se("anchor"));
            let oe = "";
            x2(Q, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !f2(O2) && (oe = d2(O2, K.originalText)), (W2 || X) && (x2(Q, ["sequence", "mapping"]) && !B(Q) ? le.push(r2) : le.push(" ")), B(Q) && le.push([Q.middleComments.length === 1 ? "" : r2, u2(r2, O2.map(se, "middleComments")), r2]);
            let ae = O2.getParentNode();
            return R2(O2) ? le.push(h3(K.originalText.slice(Q.position.start.offset, Q.position.end.offset).trimEnd(), c2)) : le.push(a2(M2(Q, ae, O2, K, se))), I(Q) && !x2(Q, ["document", "documentHead"]) && le.push(l2([Q.type === "mappingValue" && !Q.content ? "" : " ", ae.type === "mappingKey" && O2.getParentNode(2).type === "mapping" && m2(Q) ? "" : t2, se("trailingComment")])), C2(Q) && le.push(o2(Q.type === "sequenceItem" ? 2 : 0, [r2, u2(r2, O2.map((Ae) => [g2(K.originalText, Ae.getValue(), v2) ? r2 : "", se()], "endComments"))])), le.push(oe), le;
          }
          __name($, "$");
          function M2(O2, K, se, Q, le) {
            switch (O2.type) {
              case "root": {
                let { children: W2 } = O2, X = [];
                se.each((ae, Ae) => {
                  let z = W2[Ae], H = W2[Ae + 1];
                  Ae !== 0 && X.push(r2), X.push(le()), J(z, H) ? (X.push(r2, "..."), I(z) && X.push(" ", le("trailingComment"))) : H && !I(H.head) && X.push(r2, "---");
                }, "children");
                let oe = F(O2);
                return (!x2(oe, ["blockLiteral", "blockFolded"]) || oe.chomping !== "keep") && X.push(r2), X;
              }
              case "document": {
                let W2 = K.children[se.getName() + 1], X = [];
                return L2(O2, W2, K, Q) === "head" && ((O2.head.children.length > 0 || O2.head.endComments.length > 0) && X.push(le("head")), I(O2.head) ? X.push(["---", " ", le(["head", "trailingComment"])]) : X.push("---")), q(O2) && X.push(le("body")), u2(r2, X);
              }
              case "documentHead":
                return u2(r2, [...se.map(le, "children"), ...se.map(le, "endComments")]);
              case "documentBody": {
                let { children: W2, endComments: X } = O2, oe = "";
                if (W2.length > 0 && X.length > 0) {
                  let ae = F(O2);
                  x2(ae, ["blockFolded", "blockLiteral"]) ? ae.chomping !== "keep" && (oe = [r2, r2]) : oe = r2;
                }
                return [u2(r2, se.map(le, "children")), oe, u2(r2, se.map(le, "endComments"))];
              }
              case "directive":
                return ["%", u2(" ", [O2.name, ...O2.parameters])];
              case "comment":
                return ["#", O2.value];
              case "alias":
                return ["*", O2.value];
              case "tag":
                return Q.originalText.slice(O2.position.start.offset, O2.position.end.offset);
              case "anchor":
                return ["&", O2.value];
              case "plain":
                return Y(O2.type, Q.originalText.slice(O2.position.start.offset, O2.position.end.offset), Q);
              case "quoteDouble":
              case "quoteSingle": {
                let W2 = "'", X = '"', oe = Q.originalText.slice(O2.position.start.offset + 1, O2.position.end.offset - 1);
                if (O2.type === "quoteSingle" && oe.includes("\\") || O2.type === "quoteDouble" && /\\[^"]/.test(oe)) {
                  let Ae = O2.type === "quoteDouble" ? X : W2;
                  return [Ae, Y(O2.type, oe, Q), Ae];
                }
                if (oe.includes(X))
                  return [W2, Y(O2.type, O2.type === "quoteDouble" ? oe.replace(/\\"/g, X).replace(/'/g, W2.repeat(2)) : oe, Q), W2];
                if (oe.includes(W2))
                  return [X, Y(O2.type, O2.type === "quoteSingle" ? oe.replace(/''/g, W2) : oe, Q), X];
                let ae = Q.singleQuote ? W2 : X;
                return [ae, Y(O2.type, oe, Q), ae];
              }
              case "blockFolded":
              case "blockLiteral":
                return k2(se, le, Q);
              case "mapping":
              case "sequence":
                return u2(r2, se.map(le, "children"));
              case "sequenceItem":
                return ["- ", o2(2, O2.content ? le("content") : "")];
              case "mappingKey":
              case "mappingValue":
                return O2.content ? le("content") : "";
              case "mappingItem":
              case "flowMappingItem":
                return N2(O2, K, se, le, Q);
              case "flowMapping":
                return _2(se, le, Q);
              case "flowSequence":
                return b2(se, le, Q);
              case "flowSequenceItem":
                return le("content");
              default:
                throw new Error(`Unexpected node type ${O2.type}`);
            }
          }
          __name(M2, "M");
          function q(O2) {
            return O2.body.children.length > 0 || P2(O2.body);
          }
          __name(q, "q");
          function J(O2, K) {
            return I(O2) || K && (K.head.children.length > 0 || P2(K.head));
          }
          __name(J, "J");
          function L2(O2, K, se, Q) {
            return se.children[0] === O2 && /---(?:\s|$)/.test(Q.originalText.slice(v2(O2), v2(O2) + 4)) || O2.head.children.length > 0 || P2(O2.head) || I(O2.head) ? "head" : J(O2, K) ? false : K ? "root" : false;
          }
          __name(L2, "L");
          function Y(O2, K, se) {
            let Q = T2(O2, K, se);
            return u2(r2, Q.map((le) => s2(y2(u2(i2, le)))));
          }
          __name(Y, "Y");
          function V(O2, K) {
            if (x2(K))
              switch (delete K.position, K.type) {
                case "comment":
                  if (D(K.value))
                    return null;
                  break;
                case "quoteDouble":
                case "quoteSingle":
                  K.type = "quote";
                  break;
              }
          }
          __name(V, "V");
          n2.exports = { preprocess: E2, embed: w2, print: $, massageAstNode: V, insertPragma: p2 };
        } }), yg = ee({ "src/language-yaml/options.js"(e2, n2) {
          "use strict";
          re();
          var t2 = qt();
          n2.exports = { bracketSpacing: t2.bracketSpacing, singleQuote: t2.singleQuote, proseWrap: t2.proseWrap };
        } }), hg = ee({ "src/language-yaml/parsers.js"() {
          re();
        } }), vg = ee({ "node_modules/linguist-languages/data/YAML.json"(e2, n2) {
          n2.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
        } }), Cg = ee({ "src/language-yaml/index.js"(e2, n2) {
          "use strict";
          re();
          var t2 = wt(), s2 = gg(), a2 = yg(), r2 = hg(), u2 = [t2(vg(), (i2) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i2.filenames.filter((l2) => l2 !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
          n2.exports = { languages: u2, printers: { yaml: s2 }, options: a2, parsers: r2 };
        } }), Eg = ee({ "src/languages.js"(e2, n2) {
          "use strict";
          re(), n2.exports = [td(), vd(), Td(), kd(), Vd(), og(), Cg()];
        } });
        re();
        var { version: Fg } = fa(), kt = vm(), { getSupportInfo: Ag } = Rn(), Sg = Cm(), xg = Eg(), bg = qe();
        function Bt(e2) {
          let n2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return function() {
            for (var t2 = arguments.length, s2 = new Array(t2), a2 = 0; a2 < t2; a2++)
              s2[a2] = arguments[a2];
            let r2 = s2[n2] || {}, u2 = r2.plugins || [];
            return s2[n2] = Object.assign(Object.assign({}, r2), {}, { plugins: [...xg, ...Array.isArray(u2) ? u2 : Object.values(u2)] }), e2(...s2);
          };
        }
        __name(Bt, "Bt");
        var Bn = Bt(kt.formatWithCursor);
        mo.exports = { formatWithCursor: Bn, format(e2, n2) {
          return Bn(e2, n2).formatted;
        }, check(e2, n2) {
          let { formatted: t2 } = Bn(e2, n2);
          return t2 === e2;
        }, doc: bg, getSupportInfo: Bt(Ag, 0), version: Fg, util: Sg, __debug: { parse: Bt(kt.parse), formatAST: Bt(kt.formatAST), formatDoc: Bt(kt.formatDoc), printToDoc: Bt(kt.printToDoc), printDocToString: Bt(kt.printDocToString) } };
      });
      return Tg();
    });
  }
});

// js/ws.ts
init_define_process();

// ../../.yarn/global/cache/avl-npm-1.5.3-ee43491243-9.zip/node_modules/avl/src/index.js
init_define_process();

// ../../.yarn/global/cache/avl-npm-1.5.3-ee43491243-9.zip/node_modules/avl/src/utils.js
init_define_process();
function print(root, printNode = (n2) => n2.key) {
  var out = [];
  row(root, "", true, (v2) => out.push(v2), printNode);
  return out.join("");
}
__name(print, "print");
function row(root, prefix, isTail, out, printNode) {
  if (root) {
    out(`${prefix}${isTail ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 "}${printNode(root)}
`);
    const indent = prefix + (isTail ? "    " : "\u2502   ");
    if (root.left)
      row(root.left, indent, false, out, printNode);
    if (root.right)
      row(root.right, indent, true, out, printNode);
  }
}
__name(row, "row");
function isBalanced(root) {
  if (root === null)
    return true;
  var lh = height(root.left);
  var rh = height(root.right);
  if (Math.abs(lh - rh) <= 1 && isBalanced(root.left) && isBalanced(root.right))
    return true;
  return false;
}
__name(isBalanced, "isBalanced");
function height(node) {
  return node ? 1 + Math.max(height(node.left), height(node.right)) : 0;
}
__name(height, "height");
function loadRecursive(parent, keys, values, start, end) {
  const size = end - start;
  if (size > 0) {
    const middle = start + Math.floor(size / 2);
    const key = keys[middle];
    const data = values[middle];
    const node = { key, data, parent };
    node.left = loadRecursive(node, keys, values, start, middle);
    node.right = loadRecursive(node, keys, values, middle + 1, end);
    return node;
  }
  return null;
}
__name(loadRecursive, "loadRecursive");
function markBalance(node) {
  if (node === null)
    return 0;
  const lh = markBalance(node.left);
  const rh = markBalance(node.right);
  node.balanceFactor = lh - rh;
  return Math.max(lh, rh) + 1;
}
__name(markBalance, "markBalance");
function sort(keys, values, left, right, compare) {
  if (left >= right)
    return;
  const pivot = keys[left + right >> 1];
  let i2 = left - 1;
  let j2 = right + 1;
  while (true) {
    do
      i2++;
    while (compare(keys[i2], pivot) < 0);
    do
      j2--;
    while (compare(keys[j2], pivot) > 0);
    if (i2 >= j2)
      break;
    let tmp = keys[i2];
    keys[i2] = keys[j2];
    keys[j2] = tmp;
    tmp = values[i2];
    values[i2] = values[j2];
    values[j2] = tmp;
  }
  sort(keys, values, left, j2, compare);
  sort(keys, values, j2 + 1, right, compare);
}
__name(sort, "sort");

// ../../.yarn/global/cache/avl-npm-1.5.3-ee43491243-9.zip/node_modules/avl/src/index.js
function DEFAULT_COMPARE(a2, b2) {
  return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
}
__name(DEFAULT_COMPARE, "DEFAULT_COMPARE");
function rotateLeft(node) {
  var rightNode = node.right;
  node.right = rightNode.left;
  if (rightNode.left)
    rightNode.left.parent = node;
  rightNode.parent = node.parent;
  if (rightNode.parent) {
    if (rightNode.parent.left === node) {
      rightNode.parent.left = rightNode;
    } else {
      rightNode.parent.right = rightNode;
    }
  }
  node.parent = rightNode;
  rightNode.left = node;
  node.balanceFactor += 1;
  if (rightNode.balanceFactor < 0) {
    node.balanceFactor -= rightNode.balanceFactor;
  }
  rightNode.balanceFactor += 1;
  if (node.balanceFactor > 0) {
    rightNode.balanceFactor += node.balanceFactor;
  }
  return rightNode;
}
__name(rotateLeft, "rotateLeft");
function rotateRight(node) {
  var leftNode = node.left;
  node.left = leftNode.right;
  if (node.left)
    node.left.parent = node;
  leftNode.parent = node.parent;
  if (leftNode.parent) {
    if (leftNode.parent.left === node) {
      leftNode.parent.left = leftNode;
    } else {
      leftNode.parent.right = leftNode;
    }
  }
  node.parent = leftNode;
  leftNode.right = node;
  node.balanceFactor -= 1;
  if (leftNode.balanceFactor > 0) {
    node.balanceFactor -= leftNode.balanceFactor;
  }
  leftNode.balanceFactor -= 1;
  if (node.balanceFactor < 0) {
    leftNode.balanceFactor += node.balanceFactor;
  }
  return leftNode;
}
__name(rotateRight, "rotateRight");
var AVLTree = class {
  constructor(comparator, noDuplicates = false) {
    this._comparator = comparator || DEFAULT_COMPARE;
    this._root = null;
    this._size = 0;
    this._noDuplicates = !!noDuplicates;
  }
  destroy() {
    return this.clear();
  }
  clear() {
    this._root = null;
    this._size = 0;
    return this;
  }
  get size() {
    return this._size;
  }
  contains(key) {
    if (this._root) {
      var node = this._root;
      var comparator = this._comparator;
      while (node) {
        var cmp = comparator(key, node.key);
        if (cmp === 0)
          return true;
        else if (cmp < 0)
          node = node.left;
        else
          node = node.right;
      }
    }
    return false;
  }
  next(node) {
    var successor = node;
    if (successor) {
      if (successor.right) {
        successor = successor.right;
        while (successor.left)
          successor = successor.left;
      } else {
        successor = node.parent;
        while (successor && successor.right === node) {
          node = successor;
          successor = successor.parent;
        }
      }
    }
    return successor;
  }
  prev(node) {
    var predecessor = node;
    if (predecessor) {
      if (predecessor.left) {
        predecessor = predecessor.left;
        while (predecessor.right)
          predecessor = predecessor.right;
      } else {
        predecessor = node.parent;
        while (predecessor && predecessor.left === node) {
          node = predecessor;
          predecessor = predecessor.parent;
        }
      }
    }
    return predecessor;
  }
  forEach(callback) {
    var current = this._root;
    var s2 = [], done = false, i2 = 0;
    while (!done) {
      if (current) {
        s2.push(current);
        current = current.left;
      } else {
        if (s2.length > 0) {
          current = s2.pop();
          callback(current, i2++);
          current = current.right;
        } else
          done = true;
      }
    }
    return this;
  }
  range(low, high, fn, ctx) {
    const Q = [];
    const compare = this._comparator;
    let node = this._root, cmp;
    while (Q.length !== 0 || node) {
      if (node) {
        Q.push(node);
        node = node.left;
      } else {
        node = Q.pop();
        cmp = compare(node.key, high);
        if (cmp > 0) {
          break;
        } else if (compare(node.key, low) >= 0) {
          if (fn.call(ctx, node))
            return this;
        }
        node = node.right;
      }
    }
    return this;
  }
  keys() {
    var current = this._root;
    var s2 = [], r2 = [], done = false;
    while (!done) {
      if (current) {
        s2.push(current);
        current = current.left;
      } else {
        if (s2.length > 0) {
          current = s2.pop();
          r2.push(current.key);
          current = current.right;
        } else
          done = true;
      }
    }
    return r2;
  }
  values() {
    var current = this._root;
    var s2 = [], r2 = [], done = false;
    while (!done) {
      if (current) {
        s2.push(current);
        current = current.left;
      } else {
        if (s2.length > 0) {
          current = s2.pop();
          r2.push(current.data);
          current = current.right;
        } else
          done = true;
      }
    }
    return r2;
  }
  at(index) {
    var current = this._root;
    var s2 = [], done = false, i2 = 0;
    while (!done) {
      if (current) {
        s2.push(current);
        current = current.left;
      } else {
        if (s2.length > 0) {
          current = s2.pop();
          if (i2 === index)
            return current;
          i2++;
          current = current.right;
        } else
          done = true;
      }
    }
    return null;
  }
  minNode() {
    var node = this._root;
    if (!node)
      return null;
    while (node.left)
      node = node.left;
    return node;
  }
  maxNode() {
    var node = this._root;
    if (!node)
      return null;
    while (node.right)
      node = node.right;
    return node;
  }
  min() {
    var node = this._root;
    if (!node)
      return null;
    while (node.left)
      node = node.left;
    return node.key;
  }
  max() {
    var node = this._root;
    if (!node)
      return null;
    while (node.right)
      node = node.right;
    return node.key;
  }
  isEmpty() {
    return !this._root;
  }
  pop() {
    var node = this._root, returnValue = null;
    if (node) {
      while (node.left)
        node = node.left;
      returnValue = { key: node.key, data: node.data };
      this.remove(node.key);
    }
    return returnValue;
  }
  popMax() {
    var node = this._root, returnValue = null;
    if (node) {
      while (node.right)
        node = node.right;
      returnValue = { key: node.key, data: node.data };
      this.remove(node.key);
    }
    return returnValue;
  }
  find(key) {
    var root = this._root;
    var subtree = root, cmp;
    var compare = this._comparator;
    while (subtree) {
      cmp = compare(key, subtree.key);
      if (cmp === 0)
        return subtree;
      else if (cmp < 0)
        subtree = subtree.left;
      else
        subtree = subtree.right;
    }
    return null;
  }
  insert(key, data) {
    if (!this._root) {
      this._root = {
        parent: null,
        left: null,
        right: null,
        balanceFactor: 0,
        key,
        data
      };
      this._size++;
      return this._root;
    }
    var compare = this._comparator;
    var node = this._root;
    var parent = null;
    var cmp = 0;
    if (this._noDuplicates) {
      while (node) {
        cmp = compare(key, node.key);
        parent = node;
        if (cmp === 0)
          return null;
        else if (cmp < 0)
          node = node.left;
        else
          node = node.right;
      }
    } else {
      while (node) {
        cmp = compare(key, node.key);
        parent = node;
        if (cmp <= 0)
          node = node.left;
        else
          node = node.right;
      }
    }
    var newNode = {
      left: null,
      right: null,
      balanceFactor: 0,
      parent,
      key,
      data
    };
    var newRoot;
    if (cmp <= 0)
      parent.left = newNode;
    else
      parent.right = newNode;
    while (parent) {
      cmp = compare(parent.key, key);
      if (cmp < 0)
        parent.balanceFactor -= 1;
      else
        parent.balanceFactor += 1;
      if (parent.balanceFactor === 0)
        break;
      else if (parent.balanceFactor < -1) {
        if (parent.right.balanceFactor === 1)
          rotateRight(parent.right);
        newRoot = rotateLeft(parent);
        if (parent === this._root)
          this._root = newRoot;
        break;
      } else if (parent.balanceFactor > 1) {
        if (parent.left.balanceFactor === -1)
          rotateLeft(parent.left);
        newRoot = rotateRight(parent);
        if (parent === this._root)
          this._root = newRoot;
        break;
      }
      parent = parent.parent;
    }
    this._size++;
    return newNode;
  }
  remove(key) {
    if (!this._root)
      return null;
    var node = this._root;
    var compare = this._comparator;
    var cmp = 0;
    while (node) {
      cmp = compare(key, node.key);
      if (cmp === 0)
        break;
      else if (cmp < 0)
        node = node.left;
      else
        node = node.right;
    }
    if (!node)
      return null;
    var returnValue = node.key;
    var max, min;
    if (node.left) {
      max = node.left;
      while (max.left || max.right) {
        while (max.right)
          max = max.right;
        node.key = max.key;
        node.data = max.data;
        if (max.left) {
          node = max;
          max = max.left;
        }
      }
      node.key = max.key;
      node.data = max.data;
      node = max;
    }
    if (node.right) {
      min = node.right;
      while (min.left || min.right) {
        while (min.left)
          min = min.left;
        node.key = min.key;
        node.data = min.data;
        if (min.right) {
          node = min;
          min = min.right;
        }
      }
      node.key = min.key;
      node.data = min.data;
      node = min;
    }
    var parent = node.parent;
    var pp = node;
    var newRoot;
    while (parent) {
      if (parent.left === pp)
        parent.balanceFactor -= 1;
      else
        parent.balanceFactor += 1;
      if (parent.balanceFactor < -1) {
        if (parent.right.balanceFactor === 1)
          rotateRight(parent.right);
        newRoot = rotateLeft(parent);
        if (parent === this._root)
          this._root = newRoot;
        parent = newRoot;
      } else if (parent.balanceFactor > 1) {
        if (parent.left.balanceFactor === -1)
          rotateLeft(parent.left);
        newRoot = rotateRight(parent);
        if (parent === this._root)
          this._root = newRoot;
        parent = newRoot;
      }
      if (parent.balanceFactor === -1 || parent.balanceFactor === 1)
        break;
      pp = parent;
      parent = parent.parent;
    }
    if (node.parent) {
      if (node.parent.left === node)
        node.parent.left = null;
      else
        node.parent.right = null;
    }
    if (node === this._root)
      this._root = null;
    this._size--;
    return returnValue;
  }
  load(keys = [], values = [], presort) {
    if (this._size !== 0)
      throw new Error("bulk-load: tree is not empty");
    const size = keys.length;
    if (presort)
      sort(keys, values, 0, size - 1, this._comparator);
    this._root = loadRecursive(null, keys, values, 0, size);
    markBalance(this._root);
    this._size = size;
    return this;
  }
  isBalanced() {
    return isBalanced(this._root);
  }
  toString(printNode) {
    return print(this._root, printNode);
  }
};
__name(AVLTree, "AVLTree");
AVLTree.default = AVLTree;

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/adapter_core.js
init_define_process();

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/adapter_factory.js
init_define_process();

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/utils.js
init_define_process();
var logDisabled_ = true;
var deprecationWarnings_ = true;
function extractVersion(uastring, expr, pos) {
  const match = uastring.match(expr);
  return match && match.length >= pos && parseInt(match[pos], 10);
}
__name(extractVersion, "extractVersion");
function wrapPeerConnectionEvent(window2, eventNameToWrap, wrapper) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const proto = window2.RTCPeerConnection.prototype;
  const nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    const wrappedCallback = /* @__PURE__ */ __name((e2) => {
      const modifiedEvent = wrapper(e2);
      if (modifiedEvent) {
        if (cb.handleEvent) {
          cb.handleEvent(modifiedEvent);
        } else {
          cb(modifiedEvent);
        }
      }
    }, "wrappedCallback");
    this._eventMap = this._eventMap || {};
    if (!this._eventMap[eventNameToWrap]) {
      this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();
    }
    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
    return nativeAddEventListener.apply(this, [
      nativeEventName,
      wrappedCallback
    ]);
  };
  const nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    if (!this._eventMap[eventNameToWrap].has(cb)) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
    this._eventMap[eventNameToWrap].delete(cb);
    if (this._eventMap[eventNameToWrap].size === 0) {
      delete this._eventMap[eventNameToWrap];
    }
    if (Object.keys(this._eventMap).length === 0) {
      delete this._eventMap;
    }
    return nativeRemoveEventListener.apply(this, [
      nativeEventName,
      unwrappedCb
    ]);
  };
  Object.defineProperty(proto, "on" + eventNameToWrap, {
    get() {
      return this["_on" + eventNameToWrap];
    },
    set(cb) {
      if (this["_on" + eventNameToWrap]) {
        this.removeEventListener(
          eventNameToWrap,
          this["_on" + eventNameToWrap]
        );
        delete this["_on" + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(
          eventNameToWrap,
          this["_on" + eventNameToWrap] = cb
        );
      }
    },
    enumerable: true,
    configurable: true
  });
}
__name(wrapPeerConnectionEvent, "wrapPeerConnectionEvent");
function disableLog(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  logDisabled_ = bool;
  return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
}
__name(disableLog, "disableLog");
function disableWarnings(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  deprecationWarnings_ = !bool;
  return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
}
__name(disableWarnings, "disableWarnings");
function log() {
  if (typeof window === "object") {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== "undefined" && typeof console.log === "function") {
      console.log.apply(console, arguments);
    }
  }
}
__name(log, "log");
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");
}
__name(deprecated, "deprecated");
function detectBrowser(window2) {
  const result = { browser: null, version: null };
  if (typeof window2 === "undefined" || !window2.navigator) {
    result.browser = "Not a browser.";
    return result;
  }
  const { navigator: navigator2 } = window2;
  if (navigator2.mozGetUserMedia) {
    result.browser = "firefox";
    result.version = extractVersion(
      navigator2.userAgent,
      /Firefox\/(\d+)\./,
      1
    );
  } else if (navigator2.webkitGetUserMedia || window2.isSecureContext === false && window2.webkitRTCPeerConnection) {
    result.browser = "chrome";
    result.version = extractVersion(
      navigator2.userAgent,
      /Chrom(e|ium)\/(\d+)\./,
      2
    );
  } else if (window2.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\/(\d+)\./)) {
    result.browser = "safari";
    result.version = extractVersion(
      navigator2.userAgent,
      /AppleWebKit\/(\d+)\./,
      1
    );
    result.supportsUnifiedPlan = window2.RTCRtpTransceiver && "currentDirection" in window2.RTCRtpTransceiver.prototype;
  } else {
    result.browser = "Not a supported browser.";
    return result;
  }
  return result;
}
__name(detectBrowser, "detectBrowser");
function isObject(val) {
  return Object.prototype.toString.call(val) === "[object Object]";
}
__name(isObject, "isObject");
function compactObject(data) {
  if (!isObject(data)) {
    return data;
  }
  return Object.keys(data).reduce(function(accumulator, key) {
    const isObj = isObject(data[key]);
    const value = isObj ? compactObject(data[key]) : data[key];
    const isEmptyObject = isObj && !Object.keys(value).length;
    if (value === void 0 || isEmptyObject) {
      return accumulator;
    }
    return Object.assign(accumulator, { [key]: value });
  }, {});
}
__name(compactObject, "compactObject");
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach((name) => {
    if (name.endsWith("Id")) {
      walkStats(stats, stats.get(base[name]), resultSet);
    } else if (name.endsWith("Ids")) {
      base[name].forEach((id) => {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}
__name(walkStats, "walkStats");
function filterStats(result, track, outbound) {
  const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
  const filteredResult = /* @__PURE__ */ new Map();
  if (track === null) {
    return filteredResult;
  }
  const trackStats = [];
  result.forEach((value) => {
    if (value.type === "track" && value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach((trackStat) => {
    result.forEach((stats) => {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}
__name(filterStats, "filterStats");

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js
var chrome_shim_exports = {};
__export(chrome_shim_exports, {
  fixNegotiationNeeded: () => fixNegotiationNeeded,
  shimAddTrackRemoveTrack: () => shimAddTrackRemoveTrack,
  shimAddTrackRemoveTrackWithNative: () => shimAddTrackRemoveTrackWithNative,
  shimGetDisplayMedia: () => shimGetDisplayMedia,
  shimGetSendersWithDtmf: () => shimGetSendersWithDtmf,
  shimGetStats: () => shimGetStats,
  shimGetUserMedia: () => shimGetUserMedia,
  shimMediaStream: () => shimMediaStream,
  shimOnTrack: () => shimOnTrack,
  shimPeerConnection: () => shimPeerConnection,
  shimSenderReceiverGetStats: () => shimSenderReceiverGetStats
});
init_define_process();

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/chrome/getusermedia.js
init_define_process();
var logging = log;
function shimGetUserMedia(window2, browserDetails) {
  const navigator2 = window2 && window2.navigator;
  if (!navigator2.mediaDevices) {
    return;
  }
  const constraintsToChrome_ = /* @__PURE__ */ __name(function(c2) {
    if (typeof c2 !== "object" || c2.mandatory || c2.optional) {
      return c2;
    }
    const cc = {};
    Object.keys(c2).forEach((key) => {
      if (key === "require" || key === "advanced" || key === "mediaSource") {
        return;
      }
      const r2 = typeof c2[key] === "object" ? c2[key] : { ideal: c2[key] };
      if (r2.exact !== void 0 && typeof r2.exact === "number") {
        r2.min = r2.max = r2.exact;
      }
      const oldname_ = /* @__PURE__ */ __name(function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return name === "deviceId" ? "sourceId" : name;
      }, "oldname_");
      if (r2.ideal !== void 0) {
        cc.optional = cc.optional || [];
        let oc = {};
        if (typeof r2.ideal === "number") {
          oc[oldname_("min", key)] = r2.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname_("max", key)] = r2.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname_("", key)] = r2.ideal;
          cc.optional.push(oc);
        }
      }
      if (r2.exact !== void 0 && typeof r2.exact !== "number") {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname_("", key)] = r2.exact;
      } else {
        ["min", "max"].forEach((mix) => {
          if (r2[mix] !== void 0) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname_(mix, key)] = r2[mix];
          }
        });
      }
    });
    if (c2.advanced) {
      cc.optional = (cc.optional || []).concat(c2.advanced);
    }
    return cc;
  }, "constraintsToChrome_");
  const shimConstraints_ = /* @__PURE__ */ __name(function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === "object") {
      const remap = /* @__PURE__ */ __name(function(obj, a2, b2) {
        if (a2 in obj && !(b2 in obj)) {
          obj[b2] = obj[a2];
          delete obj[a2];
        }
      }, "remap");
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, "autoGainControl", "googAutoGainControl");
      remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === "object") {
      let face = constraints.video.facingMode;
      face = face && (typeof face === "object" ? face : { ideal: face });
      const getSupportedFacingModeLies = browserDetails.version < 66;
      if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        let matches;
        if (face.exact === "environment" || face.ideal === "environment") {
          matches = ["back", "rear"];
        } else if (face.exact === "user" || face.ideal === "user") {
          matches = ["front"];
        }
        if (matches) {
          return navigator2.mediaDevices.enumerateDevices().then((devices) => {
            devices = devices.filter((d2) => d2.kind === "videoinput");
            let dev = devices.find((d2) => matches.some((match) => d2.label.toLowerCase().includes(match)));
            if (!dev && devices.length && matches.includes("back")) {
              dev = devices[devices.length - 1];
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging("chrome: " + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging("chrome: " + JSON.stringify(constraints));
    return func(constraints);
  }, "shimConstraints_");
  const shimError_ = /* @__PURE__ */ __name(function(e2) {
    if (browserDetails.version >= 64) {
      return e2;
    }
    return {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[e2.name] || e2.name,
      message: e2.message,
      constraint: e2.constraint || e2.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  }, "shimError_");
  const getUserMedia_ = /* @__PURE__ */ __name(function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, (c2) => {
      navigator2.webkitGetUserMedia(c2, onSuccess, (e2) => {
        if (onError) {
          onError(shimError_(e2));
        }
      });
    });
  }, "getUserMedia_");
  navigator2.getUserMedia = getUserMedia_.bind(navigator2);
  if (navigator2.mediaDevices.getUserMedia) {
    const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(cs) {
      return shimConstraints_(cs, (c2) => origGetUserMedia(c2).then((stream) => {
        if (c2.audio && !stream.getAudioTracks().length || c2.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach((track) => {
            track.stop();
          });
          throw new DOMException("", "NotFoundError");
        }
        return stream;
      }, (e2) => Promise.reject(shimError_(e2))));
    };
  }
}
__name(shimGetUserMedia, "shimGetUserMedia");

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js
init_define_process();
function shimGetDisplayMedia(window2, getSourceId) {
  if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
    return;
  }
  if (!window2.navigator.mediaDevices) {
    return;
  }
  if (typeof getSourceId !== "function") {
    console.error("shimGetDisplayMedia: getSourceId argument is not a function");
    return;
  }
  window2.navigator.mediaDevices.getDisplayMedia = /* @__PURE__ */ __name(function getDisplayMedia(constraints) {
    return getSourceId(constraints).then((sourceId) => {
      const widthSpecified = constraints.video && constraints.video.width;
      const heightSpecified = constraints.video && constraints.video.height;
      const frameRateSpecified = constraints.video && constraints.video.frameRate;
      constraints.video = {
        mandatory: {
          chromeMediaSource: "desktop",
          chromeMediaSourceId: sourceId,
          maxFrameRate: frameRateSpecified || 3
        }
      };
      if (widthSpecified) {
        constraints.video.mandatory.maxWidth = widthSpecified;
      }
      if (heightSpecified) {
        constraints.video.mandatory.maxHeight = heightSpecified;
      }
      return window2.navigator.mediaDevices.getUserMedia(constraints);
    });
  }, "getDisplayMedia");
}
__name(shimGetDisplayMedia, "shimGetDisplayMedia");

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js
function shimMediaStream(window2) {
  window2.MediaStream = window2.MediaStream || window2.webkitMediaStream;
}
__name(shimMediaStream, "shimMediaStream");
function shimOnTrack(window2) {
  if (typeof window2 === "object" && window2.RTCPeerConnection && !("ontrack" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(f2) {
        if (this._ontrack) {
          this.removeEventListener("track", this._ontrack);
        }
        this.addEventListener("track", this._ontrack = f2);
      },
      enumerable: true,
      configurable: true
    });
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = /* @__PURE__ */ __name(function setRemoteDescription() {
      if (!this._ontrackpoly) {
        this._ontrackpoly = (e2) => {
          e2.stream.addEventListener("addtrack", (te) => {
            let receiver;
            if (window2.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === te.track.id);
            } else {
              receiver = { track: te.track };
            }
            const event = new Event("track");
            event.track = te.track;
            event.receiver = receiver;
            event.transceiver = { receiver };
            event.streams = [e2.stream];
            this.dispatchEvent(event);
          });
          e2.stream.getTracks().forEach((track) => {
            let receiver;
            if (window2.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === track.id);
            } else {
              receiver = { track };
            }
            const event = new Event("track");
            event.track = track;
            event.receiver = receiver;
            event.transceiver = { receiver };
            event.streams = [e2.stream];
            this.dispatchEvent(event);
          });
        };
        this.addEventListener("addstream", this._ontrackpoly);
      }
      return origSetRemoteDescription.apply(this, arguments);
    }, "setRemoteDescription");
  } else {
    wrapPeerConnectionEvent(window2, "track", (e2) => {
      if (!e2.transceiver) {
        Object.defineProperty(
          e2,
          "transceiver",
          { value: { receiver: e2.receiver } }
        );
      }
      return e2;
    });
  }
}
__name(shimOnTrack, "shimOnTrack");
function shimGetSendersWithDtmf(window2) {
  if (typeof window2 === "object" && window2.RTCPeerConnection && !("getSenders" in window2.RTCPeerConnection.prototype) && "createDTMFSender" in window2.RTCPeerConnection.prototype) {
    const shimSenderWithDtmf = /* @__PURE__ */ __name(function(pc, track) {
      return {
        track,
        get dtmf() {
          if (this._dtmf === void 0) {
            if (track.kind === "audio") {
              this._dtmf = pc.createDTMFSender(track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
        _pc: pc
      };
    }, "shimSenderWithDtmf");
    if (!window2.RTCPeerConnection.prototype.getSenders) {
      window2.RTCPeerConnection.prototype.getSenders = /* @__PURE__ */ __name(function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice();
      }, "getSenders");
      const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
      window2.RTCPeerConnection.prototype.addTrack = /* @__PURE__ */ __name(function addTrack(track, stream) {
        let sender = origAddTrack.apply(this, arguments);
        if (!sender) {
          sender = shimSenderWithDtmf(this, track);
          this._senders.push(sender);
        }
        return sender;
      }, "addTrack");
      const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
      window2.RTCPeerConnection.prototype.removeTrack = /* @__PURE__ */ __name(function removeTrack(sender) {
        origRemoveTrack.apply(this, arguments);
        const idx = this._senders.indexOf(sender);
        if (idx !== -1) {
          this._senders.splice(idx, 1);
        }
      }, "removeTrack");
    }
    const origAddStream = window2.RTCPeerConnection.prototype.addStream;
    window2.RTCPeerConnection.prototype.addStream = /* @__PURE__ */ __name(function addStream(stream) {
      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach((track) => {
        this._senders.push(shimSenderWithDtmf(this, track));
      });
    }, "addStream");
    const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
    window2.RTCPeerConnection.prototype.removeStream = /* @__PURE__ */ __name(function removeStream(stream) {
      this._senders = this._senders || [];
      origRemoveStream.apply(this, [stream]);
      stream.getTracks().forEach((track) => {
        const sender = this._senders.find((s2) => s2.track === track);
        if (sender) {
          this._senders.splice(this._senders.indexOf(sender), 1);
        }
      });
    }, "removeStream");
  } else if (typeof window2 === "object" && window2.RTCPeerConnection && "getSenders" in window2.RTCPeerConnection.prototype && "createDTMFSender" in window2.RTCPeerConnection.prototype && window2.RTCRtpSender && !("dtmf" in window2.RTCRtpSender.prototype)) {
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    window2.RTCPeerConnection.prototype.getSenders = /* @__PURE__ */ __name(function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    }, "getSenders");
    Object.defineProperty(window2.RTCRtpSender.prototype, "dtmf", {
      get() {
        if (this._dtmf === void 0) {
          if (this.track.kind === "audio") {
            this._dtmf = this._pc.createDTMFSender(this.track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
}
__name(shimGetSendersWithDtmf, "shimGetSendersWithDtmf");
function shimGetStats(window2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const origGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = /* @__PURE__ */ __name(function getStats() {
    const [selector, onSucc, onErr] = arguments;
    if (arguments.length > 0 && typeof selector === "function") {
      return origGetStats.apply(this, arguments);
    }
    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== "function")) {
      return origGetStats.apply(this, []);
    }
    const fixChromeStats_ = /* @__PURE__ */ __name(function(response) {
      const standardReport = {};
      const reports = response.result();
      reports.forEach((report) => {
        const standardStats = {
          id: report.id,
          timestamp: report.timestamp,
          type: {
            localcandidate: "local-candidate",
            remotecandidate: "remote-candidate"
          }[report.type] || report.type
        };
        report.names().forEach((name) => {
          standardStats[name] = report.stat(name);
        });
        standardReport[standardStats.id] = standardStats;
      });
      return standardReport;
    }, "fixChromeStats_");
    const makeMapStats = /* @__PURE__ */ __name(function(stats) {
      return new Map(Object.keys(stats).map((key) => [key, stats[key]]));
    }, "makeMapStats");
    if (arguments.length >= 2) {
      const successCallbackWrapper_ = /* @__PURE__ */ __name(function(response) {
        onSucc(makeMapStats(fixChromeStats_(response)));
      }, "successCallbackWrapper_");
      return origGetStats.apply(this, [
        successCallbackWrapper_,
        selector
      ]);
    }
    return new Promise((resolve, reject) => {
      origGetStats.apply(this, [
        function(response) {
          resolve(makeMapStats(fixChromeStats_(response)));
        },
        reject
      ]);
    }).then(onSucc, onErr);
  }, "getStats");
}
__name(shimGetStats, "shimGetStats");
function shimSenderReceiverGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender && window2.RTCRtpReceiver)) {
    return;
  }
  if (!("getStats" in window2.RTCRtpSender.prototype)) {
    const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window2.RTCPeerConnection.prototype.getSenders = /* @__PURE__ */ __name(function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      }, "getSenders");
    }
    const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window2.RTCPeerConnection.prototype.addTrack = /* @__PURE__ */ __name(function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      }, "addTrack");
    }
    window2.RTCRtpSender.prototype.getStats = /* @__PURE__ */ __name(function getStats() {
      const sender = this;
      return this._pc.getStats().then((result) => filterStats(result, sender.track, true));
    }, "getStats");
  }
  if (!("getStats" in window2.RTCRtpReceiver.prototype)) {
    const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window2.RTCPeerConnection.prototype.getReceivers = /* @__PURE__ */ __name(function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach((receiver) => receiver._pc = this);
        return receivers;
      }, "getReceivers");
    }
    wrapPeerConnectionEvent(window2, "track", (e2) => {
      e2.receiver._pc = e2.srcElement;
      return e2;
    });
    window2.RTCRtpReceiver.prototype.getStats = /* @__PURE__ */ __name(function getStats() {
      const receiver = this;
      return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));
    }, "getStats");
  }
  if (!("getStats" in window2.RTCRtpSender.prototype && "getStats" in window2.RTCRtpReceiver.prototype)) {
    return;
  }
  const origGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = /* @__PURE__ */ __name(function getStats() {
    if (arguments.length > 0 && arguments[0] instanceof window2.MediaStreamTrack) {
      const track = arguments[0];
      let sender;
      let receiver;
      let err;
      this.getSenders().forEach((s2) => {
        if (s2.track === track) {
          if (sender) {
            err = true;
          } else {
            sender = s2;
          }
        }
      });
      this.getReceivers().forEach((r2) => {
        if (r2.track === track) {
          if (receiver) {
            err = true;
          } else {
            receiver = r2;
          }
        }
        return r2.track === track;
      });
      if (err || sender && receiver) {
        return Promise.reject(new DOMException(
          "There are more than one sender or receiver for the track.",
          "InvalidAccessError"
        ));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException(
        "There is no sender or receiver for the track.",
        "InvalidAccessError"
      ));
    }
    return origGetStats.apply(this, arguments);
  }, "getStats");
}
__name(shimSenderReceiverGetStats, "shimSenderReceiverGetStats");
function shimAddTrackRemoveTrackWithNative(window2) {
  window2.RTCPeerConnection.prototype.getLocalStreams = /* @__PURE__ */ __name(function getLocalStreams() {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);
  }, "getLocalStreams");
  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
  window2.RTCPeerConnection.prototype.addTrack = /* @__PURE__ */ __name(function addTrack(track, stream) {
    if (!stream) {
      return origAddTrack.apply(this, arguments);
    }
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const sender = origAddTrack.apply(this, arguments);
    if (!this._shimmedLocalStreams[stream.id]) {
      this._shimmedLocalStreams[stream.id] = [stream, sender];
    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
      this._shimmedLocalStreams[stream.id].push(sender);
    }
    return sender;
  }, "addTrack");
  const origAddStream = window2.RTCPeerConnection.prototype.addStream;
  window2.RTCPeerConnection.prototype.addStream = /* @__PURE__ */ __name(function addStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    stream.getTracks().forEach((track) => {
      const alreadyExists = this.getSenders().find((s2) => s2.track === track);
      if (alreadyExists) {
        throw new DOMException(
          "Track already exists.",
          "InvalidAccessError"
        );
      }
    });
    const existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  }, "addStream");
  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
  window2.RTCPeerConnection.prototype.removeStream = /* @__PURE__ */ __name(function removeStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    delete this._shimmedLocalStreams[stream.id];
    return origRemoveStream.apply(this, arguments);
  }, "removeStream");
  const origRemoveTrack = window2.RTCPeerConnection.prototype.removeTrack;
  window2.RTCPeerConnection.prototype.removeTrack = /* @__PURE__ */ __name(function removeTrack(sender) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    if (sender) {
      Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
        if (idx !== -1) {
          this._shimmedLocalStreams[streamId].splice(idx, 1);
        }
        if (this._shimmedLocalStreams[streamId].length === 1) {
          delete this._shimmedLocalStreams[streamId];
        }
      });
    }
    return origRemoveTrack.apply(this, arguments);
  }, "removeTrack");
}
__name(shimAddTrackRemoveTrackWithNative, "shimAddTrackRemoveTrackWithNative");
function shimAddTrackRemoveTrack(window2, browserDetails) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (window2.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window2);
  }
  const origGetLocalStreams = window2.RTCPeerConnection.prototype.getLocalStreams;
  window2.RTCPeerConnection.prototype.getLocalStreams = /* @__PURE__ */ __name(function getLocalStreams() {
    const nativeStreams = origGetLocalStreams.apply(this);
    this._reverseStreams = this._reverseStreams || {};
    return nativeStreams.map((stream) => this._reverseStreams[stream.id]);
  }, "getLocalStreams");
  const origAddStream = window2.RTCPeerConnection.prototype.addStream;
  window2.RTCPeerConnection.prototype.addStream = /* @__PURE__ */ __name(function addStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    stream.getTracks().forEach((track) => {
      const alreadyExists = this.getSenders().find((s2) => s2.track === track);
      if (alreadyExists) {
        throw new DOMException(
          "Track already exists.",
          "InvalidAccessError"
        );
      }
    });
    if (!this._reverseStreams[stream.id]) {
      const newStream = new window2.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  }, "addStream");
  const origRemoveStream = window2.RTCPeerConnection.prototype.removeStream;
  window2.RTCPeerConnection.prototype.removeStream = /* @__PURE__ */ __name(function removeStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
    delete this._streams[stream.id];
  }, "removeStream");
  window2.RTCPeerConnection.prototype.addTrack = /* @__PURE__ */ __name(function addTrack(track, stream) {
    if (this.signalingState === "closed") {
      throw new DOMException(
        "The RTCPeerConnection's signalingState is 'closed'.",
        "InvalidStateError"
      );
    }
    const streams = [].slice.call(arguments, 1);
    if (streams.length !== 1 || !streams[0].getTracks().find((t2) => t2 === track)) {
      throw new DOMException(
        "The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.",
        "NotSupportedError"
      );
    }
    const alreadyExists = this.getSenders().find((s2) => s2.track === track);
    if (alreadyExists) {
      throw new DOMException(
        "Track already exists.",
        "InvalidAccessError"
      );
    }
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    const oldStream = this._streams[stream.id];
    if (oldStream) {
      oldStream.addTrack(track);
      Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    } else {
      const newStream = new window2.MediaStream([track]);
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      this.addStream(newStream);
    }
    return this.getSenders().find((s2) => s2.track === track);
  }, "addTrack");
  function replaceInternalStreamId(pc, description) {
    let sdp2 = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc._reverseStreams[internalId];
      const internalStream = pc._streams[externalStream.id];
      sdp2 = sdp2.replace(
        new RegExp(internalStream.id, "g"),
        externalStream.id
      );
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp2
    });
  }
  __name(replaceInternalStreamId, "replaceInternalStreamId");
  function replaceExternalStreamId(pc, description) {
    let sdp2 = description.sdp;
    Object.keys(pc._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc._reverseStreams[internalId];
      const internalStream = pc._streams[externalStream.id];
      sdp2 = sdp2.replace(
        new RegExp(externalStream.id, "g"),
        internalStream.id
      );
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp2
    });
  }
  __name(replaceExternalStreamId, "replaceExternalStreamId");
  ["createOffer", "createAnswer"].forEach(function(method) {
    const nativeMethod = window2.RTCPeerConnection.prototype[method];
    const methodObj = { [method]() {
      const args = arguments;
      const isLegacyCall = arguments.length && typeof arguments[0] === "function";
      if (isLegacyCall) {
        return nativeMethod.apply(this, [
          (description) => {
            const desc = replaceInternalStreamId(this, description);
            args[0].apply(null, [desc]);
          },
          (err) => {
            if (args[1]) {
              args[1].apply(null, err);
            }
          },
          arguments[2]
        ]);
      }
      return nativeMethod.apply(this, arguments).then((description) => replaceInternalStreamId(this, description));
    } };
    window2.RTCPeerConnection.prototype[method] = methodObj[method];
  });
  const origSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
  window2.RTCPeerConnection.prototype.setLocalDescription = /* @__PURE__ */ __name(function setLocalDescription() {
    if (!arguments.length || !arguments[0].type) {
      return origSetLocalDescription.apply(this, arguments);
    }
    arguments[0] = replaceExternalStreamId(this, arguments[0]);
    return origSetLocalDescription.apply(this, arguments);
  }, "setLocalDescription");
  const origLocalDescription = Object.getOwnPropertyDescriptor(
    window2.RTCPeerConnection.prototype,
    "localDescription"
  );
  Object.defineProperty(
    window2.RTCPeerConnection.prototype,
    "localDescription",
    {
      get() {
        const description = origLocalDescription.get.apply(this);
        if (description.type === "") {
          return description;
        }
        return replaceInternalStreamId(this, description);
      }
    }
  );
  window2.RTCPeerConnection.prototype.removeTrack = /* @__PURE__ */ __name(function removeTrack(sender) {
    if (this.signalingState === "closed") {
      throw new DOMException(
        "The RTCPeerConnection's signalingState is 'closed'.",
        "InvalidStateError"
      );
    }
    if (!sender._pc) {
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    }
    const isLocal = sender._pc === this;
    if (!isLocal) {
      throw new DOMException(
        "Sender was not created by this connection.",
        "InvalidAccessError"
      );
    }
    this._streams = this._streams || {};
    let stream;
    Object.keys(this._streams).forEach((streamid) => {
      const hasTrack = this._streams[streamid].getTracks().find((track) => sender.track === track);
      if (hasTrack) {
        stream = this._streams[streamid];
      }
    });
    if (stream) {
      if (stream.getTracks().length === 1) {
        this.removeStream(this._reverseStreams[stream.id]);
      } else {
        stream.removeTrack(sender.track);
      }
      this.dispatchEvent(new Event("negotiationneeded"));
    }
  }, "removeTrack");
}
__name(shimAddTrackRemoveTrack, "shimAddTrackRemoveTrack");
function shimPeerConnection(window2, browserDetails) {
  if (!window2.RTCPeerConnection && window2.webkitRTCPeerConnection) {
    window2.RTCPeerConnection = window2.webkitRTCPeerConnection;
  }
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (browserDetails.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = { [method]() {
        arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      } };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
}
__name(shimPeerConnection, "shimPeerConnection");
function fixNegotiationNeeded(window2, browserDetails) {
  wrapPeerConnectionEvent(window2, "negotiationneeded", (e2) => {
    const pc = e2.target;
    if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === "plan-b") {
      if (pc.signalingState !== "stable") {
        return;
      }
    }
    return e2;
  });
}
__name(fixNegotiationNeeded, "fixNegotiationNeeded");

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js
var firefox_shim_exports = {};
__export(firefox_shim_exports, {
  shimAddTransceiver: () => shimAddTransceiver,
  shimCreateAnswer: () => shimCreateAnswer,
  shimCreateOffer: () => shimCreateOffer,
  shimGetDisplayMedia: () => shimGetDisplayMedia2,
  shimGetParameters: () => shimGetParameters,
  shimGetUserMedia: () => shimGetUserMedia2,
  shimOnTrack: () => shimOnTrack2,
  shimPeerConnection: () => shimPeerConnection2,
  shimRTCDataChannel: () => shimRTCDataChannel,
  shimReceiverGetStats: () => shimReceiverGetStats,
  shimRemoveStream: () => shimRemoveStream,
  shimSenderGetStats: () => shimSenderGetStats
});
init_define_process();

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/firefox/getusermedia.js
init_define_process();
function shimGetUserMedia2(window2, browserDetails) {
  const navigator2 = window2 && window2.navigator;
  const MediaStreamTrack = window2 && window2.MediaStreamTrack;
  navigator2.getUserMedia = function(constraints, onSuccess, onError) {
    deprecated(
      "navigator.getUserMedia",
      "navigator.mediaDevices.getUserMedia"
    );
    navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
  if (!(browserDetails.version > 55 && "autoGainControl" in navigator2.mediaDevices.getSupportedConstraints())) {
    const remap = /* @__PURE__ */ __name(function(obj, a2, b2) {
      if (a2 in obj && !(b2 in obj)) {
        obj[b2] = obj[a2];
        delete obj[a2];
      }
    }, "remap");
    const nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(c2) {
      if (typeof c2 === "object" && typeof c2.audio === "object") {
        c2 = JSON.parse(JSON.stringify(c2));
        remap(c2.audio, "autoGainControl", "mozAutoGainControl");
        remap(c2.audio, "noiseSuppression", "mozNoiseSuppression");
      }
      return nativeGetUserMedia(c2);
    };
    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        const obj = nativeGetSettings.apply(this, arguments);
        remap(obj, "mozAutoGainControl", "autoGainControl");
        remap(obj, "mozNoiseSuppression", "noiseSuppression");
        return obj;
      };
    }
    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c2) {
        if (this.kind === "audio" && typeof c2 === "object") {
          c2 = JSON.parse(JSON.stringify(c2));
          remap(c2, "autoGainControl", "mozAutoGainControl");
          remap(c2, "noiseSuppression", "mozNoiseSuppression");
        }
        return nativeApplyConstraints.apply(this, [c2]);
      };
    }
  }
}
__name(shimGetUserMedia2, "shimGetUserMedia");

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js
init_define_process();
function shimGetDisplayMedia2(window2, preferredMediaSource) {
  if (window2.navigator.mediaDevices && "getDisplayMedia" in window2.navigator.mediaDevices) {
    return;
  }
  if (!window2.navigator.mediaDevices) {
    return;
  }
  window2.navigator.mediaDevices.getDisplayMedia = /* @__PURE__ */ __name(function getDisplayMedia(constraints) {
    if (!(constraints && constraints.video)) {
      const err = new DOMException("getDisplayMedia without video constraints is undefined");
      err.name = "NotFoundError";
      err.code = 8;
      return Promise.reject(err);
    }
    if (constraints.video === true) {
      constraints.video = { mediaSource: preferredMediaSource };
    } else {
      constraints.video.mediaSource = preferredMediaSource;
    }
    return window2.navigator.mediaDevices.getUserMedia(constraints);
  }, "getDisplayMedia");
}
__name(shimGetDisplayMedia2, "shimGetDisplayMedia");

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js
function shimOnTrack2(window2) {
  if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
    Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return { receiver: this.receiver };
      }
    });
  }
}
__name(shimOnTrack2, "shimOnTrack");
function shimPeerConnection2(window2, browserDetails) {
  if (typeof window2 !== "object" || !(window2.RTCPeerConnection || window2.mozRTCPeerConnection)) {
    return;
  }
  if (!window2.RTCPeerConnection && window2.mozRTCPeerConnection) {
    window2.RTCPeerConnection = window2.mozRTCPeerConnection;
  }
  if (browserDetails.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window2.RTCPeerConnection.prototype[method];
      const methodObj = { [method]() {
        arguments[0] = new (method === "addIceCandidate" ? window2.RTCIceCandidate : window2.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      } };
      window2.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
  const modernStatsTypes = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  };
  const nativeGetStats = window2.RTCPeerConnection.prototype.getStats;
  window2.RTCPeerConnection.prototype.getStats = /* @__PURE__ */ __name(function getStats() {
    const [selector, onSucc, onErr] = arguments;
    return nativeGetStats.apply(this, [selector || null]).then((stats) => {
      if (browserDetails.version < 53 && !onSucc) {
        try {
          stats.forEach((stat) => {
            stat.type = modernStatsTypes[stat.type] || stat.type;
          });
        } catch (e2) {
          if (e2.name !== "TypeError") {
            throw e2;
          }
          stats.forEach((stat, i2) => {
            stats.set(i2, Object.assign({}, stat, {
              type: modernStatsTypes[stat.type] || stat.type
            }));
          });
        }
      }
      return stats;
    }).then(onSucc, onErr);
  }, "getStats");
}
__name(shimPeerConnection2, "shimPeerConnection");
function shimSenderGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
    return;
  }
  if (window2.RTCRtpSender && "getStats" in window2.RTCRtpSender.prototype) {
    return;
  }
  const origGetSenders = window2.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window2.RTCPeerConnection.prototype.getSenders = /* @__PURE__ */ __name(function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    }, "getSenders");
  }
  const origAddTrack = window2.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window2.RTCPeerConnection.prototype.addTrack = /* @__PURE__ */ __name(function addTrack() {
      const sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    }, "addTrack");
  }
  window2.RTCRtpSender.prototype.getStats = /* @__PURE__ */ __name(function getStats() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  }, "getStats");
}
__name(shimSenderGetStats, "shimSenderGetStats");
function shimReceiverGetStats(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection && window2.RTCRtpSender)) {
    return;
  }
  if (window2.RTCRtpSender && "getStats" in window2.RTCRtpReceiver.prototype) {
    return;
  }
  const origGetReceivers = window2.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window2.RTCPeerConnection.prototype.getReceivers = /* @__PURE__ */ __name(function getReceivers() {
      const receivers = origGetReceivers.apply(this, []);
      receivers.forEach((receiver) => receiver._pc = this);
      return receivers;
    }, "getReceivers");
  }
  wrapPeerConnectionEvent(window2, "track", (e2) => {
    e2.receiver._pc = e2.srcElement;
    return e2;
  });
  window2.RTCRtpReceiver.prototype.getStats = /* @__PURE__ */ __name(function getStats() {
    return this._pc.getStats(this.track);
  }, "getStats");
}
__name(shimReceiverGetStats, "shimReceiverGetStats");
function shimRemoveStream(window2) {
  if (!window2.RTCPeerConnection || "removeStream" in window2.RTCPeerConnection.prototype) {
    return;
  }
  window2.RTCPeerConnection.prototype.removeStream = /* @__PURE__ */ __name(function removeStream(stream) {
    deprecated("removeStream", "removeTrack");
    this.getSenders().forEach((sender) => {
      if (sender.track && stream.getTracks().includes(sender.track)) {
        this.removeTrack(sender);
      }
    });
  }, "removeStream");
}
__name(shimRemoveStream, "shimRemoveStream");
function shimRTCDataChannel(window2) {
  if (window2.DataChannel && !window2.RTCDataChannel) {
    window2.RTCDataChannel = window2.DataChannel;
  }
}
__name(shimRTCDataChannel, "shimRTCDataChannel");
function shimAddTransceiver(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origAddTransceiver = window2.RTCPeerConnection.prototype.addTransceiver;
  if (origAddTransceiver) {
    window2.RTCPeerConnection.prototype.addTransceiver = /* @__PURE__ */ __name(function addTransceiver() {
      this.setParametersPromises = [];
      let sendEncodings = arguments[1] && arguments[1].sendEncodings;
      if (sendEncodings === void 0) {
        sendEncodings = [];
      }
      sendEncodings = [...sendEncodings];
      const shouldPerformCheck = sendEncodings.length > 0;
      if (shouldPerformCheck) {
        sendEncodings.forEach((encodingParam) => {
          if ("rid" in encodingParam) {
            const ridRegex = /^[a-z0-9]{0,16}$/i;
            if (!ridRegex.test(encodingParam.rid)) {
              throw new TypeError("Invalid RID value provided.");
            }
          }
          if ("scaleResolutionDownBy" in encodingParam) {
            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            }
          }
          if ("maxFramerate" in encodingParam) {
            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
              throw new RangeError("max_framerate must be >= 0.0");
            }
          }
        });
      }
      const transceiver = origAddTransceiver.apply(this, arguments);
      if (shouldPerformCheck) {
        const { sender } = transceiver;
        const params = sender.getParameters();
        if (!("encodings" in params) || params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
          params.encodings = sendEncodings;
          sender.sendEncodings = sendEncodings;
          this.setParametersPromises.push(
            sender.setParameters(params).then(() => {
              delete sender.sendEncodings;
            }).catch(() => {
              delete sender.sendEncodings;
            })
          );
        }
      }
      return transceiver;
    }, "addTransceiver");
  }
}
__name(shimAddTransceiver, "shimAddTransceiver");
function shimGetParameters(window2) {
  if (!(typeof window2 === "object" && window2.RTCRtpSender)) {
    return;
  }
  const origGetParameters = window2.RTCRtpSender.prototype.getParameters;
  if (origGetParameters) {
    window2.RTCRtpSender.prototype.getParameters = /* @__PURE__ */ __name(function getParameters() {
      const params = origGetParameters.apply(this, arguments);
      if (!("encodings" in params)) {
        params.encodings = [].concat(this.sendEncodings || [{}]);
      }
      return params;
    }, "getParameters");
  }
}
__name(shimGetParameters, "shimGetParameters");
function shimCreateOffer(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
  window2.RTCPeerConnection.prototype.createOffer = /* @__PURE__ */ __name(function createOffer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateOffer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateOffer.apply(this, arguments);
  }, "createOffer");
}
__name(shimCreateOffer, "shimCreateOffer");
function shimCreateAnswer(window2) {
  if (!(typeof window2 === "object" && window2.RTCPeerConnection)) {
    return;
  }
  const origCreateAnswer = window2.RTCPeerConnection.prototype.createAnswer;
  window2.RTCPeerConnection.prototype.createAnswer = /* @__PURE__ */ __name(function createAnswer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateAnswer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateAnswer.apply(this, arguments);
  }, "createAnswer");
}
__name(shimCreateAnswer, "shimCreateAnswer");

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/safari/safari_shim.js
var safari_shim_exports = {};
__export(safari_shim_exports, {
  shimAudioContext: () => shimAudioContext,
  shimCallbacksAPI: () => shimCallbacksAPI,
  shimConstraints: () => shimConstraints,
  shimCreateOfferLegacy: () => shimCreateOfferLegacy,
  shimGetUserMedia: () => shimGetUserMedia3,
  shimLocalStreamsAPI: () => shimLocalStreamsAPI,
  shimRTCIceServerUrls: () => shimRTCIceServerUrls,
  shimRemoteStreamsAPI: () => shimRemoteStreamsAPI,
  shimTrackEventTransceiver: () => shimTrackEventTransceiver
});
init_define_process();
function shimLocalStreamsAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  if (!("getLocalStreams" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.getLocalStreams = /* @__PURE__ */ __name(function getLocalStreams() {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      return this._localStreams;
    }, "getLocalStreams");
  }
  if (!("addStream" in window2.RTCPeerConnection.prototype)) {
    const _addTrack = window2.RTCPeerConnection.prototype.addTrack;
    window2.RTCPeerConnection.prototype.addStream = /* @__PURE__ */ __name(function addStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      stream.getAudioTracks().forEach((track) => _addTrack.call(
        this,
        track,
        stream
      ));
      stream.getVideoTracks().forEach((track) => _addTrack.call(
        this,
        track,
        stream
      ));
    }, "addStream");
    window2.RTCPeerConnection.prototype.addTrack = /* @__PURE__ */ __name(function addTrack(track, ...streams) {
      if (streams) {
        streams.forEach((stream) => {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (!this._localStreams.includes(stream)) {
            this._localStreams.push(stream);
          }
        });
      }
      return _addTrack.apply(this, arguments);
    }, "addTrack");
  }
  if (!("removeStream" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.removeStream = /* @__PURE__ */ __name(function removeStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      const index = this._localStreams.indexOf(stream);
      if (index === -1) {
        return;
      }
      this._localStreams.splice(index, 1);
      const tracks2 = stream.getTracks();
      this.getSenders().forEach((sender) => {
        if (tracks2.includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    }, "removeStream");
  }
}
__name(shimLocalStreamsAPI, "shimLocalStreamsAPI");
function shimRemoteStreamsAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  if (!("getRemoteStreams" in window2.RTCPeerConnection.prototype)) {
    window2.RTCPeerConnection.prototype.getRemoteStreams = /* @__PURE__ */ __name(function getRemoteStreams() {
      return this._remoteStreams ? this._remoteStreams : [];
    }, "getRemoteStreams");
  }
  if (!("onaddstream" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(f2) {
        if (this._onaddstream) {
          this.removeEventListener("addstream", this._onaddstream);
          this.removeEventListener("track", this._onaddstreampoly);
        }
        this.addEventListener("addstream", this._onaddstream = f2);
        this.addEventListener("track", this._onaddstreampoly = (e2) => {
          e2.streams.forEach((stream) => {
            if (!this._remoteStreams) {
              this._remoteStreams = [];
            }
            if (this._remoteStreams.includes(stream)) {
              return;
            }
            this._remoteStreams.push(stream);
            const event = new Event("addstream");
            event.stream = stream;
            this.dispatchEvent(event);
          });
        });
      }
    });
    const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
    window2.RTCPeerConnection.prototype.setRemoteDescription = /* @__PURE__ */ __name(function setRemoteDescription() {
      const pc = this;
      if (!this._onaddstreampoly) {
        this.addEventListener("track", this._onaddstreampoly = function(e2) {
          e2.streams.forEach((stream) => {
            if (!pc._remoteStreams) {
              pc._remoteStreams = [];
            }
            if (pc._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            pc._remoteStreams.push(stream);
            const event = new Event("addstream");
            event.stream = stream;
            pc.dispatchEvent(event);
          });
        });
      }
      return origSetRemoteDescription.apply(pc, arguments);
    }, "setRemoteDescription");
  }
}
__name(shimRemoteStreamsAPI, "shimRemoteStreamsAPI");
function shimCallbacksAPI(window2) {
  if (typeof window2 !== "object" || !window2.RTCPeerConnection) {
    return;
  }
  const prototype = window2.RTCPeerConnection.prototype;
  const origCreateOffer = prototype.createOffer;
  const origCreateAnswer = prototype.createAnswer;
  const setLocalDescription = prototype.setLocalDescription;
  const setRemoteDescription = prototype.setRemoteDescription;
  const addIceCandidate = prototype.addIceCandidate;
  prototype.createOffer = /* @__PURE__ */ __name(function createOffer(successCallback, failureCallback) {
    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateOffer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  }, "createOffer");
  prototype.createAnswer = /* @__PURE__ */ __name(function createAnswer(successCallback, failureCallback) {
    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateAnswer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  }, "createAnswer");
  let withCallback = /* @__PURE__ */ __name(function(description, successCallback, failureCallback) {
    const promise = setLocalDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  }, "withCallback");
  prototype.setLocalDescription = withCallback;
  withCallback = /* @__PURE__ */ __name(function(description, successCallback, failureCallback) {
    const promise = setRemoteDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  }, "withCallback");
  prototype.setRemoteDescription = withCallback;
  withCallback = /* @__PURE__ */ __name(function(candidate, successCallback, failureCallback) {
    const promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  }, "withCallback");
  prototype.addIceCandidate = withCallback;
}
__name(shimCallbacksAPI, "shimCallbacksAPI");
function shimGetUserMedia3(window2) {
  const navigator2 = window2 && window2.navigator;
  if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    const mediaDevices = navigator2.mediaDevices;
    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator2.mediaDevices.getUserMedia = (constraints) => {
      return _getUserMedia(shimConstraints(constraints));
    };
  }
  if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    navigator2.getUserMedia = (/* @__PURE__ */ __name(function getUserMedia(constraints, cb, errcb) {
      navigator2.mediaDevices.getUserMedia(constraints).then(cb, errcb);
    }, "getUserMedia")).bind(navigator2);
  }
}
__name(shimGetUserMedia3, "shimGetUserMedia");
function shimConstraints(constraints) {
  if (constraints && constraints.video !== void 0) {
    return Object.assign(
      {},
      constraints,
      { video: compactObject(constraints.video) }
    );
  }
  return constraints;
}
__name(shimConstraints, "shimConstraints");
function shimRTCIceServerUrls(window2) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  const OrigPeerConnection = window2.RTCPeerConnection;
  window2.RTCPeerConnection = /* @__PURE__ */ __name(function RTCPeerConnection2(pcConfig, pcConstraints) {
    if (pcConfig && pcConfig.iceServers) {
      const newIceServers = [];
      for (let i2 = 0; i2 < pcConfig.iceServers.length; i2++) {
        let server = pcConfig.iceServers[i2];
        if (!server.hasOwnProperty("urls") && server.hasOwnProperty("url")) {
          deprecated("RTCIceServer.url", "RTCIceServer.urls");
          server = JSON.parse(JSON.stringify(server));
          server.urls = server.url;
          delete server.url;
          newIceServers.push(server);
        } else {
          newIceServers.push(pcConfig.iceServers[i2]);
        }
      }
      pcConfig.iceServers = newIceServers;
    }
    return new OrigPeerConnection(pcConfig, pcConstraints);
  }, "RTCPeerConnection");
  window2.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  if ("generateCertificate" in OrigPeerConnection) {
    Object.defineProperty(window2.RTCPeerConnection, "generateCertificate", {
      get() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
}
__name(shimRTCIceServerUrls, "shimRTCIceServerUrls");
function shimTrackEventTransceiver(window2) {
  if (typeof window2 === "object" && window2.RTCTrackEvent && "receiver" in window2.RTCTrackEvent.prototype && !("transceiver" in window2.RTCTrackEvent.prototype)) {
    Object.defineProperty(window2.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return { receiver: this.receiver };
      }
    });
  }
}
__name(shimTrackEventTransceiver, "shimTrackEventTransceiver");
function shimCreateOfferLegacy(window2) {
  const origCreateOffer = window2.RTCPeerConnection.prototype.createOffer;
  window2.RTCPeerConnection.prototype.createOffer = /* @__PURE__ */ __name(function createOffer(offerOptions) {
    if (offerOptions) {
      if (typeof offerOptions.offerToReceiveAudio !== "undefined") {
        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
      }
      const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "audio");
      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
        if (audioTransceiver.direction === "sendrecv") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("sendonly");
          } else {
            audioTransceiver.direction = "sendonly";
          }
        } else if (audioTransceiver.direction === "recvonly") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("inactive");
          } else {
            audioTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
        this.addTransceiver("audio", { direction: "recvonly" });
      }
      if (typeof offerOptions.offerToReceiveVideo !== "undefined") {
        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
      }
      const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "video");
      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
        if (videoTransceiver.direction === "sendrecv") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("sendonly");
          } else {
            videoTransceiver.direction = "sendonly";
          }
        } else if (videoTransceiver.direction === "recvonly") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("inactive");
          } else {
            videoTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
        this.addTransceiver("video", { direction: "recvonly" });
      }
    }
    return origCreateOffer.apply(this, arguments);
  }, "createOffer");
}
__name(shimCreateOfferLegacy, "shimCreateOfferLegacy");
function shimAudioContext(window2) {
  if (typeof window2 !== "object" || window2.AudioContext) {
    return;
  }
  window2.AudioContext = window2.webkitAudioContext;
}
__name(shimAudioContext, "shimAudioContext");

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/common_shim.js
var common_shim_exports = {};
__export(common_shim_exports, {
  removeExtmapAllowMixed: () => removeExtmapAllowMixed,
  shimAddIceCandidateNullOrEmpty: () => shimAddIceCandidateNullOrEmpty,
  shimConnectionState: () => shimConnectionState,
  shimMaxMessageSize: () => shimMaxMessageSize,
  shimParameterlessSetLocalDescription: () => shimParameterlessSetLocalDescription,
  shimRTCIceCandidate: () => shimRTCIceCandidate,
  shimRTCIceCandidateRelayProtocol: () => shimRTCIceCandidateRelayProtocol,
  shimSendThrowTypeError: () => shimSendThrowTypeError
});
init_define_process();
var import_sdp = __toESM(require_sdp());
function shimRTCIceCandidate(window2) {
  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "foundation" in window2.RTCIceCandidate.prototype) {
    return;
  }
  const NativeRTCIceCandidate = window2.RTCIceCandidate;
  window2.RTCIceCandidate = /* @__PURE__ */ __name(function RTCIceCandidate2(args) {
    if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substr(2);
    }
    if (args.candidate && args.candidate.length) {
      const nativeCandidate = new NativeRTCIceCandidate(args);
      const parsedCandidate = import_sdp.default.parseCandidate(args.candidate);
      const augmentedCandidate = Object.assign(
        nativeCandidate,
        parsedCandidate
      );
      augmentedCandidate.toJSON = /* @__PURE__ */ __name(function toJSON() {
        return {
          candidate: augmentedCandidate.candidate,
          sdpMid: augmentedCandidate.sdpMid,
          sdpMLineIndex: augmentedCandidate.sdpMLineIndex,
          usernameFragment: augmentedCandidate.usernameFragment
        };
      }, "toJSON");
      return augmentedCandidate;
    }
    return new NativeRTCIceCandidate(args);
  }, "RTCIceCandidate");
  window2.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
  wrapPeerConnectionEvent(window2, "icecandidate", (e2) => {
    if (e2.candidate) {
      Object.defineProperty(e2, "candidate", {
        value: new window2.RTCIceCandidate(e2.candidate),
        writable: "false"
      });
    }
    return e2;
  });
}
__name(shimRTCIceCandidate, "shimRTCIceCandidate");
function shimRTCIceCandidateRelayProtocol(window2) {
  if (!window2.RTCIceCandidate || window2.RTCIceCandidate && "relayProtocol" in window2.RTCIceCandidate.prototype) {
    return;
  }
  wrapPeerConnectionEvent(window2, "icecandidate", (e2) => {
    if (e2.candidate) {
      const parsedCandidate = import_sdp.default.parseCandidate(e2.candidate.candidate);
      if (parsedCandidate.type === "relay") {
        e2.candidate.relayProtocol = {
          0: "tls",
          1: "tcp",
          2: "udp"
        }[parsedCandidate.priority >> 24];
      }
    }
    return e2;
  });
}
__name(shimRTCIceCandidateRelayProtocol, "shimRTCIceCandidateRelayProtocol");
function shimMaxMessageSize(window2, browserDetails) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (!("sctp" in window2.RTCPeerConnection.prototype)) {
    Object.defineProperty(window2.RTCPeerConnection.prototype, "sctp", {
      get() {
        return typeof this._sctp === "undefined" ? null : this._sctp;
      }
    });
  }
  const sctpInDescription = /* @__PURE__ */ __name(function(description) {
    if (!description || !description.sdp) {
      return false;
    }
    const sections = import_sdp.default.splitSections(description.sdp);
    sections.shift();
    return sections.some((mediaSection) => {
      const mLine = import_sdp.default.parseMLine(mediaSection);
      return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
    });
  }, "sctpInDescription");
  const getRemoteFirefoxVersion = /* @__PURE__ */ __name(function(description) {
    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    const version = parseInt(match[1], 10);
    return version !== version ? -1 : version;
  }, "getRemoteFirefoxVersion");
  const getCanSendMaxMessageSize = /* @__PURE__ */ __name(function(remoteIsFirefox) {
    let canSendMaxMessageSize = 65536;
    if (browserDetails.browser === "firefox") {
      if (browserDetails.version < 57) {
        if (remoteIsFirefox === -1) {
          canSendMaxMessageSize = 16384;
        } else {
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails.version < 60) {
        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
      } else {
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  }, "getCanSendMaxMessageSize");
  const getMaxMessageSize = /* @__PURE__ */ __name(function(description, remoteIsFirefox) {
    let maxMessageSize = 65536;
    if (browserDetails.browser === "firefox" && browserDetails.version === 57) {
      maxMessageSize = 65535;
    }
    const match = import_sdp.default.matchPrefix(
      description.sdp,
      "a=max-message-size:"
    );
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substr(19), 10);
    } else if (browserDetails.browser === "firefox" && remoteIsFirefox !== -1) {
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  }, "getMaxMessageSize");
  const origSetRemoteDescription = window2.RTCPeerConnection.prototype.setRemoteDescription;
  window2.RTCPeerConnection.prototype.setRemoteDescription = /* @__PURE__ */ __name(function setRemoteDescription() {
    this._sctp = null;
    if (browserDetails.browser === "chrome" && browserDetails.version >= 76) {
      const { sdpSemantics } = this.getConfiguration();
      if (sdpSemantics === "plan-b") {
        Object.defineProperty(this, "sctp", {
          get() {
            return typeof this._sctp === "undefined" ? null : this._sctp;
          },
          enumerable: true,
          configurable: true
        });
      }
    }
    if (sctpInDescription(arguments[0])) {
      const isFirefox = getRemoteFirefoxVersion(arguments[0]);
      const canSendMMS = getCanSendMaxMessageSize(isFirefox);
      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);
      let maxMessageSize;
      if (canSendMMS === 0 && remoteMMS === 0) {
        maxMessageSize = Number.POSITIVE_INFINITY;
      } else if (canSendMMS === 0 || remoteMMS === 0) {
        maxMessageSize = Math.max(canSendMMS, remoteMMS);
      } else {
        maxMessageSize = Math.min(canSendMMS, remoteMMS);
      }
      const sctp = {};
      Object.defineProperty(sctp, "maxMessageSize", {
        get() {
          return maxMessageSize;
        }
      });
      this._sctp = sctp;
    }
    return origSetRemoteDescription.apply(this, arguments);
  }, "setRemoteDescription");
}
__name(shimMaxMessageSize, "shimMaxMessageSize");
function shimSendThrowTypeError(window2) {
  if (!(window2.RTCPeerConnection && "createDataChannel" in window2.RTCPeerConnection.prototype)) {
    return;
  }
  function wrapDcSend(dc, pc) {
    const origDataChannelSend = dc.send;
    dc.send = /* @__PURE__ */ __name(function send() {
      const data = arguments[0];
      const length = data.length || data.size || data.byteLength;
      if (dc.readyState === "open" && pc.sctp && length > pc.sctp.maxMessageSize) {
        throw new TypeError("Message too large (can send a maximum of " + pc.sctp.maxMessageSize + " bytes)");
      }
      return origDataChannelSend.apply(dc, arguments);
    }, "send");
  }
  __name(wrapDcSend, "wrapDcSend");
  const origCreateDataChannel = window2.RTCPeerConnection.prototype.createDataChannel;
  window2.RTCPeerConnection.prototype.createDataChannel = /* @__PURE__ */ __name(function createDataChannel() {
    const dataChannel = origCreateDataChannel.apply(this, arguments);
    wrapDcSend(dataChannel, this);
    return dataChannel;
  }, "createDataChannel");
  wrapPeerConnectionEvent(window2, "datachannel", (e2) => {
    wrapDcSend(e2.channel, e2.target);
    return e2;
  });
}
__name(shimSendThrowTypeError, "shimSendThrowTypeError");
function shimConnectionState(window2) {
  if (!window2.RTCPeerConnection || "connectionState" in window2.RTCPeerConnection.prototype) {
    return;
  }
  const proto = window2.RTCPeerConnection.prototype;
  Object.defineProperty(proto, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(proto, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(cb) {
      if (this._onconnectionstatechange) {
        this.removeEventListener(
          "connectionstatechange",
          this._onconnectionstatechange
        );
        delete this._onconnectionstatechange;
      }
      if (cb) {
        this.addEventListener(
          "connectionstatechange",
          this._onconnectionstatechange = cb
        );
      }
    },
    enumerable: true,
    configurable: true
  });
  ["setLocalDescription", "setRemoteDescription"].forEach((method) => {
    const origMethod = proto[method];
    proto[method] = function() {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = (e2) => {
          const pc = e2.target;
          if (pc._lastConnectionState !== pc.connectionState) {
            pc._lastConnectionState = pc.connectionState;
            const newEvent = new Event("connectionstatechange", e2);
            pc.dispatchEvent(newEvent);
          }
          return e2;
        };
        this.addEventListener(
          "iceconnectionstatechange",
          this._connectionstatechangepoly
        );
      }
      return origMethod.apply(this, arguments);
    };
  });
}
__name(shimConnectionState, "shimConnectionState");
function removeExtmapAllowMixed(window2, browserDetails) {
  if (!window2.RTCPeerConnection) {
    return;
  }
  if (browserDetails.browser === "chrome" && browserDetails.version >= 71) {
    return;
  }
  if (browserDetails.browser === "safari" && browserDetails.version >= 605) {
    return;
  }
  const nativeSRD = window2.RTCPeerConnection.prototype.setRemoteDescription;
  window2.RTCPeerConnection.prototype.setRemoteDescription = /* @__PURE__ */ __name(function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
      const sdp2 = desc.sdp.split("\n").filter((line) => {
        return line.trim() !== "a=extmap-allow-mixed";
      }).join("\n");
      if (window2.RTCSessionDescription && desc instanceof window2.RTCSessionDescription) {
        arguments[0] = new window2.RTCSessionDescription({
          type: desc.type,
          sdp: sdp2
        });
      } else {
        desc.sdp = sdp2;
      }
    }
    return nativeSRD.apply(this, arguments);
  }, "setRemoteDescription");
}
__name(removeExtmapAllowMixed, "removeExtmapAllowMixed");
function shimAddIceCandidateNullOrEmpty(window2, browserDetails) {
  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeAddIceCandidate = window2.RTCPeerConnection.prototype.addIceCandidate;
  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
    return;
  }
  window2.RTCPeerConnection.prototype.addIceCandidate = /* @__PURE__ */ __name(function addIceCandidate() {
    if (!arguments[0]) {
      if (arguments[1]) {
        arguments[1].apply(null);
      }
      return Promise.resolve();
    }
    if ((browserDetails.browser === "chrome" && browserDetails.version < 78 || browserDetails.browser === "firefox" && browserDetails.version < 68 || browserDetails.browser === "safari") && arguments[0] && arguments[0].candidate === "") {
      return Promise.resolve();
    }
    return nativeAddIceCandidate.apply(this, arguments);
  }, "addIceCandidate");
}
__name(shimAddIceCandidateNullOrEmpty, "shimAddIceCandidateNullOrEmpty");
function shimParameterlessSetLocalDescription(window2, browserDetails) {
  if (!(window2.RTCPeerConnection && window2.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeSetLocalDescription = window2.RTCPeerConnection.prototype.setLocalDescription;
  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
    return;
  }
  window2.RTCPeerConnection.prototype.setLocalDescription = /* @__PURE__ */ __name(function setLocalDescription() {
    let desc = arguments[0] || {};
    if (typeof desc !== "object" || desc.type && desc.sdp) {
      return nativeSetLocalDescription.apply(this, arguments);
    }
    desc = { type: desc.type, sdp: desc.sdp };
    if (!desc.type) {
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          desc.type = "offer";
          break;
        default:
          desc.type = "answer";
          break;
      }
    }
    if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") {
      return nativeSetLocalDescription.apply(this, [desc]);
    }
    const func = desc.type === "offer" ? this.createOffer : this.createAnswer;
    return func.apply(this).then((d2) => nativeSetLocalDescription.apply(this, [d2]));
  }, "setLocalDescription");
}
__name(shimParameterlessSetLocalDescription, "shimParameterlessSetLocalDescription");

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/adapter_factory.js
var sdp = __toESM(require_sdp());
function adapterFactory({ window: window2 } = {}, options = {
  shimChrome: true,
  shimFirefox: true,
  shimSafari: true
}) {
  const logging2 = log;
  const browserDetails = detectBrowser(window2);
  const adapter2 = {
    browserDetails,
    commonShim: common_shim_exports,
    extractVersion,
    disableLog,
    disableWarnings,
    sdp
  };
  switch (browserDetails.browser) {
    case "chrome":
      if (!chrome_shim_exports || !shimPeerConnection || !options.shimChrome) {
        logging2("Chrome shim is not included in this adapter release.");
        return adapter2;
      }
      if (browserDetails.version === null) {
        logging2("Chrome shim can not determine version, not shimming.");
        return adapter2;
      }
      logging2("adapter.js shimming chrome.");
      adapter2.browserShim = chrome_shim_exports;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails);
      shimParameterlessSetLocalDescription(window2, browserDetails);
      shimGetUserMedia(window2, browserDetails);
      shimMediaStream(window2, browserDetails);
      shimPeerConnection(window2, browserDetails);
      shimOnTrack(window2, browserDetails);
      shimAddTrackRemoveTrack(window2, browserDetails);
      shimGetSendersWithDtmf(window2, browserDetails);
      shimGetStats(window2, browserDetails);
      shimSenderReceiverGetStats(window2, browserDetails);
      fixNegotiationNeeded(window2, browserDetails);
      shimRTCIceCandidate(window2, browserDetails);
      shimRTCIceCandidateRelayProtocol(window2, browserDetails);
      shimConnectionState(window2, browserDetails);
      shimMaxMessageSize(window2, browserDetails);
      shimSendThrowTypeError(window2, browserDetails);
      removeExtmapAllowMixed(window2, browserDetails);
      break;
    case "firefox":
      if (!firefox_shim_exports || !shimPeerConnection2 || !options.shimFirefox) {
        logging2("Firefox shim is not included in this adapter release.");
        return adapter2;
      }
      logging2("adapter.js shimming firefox.");
      adapter2.browserShim = firefox_shim_exports;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails);
      shimParameterlessSetLocalDescription(window2, browserDetails);
      shimGetUserMedia2(window2, browserDetails);
      shimPeerConnection2(window2, browserDetails);
      shimOnTrack2(window2, browserDetails);
      shimRemoveStream(window2, browserDetails);
      shimSenderGetStats(window2, browserDetails);
      shimReceiverGetStats(window2, browserDetails);
      shimRTCDataChannel(window2, browserDetails);
      shimAddTransceiver(window2, browserDetails);
      shimGetParameters(window2, browserDetails);
      shimCreateOffer(window2, browserDetails);
      shimCreateAnswer(window2, browserDetails);
      shimRTCIceCandidate(window2, browserDetails);
      shimConnectionState(window2, browserDetails);
      shimMaxMessageSize(window2, browserDetails);
      shimSendThrowTypeError(window2, browserDetails);
      break;
    case "safari":
      if (!safari_shim_exports || !options.shimSafari) {
        logging2("Safari shim is not included in this adapter release.");
        return adapter2;
      }
      logging2("adapter.js shimming safari.");
      adapter2.browserShim = safari_shim_exports;
      shimAddIceCandidateNullOrEmpty(window2, browserDetails);
      shimParameterlessSetLocalDescription(window2, browserDetails);
      shimRTCIceServerUrls(window2, browserDetails);
      shimCreateOfferLegacy(window2, browserDetails);
      shimCallbacksAPI(window2, browserDetails);
      shimLocalStreamsAPI(window2, browserDetails);
      shimRemoteStreamsAPI(window2, browserDetails);
      shimTrackEventTransceiver(window2, browserDetails);
      shimGetUserMedia3(window2, browserDetails);
      shimAudioContext(window2, browserDetails);
      shimRTCIceCandidate(window2, browserDetails);
      shimRTCIceCandidateRelayProtocol(window2, browserDetails);
      shimMaxMessageSize(window2, browserDetails);
      shimSendThrowTypeError(window2, browserDetails);
      removeExtmapAllowMixed(window2, browserDetails);
      break;
    default:
      logging2("Unsupported browser!");
      break;
  }
  return adapter2;
}
__name(adapterFactory, "adapterFactory");

// ../../.yarn/global/cache/webrtc-adapter-npm-8.2.0-3d75ed65ad-9.zip/node_modules/webrtc-adapter/src/js/adapter_core.js
var adapter = adapterFactory({ window: typeof window === "undefined" ? void 0 : window });
var adapter_core_default = adapter;

// js/renderPreviewWindow.tsx
init_define_process();
var import_react7 = __toESM(require_react(), 1);
var import_client2 = __toESM(require_client(), 1);

// ../../.yarn/__virtual__/react-reverse-portal-virtual-1d0f51ed61/0/global/cache/react-reverse-portal-npm-2.1.1-e50ec91de3-9.zip/node_modules/react-reverse-portal/dist/web/index.js
init_define_process();
var React = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());
var __extends = function() {
  var extendStatics2 = /* @__PURE__ */ __name(function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  }, "extendStatics");
  return function(d2, b2) {
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    __name(__, "__");
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var ELEMENT_TYPE_HTML = "html";
var ELEMENT_TYPE_SVG = "svg";
var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
var validateElementType = /* @__PURE__ */ __name(function(domElement, elementType) {
  if (elementType === ELEMENT_TYPE_HTML) {
    return domElement instanceof HTMLElement;
  }
  if (elementType === ELEMENT_TYPE_SVG) {
    return domElement instanceof SVGElement;
  }
  throw new Error('Unrecognized element type "' + elementType + '" for validateElementType.');
}, "validateElementType");
var createPortalNode = /* @__PURE__ */ __name(function(elementType, options) {
  var initialProps = {};
  var parent;
  var lastPlaceholder;
  var element;
  if (elementType === ELEMENT_TYPE_HTML) {
    element = document.createElement("div");
  } else if (elementType === ELEMENT_TYPE_SVG) {
    element = document.createElementNS(SVG_NAMESPACE, "g");
  } else {
    throw new Error('Invalid element type "' + elementType + '" for createPortalNode: must be "html" or "svg".');
  }
  if (options && typeof options === "object") {
    for (var _i = 0, _a = Object.entries(options.attributes); _i < _a.length; _i++) {
      var _b = _a[_i], key = _b[0], value = _b[1];
      element.setAttribute(key, value);
    }
  }
  var portalNode = {
    element,
    elementType,
    setPortalProps: function(props) {
      initialProps = props;
    },
    getInitialPortalProps: function() {
      return initialProps;
    },
    mount: function(newParent, newPlaceholder) {
      if (newPlaceholder === lastPlaceholder) {
        return;
      }
      portalNode.unmount();
      if (newParent !== parent) {
        if (!validateElementType(newParent, elementType)) {
          throw new Error('Invalid element type for portal: "' + elementType + '" portalNodes must be used with ' + elementType + " elements, but OutPortal is within <" + newParent.tagName + ">.");
        }
      }
      newParent.replaceChild(portalNode.element, newPlaceholder);
      parent = newParent;
      lastPlaceholder = newPlaceholder;
    },
    unmount: function(expectedPlaceholder) {
      if (expectedPlaceholder && expectedPlaceholder !== lastPlaceholder) {
        return;
      }
      if (parent && lastPlaceholder) {
        parent.replaceChild(lastPlaceholder, portalNode.element);
        parent = void 0;
        lastPlaceholder = void 0;
      }
    }
  };
  return portalNode;
}, "createPortalNode");
var InPortal = function(_super) {
  __extends(InPortal2, _super);
  function InPortal2(props) {
    var _this = _super.call(this, props) || this;
    _this.addPropsChannel = function() {
      Object.assign(_this.props.node, {
        setPortalProps: function(props2) {
          _this.setState({ nodeProps: props2 });
        }
      });
    };
    _this.state = {
      nodeProps: _this.props.node.getInitialPortalProps()
    };
    return _this;
  }
  __name(InPortal2, "InPortal");
  InPortal2.prototype.componentDidMount = function() {
    this.addPropsChannel();
  };
  InPortal2.prototype.componentDidUpdate = function() {
    this.addPropsChannel();
  };
  InPortal2.prototype.render = function() {
    var _this = this;
    var _a = this.props, children = _a.children, node = _a.node;
    return ReactDOM.createPortal(React.Children.map(children, function(child) {
      if (!React.isValidElement(child))
        return child;
      return React.cloneElement(child, _this.state.nodeProps);
    }), node.element);
  };
  return InPortal2;
}(React.PureComponent);
var OutPortal = function(_super) {
  __extends(OutPortal2, _super);
  function OutPortal2(props) {
    var _this = _super.call(this, props) || this;
    _this.placeholderNode = React.createRef();
    _this.passPropsThroughPortal();
    return _this;
  }
  __name(OutPortal2, "OutPortal");
  OutPortal2.prototype.passPropsThroughPortal = function() {
    var propsForTarget = Object.assign({}, this.props, { node: void 0 });
    this.props.node.setPortalProps(propsForTarget);
  };
  OutPortal2.prototype.componentDidMount = function() {
    var node = this.props.node;
    this.currentPortalNode = node;
    var placeholder = this.placeholderNode.current;
    var parent = placeholder.parentNode;
    node.mount(parent, placeholder);
    this.passPropsThroughPortal();
  };
  OutPortal2.prototype.componentDidUpdate = function() {
    var node = this.props.node;
    if (this.currentPortalNode && node !== this.currentPortalNode) {
      this.currentPortalNode.unmount(this.placeholderNode.current);
      this.currentPortalNode.setPortalProps({});
      this.currentPortalNode = node;
    }
    var placeholder = this.placeholderNode.current;
    var parent = placeholder.parentNode;
    node.mount(parent, placeholder);
    this.passPropsThroughPortal();
  };
  OutPortal2.prototype.componentWillUnmount = function() {
    var node = this.props.node;
    node.unmount(this.placeholderNode.current);
    node.setPortalProps({});
  };
  OutPortal2.prototype.render = function() {
    return React.createElement("div", { ref: this.placeholderNode });
  };
  return OutPortal2;
}(React.PureComponent);
var createHtmlPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_HTML);
var createSvgPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_SVG);

// js/starter.tsx
init_define_process();
var import_react2 = __toESM(require_react(), 1);

// ../../.yarn/global/cache/@ampproject-worker-dom-npm-0.34.0-cfc9652499-9.zip/node_modules/@ampproject/worker-dom/dist/main.mjs
init_define_process();
var e = /* @__PURE__ */ __name((e2, t2, n2, r2, s2) => {
  const o2 = s2.executorsAllowed.includes(8);
  return { execute: (e3, r3, s3) => (o2 && s3 && (e3 = t2.getNode(e3[r3 + 1])) && (s3 = e3.transferControlToOffscreen(), n2.messageToWorker({ 12: 9, 13: [e3._index_], 38: s3 }, [s3])), r3 + 2) };
}, "e");
var t = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14];
var n = /* @__PURE__ */ __name((e2, t2) => Array.prototype.forEach.call(e2, t2), "n");
var r = class {
  constructor(e2, t2) {
    this.nodes = this.count = this.stringContext = this.baseElement = void 0, this.createNodes = (e3, t3) => {
      let n2 = (e3 = new Uint16Array(e3)).length;
      for (let s2 = 0; s2 < n2; s2 += 5) {
        var r2 = void 0;
        if (3 === e3[s2 + 1])
          r2 = document.createTextNode(this.stringContext.get(e3[s2 + 3]));
        else if (8 === e3[s2 + 1])
          r2 = document.createComment(this.stringContext.get(e3[s2 + 3]));
        else if (11 === e3[s2 + 1])
          r2 = document.createDocumentFragment();
        else if (r2 = this.stringContext.get(e3[s2 + 2]), r2 = 0 !== e3[s2 + 4] ? document.createElementNS(this.stringContext.get(e3[s2 + 4]), r2) : document.createElement(r2), t3 && !t3.sanitize(r2))
          continue;
        this.storeNode(r2, e3[s2]);
      }
    }, this.getNode = (e3) => (e3 = this.nodes.get(e3)) && "BODY" === e3.nodeName ? this.baseElement : e3, this.storeNodes = (e3) => {
      this.storeNode(e3, ++this.count), n(e3.childNodes, (e4) => this.storeNodes(e4));
    }, this.count = 2, this.stringContext = e2, this.nodes = /* @__PURE__ */ new Map([[1, t2], [2, t2]]), this.baseElement = t2, t2._index_ = 2, n(t2.childNodes, (e3) => this.storeNodes(e3));
  }
  storeNode(e2, t2) {
    e2._index_ = t2, this.nodes.set(t2, e2);
  }
};
__name(r, "r");
var s = /* @__PURE__ */ new Map();
var o = /* @__PURE__ */ __name((e2, t2) => {
  t2 && "value" in t2 && null === t2.oninput && (t2.oninput = () => l(e2, t2));
}, "o");
var i = /* @__PURE__ */ __name((e2, t2) => {
  t2 && "value" in t2 && !s.get(t2) && (new MutationObserver((t3) => t3.map((t4) => l(e2, t4.target))).observe(t2, { attributes: true }), s.set(t2, true));
}, "i");
var l = /* @__PURE__ */ __name((e2, t2) => e2.messageToWorker({ 12: 4, 40: { 7: t2._index_, 21: t2.value } }), "l");
var u = /* @__PURE__ */ __name((e2) => Object.values(e2).map((e3) => [e3.identifier, e3.screenX, e3.screenY, e3.clientX, e3.clientY, e3.pageX, e3.pageY, e3.target._index_]), "u");
var a = /* @__PURE__ */ __name((e2, t2, n2, r2, s2) => {
  const a2 = [], c2 = s2.executorsAllowed.includes(4);
  let d2 = [window.innerWidth, window.innerHeight];
  const h3 = /* @__PURE__ */ __name((e3, t3) => (r3) => {
    t3 && r3.preventDefault();
    var s3 = r3.currentTarget;
    if (s3 && "value" in s3)
      l(n2, r3.currentTarget);
    else if ("resize" === r3.type) {
      const { innerWidth: e4, innerHeight: t4 } = window;
      if (d2[0] === e4 && d2[1] === t4)
        return;
      d2 = [window.innerWidth, window.innerHeight], n2.messageToWorker({ 12: 5, 40: d2 });
    }
    n2.messageToWorker({ 12: 1, 39: { 7: e3, 25: r3.bubbles, 26: r3.cancelable, 27: r3.cancelBubble, 28: [r3.currentTarget._index_ || 0], 29: r3.defaultPrevented, 30: r3.eventPhase, 31: r3.isTrusted, 32: r3.returnValue, 13: [r3.target._index_ || 0], 33: r3.timeStamp, 12: r3.type, 35: "keyCode" in r3 ? r3.keyCode : void 0, 60: "pageX" in r3 ? r3.pageX : void 0, 61: "pageY" in r3 ? r3.pageY : void 0, 65: "offsetX" in r3 ? r3.offsetX : void 0, 66: "offsetY" in r3 ? r3.offsetY : void 0, 62: "touches" in r3 ? u(r3.touches) : void 0, 63: "changedTouches" in r3 ? u(r3.changedTouches) : void 0 } });
  }, "h");
  return { execute(r3, s3, l2) {
    var u2 = r3[s3 + 2];
    const d3 = s3 + 4 + 2 * u2;
    if (u2 = s3 + 4 + 6 * r3[s3 + 3] + 2 * u2, c2 && l2 && (l2 = t2.getNode(r3[s3 + 1]))) {
      let c3 = s3 + 4;
      for (; c3 < u2; ) {
        const u3 = c3 <= d3;
        e: {
          s3 = l2;
          var g2 = u3, f2 = r3, p2 = c3;
          const d4 = e2.get(f2[p2]), m2 = f2[p2 + 1];
          if (s3 === t2.baseElement) {
            g2 ? addEventListener(d4, a2[m2] = h3(1, !!f2[p2 + 5])) : removeEventListener(d4, a2[m2]);
            break e;
          }
          let w2 = null !== s3.oninput;
          const x2 = "change" === d4;
          g2 ? (x2 && (w2 = true, s3.onchange = null), s3.addEventListener(d4, a2[m2] = h3(s3._index_, !!f2[p2 + 5]))) : (x2 && (w2 = false), s3.removeEventListener(d4, a2[m2])), s3 && "value" in s3 && (w2 || o(n2, s3), i(n2, s3));
        }
        c3 += u3 ? 2 : 6;
      }
    }
    return u2;
  } };
}, "a");
var c = /* @__PURE__ */ __name((e2, t2, n2, r2, s2) => {
  const o2 = s2.executorsAllowed.includes(5);
  return { execute: (e3, r3, s3) => (o2 && s3 && (e3 = t2.getNode(e3[r3 + 1])) && (s3 = e3.getBoundingClientRect(), n2.messageToWorker({ 12: 6, 13: [e3._index_], 38: [s3.top, s3.right, s3.bottom, s3.left, s3.width, s3.height] })), r3 + 2) };
}, "c");
var d = /* @__PURE__ */ __name((e2, { getNode: t2 }, n2, r2, s2) => {
  const l2 = s2.executorsAllowed.includes(2);
  return { execute(e3, r3, s3) {
    const u2 = e3[r3 + 4], a2 = e3[r3 + 5];
    if (l2 && s3) {
      const s4 = t2(e3[r3 + 1]);
      s4 && (0 < a2 && e3.slice(r3 + 6 + u2, r3 + 6 + u2 + a2).forEach((e4) => {
        (e4 = t2(e4)) && e4.remove();
      }), 0 < u2 && e3.slice(r3 + 6, r3 + 6 + u2).forEach((l3) => {
        const u3 = e3[r3 + 2];
        (l3 = t2(l3)) && (s4.insertBefore(l3, u3 && t2(u3) || null), o(n2, l3), i(n2, l3));
      }));
    }
    return r3 + 6 + u2 + a2;
  } };
}, "d");
var h = /* @__PURE__ */ __name((e2, t2, n2, r2, s2) => {
  const o2 = s2.executorsAllowed.includes(0);
  return { execute(n3, r3, i2) {
    if (o2 && i2) {
      i2 = t2.getNode(n3[r3 + 1]);
      const o3 = e2.get(n3[r3 + 2]);
      n3 = 0 !== (n3 = n3[r3 + 4]) ? e2.get(n3 - 1) : null, i2 && null != o3 && (s2.sanitizer ? s2.sanitizer.setAttribute(i2, o3, n3) : null == n3 ? i2.removeAttribute(o3) : i2.setAttribute(o3, n3));
    }
    return r3 + 5;
  } };
}, "h");
var g = /* @__PURE__ */ __name((e2, t2, n2, r2, s2) => {
  const o2 = s2.executorsAllowed.includes(1);
  return { execute: (n3, r3, s3) => (o2 && s3 && (s3 = t2.getNode(n3[r3 + 1]), n3 = n3[r3 + 2], s3 && n3 && (s3.textContent = e2.get(n3))), r3 + 3) };
}, "g");
var f = /* @__PURE__ */ __name((e2, t2, n2, r2, s2) => {
  const o2 = s2.executorsAllowed.includes(3);
  return { execute(n3, r3, i2) {
    if (o2 && i2) {
      i2 = t2.getNode(n3[r3 + 1]);
      const o3 = e2.get(n3[r3 + 2]);
      {
        const t3 = n3[r3 + 4];
        n3 = 1 === n3[r3 + 3] ? 1 === t3 : 0 !== t3 ? e2.get(t3) : null;
      }
      i2 && o3 && null != n3 && (s2.sanitizer ? s2.sanitizer.setProperty(i2, o3, String(n3)) : i2[o3] = n3);
    }
    return r3 + 5;
  } };
}, "f");
var p = /* @__PURE__ */ __name((e2, t2, n2, r2, s2) => {
  const o2 = s2.executorsAllowed.includes(6);
  let i2, l2 = 0;
  return { execute(e3, t3, n3) {
    if (o2 && n3 && s2.longTask)
      if (6 === e3[t3]) {
        if (l2++, !i2) {
          const e4 = new Promise((e5) => i2 = e5);
          Promise.resolve().then(() => s2.longTask && s2.longTask(e4));
        }
      } else
        7 === e3[t3] && (l2--, i2 && 0 >= l2 && (i2(), i2 = null, l2 = 0));
    return t3 + 2;
  }, get active() {
    return null !== i2;
  } };
}, "p");
var m = new Float32Array(1);
var w = new Uint16Array(m.buffer);
function x(e2, t2, n2, r2, s2, o2) {
  let i2 = [];
  for (let u2 = 0; u2 < n2; u2++)
    switch (e2[t2++]) {
      case 1:
        i2.push(e2[t2++]);
        break;
      case 2:
        w[0] = e2[t2++], w[1] = e2[t2++], i2.push(m[0]);
        break;
      case 3:
        i2.push(r2.get(e2[t2++]));
        break;
      case 4:
        var l2 = e2[t2++];
        t2 = x(e2, t2, l2, r2, s2, o2), i2.push(t2.args), t2 = t2.offset;
        break;
      case 5:
        if (!o2)
          throw Error("objectContext not provided.");
        i2.push(o2.get(e2[t2++]));
        break;
      case 6:
        l2 = s2.getNode(e2[t2++]), i2.push(l2.getContext("2d"));
        break;
      case 7:
        i2.push(s2.getNode(e2[t2++]));
        break;
      default:
        throw Error("Cannot deserialize argument.");
    }
  return { args: i2, offset: t2 };
}
__name(x, "x");
var v = /* @__PURE__ */ __name((e2, t2, n2, r2, s2) => {
  const o2 = s2.executorsAllowed.includes(9);
  return { execute(n3, s3, i2) {
    const l2 = e2.get(n3[s3 + 1]), u2 = n3[s3 + 2], { offset: a2, args: c2 } = x(n3, s3 + 3, 1, e2, t2, r2);
    s3 = c2[0];
    const { offset: d2, args: h3 } = x(n3, a2, u2, e2, t2, r2);
    return o2 && i2 && (b(s3, l2) ? s3[l2] = h3[0] : s3[l2](...h3)), d2;
  } };
}, "v");
function b(e2, t2) {
  if (!e2)
    throw Error(`Property ${t2} does not exist on ${e2}.`);
  let n2 = Object.getOwnPropertyDescriptor(e2, t2);
  return void 0 !== n2 ? "set" in n2 : b(Object.getPrototypeOf(e2), t2);
}
__name(b, "b");
var k = /* @__PURE__ */ __name((e2, t2, n2, r2, s2) => {
  const o2 = s2.executorsAllowed.includes(10);
  if (!r2)
    throw Error("objectContext is not defined.");
  return { execute(n3, s3, i2) {
    const l2 = e2.get(n3[s3 + 1]), u2 = n3[s3 + 2], a2 = n3[s3 + 3], { offset: c2, args: d2 } = x(n3, s3 + 4, 1, e2, t2, r2);
    s3 = d2[0];
    const { offset: h3, args: g2 } = x(n3, c2, a2, e2, t2, r2);
    return o2 && i2 && "new" !== l2 && r2.store(u2, s3[l2](...g2)), h3;
  } };
}, "k");
var y = /* @__PURE__ */ __name((e2, t2, n2, r2, s2) => {
  const o2 = s2.executorsAllowed.includes(11);
  return { execute: (e3, r3, s3) => (o2 && s3 && (s3 = t2.getNode(e3[r3 + 1])) && self.createImageBitmap(s3).then((t3) => {
    n2.messageToWorker({ 12: 10, 73: e3[r3 + 2], 38: t3 }, [t3]);
  }), r3 + 3) };
}, "y");
var N = /* @__PURE__ */ __name((e2, t2, n2, r2, s2) => {
  const o2 = s2.executorsAllowed.includes(12);
  return { execute(t3, r3, i2) {
    if (o2 && i2) {
      i2 = t3[r3 + 1];
      var l2 = t3[r3 + 2], u2 = t3[r3 + 3];
      const o3 = t3[r3 + 4];
      if (t3 = 0 < u2 ? e2.get(u2 - 1) : "", u2 = 0 < o3 ? e2.get(o3 - 1) : null, 1 === i2)
        ((e3, t4) => {
          s2.sanitizer && 2 === e3 && s2.sanitizer.getStorage(e3, t4).then((r4) => {
            n2.messageToWorker({ 12: 11, 74: t4, 75: e3, 21: r4 });
          });
        })(l2, t3);
      else if (2 === i2)
        if (i2 = l2, l2 = t3, t3 = u2, s2.sanitizer)
          s2.sanitizer.setStorage(i2, l2, t3);
        else {
          let e3;
          if (0 === i2 ? e3 = window.localStorage : 1 === i2 && (e3 = window.sessionStorage), e3)
            if (null == l2) {
              if (null != t3)
                throw Error("Unexpected storage operation.");
              e3.clear();
            } else
              null == t3 ? e3.removeItem(l2) : e3.setItem(l2, t3);
        }
    }
    return r3 + 5;
  } };
}, "N");
var C = 0;
var A = {};
var O = /* @__PURE__ */ __name((e2, t2, n2, r2, s2) => {
  const o2 = s2.executorsAllowed.includes(13);
  return { execute(t3, n3) {
    if (o2) {
      const r3 = t3[n3 + 1], s3 = t3[n3 + 2];
      t3 = t3[n3 + 3], t3 = e2.hasIndex(t3) ? JSON.parse(e2.get(t3)) : void 0, 1 === r3 ? A[s3].resolve(t3) : A[s3].reject(t3), delete A[s3];
    }
    return n3 + 4;
  } };
}, "O");
var _ = /* @__PURE__ */ __name((e2, t2, n2, r2, s2) => {
  const o2 = s2.executorsAllowed.includes(14);
  return { execute: (e3, n3, r3) => (o2 && r3 && (e3 = t2.getNode(e3[n3 + 1])) && e3.scrollIntoView(), n3 + 2) };
}, "_");
var E = class {
  constructor(t2, n2, r2, s2, o2) {
    this.nodeContext = this.stringContext = void 0, this.mutationQueue = [], this.pendingMutations = false, this.executors = this.sanitizer = this.mutationPumpFunction = void 0, this.syncFlush = (e2 = true) => {
      let t3 = [];
      return this.mutationQueue.forEach((n3) => {
        let r3 = n3.length, s3 = 0;
        for (; s3 < r3; ) {
          let r4 = n3[s3];
          var o3;
          if (!(o3 = e2)) {
            e:
              switch (r4) {
                case 4:
                case 5:
                case 6:
                case 7:
                case 12:
                case 8:
                case 13:
                  o3 = false;
                  break e;
                default:
                  o3 = true;
              }
            o3 = !o3;
          }
          o3 || t3.push(r4), s3 = this.executors[r4].execute(n3, s3, o3);
        }
      }), this.mutationQueue = [], this.pendingMutations = false, t3;
    }, this.stringContext = t2, this.nodeContext = n2, this.sanitizer = s2.sanitizer, this.mutationPumpFunction = s2.mutationPump, n2 = p.apply(null, t2 = [t2, n2, r2, o2, s2]), this.executors = { 2: d.apply(null, t2), 0: h.apply(null, t2), 1: g.apply(null, t2), 3: f.apply(null, t2), 4: a.apply(null, t2), 5: c.apply(null, t2), 6: n2, 7: n2, 8: e.apply(null, t2), 9: v.apply(null, t2), 10: k.apply(null, t2), 11: y.apply(null, t2), 12: N.apply(null, t2), 13: O.apply(null, t2), 14: _.apply(null, t2) };
  }
  mutate(e2, t2, n2, r2) {
    this.stringContext.storeValues(n2), this.nodeContext.createNodes(t2, this.sanitizer), this.mutationQueue = this.mutationQueue.concat(r2), this.pendingMutations || (this.pendingMutations = true, this.mutationPumpFunction(this.syncFlush, e2));
  }
};
__name(E, "E");
var T = class {
  constructor() {
    this.strings = [];
  }
  get(e2) {
    return this.strings[e2] || "";
  }
  hasIndex(e2) {
    return void 0 !== this.strings[e2];
  }
  store(e2) {
    return this.strings.push(e2), this.strings.length - 1;
  }
  storeValues(e2) {
    e2.forEach((e3) => this.store(e3));
  }
};
__name(T, "T");
var M = [8, 3];
function S(e2, t2, n2, r2) {
  var s2 = [].slice.call(e2.childNodes).filter(n2);
  return s2 = { 7: e2._index_, 11: 0, 0: e2.nodeType, 1: t2(e2.localName || e2.nodeName), 4: s2.map((e3) => S(e3, t2, n2, r2)), 2: [].map.call(e2.attributes || [], (e3) => [t2(e3.namespaceURI || "null"), t2(e3.name), t2(e3.value)]) }, null != e2.namespaceURI && (s2[6] = t2(e2.namespaceURI)), M.includes(e2.nodeType) && null !== e2.textContent && (s2[5] = t2(e2.textContent)), o(r2, e2), i(r2, e2), s2;
}
__name(S, "S");
var U = class {
  constructor(e2, t2, n2, r2, s2) {
    this[55] = void 0, this.nodeContext = t2, this.config = s2;
    let { skeleton: o2, strings: i2 } = function(e3, t3, n3) {
      t3 = t3.hydrateFilter || (() => true);
      let r3 = [], s3 = /* @__PURE__ */ new Map();
      return { skeleton: S(e3, (e4) => {
        if (s3.has(e4))
          return s3.get(e4);
        const t4 = r3.length;
        return s3.set(e4, t4), r3.push(e4), t4;
      }, t3, n3), strings: r3 };
    }(e2, s2, this);
    t2 = [];
    let l2 = [], u2 = W("localStorage"), a2 = W("sessionStorage");
    for (let n3 in e2.style)
      t2.push(n3);
    for (let t3 in e2)
      t3.startsWith("on") && l2.push(t3);
    n2 = `'use strict';(function(){${n2}self['window']=self;var workerDOM=WorkerThread.workerDOM;WorkerThread.hydrate(workerDOM.document,${JSON.stringify(i2)},${JSON.stringify(o2)},${JSON.stringify(t2)},${JSON.stringify(l2)},[${window.innerWidth},${window.innerHeight}],${JSON.stringify(u2)},${JSON.stringify(a2)});workerDOM.document[59](this);Object.assign(self,workerDOM);}).call(self);${r2}//# sourceURL=${encodeURI(s2.authorURL)}`, s2.sandbox || (this[55] = new Worker(URL.createObjectURL(new Blob([n2])))), s2.onCreateWorker && s2.onCreateWorker(e2, i2, o2, t2);
  }
  ready() {
    return this.worker.readyPromise || Promise.resolve();
  }
  get worker() {
    return this[55];
  }
  messageToWorker(e2, t2) {
    this.config.onSendMessage && this.config.onSendMessage(e2), this.worker.postMessage(e2, t2 || []);
  }
};
__name(U, "U");
function W(e2, t2) {
  try {
    return t2 ? { storage: t2.getStorage("localStorage" == e2 ? 0 : 1), errorMsg: null } : { storage: window[e2], errorMsg: null };
  } catch (e3) {
    return { errorMsg: e3.message, storage: null };
  }
}
__name(W, "W");
var P = class {
  constructor() {
    this.objects = void 0, this.objects = /* @__PURE__ */ new Map();
  }
  store(e2, t2) {
    this.objects.set(e2, t2);
  }
  get(e2) {
    let t2 = this.objects.get(e2);
    if (t2)
      return t2;
    throw Error("Object with id (" + e2 + ") does not exist.");
  }
};
__name(P, "P");
var L = class {
  constructor(e2, t2) {
    this.workerContext_ = e2, this.config = t2;
  }
  callFunction(e2, ...t2) {
    if (!this.config.executorsAllowed.includes(13))
      throw Error(`[worker-dom]: Error calling ${e2}. You must enable the FUNCTION_CALL executor within the config.`);
    let { promise: n2, index: r2 } = function() {
      let e3, t3, n3 = new Promise((n4, r4) => {
        e3 = n4, t3 = r4;
      });
      C >= Number.MAX_VALUE && (C = 0);
      let r3 = C++;
      return A[r3] = { promise: n3, resolve: e3, reject: t3 }, { promise: n3, index: r3 };
    }();
    return e2 = { 12: 12, 77: e2, 78: JSON.stringify(t2), 7: r2 }, this.workerContext_.messageToWorker(e2), n2;
  }
  set onerror(e2) {
    this.workerContext_.worker.onerror = e2;
  }
  terminate() {
    this.workerContext_.worker.terminate();
  }
};
__name(L, "L");
var R = [3, 2];
function j(e2, n2) {
  return function(e3, n3, s2) {
    var o2 = n3.dataset.shadowDom;
    if ("open" === o2 || "closed" === o2) {
      o2 = n3.attachShadow({ mode: o2 });
      let e4 = n3.cloneNode(true);
      o2.appendChild(e4), n3 = e4;
    }
    let i2 = new T(), l2 = new P(), u2 = new r(i2, n3), a2 = function(e4) {
      return Object.assign({}, { mutationPump: requestAnimationFrame.bind(null), executorsAllowed: t }, e4);
    }(s2);
    return e3.then(([e4, t2]) => {
      if (e4 && t2 && s2.authorURL) {
        let r2 = new U(n3, u2, e4, t2, a2), o3 = new E(i2, u2, r2, a2, l2);
        return r2.worker.onmessage = (e5) => {
          let { data: t3 } = e5;
          R.includes(t3[12]) && (o3.mutate(t3[54], t3[37], t3[41], new Uint16Array(t3[36])), s2.onReceiveMessage) && s2.onReceiveMessage(e5);
        }, r2.ready().then(() => new L(r2, a2));
      }
      return null;
    });
  }(Promise.all([fetch(n2.domURL).then((e3) => e3.text()), fetch(n2.authorURL).then((e3) => e3.text())]), e2, n2);
}
__name(j, "j");
function upgradeElement(e2, t2) {
  let n2 = e2.getAttribute("src");
  return n2 ? j(e2, { authorURL: n2, domURL: t2 }) : Promise.resolve(null);
}
__name(upgradeElement, "upgradeElement");

// js/starter.tsx
var import_react3 = __toESM(require_emotion_react_cjs(), 1);

// ../../.yarn/global/cache/async-mutex-npm-0.4.0-f5a25d4255-9.zip/node_modules/async-mutex/index.mjs
init_define_process();
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._weightedQueues = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve, reject) => {
      if (!this._weightedQueues[weight - 1])
        this._weightedQueues[weight - 1] = [];
      this._weightedQueues[weight - 1].push({ resolve, reject });
      this._dispatch();
    });
  }
  runExclusive(callback, weight = 1) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const [value, release] = yield this.acquire(weight);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve) => {
      if (!this._weightedWaiters[weight - 1])
        this._weightedWaiters[weight - 1] = [];
      this._weightedWaiters[weight - 1].push(resolve);
      this._dispatch();
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatch();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatch();
  }
  cancel() {
    this._weightedQueues.forEach((queue) => queue.forEach((entry) => entry.reject(this._cancelError)));
    this._weightedQueues = [];
  }
  _dispatch() {
    var _a;
    for (let weight = this._value; weight > 0; weight--) {
      const queueEntry = (_a = this._weightedQueues[weight - 1]) === null || _a === void 0 ? void 0 : _a.shift();
      if (!queueEntry)
        continue;
      const previousValue = this._value;
      const previousWeight = weight;
      this._value -= weight;
      weight = this._value + 1;
      queueEntry.resolve([previousValue, this._newReleaser(previousWeight)]);
    }
    this._drainUnlockWaiters();
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    for (let weight = this._value; weight > 0; weight--) {
      if (!this._weightedWaiters[weight - 1])
        continue;
      this._weightedWaiters[weight - 1].forEach((waiter) => waiter());
      this._weightedWaiters[weight - 1] = [];
    }
  }
};
__name(Semaphore, "Semaphore");
var __awaiter$1 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const [, releaser] = yield this._semaphore.acquire();
      return releaser;
    });
  }
  runExclusive(callback) {
    return this._semaphore.runExclusive(() => callback());
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock() {
    return this._semaphore.waitForUnlock();
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};
__name(Mutex, "Mutex");

// js/esbuildEsm.ts
init_define_process();
var import_esbuild_wasm = __toESM(require_browser(), 1);

// js/fetchPlugin.tsx
init_define_process();

// js/runner.tsx
init_define_process();

// js/renderToString.tsx
init_define_process();
var import_react = __toESM(require_react(), 1);
var import_client = __toESM(require_client(), 1);
var import_jsx_runtime = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var mod = {
  md5Hash: "",
  wait: 1,
  res: null,
  codeSpace: "",
  waitForDiv: async (md5Hash) => {
    if (mod.md5Hash !== md5Hash)
      return "";
    if (!mod.res?.innerHTML)
      await waitForAnimation();
    mod.wait *= 2;
    await wait(mod.wait);
    if (!mod.res?.innerHTML.includes(md5Hash)) {
      await waitForAnimation();
    }
    const html = mod.res?.innerHTML;
    if (html?.includes(md5Hash) && mod.res?.firstElementChild?.innerHTML !== "")
      return html;
    mod.wait = mod.wait * 2;
    return await mod.waitForDiv(md5Hash);
  },
  setApp: (md5Hash) => {
    const rootDiv = document.createElement("div");
    rootDiv.style.visibility = "hidden";
    rootDiv.style.position = "absolute";
    const root = (0, import_client.createRoot)(rootDiv);
    const App = apps[md5Hash];
    mod.md5Hash = md5Hash;
    mod.res = rootDiv;
    root.render(
      /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.StrictMode, { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(App, { appId: `${mod.codeSpace}-${md5Hash}` }) })
    );
    return () => {
      root.unmount();
      rootDiv.remove();
    };
  }
};
var render = /* @__PURE__ */ __name(async (transpiled, codeSpace4) => {
  mod.codeSpace = codeSpace4;
  const md5hash = md5(transpiled);
  if (!apps[md5hash])
    await appFactory(transpiled);
  mod.wait = 1;
  const cleanup = mod.setApp(
    md5hash
  );
  try {
    const html = await mod.waitForDiv(md5hash);
    if (!html)
      return { html: null, css: null };
    const css4 = mineFromCaches(eCaches[md5hash]);
    const globalCss = document.querySelector(
      `style[data-emotion=${eCaches[md5hash].key}-global]`
    )?.innerHTML;
    return {
      html,
      css: globalCss ? globalCss + " " + css4 : css4
    };
  } finally {
    cleanup();
  }
}, "render");
function mineFromCaches(cache) {
  const key = cache.key;
  try {
    return Array.from(
      document.querySelectorAll(`style[data-emotion="${cache.key}"]`)
    ).map((x2) => x2.textContent).join(
      "\n"
    );
  } catch {
    return Array.from(document.styleSheets).map((x2) => {
      try {
        return x2.cssRules[0];
      } catch {
        return null;
      }
    }).filter((x2) => x2 && x2.selectorText && x2.selectorText.indexOf(key) !== -1).map((x2) => x2.cssText).join("\n");
  }
}
__name(mineFromCaches, "mineFromCaches");
var waitForAnimation = /* @__PURE__ */ __name(() => {
  let animationFrame;
  console.log("wait for animation");
  const animated = new Promise((resolve) => animationFrame = resolve);
  requestAnimationFrame(() => animationFrame(true));
  return animated;
}, "waitForAnimation");

// js/toUmd.ts
init_define_process();

// js/importmap.json
var imports = {
  "framer-motion": "/motion.mjs",
  "@emotion/react": "/emotion.mjs",
  "@emotion/cache": "/emotionCache.mjs",
  "@emotion/styled": "/emotionStyled.mjs",
  "@emotion/react/jsx-runtime": "/emotionJsxRuntime.mjs",
  react: "/reactMod.mjs",
  "react/jsx-runtime": "/jsx.mjs",
  "react-dom": "/reactDom.mjs",
  "react-dom/client": "/reactDomClient.mjs",
  "react-error-boundary": "/reactMod.mjs"
};
var importmap_default = {
  imports
};

// js/toUmd.ts
var import_localforage = __toESM(require_localforage(), 1);
var fileCache = import_localforage.default.createInstance({
  name: "filecache"
});
var imp = { ...importmap_default.imports };
var importMasRes = {};
Object.keys(imp).map((k2) => Object.assign(importMasRes, { [k2]: location.origin + imp[k2] }));
var mod2 = {
  printR(name, included) {
    if (included[mod2.hashMap[name]])
      return "";
    included[mod2.hashMap[name]] = true;
    const current = mod2.data[mod2.hashMap[name]];
    if (!current)
      console.error(name + " is missing!");
    const currentCode = current.code;
    if (!current.deps || !current.deps.length) {
      return currentCode;
    }
    const myDepts = [...current.deps];
    const depts = myDepts.map((name2) => mod2.printR(name2, included)).join(
      " \n "
    );
    return depts + `
    
    ` + currentCode;
  },
  toJs: async (name) => {
    const js = mod2.printR(name, {});
    let reverseMap = {};
    Object.keys(mod2.hashMap).forEach((key) => reverseMap = { ...reverseMap, [mod2.hashMap[key]]: key });
    let modZ = {};
    Object.keys(mod2.data).forEach((k2) => modZ = { ...modZ, [reverseMap[k2]]: k2 });
    Object.keys(importMasRes).forEach((k2) => modZ = { ...modZ, [k2]: "getName(`" + importMasRes[k2] + "`)" });
    const res = `
     ${js}




  
  function require(name){


      const importmap = ${JSON.stringify(importmap_default.imports)};
      const uName = new URL(name, location.origin).toString();    
      const urlName = new URL(name+"/index.js", location.origin).toString();
      if (globalThis.globalNames[name]) return  globalThis.globalNames[name];     
      
      if (globalThis.globalNames[uName]) return  globalThis.globalNames[uName];     

      if (globalThis.globalNames[urlName]) return  globalThis.globalNames[urlName];
      if (importmap[name]) return require(importmap[name])      
      if (!name.includes("/npm:")){
      const npmUrl = new URL('/npm:*'+name+"?bundle&external=@emotion/*,react*,react ", location.origin).toString()
      return require(npmUrl);
    }
  }`;
    return res;
  },
  last: 0,
  hashMap: {},
  data: {}
};
var findDeps = /* @__PURE__ */ __name((code) => {
  const regex = /require\("(.+?)"\)/gm;
  let m2;
  const deps = [];
  while ((m2 = regex.exec(code)) !== null) {
    if (m2.index === regex.lastIndex) {
      regex.lastIndex++;
    }
    for (const [groupIndex, match] of m2.entries()) {
      if (groupIndex == 1) {
        deps.push(match);
      }
    }
  }
  return deps;
}, "findDeps");
var toUmd = /* @__PURE__ */ __name(async (source, name) => {
  const hash = md5(source);
  mod2.hashMap = { ...mod2.hashMap, [name]: hash };
  if (mod2.data[hash])
    return mod2;
  try {
    mod2.data[hash] = {
      code: (await initAndTransform(source, {
        format: "iife",
        keepNames: true,
        treeShaking: true,
        platform: "browser",
        ignoreAnnotations: true,
        target: "es2022",
        define: {
          "globalThis.workerDom": JSON.stringify(true),
          "process.env.NODE_ENV": `"development"`,
          "process.env.NODE_DEBUG": JSON.stringify(false),
          "process.browser": JSON.stringify(true),
          "process.env.DEBUG": JSON.stringify(false),
          "isBrowser": JSON.stringify(true),
          "isJest": JSON.stringify(false),
          "process.env.version": '"1.1.1"',
          global: "globalThis",
          "process.env.DUMP_SESSION_KEYS": JSON.stringify(false)
        },
        loader: "ts",
        globalName: hash
      })).code,
      deps: []
    };
  } catch {
    mod2.data[hash] = {
      code: (await initAndTransform(source, {
        format: "iife",
        keepNames: true,
        treeShaking: true,
        define: {
          "globalThis.workerDom": JSON.stringify(true),
          "process.env.NODE_ENV": `"development"`,
          "process.env.NODE_DEBUG": JSON.stringify(false),
          "process.browser": JSON.stringify(true),
          "process.env.DEBUG": JSON.stringify(false),
          "isBrowser": JSON.stringify(true),
          "isJest": JSON.stringify(false),
          "process.env.version": '"1.1.1"',
          global: "globalThis",
          "process.env.DUMP_SESSION_KEYS": JSON.stringify(false)
        },
        ignoreAnnotations: true,
        target: "es2022",
        tsconfigRaw: {
          compilerOptions: {
            jsx: "react-jsx",
            useDefineForClassFields: false,
            jsxImportSource: "@emotion/react"
          }
        },
        loader: "tsx",
        globalName: hash
      })).code,
      deps: []
    };
  }
  mod2.data[hash].code = mod2.data[hash].code + `
  
  globalThis.globalNames = globalThis.globalNames || {};
  globalThis.globalNames["${name}"] =  ${hash}  ;`;
  mod2.data[hash].deps = findDeps(mod2.data[hash].code).map((dep) => import.meta.resolve(dep, name));
  await Promise.all(
    mod2.data[hash].deps.map(
      (depUrl) => fetch_or_die(depUrl).then((content) => toUmd(content, depUrl).then(async (mod5) => await mod5))
    )
  );
  return mod2;
}, "toUmd");
var urls = {};
var fetch_or_die = /* @__PURE__ */ __name(async (url) => {
  if (url.includes(`/live/`))
    return await fetch(url).then((res) => res.text());
  if (urls[url])
    return urls[url];
  const cached = await fileCache.getItem(url);
  if (cached)
    return cached;
  urls[url] = urls[url] || await fetch(url).then((res) => res.text());
  await fileCache.setItem(url, urls[url]);
  return urls[url];
}, "fetch_or_die");

// js/runner.tsx
var esmTransform = /* @__PURE__ */ __name(async (code) => {
  const transpiled = await initAndTransform(code, {
    loader: "tsx",
    format: "esm",
    treeShaking: true,
    platform: "browser",
    minify: false,
    keepNames: true,
    tsconfigRaw: {
      compilerOptions: {
        jsx: "react-jsx",
        useDefineForClassFields: false,
        jsxFragmentFactory: "Fragment",
        jsxImportSource: "@emotion/react"
      }
    },
    target: "es2022"
  });
  return transpiled.code;
}, "esmTransform");
Object.assign(globalThis, { transform: initAndTransform, build, toUmd });
var counterMax = mST().i;
async function runner({ code, counter, codeSpace: codeSpace4 }) {
  if (counter < counterMax)
    return;
  counterMax = counter;
  try {
    const transpiledCode = await esmTransform(code);
    const { html, css: css4 } = await render(transpiledCode, codeSpace4);
    console.log({ html, css: css4 });
    if (!html || !css4) {
      return;
    }
    save({
      ...mST(),
      code,
      i: counter,
      transpiled: transpiledCode,
      html,
      css: css4
    });
  } catch (error) {
    console.error({ error });
  } finally {
  }
}
__name(runner, "runner");

// js/fetchPlugin.tsx
var fetchCache = {
  match: (req) => caches.open("fetchCache").then((fc) => {
    fetchCache = fc;
    return fc.match(req);
  })
};
var codeSpace = location.pathname.slice(1).split("/")[1];
var fetchPlugin = /* @__PURE__ */ __name((importmapReplace) => ({
  name: "http",
  setup(build2) {
    build2.onResolve({ filter: /.*/, namespace: "http-url" }, (args) => ({
      path: new URL(args.path, args.importer).toString(),
      namespace: "http-url"
    }));
    build2.onResolve({ filter: /\.ttf*/, namespace: "http-url" }, (args) => ({
      path: new URL(args.path, args.importer).toString(),
      namespace: "ttf"
    }));
    build2.onLoad({ filter: /.*.tsx.*/ }, async (args) => {
      if (args.path.indexOf("render.tsx") !== -1) {
        const contents = await esmTransform(`
      import {hydrateRoot} from "react-dom/client"
      import { CacheProvider } from "@emotion/react";
      import createCache from "@emotion/cache";
      import {StrictMode} from "react";
      import { ErrorBoundary } from "react-error-boundary";
      import App from "${location.origin}/live/${codeSpace}/index.js/${mST().i}"
      document.body.innerHTML = ${JSON.stringify(`<style>${mST().css}</style><div id="root" style="height:100%">${mST().html}</div>`)};

  let rootEl = document.getElementById("root");

  const codeSpace="${codeSpace}"
    const cache = createCache({
      key: "${hashCode()}",
      container: rootEl,
      speedy: false
    });
  
   cache.compat = undefined;

   const bc = new BroadcastChannel(location.origin);

   bc.onmessage = async (event) => {
     if (
      event.data.codeSpace === codeSpace)
{
      const App = (await("${location.origin}/live/${codeSpace}/index.js/"+event.data.i)).default;

      hydrateRoot(rootEl, <StrictMode><ErrorBoundary
        fallbackRender={({ error }) => (
          <div role="alert">
            <div>Oh n o</div>
            <pre>{error.message}</pre>
          </div>
        )}>
        <CacheProvider value={cache}>
          <App />
        </CacheProvider>
        </ErrorBoundary></StrictMode>);
        }
  }
 
  
   hydrateRoot(rootEl, <StrictMode><ErrorBoundary
    fallbackRender={({ error }) => (
      <div role="alert">
        <div>Oh n o</div>
        <pre>{error.message}</pre>
      </div>
    )}>
    <CacheProvider value={cache}>
      <App />
    </CacheProvider>
    </ErrorBoundary></StrictMode>);
      `);
        return {
          contents
        };
      }
    });
    build2.onLoad({ filter: /.*/ }, async (args) => {
      const getRequest = /* @__PURE__ */ __name(async (req2) => {
        let response2 = await fetchCache.match(req2);
        if (response2)
          return response2;
        response2 = await fetch(req2);
        if (!response2 || !response2.ok)
          return response2;
        response2 = new Response(response2.body, response2);
        await fetchCache.put(req2, response2.clone());
        return response2;
      }, "getRequest");
      const req = new Request(args.path);
      let response = await getRequest(req);
      if (req.url.indexOf(".tsx")) {
        const contents2 = await esmTransform(await response.text());
        return {
          contents: importmapReplace(contents2)
        };
      }
      if (args.namespace === "ttf") {
        let contents2 = response.blob();
        return {
          contents: contents2,
          loader: "dataurl"
        };
      }
      let contents = await response.text();
      return { contents };
    });
  }
}), "fetchPlugin");

// js/unpkg-path-plugin.tsx
init_define_process();
var esbuild = __toESM(require_browser(), 1);
var unpkgPathPlugin = {
  name: "unpkg-path-plugin",
  setup(build2) {
    build2.onResolve({ filter: /^\.+\// }, (args) => {
      const url = new URL(args.path, location.origin).toString();
      return {
        path: url,
        namespace: "http-url"
      };
    });
    build2.onResolve({ filter: /^\[a-z]+\// }, (args) => {
      if (args.path.indexOf(location.origin) !== -1) {
        return {
          namespace: "http-url",
          path: args.path
        };
      }
      return {
        path: `${location.origin}/npm:/${args.path}`,
        namespace: "http-url"
      };
    });
  }
};

// js/esbuildEsm.ts
var mod3 = {
  init: false,
  initialize: () => {
    if (mod3.init !== false)
      return mod3.init;
    return fetch(`${location.origin}/files.json`).then((f2) => f2.json()).then((k2) => {
      const wasmURL = new URL(
        k2[Object.keys(k2).find(
          (i2) => i2.indexOf(".wasm") !== -1 && i2.indexOf("esbuild") !== -1
        )],
        location.origin
      ).toString();
      mod3.init = (0, import_esbuild_wasm.initialize)({
        wasmURL
      }).then(() => mod3.init = true);
      return mod3.init;
    });
  }
};
var initAndTransform = /* @__PURE__ */ __name(async (code, opts) => {
  const initFinished = mod3.initialize();
  if (initFinished !== true)
    await initFinished;
  const transformed = await (0, import_esbuild_wasm.transform)(code, {
    ...opts,
    define: { ...define2, ...opts?.define ? opts.define : {} }
  });
  const trp = opts.keepNames ? importMapReplace(transformed.code) : transformed.code;
  const res = { code: `/*${md5(code)}*/` + trp + `/*${mST().i}*/` };
  return res;
}, "initAndTransform");
var define2 = {
  "process.env.NODE_ENV": `"development"`,
  "process.env.NODE_DEBUG": JSON.stringify(false),
  "process.browser": JSON.stringify(true),
  "process.env.DEBUG": JSON.stringify(true),
  "isBrowser": JSON.stringify(true),
  "isJest": JSON.stringify(false),
  "process.env.version": '"1.1.1"',
  global: "globalThis",
  "WORKER_DOM_DEBUG": JSON.stringify(false),
  "process.env.DUMP_SESSION_KEYS": JSON.stringify(false),
  process: JSON.stringify({
    env: {
      NODE_ENV: `development`,
      browser: true,
      NODE_DEBUG: false,
      DEBUG: true,
      isBrowser: true
    },
    browser: true
  })
};
var definePrd = {
  "process.env.NODE_ENV": `"production"`,
  "process.env.NODE_DEBUG": JSON.stringify(false),
  "process.browser": JSON.stringify(true),
  "process.env.DEBUG": JSON.stringify(false),
  "isBrowser": JSON.stringify(true),
  "isJest": JSON.stringify(false),
  "process.env.version": '"1.1.1"',
  global: "globalThis",
  "WORKER_DOM_DEBUG": JSON.stringify(false),
  "process.env.DUMP_SESSION_KEYS": JSON.stringify(false),
  process: JSON.stringify({
    env: {
      NODE_ENV: `production`,
      browser: true,
      NODE_DEBUG: false,
      DEBUG: false,
      isBrowser: true
    },
    browser: true
  })
};
var skipImportmapReplaceNames = false;
var build = /* @__PURE__ */ __name(async (codeSpace4, i2, signal, bundle) => {
  const initFinished = mod3.initialize();
  if (initFinished !== true)
    await initFinished;
  const defaultOpts = {
    bundle: false,
    resolveExtensions: [
      ".tsx",
      ".ts",
      ".jsx",
      ".js",
      ".d.ts",
      ".css",
      ".json",
      ".mjs",
      ".js",
      ".wasm",
      ".ttf"
    ],
    loader: {
      ".js": "tsx",
      ".tsx": "tsx",
      ".css": "css",
      ".ttf": "dataurl"
    },
    write: false,
    metafile: true,
    target: "es2022",
    outdir: `./`,
    treeShaking: true,
    minify: false,
    define: define2,
    minifyIdentifiers: false,
    minifySyntax: false,
    minifyWhitespace: false,
    splitting: false,
    incremental: true,
    format: "esm",
    entryPoints: [
      `./render.tsx?i=${i2}`
    ],
    tsconfig: "./tsconfig.json",
    plugins: [unpkgPathPlugin, fetchPlugin(importMapReplace)]
  };
  let b2;
  if (!signal.aborted && (b2 = await (0, import_esbuild_wasm.build)(defaultOpts)) && !signal.aborted) {
    console.log(b2.outputFiles);
    return b2.outputFiles[0].contents;
  }
  return false;
}, "build");
function importMapReplace(codeInp) {
  if (skipImportmapReplaceNames)
    return codeInp;
  const items = Object.keys(
    imports
  );
  let returnStr = codeInp;
  items.map((lib) => {
    const uri = new URL(imports[lib], location.origin).toString();
    returnStr = returnStr.replaceAll(
      ` from "${lib}"`,
      ` from "${uri}"`
    ).replaceAll(
      ` from './`,
      ` from 'https://${location.origin}/live/`
    );
  });
  return returnStr;
}
__name(importMapReplace, "importMapReplace");

// js/starter.tsx
var import_jsx_runtime2 = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var codeSpace2 = location.pathname.slice(1).split("/")[1];
var mutex = new Mutex();
if (location.pathname.includes(`/live/${codeSpace2}/hydrated`)) {
  runInWorker(codeSpace2, document.getElementById("root"));
}
var worker;
var lastH = "";
var lastSuccessful = "";
async function runInWorker(nameSpace, _parent) {
  if (worker)
    worker.terminate();
  lastH = hashCode();
  console.log(`last hash: ${lastH}`);
  await mutex.runExclusive(async () => {
    const current = hashCode();
    if (lastH !== hashCode()) {
      console.log(`skipping old build hash: ${lastH}`);
      return;
    }
    if (current === lastSuccessful) {
      console.log(
        `skipping build since it is the latest successful: ${current}`
      );
      return;
    }
    const div = await moveToWorker(nameSpace, document.getElementById("root"));
    if (!div)
      return;
    const w2 = await upgradeElement(
      div,
      "/node_modules/@ampproject/worker-dom@0.34.0/dist/worker/worker.mjs"
    );
    if (w2 === null)
      throw new Error("No worker");
    worker = w2;
  });
}
__name(runInWorker, "runInWorker");
async function moveToWorker(nameSpace, parent) {
  const { i: i2 } = nameSpace === codeSpace2 ? mST() : (await import(`${location.origin}/live/${codeSpace2}/mST.mjs`)).mST;
  const div = parent?.getElementsByTagName("div")[0];
  div.style.height = "100%";
  const cont = new AbortController();
  const js = await build(codeSpace2, i2, cont.signal, false);
  if (!js)
    return false;
  const src = createJsBlob(js);
  div.setAttribute("src", src);
  div.setAttribute("data-shadow-dom", "open");
  return div;
}
__name(moveToWorker, "moveToWorker");
Object.assign(globalThis, { md5 });
var controller;
onSessionUpdate(() => {
  if (controller)
    controller.abort();
}, "abort");
if (!Object.hasOwn(globalThis, "apps")) {
  Object.assign(globalThis, { apps: {}, eCaches: {} });
}
var { apps: apps2, eCaches: eCaches2 } = globalThis;
function AutoUpdateApp({ codeSpace: codeSpace4 }) {
  (0, import_react2.useEffect)(() => {
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, {});
}
__name(AutoUpdateApp, "AutoUpdateApp");
async function appFactory(transpiled = "") {
  const { transpiled: mstTranspiled, i: mstI } = mST();
  const trp = transpiled.length > 0 ? transpiled : mstTranspiled;
  const hash = md5(trp);
  if (!apps2[hash] || !eCaches2[hash]) {
    try {
      eCaches2[hash] = eCaches2[hash] || emotionCache_default({
        key: hash,
        speedy: false
      });
      eCaches2[hash].compat = void 0;
      console.log(`i: ${mstI}: `);
      let mod5;
      try {
        mod5 = await import(createJsBlob(trp));
      } catch {
        mod5 = new Function(trp + ` return ${trp.slice(2, 10)}`)();
      }
      const App = mod5.default;
      apps2[hash] = ({ appId }) => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { style: { height: 100 + "%" }, id: appId, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(import_react3.CacheProvider, { value: eCaches2[hash], children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(App, {}) }, hash) }, hash);
    } catch (error) {
      if (error instanceof SyntaxError) {
        const name = error.name;
        const message = error.message;
        apps2[hash] = () => /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { css: import_react3.css`background-color: orange;`, children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h1", { children: "Syntax Error" }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h2", { children: hash }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("h2", { children: [
            name,
            ": ",
            message
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { children: JSON.stringify({ err: error }) })
        ] });
      } else if (error instanceof Error) {
        const name = error.name;
        const message = error.message;
        apps2[hash] = () => /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("div", { css: import_react3.css`background-color: orange;`, children: [
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("h1", { children: "Syntax Error" }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("h2", { children: [
            name,
            ": ",
            message
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("p", { children: JSON.stringify({ err: error }) })
        ] });
      } else {
        apps2[hash] = () => /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("div", { css: import_react3.css`background-color: orange;`, children: /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)("h1", { children: [
          "Unknown Error: $",
          hash
        ] }) });
      }
    }
    if (transpiled !== "")
      return apps2[hash];
  }
  return apps2[hash];
}
__name(appFactory, "appFactory");
function createJsBlob(code) {
  return URL.createObjectURL(
    new Blob([code], {
      type: "application/javascript"
    })
  );
}
__name(createJsBlob, "createJsBlob");

// js/renderPreviewWindow.tsx
var import_react8 = __toESM(require_emotion_react_cjs(), 1);

// js/Editor.tsx
init_define_process();
var import_react5 = __toESM(require_emotion_react_cjs(), 1);
var import_react6 = __toESM(require_react(), 1);

// ../../.yarn/__virtual__/react-rnd-virtual-1610495181/0/global/cache/react-rnd-npm-10.3.7-cb1aaea902-9.zip/node_modules/react-rnd/lib/index.js
init_define_process();
var import_react4 = __toESM(require_react());
var import_react_draggable = __toESM(require_cjs());

// ../../.yarn/__virtual__/re-resizable-virtual-3b39e27e89/0/global/cache/re-resizable-npm-6.9.6-ea5c7065a7-9.zip/node_modules/re-resizable/lib/index.js
init_define_process();
var React3 = __toESM(require_react());

// ../../.yarn/__virtual__/re-resizable-virtual-3b39e27e89/0/global/cache/re-resizable-npm-6.9.6-ea5c7065a7-9.zip/node_modules/re-resizable/lib/resizer.js
init_define_process();
var React2 = __toESM(require_react());
var __extends2 = function() {
  var extendStatics2 = /* @__PURE__ */ __name(function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  }, "extendStatics");
  return function(d2, b2) {
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    __name(__, "__");
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var styles = {
  top: {
    width: "100%",
    height: "10px",
    top: "-5px",
    left: "0px",
    cursor: "row-resize"
  },
  right: {
    width: "10px",
    height: "100%",
    top: "0px",
    right: "-5px",
    cursor: "col-resize"
  },
  bottom: {
    width: "100%",
    height: "10px",
    bottom: "-5px",
    left: "0px",
    cursor: "row-resize"
  },
  left: {
    width: "10px",
    height: "100%",
    top: "0px",
    left: "-5px",
    cursor: "col-resize"
  },
  topRight: {
    width: "20px",
    height: "20px",
    position: "absolute",
    right: "-10px",
    top: "-10px",
    cursor: "ne-resize"
  },
  bottomRight: {
    width: "20px",
    height: "20px",
    position: "absolute",
    right: "-10px",
    bottom: "-10px",
    cursor: "se-resize"
  },
  bottomLeft: {
    width: "20px",
    height: "20px",
    position: "absolute",
    left: "-10px",
    bottom: "-10px",
    cursor: "sw-resize"
  },
  topLeft: {
    width: "20px",
    height: "20px",
    position: "absolute",
    left: "-10px",
    top: "-10px",
    cursor: "nw-resize"
  }
};
var Resizer = function(_super) {
  __extends2(Resizer2, _super);
  function Resizer2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onMouseDown = function(e2) {
      _this.props.onResizeStart(e2, _this.props.direction);
    };
    _this.onTouchStart = function(e2) {
      _this.props.onResizeStart(e2, _this.props.direction);
    };
    return _this;
  }
  __name(Resizer2, "Resizer");
  Resizer2.prototype.render = function() {
    return React2.createElement("div", { className: this.props.className || "", style: __assign(__assign({ position: "absolute", userSelect: "none" }, styles[this.props.direction]), this.props.replaceStyles || {}), onMouseDown: this.onMouseDown, onTouchStart: this.onTouchStart }, this.props.children);
  };
  return Resizer2;
}(React2.PureComponent);

// ../../.yarn/__virtual__/re-resizable-virtual-3b39e27e89/0/global/cache/re-resizable-npm-6.9.6-ea5c7065a7-9.zip/node_modules/re-resizable/lib/index.js
var import_fast_memoize = __toESM(require_src());
var __extends3 = function() {
  var extendStatics2 = /* @__PURE__ */ __name(function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  }, "extendStatics");
  return function(d2, b2) {
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    __name(__, "__");
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign2 = function() {
  __assign2 = Object.assign || function(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign2.apply(this, arguments);
};
var DEFAULT_SIZE = {
  width: "auto",
  height: "auto"
};
var clamp = (0, import_fast_memoize.default)(function(n2, min, max) {
  return Math.max(Math.min(n2, max), min);
});
var snap = (0, import_fast_memoize.default)(function(n2, size) {
  return Math.round(n2 / size) * size;
});
var hasDirection = (0, import_fast_memoize.default)(function(dir, target) {
  return new RegExp(dir, "i").test(target);
});
var isTouchEvent = /* @__PURE__ */ __name(function(event) {
  return Boolean(event.touches && event.touches.length);
}, "isTouchEvent");
var isMouseEvent = /* @__PURE__ */ __name(function(event) {
  return Boolean((event.clientX || event.clientX === 0) && (event.clientY || event.clientY === 0));
}, "isMouseEvent");
var findClosestSnap = (0, import_fast_memoize.default)(function(n2, snapArray, snapGap) {
  if (snapGap === void 0) {
    snapGap = 0;
  }
  var closestGapIndex = snapArray.reduce(function(prev, curr, index) {
    return Math.abs(curr - n2) < Math.abs(snapArray[prev] - n2) ? index : prev;
  }, 0);
  var gap = Math.abs(snapArray[closestGapIndex] - n2);
  return snapGap === 0 || gap < snapGap ? snapArray[closestGapIndex] : n2;
});
var endsWith = (0, import_fast_memoize.default)(function(str, searchStr) {
  return str.substr(str.length - searchStr.length, searchStr.length) === searchStr;
});
var getStringSize = (0, import_fast_memoize.default)(function(n2) {
  n2 = n2.toString();
  if (n2 === "auto") {
    return n2;
  }
  if (endsWith(n2, "px")) {
    return n2;
  }
  if (endsWith(n2, "%")) {
    return n2;
  }
  if (endsWith(n2, "vh")) {
    return n2;
  }
  if (endsWith(n2, "vw")) {
    return n2;
  }
  if (endsWith(n2, "vmax")) {
    return n2;
  }
  if (endsWith(n2, "vmin")) {
    return n2;
  }
  return n2 + "px";
});
var getPixelSize = /* @__PURE__ */ __name(function(size, parentSize, innerWidth, innerHeight) {
  if (size && typeof size === "string") {
    if (endsWith(size, "px")) {
      return Number(size.replace("px", ""));
    }
    if (endsWith(size, "%")) {
      var ratio = Number(size.replace("%", "")) / 100;
      return parentSize * ratio;
    }
    if (endsWith(size, "vw")) {
      var ratio = Number(size.replace("vw", "")) / 100;
      return innerWidth * ratio;
    }
    if (endsWith(size, "vh")) {
      var ratio = Number(size.replace("vh", "")) / 100;
      return innerHeight * ratio;
    }
  }
  return size;
}, "getPixelSize");
var calculateNewMax = (0, import_fast_memoize.default)(function(parentSize, innerWidth, innerHeight, maxWidth, maxHeight, minWidth, minHeight) {
  maxWidth = getPixelSize(maxWidth, parentSize.width, innerWidth, innerHeight);
  maxHeight = getPixelSize(maxHeight, parentSize.height, innerWidth, innerHeight);
  minWidth = getPixelSize(minWidth, parentSize.width, innerWidth, innerHeight);
  minHeight = getPixelSize(minHeight, parentSize.height, innerWidth, innerHeight);
  return {
    maxWidth: typeof maxWidth === "undefined" ? void 0 : Number(maxWidth),
    maxHeight: typeof maxHeight === "undefined" ? void 0 : Number(maxHeight),
    minWidth: typeof minWidth === "undefined" ? void 0 : Number(minWidth),
    minHeight: typeof minHeight === "undefined" ? void 0 : Number(minHeight)
  };
});
var definedProps = [
  "as",
  "style",
  "className",
  "grid",
  "snap",
  "bounds",
  "boundsByDirection",
  "size",
  "defaultSize",
  "minWidth",
  "minHeight",
  "maxWidth",
  "maxHeight",
  "lockAspectRatio",
  "lockAspectRatioExtraWidth",
  "lockAspectRatioExtraHeight",
  "enable",
  "handleStyles",
  "handleClasses",
  "handleWrapperStyle",
  "handleWrapperClass",
  "children",
  "onResizeStart",
  "onResize",
  "onResizeStop",
  "handleComponent",
  "scale",
  "resizeRatio",
  "snapGap"
];
var baseClassName = "__resizable_base__";
var Resizable = function(_super) {
  __extends3(Resizable2, _super);
  function Resizable2(props) {
    var _this = _super.call(this, props) || this;
    _this.ratio = 1;
    _this.resizable = null;
    _this.parentLeft = 0;
    _this.parentTop = 0;
    _this.resizableLeft = 0;
    _this.resizableRight = 0;
    _this.resizableTop = 0;
    _this.resizableBottom = 0;
    _this.targetLeft = 0;
    _this.targetTop = 0;
    _this.appendBase = function() {
      if (!_this.resizable || !_this.window) {
        return null;
      }
      var parent = _this.parentNode;
      if (!parent) {
        return null;
      }
      var element = _this.window.document.createElement("div");
      element.style.width = "100%";
      element.style.height = "100%";
      element.style.position = "absolute";
      element.style.transform = "scale(0, 0)";
      element.style.left = "0";
      element.style.flex = "0 0 100%";
      if (element.classList) {
        element.classList.add(baseClassName);
      } else {
        element.className += baseClassName;
      }
      parent.appendChild(element);
      return element;
    };
    _this.removeBase = function(base) {
      var parent = _this.parentNode;
      if (!parent) {
        return;
      }
      parent.removeChild(base);
    };
    _this.ref = function(c2) {
      if (c2) {
        _this.resizable = c2;
      }
    };
    _this.state = {
      isResizing: false,
      width: typeof (_this.propsSize && _this.propsSize.width) === "undefined" ? "auto" : _this.propsSize && _this.propsSize.width,
      height: typeof (_this.propsSize && _this.propsSize.height) === "undefined" ? "auto" : _this.propsSize && _this.propsSize.height,
      direction: "right",
      original: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      backgroundStyle: {
        height: "100%",
        width: "100%",
        backgroundColor: "rgba(0,0,0,0)",
        cursor: "auto",
        opacity: 0,
        position: "fixed",
        zIndex: 9999,
        top: "0",
        left: "0",
        bottom: "0",
        right: "0"
      },
      flexBasis: void 0
    };
    _this.onResizeStart = _this.onResizeStart.bind(_this);
    _this.onMouseMove = _this.onMouseMove.bind(_this);
    _this.onMouseUp = _this.onMouseUp.bind(_this);
    return _this;
  }
  __name(Resizable2, "Resizable");
  Object.defineProperty(Resizable2.prototype, "parentNode", {
    get: function() {
      if (!this.resizable) {
        return null;
      }
      return this.resizable.parentNode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Resizable2.prototype, "window", {
    get: function() {
      if (!this.resizable) {
        return null;
      }
      if (!this.resizable.ownerDocument) {
        return null;
      }
      return this.resizable.ownerDocument.defaultView;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Resizable2.prototype, "propsSize", {
    get: function() {
      return this.props.size || this.props.defaultSize || DEFAULT_SIZE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Resizable2.prototype, "size", {
    get: function() {
      var width = 0;
      var height2 = 0;
      if (this.resizable && this.window) {
        var orgWidth = this.resizable.offsetWidth;
        var orgHeight = this.resizable.offsetHeight;
        var orgPosition = this.resizable.style.position;
        if (orgPosition !== "relative") {
          this.resizable.style.position = "relative";
        }
        width = this.resizable.style.width !== "auto" ? this.resizable.offsetWidth : orgWidth;
        height2 = this.resizable.style.height !== "auto" ? this.resizable.offsetHeight : orgHeight;
        this.resizable.style.position = orgPosition;
      }
      return { width, height: height2 };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Resizable2.prototype, "sizeStyle", {
    get: function() {
      var _this = this;
      var size = this.props.size;
      var getSize = /* @__PURE__ */ __name(function(key) {
        if (typeof _this.state[key] === "undefined" || _this.state[key] === "auto") {
          return "auto";
        }
        if (_this.propsSize && _this.propsSize[key] && endsWith(_this.propsSize[key].toString(), "%")) {
          if (endsWith(_this.state[key].toString(), "%")) {
            return _this.state[key].toString();
          }
          var parentSize = _this.getParentSize();
          var value = Number(_this.state[key].toString().replace("px", ""));
          var percent = value / parentSize[key] * 100;
          return percent + "%";
        }
        return getStringSize(_this.state[key]);
      }, "getSize");
      var width = size && typeof size.width !== "undefined" && !this.state.isResizing ? getStringSize(size.width) : getSize("width");
      var height2 = size && typeof size.height !== "undefined" && !this.state.isResizing ? getStringSize(size.height) : getSize("height");
      return { width, height: height2 };
    },
    enumerable: false,
    configurable: true
  });
  Resizable2.prototype.getParentSize = function() {
    if (!this.parentNode) {
      if (!this.window) {
        return { width: 0, height: 0 };
      }
      return { width: this.window.innerWidth, height: this.window.innerHeight };
    }
    var base = this.appendBase();
    if (!base) {
      return { width: 0, height: 0 };
    }
    var wrapChanged = false;
    var wrap = this.parentNode.style.flexWrap;
    if (wrap !== "wrap") {
      wrapChanged = true;
      this.parentNode.style.flexWrap = "wrap";
    }
    base.style.position = "relative";
    base.style.minWidth = "100%";
    base.style.minHeight = "100%";
    var size = {
      width: base.offsetWidth,
      height: base.offsetHeight
    };
    if (wrapChanged) {
      this.parentNode.style.flexWrap = wrap;
    }
    this.removeBase(base);
    return size;
  };
  Resizable2.prototype.bindEvents = function() {
    if (this.window) {
      this.window.addEventListener("mouseup", this.onMouseUp);
      this.window.addEventListener("mousemove", this.onMouseMove);
      this.window.addEventListener("mouseleave", this.onMouseUp);
      this.window.addEventListener("touchmove", this.onMouseMove, {
        capture: true,
        passive: false
      });
      this.window.addEventListener("touchend", this.onMouseUp);
    }
  };
  Resizable2.prototype.unbindEvents = function() {
    if (this.window) {
      this.window.removeEventListener("mouseup", this.onMouseUp);
      this.window.removeEventListener("mousemove", this.onMouseMove);
      this.window.removeEventListener("mouseleave", this.onMouseUp);
      this.window.removeEventListener("touchmove", this.onMouseMove, true);
      this.window.removeEventListener("touchend", this.onMouseUp);
    }
  };
  Resizable2.prototype.componentDidMount = function() {
    if (!this.resizable || !this.window) {
      return;
    }
    var computedStyle = this.window.getComputedStyle(this.resizable);
    this.setState({
      width: this.state.width || this.size.width,
      height: this.state.height || this.size.height,
      flexBasis: computedStyle.flexBasis !== "auto" ? computedStyle.flexBasis : void 0
    });
  };
  Resizable2.prototype.componentWillUnmount = function() {
    if (this.window) {
      this.unbindEvents();
    }
  };
  Resizable2.prototype.createSizeForCssProperty = function(newSize, kind) {
    var propsSize = this.propsSize && this.propsSize[kind];
    return this.state[kind] === "auto" && this.state.original[kind] === newSize && (typeof propsSize === "undefined" || propsSize === "auto") ? "auto" : newSize;
  };
  Resizable2.prototype.calculateNewMaxFromBoundary = function(maxWidth, maxHeight) {
    var boundsByDirection = this.props.boundsByDirection;
    var direction = this.state.direction;
    var widthByDirection = boundsByDirection && hasDirection("left", direction);
    var heightByDirection = boundsByDirection && hasDirection("top", direction);
    var boundWidth;
    var boundHeight;
    if (this.props.bounds === "parent") {
      var parent_1 = this.parentNode;
      if (parent_1) {
        boundWidth = widthByDirection ? this.resizableRight - this.parentLeft : parent_1.offsetWidth + (this.parentLeft - this.resizableLeft);
        boundHeight = heightByDirection ? this.resizableBottom - this.parentTop : parent_1.offsetHeight + (this.parentTop - this.resizableTop);
      }
    } else if (this.props.bounds === "window") {
      if (this.window) {
        boundWidth = widthByDirection ? this.resizableRight : this.window.innerWidth - this.resizableLeft;
        boundHeight = heightByDirection ? this.resizableBottom : this.window.innerHeight - this.resizableTop;
      }
    } else if (this.props.bounds) {
      boundWidth = widthByDirection ? this.resizableRight - this.targetLeft : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft);
      boundHeight = heightByDirection ? this.resizableBottom - this.targetTop : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop);
    }
    if (boundWidth && Number.isFinite(boundWidth)) {
      maxWidth = maxWidth && maxWidth < boundWidth ? maxWidth : boundWidth;
    }
    if (boundHeight && Number.isFinite(boundHeight)) {
      maxHeight = maxHeight && maxHeight < boundHeight ? maxHeight : boundHeight;
    }
    return { maxWidth, maxHeight };
  };
  Resizable2.prototype.calculateNewSizeFromDirection = function(clientX, clientY) {
    var scale = this.props.scale || 1;
    var resizeRatio = this.props.resizeRatio || 1;
    var _a = this.state, direction = _a.direction, original = _a.original;
    var _b = this.props, lockAspectRatio = _b.lockAspectRatio, lockAspectRatioExtraHeight = _b.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _b.lockAspectRatioExtraWidth;
    var newWidth = original.width;
    var newHeight = original.height;
    var extraHeight = lockAspectRatioExtraHeight || 0;
    var extraWidth = lockAspectRatioExtraWidth || 0;
    if (hasDirection("right", direction)) {
      newWidth = original.width + (clientX - original.x) * resizeRatio / scale;
      if (lockAspectRatio) {
        newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
      }
    }
    if (hasDirection("left", direction)) {
      newWidth = original.width - (clientX - original.x) * resizeRatio / scale;
      if (lockAspectRatio) {
        newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
      }
    }
    if (hasDirection("bottom", direction)) {
      newHeight = original.height + (clientY - original.y) * resizeRatio / scale;
      if (lockAspectRatio) {
        newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
      }
    }
    if (hasDirection("top", direction)) {
      newHeight = original.height - (clientY - original.y) * resizeRatio / scale;
      if (lockAspectRatio) {
        newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
      }
    }
    return { newWidth, newHeight };
  };
  Resizable2.prototype.calculateNewSizeFromAspectRatio = function(newWidth, newHeight, max, min) {
    var _a = this.props, lockAspectRatio = _a.lockAspectRatio, lockAspectRatioExtraHeight = _a.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _a.lockAspectRatioExtraWidth;
    var computedMinWidth = typeof min.width === "undefined" ? 10 : min.width;
    var computedMaxWidth = typeof max.width === "undefined" || max.width < 0 ? newWidth : max.width;
    var computedMinHeight = typeof min.height === "undefined" ? 10 : min.height;
    var computedMaxHeight = typeof max.height === "undefined" || max.height < 0 ? newHeight : max.height;
    var extraHeight = lockAspectRatioExtraHeight || 0;
    var extraWidth = lockAspectRatioExtraWidth || 0;
    if (lockAspectRatio) {
      var extraMinWidth = (computedMinHeight - extraHeight) * this.ratio + extraWidth;
      var extraMaxWidth = (computedMaxHeight - extraHeight) * this.ratio + extraWidth;
      var extraMinHeight = (computedMinWidth - extraWidth) / this.ratio + extraHeight;
      var extraMaxHeight = (computedMaxWidth - extraWidth) / this.ratio + extraHeight;
      var lockedMinWidth = Math.max(computedMinWidth, extraMinWidth);
      var lockedMaxWidth = Math.min(computedMaxWidth, extraMaxWidth);
      var lockedMinHeight = Math.max(computedMinHeight, extraMinHeight);
      var lockedMaxHeight = Math.min(computedMaxHeight, extraMaxHeight);
      newWidth = clamp(newWidth, lockedMinWidth, lockedMaxWidth);
      newHeight = clamp(newHeight, lockedMinHeight, lockedMaxHeight);
    } else {
      newWidth = clamp(newWidth, computedMinWidth, computedMaxWidth);
      newHeight = clamp(newHeight, computedMinHeight, computedMaxHeight);
    }
    return { newWidth, newHeight };
  };
  Resizable2.prototype.setBoundingClientRect = function() {
    if (this.props.bounds === "parent") {
      var parent_2 = this.parentNode;
      if (parent_2) {
        var parentRect = parent_2.getBoundingClientRect();
        this.parentLeft = parentRect.left;
        this.parentTop = parentRect.top;
      }
    }
    if (this.props.bounds && typeof this.props.bounds !== "string") {
      var targetRect = this.props.bounds.getBoundingClientRect();
      this.targetLeft = targetRect.left;
      this.targetTop = targetRect.top;
    }
    if (this.resizable) {
      var _a = this.resizable.getBoundingClientRect(), left = _a.left, top_1 = _a.top, right = _a.right, bottom = _a.bottom;
      this.resizableLeft = left;
      this.resizableRight = right;
      this.resizableTop = top_1;
      this.resizableBottom = bottom;
    }
  };
  Resizable2.prototype.onResizeStart = function(event, direction) {
    if (!this.resizable || !this.window) {
      return;
    }
    var clientX = 0;
    var clientY = 0;
    if (event.nativeEvent && isMouseEvent(event.nativeEvent)) {
      clientX = event.nativeEvent.clientX;
      clientY = event.nativeEvent.clientY;
    } else if (event.nativeEvent && isTouchEvent(event.nativeEvent)) {
      clientX = event.nativeEvent.touches[0].clientX;
      clientY = event.nativeEvent.touches[0].clientY;
    }
    if (this.props.onResizeStart) {
      if (this.resizable) {
        var startResize = this.props.onResizeStart(event, direction, this.resizable);
        if (startResize === false) {
          return;
        }
      }
    }
    if (this.props.size) {
      if (typeof this.props.size.height !== "undefined" && this.props.size.height !== this.state.height) {
        this.setState({ height: this.props.size.height });
      }
      if (typeof this.props.size.width !== "undefined" && this.props.size.width !== this.state.width) {
        this.setState({ width: this.props.size.width });
      }
    }
    this.ratio = typeof this.props.lockAspectRatio === "number" ? this.props.lockAspectRatio : this.size.width / this.size.height;
    var flexBasis;
    var computedStyle = this.window.getComputedStyle(this.resizable);
    if (computedStyle.flexBasis !== "auto") {
      var parent_3 = this.parentNode;
      if (parent_3) {
        var dir = this.window.getComputedStyle(parent_3).flexDirection;
        this.flexDir = dir.startsWith("row") ? "row" : "column";
        flexBasis = computedStyle.flexBasis;
      }
    }
    this.setBoundingClientRect();
    this.bindEvents();
    var state = {
      original: {
        x: clientX,
        y: clientY,
        width: this.size.width,
        height: this.size.height
      },
      isResizing: true,
      backgroundStyle: __assign2(__assign2({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(event.target).cursor || "auto" }),
      direction,
      flexBasis
    };
    this.setState(state);
  };
  Resizable2.prototype.onMouseMove = function(event) {
    if (!this.state.isResizing || !this.resizable || !this.window) {
      return;
    }
    if (this.window.TouchEvent && isTouchEvent(event)) {
      try {
        event.preventDefault();
        event.stopPropagation();
      } catch (e2) {
      }
    }
    var _a = this.props, maxWidth = _a.maxWidth, maxHeight = _a.maxHeight, minWidth = _a.minWidth, minHeight = _a.minHeight;
    var clientX = isTouchEvent(event) ? event.touches[0].clientX : event.clientX;
    var clientY = isTouchEvent(event) ? event.touches[0].clientY : event.clientY;
    var _b = this.state, direction = _b.direction, original = _b.original, width = _b.width, height2 = _b.height;
    var parentSize = this.getParentSize();
    var max = calculateNewMax(parentSize, this.window.innerWidth, this.window.innerHeight, maxWidth, maxHeight, minWidth, minHeight);
    maxWidth = max.maxWidth;
    maxHeight = max.maxHeight;
    minWidth = max.minWidth;
    minHeight = max.minHeight;
    var _c = this.calculateNewSizeFromDirection(clientX, clientY), newHeight = _c.newHeight, newWidth = _c.newWidth;
    var boundaryMax = this.calculateNewMaxFromBoundary(maxWidth, maxHeight);
    if (this.props.snap && this.props.snap.x) {
      newWidth = findClosestSnap(newWidth, this.props.snap.x, this.props.snapGap);
    }
    if (this.props.snap && this.props.snap.y) {
      newHeight = findClosestSnap(newHeight, this.props.snap.y, this.props.snapGap);
    }
    var newSize = this.calculateNewSizeFromAspectRatio(newWidth, newHeight, { width: boundaryMax.maxWidth, height: boundaryMax.maxHeight }, { width: minWidth, height: minHeight });
    newWidth = newSize.newWidth;
    newHeight = newSize.newHeight;
    if (this.props.grid) {
      var newGridWidth = snap(newWidth, this.props.grid[0]);
      var newGridHeight = snap(newHeight, this.props.grid[1]);
      var gap = this.props.snapGap || 0;
      newWidth = gap === 0 || Math.abs(newGridWidth - newWidth) <= gap ? newGridWidth : newWidth;
      newHeight = gap === 0 || Math.abs(newGridHeight - newHeight) <= gap ? newGridHeight : newHeight;
    }
    var delta = {
      width: newWidth - original.width,
      height: newHeight - original.height
    };
    if (width && typeof width === "string") {
      if (endsWith(width, "%")) {
        var percent = newWidth / parentSize.width * 100;
        newWidth = percent + "%";
      } else if (endsWith(width, "vw")) {
        var vw = newWidth / this.window.innerWidth * 100;
        newWidth = vw + "vw";
      } else if (endsWith(width, "vh")) {
        var vh = newWidth / this.window.innerHeight * 100;
        newWidth = vh + "vh";
      }
    }
    if (height2 && typeof height2 === "string") {
      if (endsWith(height2, "%")) {
        var percent = newHeight / parentSize.height * 100;
        newHeight = percent + "%";
      } else if (endsWith(height2, "vw")) {
        var vw = newHeight / this.window.innerWidth * 100;
        newHeight = vw + "vw";
      } else if (endsWith(height2, "vh")) {
        var vh = newHeight / this.window.innerHeight * 100;
        newHeight = vh + "vh";
      }
    }
    var newState = {
      width: this.createSizeForCssProperty(newWidth, "width"),
      height: this.createSizeForCssProperty(newHeight, "height")
    };
    if (this.flexDir === "row") {
      newState.flexBasis = newState.width;
    } else if (this.flexDir === "column") {
      newState.flexBasis = newState.height;
    }
    this.setState(newState);
    if (this.props.onResize) {
      this.props.onResize(event, direction, this.resizable, delta);
    }
  };
  Resizable2.prototype.onMouseUp = function(event) {
    var _a = this.state, isResizing = _a.isResizing, direction = _a.direction, original = _a.original;
    if (!isResizing || !this.resizable) {
      return;
    }
    var delta = {
      width: this.size.width - original.width,
      height: this.size.height - original.height
    };
    if (this.props.onResizeStop) {
      this.props.onResizeStop(event, direction, this.resizable, delta);
    }
    if (this.props.size) {
      this.setState(this.props.size);
    }
    this.unbindEvents();
    this.setState({
      isResizing: false,
      backgroundStyle: __assign2(__assign2({}, this.state.backgroundStyle), { cursor: "auto" })
    });
  };
  Resizable2.prototype.updateSize = function(size) {
    this.setState({ width: size.width, height: size.height });
  };
  Resizable2.prototype.renderResizer = function() {
    var _this = this;
    var _a = this.props, enable = _a.enable, handleStyles = _a.handleStyles, handleClasses = _a.handleClasses, handleWrapperStyle = _a.handleWrapperStyle, handleWrapperClass = _a.handleWrapperClass, handleComponent = _a.handleComponent;
    if (!enable) {
      return null;
    }
    var resizers = Object.keys(enable).map(function(dir) {
      if (enable[dir] !== false) {
        return React3.createElement(Resizer, { key: dir, direction: dir, onResizeStart: _this.onResizeStart, replaceStyles: handleStyles && handleStyles[dir], className: handleClasses && handleClasses[dir] }, handleComponent && handleComponent[dir] ? handleComponent[dir] : null);
      }
      return null;
    });
    return React3.createElement("div", { className: handleWrapperClass, style: handleWrapperStyle }, resizers);
  };
  Resizable2.prototype.render = function() {
    var _this = this;
    var extendsProps = Object.keys(this.props).reduce(function(acc, key) {
      if (definedProps.indexOf(key) !== -1) {
        return acc;
      }
      acc[key] = _this.props[key];
      return acc;
    }, {});
    var style = __assign2(__assign2(__assign2({ position: "relative", userSelect: this.state.isResizing ? "none" : "auto" }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: "border-box", flexShrink: 0 });
    if (this.state.flexBasis) {
      style.flexBasis = this.state.flexBasis;
    }
    var Wrapper = this.props.as || "div";
    return React3.createElement(
      Wrapper,
      __assign2({ ref: this.ref, style, className: this.props.className }, extendsProps),
      this.state.isResizing && React3.createElement("div", { style: this.state.backgroundStyle }),
      this.props.children,
      this.renderResizer()
    );
  };
  Resizable2.defaultProps = {
    as: "div",
    onResizeStart: function() {
    },
    onResize: function() {
    },
    onResizeStop: function() {
    },
    enable: {
      top: true,
      right: true,
      bottom: true,
      left: true,
      topRight: true,
      bottomRight: true,
      bottomLeft: true,
      topLeft: true
    },
    style: {},
    grid: [1, 1],
    lockAspectRatio: false,
    lockAspectRatioExtraWidth: 0,
    lockAspectRatioExtraHeight: 0,
    scale: 1,
    resizeRatio: 1,
    snapGap: 0
  };
  return Resizable2;
}(React3.PureComponent);

// ../../.yarn/__virtual__/react-rnd-virtual-1610495181/0/global/cache/react-rnd-npm-10.3.7-cb1aaea902-9.zip/node_modules/react-rnd/lib/index.js
var extendStatics = /* @__PURE__ */ __name(function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
}, "extendStatics");
function __extends4(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  __name(__, "__");
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
__name(__extends4, "__extends");
var __assign3 = /* @__PURE__ */ __name(function() {
  __assign3 = Object.assign || /* @__PURE__ */ __name(function __assign4(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  }, "__assign");
  return __assign3.apply(this, arguments);
}, "__assign");
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
__name(__rest, "__rest");
var Draggable = import_react_draggable.default;
var resizableStyle = {
  width: "auto",
  height: "auto",
  display: "inline-block",
  position: "absolute",
  top: 0,
  left: 0
};
var getEnableResizingByFlag = /* @__PURE__ */ __name(function(flag) {
  return {
    bottom: flag,
    bottomLeft: flag,
    bottomRight: flag,
    left: flag,
    right: flag,
    top: flag,
    topLeft: flag,
    topRight: flag
  };
}, "getEnableResizingByFlag");
var Rnd = function(_super) {
  __extends4(Rnd2, _super);
  function Rnd2(props) {
    var _this = _super.call(this, props) || this;
    _this.resizingPosition = { x: 0, y: 0 };
    _this.offsetFromParent = { left: 0, top: 0 };
    _this.resizableElement = { current: null };
    _this.originalPosition = { x: 0, y: 0 };
    _this.refDraggable = function(c2) {
      if (!c2)
        return;
      _this.draggable = c2;
    };
    _this.refResizable = function(c2) {
      if (!c2)
        return;
      _this.resizable = c2;
      _this.resizableElement.current = c2.resizable;
    };
    _this.state = {
      resizing: false,
      bounds: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      },
      maxWidth: props.maxWidth,
      maxHeight: props.maxHeight
    };
    _this.onResizeStart = _this.onResizeStart.bind(_this);
    _this.onResize = _this.onResize.bind(_this);
    _this.onResizeStop = _this.onResizeStop.bind(_this);
    _this.onDragStart = _this.onDragStart.bind(_this);
    _this.onDrag = _this.onDrag.bind(_this);
    _this.onDragStop = _this.onDragStop.bind(_this);
    _this.getMaxSizesFromProps = _this.getMaxSizesFromProps.bind(_this);
    return _this;
  }
  __name(Rnd2, "Rnd");
  Rnd2.prototype.componentDidMount = function() {
    this.updateOffsetFromParent();
    var _a = this.offsetFromParent, left = _a.left, top = _a.top;
    var _b = this.getDraggablePosition(), x2 = _b.x, y2 = _b.y;
    this.draggable.setState({
      x: x2 - left,
      y: y2 - top
    });
    this.forceUpdate();
  };
  Rnd2.prototype.getDraggablePosition = function() {
    var _a = this.draggable.state, x2 = _a.x, y2 = _a.y;
    return { x: x2, y: y2 };
  };
  Rnd2.prototype.getParent = function() {
    return this.resizable && this.resizable.parentNode;
  };
  Rnd2.prototype.getParentSize = function() {
    return this.resizable.getParentSize();
  };
  Rnd2.prototype.getMaxSizesFromProps = function() {
    var maxWidth = typeof this.props.maxWidth === "undefined" ? Number.MAX_SAFE_INTEGER : this.props.maxWidth;
    var maxHeight = typeof this.props.maxHeight === "undefined" ? Number.MAX_SAFE_INTEGER : this.props.maxHeight;
    return { maxWidth, maxHeight };
  };
  Rnd2.prototype.getSelfElement = function() {
    return this.resizable && this.resizable.resizable;
  };
  Rnd2.prototype.getOffsetHeight = function(boundary) {
    var scale = this.props.scale;
    switch (this.props.bounds) {
      case "window":
        return window.innerHeight / scale;
      case "body":
        return document.body.offsetHeight / scale;
      default:
        return boundary.offsetHeight;
    }
  };
  Rnd2.prototype.getOffsetWidth = function(boundary) {
    var scale = this.props.scale;
    switch (this.props.bounds) {
      case "window":
        return window.innerWidth / scale;
      case "body":
        return document.body.offsetWidth / scale;
      default:
        return boundary.offsetWidth;
    }
  };
  Rnd2.prototype.onDragStart = function(e2, data) {
    if (this.props.onDragStart) {
      this.props.onDragStart(e2, data);
    }
    var pos = this.getDraggablePosition();
    this.originalPosition = pos;
    if (!this.props.bounds)
      return;
    var parent = this.getParent();
    var scale = this.props.scale;
    var boundary;
    if (this.props.bounds === "parent") {
      boundary = parent;
    } else if (this.props.bounds === "body") {
      var parentRect_1 = parent.getBoundingClientRect();
      var parentLeft_1 = parentRect_1.left;
      var parentTop_1 = parentRect_1.top;
      var bodyRect = document.body.getBoundingClientRect();
      var left_1 = -(parentLeft_1 - parent.offsetLeft * scale - bodyRect.left) / scale;
      var top_1 = -(parentTop_1 - parent.offsetTop * scale - bodyRect.top) / scale;
      var right = (document.body.offsetWidth - this.resizable.size.width * scale) / scale + left_1;
      var bottom = (document.body.offsetHeight - this.resizable.size.height * scale) / scale + top_1;
      return this.setState({ bounds: { top: top_1, right, bottom, left: left_1 } });
    } else if (this.props.bounds === "window") {
      if (!this.resizable)
        return;
      var parentRect_2 = parent.getBoundingClientRect();
      var parentLeft_2 = parentRect_2.left;
      var parentTop_2 = parentRect_2.top;
      var left_2 = -(parentLeft_2 - parent.offsetLeft * scale) / scale;
      var top_2 = -(parentTop_2 - parent.offsetTop * scale) / scale;
      var right = (window.innerWidth - this.resizable.size.width * scale) / scale + left_2;
      var bottom = (window.innerHeight - this.resizable.size.height * scale) / scale + top_2;
      return this.setState({ bounds: { top: top_2, right, bottom, left: left_2 } });
    } else {
      boundary = document.querySelector(this.props.bounds);
    }
    if (!(boundary instanceof HTMLElement) || !(parent instanceof HTMLElement)) {
      return;
    }
    var boundaryRect = boundary.getBoundingClientRect();
    var boundaryLeft = boundaryRect.left;
    var boundaryTop = boundaryRect.top;
    var parentRect = parent.getBoundingClientRect();
    var parentLeft = parentRect.left;
    var parentTop = parentRect.top;
    var left = (boundaryLeft - parentLeft) / scale;
    var top = boundaryTop - parentTop;
    if (!this.resizable)
      return;
    this.updateOffsetFromParent();
    var offset = this.offsetFromParent;
    this.setState({
      bounds: {
        top: top - offset.top,
        right: left + (boundary.offsetWidth - this.resizable.size.width) - offset.left / scale,
        bottom: top + (boundary.offsetHeight - this.resizable.size.height) - offset.top,
        left: left - offset.left / scale
      }
    });
  };
  Rnd2.prototype.onDrag = function(e2, data) {
    if (!this.props.onDrag)
      return;
    var _a = this.offsetFromParent, left = _a.left, top = _a.top;
    if (!this.props.dragAxis || this.props.dragAxis === "both") {
      return this.props.onDrag(e2, __assign3(__assign3({}, data), { x: data.x - left, y: data.y - top }));
    } else if (this.props.dragAxis === "x") {
      return this.props.onDrag(e2, __assign3(__assign3({}, data), { x: data.x + left, y: this.originalPosition.y + top, deltaY: 0 }));
    } else if (this.props.dragAxis === "y") {
      return this.props.onDrag(e2, __assign3(__assign3({}, data), { x: this.originalPosition.x + left, y: data.y + top, deltaX: 0 }));
    }
  };
  Rnd2.prototype.onDragStop = function(e2, data) {
    if (!this.props.onDragStop)
      return;
    var _a = this.offsetFromParent, left = _a.left, top = _a.top;
    if (!this.props.dragAxis || this.props.dragAxis === "both") {
      return this.props.onDragStop(e2, __assign3(__assign3({}, data), { x: data.x + left, y: data.y + top }));
    } else if (this.props.dragAxis === "x") {
      return this.props.onDragStop(e2, __assign3(__assign3({}, data), { x: data.x + left, y: this.originalPosition.y + top, deltaY: 0 }));
    } else if (this.props.dragAxis === "y") {
      return this.props.onDragStop(e2, __assign3(__assign3({}, data), { x: this.originalPosition.x + left, y: data.y + top, deltaX: 0 }));
    }
  };
  Rnd2.prototype.onResizeStart = function(e2, dir, elementRef) {
    e2.stopPropagation();
    this.setState({
      resizing: true
    });
    var scale = this.props.scale;
    var offset = this.offsetFromParent;
    var pos = this.getDraggablePosition();
    this.resizingPosition = { x: pos.x + offset.left, y: pos.y + offset.top };
    this.originalPosition = pos;
    if (this.props.bounds) {
      var parent_1 = this.getParent();
      var boundary = void 0;
      if (this.props.bounds === "parent") {
        boundary = parent_1;
      } else if (this.props.bounds === "body") {
        boundary = document.body;
      } else if (this.props.bounds === "window") {
        boundary = window;
      } else {
        boundary = document.querySelector(this.props.bounds);
      }
      var self_1 = this.getSelfElement();
      if (self_1 instanceof Element && (boundary instanceof HTMLElement || boundary === window) && parent_1 instanceof HTMLElement) {
        var _a = this.getMaxSizesFromProps(), maxWidth = _a.maxWidth, maxHeight = _a.maxHeight;
        var parentSize = this.getParentSize();
        if (maxWidth && typeof maxWidth === "string") {
          if (maxWidth.endsWith("%")) {
            var ratio = Number(maxWidth.replace("%", "")) / 100;
            maxWidth = parentSize.width * ratio;
          } else if (maxWidth.endsWith("px")) {
            maxWidth = Number(maxWidth.replace("px", ""));
          }
        }
        if (maxHeight && typeof maxHeight === "string") {
          if (maxHeight.endsWith("%")) {
            var ratio = Number(maxHeight.replace("%", "")) / 100;
            maxHeight = parentSize.width * ratio;
          } else if (maxHeight.endsWith("px")) {
            maxHeight = Number(maxHeight.replace("px", ""));
          }
        }
        var selfRect = self_1.getBoundingClientRect();
        var selfLeft = selfRect.left;
        var selfTop = selfRect.top;
        var boundaryRect = this.props.bounds === "window" ? { left: 0, top: 0 } : boundary.getBoundingClientRect();
        var boundaryLeft = boundaryRect.left;
        var boundaryTop = boundaryRect.top;
        var offsetWidth = this.getOffsetWidth(boundary);
        var offsetHeight = this.getOffsetHeight(boundary);
        var hasLeft = dir.toLowerCase().endsWith("left");
        var hasRight = dir.toLowerCase().endsWith("right");
        var hasTop = dir.startsWith("top");
        var hasBottom = dir.startsWith("bottom");
        if ((hasLeft || hasTop) && this.resizable) {
          var max = (selfLeft - boundaryLeft) / scale + this.resizable.size.width;
          this.setState({ maxWidth: max > Number(maxWidth) ? maxWidth : max });
        }
        if (hasRight || this.props.lockAspectRatio && !hasLeft && !hasTop) {
          var max = offsetWidth + (boundaryLeft - selfLeft) / scale;
          this.setState({ maxWidth: max > Number(maxWidth) ? maxWidth : max });
        }
        if ((hasTop || hasLeft) && this.resizable) {
          var max = (selfTop - boundaryTop) / scale + this.resizable.size.height;
          this.setState({
            maxHeight: max > Number(maxHeight) ? maxHeight : max
          });
        }
        if (hasBottom || this.props.lockAspectRatio && !hasTop && !hasLeft) {
          var max = offsetHeight + (boundaryTop - selfTop) / scale;
          this.setState({
            maxHeight: max > Number(maxHeight) ? maxHeight : max
          });
        }
      }
    } else {
      this.setState({
        maxWidth: this.props.maxWidth,
        maxHeight: this.props.maxHeight
      });
    }
    if (this.props.onResizeStart) {
      this.props.onResizeStart(e2, dir, elementRef);
    }
  };
  Rnd2.prototype.onResize = function(e2, direction, elementRef, delta) {
    var newPos = { x: this.originalPosition.x, y: this.originalPosition.y };
    var left = -delta.width;
    var top = -delta.height;
    var directions = ["top", "left", "topLeft", "bottomLeft", "topRight"];
    if (directions.indexOf(direction) !== -1) {
      if (direction === "bottomLeft") {
        newPos.x += left;
      } else if (direction === "topRight") {
        newPos.y += top;
      } else {
        newPos.x += left;
        newPos.y += top;
      }
    }
    if (newPos.x !== this.draggable.state.x || newPos.y !== this.draggable.state.y) {
      this.draggable.setState(newPos);
    }
    this.updateOffsetFromParent();
    var offset = this.offsetFromParent;
    var x2 = this.getDraggablePosition().x + offset.left;
    var y2 = this.getDraggablePosition().y + offset.top;
    this.resizingPosition = { x: x2, y: y2 };
    if (!this.props.onResize)
      return;
    this.props.onResize(e2, direction, elementRef, delta, {
      x: x2,
      y: y2
    });
  };
  Rnd2.prototype.onResizeStop = function(e2, direction, elementRef, delta) {
    this.setState({
      resizing: false
    });
    var _a = this.getMaxSizesFromProps(), maxWidth = _a.maxWidth, maxHeight = _a.maxHeight;
    this.setState({ maxWidth, maxHeight });
    if (this.props.onResizeStop) {
      this.props.onResizeStop(e2, direction, elementRef, delta, this.resizingPosition);
    }
  };
  Rnd2.prototype.updateSize = function(size) {
    if (!this.resizable)
      return;
    this.resizable.updateSize({ width: size.width, height: size.height });
  };
  Rnd2.prototype.updatePosition = function(position) {
    this.draggable.setState(position);
  };
  Rnd2.prototype.updateOffsetFromParent = function() {
    var scale = this.props.scale;
    var parent = this.getParent();
    var self2 = this.getSelfElement();
    if (!parent || self2 === null) {
      return {
        top: 0,
        left: 0
      };
    }
    var parentRect = parent.getBoundingClientRect();
    var parentLeft = parentRect.left;
    var parentTop = parentRect.top;
    var selfRect = self2.getBoundingClientRect();
    var position = this.getDraggablePosition();
    var scrollLeft = parent.scrollLeft;
    var scrollTop = parent.scrollTop;
    this.offsetFromParent = {
      left: selfRect.left - parentLeft + scrollLeft - position.x * scale,
      top: selfRect.top - parentTop + scrollTop - position.y * scale
    };
  };
  Rnd2.prototype.render = function() {
    var _a = this.props, disableDragging = _a.disableDragging, style = _a.style, dragHandleClassName = _a.dragHandleClassName, position = _a.position, onMouseDown = _a.onMouseDown, onMouseUp = _a.onMouseUp, dragAxis = _a.dragAxis, dragGrid = _a.dragGrid, bounds = _a.bounds, enableUserSelectHack = _a.enableUserSelectHack, cancel = _a.cancel, children = _a.children, onResizeStart = _a.onResizeStart, onResize = _a.onResize, onResizeStop = _a.onResizeStop, onDragStart = _a.onDragStart, onDrag = _a.onDrag, onDragStop = _a.onDragStop, resizeHandleStyles = _a.resizeHandleStyles, resizeHandleClasses = _a.resizeHandleClasses, resizeHandleComponent = _a.resizeHandleComponent, enableResizing = _a.enableResizing, resizeGrid = _a.resizeGrid, resizeHandleWrapperClass = _a.resizeHandleWrapperClass, resizeHandleWrapperStyle = _a.resizeHandleWrapperStyle, scale = _a.scale, allowAnyClick = _a.allowAnyClick, resizableProps = __rest(_a, ["disableDragging", "style", "dragHandleClassName", "position", "onMouseDown", "onMouseUp", "dragAxis", "dragGrid", "bounds", "enableUserSelectHack", "cancel", "children", "onResizeStart", "onResize", "onResizeStop", "onDragStart", "onDrag", "onDragStop", "resizeHandleStyles", "resizeHandleClasses", "resizeHandleComponent", "enableResizing", "resizeGrid", "resizeHandleWrapperClass", "resizeHandleWrapperStyle", "scale", "allowAnyClick"]);
    var defaultValue = this.props.default ? __assign3({}, this.props.default) : void 0;
    delete resizableProps.default;
    var cursorStyle = disableDragging || dragHandleClassName ? { cursor: "auto" } : { cursor: "move" };
    var innerStyle = __assign3(__assign3(__assign3({}, resizableStyle), cursorStyle), style);
    var _b = this.offsetFromParent, left = _b.left, top = _b.top;
    var draggablePosition;
    if (position) {
      draggablePosition = {
        x: position.x - left,
        y: position.y - top
      };
    }
    var pos = this.state.resizing ? void 0 : draggablePosition;
    var dragAxisOrUndefined = this.state.resizing ? "both" : dragAxis;
    return (0, import_react4.createElement)(
      Draggable,
      { ref: this.refDraggable, handle: dragHandleClassName ? ".".concat(dragHandleClassName) : void 0, defaultPosition: defaultValue, onMouseDown, onMouseUp, onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop, axis: dragAxisOrUndefined, disabled: disableDragging, grid: dragGrid, bounds: bounds ? this.state.bounds : void 0, position: pos, enableUserSelectHack, cancel, scale, allowAnyClick, nodeRef: this.resizableElement },
      (0, import_react4.createElement)(Resizable, __assign3({}, resizableProps, { ref: this.refResizable, defaultSize: defaultValue, size: this.props.size, enable: typeof enableResizing === "boolean" ? getEnableResizingByFlag(enableResizing) : enableResizing, onResizeStart: this.onResizeStart, onResize: this.onResize, onResizeStop: this.onResizeStop, style: innerStyle, minWidth: this.props.minWidth, minHeight: this.props.minHeight, maxWidth: this.state.resizing ? this.state.maxWidth : this.props.maxWidth, maxHeight: this.state.resizing ? this.state.maxHeight : this.props.maxHeight, grid: resizeGrid, handleWrapperClass: resizeHandleWrapperClass, handleWrapperStyle: resizeHandleWrapperStyle, lockAspectRatio: this.props.lockAspectRatio, lockAspectRatioExtraWidth: this.props.lockAspectRatioExtraWidth, lockAspectRatioExtraHeight: this.props.lockAspectRatioExtraHeight, handleStyles: resizeHandleStyles, handleClasses: resizeHandleClasses, handleComponent: resizeHandleComponent, scale: this.props.scale }), children)
    );
  };
  Rnd2.defaultProps = {
    maxWidth: Number.MAX_SAFE_INTEGER,
    maxHeight: Number.MAX_SAFE_INTEGER,
    scale: 1,
    onResizeStart: function() {
    },
    onResize: function() {
    },
    onResizeStop: function() {
    },
    onDragStart: function() {
    },
    onDrag: function() {
    },
    onDragStop: function() {
    }
  };
  return Rnd2;
}(import_react4.PureComponent);

// js/isMobile.mjs
init_define_process();
function isMobile() {
  const isIOS = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.userAgent.indexOf("SAMSUNG") === -1;
  let check = false;
  (function(a2) {
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a2) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[23]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(a2.slice(0, 4))) {
      check = true;
    }
  })(navigator.userAgent || navigator.vendor || window.opera);
  return check && !isIOS;
}
__name(isMobile, "isMobile");

// js/prettierEsm.ts
init_define_process();
var import_parser_babel = __toESM(require_parser_babel(), 1);
var import_standalone = __toESM(require_standalone(), 1);
var prettierJs = /* @__PURE__ */ __name((code) => {
  try {
    return (0, import_standalone.format)(code, {
      arrowParens: "always",
      bracketSpacing: true,
      embeddedLanguageFormatting: "auto",
      insertPragma: false,
      bracketSameLine: true,
      jsxSingleQuote: false,
      htmlWhitespaceSensitivity: "strict",
      printWidth: 90,
      proseWrap: "preserve",
      quoteProps: "as-needed",
      requirePragma: false,
      semi: true,
      singleQuote: true,
      tabWidth: 2,
      trailingComma: "all",
      useTabs: false,
      parser: "babel-ts",
      plugins: [
        import_parser_babel.default
      ]
    });
  } catch (error) {
    console.error("prettier error"), console.error({ err: error });
    return null;
  }
}, "prettierJs");

// js/Editor.tsx
var import_jsx_runtime3 = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var mod4 = {
  getValue: async () => "",
  setValue: async (code) => {
    if (code.length < 10)
      console.log(code);
  },
  getErrors: async () => [],
  code: "",
  counter: 0,
  codeToSet: ""
};
var Editor = /* @__PURE__ */ __name(({ codeSpace: codeSpace4 }) => {
  const ref = (0, import_react6.useRef)(null);
  const { i: i2, code } = mST();
  const engine = isMobile() ? "ace" : "monaco";
  const [
    mySession,
    changeContent
  ] = (0, import_react6.useState)({
    myCode: code,
    counter: i2,
    started: false,
    onChange(_cb) {
    }
  });
  mod4.counter = mST().i;
  const {
    myCode,
    started,
    onChange
  } = mySession;
  mod4.code = myCode;
  (0, import_react6.useEffect)(() => {
    if (started)
      return;
    if (!ref?.current || started) {
      return;
    }
    const container = ref?.current;
    if (container === null)
      return;
    (engine === "monaco" ? setMonaco(container, codeSpace4) : setAce(container, codeSpace4)).then((res) => Object.assign(mod4, { setValue: res?.setValue })).then(
      () => changeContent((x2) => ({ ...x2, started: true }))
    );
  }, [started, ref.current]);
  (0, import_react6.useEffect)(
    () => {
      mod4.getErrors().then(console.log);
      onChange(
        () => mod4.getValue().then(
          () => changeContent((x2) => ({
            ...x2,
            counter: mod4.counter,
            myCode: mod4.code
          }))
        )
      );
    },
    [onChange, myCode, changeContent]
  );
  onSessionUpdate(async () => {
    if (mod4.counter >= mST().i) {
      return;
    }
    const { i: i3, code: code2 } = mST();
    if (!code2)
      return;
    mod4.setValue(code2);
    mod4.code = code2;
    mod4.counter = i3;
    changeContent((x2) => ({
      ...x2,
      counter: i3,
      myCode: code2
    }));
  }, "editor");
  const EditorNode = /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    "div",
    {
      "data-test-id": "editor",
      ref,
      css: import_react5.css`
    ${engine === "ace" ? `` : `border-right: 4px dashed gray;
    border-bottom: 4px dashed gray;`}

    width: 100%;
    height: 100%;
    display: block;
    position: absolute;
    top:0;
    bottom:0;
    left:0;
    right:0;
    `
    }
  );
  if (engine === "ace")
    return EditorNode;
  return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
    Rnd,
    {
      enableResizing: true,
      disableDragging: true,
      minWidth: 640,
      minHeight: "100vh",
      bounds: "body",
      allowAnyClick: true,
      lockAspectRatio: false,
      enable: {
        top: false,
        bottom: true,
        right: true,
        left: false
      },
      defaultSize: {
        width: "640px",
        height: "100vh"
      },
      children: EditorNode
    }
  );
}, "Editor");
async function onModChange(_code, codeSpace4) {
  const code = prettierJs(_code);
  if (!code)
    return;
  if (code === prettierJs(mod4.code))
    return;
  const counter = ++mod4.counter;
  mod4.code = code;
  runner({ code, counter, codeSpace: codeSpace4 });
}
__name(onModChange, "onModChange");
var startedM = 0;
async function setMonaco(container, codeSpace4) {
  if (startedM)
    return;
  startedM = 1;
  const link = document.createElement("link");
  link.setAttribute("rel", "stylesheet");
  link.href = location.origin + "/Editor.css";
  document.head.append(link);
  const { startMonaco } = await import("./chunk-startMonaco-POCD6PRP.mjs");
  return await startMonaco({
    container,
    codeSpace: codeSpace4,
    code: mST().code,
    onChange: (code) => onModChange(code, codeSpace4)
  });
}
__name(setMonaco, "setMonaco");
var startedAce = 0;
async function setAce(container, codeSpace4) {
  if (startedAce)
    return;
  startedAce = 1;
  const { startAce } = await import("./chunk-startAce-L4DX4ZHZ.mjs");
  return await startAce(
    mST().code,
    (code) => onModChange(code, codeSpace4),
    container
  );
}
__name(setAce, "setAce");

// js/renderPreviewWindow.tsx
var import_jsx_runtime4 = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var DraggableWindowLazy = (0, import_react7.lazy)(() => import("./chunk-DraggableWindow-RVFKRKFL.mjs"));
var RainbowContainer = /* @__PURE__ */ __name(({ children }) => /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
  "div",
  {
    css: import_react8.css`
height: 100%;
width: 100%;
background-blend-mode: overlay;
background:  repeating-radial-gradient(circle at bottom left, 
              #fedc00 0, #fedc00 5.5555555556%, 
              #fcb712 0, #fcb712 11.1111111111%, 
              #f7921e 0, #f7921e 16.6666666667%, 
            #e87f24 0, #e87f24 22.2222222222%, 
            #dd6227 0, #dd6227 27.7777777778%,
             #dc4c27 0, #dc4c27 33.3333333333%, 
            #ca3435 0, #ca3435 38.8888888889%, 
            #b82841 0, #b82841 44.4444444444%, 
            #953751 0, #953751 50%, #364c88 0, 
            #364c88 55.5555555556%, #16599d 0, 
            #16599d 61.1111111111%, #02609e 0, 
            #02609e 66.6666666667%, #0073a9 0, 
            #0073a9 72.2222222222%, #008aa4 0, 
            #008aa4 77.7777777778%, #239a87 0, 
            #239a87 83.3333333333%, #7cba6d 0, 
            #7cba6d 88.8888888889%, #becc2f 0, 
            #becc2f 94.4444444444%, #e0d81d 0, 
            #e0d81d 100%), 
            repeating-radial-gradient(circle at bottom right, 
              #fedc00 0, #fedc00 5.5555555556%, 
              #fcb712 0, #fcb712 11.1111111111%, 
              #f7921e 0, #f7921e 16.6666666667%, 
              #e87f24 0, #e87f24 22.2222222222%, 
              #dd6227 0, #dd6227 27.7777777778%, 
              #dc4c27 0, #dc4c27 33.3333333333%, 
              #ca3435 0, #ca3435 38.8888888889%, 
              #b82841 0, #b82841 44.4444444444%, 
              #953751 0, #953751 50%,
               #364c88 0, #364c88 55.5555555556%, 
               #16599d 0, #16599d 61.1111111111%, 
               #02609e 0, #02609e 66.6666666667%, 
               #0073a9 0, #0073a9 72.2222222222%, 
               #008aa4 0, #008aa4 77.7777777778%,
                #239a87 0, #239a87 83.3333333333%, 
                #7cba6d 0, #7cba6d 88.8888888889%, 
                #becc2f 0, #becc2f 94.4444444444%, 
                #e0d81d 0, #e0d81d 100%);
`,
    children
  }
), "RainbowContainer");
var AppToRender = /* @__PURE__ */ __name(({ codeSpace: codeSpace4 }) => {
  const portalNode = (0, import_react7.useMemo)(() => createHtmlPortalNode({
    attributes: {
      style: "height: 100%"
    }
  }), []);
  const onlyApp = location.pathname.endsWith("public") || location.pathname.endsWith("hydrated");
  const devTools = !onlyApp;
  return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(InPortal, { node: portalNode, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(AutoUpdateApp, { codeSpace: codeSpace4 }) }),
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      import_react7.Suspense,
      {
        fallback: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(OutPortal, { node: portalNode }),
        children: devTools ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(RainbowContainer, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_react7.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            Editor,
            {
              codeSpace: codeSpace4
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(DraggableWindowLazy, { room: codeSpace4, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(OutPortal, { node: portalNode }) })
        ] }) }) : /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("div", { style: { height: 100 + "%" }, children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(OutPortal, { node: portalNode }) })
      }
    )
  ] });
}, "AppToRender");
var singleton = { started: false };
var renderPreviewWindow = /* @__PURE__ */ __name(({ codeSpace: codeSpace4, dry }) => {
  if (singleton.started)
    return;
  singleton.started = true;
  const div = document.querySelector(`#root`);
  div.style.height = "100%";
  const root = (0, import_client2.createRoot)(div);
  root.render(
    /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(import_react7.StrictMode, { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(AppToRender, { codeSpace: codeSpace4 }) })
  );
}, "renderPreviewWindow");

// js/uidV4.mjs
init_define_process();

// ../../.yarn/global/cache/uuid-npm-9.0.0-46c41e3e43-9.zip/node_modules/uuid/dist/esm-browser/index.js
init_define_process();

// ../../.yarn/global/cache/uuid-npm-9.0.0-46c41e3e43-9.zip/node_modules/uuid/dist/esm-browser/rng.js
init_define_process();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
__name(rng, "rng");

// ../../.yarn/global/cache/uuid-npm-9.0.0-46c41e3e43-9.zip/node_modules/uuid/dist/esm-browser/stringify.js
init_define_process();
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
__name(unsafeStringify, "unsafeStringify");

// ../../.yarn/global/cache/uuid-npm-9.0.0-46c41e3e43-9.zip/node_modules/uuid/dist/esm-browser/v4.js
init_define_process();

// ../../.yarn/global/cache/uuid-npm-9.0.0-46c41e3e43-9.zip/node_modules/uuid/dist/esm-browser/native.js
init_define_process();
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// ../../.yarn/global/cache/uuid-npm-9.0.0-46c41e3e43-9.zip/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
__name(v4, "v4");
var v4_default = v4;

// js/uidV4.mjs
var uidV4_default = v4_default;

// js/ws.ts
var users = new AVLTree(
  (a2, b2) => a2 === b2 ? 0 : a2 < b2 ? 1 : -1,
  true
);
var webRtcArray = [];
var user = md5((self && self.crypto && self.crypto.randomUUID && self.crypto.randomUUID() || uidV4_default()).slice(
  0,
  8
));
users.insert(user);
var rtcConns = {};
var bc;
var codeSpace3;
var wsLastHashCode = "";
var webRTCLastSeenHashCode = "";
var lastSeenTimestamp = 0;
var lastSeenNow = 0;
var ws = null;
var rejoined = false;
var tracks = {};
var wsConns = {};
var pingHandler;
var sendChannel = {
  localStream: null,
  webRtcArray,
  tracks,
  user,
  i: 0,
  users,
  vidElement: document.createElement("video"),
  stopVideo,
  startVideo,
  rtcConns,
  wsConns,
  send(d2) {
    if (pingHandler)
      clearTimeout(pingHandler);
    pingHandler = setTimeout(() => {
      sendChannel.send({ name: user, hashCode: hashCode(), type: "ping" });
    }, Math.random() * 2e4);
    const me = users.find(user);
    const left = me?.left;
    const right = me?.right;
    const parent = me?.parent;
    if (!d2.i)
      d2.i = ++sendChannel.i;
    if (!d2.name)
      d2.name = user;
    const data = JSON.stringify(d2);
    const sendToUser = /* @__PURE__ */ __name((u2) => {
      webRtcArray.find((t2) => t2.target === u2)?.send(data) || wsConns[u2]?.send(data) || users.remove(u2);
    }, "sendToUser");
    const target = d2.target;
    if (target) {
      if (target === user) {
        return;
      }
      if (target === left?.data)
        return sendToUser(left?.key);
      if (target === right?.data)
        return sendToUser(right?.key);
      if (parent === left?.data)
        return sendToUser(parent?.key);
      if (target < user) {
        sendToUser(left?.key);
        if (parent < user)
          sendToUser(parent?.key);
      }
      if (target > user) {
        sendToUser(right?.key);
        if (parent > user)
          sendToUser(parent?.key);
      }
    }
    [...Object.keys(wsConns), ...webRtcArray.map((x2) => x2.target)].map((u2) => {
      try {
        if (u2 in [left.key, right.key, parent.key]) {
          sendToUser(u2);
        }
      } catch (error) {
      }
    });
  }
};
async function stopVideo() {
  if (!sendChannel.localStream)
    return;
}
__name(stopVideo, "stopVideo");
async function startVideo() {
  console.log({ adapter: adapter_core_default });
  const supported = await navigator.mediaDevices.getSupportedConstraints();
  console.log({ supported });
  const mediaConstraints = {
    audio: false,
    video: true
  };
  const localStream = await navigator.mediaDevices.getUserMedia(
    mediaConstraints
  );
  handleSuccess(localStream);
  function handleSuccess(localStream2) {
    const video = sendChannel.vidElement;
    const videoTracks = localStream2.getVideoTracks();
    console.log("Got stream with constraints:", mediaConstraints);
    console.log(`Using video device: ${videoTracks[0].label}`);
    sendChannel.localStream = localStream2;
    video.srcObject = localStream2;
  }
  __name(handleSuccess, "handleSuccess");
  localStream.getVideoTracks().forEach(
    (track) => Object.keys(sendChannel.rtcConns).map((k2) => {
      const peerConnection = sendChannel.rtcConns[k2];
      peerConnection.addTrack(track);
    })
  );
}
__name(startVideo, "startVideo");
sendChannel.vidElement.playsInline = true;
sendChannel.vidElement.autoplay = true;
Object.assign(globalThis, { sendChannel, mST, users });
sendChannel.users = users;
var save = /* @__PURE__ */ __name(async (newSess) => {
  const messageData = makePatch(newSess);
  if (messageData) {
    await applyPatch(messageData);
    const msg = { ...messageData, name: user, i: ++sendChannel.i };
    sendChannel.send(msg);
  }
}, "save");
var run = /* @__PURE__ */ __name(async (startState) => {
  const { mST: mst, dry, address } = startState;
  codeSpace3 = startState.codeSpace;
  startSession(codeSpace3, {
    name: user,
    state: mst
  }, location.origin);
  if (location.pathname === `/live/${codeSpace3}`) {
    renderPreviewWindow({ codeSpace: codeSpace3, dry: !!dry });
  }
  await join();
  console.log("broadcastChannel");
  bc = new BroadcastChannel(location.origin);
  bc.postMessage({ user, type: "suggestNeighborsRequest" });
  bc.onmessage = async (event) => {
    if (event.data.ignoreUser && event.data.ignoreUser === user) {
      return;
    }
    if (event.data.codeSpace === codeSpace3 && event.data.i > sendChannel.i) {
      sendChannel.i = event.data.i;
    }
    if (event.data.ignoreUser) {
      !ignoreUsers.includes(event.data.ignoreUser) && ignoreUsers.push(event.data.ignoreUser);
    }
    if (event.data.codeSpace === codeSpace3 && event.data.sess.code !== mST().code) {
    }
  };
  onSessionUpdate(
    async () => {
      const sess = mST();
      bc.postMessage({
        ignoreUser: user,
        sess,
        hashCode: md5(sess.transpiled),
        html: sess.html,
        css: sess.css,
        codeSpace: codeSpace3,
        address
      });
    },
    "broadcast"
  );
}, "run");
async function rejoin(wsName) {
  if (!rejoined || ws === null) {
    ws = null;
    const newWs = await join();
    users.insert(wsName);
    const t2 = users.find(wsName);
    sendChannel.wsConns[wsName] = {
      send: (str) => {
        if (ws && ws.readyState == ws.OPEN) {
          ws.send(str);
          return true;
        }
        return false;
      },
      target: wsName,
      lastSeen: Date.now()
    };
    Object.assign(t2, sendChannel.wsConns[wsName]);
    return newWs;
  }
  return ws;
}
__name(rejoin, "rejoin");
var ignoreUsers = [];
async function join() {
  if (ws !== null) {
    return ws;
  }
  rejoined = true;
  if (location.origin.includes("localhost")) {
    return;
  }
  const wsConnection = new WebSocket(
    `wss://${location.host}/live/` + codeSpace3 + "/websocket"
  );
  rejoined = false;
  wsConnection.addEventListener("open", () => {
    ws = wsConnection;
    const send = /* @__PURE__ */ __name((data) => {
      if (ws?.readyState === ws?.OPEN) {
        ws && ws?.send && ws?.send(data);
        return true;
      }
      return true;
    }, "send");
    const extendedWS = {
      send,
      hashCode,
      lastSeen: Date.now(),
      target: void 0
    };
    send(JSON.stringify({ name: user, hashCode: hashCode(), i: ++sendChannel.i }));
    ws.addEventListener(
      "message",
      (event) => {
        processWsMessage(event, "ws", extendedWS);
      }
    );
    return wsConnection;
  });
  return wsConnection;
}
__name(join, "join");
var h2 = {};
async function processWsMessage(event, source, conn) {
  conn.lastSeen = Date.now();
  console.log({ event });
  lastSeenNow = Date.now();
  console.log(typeof event.data);
  const data = JSON.parse(event.data);
  console.log("WSWSWS", { data });
  if (!data.i)
    return;
  if (sendChannel.i >= data.i)
    return;
  sendChannel.i = data.i;
  sendChannel.send(data);
  if (!conn.target && data.name && data.hashCode) {
    conn.target = data.name;
    sendChannel.wsConns[data.name] = conn;
    conn.hashCode = data.hashCode;
    users.insert(conn.target);
  }
  if (data.name)
    users.insert(data.name);
  processData(data, source, conn);
}
__name(processWsMessage, "processWsMessage");
async function processData(data, source, conn) {
  if (data.type === "ws-reconnect" && data.target == user) {
    rejoin(data.name);
  }
  if (source === "ws" && data.timestamp) {
    lastSeenNow = Date.now();
    lastSeenTimestamp = data.timestamp;
  }
  if (data.hashCode || data.newHash && conn) {
    conn.hashCode = data.hashCode || data.newHash;
  }
  if (source === "ws" && data.hashCode) {
    wsLastHashCode = data.hashCode;
  }
  if (source === "ws" && data.hashCode) {
    wsLastHashCode = data.hashCode;
  }
  if (source === "rtc" && data.hashCode || data.newHash) {
    webRTCLastSeenHashCode = data.hashCode || data.newHash;
  }
  if (ignoreUsers.includes(data.name)) {
    return;
  }
  if (data.newHash === hashCode()) {
    return;
  }
  if (data.oldHash && data.newHash) {
    if (h2[data.oldHash] && h2[data.oldHash] === data.newHash) {
      return;
    }
    h2[data.oldHash] = data.newHash;
  }
  if (data.newHash === hashCode()) {
    return;
  }
  (async () => {
    try {
      if (data.type === "new-ice-candidate" && data.target === user) {
        await handleNewICECandidateMessage(data.candidate, data.name);
        return;
      }
      if (data.type === "video-offer" && data.target === user) {
        await handleChatOffer(data.offer, data.name);
        return;
      }
      if (data.type === "video-answer" && data.target === user) {
        await handleChatAnswerMessage(data.answer, data.name);
        return;
      }
      if (data.name && data.name !== user && !rtcConns[data.name] && !ignoreUsers.includes(data.name)) {
        await createPeerConnection(data.name);
        const users2 = data.users;
        const p2pUsers = users2.filter((u2) => u2 !== user && !ignoreUsers.includes(u2));
        while (p2pUsers.length) {
          const nextToConnect = p2pUsers.pop();
          if (nextToConnect && !sendChannel.rtcConns[nextToConnect]) {
            createPeerConnection(nextToConnect);
          }
          await wait(500);
        }
        return;
      }
    } catch (error) {
    }
  })();
  if (data.patch && data.name !== user) {
    if (data.newHash === hashCode()) {
      return;
    }
    await applyPatch(data);
    if (data.newHash === hashCode()) {
      if (sendChannel) {
        sendChannel.send({ hashCode: data.newHash });
      }
      return;
    }
    return;
  }
  if (data.patch && data.name === user) {
    wsLastHashCode = data.newHash;
    return;
  }
  if (data.name === user) {
    return;
  }
  if (wsLastHashCode !== hashCode()) {
  }
  function createPeerConnection(target) {
    if (rtcConns[target]) {
      return;
    }
    rtcConns[target] = new RTCPeerConnection(
      rcpOptions
    );
    rtcConns[target].onicecandidate = (event) => {
      if (event.candidate) {
        sendChannel.send({
          type: "new-ice-candidate",
          target,
          name: user,
          candidate: event.candidate.toJSON()
        });
      }
    };
    rtcConns[target].oniceconnectionstatechange = handleICEConnectionStateChangeEvent;
    rtcConns[target].onicegatheringstatechange = handleICEGatheringStateChangeEvent;
    rtcConns[target].onsignalingstatechange = () => {
      switch (rtcConns[target].signalingState) {
        case "closed":
          break;
      }
    };
    rtcConns[target].onnegotiationneeded = handleNegotiationNeededEvent;
    rtcConns[target].ontrack = function(ev) {
      console.log("OnTack event ", ev);
      const vidElement = document.createElement("video");
      vidElement.autoplay = true;
      vidElement.playsInline = true;
      let stream;
      if (ev.streams && ev.streams[0]) {
        vidElement.srcObject = ev.streams[0];
        stream = ev.streams[0];
      } else {
        let inboundStream = new MediaStream();
        inboundStream.addTrack(ev.track);
        vidElement.srcObject = inboundStream;
        stream = inboundStream;
      }
      ev.track.onended = () => vidElement.srcObject = null;
      sendChannel.tracks[target] = {
        track: ev.track,
        streams: [stream],
        vidElement
      };
    };
    rtcConns[target].ondatachannel = async (event) => {
      rtcConns[target];
      const rtcChannel = event.channel;
      rtcChannel.binaryType = "arraybuffer";
      rtcChannel.addEventListener("close", onReceiveChannelClosed);
      if (sendChannel && sendChannel.localStream && sendChannel.localStream.active) {
        sendChannel.localStream.getTracks().forEach((track) => {
          const datachannel = rtcConns[target];
          datachannel.addTrack(track);
        });
      }
      const conn2 = {
        send: (data2) => {
          rtcChannel.readyState == "open";
          rtcChannel.send(data2);
          return true;
        },
        hashCode: void 0,
        lastSeen: Date.now(),
        target
      };
      rtcChannel.addEventListener(
        "message",
        async (message) => processWsMessage(
          message,
          "rtc",
          conn2
        )
      );
      users.insert(target);
      const t2 = users.find(target);
      Object.assign(t2, conn2);
      const rtcWithTarget = Object.assign(rtc, { target });
      webRtcArray.push(rtcWithTarget);
    };
    const dataChannelOptions = {
      ordered: true,
      reliable: true,
      maxPacketLifeTime: 3e3
    };
    const rtc = Object.assign(
      rtcConns[target].createDataChannel(
        target,
        dataChannelOptions
      ),
      { target }
    );
    rtc.binaryType = "arraybuffer";
    rtc.addEventListener("error", (error) => {
      console.log("xxxxxx-  Data Channel Error:", error);
    });
    rtc.addEventListener("open", () => {
      webRtcArray.push(rtc);
    });
    rtc.addEventListener("close", () => {
    });
    return rtcConns[target];
    function onReceiveChannelClosed() {
      rtcConns[target].close();
      delete rtcConns[target];
      users.remove(target);
    }
    __name(onReceiveChannelClosed, "onReceiveChannelClosed");
    async function handleNegotiationNeededEvent() {
      try {
        const offer = await rtcConns[target].createOffer();
        if (rtcConns[target].signalingState != "stable") {
          return;
        }
        await rtcConns[target].setLocalDescription(offer);
        sendChannel.send({
          target,
          name: user,
          type: "video-offer",
          offer: rtcConns[target].localDescription
        });
      } catch {
      }
    }
    __name(handleNegotiationNeededEvent, "handleNegotiationNeededEvent");
    function handleICEConnectionStateChangeEvent() {
      switch (rtcConns[target].iceConnectionState) {
        case "closed":
        case "failed":
        case "disconnected":
          break;
      }
    }
    __name(handleICEConnectionStateChangeEvent, "handleICEConnectionStateChangeEvent");
    function handleICEGatheringStateChangeEvent() {
    }
    __name(handleICEGatheringStateChangeEvent, "handleICEGatheringStateChangeEvent");
  }
  __name(createPeerConnection, "createPeerConnection");
  async function handleChatAnswerMessage(answer, target) {
    if (rtcConns[target].signalingState === "stable")
      return;
    await rtcConns[target].setRemoteDescription(
      new RTCSessionDescription(
        answer
      )
    ).catch(console.error);
  }
  __name(handleChatAnswerMessage, "handleChatAnswerMessage");
  async function handleChatOffer(offer, target) {
    if (!rtcConns[target]) {
      createPeerConnection(target);
    }
    await rtcConns[target].setRemoteDescription(
      new RTCSessionDescription(offer)
    );
    const answer = await rtcConns[target].createAnswer();
    await rtcConns[target].setLocalDescription(
      answer
    );
    sendChannel.send({
      target,
      name: user,
      type: "video-answer",
      answer
    });
  }
  __name(handleChatOffer, "handleChatOffer");
}
__name(processData, "processData");
var rcpOptions = {
  iceServers: ["stun3.l.google.com:19302"].map((url) => ({
    urls: `stun:${url}`
  }))
};
rcpOptions.iceServers = [{ urls: "stun:stun.stunprotocol.org:3478" }, {
  urls: "stun:stun.l.google.com:19302"
}];
async function handleNewICECandidateMessage(init, target) {
  const candidate = new RTCIceCandidate(init);
  await rtcConns[target].addIceCandidate(candidate);
}
__name(handleNewICECandidateMessage, "handleNewICECandidateMessage");

export {
  sendChannel,
  save,
  run,
  join,
  Editor
};

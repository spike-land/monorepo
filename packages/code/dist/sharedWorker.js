var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));

// <define:process>
var init_define_process = __esm({
  "<define:process>"() {
  }
});

// node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module) {
    init_define_process();
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = /* @__PURE__ */ __name(function() {
      return root.Date.now();
    }, "now");
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      __name(invokeFunc, "invokeFunc");
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      __name(leadingEdge, "leadingEdge");
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      __name(remainingWait, "remainingWait");
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      __name(shouldInvoke, "shouldInvoke");
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      __name(timerExpired, "timerExpired");
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      __name(trailingEdge, "trailingEdge");
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      __name(cancel, "cancel");
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      __name(flush, "flush");
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      __name(debounced, "debounced");
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    __name(debounce2, "debounce");
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    __name(isObject, "isObject");
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol, "isSymbol");
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    __name(toNumber, "toNumber");
    module.exports = debounce2;
  }
});

// node_modules/prettier/parser-typescript.js
var require_parser_typescript = __commonJS({
  "node_modules/prettier/parser-typescript.js"(exports, module) {
    init_define_process();
    (function(e) {
      if (typeof exports == "object" && typeof module == "object")
        module.exports = e();
      else if (typeof define == "function" && define.amd)
        define(e);
      else {
        var i = typeof globalThis < "u" ? globalThis : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : this || {};
        i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.typescript = e();
      }
    })(function() {
      "use strict";
      var wt = /* @__PURE__ */ __name((a, c) => () => (c || a((c = { exports: {} }).exports, c), c.exports), "wt");
      var di = wt((dT, Lf) => {
        var Zu = /* @__PURE__ */ __name(function(a) {
          return a && a.Math == Math && a;
        }, "Zu");
        Lf.exports = Zu(typeof globalThis == "object" && globalThis) || Zu(typeof window == "object" && window) || Zu(typeof self == "object" && self) || Zu(typeof globalThis == "object" && globalThis) || function() {
          return this;
        }() || Function("return this")();
      });
      var zo = wt((mT, Rf) => {
        Rf.exports = function(a) {
          try {
            return !!a();
          } catch {
            return true;
          }
        };
      });
      var S_ = wt((gT, jf) => {
        var Dh = zo();
        jf.exports = !Dh(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var el = wt((yT, Jf) => {
        var xh = zo();
        Jf.exports = !xh(function() {
          var a = function() {
          }.bind();
          return typeof a != "function" || a.hasOwnProperty("prototype");
        });
      });
      var tl = wt((hT, Ff) => {
        var wh = el(), rl = Function.prototype.call;
        Ff.exports = wh ? rl.bind(rl) : function() {
          return rl.apply(rl, arguments);
        };
      });
      var zf = wt((Uf) => {
        "use strict";
        var Bf = {}.propertyIsEnumerable, qf = Object.getOwnPropertyDescriptor, Ah = qf && !Bf.call({ 1: 2 }, 1);
        Uf.f = Ah ? function(c) {
          var A = qf(this, c);
          return !!A && A.enumerable;
        } : Bf;
      });
      var Yl = wt((bT, Vf) => {
        Vf.exports = function(a, c) {
          return { enumerable: !(a & 1), configurable: !(a & 2), writable: !(a & 4), value: c };
        };
      });
      var Ra = wt((ET, Hf) => {
        var Wf = el(), Kf = Function.prototype, kh = Kf.bind, Zl = Kf.call, Ph = Wf && kh.bind(Zl, Zl);
        Hf.exports = Wf ? function(a) {
          return a && Ph(a);
        } : function(a) {
          return a && function() {
            return Zl.apply(a, arguments);
          };
        };
      });
      var nl = wt((TT, Xf) => {
        var Gf = Ra(), Nh = Gf({}.toString), Ih = Gf("".slice);
        Xf.exports = function(a) {
          return Ih(Nh(a), 8, -1);
        };
      });
      var Qf = wt((ST, $f) => {
        var Oh = di(), Mh = Ra(), Lh = zo(), Rh = nl(), ep = Oh.Object, jh = Mh("".split);
        $f.exports = Lh(function() {
          return !ep("z").propertyIsEnumerable(0);
        }) ? function(a) {
          return Rh(a) == "String" ? jh(a, "") : ep(a);
        } : ep;
      });
      var rp = wt((CT, Yf) => {
        var Jh = di(), Fh = Jh.TypeError;
        Yf.exports = function(a) {
          if (a == null)
            throw Fh("Can't call method on " + a);
          return a;
        };
      });
      var il = wt((DT, Zf) => {
        var Bh = Qf(), qh = rp();
        Zf.exports = function(a) {
          return Bh(qh(a));
        };
      });
      var ja = wt((xT, ed) => {
        ed.exports = function(a) {
          return typeof a == "function";
        };
      });
      var C_ = wt((wT, rd) => {
        var Uh = ja();
        rd.exports = function(a) {
          return typeof a == "object" ? a !== null : Uh(a);
        };
      });
      var Iu = wt((AT, td) => {
        var tp = di(), zh = ja(), Vh = /* @__PURE__ */ __name(function(a) {
          return zh(a) ? a : void 0;
        }, "Vh");
        td.exports = function(a, c) {
          return arguments.length < 2 ? Vh(tp[a]) : tp[a] && tp[a][c];
        };
      });
      var id = wt((kT, nd) => {
        var Wh = Ra();
        nd.exports = Wh({}.isPrototypeOf);
      });
      var od = wt((PT, ad) => {
        var Kh = Iu();
        ad.exports = Kh("navigator", "userAgent") || "";
      });
      var fd = wt((NT, pd) => {
        var ld = di(), np = od(), sd = ld.process, _d = ld.Deno, cd = sd && sd.versions || _d && _d.version, ud = cd && cd.v8, Qa, al;
        ud && (Qa = ud.split("."), al = Qa[0] > 0 && Qa[0] < 4 ? 1 : +(Qa[0] + Qa[1]));
        !al && np && (Qa = np.match(/Edge\/(\d+)/), (!Qa || Qa[1] >= 74) && (Qa = np.match(/Chrome\/(\d+)/), Qa && (al = +Qa[1])));
        pd.exports = al;
      });
      var ip = wt((IT, md) => {
        var dd = fd(), Hh = zo();
        md.exports = !!Object.getOwnPropertySymbols && !Hh(function() {
          var a = Symbol();
          return !String(a) || !(Object(a) instanceof Symbol) || !Symbol.sham && dd && dd < 41;
        });
      });
      var ap = wt((OT, gd) => {
        var Gh = ip();
        gd.exports = Gh && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var op = wt((MT, yd) => {
        var Xh = di(), $h = Iu(), Qh = ja(), Yh = id(), Zh = ap(), e0 = Xh.Object;
        yd.exports = Zh ? function(a) {
          return typeof a == "symbol";
        } : function(a) {
          var c = $h("Symbol");
          return Qh(c) && Yh(c.prototype, e0(a));
        };
      });
      var vd = wt((LT, hd) => {
        var r0 = di(), t0 = r0.String;
        hd.exports = function(a) {
          try {
            return t0(a);
          } catch {
            return "Object";
          }
        };
      });
      var ol = wt((RT, bd) => {
        var n0 = di(), i0 = ja(), a0 = vd(), o0 = n0.TypeError;
        bd.exports = function(a) {
          if (i0(a))
            return a;
          throw o0(a0(a) + " is not a function");
        };
      });
      var Td = wt((jT, Ed) => {
        var s0 = ol();
        Ed.exports = function(a, c) {
          var A = a[c];
          return A == null ? void 0 : s0(A);
        };
      });
      var Cd = wt((JT, Sd) => {
        var _0 = di(), sp = tl(), _p = ja(), cp = C_(), c0 = _0.TypeError;
        Sd.exports = function(a, c) {
          var A, T;
          if (c === "string" && _p(A = a.toString) && !cp(T = sp(A, a)) || _p(A = a.valueOf) && !cp(T = sp(A, a)) || c !== "string" && _p(A = a.toString) && !cp(T = sp(A, a)))
            return T;
          throw c0("Can't convert object to primitive value");
        };
      });
      var xd = wt((FT, Dd) => {
        Dd.exports = false;
      });
      var sl = wt((BT, Ad) => {
        var wd = di(), u0 = Object.defineProperty;
        Ad.exports = function(a, c) {
          try {
            u0(wd, a, { value: c, configurable: true, writable: true });
          } catch {
            wd[a] = c;
          }
          return c;
        };
      });
      var _l = wt((qT, Pd) => {
        var l0 = di(), p0 = sl(), kd = "__core-js_shared__", f0 = l0[kd] || p0(kd, {});
        Pd.exports = f0;
      });
      var up = wt((UT, Id) => {
        var d0 = xd(), Nd = _l();
        (Id.exports = function(a, c) {
          return Nd[a] || (Nd[a] = c !== void 0 ? c : {});
        })("versions", []).push({ version: "3.22.2", mode: d0 ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var lp = wt((zT, Od) => {
        var m0 = di(), g0 = rp(), y0 = m0.Object;
        Od.exports = function(a) {
          return y0(g0(a));
        };
      });
      var As = wt((VT, Md) => {
        var h0 = Ra(), v0 = lp(), b0 = h0({}.hasOwnProperty);
        Md.exports = Object.hasOwn || function(c, A) {
          return b0(v0(c), A);
        };
      });
      var pp = wt((WT, Ld) => {
        var E0 = Ra(), T0 = 0, S0 = Math.random(), C0 = E0(1 .toString);
        Ld.exports = function(a) {
          return "Symbol(" + (a === void 0 ? "" : a) + ")_" + C0(++T0 + S0, 36);
        };
      });
      var Ou = wt((KT, Bd) => {
        var D0 = di(), x0 = up(), Rd = As(), w0 = pp(), jd = ip(), Fd = ap(), Fc = x0("wks"), D_ = D0.Symbol, Jd = D_ && D_.for, A0 = Fd ? D_ : D_ && D_.withoutSetter || w0;
        Bd.exports = function(a) {
          if (!Rd(Fc, a) || !(jd || typeof Fc[a] == "string")) {
            var c = "Symbol." + a;
            jd && Rd(D_, a) ? Fc[a] = D_[a] : Fd && Jd ? Fc[a] = Jd(c) : Fc[a] = A0(c);
          }
          return Fc[a];
        };
      });
      var Vd = wt((HT, zd) => {
        var k0 = di(), P0 = tl(), qd = C_(), Ud = op(), N0 = Td(), I0 = Cd(), O0 = Ou(), M0 = k0.TypeError, L0 = O0("toPrimitive");
        zd.exports = function(a, c) {
          if (!qd(a) || Ud(a))
            return a;
          var A = N0(a, L0), T;
          if (A) {
            if (c === void 0 && (c = "default"), T = P0(A, a, c), !qd(T) || Ud(T))
              return T;
            throw M0("Can't convert object to primitive value");
          }
          return c === void 0 && (c = "number"), I0(a, c);
        };
      });
      var fp = wt((GT, Wd) => {
        var R0 = Vd(), j0 = op();
        Wd.exports = function(a) {
          var c = R0(a, "string");
          return j0(c) ? c : c + "";
        };
      });
      var Gd = wt((XT, Hd) => {
        var J0 = di(), Kd = C_(), dp = J0.document, F0 = Kd(dp) && Kd(dp.createElement);
        Hd.exports = function(a) {
          return F0 ? dp.createElement(a) : {};
        };
      });
      var mp = wt(($T, Xd) => {
        var B0 = S_(), q0 = zo(), U0 = Gd();
        Xd.exports = !B0 && !q0(function() {
          return Object.defineProperty(U0("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var gp = wt((Qd) => {
        var z0 = S_(), V0 = tl(), W0 = zf(), K0 = Yl(), H0 = il(), G0 = fp(), X0 = As(), $0 = mp(), $d = Object.getOwnPropertyDescriptor;
        Qd.f = z0 ? $d : function(c, A) {
          if (c = H0(c), A = G0(A), $0)
            try {
              return $d(c, A);
            } catch {
            }
          if (X0(c, A))
            return K0(!V0(W0.f, c, A), c[A]);
        };
      });
      var Zd = wt((YT, Yd) => {
        var Q0 = S_(), Y0 = zo();
        Yd.exports = Q0 && Y0(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var yp = wt((ZT, rm) => {
        var em = di(), Z0 = C_(), ev = em.String, rv = em.TypeError;
        rm.exports = function(a) {
          if (Z0(a))
            return a;
          throw rv(ev(a) + " is not an object");
        };
      });
      var Tp = wt((nm) => {
        var tv = di(), nv = S_(), iv = mp(), av = Zd(), cl = yp(), tm = fp(), ov = tv.TypeError, hp = Object.defineProperty, sv = Object.getOwnPropertyDescriptor, vp = "enumerable", bp = "configurable", Ep = "writable";
        nm.f = nv ? av ? function(c, A, T) {
          if (cl(c), A = tm(A), cl(T), typeof c == "function" && A === "prototype" && "value" in T && Ep in T && !T[Ep]) {
            var oe = sv(c, A);
            oe && oe[Ep] && (c[A] = T.value, T = { configurable: bp in T ? T[bp] : oe[bp], enumerable: vp in T ? T[vp] : oe[vp], writable: false });
          }
          return hp(c, A, T);
        } : hp : function(c, A, T) {
          if (cl(c), A = tm(A), cl(T), iv)
            try {
              return hp(c, A, T);
            } catch {
            }
          if ("get" in T || "set" in T)
            throw ov("Accessors not supported");
          return "value" in T && (c[A] = T.value), c;
        };
      });
      var ul = wt((r6, im) => {
        var _v = S_(), cv = Tp(), uv = Yl();
        im.exports = _v ? function(a, c, A) {
          return cv.f(a, c, uv(1, A));
        } : function(a, c, A) {
          return a[c] = A, a;
        };
      });
      var ll = wt((t6, am) => {
        var lv = Ra(), pv = ja(), Sp = _l(), fv = lv(Function.toString);
        pv(Sp.inspectSource) || (Sp.inspectSource = function(a) {
          return fv(a);
        });
        am.exports = Sp.inspectSource;
      });
      var _m = wt((n6, sm) => {
        var dv = di(), mv = ja(), gv = ll(), om = dv.WeakMap;
        sm.exports = mv(om) && /native code/.test(gv(om));
      });
      var lm = wt((i6, um) => {
        var yv = up(), hv = pp(), cm = yv("keys");
        um.exports = function(a) {
          return cm[a] || (cm[a] = hv(a));
        };
      });
      var Cp = wt((a6, pm) => {
        pm.exports = {};
      });
      var hm = wt((o6, ym) => {
        var vv = _m(), gm = di(), Dp = Ra(), bv = C_(), Ev = ul(), xp = As(), wp = _l(), Tv = lm(), Sv = Cp(), fm = "Object already initialized", kp = gm.TypeError, Cv = gm.WeakMap, pl, Mu, fl, Dv = /* @__PURE__ */ __name(function(a) {
          return fl(a) ? Mu(a) : pl(a, {});
        }, "Dv"), xv = /* @__PURE__ */ __name(function(a) {
          return function(c) {
            var A;
            if (!bv(c) || (A = Mu(c)).type !== a)
              throw kp("Incompatible receiver, " + a + " required");
            return A;
          };
        }, "xv");
        vv || wp.state ? (ks = wp.state || (wp.state = new Cv()), dm = Dp(ks.get), Ap = Dp(ks.has), mm = Dp(ks.set), pl = /* @__PURE__ */ __name(function(a, c) {
          if (Ap(ks, a))
            throw new kp(fm);
          return c.facade = a, mm(ks, a, c), c;
        }, "pl"), Mu = /* @__PURE__ */ __name(function(a) {
          return dm(ks, a) || {};
        }, "Mu"), fl = /* @__PURE__ */ __name(function(a) {
          return Ap(ks, a);
        }, "fl")) : (x_ = Tv("state"), Sv[x_] = true, pl = /* @__PURE__ */ __name(function(a, c) {
          if (xp(a, x_))
            throw new kp(fm);
          return c.facade = a, Ev(a, x_, c), c;
        }, "pl"), Mu = /* @__PURE__ */ __name(function(a) {
          return xp(a, x_) ? a[x_] : {};
        }, "Mu"), fl = /* @__PURE__ */ __name(function(a) {
          return xp(a, x_);
        }, "fl"));
        var ks, dm, Ap, mm, x_;
        ym.exports = { set: pl, get: Mu, has: fl, enforce: Dv, getterFor: xv };
      });
      var Em = wt((s6, bm) => {
        var Pp = S_(), wv = As(), vm = Function.prototype, Av = Pp && Object.getOwnPropertyDescriptor, Np = wv(vm, "name"), kv = Np && function() {
        }.name === "something", Pv = Np && (!Pp || Pp && Av(vm, "name").configurable);
        bm.exports = { EXISTS: Np, PROPER: kv, CONFIGURABLE: Pv };
      });
      var xm = wt((_6, Dm) => {
        var Nv = di(), Tm = ja(), Iv = As(), Sm = ul(), Ov = sl(), Mv = ll(), Cm = hm(), Lv = Em().CONFIGURABLE, Rv = Cm.get, jv = Cm.enforce, Jv = String(String).split("String");
        (Dm.exports = function(a, c, A, T) {
          var oe = T ? !!T.unsafe : false, z = T ? !!T.enumerable : false, I = T ? !!T.noTargetGet : false, E = T && T.name !== void 0 ? T.name : c, N;
          if (Tm(A) && (String(E).slice(0, 7) === "Symbol(" && (E = "[" + String(E).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Iv(A, "name") || Lv && A.name !== E) && Sm(A, "name", E), N = jv(A), N.source || (N.source = Jv.join(typeof E == "string" ? E : ""))), a === Nv) {
            z ? a[c] = A : Ov(c, A);
            return;
          } else
            oe ? !I && a[c] && (z = true) : delete a[c];
          z ? a[c] = A : Sm(a, c, A);
        })(Function.prototype, "toString", function() {
          return Tm(this) && Rv(this).source || Mv(this);
        });
      });
      var Ip = wt((c6, wm) => {
        var Fv = Math.ceil, Bv = Math.floor;
        wm.exports = function(a) {
          var c = +a;
          return c !== c || c === 0 ? 0 : (c > 0 ? Bv : Fv)(c);
        };
      });
      var km = wt((u6, Am) => {
        var qv = Ip(), Uv = Math.max, zv = Math.min;
        Am.exports = function(a, c) {
          var A = qv(a);
          return A < 0 ? Uv(A + c, 0) : zv(A, c);
        };
      });
      var Nm = wt((l6, Pm) => {
        var Vv = Ip(), Wv = Math.min;
        Pm.exports = function(a) {
          return a > 0 ? Wv(Vv(a), 9007199254740991) : 0;
        };
      });
      var dl = wt((p6, Im) => {
        var Kv = Nm();
        Im.exports = function(a) {
          return Kv(a.length);
        };
      });
      var Lm = wt((f6, Mm) => {
        var Hv = il(), Gv = km(), Xv = dl(), Om = /* @__PURE__ */ __name(function(a) {
          return function(c, A, T) {
            var oe = Hv(c), z = Xv(oe), I = Gv(T, z), E;
            if (a && A != A) {
              for (; z > I; )
                if (E = oe[I++], E != E)
                  return true;
            } else
              for (; z > I; I++)
                if ((a || I in oe) && oe[I] === A)
                  return a || I || 0;
            return !a && -1;
          };
        }, "Om");
        Mm.exports = { includes: Om(true), indexOf: Om(false) };
      });
      var Jm = wt((d6, jm) => {
        var $v = Ra(), Op = As(), Qv = il(), Yv = Lm().indexOf, Zv = Cp(), Rm = $v([].push);
        jm.exports = function(a, c) {
          var A = Qv(a), T = 0, oe = [], z;
          for (z in A)
            !Op(Zv, z) && Op(A, z) && Rm(oe, z);
          for (; c.length > T; )
            Op(A, z = c[T++]) && (~Yv(oe, z) || Rm(oe, z));
          return oe;
        };
      });
      var Bm = wt((m6, Fm) => {
        Fm.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var Um = wt((qm) => {
        var e1 = Jm(), r1 = Bm(), t1 = r1.concat("length", "prototype");
        qm.f = Object.getOwnPropertyNames || function(c) {
          return e1(c, t1);
        };
      });
      var Vm = wt((zm) => {
        zm.f = Object.getOwnPropertySymbols;
      });
      var Km = wt((h6, Wm) => {
        var n1 = Iu(), i1 = Ra(), a1 = Um(), o1 = Vm(), s1 = yp(), _1 = i1([].concat);
        Wm.exports = n1("Reflect", "ownKeys") || function(c) {
          var A = a1.f(s1(c)), T = o1.f;
          return T ? _1(A, T(c)) : A;
        };
      });
      var Xm = wt((v6, Gm) => {
        var Hm = As(), c1 = Km(), u1 = gp(), l1 = Tp();
        Gm.exports = function(a, c, A) {
          for (var T = c1(c), oe = l1.f, z = u1.f, I = 0; I < T.length; I++) {
            var E = T[I];
            !Hm(a, E) && !(A && Hm(A, E)) && oe(a, E, z(c, E));
          }
        };
      });
      var Qm = wt((b6, $m) => {
        var p1 = zo(), f1 = ja(), d1 = /#|\.prototype\./, Lu = /* @__PURE__ */ __name(function(a, c) {
          var A = g1[m1(a)];
          return A == h1 ? true : A == y1 ? false : f1(c) ? p1(c) : !!c;
        }, "Lu"), m1 = Lu.normalize = function(a) {
          return String(a).replace(d1, ".").toLowerCase();
        }, g1 = Lu.data = {}, y1 = Lu.NATIVE = "N", h1 = Lu.POLYFILL = "P";
        $m.exports = Lu;
      });
      var Lp = wt((E6, Ym) => {
        var Mp = di(), v1 = gp().f, b1 = ul(), E1 = xm(), T1 = sl(), S1 = Xm(), C1 = Qm();
        Ym.exports = function(a, c) {
          var A = a.target, T = a.global, oe = a.stat, z, I, E, N, e, t;
          if (T ? I = Mp : oe ? I = Mp[A] || T1(A, {}) : I = (Mp[A] || {}).prototype, I)
            for (E in c) {
              if (e = c[E], a.noTargetGet ? (t = v1(I, E), N = t && t.value) : N = I[E], z = C1(T ? E : A + (oe ? "." : "#") + E, a.forced), !z && N !== void 0) {
                if (typeof e == typeof N)
                  continue;
                S1(e, N);
              }
              (a.sham || N && N.sham) && b1(e, "sham", true), E1(I, E, e, a);
            }
        };
      });
      var Zm = wt(() => {
        var D1 = Lp(), x1 = di();
        D1({ global: true }, { globalThis: x1 });
      });
      var eg = wt(() => {
        Zm();
      });
      var Rp = wt((x6, rg) => {
        var w1 = nl();
        rg.exports = Array.isArray || function(c) {
          return w1(c) == "Array";
        };
      });
      var ig = wt((w6, ng) => {
        var tg = Ra(), A1 = ol(), k1 = el(), P1 = tg(tg.bind);
        ng.exports = function(a, c) {
          return A1(a), c === void 0 ? a : k1 ? P1(a, c) : function() {
            return a.apply(c, arguments);
          };
        };
      });
      var sg = wt((A6, og) => {
        "use strict";
        var N1 = di(), I1 = Rp(), O1 = dl(), M1 = ig(), L1 = N1.TypeError, ag = /* @__PURE__ */ __name(function(a, c, A, T, oe, z, I, E) {
          for (var N = oe, e = 0, t = I ? M1(I, E) : false, x, s; e < T; ) {
            if (e in A) {
              if (x = t ? t(A[e], e, c) : A[e], z > 0 && I1(x))
                s = O1(x), N = ag(a, c, x, s, N, z - 1) - 1;
              else {
                if (N >= 9007199254740991)
                  throw L1("Exceed the acceptable array length");
                a[N] = x;
              }
              N++;
            }
            e++;
          }
          return N;
        }, "ag");
        og.exports = ag;
      });
      var ug = wt((k6, cg) => {
        var R1 = Ou(), j1 = R1("toStringTag"), _g = {};
        _g[j1] = "z";
        cg.exports = String(_g) === "[object z]";
      });
      var pg = wt((P6, lg) => {
        var J1 = di(), F1 = ug(), B1 = ja(), ml = nl(), q1 = Ou(), U1 = q1("toStringTag"), z1 = J1.Object, V1 = ml(function() {
          return arguments;
        }()) == "Arguments", W1 = /* @__PURE__ */ __name(function(a, c) {
          try {
            return a[c];
          } catch {
          }
        }, "W1");
        lg.exports = F1 ? ml : function(a) {
          var c, A, T;
          return a === void 0 ? "Undefined" : a === null ? "Null" : typeof (A = W1(c = z1(a), U1)) == "string" ? A : V1 ? ml(c) : (T = ml(c)) == "Object" && B1(c.callee) ? "Arguments" : T;
        };
      });
      var hg = wt((N6, yg) => {
        var K1 = Ra(), H1 = zo(), fg = ja(), G1 = pg(), X1 = Iu(), $1 = ll(), dg = /* @__PURE__ */ __name(function() {
        }, "dg"), Q1 = [], mg = X1("Reflect", "construct"), jp = /^\s*(?:class|function)\b/, Y1 = K1(jp.exec), Z1 = !jp.exec(dg), Ru = /* @__PURE__ */ __name(function(c) {
          if (!fg(c))
            return false;
          try {
            return mg(dg, Q1, c), true;
          } catch {
            return false;
          }
        }, "Ru"), gg = /* @__PURE__ */ __name(function(c) {
          if (!fg(c))
            return false;
          switch (G1(c)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Z1 || !!Y1(jp, $1(c));
          } catch {
            return true;
          }
        }, "gg");
        gg.sham = true;
        yg.exports = !mg || H1(function() {
          var a;
          return Ru(Ru.call) || !Ru(Object) || !Ru(function() {
            a = true;
          }) || a;
        }) ? gg : Ru;
      });
      var Tg = wt((I6, Eg) => {
        var eb = di(), vg = Rp(), rb = hg(), tb = C_(), nb = Ou(), ib = nb("species"), bg = eb.Array;
        Eg.exports = function(a) {
          var c;
          return vg(a) && (c = a.constructor, rb(c) && (c === bg || vg(c.prototype)) ? c = void 0 : tb(c) && (c = c[ib], c === null && (c = void 0))), c === void 0 ? bg : c;
        };
      });
      var Cg = wt((O6, Sg) => {
        var ab = Tg();
        Sg.exports = function(a, c) {
          return new (ab(a))(c === 0 ? 0 : c);
        };
      });
      var Dg = wt(() => {
        "use strict";
        var ob = Lp(), sb = sg(), _b = ol(), cb = lp(), ub = dl(), lb = Cg();
        ob({ target: "Array", proto: true }, { flatMap: function(c) {
          var A = cb(this), T = ub(A), oe;
          return _b(c), oe = lb(A, 0), oe.length = sb(oe, A, A, T, 0, 1, c, arguments.length > 1 ? arguments[1] : void 0), oe;
        } });
      });
      var pT = wt((R6, Ey) => {
        eg();
        Dg();
        var Wp = Object.defineProperty, pb = Object.getOwnPropertyDescriptor, Kp = Object.getOwnPropertyNames, fb = Object.prototype.hasOwnProperty, Ju = /* @__PURE__ */ __name((a, c) => function() {
          return a && (c = (0, a[Kp(a)[0]])(a = 0)), c;
        }, "Ju"), Ur = /* @__PURE__ */ __name((a, c) => function() {
          return c || (0, a[Kp(a)[0]])((c = { exports: {} }).exports, c), c.exports;
        }, "Ur"), bl = /* @__PURE__ */ __name((a, c) => {
          for (var A in c)
            Wp(a, A, { get: c[A], enumerable: true });
        }, "bl"), db = /* @__PURE__ */ __name((a, c, A, T) => {
          if (c && typeof c == "object" || typeof c == "function")
            for (let oe of Kp(c))
              !fb.call(a, oe) && oe !== A && Wp(a, oe, { get: () => c[oe], enumerable: !(T = pb(c, oe)) || T.enumerable });
          return a;
        }, "db"), Ja = /* @__PURE__ */ __name((a) => db(Wp({}, "__esModule", { value: true }), a), "Ja"), xg, wg, Ea, Jr = Ju({ "<define:process>"() {
          xg = {}, wg = [], Ea = { env: xg, argv: wg };
        } }), Ng = Ur({ "src/common/parser-create-error.js"(a, c) {
          "use strict";
          Jr();
          function A(T, oe) {
            let z = new SyntaxError(T + " (" + oe.start.line + ":" + oe.start.column + ")");
            return z.loc = oe, z;
          }
          __name(A, "A");
          c.exports = A;
        } }), mb = Ur({ "src/utils/try-combinations.js"(a, c) {
          "use strict";
          Jr();
          function A() {
            let T;
            for (var oe = arguments.length, z = new Array(oe), I = 0; I < oe; I++)
              z[I] = arguments[I];
            for (let [E, N] of z.entries())
              try {
                return { result: N() };
              } catch (e) {
                E === 0 && (T = e);
              }
            return { error: T };
          }
          __name(A, "A");
          c.exports = A;
        } }), Ig = {};
        bl(Ig, { EOL: () => Bp, arch: () => gb, cpus: () => Fg, default: () => Vg, endianness: () => Og, freemem: () => jg, getNetworkInterfaces: () => zg, hostname: () => Mg, loadavg: () => Lg, networkInterfaces: () => Ug, platform: () => yb, release: () => qg, tmpDir: () => Jp, tmpdir: () => Fp, totalmem: () => Jg, type: () => Bg, uptime: () => Rg });
        function Og() {
          if (typeof gl > "u") {
            var a = new ArrayBuffer(2), c = new Uint8Array(a), A = new Uint16Array(a);
            if (c[0] = 1, c[1] = 2, A[0] === 258)
              gl = "BE";
            else if (A[0] === 513)
              gl = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return gl;
        }
        __name(Og, "Og");
        function Mg() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        __name(Mg, "Mg");
        function Lg() {
          return [];
        }
        __name(Lg, "Lg");
        function Rg() {
          return 0;
        }
        __name(Rg, "Rg");
        function jg() {
          return Number.MAX_VALUE;
        }
        __name(jg, "jg");
        function Jg() {
          return Number.MAX_VALUE;
        }
        __name(Jg, "Jg");
        function Fg() {
          return [];
        }
        __name(Fg, "Fg");
        function Bg() {
          return "Browser";
        }
        __name(Bg, "Bg");
        function qg() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        __name(qg, "qg");
        function Ug() {
        }
        __name(Ug, "Ug");
        function zg() {
        }
        __name(zg, "zg");
        function gb() {
          return "javascript";
        }
        __name(gb, "gb");
        function yb() {
          return "browser";
        }
        __name(yb, "yb");
        function Jp() {
          return "/tmp";
        }
        __name(Jp, "Jp");
        var gl, Fp, Bp, Vg, hb = Ju({ "node-modules-polyfills:os"() {
          Jr(), Fp = Jp, Bp = `
`, Vg = { EOL: Bp, tmpdir: Fp, tmpDir: Jp, networkInterfaces: Ug, getNetworkInterfaces: zg, release: qg, type: Bg, cpus: Fg, totalmem: Jg, freemem: jg, uptime: Rg, loadavg: Lg, hostname: Mg, endianness: Og };
        } }), vb = Ur({ "node-modules-polyfills-commonjs:os"(a, c) {
          Jr();
          var A = (hb(), Ja(Ig));
          if (A && A.default) {
            c.exports = A.default;
            for (let T in A)
              c.exports[T] = A[T];
          } else
            A && (c.exports = A);
        } }), bb = Ur({ "node_modules/detect-newline/index.js"(a, c) {
          "use strict";
          Jr();
          var A = /* @__PURE__ */ __name((T) => {
            if (typeof T != "string")
              throw new TypeError("Expected a string");
            let oe = T.match(/(?:\r?\n)/g) || [];
            if (oe.length === 0)
              return;
            let z = oe.filter((E) => E === `\r
`).length, I = oe.length - z;
            return z > I ? `\r
` : `
`;
          }, "A");
          c.exports = A, c.exports.graceful = (T) => typeof T == "string" && A(T) || `
`;
        } }), Eb = Ur({ "node_modules/jest-docblock/build/index.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.extract = q, a.parse = fe, a.parseWithComments = Te, a.print = Se, a.strip = F;
          function c() {
            let se = vb();
            return c = /* @__PURE__ */ __name(function() {
              return se;
            }, "c"), se;
          }
          __name(c, "c");
          function A() {
            let se = T(bb());
            return A = /* @__PURE__ */ __name(function() {
              return se;
            }, "A"), se;
          }
          __name(A, "A");
          function T(se) {
            return se && se.__esModule ? se : { default: se };
          }
          __name(T, "T");
          var oe = /\*\/$/, z = /^\/\*\*?/, I = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, E = /(^|\s+)\/\/([^\r\n]*)/g, N = /^(\r?\n)+/, e = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, t = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, x = /(\r?\n|^) *\* ?/g, s = [];
          function q(se) {
            let Le = se.match(I);
            return Le ? Le[0].trimLeft() : "";
          }
          __name(q, "q");
          function F(se) {
            let Le = se.match(I);
            return Le && Le[0] ? se.substring(Le[0].length) : se;
          }
          __name(F, "F");
          function fe(se) {
            return Te(se).pragmas;
          }
          __name(fe, "fe");
          function Te(se) {
            let Le = (0, A().default)(se) || c().EOL;
            se = se.replace(z, "").replace(oe, "").replace(x, "$1");
            let Q = "";
            for (; Q !== se; )
              Q = se, se = se.replace(e, `${Le}$1 $2${Le}`);
            se = se.replace(N, "").trimRight();
            let Be = /* @__PURE__ */ Object.create(null), je = se.replace(t, "").replace(N, "").trimRight(), W;
            for (; W = t.exec(se); ) {
              let B = W[2].replace(E, "");
              typeof Be[W[1]] == "string" || Array.isArray(Be[W[1]]) ? Be[W[1]] = s.concat(Be[W[1]], B) : Be[W[1]] = B;
            }
            return { comments: je, pragmas: Be };
          }
          __name(Te, "Te");
          function Se(se) {
            let { comments: Le = "", pragmas: Q = {} } = se, Be = (0, A().default)(Le) || c().EOL, je = "/**", W = " *", B = " */", U = Object.keys(Q), m = U.map((g) => J(g, Q[g])).reduce((g, O) => g.concat(O), []).map((g) => `${W} ${g}${Be}`).join("");
            if (!Le) {
              if (U.length === 0)
                return "";
              if (U.length === 1 && !Array.isArray(Q[U[0]])) {
                let g = Q[U[0]];
                return `${je} ${J(U[0], g)[0]}${B}`;
              }
            }
            let v = Le.split(Be).map((g) => `${W} ${g}`).join(Be) + Be;
            return je + Be + (Le ? v : "") + (Le && U.length ? W + Be : "") + m + B;
          }
          __name(Se, "Se");
          function J(se, Le) {
            return s.concat(Le).map((Q) => `@${se} ${Q}`.trim());
          }
          __name(J, "J");
        } }), Tb = Ur({ "src/common/end-of-line.js"(a, c) {
          "use strict";
          Jr();
          function A(I) {
            let E = I.indexOf("\r");
            return E >= 0 ? I.charAt(E + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          __name(A, "A");
          function T(I) {
            switch (I) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          __name(T, "T");
          function oe(I, E) {
            let N;
            switch (E) {
              case `
`:
                N = /\n/g;
                break;
              case "\r":
                N = /\r/g;
                break;
              case `\r
`:
                N = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(E)}.`);
            }
            let e = I.match(N);
            return e ? e.length : 0;
          }
          __name(oe, "oe");
          function z(I) {
            return I.replace(/\r\n?/g, `
`);
          }
          __name(z, "z");
          c.exports = { guessEndOfLine: A, convertEndOfLineToChars: T, countEndOfLineChars: oe, normalizeEndOfLine: z };
        } }), Sb = Ur({ "src/language-js/utils/get-shebang.js"(a, c) {
          "use strict";
          Jr();
          function A(T) {
            if (!T.startsWith("#!"))
              return "";
            let oe = T.indexOf(`
`);
            return oe === -1 ? T : T.slice(0, oe);
          }
          __name(A, "A");
          c.exports = A;
        } }), Cb = Ur({ "src/language-js/pragma.js"(a, c) {
          "use strict";
          Jr();
          var { parseWithComments: A, strip: T, extract: oe, print: z } = Eb(), { normalizeEndOfLine: I } = Tb(), E = Sb();
          function N(x) {
            let s = E(x);
            s && (x = x.slice(s.length + 1));
            let q = oe(x), { pragmas: F, comments: fe } = A(q);
            return { shebang: s, text: x, pragmas: F, comments: fe };
          }
          __name(N, "N");
          function e(x) {
            let s = Object.keys(N(x).pragmas);
            return s.includes("prettier") || s.includes("format");
          }
          __name(e, "e");
          function t(x) {
            let { shebang: s, text: q, pragmas: F, comments: fe } = N(x), Te = T(q), Se = z({ pragmas: Object.assign({ format: "" }, F), comments: fe.trimStart() });
            return (s ? `${s}
` : "") + I(Se) + (Te.startsWith(`
`) ? `
` : `

`) + Te;
          }
          __name(t, "t");
          c.exports = { hasPragma: e, insertPragma: t };
        } }), Wg = Ur({ "src/utils/is-non-empty-array.js"(a, c) {
          "use strict";
          Jr();
          function A(T) {
            return Array.isArray(T) && T.length > 0;
          }
          __name(A, "A");
          c.exports = A;
        } }), Kg = Ur({ "src/language-js/loc.js"(a, c) {
          "use strict";
          Jr();
          var A = Wg();
          function T(N) {
            var e, t;
            let x = N.range ? N.range[0] : N.start, s = (e = (t = N.declaration) === null || t === void 0 ? void 0 : t.decorators) !== null && e !== void 0 ? e : N.decorators;
            return A(s) ? Math.min(T(s[0]), x) : x;
          }
          __name(T, "T");
          function oe(N) {
            return N.range ? N.range[1] : N.end;
          }
          __name(oe, "oe");
          function z(N, e) {
            let t = T(N);
            return Number.isInteger(t) && t === T(e);
          }
          __name(z, "z");
          function I(N, e) {
            let t = oe(N);
            return Number.isInteger(t) && t === oe(e);
          }
          __name(I, "I");
          function E(N, e) {
            return z(N, e) && I(N, e);
          }
          __name(E, "E");
          c.exports = { locStart: T, locEnd: oe, hasSameLocStart: z, hasSameLoc: E };
        } }), Db = Ur({ "src/language-js/parse/utils/create-parser.js"(a, c) {
          "use strict";
          Jr();
          var { hasPragma: A } = Cb(), { locStart: T, locEnd: oe } = Kg();
          function z(I) {
            return I = typeof I == "function" ? { parse: I } : I, Object.assign({ astFormat: "estree", hasPragma: A, locStart: T, locEnd: oe }, I);
          }
          __name(z, "z");
          c.exports = z;
        } }), xb = Ur({ "src/language-js/parse/utils/replace-hashbang.js"(a, c) {
          "use strict";
          Jr();
          function A(T) {
            return T.charAt(0) === "#" && T.charAt(1) === "!" ? "//" + T.slice(2) : T;
          }
          __name(A, "A");
          c.exports = A;
        } }), wb = Ur({ "src/language-js/utils/is-ts-keyword-type.js"(a, c) {
          "use strict";
          Jr();
          function A(T) {
            let { type: oe } = T;
            return oe.startsWith("TS") && oe.endsWith("Keyword");
          }
          __name(A, "A");
          c.exports = A;
        } }), Ab = Ur({ "src/language-js/utils/is-block-comment.js"(a, c) {
          "use strict";
          Jr();
          var A = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), T = /* @__PURE__ */ __name((oe) => A.has(oe == null ? void 0 : oe.type), "T");
          c.exports = T;
        } }), kb = Ur({ "src/language-js/utils/is-type-cast-comment.js"(a, c) {
          "use strict";
          Jr();
          var A = Ab();
          function T(oe) {
            return A(oe) && oe.value[0] === "*" && /@type\b/.test(oe.value);
          }
          __name(T, "T");
          c.exports = T;
        } }), Pb = Ur({ "src/utils/get-last.js"(a, c) {
          "use strict";
          Jr();
          var A = /* @__PURE__ */ __name((T) => T[T.length - 1], "A");
          c.exports = A;
        } }), Hg = Ur({ "src/language-js/parse/postprocess/visit-node.js"(a, c) {
          "use strict";
          Jr();
          function A(T, oe) {
            if (Array.isArray(T)) {
              for (let z = 0; z < T.length; z++)
                T[z] = A(T[z], oe);
              return T;
            }
            if (T && typeof T == "object" && typeof T.type == "string") {
              let z = Object.keys(T);
              for (let I = 0; I < z.length; I++)
                T[z[I]] = A(T[z[I]], oe);
              return oe(T) || T;
            }
            return T;
          }
          __name(A, "A");
          c.exports = A;
        } }), Gg = Ur({ "src/language-js/parse/postprocess/throw-syntax-error.js"(a, c) {
          "use strict";
          Jr();
          var A = Ng();
          function T(oe, z) {
            let { start: I, end: E } = oe.loc;
            throw A(z, { start: { line: I.line, column: I.column + 1 }, end: { line: E.line, column: E.column + 1 } });
          }
          __name(T, "T");
          c.exports = T;
        } }), Nb = Ur({ "src/language-js/parse/postprocess/typescript.js"(a, c) {
          "use strict";
          Jr();
          var A = Wg(), T = Hg(), oe = Gg(), z = { AbstractKeyword: 126, SourceFile: 308, PropertyDeclaration: 169 };
          function I(t) {
            for (; t && t.kind !== z.SourceFile; )
              t = t.parent;
            return t;
          }
          __name(I, "I");
          function E(t) {
            let { illegalDecorators: x } = t;
            if (!A(x))
              return;
            let [{ expression: s }] = x, q = I(s), [F, fe] = [s.pos, s.end].map((Te) => {
              let { line: Se, character: J } = q.getLineAndCharacterOfPosition(Te);
              return { line: Se + 1, column: J };
            });
            oe({ loc: { start: F, end: fe } }, "Decorators are not valid here.");
          }
          __name(E, "E");
          function N(t, x) {
            t.kind !== z.PropertyDeclaration || t.modifiers && !t.modifiers.some((s) => s.kind === z.AbstractKeyword) || t.initializer && x.value === null && oe(x, "Abstract property cannot have an initializer");
          }
          __name(N, "N");
          function e(t, x) {
            let { esTreeNodeToTSNodeMap: s, tsNodeToESTreeNodeMap: q } = x.tsParseResult;
            T(t, (F) => {
              let fe = s.get(F);
              if (!fe)
                return;
              let Te = q.get(fe);
              Te === F && (E(fe), N(fe, Te));
            });
          }
          __name(e, "e");
          c.exports = { throwErrorForInvalidNodes: e };
        } }), Ib = Ur({ "src/language-js/parse/postprocess/index.js"(a, c) {
          "use strict";
          Jr();
          var { locStart: A, locEnd: T } = Kg(), oe = wb(), z = kb(), I = Pb(), E = Hg(), { throwErrorForInvalidNodes: N } = Nb(), e = Gg();
          function t(F, fe) {
            if (fe.parser === "typescript" && /@|abstract/.test(fe.originalText) && N(F, fe), fe.parser !== "typescript" && fe.parser !== "flow" && fe.parser !== "acorn" && fe.parser !== "espree" && fe.parser !== "meriyah") {
              let Se = /* @__PURE__ */ new Set();
              F = E(F, (J) => {
                J.leadingComments && J.leadingComments.some(z) && Se.add(A(J));
              }), F = E(F, (J) => {
                if (J.type === "ParenthesizedExpression") {
                  let { expression: se } = J;
                  if (se.type === "TypeCastExpression")
                    return se.range = J.range, se;
                  let Le = A(J);
                  if (!Se.has(Le))
                    return se.extra = Object.assign(Object.assign({}, se.extra), {}, { parenthesized: true }), se;
                }
              });
            }
            return F = E(F, (Se) => {
              switch (Se.type) {
                case "ChainExpression":
                  return x(Se.expression);
                case "LogicalExpression": {
                  if (s(Se))
                    return q(Se);
                  break;
                }
                case "VariableDeclaration": {
                  let J = I(Se.declarations);
                  J && J.init && Te(Se, J);
                  break;
                }
                case "TSParenthesizedType":
                  return oe(Se.typeAnnotation) || Se.typeAnnotation.type === "TSThisType" || (Se.typeAnnotation.range = [A(Se), T(Se)]), Se.typeAnnotation;
                case "TSTypeParameter":
                  if (typeof Se.name == "string") {
                    let J = A(Se);
                    Se.name = { type: "Identifier", name: Se.name, range: [J, J + Se.name.length] };
                  }
                  break;
                case "ObjectExpression":
                  if (fe.parser === "typescript") {
                    let J = Se.properties.find((se) => se.type === "Property" && se.value.type === "TSEmptyBodyFunctionExpression");
                    J && e(J.value, "Unexpected token.");
                  }
                  break;
                case "SequenceExpression": {
                  let J = I(Se.expressions);
                  Se.range = [A(Se), Math.min(T(J), T(Se))];
                  break;
                }
                case "TopicReference":
                  fe.__isUsingHackPipeline = true;
                  break;
                case "ExportAllDeclaration": {
                  let { exported: J } = Se;
                  if (fe.parser === "meriyah" && J && J.type === "Identifier") {
                    let se = fe.originalText.slice(A(J), T(J));
                    (se.startsWith('"') || se.startsWith("'")) && (Se.exported = Object.assign(Object.assign({}, Se.exported), {}, { type: "Literal", value: Se.exported.name, raw: se }));
                  }
                  break;
                }
                case "PropertyDefinition":
                  if (fe.parser === "meriyah" && Se.static && !Se.computed && !Se.key) {
                    let J = "static", se = A(Se);
                    Object.assign(Se, { static: false, key: { type: "Identifier", name: J, range: [se, se + J.length] } });
                  }
                  break;
              }
            }), F;
            function Te(Se, J) {
              fe.originalText[T(J)] !== ";" && (Se.range = [A(Se), T(J)]);
            }
            __name(Te, "Te");
          }
          __name(t, "t");
          function x(F) {
            switch (F.type) {
              case "CallExpression":
                F.type = "OptionalCallExpression", F.callee = x(F.callee);
                break;
              case "MemberExpression":
                F.type = "OptionalMemberExpression", F.object = x(F.object);
                break;
              case "TSNonNullExpression":
                F.expression = x(F.expression);
                break;
            }
            return F;
          }
          __name(x, "x");
          function s(F) {
            return F.type === "LogicalExpression" && F.right.type === "LogicalExpression" && F.operator === F.right.operator;
          }
          __name(s, "s");
          function q(F) {
            return s(F) ? q({ type: "LogicalExpression", operator: F.operator, left: q({ type: "LogicalExpression", operator: F.operator, left: F.left, right: F.right.left, range: [A(F.left), T(F.right.left)] }), right: F.right.right, range: [A(F), T(F)] }) : F;
          }
          __name(q, "q");
          c.exports = t;
        } }), Ps = Ur({ "scripts/build/shims/debug.cjs"(a, c) {
          "use strict";
          Jr(), c.exports = () => () => {
          };
        } }), xi = Ur({ "node_modules/typescript/lib/typescript.js"(a, c) {
          "use strict";
          Jr();
          var A = a && a.__spreadArray || function(e, t, x) {
            if (x || arguments.length === 2)
              for (var s = 0, q = t.length, F; s < q; s++)
                (F || !(s in t)) && (F || (F = Array.prototype.slice.call(t, 0, s)), F[s] = t[s]);
            return e.concat(F || Array.prototype.slice.call(t));
          }, T = a && a.__assign || function() {
            return T = Object.assign || function(e) {
              for (var t, x = 1, s = arguments.length; x < s; x++) {
                t = arguments[x];
                for (var q in t)
                  Object.prototype.hasOwnProperty.call(t, q) && (e[q] = t[q]);
              }
              return e;
            }, T.apply(this, arguments);
          }, oe = a && a.__makeTemplateObject || function(e, t) {
            return Object.defineProperty ? Object.defineProperty(e, "raw", { value: t }) : e.raw = t, e;
          }, z = a && a.__generator || function(e, t) {
            var x = { label: 0, sent: function() {
              if (F[0] & 1)
                throw F[1];
              return F[1];
            }, trys: [], ops: [] }, s, q, F, fe;
            return fe = { next: Te(0), throw: Te(1), return: Te(2) }, typeof Symbol == "function" && (fe[Symbol.iterator] = function() {
              return this;
            }), fe;
            function Te(J) {
              return function(se) {
                return Se([J, se]);
              };
            }
            __name(Te, "Te");
            function Se(J) {
              if (s)
                throw new TypeError("Generator is already executing.");
              for (; fe && (fe = 0, J[0] && (x = 0)), x; )
                try {
                  if (s = 1, q && (F = J[0] & 2 ? q.return : J[0] ? q.throw || ((F = q.return) && F.call(q), 0) : q.next) && !(F = F.call(q, J[1])).done)
                    return F;
                  switch (q = 0, F && (J = [J[0] & 2, F.value]), J[0]) {
                    case 0:
                    case 1:
                      F = J;
                      break;
                    case 4:
                      return x.label++, { value: J[1], done: false };
                    case 5:
                      x.label++, q = J[1], J = [0];
                      continue;
                    case 7:
                      J = x.ops.pop(), x.trys.pop();
                      continue;
                    default:
                      if (F = x.trys, !(F = F.length > 0 && F[F.length - 1]) && (J[0] === 6 || J[0] === 2)) {
                        x = 0;
                        continue;
                      }
                      if (J[0] === 3 && (!F || J[1] > F[0] && J[1] < F[3])) {
                        x.label = J[1];
                        break;
                      }
                      if (J[0] === 6 && x.label < F[1]) {
                        x.label = F[1], F = J;
                        break;
                      }
                      if (F && x.label < F[2]) {
                        x.label = F[2], x.ops.push(J);
                        break;
                      }
                      F[2] && x.ops.pop(), x.trys.pop();
                      continue;
                  }
                  J = t.call(e, x);
                } catch (se) {
                  J = [6, se], q = 0;
                } finally {
                  s = F = 0;
                }
              if (J[0] & 5)
                throw J[1];
              return { value: J[0] ? J[1] : void 0, done: true };
            }
            __name(Se, "Se");
          }, I = a && a.__rest || function(e, t) {
            var x = {};
            for (var s in e)
              Object.prototype.hasOwnProperty.call(e, s) && t.indexOf(s) < 0 && (x[s] = e[s]);
            if (e != null && typeof Object.getOwnPropertySymbols == "function")
              for (var q = 0, s = Object.getOwnPropertySymbols(e); q < s.length; q++)
                t.indexOf(s[q]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[q]) && (x[s[q]] = e[s[q]]);
            return x;
          }, E = a && a.__extends || function() {
            var e = /* @__PURE__ */ __name(function(t, x) {
              return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(s, q) {
                s.__proto__ = q;
              } || function(s, q) {
                for (var F in q)
                  Object.prototype.hasOwnProperty.call(q, F) && (s[F] = q[F]);
              }, e(t, x);
            }, "e");
            return function(t, x) {
              if (typeof x != "function" && x !== null)
                throw new TypeError("Class extends value " + String(x) + " is not a constructor or null");
              e(t, x);
              function s() {
                this.constructor = t;
              }
              __name(s, "s");
              t.prototype = x === null ? Object.create(x) : (s.prototype = x.prototype, new s());
            };
          }(), N;
          (function(e) {
            e.versionMajorMinor = "4.9", e.version = "".concat(e.versionMajorMinor, ".3");
            var t;
            (function(s) {
              s[s.LessThan = -1] = "LessThan", s[s.EqualTo = 0] = "EqualTo", s[s.GreaterThan = 1] = "GreaterThan";
            })(t = e.Comparison || (e.Comparison = {}));
            var x;
            (function(s) {
              var q = typeof globalThis < "u" || typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : void 0;
              function F() {
                var Te = q == null ? void 0 : q.Map, Se = typeof Te < "u" && "entries" in Te.prototype && new Te([[0, 0]]).size === 1 ? Te : void 0;
                if (!Se)
                  throw new Error("No compatible Map implementation found.");
                return Se;
              }
              __name(F, "F");
              s.tryGetNativeMap = F;
              function fe() {
                var Te = q == null ? void 0 : q.Set, Se = typeof Te < "u" && "entries" in Te.prototype && new Te([0]).size === 1 ? Te : void 0;
                if (!Se)
                  throw new Error("No compatible Set implementation found.");
                return Se;
              }
              __name(fe, "fe");
              s.tryGetNativeSet = fe;
            })(x || (x = {})), e.Map = x.tryGetNativeMap(), e.Set = x.tryGetNativeSet();
          })(N || (N = {}));
          var N;
          (function(e) {
            function t(C) {
              if (C) {
                if (Vt(C))
                  return pt(C);
                if (C instanceof e.Map)
                  return C.entries();
                if (C instanceof e.Set)
                  return C.values();
                throw new Error("Iteration not supported.");
              }
            }
            __name(t, "t");
            e.getIterator = t, e.emptyArray = [], e.emptyMap = new e.Map(), e.emptySet = new e.Set();
            function x(C) {
              return C ? C.length : 0;
            }
            __name(x, "x");
            e.length = x;
            function s(C, V) {
              if (C)
                for (var ee = 0; ee < C.length; ee++) {
                  var le = V(C[ee], ee);
                  if (le)
                    return le;
                }
            }
            __name(s, "s");
            e.forEach = s;
            function q(C, V) {
              if (C)
                for (var ee = C.length - 1; ee >= 0; ee--) {
                  var le = V(C[ee], ee);
                  if (le)
                    return le;
                }
            }
            __name(q, "q");
            e.forEachRight = q;
            function F(C, V) {
              if (C !== void 0)
                for (var ee = 0; ee < C.length; ee++) {
                  var le = V(C[ee], ee);
                  if (le !== void 0)
                    return le;
                }
            }
            __name(F, "F");
            e.firstDefined = F;
            function fe(C, V) {
              for (; ; ) {
                var ee = C.next();
                if (ee.done)
                  return;
                var le = V(ee.value);
                if (le !== void 0)
                  return le;
              }
            }
            __name(fe, "fe");
            e.firstDefinedIterator = fe;
            function Te(C, V, ee) {
              var le = ee;
              if (C)
                for (var Ze = C.next(), Ir = 0; !Ze.done; Ze = C.next(), Ir++)
                  le = V(le, Ze.value, Ir);
              return le;
            }
            __name(Te, "Te");
            e.reduceLeftIterator = Te;
            function Se(C, V, ee) {
              var le = [];
              e.Debug.assertEqual(C.length, V.length);
              for (var Ze = 0; Ze < C.length; Ze++)
                le.push(ee(C[Ze], V[Ze], Ze));
              return le;
            }
            __name(Se, "Se");
            e.zipWith = Se;
            function J(C, V) {
              e.Debug.assertEqual(C.length, V.length);
              var ee = 0;
              return { next: function() {
                return ee === C.length ? { value: void 0, done: true } : (ee++, { value: [C[ee - 1], V[ee - 1]], done: false });
              } };
            }
            __name(J, "J");
            e.zipToIterator = J;
            function se(C, V) {
              e.Debug.assert(C.length === V.length);
              for (var ee = new e.Map(), le = 0; le < C.length; ++le)
                ee.set(C[le], V[le]);
              return ee;
            }
            __name(se, "se");
            e.zipToMap = se;
            function Le(C, V) {
              if (C.length <= 1)
                return C;
              for (var ee = [], le = 0, Ze = C.length; le < Ze; le++)
                le && ee.push(V), ee.push(C[le]);
              return ee;
            }
            __name(Le, "Le");
            e.intersperse = Le;
            function Q(C, V) {
              if (C) {
                for (var ee = 0; ee < C.length; ee++)
                  if (!V(C[ee], ee))
                    return false;
              }
              return true;
            }
            __name(Q, "Q");
            e.every = Q;
            function Be(C, V, ee) {
              if (C !== void 0)
                for (var le = ee != null ? ee : 0; le < C.length; le++) {
                  var Ze = C[le];
                  if (V(Ze, le))
                    return Ze;
                }
            }
            __name(Be, "Be");
            e.find = Be;
            function je(C, V, ee) {
              if (C !== void 0)
                for (var le = ee != null ? ee : C.length - 1; le >= 0; le--) {
                  var Ze = C[le];
                  if (V(Ze, le))
                    return Ze;
                }
            }
            __name(je, "je");
            e.findLast = je;
            function W(C, V, ee) {
              if (C === void 0)
                return -1;
              for (var le = ee != null ? ee : 0; le < C.length; le++)
                if (V(C[le], le))
                  return le;
              return -1;
            }
            __name(W, "W");
            e.findIndex = W;
            function B(C, V, ee) {
              if (C === void 0)
                return -1;
              for (var le = ee != null ? ee : C.length - 1; le >= 0; le--)
                if (V(C[le], le))
                  return le;
              return -1;
            }
            __name(B, "B");
            e.findLastIndex = B;
            function U(C, V) {
              for (var ee = 0; ee < C.length; ee++) {
                var le = V(C[ee], ee);
                if (le)
                  return le;
              }
              return e.Debug.fail();
            }
            __name(U, "U");
            e.findMap = U;
            function m(C, V, ee) {
              if (ee === void 0 && (ee = On), C)
                for (var le = 0, Ze = C; le < Ze.length; le++) {
                  var Ir = Ze[le];
                  if (ee(Ir, V))
                    return true;
                }
              return false;
            }
            __name(m, "m");
            e.contains = m;
            function v(C, V, ee) {
              return ee === void 0 && (ee = On), C.length === V.length && C.every(function(le, Ze) {
                return ee(le, V[Ze]);
              });
            }
            __name(v, "v");
            e.arraysEqual = v;
            function g(C, V, ee) {
              for (var le = ee || 0; le < C.length; le++)
                if (m(V, C.charCodeAt(le)))
                  return le;
              return -1;
            }
            __name(g, "g");
            e.indexOfAnyCharCode = g;
            function O(C, V) {
              var ee = 0;
              if (C)
                for (var le = 0; le < C.length; le++) {
                  var Ze = C[le];
                  V(Ze, le) && ee++;
                }
              return ee;
            }
            __name(O, "O");
            e.countWhere = O;
            function S(C, V) {
              if (C) {
                for (var ee = C.length, le = 0; le < ee && V(C[le]); )
                  le++;
                if (le < ee) {
                  var Ze = C.slice(0, le);
                  for (le++; le < ee; ) {
                    var Ir = C[le];
                    V(Ir) && Ze.push(Ir), le++;
                  }
                  return Ze;
                }
              }
              return C;
            }
            __name(S, "S");
            e.filter = S;
            function te(C, V) {
              for (var ee = 0, le = 0; le < C.length; le++)
                V(C[le], le, C) && (C[ee] = C[le], ee++);
              C.length = ee;
            }
            __name(te, "te");
            e.filterMutate = te;
            function Je(C) {
              C.length = 0;
            }
            __name(Je, "Je");
            e.clear = Je;
            function qe(C, V) {
              var ee;
              if (C) {
                ee = [];
                for (var le = 0; le < C.length; le++)
                  ee.push(V(C[le], le));
              }
              return ee;
            }
            __name(qe, "qe");
            e.map = qe;
            function ge(C, V) {
              return { next: function() {
                var ee = C.next();
                return ee.done ? ee : { value: V(ee.value), done: false };
              } };
            }
            __name(ge, "ge");
            e.mapIterator = ge;
            function ie(C, V) {
              if (C)
                for (var ee = 0; ee < C.length; ee++) {
                  var le = C[ee], Ze = V(le, ee);
                  if (le !== Ze) {
                    var Ir = C.slice(0, ee);
                    for (Ir.push(Ze), ee++; ee < C.length; ee++)
                      Ir.push(V(C[ee], ee));
                    return Ir;
                  }
                }
              return C;
            }
            __name(ie, "ie");
            e.sameMap = ie;
            function G(C) {
              for (var V = [], ee = 0, le = C; ee < le.length; ee++) {
                var Ze = le[ee];
                Ze && (Vt(Ze) ? h(V, Ze) : V.push(Ze));
              }
              return V;
            }
            __name(G, "G");
            e.flatten = G;
            function pe(C, V) {
              var ee;
              if (C)
                for (var le = 0; le < C.length; le++) {
                  var Ze = V(C[le], le);
                  Ze && (Vt(Ze) ? ee = h(ee, Ze) : ee = rt(ee, Ze));
                }
              return ee || e.emptyArray;
            }
            __name(pe, "pe");
            e.flatMap = pe;
            function j(C, V) {
              var ee = [];
              if (C)
                for (var le = 0; le < C.length; le++) {
                  var Ze = V(C[le], le);
                  Ze && (Vt(Ze) ? h(ee, Ze) : ee.push(Ze));
                }
              return ee;
            }
            __name(j, "j");
            e.flatMapToMutable = j;
            function be(C, V) {
              var ee = C.next();
              if (ee.done)
                return e.emptyIterator;
              var le = Ze(ee.value);
              return { next: function() {
                for (; ; ) {
                  var Ir = le.next();
                  if (!Ir.done)
                    return Ir;
                  var Ar = C.next();
                  if (Ar.done)
                    return Ar;
                  le = Ze(Ar.value);
                }
              } };
              function Ze(Ir) {
                var Ar = V(Ir);
                return Ar === void 0 ? e.emptyIterator : Vt(Ar) ? pt(Ar) : Ar;
              }
              __name(Ze, "Ze");
            }
            __name(be, "be");
            e.flatMapIterator = be;
            function $e(C, V) {
              var ee;
              if (C)
                for (var le = 0; le < C.length; le++) {
                  var Ze = C[le], Ir = V(Ze, le);
                  (ee || Ze !== Ir || Vt(Ir)) && (ee || (ee = C.slice(0, le)), Vt(Ir) ? h(ee, Ir) : ee.push(Ir));
                }
              return ee || C;
            }
            __name($e, "$e");
            e.sameFlatMap = $e;
            function Re(C, V) {
              for (var ee = [], le = 0; le < C.length; le++) {
                var Ze = V(C[le], le);
                if (Ze === void 0)
                  return;
                ee.push(Ze);
              }
              return ee;
            }
            __name(Re, "Re");
            e.mapAllOrFail = Re;
            function Fe(C, V) {
              var ee = [];
              if (C)
                for (var le = 0; le < C.length; le++) {
                  var Ze = V(C[le], le);
                  Ze !== void 0 && ee.push(Ze);
                }
              return ee;
            }
            __name(Fe, "Fe");
            e.mapDefined = Fe;
            function dr(C, V) {
              return { next: function() {
                for (; ; ) {
                  var ee = C.next();
                  if (ee.done)
                    return ee;
                  var le = V(ee.value);
                  if (le !== void 0)
                    return { value: le, done: false };
                }
              } };
            }
            __name(dr, "dr");
            e.mapDefinedIterator = dr;
            function ze(C, V) {
              if (!!C) {
                var ee = new e.Map();
                return C.forEach(function(le, Ze) {
                  var Ir = V(Ze, le);
                  if (Ir !== void 0) {
                    var Ar = Ir[0], hr = Ir[1];
                    Ar !== void 0 && hr !== void 0 && ee.set(Ar, hr);
                  }
                }), ee;
              }
            }
            __name(ze, "ze");
            e.mapDefinedEntries = ze;
            function ve(C, V) {
              if (C) {
                var ee = new e.Set();
                return C.forEach(function(le) {
                  var Ze = V(le);
                  Ze !== void 0 && ee.add(Ze);
                }), ee;
              }
            }
            __name(ve, "ve");
            e.mapDefinedValues = ve;
            function er(C, V, ee) {
              if (C.has(V))
                return C.get(V);
              var le = ee();
              return C.set(V, le), le;
            }
            __name(er, "er");
            e.getOrUpdate = er;
            function ar(C, V) {
              return C.has(V) ? false : (C.add(V), true);
            }
            __name(ar, "ar");
            e.tryAddToSet = ar, e.emptyIterator = { next: function() {
              return { value: void 0, done: true };
            } };
            function Cr(C) {
              var V = false;
              return { next: function() {
                var ee = V;
                return V = true, ee ? { value: void 0, done: true } : { value: C, done: false };
              } };
            }
            __name(Cr, "Cr");
            e.singleIterator = Cr;
            function Ce(C, V, ee) {
              var le;
              if (C) {
                le = [];
                for (var Ze = C.length, Ir = void 0, Ar = void 0, hr = 0, yt = 0; hr < Ze; ) {
                  for (; yt < Ze; ) {
                    var Pt = C[yt];
                    if (Ar = V(Pt, yt), yt === 0)
                      Ir = Ar;
                    else if (Ar !== Ir)
                      break;
                    yt++;
                  }
                  if (hr < yt) {
                    var Ut = ee(C.slice(hr, yt), Ir, hr, yt);
                    Ut && le.push(Ut), hr = yt;
                  }
                  Ir = Ar, yt++;
                }
              }
              return le;
            }
            __name(Ce, "Ce");
            e.spanMap = Ce;
            function Xe(C, V) {
              if (!!C) {
                var ee = new e.Map();
                return C.forEach(function(le, Ze) {
                  var Ir = V(Ze, le), Ar = Ir[0], hr = Ir[1];
                  ee.set(Ar, hr);
                }), ee;
              }
            }
            __name(Xe, "Xe");
            e.mapEntries = Xe;
            function gr(C, V) {
              if (C)
                if (V)
                  for (var ee = 0, le = C; ee < le.length; ee++) {
                    var Ze = le[ee];
                    if (V(Ze))
                      return true;
                  }
                else
                  return C.length > 0;
              return false;
            }
            __name(gr, "gr");
            e.some = gr;
            function X(C, V, ee) {
              for (var le, Ze = 0; Ze < C.length; Ze++)
                V(C[Ze]) ? le = le === void 0 ? Ze : le : le !== void 0 && (ee(le, Ze), le = void 0);
              le !== void 0 && ee(le, C.length);
            }
            __name(X, "X");
            e.getRangesWhere = X;
            function Ee(C, V) {
              return gr(V) ? gr(C) ? A(A([], C, true), V, true) : V : C;
            }
            __name(Ee, "Ee");
            e.concatenate = Ee;
            function we(C, V) {
              return V;
            }
            __name(we, "we");
            function he(C) {
              return C.map(we);
            }
            __name(he, "he");
            e.indicesOf = he;
            function yr(C, V, ee) {
              var le = he(C);
              jr(C, le, ee);
              for (var Ze = C[le[0]], Ir = [le[0]], Ar = 1; Ar < le.length; Ar++) {
                var hr = le[Ar], yt = C[hr];
                V(Ze, yt) || (Ir.push(hr), Ze = yt);
              }
              return Ir.sort(), Ir.map(function(Pt) {
                return C[Pt];
              });
            }
            __name(yr, "yr");
            function kr(C, V) {
              for (var ee = [], le = 0, Ze = C; le < Ze.length; le++) {
                var Ir = Ze[le];
                ae(ee, Ir, V);
              }
              return ee;
            }
            __name(kr, "kr");
            function nr(C, V, ee) {
              return C.length === 0 ? [] : C.length === 1 ? C.slice() : ee ? yr(C, V, ee) : kr(C, V);
            }
            __name(nr, "nr");
            e.deduplicate = nr;
            function tr(C, V) {
              if (C.length === 0)
                return e.emptyArray;
              for (var ee = C[0], le = [ee], Ze = 1; Ze < C.length; Ze++) {
                var Ir = C[Ze];
                switch (V(Ir, ee)) {
                  case true:
                  case 0:
                    continue;
                  case -1:
                    return e.Debug.fail("Array is unsorted.");
                }
                le.push(ee = Ir);
              }
              return le;
            }
            __name(tr, "tr");
            function Lr() {
              return [];
            }
            __name(Lr, "Lr");
            e.createSortedArray = Lr;
            function zr(C, V, ee, le) {
              if (C.length === 0)
                return C.push(V), true;
              var Ze = Mr(C, V, Dn, ee);
              return Ze < 0 ? (C.splice(~Ze, 0, V), true) : le ? (C.splice(Ze, 0, V), true) : false;
            }
            __name(zr, "zr");
            e.insertSorted = zr;
            function ye(C, V, ee) {
              return tr(qr(C, V), ee || V || Me);
            }
            __name(ye, "ye");
            e.sortAndDeduplicate = ye;
            function ir(C, V) {
              if (C.length < 2)
                return true;
              for (var ee = C[0], le = 0, Ze = C.slice(1); le < Ze.length; le++) {
                var Ir = Ze[le];
                if (V(ee, Ir) === 1)
                  return false;
                ee = Ir;
              }
              return true;
            }
            __name(ir, "ir");
            e.arrayIsSorted = ir;
            function Dr(C, V, ee) {
              if (ee === void 0 && (ee = On), !C || !V)
                return C === V;
              if (C.length !== V.length)
                return false;
              for (var le = 0; le < C.length; le++)
                if (!ee(C[le], V[le], le))
                  return false;
              return true;
            }
            __name(Dr, "Dr");
            e.arrayIsEqualTo = Dr;
            function Pr(C) {
              var V;
              if (C)
                for (var ee = 0; ee < C.length; ee++) {
                  var le = C[ee];
                  (V || !le) && (V || (V = C.slice(0, ee)), le && V.push(le));
                }
              return V || C;
            }
            __name(Pr, "Pr");
            e.compact = Pr;
            function Br(C, V, ee) {
              if (!V || !C || V.length === 0 || C.length === 0)
                return V;
              var le = [];
              e:
                for (var Ze = 0, Ir = 0; Ir < V.length; Ir++) {
                  Ir > 0 && e.Debug.assertGreaterThanOrEqual(ee(V[Ir], V[Ir - 1]), 0);
                  r:
                    for (var Ar = Ze; Ze < C.length; Ze++)
                      switch (Ze > Ar && e.Debug.assertGreaterThanOrEqual(ee(C[Ze], C[Ze - 1]), 0), ee(V[Ir], C[Ze])) {
                        case -1:
                          le.push(V[Ir]);
                          continue e;
                        case 0:
                          continue e;
                        case 1:
                          continue r;
                      }
                }
              return le;
            }
            __name(Br, "Br");
            e.relativeComplement = Br;
            function ut(C, V) {
              for (var ee = 0, le = 0, Ze = C; le < Ze.length; le++) {
                var Ir = Ze[le];
                ee += Ir[V];
              }
              return ee;
            }
            __name(ut, "ut");
            e.sum = ut;
            function rt(C, V) {
              return V === void 0 ? C : C === void 0 ? [V] : (C.push(V), C);
            }
            __name(rt, "rt");
            e.append = rt;
            function Z(C, V) {
              return C === void 0 ? V : V === void 0 ? C : Vt(C) ? Vt(V) ? Ee(C, V) : rt(C, V) : Vt(V) ? rt(V, C) : [C, V];
            }
            __name(Z, "Z");
            e.combine = Z;
            function f(C, V) {
              return V < 0 ? C.length + V : V;
            }
            __name(f, "f");
            function h(C, V, ee, le) {
              if (V === void 0 || V.length === 0)
                return C;
              if (C === void 0)
                return V.slice(ee, le);
              ee = ee === void 0 ? 0 : f(V, ee), le = le === void 0 ? V.length : f(V, le);
              for (var Ze = ee; Ze < le && Ze < V.length; Ze++)
                V[Ze] !== void 0 && C.push(V[Ze]);
              return C;
            }
            __name(h, "h");
            e.addRange = h;
            function ae(C, V, ee) {
              return m(C, V, ee) ? false : (C.push(V), true);
            }
            __name(ae, "ae");
            e.pushIfUnique = ae;
            function xr(C, V, ee) {
              return C ? (ae(C, V, ee), C) : [V];
            }
            __name(xr, "xr");
            e.appendIfUnique = xr;
            function jr(C, V, ee) {
              V.sort(function(le, Ze) {
                return ee(C[le], C[Ze]) || L(le, Ze);
              });
            }
            __name(jr, "jr");
            function qr(C, V) {
              return C.length === 0 ? C : C.slice().sort(V);
            }
            __name(qr, "qr");
            e.sort = qr;
            function pt(C) {
              var V = 0;
              return { next: function() {
                return V === C.length ? { value: void 0, done: true } : (V++, { value: C[V - 1], done: false });
              } };
            }
            __name(pt, "pt");
            e.arrayIterator = pt;
            function Ge(C) {
              var V = C.length;
              return { next: function() {
                return V === 0 ? { value: void 0, done: true } : (V--, { value: C[V], done: false });
              } };
            }
            __name(Ge, "Ge");
            e.arrayReverseIterator = Ge;
            function K(C, V) {
              var ee = he(C);
              return jr(C, ee, V), ee.map(function(le) {
                return C[le];
              });
            }
            __name(K, "K");
            e.stableSort = K;
            function r(C, V, ee, le) {
              for (; ee < le; ) {
                if (C[ee] !== V[ee])
                  return false;
                ee++;
              }
              return true;
            }
            __name(r, "r");
            e.rangeEquals = r;
            function ct(C, V) {
              if (C && (V = f(C, V), V < C.length))
                return C[V];
            }
            __name(ct, "ct");
            e.elementAt = ct;
            function ft(C) {
              return C === void 0 || C.length === 0 ? void 0 : C[0];
            }
            __name(ft, "ft");
            e.firstOrUndefined = ft;
            function Ie(C) {
              return e.Debug.assert(C.length !== 0), C[0];
            }
            __name(Ie, "Ie");
            e.first = Ie;
            function me(C) {
              return C === void 0 || C.length === 0 ? void 0 : C[C.length - 1];
            }
            __name(me, "me");
            e.lastOrUndefined = me;
            function xe(C) {
              return e.Debug.assert(C.length !== 0), C[C.length - 1];
            }
            __name(xe, "xe");
            e.last = xe;
            function Ye(C) {
              return C && C.length === 1 ? C[0] : void 0;
            }
            __name(Ye, "Ye");
            e.singleOrUndefined = Ye;
            function vr(C) {
              return e.Debug.checkDefined(Ye(C));
            }
            __name(vr, "vr");
            e.single = vr;
            function nt(C) {
              return C && C.length === 1 ? C[0] : C;
            }
            __name(nt, "nt");
            e.singleOrMany = nt;
            function pr(C, V, ee) {
              var le = C.slice(0);
              return le[V] = ee, le;
            }
            __name(pr, "pr");
            e.replaceElement = pr;
            function Mr(C, V, ee, le, Ze) {
              return ot(C, ee(V), ee, le, Ze);
            }
            __name(Mr, "Mr");
            e.binarySearch = Mr;
            function ot(C, V, ee, le, Ze) {
              if (!gr(C))
                return -1;
              for (var Ir = Ze || 0, Ar = C.length - 1; Ir <= Ar; ) {
                var hr = Ir + (Ar - Ir >> 1), yt = ee(C[hr], hr);
                switch (le(yt, V)) {
                  case -1:
                    Ir = hr + 1;
                    break;
                  case 0:
                    return hr;
                  case 1:
                    Ar = hr - 1;
                    break;
                }
              }
              return ~Ir;
            }
            __name(ot, "ot");
            e.binarySearchKey = ot;
            function At(C, V, ee, le, Ze) {
              if (C && C.length > 0) {
                var Ir = C.length;
                if (Ir > 0) {
                  var Ar = le === void 0 || le < 0 ? 0 : le, hr = Ze === void 0 || Ar + Ze > Ir - 1 ? Ir - 1 : Ar + Ze, yt = void 0;
                  for (arguments.length <= 2 ? (yt = C[Ar], Ar++) : yt = ee; Ar <= hr; )
                    yt = V(yt, C[Ar], Ar), Ar++;
                  return yt;
                }
              }
              return ee;
            }
            __name(At, "At");
            e.reduceLeft = At;
            var re = Object.prototype.hasOwnProperty;
            function de(C, V) {
              return re.call(C, V);
            }
            __name(de, "de");
            e.hasProperty = de;
            function He(C, V) {
              return re.call(C, V) ? C[V] : void 0;
            }
            __name(He, "He");
            e.getProperty = He;
            function Nr(C) {
              var V = [];
              for (var ee in C)
                re.call(C, ee) && V.push(ee);
              return V;
            }
            __name(Nr, "Nr");
            e.getOwnKeys = Nr;
            function Yr(C) {
              var V = [];
              do
                for (var ee = Object.getOwnPropertyNames(C), le = 0, Ze = ee; le < Ze.length; le++) {
                  var Ir = Ze[le];
                  ae(V, Ir);
                }
              while (C = Object.getPrototypeOf(C));
              return V;
            }
            __name(Yr, "Yr");
            e.getAllKeys = Yr;
            function St(C) {
              var V = [];
              for (var ee in C)
                re.call(C, ee) && V.push(C[ee]);
              return V;
            }
            __name(St, "St");
            e.getOwnValues = St;
            var Dt = Object.entries || function(C) {
              for (var V = Nr(C), ee = Array(V.length), le = 0; le < V.length; le++)
                ee[le] = [V[le], C[V[le]]];
              return ee;
            };
            function Lt(C) {
              return C ? Dt(C) : [];
            }
            __name(Lt, "Lt");
            e.getEntries = Lt;
            function zt(C, V) {
              for (var ee = new Array(C), le = 0; le < C; le++)
                ee[le] = V(le);
              return ee;
            }
            __name(zt, "zt");
            e.arrayOf = zt;
            function Zt(C, V) {
              for (var ee = [], le = C.next(); !le.done; le = C.next())
                ee.push(V ? V(le.value) : le.value);
              return ee;
            }
            __name(Zt, "Zt");
            e.arrayFrom = Zt;
            function mt(C) {
              for (var V = [], ee = 1; ee < arguments.length; ee++)
                V[ee - 1] = arguments[ee];
              for (var le = 0, Ze = V; le < Ze.length; le++) {
                var Ir = Ze[le];
                if (Ir !== void 0)
                  for (var Ar in Ir)
                    de(Ir, Ar) && (C[Ar] = Ir[Ar]);
              }
              return C;
            }
            __name(mt, "mt");
            e.assign = mt;
            function at(C, V, ee) {
              if (ee === void 0 && (ee = On), C === V)
                return true;
              if (!C || !V)
                return false;
              for (var le in C)
                if (re.call(C, le) && (!re.call(V, le) || !ee(C[le], V[le])))
                  return false;
              for (var le in V)
                if (re.call(V, le) && !re.call(C, le))
                  return false;
              return true;
            }
            __name(at, "at");
            e.equalOwnProperties = at;
            function k(C, V, ee) {
              ee === void 0 && (ee = Dn);
              for (var le = new e.Map(), Ze = 0, Ir = C; Ze < Ir.length; Ze++) {
                var Ar = Ir[Ze], hr = V(Ar);
                hr !== void 0 && le.set(hr, ee(Ar));
              }
              return le;
            }
            __name(k, "k");
            e.arrayToMap = k;
            function ue(C, V, ee) {
              ee === void 0 && (ee = Dn);
              for (var le = [], Ze = 0, Ir = C; Ze < Ir.length; Ze++) {
                var Ar = Ir[Ze];
                le[V(Ar)] = ee(Ar);
              }
              return le;
            }
            __name(ue, "ue");
            e.arrayToNumericMap = ue;
            function Qe(C, V, ee) {
              ee === void 0 && (ee = Dn);
              for (var le = cn(), Ze = 0, Ir = C; Ze < Ir.length; Ze++) {
                var Ar = Ir[Ze];
                le.add(V(Ar), ee(Ar));
              }
              return le;
            }
            __name(Qe, "Qe");
            e.arrayToMultiMap = Qe;
            function Sr(C, V, ee) {
              return ee === void 0 && (ee = Dn), Zt(Qe(C, V).values(), ee);
            }
            __name(Sr, "Sr");
            e.group = Sr;
            function Kr(C) {
              var V = {};
              for (var ee in C)
                re.call(C, ee) && (V[ee] = C[ee]);
              return V;
            }
            __name(Kr, "Kr");
            e.clone = Kr;
            function Hr(C, V) {
              var ee = {};
              for (var le in V)
                re.call(V, le) && (ee[le] = V[le]);
              for (var le in C)
                re.call(C, le) && (ee[le] = C[le]);
              return ee;
            }
            __name(Hr, "Hr");
            e.extend = Hr;
            function Ct(C, V) {
              for (var ee in V)
                re.call(V, ee) && (C[ee] = V[ee]);
            }
            __name(Ct, "Ct");
            e.copyProperties = Ct;
            function Xt(C, V) {
              return V ? V.bind(C) : void 0;
            }
            __name(Xt, "Xt");
            e.maybeBind = Xt;
            function cn() {
              var C = new e.Map();
              return C.add = In, C.remove = yn, C;
            }
            __name(cn, "cn");
            e.createMultiMap = cn;
            function In(C, V) {
              var ee = this.get(C);
              return ee ? ee.push(V) : this.set(C, ee = [V]), ee;
            }
            __name(In, "In");
            function yn(C, V) {
              var ee = this.get(C);
              ee && (Rn(ee, V), ee.length || this.delete(C));
            }
            __name(yn, "yn");
            function hn() {
              return cn();
            }
            __name(hn, "hn");
            e.createUnderscoreEscapedMultiMap = hn;
            function ln(C) {
              var V = (C == null ? void 0 : C.slice()) || [], ee = 0;
              function le() {
                return ee === V.length;
              }
              __name(le, "le");
              function Ze() {
                for (var Ar = [], hr = 0; hr < arguments.length; hr++)
                  Ar[hr] = arguments[hr];
                V.push.apply(V, Ar);
              }
              __name(Ze, "Ze");
              function Ir() {
                if (le())
                  throw new Error("Queue is empty");
                var Ar = V[ee];
                if (V[ee] = void 0, ee++, ee > 100 && ee > V.length >> 1) {
                  var hr = V.length - ee;
                  V.copyWithin(0, ee), V.length = hr, ee = 0;
                }
                return Ar;
              }
              __name(Ir, "Ir");
              return { enqueue: Ze, dequeue: Ir, isEmpty: le };
            }
            __name(ln, "ln");
            e.createQueue = ln;
            function En(C, V) {
              var ee = new e.Map(), le = 0;
              function Ze() {
                var Ar = ee.values(), hr;
                return { next: function() {
                  for (; ; )
                    if (hr) {
                      var yt = hr.next();
                      if (!yt.done)
                        return { value: yt.value };
                      hr = void 0;
                    } else {
                      var yt = Ar.next();
                      if (yt.done)
                        return { value: void 0, done: true };
                      if (!Vt(yt.value))
                        return { value: yt.value };
                      hr = pt(yt.value);
                    }
                } };
              }
              __name(Ze, "Ze");
              var Ir = { has: function(Ar) {
                var hr = C(Ar);
                if (!ee.has(hr))
                  return false;
                var yt = ee.get(hr);
                if (!Vt(yt))
                  return V(yt, Ar);
                for (var Pt = 0, Ut = yt; Pt < Ut.length; Pt++) {
                  var jt = Ut[Pt];
                  if (V(jt, Ar))
                    return true;
                }
                return false;
              }, add: function(Ar) {
                var hr = C(Ar);
                if (ee.has(hr)) {
                  var yt = ee.get(hr);
                  if (Vt(yt))
                    m(yt, Ar, V) || (yt.push(Ar), le++);
                  else {
                    var Pt = yt;
                    V(Pt, Ar) || (ee.set(hr, [Pt, Ar]), le++);
                  }
                } else
                  ee.set(hr, Ar), le++;
                return this;
              }, delete: function(Ar) {
                var hr = C(Ar);
                if (!ee.has(hr))
                  return false;
                var yt = ee.get(hr);
                if (Vt(yt)) {
                  for (var Pt = 0; Pt < yt.length; Pt++)
                    if (V(yt[Pt], Ar))
                      return yt.length === 1 ? ee.delete(hr) : yt.length === 2 ? ee.set(hr, yt[1 - Pt]) : Mn(yt, Pt), le--, true;
                } else {
                  var Ut = yt;
                  if (V(Ut, Ar))
                    return ee.delete(hr), le--, true;
                }
                return false;
              }, clear: function() {
                ee.clear(), le = 0;
              }, get size() {
                return le;
              }, forEach: function(Ar) {
                for (var hr = 0, yt = Zt(ee.values()); hr < yt.length; hr++) {
                  var Pt = yt[hr];
                  if (Vt(Pt))
                    for (var Ut = 0, jt = Pt; Ut < jt.length; Ut++) {
                      var Ht = jt[Ut];
                      Ar(Ht, Ht);
                    }
                  else {
                    var Ht = Pt;
                    Ar(Ht, Ht);
                  }
                }
              }, keys: function() {
                return Ze();
              }, values: function() {
                return Ze();
              }, entries: function() {
                var Ar = Ze();
                return { next: function() {
                  var hr = Ar.next();
                  return hr.done ? hr : { value: [hr.value, hr.value] };
                } };
              } };
              return Ir;
            }
            __name(En, "En");
            e.createSet = En;
            function Vt(C) {
              return Array.isArray ? Array.isArray(C) : C instanceof Array;
            }
            __name(Vt, "Vt");
            e.isArray = Vt;
            function ui(C) {
              return Vt(C) ? C : [C];
            }
            __name(ui, "ui");
            e.toArray = ui;
            function ei(C) {
              return typeof C == "string";
            }
            __name(ei, "ei");
            e.isString = ei;
            function vi(C) {
              return typeof C == "number";
            }
            __name(vi, "vi");
            e.isNumber = vi;
            function ri(C, V) {
              return C !== void 0 && V(C) ? C : void 0;
            }
            __name(ri, "ri");
            e.tryCast = ri;
            function bi(C, V) {
              return C !== void 0 && V(C) ? C : e.Debug.fail("Invalid cast. The supplied value ".concat(C, " did not pass the test '").concat(e.Debug.getFunctionName(V), "'."));
            }
            __name(bi, "bi");
            e.cast = bi;
            function Qn(C) {
            }
            __name(Qn, "Qn");
            e.noop = Qn, e.noopPush = { push: Qn, length: 0 };
            function Yn() {
              return false;
            }
            __name(Yn, "Yn");
            e.returnFalse = Yn;
            function oi() {
              return true;
            }
            __name(oi, "oi");
            e.returnTrue = oi;
            function Ei() {
            }
            __name(Ei, "Ei");
            e.returnUndefined = Ei;
            function Dn(C) {
              return C;
            }
            __name(Dn, "Dn");
            e.identity = Dn;
            function Kn(C) {
              return C.toLowerCase();
            }
            __name(Kn, "Kn");
            e.toLowerCase = Kn;
            var si = /[^\u0130\u0131\u00DFa-z0-9\\/:\-_\. ]+/g;
            function mi(C) {
              return si.test(C) ? C.replace(si, Kn) : C;
            }
            __name(mi, "mi");
            e.toFileNameLowerCase = mi;
            function Zn() {
              throw new Error("Not implemented");
            }
            __name(Zn, "Zn");
            e.notImplemented = Zn;
            function Fn(C) {
              var V;
              return function() {
                return C && (V = C(), C = void 0), V;
              };
            }
            __name(Fn, "Fn");
            e.memoize = Fn;
            function gt(C) {
              var V = new e.Map();
              return function(ee) {
                var le = "".concat(typeof ee, ":").concat(ee), Ze = V.get(le);
                return Ze === void 0 && !V.has(le) && (Ze = C(ee), V.set(le, Ze)), Ze;
              };
            }
            __name(gt, "gt");
            e.memoizeOne = gt;
            function gi(C, V, ee, le, Ze) {
              if (Ze) {
                for (var Ir = [], Ar = 0; Ar < arguments.length; Ar++)
                  Ir[Ar] = arguments[Ar];
                return function(hr) {
                  return At(Ir, function(yt, Pt) {
                    return Pt(yt);
                  }, hr);
                };
              } else
                return le ? function(hr) {
                  return le(ee(V(C(hr))));
                } : ee ? function(hr) {
                  return ee(V(C(hr)));
                } : V ? function(hr) {
                  return V(C(hr));
                } : C ? function(hr) {
                  return C(hr);
                } : function(hr) {
                  return hr;
                };
            }
            __name(gi, "gi");
            e.compose = gi;
            var dn;
            (function(C) {
              C[C.None = 0] = "None", C[C.Normal = 1] = "Normal", C[C.Aggressive = 2] = "Aggressive", C[C.VeryAggressive = 3] = "VeryAggressive";
            })(dn = e.AssertionLevel || (e.AssertionLevel = {}));
            function On(C, V) {
              return C === V;
            }
            __name(On, "On");
            e.equateValues = On;
            function br(C, V) {
              return C === V || C !== void 0 && V !== void 0 && C.toUpperCase() === V.toUpperCase();
            }
            __name(br, "br");
            e.equateStringsCaseInsensitive = br;
            function Ae(C, V) {
              return On(C, V);
            }
            __name(Ae, "Ae");
            e.equateStringsCaseSensitive = Ae;
            function ur(C, V) {
              return C === V ? 0 : C === void 0 ? -1 : V === void 0 ? 1 : C < V ? -1 : 1;
            }
            __name(ur, "ur");
            function L(C, V) {
              return ur(C, V);
            }
            __name(L, "L");
            e.compareValues = L;
            function qt(C, V) {
              return L(C == null ? void 0 : C.start, V == null ? void 0 : V.start) || L(C == null ? void 0 : C.length, V == null ? void 0 : V.length);
            }
            __name(qt, "qt");
            e.compareTextSpans = qt;
            function nn(C, V) {
              return At(C, function(ee, le) {
                return V(ee, le) === -1 ? ee : le;
              });
            }
            __name(nn, "nn");
            e.min = nn;
            function fr(C, V) {
              return C === V ? 0 : C === void 0 ? -1 : V === void 0 ? 1 : (C = C.toUpperCase(), V = V.toUpperCase(), C < V ? -1 : C > V ? 1 : 0);
            }
            __name(fr, "fr");
            e.compareStringsCaseInsensitive = fr;
            function Me(C, V) {
              return ur(C, V);
            }
            __name(Me, "Me");
            e.compareStringsCaseSensitive = Me;
            function Ve(C) {
              return C ? fr : Me;
            }
            __name(Ve, "Ve");
            e.getStringComparer = Ve;
            var _r = function() {
              var C, V, ee = hr();
              return yt;
              function le(Pt, Ut, jt) {
                if (Pt === Ut)
                  return 0;
                if (Pt === void 0)
                  return -1;
                if (Ut === void 0)
                  return 1;
                var Ht = jt(Pt, Ut);
                return Ht < 0 ? -1 : Ht > 0 ? 1 : 0;
              }
              __name(le, "le");
              function Ze(Pt) {
                var Ut = new Intl.Collator(Pt, { usage: "sort", sensitivity: "variant" }).compare;
                return function(jt, Ht) {
                  return le(jt, Ht, Ut);
                };
              }
              __name(Ze, "Ze");
              function Ir(Pt) {
                if (Pt !== void 0)
                  return Ar();
                return function(jt, Ht) {
                  return le(jt, Ht, Ut);
                };
                function Ut(jt, Ht) {
                  return jt.localeCompare(Ht);
                }
                __name(Ut, "Ut");
              }
              __name(Ir, "Ir");
              function Ar() {
                return function(jt, Ht) {
                  return le(jt, Ht, Pt);
                };
                function Pt(jt, Ht) {
                  return Ut(jt.toUpperCase(), Ht.toUpperCase()) || Ut(jt, Ht);
                }
                __name(Pt, "Pt");
                function Ut(jt, Ht) {
                  return jt < Ht ? -1 : jt > Ht ? 1 : 0;
                }
                __name(Ut, "Ut");
              }
              __name(Ar, "Ar");
              function hr() {
                return typeof Intl == "object" && typeof Intl.Collator == "function" ? Ze : typeof String.prototype.localeCompare == "function" && typeof String.prototype.toLocaleUpperCase == "function" && "a".localeCompare("B") < 0 ? Ir : Ar;
              }
              __name(hr, "hr");
              function yt(Pt) {
                return Pt === void 0 ? C || (C = ee(Pt)) : Pt === "en-US" ? V || (V = ee(Pt)) : ee(Pt);
              }
              __name(yt, "yt");
            }(), lr, Vr;
            function tt() {
              return Vr;
            }
            __name(tt, "tt");
            e.getUILocale = tt;
            function dt(C) {
              Vr !== C && (Vr = C, lr = void 0);
            }
            __name(dt, "dt");
            e.setUILocale = dt;
            function It(C, V) {
              var ee = lr || (lr = _r(Vr));
              return ee(C, V);
            }
            __name(It, "It");
            e.compareStringsCaseSensitiveUI = It;
            function an(C, V, ee, le) {
              return C === V ? 0 : C === void 0 ? -1 : V === void 0 ? 1 : le(C[ee], V[ee]);
            }
            __name(an, "an");
            e.compareProperties = an;
            function sn(C, V) {
              return L(C ? 1 : 0, V ? 1 : 0);
            }
            __name(sn, "sn");
            e.compareBooleans = sn;
            function _e(C, V, ee) {
              for (var le = Math.max(2, Math.floor(C.length * 0.34)), Ze = Math.floor(C.length * 0.4) + 1, Ir, Ar = 0, hr = V; Ar < hr.length; Ar++) {
                var yt = hr[Ar], Pt = ee(yt);
                if (Pt !== void 0 && Math.abs(Pt.length - C.length) <= le) {
                  if (Pt === C || Pt.length < 3 && Pt.toLowerCase() !== C.toLowerCase())
                    continue;
                  var Ut = Gr(C, Pt, Ze - 0.1);
                  if (Ut === void 0)
                    continue;
                  e.Debug.assert(Ut < Ze), Ze = Ut, Ir = yt;
                }
              }
              return Ir;
            }
            __name(_e, "_e");
            e.getSpellingSuggestion = _e;
            function Gr(C, V, ee) {
              for (var le = new Array(V.length + 1), Ze = new Array(V.length + 1), Ir = ee + 0.01, Ar = 0; Ar <= V.length; Ar++)
                le[Ar] = Ar;
              for (var Ar = 1; Ar <= C.length; Ar++) {
                var hr = C.charCodeAt(Ar - 1), yt = Math.ceil(Ar > ee ? Ar - ee : 1), Pt = Math.floor(V.length > ee + Ar ? ee + Ar : V.length);
                Ze[0] = Ar;
                for (var Ut = Ar, jt = 1; jt < yt; jt++)
                  Ze[jt] = Ir;
                for (var jt = yt; jt <= Pt; jt++) {
                  var Ht = C[Ar - 1].toLowerCase() === V[jt - 1].toLowerCase() ? le[jt - 1] + 0.1 : le[jt - 1] + 2, yi = hr === V.charCodeAt(jt - 1) ? le[jt - 1] : Math.min(le[jt] + 1, Ze[jt - 1] + 1, Ht);
                  Ze[jt] = yi, Ut = Math.min(Ut, yi);
                }
                for (var jt = Pt + 1; jt <= V.length; jt++)
                  Ze[jt] = Ir;
                if (Ut > ee)
                  return;
                var Ni = le;
                le = Ze, Ze = Ni;
              }
              var Gn = le[V.length];
              return Gn > ee ? void 0 : Gn;
            }
            __name(Gr, "Gr");
            function Kt(C, V) {
              var ee = C.length - V.length;
              return ee >= 0 && C.indexOf(V, ee) === ee;
            }
            __name(Kt, "Kt");
            e.endsWith = Kt;
            function en(C, V) {
              return Kt(C, V) ? C.slice(0, C.length - V.length) : C;
            }
            __name(en, "en");
            e.removeSuffix = en;
            function Ot(C, V) {
              return Kt(C, V) ? C.slice(0, C.length - V.length) : void 0;
            }
            __name(Ot, "Ot");
            e.tryRemoveSuffix = Ot;
            function rr(C, V) {
              return C.indexOf(V) !== -1;
            }
            __name(rr, "rr");
            e.stringContains = rr;
            function Hn(C) {
              for (var V = C.length, ee = V - 1; ee > 0; ee--) {
                var le = C.charCodeAt(ee);
                if (le >= 48 && le <= 57)
                  do
                    --ee, le = C.charCodeAt(ee);
                  while (ee > 0 && le >= 48 && le <= 57);
                else if (ee > 4 && (le === 110 || le === 78)) {
                  if (--ee, le = C.charCodeAt(ee), le !== 105 && le !== 73 || (--ee, le = C.charCodeAt(ee), le !== 109 && le !== 77))
                    break;
                  --ee, le = C.charCodeAt(ee);
                } else
                  break;
                if (le !== 45 && le !== 46)
                  break;
                V = ee;
              }
              return V === C.length ? C : C.slice(0, V);
            }
            __name(Hn, "Hn");
            e.removeMinAndVersionNumbers = Hn;
            function rn(C, V) {
              for (var ee = 0; ee < C.length; ee++)
                if (C[ee] === V)
                  return xn(C, ee), true;
              return false;
            }
            __name(rn, "rn");
            e.orderedRemoveItem = rn;
            function xn(C, V) {
              for (var ee = V; ee < C.length - 1; ee++)
                C[ee] = C[ee + 1];
              C.pop();
            }
            __name(xn, "xn");
            e.orderedRemoveItemAt = xn;
            function Mn(C, V) {
              C[V] = C[C.length - 1], C.pop();
            }
            __name(Mn, "Mn");
            e.unorderedRemoveItemAt = Mn;
            function Rn(C, V) {
              return kn(C, function(ee) {
                return ee === V;
              });
            }
            __name(Rn, "Rn");
            e.unorderedRemoveItem = Rn;
            function kn(C, V) {
              for (var ee = 0; ee < C.length; ee++)
                if (V(C[ee]))
                  return Mn(C, ee), true;
              return false;
            }
            __name(kn, "kn");
            function on(C) {
              return C ? Dn : mi;
            }
            __name(on, "on");
            e.createGetCanonicalFileName = on;
            function Xr(C) {
              var V = C.prefix, ee = C.suffix;
              return "".concat(V, "*").concat(ee);
            }
            __name(Xr, "Xr");
            e.patternText = Xr;
            function wr(C, V) {
              return e.Debug.assert(wi(C, V)), V.substring(C.prefix.length, V.length - C.suffix.length);
            }
            __name(wr, "wr");
            e.matchedText = wr;
            function fn(C, V, ee) {
              for (var le, Ze = -1, Ir = 0, Ar = C; Ir < Ar.length; Ir++) {
                var hr = Ar[Ir], yt = V(hr);
                wi(yt, ee) && yt.prefix.length > Ze && (Ze = yt.prefix.length, le = hr);
              }
              return le;
            }
            __name(fn, "fn");
            e.findBestPatternMatch = fn;
            function mn(C, V) {
              return C.lastIndexOf(V, 0) === 0;
            }
            __name(mn, "mn");
            e.startsWith = mn;
            function Li(C, V) {
              return mn(C, V) ? C.substr(V.length) : C;
            }
            __name(Li, "Li");
            e.removePrefix = Li;
            function An(C, V, ee) {
              return ee === void 0 && (ee = Dn), mn(ee(C), ee(V)) ? C.substring(V.length) : void 0;
            }
            __name(An, "An");
            e.tryRemovePrefix = An;
            function wi(C, V) {
              var ee = C.prefix, le = C.suffix;
              return V.length >= ee.length + le.length && mn(V, ee) && Kt(V, le);
            }
            __name(wi, "wi");
            e.isPatternMatch = wi;
            function ti(C, V) {
              return function(ee) {
                return C(ee) && V(ee);
              };
            }
            __name(ti, "ti");
            e.and = ti;
            function li() {
              for (var C = [], V = 0; V < arguments.length; V++)
                C[V] = arguments[V];
              return function() {
                for (var ee = [], le = 0; le < arguments.length; le++)
                  ee[le] = arguments[le];
                for (var Ze, Ir = 0, Ar = C; Ir < Ar.length; Ir++) {
                  var hr = Ar[Ir];
                  if (Ze = hr.apply(void 0, ee), Ze)
                    return Ze;
                }
                return Ze;
              };
            }
            __name(li, "li");
            e.or = li;
            function Bn(C) {
              return function() {
                for (var V = [], ee = 0; ee < arguments.length; ee++)
                  V[ee] = arguments[ee];
                return !C.apply(void 0, V);
              };
            }
            __name(Bn, "Bn");
            e.not = Bn;
            function vn(C) {
            }
            __name(vn, "vn");
            e.assertType = vn;
            function Ue(C) {
              return C === void 0 ? void 0 : [C];
            }
            __name(Ue, "Ue");
            e.singleElementArray = Ue;
            function Vn(C, V, ee, le, Ze, Ir) {
              Ir = Ir || Qn;
              for (var Ar = 0, hr = 0, yt = C.length, Pt = V.length, Ut = false; Ar < yt && hr < Pt; ) {
                var jt = C[Ar], Ht = V[hr], yi = ee(jt, Ht);
                yi === -1 ? (le(jt), Ar++, Ut = true) : yi === 1 ? (Ze(Ht), hr++, Ut = true) : (Ir(Ht, jt), Ar++, hr++);
              }
              for (; Ar < yt; )
                le(C[Ar++]), Ut = true;
              for (; hr < Pt; )
                Ze(V[hr++]), Ut = true;
              return Ut;
            }
            __name(Vn, "Vn");
            e.enumerateInsertsAndDeletes = Vn;
            function Ti(C, V) {
              for (var ee = Array(C), le = 0; le < C; le++)
                ee[le] = V(le);
              return ee;
            }
            __name(Ti, "Ti");
            e.fill = Ti;
            function ni(C) {
              var V = [];
              return Bi(C, V, void 0, 0), V;
            }
            __name(ni, "ni");
            e.cartesianProduct = ni;
            function Bi(C, V, ee, le) {
              for (var Ze = 0, Ir = C[le]; Ze < Ir.length; Ze++) {
                var Ar = Ir[Ze], hr = void 0;
                ee ? (hr = ee.slice(), hr.push(Ar)) : hr = [Ar], le === C.length - 1 ? V.push(hr) : Bi(C, V, hr, le + 1);
              }
            }
            __name(Bi, "Bi");
            function Tn(C, V, ee) {
              return ee === void 0 && (ee = " "), V <= C.length ? C : ee.repeat(V - C.length) + C;
            }
            __name(Tn, "Tn");
            e.padLeft = Tn;
            function jn(C, V, ee) {
              return ee === void 0 && (ee = " "), V <= C.length ? C : C + ee.repeat(V - C.length);
            }
            __name(jn, "jn");
            e.padRight = jn;
            function Si(C, V) {
              for (var ee = C.length, le = 0; le < ee && V(C[le]); )
                le++;
              return C.slice(0, le);
            }
            __name(Si, "Si");
            e.takeWhile = Si, e.trimString = String.prototype.trim ? function(C) {
              return C.trim();
            } : function(C) {
              return e.trimStringEnd(e.trimStringStart(C));
            }, e.trimStringEnd = String.prototype.trimEnd ? function(C) {
              return C.trimEnd();
            } : Ci, e.trimStringStart = String.prototype.trimStart ? function(C) {
              return C.trimStart();
            } : function(C) {
              return C.replace(/^\s+/g, "");
            };
            function Ci(C) {
              for (var V = C.length - 1; V >= 0 && e.isWhiteSpaceLike(C.charCodeAt(V)); )
                V--;
              return C.slice(0, V + 1);
            }
            __name(Ci, "Ci");
          })(N || (N = {}));
          var N;
          (function(e) {
            var t;
            (function(s) {
              s[s.Off = 0] = "Off", s[s.Error = 1] = "Error", s[s.Warning = 2] = "Warning", s[s.Info = 3] = "Info", s[s.Verbose = 4] = "Verbose";
            })(t = e.LogLevel || (e.LogLevel = {}));
            var x;
            (function(s) {
              var q, F = 0;
              s.currentLogLevel = t.Warning, s.isDebugging = false, s.enableDeprecationWarnings = true;
              function fe() {
                return q != null ? q : q = new e.Version(e.version);
              }
              __name(fe, "fe");
              s.getTypeScriptVersion = fe;
              function Te(me) {
                return s.currentLogLevel <= me;
              }
              __name(Te, "Te");
              s.shouldLog = Te;
              function Se(me, xe) {
                s.loggingHost && Te(me) && s.loggingHost.log(me, xe);
              }
              __name(Se, "Se");
              function J(me) {
                Se(t.Info, me);
              }
              __name(J, "J");
              s.log = J, function(me) {
                function xe(pr) {
                  Se(t.Error, pr);
                }
                __name(xe, "xe");
                me.error = xe;
                function Ye(pr) {
                  Se(t.Warning, pr);
                }
                __name(Ye, "Ye");
                me.warn = Ye;
                function vr(pr) {
                  Se(t.Info, pr);
                }
                __name(vr, "vr");
                me.log = vr;
                function nt(pr) {
                  Se(t.Verbose, pr);
                }
                __name(nt, "nt");
                me.trace = nt;
              }(J = s.log || (s.log = {}));
              var se = {};
              function Le() {
                return F;
              }
              __name(Le, "Le");
              s.getAssertionLevel = Le;
              function Q(me) {
                var xe = F;
                if (F = me, me > xe)
                  for (var Ye = 0, vr = e.getOwnKeys(se); Ye < vr.length; Ye++) {
                    var nt = vr[Ye], pr = se[nt];
                    pr !== void 0 && s[nt] !== pr.assertion && me >= pr.level && (s[nt] = pr, se[nt] = void 0);
                  }
              }
              __name(Q, "Q");
              s.setAssertionLevel = Q;
              function Be(me) {
                return F >= me;
              }
              __name(Be, "Be");
              s.shouldAssert = Be;
              function je(me, xe) {
                return Be(me) ? true : (se[xe] = { level: me, assertion: s[xe] }, s[xe] = e.noop, false);
              }
              __name(je, "je");
              function W(me, xe) {
                debugger;
                var Ye = new Error(me ? "Debug Failure. ".concat(me) : "Debug Failure.");
                throw Error.captureStackTrace && Error.captureStackTrace(Ye, xe || W), Ye;
              }
              __name(W, "W");
              s.fail = W;
              function B(me, xe, Ye) {
                return W("".concat(xe || "Unexpected node.", `\r
Node `).concat(ar(me.kind), " was unexpected."), Ye || B);
              }
              __name(B, "B");
              s.failBadSyntaxKind = B;
              function U(me, xe, Ye, vr) {
                me || (xe = xe ? "False expression: ".concat(xe) : "False expression.", Ye && (xe += `\r
Verbose Debug Information: ` + (typeof Ye == "string" ? Ye : Ye())), W(xe, vr || U));
              }
              __name(U, "U");
              s.assert = U;
              function m(me, xe, Ye, vr, nt) {
                if (me !== xe) {
                  var pr = Ye ? vr ? "".concat(Ye, " ").concat(vr) : Ye : "";
                  W("Expected ".concat(me, " === ").concat(xe, ". ").concat(pr), nt || m);
                }
              }
              __name(m, "m");
              s.assertEqual = m;
              function v(me, xe, Ye, vr) {
                me >= xe && W("Expected ".concat(me, " < ").concat(xe, ". ").concat(Ye || ""), vr || v);
              }
              __name(v, "v");
              s.assertLessThan = v;
              function g(me, xe, Ye) {
                me > xe && W("Expected ".concat(me, " <= ").concat(xe), Ye || g);
              }
              __name(g, "g");
              s.assertLessThanOrEqual = g;
              function O(me, xe, Ye) {
                me < xe && W("Expected ".concat(me, " >= ").concat(xe), Ye || O);
              }
              __name(O, "O");
              s.assertGreaterThanOrEqual = O;
              function S(me, xe, Ye) {
                me == null && W(xe, Ye || S);
              }
              __name(S, "S");
              s.assertIsDefined = S;
              function te(me, xe, Ye) {
                return S(me, xe, Ye || te), me;
              }
              __name(te, "te");
              s.checkDefined = te;
              function Je(me, xe, Ye) {
                for (var vr = 0, nt = me; vr < nt.length; vr++) {
                  var pr = nt[vr];
                  S(pr, xe, Ye || Je);
                }
              }
              __name(Je, "Je");
              s.assertEachIsDefined = Je;
              function qe(me, xe, Ye) {
                return Je(me, xe, Ye || qe), me;
              }
              __name(qe, "qe");
              s.checkEachDefined = qe;
              function ge(me, xe, Ye) {
                xe === void 0 && (xe = "Illegal value:");
                var vr = typeof me == "object" && e.hasProperty(me, "kind") && e.hasProperty(me, "pos") ? "SyntaxKind: " + ar(me.kind) : JSON.stringify(me);
                return W("".concat(xe, " ").concat(vr), Ye || ge);
              }
              __name(ge, "ge");
              s.assertNever = ge;
              function ie(me, xe, Ye, vr) {
                je(1, "assertEachNode") && U(xe === void 0 || e.every(me, xe), Ye || "Unexpected node.", function() {
                  return "Node array did not pass test '".concat(Fe(xe), "'.");
                }, vr || ie);
              }
              __name(ie, "ie");
              s.assertEachNode = ie;
              function G(me, xe, Ye, vr) {
                je(1, "assertNode") && U(me !== void 0 && (xe === void 0 || xe(me)), Ye || "Unexpected node.", function() {
                  return "Node ".concat(ar(me == null ? void 0 : me.kind), " did not pass test '").concat(Fe(xe), "'.");
                }, vr || G);
              }
              __name(G, "G");
              s.assertNode = G;
              function pe(me, xe, Ye, vr) {
                je(1, "assertNotNode") && U(me === void 0 || xe === void 0 || !xe(me), Ye || "Unexpected node.", function() {
                  return "Node ".concat(ar(me.kind), " should not have passed test '").concat(Fe(xe), "'.");
                }, vr || pe);
              }
              __name(pe, "pe");
              s.assertNotNode = pe;
              function j(me, xe, Ye, vr) {
                je(1, "assertOptionalNode") && U(xe === void 0 || me === void 0 || xe(me), Ye || "Unexpected node.", function() {
                  return "Node ".concat(ar(me == null ? void 0 : me.kind), " did not pass test '").concat(Fe(xe), "'.");
                }, vr || j);
              }
              __name(j, "j");
              s.assertOptionalNode = j;
              function be(me, xe, Ye, vr) {
                je(1, "assertOptionalToken") && U(xe === void 0 || me === void 0 || me.kind === xe, Ye || "Unexpected node.", function() {
                  return "Node ".concat(ar(me == null ? void 0 : me.kind), " was not a '").concat(ar(xe), "' token.");
                }, vr || be);
              }
              __name(be, "be");
              s.assertOptionalToken = be;
              function $e(me, xe, Ye) {
                je(1, "assertMissingNode") && U(me === void 0, xe || "Unexpected node.", function() {
                  return "Node ".concat(ar(me.kind), " was unexpected'.");
                }, Ye || $e);
              }
              __name($e, "$e");
              s.assertMissingNode = $e;
              function Re(me) {
              }
              __name(Re, "Re");
              s.type = Re;
              function Fe(me) {
                if (typeof me != "function")
                  return "";
                if (e.hasProperty(me, "name"))
                  return me.name;
                var xe = Function.prototype.toString.call(me), Ye = /^function\s+([\w\$]+)\s*\(/.exec(xe);
                return Ye ? Ye[1] : "";
              }
              __name(Fe, "Fe");
              s.getFunctionName = Fe;
              function dr(me) {
                return "{ name: ".concat(e.unescapeLeadingUnderscores(me.escapedName), "; flags: ").concat(Ee(me.flags), "; declarations: ").concat(e.map(me.declarations, function(xe) {
                  return ar(xe.kind);
                }), " }");
              }
              __name(dr, "dr");
              s.formatSymbol = dr;
              function ze(me, xe, Ye) {
                me === void 0 && (me = 0);
                var vr = er(xe);
                if (me === 0)
                  return vr.length > 0 && vr[0][0] === 0 ? vr[0][1] : "0";
                if (Ye) {
                  for (var nt = [], pr = me, Mr = 0, ot = vr; Mr < ot.length; Mr++) {
                    var At = ot[Mr], re = At[0], de = At[1];
                    if (re > me)
                      break;
                    re !== 0 && re & me && (nt.push(de), pr &= ~re);
                  }
                  if (pr === 0)
                    return nt.join("|");
                } else
                  for (var He = 0, Nr = vr; He < Nr.length; He++) {
                    var Yr = Nr[He], re = Yr[0], de = Yr[1];
                    if (re === me)
                      return de;
                  }
                return me.toString();
              }
              __name(ze, "ze");
              s.formatEnum = ze;
              var ve = new e.Map();
              function er(me) {
                var xe = ve.get(me);
                if (xe)
                  return xe;
                var Ye = [];
                for (var vr in me) {
                  var nt = me[vr];
                  typeof nt == "number" && Ye.push([nt, vr]);
                }
                var pr = e.stableSort(Ye, function(Mr, ot) {
                  return e.compareValues(Mr[0], ot[0]);
                });
                return ve.set(me, pr), pr;
              }
              __name(er, "er");
              function ar(me) {
                return ze(me, e.SyntaxKind, false);
              }
              __name(ar, "ar");
              s.formatSyntaxKind = ar;
              function Cr(me) {
                return ze(me, e.SnippetKind, false);
              }
              __name(Cr, "Cr");
              s.formatSnippetKind = Cr;
              function Ce(me) {
                return ze(me, e.NodeFlags, true);
              }
              __name(Ce, "Ce");
              s.formatNodeFlags = Ce;
              function Xe(me) {
                return ze(me, e.ModifierFlags, true);
              }
              __name(Xe, "Xe");
              s.formatModifierFlags = Xe;
              function gr(me) {
                return ze(me, e.TransformFlags, true);
              }
              __name(gr, "gr");
              s.formatTransformFlags = gr;
              function X(me) {
                return ze(me, e.EmitFlags, true);
              }
              __name(X, "X");
              s.formatEmitFlags = X;
              function Ee(me) {
                return ze(me, e.SymbolFlags, true);
              }
              __name(Ee, "Ee");
              s.formatSymbolFlags = Ee;
              function we(me) {
                return ze(me, e.TypeFlags, true);
              }
              __name(we, "we");
              s.formatTypeFlags = we;
              function he(me) {
                return ze(me, e.SignatureFlags, true);
              }
              __name(he, "he");
              s.formatSignatureFlags = he;
              function yr(me) {
                return ze(me, e.ObjectFlags, true);
              }
              __name(yr, "yr");
              s.formatObjectFlags = yr;
              function kr(me) {
                return ze(me, e.FlowFlags, true);
              }
              __name(kr, "kr");
              s.formatFlowFlags = kr;
              function nr(me) {
                return ze(me, e.RelationComparisonResult, true);
              }
              __name(nr, "nr");
              s.formatRelationComparisonResult = nr;
              function tr(me) {
                return ze(me, e.CheckMode, true);
              }
              __name(tr, "tr");
              s.formatCheckMode = tr;
              function Lr(me) {
                return ze(me, e.SignatureCheckMode, true);
              }
              __name(Lr, "Lr");
              s.formatSignatureCheckMode = Lr;
              function zr(me) {
                return ze(me, e.TypeFacts, true);
              }
              __name(zr, "zr");
              s.formatTypeFacts = zr;
              var ye = false, ir;
              function Dr() {
                if (xr(), !ir)
                  throw new Error("Debugging helpers could not be loaded.");
                return ir;
              }
              __name(Dr, "Dr");
              function Pr(me) {
                return console.log(Br(me));
              }
              __name(Pr, "Pr");
              s.printControlFlowGraph = Pr;
              function Br(me) {
                return Dr().formatControlFlowGraph(me);
              }
              __name(Br, "Br");
              s.formatControlFlowGraph = Br;
              var ut;
              function rt(me) {
                "__debugFlowFlags" in me || Object.defineProperties(me, { __tsDebuggerDisplay: { value: function() {
                  var xe = this.flags & 2 ? "FlowStart" : this.flags & 4 ? "FlowBranchLabel" : this.flags & 8 ? "FlowLoopLabel" : this.flags & 16 ? "FlowAssignment" : this.flags & 32 ? "FlowTrueCondition" : this.flags & 64 ? "FlowFalseCondition" : this.flags & 128 ? "FlowSwitchClause" : this.flags & 256 ? "FlowArrayMutation" : this.flags & 512 ? "FlowCall" : this.flags & 1024 ? "FlowReduceLabel" : this.flags & 1 ? "FlowUnreachable" : "UnknownFlow", Ye = this.flags & ~(2048 - 1);
                  return "".concat(xe).concat(Ye ? " (".concat(kr(Ye), ")") : "");
                } }, __debugFlowFlags: { get: function() {
                  return ze(this.flags, e.FlowFlags, true);
                } }, __debugToString: { value: function() {
                  return Br(this);
                } } });
              }
              __name(rt, "rt");
              function Z(me) {
                ye && (typeof Object.setPrototypeOf == "function" ? (ut || (ut = Object.create(Object.prototype), rt(ut)), Object.setPrototypeOf(me, ut)) : rt(me));
              }
              __name(Z, "Z");
              s.attachFlowNodeDebugInfo = Z;
              var f;
              function h(me) {
                "__tsDebuggerDisplay" in me || Object.defineProperties(me, { __tsDebuggerDisplay: { value: function(xe) {
                  return xe = String(xe).replace(/(?:,[\s\w\d_]+:[^,]+)+\]$/, "]"), "NodeArray ".concat(xe);
                } } });
              }
              __name(h, "h");
              function ae(me) {
                ye && (typeof Object.setPrototypeOf == "function" ? (f || (f = Object.create(Array.prototype), h(f)), Object.setPrototypeOf(me, f)) : h(me));
              }
              __name(ae, "ae");
              s.attachNodeArrayDebugInfo = ae;
              function xr() {
                if (ye)
                  return;
                var me, xe;
                function Ye() {
                  return me === void 0 && typeof WeakMap == "function" && (me = /* @__PURE__ */ new WeakMap()), me;
                }
                __name(Ye, "Ye");
                function vr() {
                  return xe === void 0 && typeof WeakMap == "function" && (xe = /* @__PURE__ */ new WeakMap()), xe;
                }
                __name(vr, "vr");
                Object.defineProperties(e.objectAllocator.getSymbolConstructor().prototype, { __tsDebuggerDisplay: { value: function() {
                  var de = this.flags & 33554432 ? "TransientSymbol" : "Symbol", He = this.flags & -33554433;
                  return "".concat(de, " '").concat(e.symbolName(this), "'").concat(He ? " (".concat(Ee(He), ")") : "");
                } }, __debugFlags: { get: function() {
                  return Ee(this.flags);
                } } }), Object.defineProperties(e.objectAllocator.getTypeConstructor().prototype, { __tsDebuggerDisplay: { value: function() {
                  var de = this.flags & 98304 ? "NullableType" : this.flags & 384 ? "LiteralType ".concat(JSON.stringify(this.value)) : this.flags & 2048 ? "LiteralType ".concat(this.value.negative ? "-" : "").concat(this.value.base10Value, "n") : this.flags & 8192 ? "UniqueESSymbolType" : this.flags & 32 ? "EnumType" : this.flags & 67359327 ? "IntrinsicType ".concat(this.intrinsicName) : this.flags & 1048576 ? "UnionType" : this.flags & 2097152 ? "IntersectionType" : this.flags & 4194304 ? "IndexType" : this.flags & 8388608 ? "IndexedAccessType" : this.flags & 16777216 ? "ConditionalType" : this.flags & 33554432 ? "SubstitutionType" : this.flags & 262144 ? "TypeParameter" : this.flags & 524288 ? this.objectFlags & 3 ? "InterfaceType" : this.objectFlags & 4 ? "TypeReference" : this.objectFlags & 8 ? "TupleType" : this.objectFlags & 16 ? "AnonymousType" : this.objectFlags & 32 ? "MappedType" : this.objectFlags & 1024 ? "ReverseMappedType" : this.objectFlags & 256 ? "EvolvingArrayType" : "ObjectType" : "Type", He = this.flags & 524288 ? this.objectFlags & -1344 : 0;
                  return "".concat(de).concat(this.symbol ? " '".concat(e.symbolName(this.symbol), "'") : "").concat(He ? " (".concat(yr(He), ")") : "");
                } }, __debugFlags: { get: function() {
                  return we(this.flags);
                } }, __debugObjectFlags: { get: function() {
                  return this.flags & 524288 ? yr(this.objectFlags) : "";
                } }, __debugTypeToString: { value: function() {
                  var de = Ye(), He = de == null ? void 0 : de.get(this);
                  return He === void 0 && (He = this.checker.typeToString(this), de == null || de.set(this, He)), He;
                } } }), Object.defineProperties(e.objectAllocator.getSignatureConstructor().prototype, { __debugFlags: { get: function() {
                  return he(this.flags);
                } }, __debugSignatureToString: { value: function() {
                  var de;
                  return (de = this.checker) === null || de === void 0 ? void 0 : de.signatureToString(this);
                } } });
                for (var nt = [e.objectAllocator.getNodeConstructor(), e.objectAllocator.getIdentifierConstructor(), e.objectAllocator.getTokenConstructor(), e.objectAllocator.getSourceFileConstructor()], pr = 0, Mr = nt; pr < Mr.length; pr++) {
                  var ot = Mr[pr];
                  e.hasProperty(ot.prototype, "__debugKind") || Object.defineProperties(ot.prototype, { __tsDebuggerDisplay: { value: function() {
                    var de = e.isGeneratedIdentifier(this) ? "GeneratedIdentifier" : e.isIdentifier(this) ? "Identifier '".concat(e.idText(this), "'") : e.isPrivateIdentifier(this) ? "PrivateIdentifier '".concat(e.idText(this), "'") : e.isStringLiteral(this) ? "StringLiteral ".concat(JSON.stringify(this.text.length < 10 ? this.text : this.text.slice(10) + "...")) : e.isNumericLiteral(this) ? "NumericLiteral ".concat(this.text) : e.isBigIntLiteral(this) ? "BigIntLiteral ".concat(this.text, "n") : e.isTypeParameterDeclaration(this) ? "TypeParameterDeclaration" : e.isParameter(this) ? "ParameterDeclaration" : e.isConstructorDeclaration(this) ? "ConstructorDeclaration" : e.isGetAccessorDeclaration(this) ? "GetAccessorDeclaration" : e.isSetAccessorDeclaration(this) ? "SetAccessorDeclaration" : e.isCallSignatureDeclaration(this) ? "CallSignatureDeclaration" : e.isConstructSignatureDeclaration(this) ? "ConstructSignatureDeclaration" : e.isIndexSignatureDeclaration(this) ? "IndexSignatureDeclaration" : e.isTypePredicateNode(this) ? "TypePredicateNode" : e.isTypeReferenceNode(this) ? "TypeReferenceNode" : e.isFunctionTypeNode(this) ? "FunctionTypeNode" : e.isConstructorTypeNode(this) ? "ConstructorTypeNode" : e.isTypeQueryNode(this) ? "TypeQueryNode" : e.isTypeLiteralNode(this) ? "TypeLiteralNode" : e.isArrayTypeNode(this) ? "ArrayTypeNode" : e.isTupleTypeNode(this) ? "TupleTypeNode" : e.isOptionalTypeNode(this) ? "OptionalTypeNode" : e.isRestTypeNode(this) ? "RestTypeNode" : e.isUnionTypeNode(this) ? "UnionTypeNode" : e.isIntersectionTypeNode(this) ? "IntersectionTypeNode" : e.isConditionalTypeNode(this) ? "ConditionalTypeNode" : e.isInferTypeNode(this) ? "InferTypeNode" : e.isParenthesizedTypeNode(this) ? "ParenthesizedTypeNode" : e.isThisTypeNode(this) ? "ThisTypeNode" : e.isTypeOperatorNode(this) ? "TypeOperatorNode" : e.isIndexedAccessTypeNode(this) ? "IndexedAccessTypeNode" : e.isMappedTypeNode(this) ? "MappedTypeNode" : e.isLiteralTypeNode(this) ? "LiteralTypeNode" : e.isNamedTupleMember(this) ? "NamedTupleMember" : e.isImportTypeNode(this) ? "ImportTypeNode" : ar(this.kind);
                    return "".concat(de).concat(this.flags ? " (".concat(Ce(this.flags), ")") : "");
                  } }, __debugKind: { get: function() {
                    return ar(this.kind);
                  } }, __debugNodeFlags: { get: function() {
                    return Ce(this.flags);
                  } }, __debugModifierFlags: { get: function() {
                    return Xe(e.getEffectiveModifierFlagsNoCache(this));
                  } }, __debugTransformFlags: { get: function() {
                    return gr(this.transformFlags);
                  } }, __debugIsParseTreeNode: { get: function() {
                    return e.isParseTreeNode(this);
                  } }, __debugEmitFlags: { get: function() {
                    return X(e.getEmitFlags(this));
                  } }, __debugGetText: { value: function(de) {
                    if (e.nodeIsSynthesized(this))
                      return "";
                    var He = vr(), Nr = He == null ? void 0 : He.get(this);
                    if (Nr === void 0) {
                      var Yr = e.getParseTreeNode(this), St = Yr && e.getSourceFileOfNode(Yr);
                      Nr = St ? e.getSourceTextOfNodeFromSourceFile(St, Yr, de) : "", He == null || He.set(this, Nr);
                    }
                    return Nr;
                  } } });
                }
                try {
                  if (false)
                    var At, re;
                } catch {
                }
                ye = true;
              }
              __name(xr, "xr");
              s.enableDebugInfo = xr;
              function jr(me, xe, Ye, vr, nt) {
                var pr = xe ? "DeprecationError: " : "DeprecationWarning: ";
                return pr += "'".concat(me, "' "), pr += vr ? "has been deprecated since v".concat(vr) : "is deprecated", pr += xe ? " and can no longer be used." : Ye ? " and will no longer be usable after v".concat(Ye, ".") : ".", pr += nt ? " ".concat(e.formatStringFromArgs(nt, [me], 0)) : "", pr;
              }
              __name(jr, "jr");
              function qr(me, xe, Ye, vr) {
                var nt = jr(me, true, xe, Ye, vr);
                return function() {
                  throw new TypeError(nt);
                };
              }
              __name(qr, "qr");
              function pt(me, xe, Ye, vr) {
                var nt = false;
                return function() {
                  s.enableDeprecationWarnings && !nt && (J.warn(jr(me, false, xe, Ye, vr)), nt = true);
                };
              }
              __name(pt, "pt");
              function Ge(me, xe) {
                var Ye, vr;
                xe === void 0 && (xe = {});
                var nt = typeof xe.typeScriptVersion == "string" ? new e.Version(xe.typeScriptVersion) : (Ye = xe.typeScriptVersion) !== null && Ye !== void 0 ? Ye : fe(), pr = typeof xe.errorAfter == "string" ? new e.Version(xe.errorAfter) : xe.errorAfter, Mr = typeof xe.warnAfter == "string" ? new e.Version(xe.warnAfter) : xe.warnAfter, ot = typeof xe.since == "string" ? new e.Version(xe.since) : (vr = xe.since) !== null && vr !== void 0 ? vr : Mr, At = xe.error || pr && nt.compareTo(pr) <= 0, re = !Mr || nt.compareTo(Mr) >= 0;
                return At ? qr(me, pr, ot, xe.message) : re ? pt(me, pr, ot, xe.message) : e.noop;
              }
              __name(Ge, "Ge");
              s.createDeprecation = Ge;
              function K(me, xe) {
                return function() {
                  return me(), xe.apply(this, arguments);
                };
              }
              __name(K, "K");
              function r(me, xe) {
                var Ye, vr = Ge((Ye = xe == null ? void 0 : xe.name) !== null && Ye !== void 0 ? Ye : Fe(me), xe);
                return K(vr, me);
              }
              __name(r, "r");
              s.deprecate = r;
              function ct(me) {
                var xe = me & 7, Ye = xe === 0 ? "in out" : xe === 3 ? "[bivariant]" : xe === 2 ? "in" : xe === 1 ? "out" : xe === 4 ? "[independent]" : "";
                return me & 8 ? Ye += " (unmeasurable)" : me & 16 && (Ye += " (unreliable)"), Ye;
              }
              __name(ct, "ct");
              s.formatVariance = ct;
              var ft = function() {
                function me() {
                }
                __name(me, "me");
                return me.prototype.__debugToString = function() {
                  var xe;
                  switch (this.kind) {
                    case 3:
                      return ((xe = this.debugInfo) === null || xe === void 0 ? void 0 : xe.call(this)) || "(function mapper)";
                    case 0:
                      return "".concat(this.source.__debugTypeToString(), " -> ").concat(this.target.__debugTypeToString());
                    case 1:
                      return e.zipWith(this.sources, this.targets || e.map(this.sources, function() {
                        return "any";
                      }), function(Ye, vr) {
                        return "".concat(Ye.__debugTypeToString(), " -> ").concat(typeof vr == "string" ? vr : vr.__debugTypeToString());
                      }).join(", ");
                    case 2:
                      return e.zipWith(this.sources, this.targets, function(Ye, vr) {
                        return "".concat(Ye.__debugTypeToString(), " -> ").concat(vr().__debugTypeToString());
                      }).join(", ");
                    case 5:
                    case 4:
                      return "m1: ".concat(this.mapper1.__debugToString().split(`
`).join(`
    `), `
m2: `).concat(this.mapper2.__debugToString().split(`
`).join(`
    `));
                    default:
                      return ge(this);
                  }
                }, me;
              }();
              s.DebugTypeMapper = ft;
              function Ie(me) {
                return s.isDebugging ? Object.setPrototypeOf(me, ft.prototype) : me;
              }
              __name(Ie, "Ie");
              s.attachDebugPrototypeIfDebug = Ie;
            })(x = e.Debug || (e.Debug = {}));
          })(N || (N = {}));
          var N;
          (function(e) {
            e.tryGetNativePerformanceHooks = () => {
            }, e.timestamp = Date.now;
          })(N || (N = {}));
          var N;
          (function(e) {
            var t;
            (function(x) {
              var s, q;
              function F(te, Je, qe, ge) {
                return te ? fe(Je, qe, ge) : x.nullTimer;
              }
              __name(F, "F");
              x.createTimerIf = F;
              function fe(te, Je, qe) {
                var ge = 0;
                return { enter: ie, exit: G };
                function ie() {
                  ++ge === 1 && Q(Je);
                }
                __name(ie, "ie");
                function G() {
                  --ge === 0 ? (Q(qe), Be(te, Je, qe)) : ge < 0 && e.Debug.fail("enter/exit count does not match.");
                }
                __name(G, "G");
              }
              __name(fe, "fe");
              x.createTimer = fe, x.nullTimer = { enter: e.noop, exit: e.noop };
              var Te = false, Se = e.timestamp(), J = new e.Map(), se = new e.Map(), Le = new e.Map();
              function Q(te) {
                var Je;
                if (Te) {
                  var qe = (Je = se.get(te)) !== null && Je !== void 0 ? Je : 0;
                  se.set(te, qe + 1), J.set(te, e.timestamp()), q == null || q.mark(te);
                }
              }
              __name(Q, "Q");
              x.mark = Q;
              function Be(te, Je, qe) {
                var ge, ie;
                if (Te) {
                  var G = (ge = qe !== void 0 ? J.get(qe) : void 0) !== null && ge !== void 0 ? ge : e.timestamp(), pe = (ie = Je !== void 0 ? J.get(Je) : void 0) !== null && ie !== void 0 ? ie : Se, j = Le.get(te) || 0;
                  Le.set(te, j + (G - pe)), q == null || q.measure(te, Je, qe);
                }
              }
              __name(Be, "Be");
              x.measure = Be;
              function je(te) {
                return se.get(te) || 0;
              }
              __name(je, "je");
              x.getCount = je;
              function W(te) {
                return Le.get(te) || 0;
              }
              __name(W, "W");
              x.getDuration = W;
              function B(te) {
                Le.forEach(function(Je, qe) {
                  return te(qe, Je);
                });
              }
              __name(B, "B");
              x.forEachMeasure = B;
              function U(te) {
                J.forEach(function(Je, qe) {
                  return te(qe);
                });
              }
              __name(U, "U");
              x.forEachMark = U;
              function m(te) {
                te !== void 0 ? Le.delete(te) : Le.clear(), q == null || q.clearMeasures(te);
              }
              __name(m, "m");
              x.clearMeasures = m;
              function v(te) {
                te !== void 0 ? (se.delete(te), J.delete(te)) : (se.clear(), J.clear()), q == null || q.clearMarks(te);
              }
              __name(v, "v");
              x.clearMarks = v;
              function g() {
                return Te;
              }
              __name(g, "g");
              x.isEnabled = g;
              function O(te) {
                var Je;
                return te === void 0 && (te = e.sys), Te || (Te = true, s || (s = e.tryGetNativePerformanceHooks()), s && (Se = s.performance.timeOrigin, (s.shouldWriteNativeEvents || ((Je = te == null ? void 0 : te.cpuProfilingEnabled) === null || Je === void 0 ? void 0 : Je.call(te)) || (te == null ? void 0 : te.debugMode)) && (q = s.performance))), true;
              }
              __name(O, "O");
              x.enable = O;
              function S() {
                Te && (J.clear(), se.clear(), Le.clear(), q = void 0, Te = false);
              }
              __name(S, "S");
              x.disable = S;
            })(t = e.performance || (e.performance = {}));
          })(N || (N = {}));
          var N;
          (function(e) {
            var t, x = { logEvent: e.noop, logErrEvent: e.noop, logPerfEvent: e.noop, logInfoEvent: e.noop, logStartCommand: e.noop, logStopCommand: e.noop, logStartUpdateProgram: e.noop, logStopUpdateProgram: e.noop, logStartUpdateGraph: e.noop, logStopUpdateGraph: e.noop, logStartResolveModule: e.noop, logStopResolveModule: e.noop, logStartParseSourceFile: e.noop, logStopParseSourceFile: e.noop, logStartReadFile: e.noop, logStopReadFile: e.noop, logStartBindFile: e.noop, logStopBindFile: e.noop, logStartScheduledOperation: e.noop, logStopScheduledOperation: e.noop }, s;
            try {
              var q = (t = Ea.env.TS_ETW_MODULE_PATH) !== null && t !== void 0 ? t : "./node_modules/@microsoft/typescript-etw";
              s = void 0;
            } catch {
              s = void 0;
            }
            e.perfLogger = s && s.logEvent ? s : x;
          })(N || (N = {}));
          var N;
          (function(e) {
            var t;
            (function(r) {
              r[r.Unknown = 0] = "Unknown", r[r.EndOfFileToken = 1] = "EndOfFileToken", r[r.SingleLineCommentTrivia = 2] = "SingleLineCommentTrivia", r[r.MultiLineCommentTrivia = 3] = "MultiLineCommentTrivia", r[r.NewLineTrivia = 4] = "NewLineTrivia", r[r.WhitespaceTrivia = 5] = "WhitespaceTrivia", r[r.ShebangTrivia = 6] = "ShebangTrivia", r[r.ConflictMarkerTrivia = 7] = "ConflictMarkerTrivia", r[r.NumericLiteral = 8] = "NumericLiteral", r[r.BigIntLiteral = 9] = "BigIntLiteral", r[r.StringLiteral = 10] = "StringLiteral", r[r.JsxText = 11] = "JsxText", r[r.JsxTextAllWhiteSpaces = 12] = "JsxTextAllWhiteSpaces", r[r.RegularExpressionLiteral = 13] = "RegularExpressionLiteral", r[r.NoSubstitutionTemplateLiteral = 14] = "NoSubstitutionTemplateLiteral", r[r.TemplateHead = 15] = "TemplateHead", r[r.TemplateMiddle = 16] = "TemplateMiddle", r[r.TemplateTail = 17] = "TemplateTail", r[r.OpenBraceToken = 18] = "OpenBraceToken", r[r.CloseBraceToken = 19] = "CloseBraceToken", r[r.OpenParenToken = 20] = "OpenParenToken", r[r.CloseParenToken = 21] = "CloseParenToken", r[r.OpenBracketToken = 22] = "OpenBracketToken", r[r.CloseBracketToken = 23] = "CloseBracketToken", r[r.DotToken = 24] = "DotToken", r[r.DotDotDotToken = 25] = "DotDotDotToken", r[r.SemicolonToken = 26] = "SemicolonToken", r[r.CommaToken = 27] = "CommaToken", r[r.QuestionDotToken = 28] = "QuestionDotToken", r[r.LessThanToken = 29] = "LessThanToken", r[r.LessThanSlashToken = 30] = "LessThanSlashToken", r[r.GreaterThanToken = 31] = "GreaterThanToken", r[r.LessThanEqualsToken = 32] = "LessThanEqualsToken", r[r.GreaterThanEqualsToken = 33] = "GreaterThanEqualsToken", r[r.EqualsEqualsToken = 34] = "EqualsEqualsToken", r[r.ExclamationEqualsToken = 35] = "ExclamationEqualsToken", r[r.EqualsEqualsEqualsToken = 36] = "EqualsEqualsEqualsToken", r[r.ExclamationEqualsEqualsToken = 37] = "ExclamationEqualsEqualsToken", r[r.EqualsGreaterThanToken = 38] = "EqualsGreaterThanToken", r[r.PlusToken = 39] = "PlusToken", r[r.MinusToken = 40] = "MinusToken", r[r.AsteriskToken = 41] = "AsteriskToken", r[r.AsteriskAsteriskToken = 42] = "AsteriskAsteriskToken", r[r.SlashToken = 43] = "SlashToken", r[r.PercentToken = 44] = "PercentToken", r[r.PlusPlusToken = 45] = "PlusPlusToken", r[r.MinusMinusToken = 46] = "MinusMinusToken", r[r.LessThanLessThanToken = 47] = "LessThanLessThanToken", r[r.GreaterThanGreaterThanToken = 48] = "GreaterThanGreaterThanToken", r[r.GreaterThanGreaterThanGreaterThanToken = 49] = "GreaterThanGreaterThanGreaterThanToken", r[r.AmpersandToken = 50] = "AmpersandToken", r[r.BarToken = 51] = "BarToken", r[r.CaretToken = 52] = "CaretToken", r[r.ExclamationToken = 53] = "ExclamationToken", r[r.TildeToken = 54] = "TildeToken", r[r.AmpersandAmpersandToken = 55] = "AmpersandAmpersandToken", r[r.BarBarToken = 56] = "BarBarToken", r[r.QuestionToken = 57] = "QuestionToken", r[r.ColonToken = 58] = "ColonToken", r[r.AtToken = 59] = "AtToken", r[r.QuestionQuestionToken = 60] = "QuestionQuestionToken", r[r.BacktickToken = 61] = "BacktickToken", r[r.HashToken = 62] = "HashToken", r[r.EqualsToken = 63] = "EqualsToken", r[r.PlusEqualsToken = 64] = "PlusEqualsToken", r[r.MinusEqualsToken = 65] = "MinusEqualsToken", r[r.AsteriskEqualsToken = 66] = "AsteriskEqualsToken", r[r.AsteriskAsteriskEqualsToken = 67] = "AsteriskAsteriskEqualsToken", r[r.SlashEqualsToken = 68] = "SlashEqualsToken", r[r.PercentEqualsToken = 69] = "PercentEqualsToken", r[r.LessThanLessThanEqualsToken = 70] = "LessThanLessThanEqualsToken", r[r.GreaterThanGreaterThanEqualsToken = 71] = "GreaterThanGreaterThanEqualsToken", r[r.GreaterThanGreaterThanGreaterThanEqualsToken = 72] = "GreaterThanGreaterThanGreaterThanEqualsToken", r[r.AmpersandEqualsToken = 73] = "AmpersandEqualsToken", r[r.BarEqualsToken = 74] = "BarEqualsToken", r[r.BarBarEqualsToken = 75] = "BarBarEqualsToken", r[r.AmpersandAmpersandEqualsToken = 76] = "AmpersandAmpersandEqualsToken", r[r.QuestionQuestionEqualsToken = 77] = "QuestionQuestionEqualsToken", r[r.CaretEqualsToken = 78] = "CaretEqualsToken", r[r.Identifier = 79] = "Identifier", r[r.PrivateIdentifier = 80] = "PrivateIdentifier", r[r.BreakKeyword = 81] = "BreakKeyword", r[r.CaseKeyword = 82] = "CaseKeyword", r[r.CatchKeyword = 83] = "CatchKeyword", r[r.ClassKeyword = 84] = "ClassKeyword", r[r.ConstKeyword = 85] = "ConstKeyword", r[r.ContinueKeyword = 86] = "ContinueKeyword", r[r.DebuggerKeyword = 87] = "DebuggerKeyword", r[r.DefaultKeyword = 88] = "DefaultKeyword", r[r.DeleteKeyword = 89] = "DeleteKeyword", r[r.DoKeyword = 90] = "DoKeyword", r[r.ElseKeyword = 91] = "ElseKeyword", r[r.EnumKeyword = 92] = "EnumKeyword", r[r.ExportKeyword = 93] = "ExportKeyword", r[r.ExtendsKeyword = 94] = "ExtendsKeyword", r[r.FalseKeyword = 95] = "FalseKeyword", r[r.FinallyKeyword = 96] = "FinallyKeyword", r[r.ForKeyword = 97] = "ForKeyword", r[r.FunctionKeyword = 98] = "FunctionKeyword", r[r.IfKeyword = 99] = "IfKeyword", r[r.ImportKeyword = 100] = "ImportKeyword", r[r.InKeyword = 101] = "InKeyword", r[r.InstanceOfKeyword = 102] = "InstanceOfKeyword", r[r.NewKeyword = 103] = "NewKeyword", r[r.NullKeyword = 104] = "NullKeyword", r[r.ReturnKeyword = 105] = "ReturnKeyword", r[r.SuperKeyword = 106] = "SuperKeyword", r[r.SwitchKeyword = 107] = "SwitchKeyword", r[r.ThisKeyword = 108] = "ThisKeyword", r[r.ThrowKeyword = 109] = "ThrowKeyword", r[r.TrueKeyword = 110] = "TrueKeyword", r[r.TryKeyword = 111] = "TryKeyword", r[r.TypeOfKeyword = 112] = "TypeOfKeyword", r[r.VarKeyword = 113] = "VarKeyword", r[r.VoidKeyword = 114] = "VoidKeyword", r[r.WhileKeyword = 115] = "WhileKeyword", r[r.WithKeyword = 116] = "WithKeyword", r[r.ImplementsKeyword = 117] = "ImplementsKeyword", r[r.InterfaceKeyword = 118] = "InterfaceKeyword", r[r.LetKeyword = 119] = "LetKeyword", r[r.PackageKeyword = 120] = "PackageKeyword", r[r.PrivateKeyword = 121] = "PrivateKeyword", r[r.ProtectedKeyword = 122] = "ProtectedKeyword", r[r.PublicKeyword = 123] = "PublicKeyword", r[r.StaticKeyword = 124] = "StaticKeyword", r[r.YieldKeyword = 125] = "YieldKeyword", r[r.AbstractKeyword = 126] = "AbstractKeyword", r[r.AccessorKeyword = 127] = "AccessorKeyword", r[r.AsKeyword = 128] = "AsKeyword", r[r.AssertsKeyword = 129] = "AssertsKeyword", r[r.AssertKeyword = 130] = "AssertKeyword", r[r.AnyKeyword = 131] = "AnyKeyword", r[r.AsyncKeyword = 132] = "AsyncKeyword", r[r.AwaitKeyword = 133] = "AwaitKeyword", r[r.BooleanKeyword = 134] = "BooleanKeyword", r[r.ConstructorKeyword = 135] = "ConstructorKeyword", r[r.DeclareKeyword = 136] = "DeclareKeyword", r[r.GetKeyword = 137] = "GetKeyword", r[r.InferKeyword = 138] = "InferKeyword", r[r.IntrinsicKeyword = 139] = "IntrinsicKeyword", r[r.IsKeyword = 140] = "IsKeyword", r[r.KeyOfKeyword = 141] = "KeyOfKeyword", r[r.ModuleKeyword = 142] = "ModuleKeyword", r[r.NamespaceKeyword = 143] = "NamespaceKeyword", r[r.NeverKeyword = 144] = "NeverKeyword", r[r.OutKeyword = 145] = "OutKeyword", r[r.ReadonlyKeyword = 146] = "ReadonlyKeyword", r[r.RequireKeyword = 147] = "RequireKeyword", r[r.NumberKeyword = 148] = "NumberKeyword", r[r.ObjectKeyword = 149] = "ObjectKeyword", r[r.SatisfiesKeyword = 150] = "SatisfiesKeyword", r[r.SetKeyword = 151] = "SetKeyword", r[r.StringKeyword = 152] = "StringKeyword", r[r.SymbolKeyword = 153] = "SymbolKeyword", r[r.TypeKeyword = 154] = "TypeKeyword", r[r.UndefinedKeyword = 155] = "UndefinedKeyword", r[r.UniqueKeyword = 156] = "UniqueKeyword", r[r.UnknownKeyword = 157] = "UnknownKeyword", r[r.FromKeyword = 158] = "FromKeyword", r[r.GlobalKeyword = 159] = "GlobalKeyword", r[r.BigIntKeyword = 160] = "BigIntKeyword", r[r.OverrideKeyword = 161] = "OverrideKeyword", r[r.OfKeyword = 162] = "OfKeyword", r[r.QualifiedName = 163] = "QualifiedName", r[r.ComputedPropertyName = 164] = "ComputedPropertyName", r[r.TypeParameter = 165] = "TypeParameter", r[r.Parameter = 166] = "Parameter", r[r.Decorator = 167] = "Decorator", r[r.PropertySignature = 168] = "PropertySignature", r[r.PropertyDeclaration = 169] = "PropertyDeclaration", r[r.MethodSignature = 170] = "MethodSignature", r[r.MethodDeclaration = 171] = "MethodDeclaration", r[r.ClassStaticBlockDeclaration = 172] = "ClassStaticBlockDeclaration", r[r.Constructor = 173] = "Constructor", r[r.GetAccessor = 174] = "GetAccessor", r[r.SetAccessor = 175] = "SetAccessor", r[r.CallSignature = 176] = "CallSignature", r[r.ConstructSignature = 177] = "ConstructSignature", r[r.IndexSignature = 178] = "IndexSignature", r[r.TypePredicate = 179] = "TypePredicate", r[r.TypeReference = 180] = "TypeReference", r[r.FunctionType = 181] = "FunctionType", r[r.ConstructorType = 182] = "ConstructorType", r[r.TypeQuery = 183] = "TypeQuery", r[r.TypeLiteral = 184] = "TypeLiteral", r[r.ArrayType = 185] = "ArrayType", r[r.TupleType = 186] = "TupleType", r[r.OptionalType = 187] = "OptionalType", r[r.RestType = 188] = "RestType", r[r.UnionType = 189] = "UnionType", r[r.IntersectionType = 190] = "IntersectionType", r[r.ConditionalType = 191] = "ConditionalType", r[r.InferType = 192] = "InferType", r[r.ParenthesizedType = 193] = "ParenthesizedType", r[r.ThisType = 194] = "ThisType", r[r.TypeOperator = 195] = "TypeOperator", r[r.IndexedAccessType = 196] = "IndexedAccessType", r[r.MappedType = 197] = "MappedType", r[r.LiteralType = 198] = "LiteralType", r[r.NamedTupleMember = 199] = "NamedTupleMember", r[r.TemplateLiteralType = 200] = "TemplateLiteralType", r[r.TemplateLiteralTypeSpan = 201] = "TemplateLiteralTypeSpan", r[r.ImportType = 202] = "ImportType", r[r.ObjectBindingPattern = 203] = "ObjectBindingPattern", r[r.ArrayBindingPattern = 204] = "ArrayBindingPattern", r[r.BindingElement = 205] = "BindingElement", r[r.ArrayLiteralExpression = 206] = "ArrayLiteralExpression", r[r.ObjectLiteralExpression = 207] = "ObjectLiteralExpression", r[r.PropertyAccessExpression = 208] = "PropertyAccessExpression", r[r.ElementAccessExpression = 209] = "ElementAccessExpression", r[r.CallExpression = 210] = "CallExpression", r[r.NewExpression = 211] = "NewExpression", r[r.TaggedTemplateExpression = 212] = "TaggedTemplateExpression", r[r.TypeAssertionExpression = 213] = "TypeAssertionExpression", r[r.ParenthesizedExpression = 214] = "ParenthesizedExpression", r[r.FunctionExpression = 215] = "FunctionExpression", r[r.ArrowFunction = 216] = "ArrowFunction", r[r.DeleteExpression = 217] = "DeleteExpression", r[r.TypeOfExpression = 218] = "TypeOfExpression", r[r.VoidExpression = 219] = "VoidExpression", r[r.AwaitExpression = 220] = "AwaitExpression", r[r.PrefixUnaryExpression = 221] = "PrefixUnaryExpression", r[r.PostfixUnaryExpression = 222] = "PostfixUnaryExpression", r[r.BinaryExpression = 223] = "BinaryExpression", r[r.ConditionalExpression = 224] = "ConditionalExpression", r[r.TemplateExpression = 225] = "TemplateExpression", r[r.YieldExpression = 226] = "YieldExpression", r[r.SpreadElement = 227] = "SpreadElement", r[r.ClassExpression = 228] = "ClassExpression", r[r.OmittedExpression = 229] = "OmittedExpression", r[r.ExpressionWithTypeArguments = 230] = "ExpressionWithTypeArguments", r[r.AsExpression = 231] = "AsExpression", r[r.NonNullExpression = 232] = "NonNullExpression", r[r.MetaProperty = 233] = "MetaProperty", r[r.SyntheticExpression = 234] = "SyntheticExpression", r[r.SatisfiesExpression = 235] = "SatisfiesExpression", r[r.TemplateSpan = 236] = "TemplateSpan", r[r.SemicolonClassElement = 237] = "SemicolonClassElement", r[r.Block = 238] = "Block", r[r.EmptyStatement = 239] = "EmptyStatement", r[r.VariableStatement = 240] = "VariableStatement", r[r.ExpressionStatement = 241] = "ExpressionStatement", r[r.IfStatement = 242] = "IfStatement", r[r.DoStatement = 243] = "DoStatement", r[r.WhileStatement = 244] = "WhileStatement", r[r.ForStatement = 245] = "ForStatement", r[r.ForInStatement = 246] = "ForInStatement", r[r.ForOfStatement = 247] = "ForOfStatement", r[r.ContinueStatement = 248] = "ContinueStatement", r[r.BreakStatement = 249] = "BreakStatement", r[r.ReturnStatement = 250] = "ReturnStatement", r[r.WithStatement = 251] = "WithStatement", r[r.SwitchStatement = 252] = "SwitchStatement", r[r.LabeledStatement = 253] = "LabeledStatement", r[r.ThrowStatement = 254] = "ThrowStatement", r[r.TryStatement = 255] = "TryStatement", r[r.DebuggerStatement = 256] = "DebuggerStatement", r[r.VariableDeclaration = 257] = "VariableDeclaration", r[r.VariableDeclarationList = 258] = "VariableDeclarationList", r[r.FunctionDeclaration = 259] = "FunctionDeclaration", r[r.ClassDeclaration = 260] = "ClassDeclaration", r[r.InterfaceDeclaration = 261] = "InterfaceDeclaration", r[r.TypeAliasDeclaration = 262] = "TypeAliasDeclaration", r[r.EnumDeclaration = 263] = "EnumDeclaration", r[r.ModuleDeclaration = 264] = "ModuleDeclaration", r[r.ModuleBlock = 265] = "ModuleBlock", r[r.CaseBlock = 266] = "CaseBlock", r[r.NamespaceExportDeclaration = 267] = "NamespaceExportDeclaration", r[r.ImportEqualsDeclaration = 268] = "ImportEqualsDeclaration", r[r.ImportDeclaration = 269] = "ImportDeclaration", r[r.ImportClause = 270] = "ImportClause", r[r.NamespaceImport = 271] = "NamespaceImport", r[r.NamedImports = 272] = "NamedImports", r[r.ImportSpecifier = 273] = "ImportSpecifier", r[r.ExportAssignment = 274] = "ExportAssignment", r[r.ExportDeclaration = 275] = "ExportDeclaration", r[r.NamedExports = 276] = "NamedExports", r[r.NamespaceExport = 277] = "NamespaceExport", r[r.ExportSpecifier = 278] = "ExportSpecifier", r[r.MissingDeclaration = 279] = "MissingDeclaration", r[r.ExternalModuleReference = 280] = "ExternalModuleReference", r[r.JsxElement = 281] = "JsxElement", r[r.JsxSelfClosingElement = 282] = "JsxSelfClosingElement", r[r.JsxOpeningElement = 283] = "JsxOpeningElement", r[r.JsxClosingElement = 284] = "JsxClosingElement", r[r.JsxFragment = 285] = "JsxFragment", r[r.JsxOpeningFragment = 286] = "JsxOpeningFragment", r[r.JsxClosingFragment = 287] = "JsxClosingFragment", r[r.JsxAttribute = 288] = "JsxAttribute", r[r.JsxAttributes = 289] = "JsxAttributes", r[r.JsxSpreadAttribute = 290] = "JsxSpreadAttribute", r[r.JsxExpression = 291] = "JsxExpression", r[r.CaseClause = 292] = "CaseClause", r[r.DefaultClause = 293] = "DefaultClause", r[r.HeritageClause = 294] = "HeritageClause", r[r.CatchClause = 295] = "CatchClause", r[r.AssertClause = 296] = "AssertClause", r[r.AssertEntry = 297] = "AssertEntry", r[r.ImportTypeAssertionContainer = 298] = "ImportTypeAssertionContainer", r[r.PropertyAssignment = 299] = "PropertyAssignment", r[r.ShorthandPropertyAssignment = 300] = "ShorthandPropertyAssignment", r[r.SpreadAssignment = 301] = "SpreadAssignment", r[r.EnumMember = 302] = "EnumMember", r[r.UnparsedPrologue = 303] = "UnparsedPrologue", r[r.UnparsedPrepend = 304] = "UnparsedPrepend", r[r.UnparsedText = 305] = "UnparsedText", r[r.UnparsedInternalText = 306] = "UnparsedInternalText", r[r.UnparsedSyntheticReference = 307] = "UnparsedSyntheticReference", r[r.SourceFile = 308] = "SourceFile", r[r.Bundle = 309] = "Bundle", r[r.UnparsedSource = 310] = "UnparsedSource", r[r.InputFiles = 311] = "InputFiles", r[r.JSDocTypeExpression = 312] = "JSDocTypeExpression", r[r.JSDocNameReference = 313] = "JSDocNameReference", r[r.JSDocMemberName = 314] = "JSDocMemberName", r[r.JSDocAllType = 315] = "JSDocAllType", r[r.JSDocUnknownType = 316] = "JSDocUnknownType", r[r.JSDocNullableType = 317] = "JSDocNullableType", r[r.JSDocNonNullableType = 318] = "JSDocNonNullableType", r[r.JSDocOptionalType = 319] = "JSDocOptionalType", r[r.JSDocFunctionType = 320] = "JSDocFunctionType", r[r.JSDocVariadicType = 321] = "JSDocVariadicType", r[r.JSDocNamepathType = 322] = "JSDocNamepathType", r[r.JSDoc = 323] = "JSDoc", r[r.JSDocComment = 323] = "JSDocComment", r[r.JSDocText = 324] = "JSDocText", r[r.JSDocTypeLiteral = 325] = "JSDocTypeLiteral", r[r.JSDocSignature = 326] = "JSDocSignature", r[r.JSDocLink = 327] = "JSDocLink", r[r.JSDocLinkCode = 328] = "JSDocLinkCode", r[r.JSDocLinkPlain = 329] = "JSDocLinkPlain", r[r.JSDocTag = 330] = "JSDocTag", r[r.JSDocAugmentsTag = 331] = "JSDocAugmentsTag", r[r.JSDocImplementsTag = 332] = "JSDocImplementsTag", r[r.JSDocAuthorTag = 333] = "JSDocAuthorTag", r[r.JSDocDeprecatedTag = 334] = "JSDocDeprecatedTag", r[r.JSDocClassTag = 335] = "JSDocClassTag", r[r.JSDocPublicTag = 336] = "JSDocPublicTag", r[r.JSDocPrivateTag = 337] = "JSDocPrivateTag", r[r.JSDocProtectedTag = 338] = "JSDocProtectedTag", r[r.JSDocReadonlyTag = 339] = "JSDocReadonlyTag", r[r.JSDocOverrideTag = 340] = "JSDocOverrideTag", r[r.JSDocCallbackTag = 341] = "JSDocCallbackTag", r[r.JSDocEnumTag = 342] = "JSDocEnumTag", r[r.JSDocParameterTag = 343] = "JSDocParameterTag", r[r.JSDocReturnTag = 344] = "JSDocReturnTag", r[r.JSDocThisTag = 345] = "JSDocThisTag", r[r.JSDocTypeTag = 346] = "JSDocTypeTag", r[r.JSDocTemplateTag = 347] = "JSDocTemplateTag", r[r.JSDocTypedefTag = 348] = "JSDocTypedefTag", r[r.JSDocSeeTag = 349] = "JSDocSeeTag", r[r.JSDocPropertyTag = 350] = "JSDocPropertyTag", r[r.SyntaxList = 351] = "SyntaxList", r[r.NotEmittedStatement = 352] = "NotEmittedStatement", r[r.PartiallyEmittedExpression = 353] = "PartiallyEmittedExpression", r[r.CommaListExpression = 354] = "CommaListExpression", r[r.MergeDeclarationMarker = 355] = "MergeDeclarationMarker", r[r.EndOfDeclarationMarker = 356] = "EndOfDeclarationMarker", r[r.SyntheticReferenceExpression = 357] = "SyntheticReferenceExpression", r[r.Count = 358] = "Count", r[r.FirstAssignment = 63] = "FirstAssignment", r[r.LastAssignment = 78] = "LastAssignment", r[r.FirstCompoundAssignment = 64] = "FirstCompoundAssignment", r[r.LastCompoundAssignment = 78] = "LastCompoundAssignment", r[r.FirstReservedWord = 81] = "FirstReservedWord", r[r.LastReservedWord = 116] = "LastReservedWord", r[r.FirstKeyword = 81] = "FirstKeyword", r[r.LastKeyword = 162] = "LastKeyword", r[r.FirstFutureReservedWord = 117] = "FirstFutureReservedWord", r[r.LastFutureReservedWord = 125] = "LastFutureReservedWord", r[r.FirstTypeNode = 179] = "FirstTypeNode", r[r.LastTypeNode = 202] = "LastTypeNode", r[r.FirstPunctuation = 18] = "FirstPunctuation", r[r.LastPunctuation = 78] = "LastPunctuation", r[r.FirstToken = 0] = "FirstToken", r[r.LastToken = 162] = "LastToken", r[r.FirstTriviaToken = 2] = "FirstTriviaToken", r[r.LastTriviaToken = 7] = "LastTriviaToken", r[r.FirstLiteralToken = 8] = "FirstLiteralToken", r[r.LastLiteralToken = 14] = "LastLiteralToken", r[r.FirstTemplateToken = 14] = "FirstTemplateToken", r[r.LastTemplateToken = 17] = "LastTemplateToken", r[r.FirstBinaryOperator = 29] = "FirstBinaryOperator", r[r.LastBinaryOperator = 78] = "LastBinaryOperator", r[r.FirstStatement = 240] = "FirstStatement", r[r.LastStatement = 256] = "LastStatement", r[r.FirstNode = 163] = "FirstNode", r[r.FirstJSDocNode = 312] = "FirstJSDocNode", r[r.LastJSDocNode = 350] = "LastJSDocNode", r[r.FirstJSDocTagNode = 330] = "FirstJSDocTagNode", r[r.LastJSDocTagNode = 350] = "LastJSDocTagNode", r[r.FirstContextualKeyword = 126] = "FirstContextualKeyword", r[r.LastContextualKeyword = 162] = "LastContextualKeyword";
            })(t = e.SyntaxKind || (e.SyntaxKind = {}));
            var x;
            (function(r) {
              r[r.None = 0] = "None", r[r.Let = 1] = "Let", r[r.Const = 2] = "Const", r[r.NestedNamespace = 4] = "NestedNamespace", r[r.Synthesized = 8] = "Synthesized", r[r.Namespace = 16] = "Namespace", r[r.OptionalChain = 32] = "OptionalChain", r[r.ExportContext = 64] = "ExportContext", r[r.ContainsThis = 128] = "ContainsThis", r[r.HasImplicitReturn = 256] = "HasImplicitReturn", r[r.HasExplicitReturn = 512] = "HasExplicitReturn", r[r.GlobalAugmentation = 1024] = "GlobalAugmentation", r[r.HasAsyncFunctions = 2048] = "HasAsyncFunctions", r[r.DisallowInContext = 4096] = "DisallowInContext", r[r.YieldContext = 8192] = "YieldContext", r[r.DecoratorContext = 16384] = "DecoratorContext", r[r.AwaitContext = 32768] = "AwaitContext", r[r.DisallowConditionalTypesContext = 65536] = "DisallowConditionalTypesContext", r[r.ThisNodeHasError = 131072] = "ThisNodeHasError", r[r.JavaScriptFile = 262144] = "JavaScriptFile", r[r.ThisNodeOrAnySubNodesHasError = 524288] = "ThisNodeOrAnySubNodesHasError", r[r.HasAggregatedChildData = 1048576] = "HasAggregatedChildData", r[r.PossiblyContainsDynamicImport = 2097152] = "PossiblyContainsDynamicImport", r[r.PossiblyContainsImportMeta = 4194304] = "PossiblyContainsImportMeta", r[r.JSDoc = 8388608] = "JSDoc", r[r.Ambient = 16777216] = "Ambient", r[r.InWithStatement = 33554432] = "InWithStatement", r[r.JsonFile = 67108864] = "JsonFile", r[r.TypeCached = 134217728] = "TypeCached", r[r.Deprecated = 268435456] = "Deprecated", r[r.BlockScoped = 3] = "BlockScoped", r[r.ReachabilityCheckFlags = 768] = "ReachabilityCheckFlags", r[r.ReachabilityAndEmitFlags = 2816] = "ReachabilityAndEmitFlags", r[r.ContextFlags = 50720768] = "ContextFlags", r[r.TypeExcludesFlags = 40960] = "TypeExcludesFlags", r[r.PermanentlySetIncrementalFlags = 6291456] = "PermanentlySetIncrementalFlags";
            })(x = e.NodeFlags || (e.NodeFlags = {}));
            var s;
            (function(r) {
              r[r.None = 0] = "None", r[r.Export = 1] = "Export", r[r.Ambient = 2] = "Ambient", r[r.Public = 4] = "Public", r[r.Private = 8] = "Private", r[r.Protected = 16] = "Protected", r[r.Static = 32] = "Static", r[r.Readonly = 64] = "Readonly", r[r.Accessor = 128] = "Accessor", r[r.Abstract = 256] = "Abstract", r[r.Async = 512] = "Async", r[r.Default = 1024] = "Default", r[r.Const = 2048] = "Const", r[r.HasComputedJSDocModifiers = 4096] = "HasComputedJSDocModifiers", r[r.Deprecated = 8192] = "Deprecated", r[r.Override = 16384] = "Override", r[r.In = 32768] = "In", r[r.Out = 65536] = "Out", r[r.Decorator = 131072] = "Decorator", r[r.HasComputedFlags = 536870912] = "HasComputedFlags", r[r.AccessibilityModifier = 28] = "AccessibilityModifier", r[r.ParameterPropertyModifier = 16476] = "ParameterPropertyModifier", r[r.NonPublicAccessibilityModifier = 24] = "NonPublicAccessibilityModifier", r[r.TypeScriptModifier = 117086] = "TypeScriptModifier", r[r.ExportDefault = 1025] = "ExportDefault", r[r.All = 258047] = "All", r[r.Modifier = 126975] = "Modifier";
            })(s = e.ModifierFlags || (e.ModifierFlags = {}));
            var q;
            (function(r) {
              r[r.None = 0] = "None", r[r.IntrinsicNamedElement = 1] = "IntrinsicNamedElement", r[r.IntrinsicIndexedElement = 2] = "IntrinsicIndexedElement", r[r.IntrinsicElement = 3] = "IntrinsicElement";
            })(q = e.JsxFlags || (e.JsxFlags = {}));
            var F;
            (function(r) {
              r[r.Succeeded = 1] = "Succeeded", r[r.Failed = 2] = "Failed", r[r.Reported = 4] = "Reported", r[r.ReportsUnmeasurable = 8] = "ReportsUnmeasurable", r[r.ReportsUnreliable = 16] = "ReportsUnreliable", r[r.ReportsMask = 24] = "ReportsMask";
            })(F = e.RelationComparisonResult || (e.RelationComparisonResult = {}));
            var fe;
            (function(r) {
              r[r.None = 0] = "None", r[r.Auto = 1] = "Auto", r[r.Loop = 2] = "Loop", r[r.Unique = 3] = "Unique", r[r.Node = 4] = "Node", r[r.KindMask = 7] = "KindMask", r[r.ReservedInNestedScopes = 8] = "ReservedInNestedScopes", r[r.Optimistic = 16] = "Optimistic", r[r.FileLevel = 32] = "FileLevel", r[r.AllowNameSubstitution = 64] = "AllowNameSubstitution";
            })(fe = e.GeneratedIdentifierFlags || (e.GeneratedIdentifierFlags = {}));
            var Te;
            (function(r) {
              r[r.None = 0] = "None", r[r.PrecedingLineBreak = 1] = "PrecedingLineBreak", r[r.PrecedingJSDocComment = 2] = "PrecedingJSDocComment", r[r.Unterminated = 4] = "Unterminated", r[r.ExtendedUnicodeEscape = 8] = "ExtendedUnicodeEscape", r[r.Scientific = 16] = "Scientific", r[r.Octal = 32] = "Octal", r[r.HexSpecifier = 64] = "HexSpecifier", r[r.BinarySpecifier = 128] = "BinarySpecifier", r[r.OctalSpecifier = 256] = "OctalSpecifier", r[r.ContainsSeparator = 512] = "ContainsSeparator", r[r.UnicodeEscape = 1024] = "UnicodeEscape", r[r.ContainsInvalidEscape = 2048] = "ContainsInvalidEscape", r[r.BinaryOrOctalSpecifier = 384] = "BinaryOrOctalSpecifier", r[r.NumericLiteralFlags = 1008] = "NumericLiteralFlags", r[r.TemplateLiteralLikeFlags = 2048] = "TemplateLiteralLikeFlags";
            })(Te = e.TokenFlags || (e.TokenFlags = {}));
            var Se;
            (function(r) {
              r[r.Unreachable = 1] = "Unreachable", r[r.Start = 2] = "Start", r[r.BranchLabel = 4] = "BranchLabel", r[r.LoopLabel = 8] = "LoopLabel", r[r.Assignment = 16] = "Assignment", r[r.TrueCondition = 32] = "TrueCondition", r[r.FalseCondition = 64] = "FalseCondition", r[r.SwitchClause = 128] = "SwitchClause", r[r.ArrayMutation = 256] = "ArrayMutation", r[r.Call = 512] = "Call", r[r.ReduceLabel = 1024] = "ReduceLabel", r[r.Referenced = 2048] = "Referenced", r[r.Shared = 4096] = "Shared", r[r.Label = 12] = "Label", r[r.Condition = 96] = "Condition";
            })(Se = e.FlowFlags || (e.FlowFlags = {}));
            var J;
            (function(r) {
              r[r.ExpectError = 0] = "ExpectError", r[r.Ignore = 1] = "Ignore";
            })(J = e.CommentDirectiveType || (e.CommentDirectiveType = {}));
            var se = function() {
              function r() {
              }
              __name(r, "r");
              return r;
            }();
            e.OperationCanceledException = se;
            var Le;
            (function(r) {
              r[r.RootFile = 0] = "RootFile", r[r.SourceFromProjectReference = 1] = "SourceFromProjectReference", r[r.OutputFromProjectReference = 2] = "OutputFromProjectReference", r[r.Import = 3] = "Import", r[r.ReferenceFile = 4] = "ReferenceFile", r[r.TypeReferenceDirective = 5] = "TypeReferenceDirective", r[r.LibFile = 6] = "LibFile", r[r.LibReferenceDirective = 7] = "LibReferenceDirective", r[r.AutomaticTypeDirectiveFile = 8] = "AutomaticTypeDirectiveFile";
            })(Le = e.FileIncludeKind || (e.FileIncludeKind = {}));
            var Q;
            (function(r) {
              r[r.FilePreprocessingReferencedDiagnostic = 0] = "FilePreprocessingReferencedDiagnostic", r[r.FilePreprocessingFileExplainingDiagnostic = 1] = "FilePreprocessingFileExplainingDiagnostic";
            })(Q = e.FilePreprocessingDiagnosticsKind || (e.FilePreprocessingDiagnosticsKind = {}));
            var Be;
            (function(r) {
              r[r.Not = 0] = "Not", r[r.SafeModules = 1] = "SafeModules", r[r.Completely = 2] = "Completely";
            })(Be = e.StructureIsReused || (e.StructureIsReused = {}));
            var je;
            (function(r) {
              r[r.Success = 0] = "Success", r[r.DiagnosticsPresent_OutputsSkipped = 1] = "DiagnosticsPresent_OutputsSkipped", r[r.DiagnosticsPresent_OutputsGenerated = 2] = "DiagnosticsPresent_OutputsGenerated", r[r.InvalidProject_OutputsSkipped = 3] = "InvalidProject_OutputsSkipped", r[r.ProjectReferenceCycle_OutputsSkipped = 4] = "ProjectReferenceCycle_OutputsSkipped", r[r.ProjectReferenceCycle_OutputsSkupped = 4] = "ProjectReferenceCycle_OutputsSkupped";
            })(je = e.ExitStatus || (e.ExitStatus = {}));
            var W;
            (function(r) {
              r[r.Ok = 0] = "Ok", r[r.NeedsOverride = 1] = "NeedsOverride", r[r.HasInvalidOverride = 2] = "HasInvalidOverride";
            })(W = e.MemberOverrideStatus || (e.MemberOverrideStatus = {}));
            var B;
            (function(r) {
              r[r.None = 0] = "None", r[r.Literal = 1] = "Literal", r[r.Subtype = 2] = "Subtype";
            })(B = e.UnionReduction || (e.UnionReduction = {}));
            var U;
            (function(r) {
              r[r.None = 0] = "None", r[r.Signature = 1] = "Signature", r[r.NoConstraints = 2] = "NoConstraints", r[r.Completions = 4] = "Completions", r[r.SkipBindingPatterns = 8] = "SkipBindingPatterns";
            })(U = e.ContextFlags || (e.ContextFlags = {}));
            var m;
            (function(r) {
              r[r.None = 0] = "None", r[r.NoTruncation = 1] = "NoTruncation", r[r.WriteArrayAsGenericType = 2] = "WriteArrayAsGenericType", r[r.GenerateNamesForShadowedTypeParams = 4] = "GenerateNamesForShadowedTypeParams", r[r.UseStructuralFallback = 8] = "UseStructuralFallback", r[r.ForbidIndexedAccessSymbolReferences = 16] = "ForbidIndexedAccessSymbolReferences", r[r.WriteTypeArgumentsOfSignature = 32] = "WriteTypeArgumentsOfSignature", r[r.UseFullyQualifiedType = 64] = "UseFullyQualifiedType", r[r.UseOnlyExternalAliasing = 128] = "UseOnlyExternalAliasing", r[r.SuppressAnyReturnType = 256] = "SuppressAnyReturnType", r[r.WriteTypeParametersInQualifiedName = 512] = "WriteTypeParametersInQualifiedName", r[r.MultilineObjectLiterals = 1024] = "MultilineObjectLiterals", r[r.WriteClassExpressionAsTypeLiteral = 2048] = "WriteClassExpressionAsTypeLiteral", r[r.UseTypeOfFunction = 4096] = "UseTypeOfFunction", r[r.OmitParameterModifiers = 8192] = "OmitParameterModifiers", r[r.UseAliasDefinedOutsideCurrentScope = 16384] = "UseAliasDefinedOutsideCurrentScope", r[r.UseSingleQuotesForStringLiteralType = 268435456] = "UseSingleQuotesForStringLiteralType", r[r.NoTypeReduction = 536870912] = "NoTypeReduction", r[r.OmitThisParameter = 33554432] = "OmitThisParameter", r[r.AllowThisInObjectLiteral = 32768] = "AllowThisInObjectLiteral", r[r.AllowQualifiedNameInPlaceOfIdentifier = 65536] = "AllowQualifiedNameInPlaceOfIdentifier", r[r.AllowQualifedNameInPlaceOfIdentifier = 65536] = "AllowQualifedNameInPlaceOfIdentifier", r[r.AllowAnonymousIdentifier = 131072] = "AllowAnonymousIdentifier", r[r.AllowEmptyUnionOrIntersection = 262144] = "AllowEmptyUnionOrIntersection", r[r.AllowEmptyTuple = 524288] = "AllowEmptyTuple", r[r.AllowUniqueESSymbolType = 1048576] = "AllowUniqueESSymbolType", r[r.AllowEmptyIndexInfoType = 2097152] = "AllowEmptyIndexInfoType", r[r.WriteComputedProps = 1073741824] = "WriteComputedProps", r[r.AllowNodeModulesRelativePaths = 67108864] = "AllowNodeModulesRelativePaths", r[r.DoNotIncludeSymbolChain = 134217728] = "DoNotIncludeSymbolChain", r[r.IgnoreErrors = 70221824] = "IgnoreErrors", r[r.InObjectTypeLiteral = 4194304] = "InObjectTypeLiteral", r[r.InTypeAlias = 8388608] = "InTypeAlias", r[r.InInitialEntityName = 16777216] = "InInitialEntityName";
            })(m = e.NodeBuilderFlags || (e.NodeBuilderFlags = {}));
            var v;
            (function(r) {
              r[r.None = 0] = "None", r[r.NoTruncation = 1] = "NoTruncation", r[r.WriteArrayAsGenericType = 2] = "WriteArrayAsGenericType", r[r.UseStructuralFallback = 8] = "UseStructuralFallback", r[r.WriteTypeArgumentsOfSignature = 32] = "WriteTypeArgumentsOfSignature", r[r.UseFullyQualifiedType = 64] = "UseFullyQualifiedType", r[r.SuppressAnyReturnType = 256] = "SuppressAnyReturnType", r[r.MultilineObjectLiterals = 1024] = "MultilineObjectLiterals", r[r.WriteClassExpressionAsTypeLiteral = 2048] = "WriteClassExpressionAsTypeLiteral", r[r.UseTypeOfFunction = 4096] = "UseTypeOfFunction", r[r.OmitParameterModifiers = 8192] = "OmitParameterModifiers", r[r.UseAliasDefinedOutsideCurrentScope = 16384] = "UseAliasDefinedOutsideCurrentScope", r[r.UseSingleQuotesForStringLiteralType = 268435456] = "UseSingleQuotesForStringLiteralType", r[r.NoTypeReduction = 536870912] = "NoTypeReduction", r[r.OmitThisParameter = 33554432] = "OmitThisParameter", r[r.AllowUniqueESSymbolType = 1048576] = "AllowUniqueESSymbolType", r[r.AddUndefined = 131072] = "AddUndefined", r[r.WriteArrowStyleSignature = 262144] = "WriteArrowStyleSignature", r[r.InArrayType = 524288] = "InArrayType", r[r.InElementType = 2097152] = "InElementType", r[r.InFirstTypeArgument = 4194304] = "InFirstTypeArgument", r[r.InTypeAlias = 8388608] = "InTypeAlias", r[r.WriteOwnNameForAnyLike = 0] = "WriteOwnNameForAnyLike", r[r.NodeBuilderFlagsMask = 848330091] = "NodeBuilderFlagsMask";
            })(v = e.TypeFormatFlags || (e.TypeFormatFlags = {}));
            var g;
            (function(r) {
              r[r.None = 0] = "None", r[r.WriteTypeParametersOrArguments = 1] = "WriteTypeParametersOrArguments", r[r.UseOnlyExternalAliasing = 2] = "UseOnlyExternalAliasing", r[r.AllowAnyNodeKind = 4] = "AllowAnyNodeKind", r[r.UseAliasDefinedOutsideCurrentScope = 8] = "UseAliasDefinedOutsideCurrentScope", r[r.WriteComputedProps = 16] = "WriteComputedProps", r[r.DoNotIncludeSymbolChain = 32] = "DoNotIncludeSymbolChain";
            })(g = e.SymbolFormatFlags || (e.SymbolFormatFlags = {}));
            var O;
            (function(r) {
              r[r.Accessible = 0] = "Accessible", r[r.NotAccessible = 1] = "NotAccessible", r[r.CannotBeNamed = 2] = "CannotBeNamed";
            })(O = e.SymbolAccessibility || (e.SymbolAccessibility = {}));
            var S;
            (function(r) {
              r[r.UnionOrIntersection = 0] = "UnionOrIntersection", r[r.Spread = 1] = "Spread";
            })(S = e.SyntheticSymbolKind || (e.SyntheticSymbolKind = {}));
            var te;
            (function(r) {
              r[r.This = 0] = "This", r[r.Identifier = 1] = "Identifier", r[r.AssertsThis = 2] = "AssertsThis", r[r.AssertsIdentifier = 3] = "AssertsIdentifier";
            })(te = e.TypePredicateKind || (e.TypePredicateKind = {}));
            var Je;
            (function(r) {
              r[r.Unknown = 0] = "Unknown", r[r.TypeWithConstructSignatureAndValue = 1] = "TypeWithConstructSignatureAndValue", r[r.VoidNullableOrNeverType = 2] = "VoidNullableOrNeverType", r[r.NumberLikeType = 3] = "NumberLikeType", r[r.BigIntLikeType = 4] = "BigIntLikeType", r[r.StringLikeType = 5] = "StringLikeType", r[r.BooleanType = 6] = "BooleanType", r[r.ArrayLikeType = 7] = "ArrayLikeType", r[r.ESSymbolType = 8] = "ESSymbolType", r[r.Promise = 9] = "Promise", r[r.TypeWithCallSignature = 10] = "TypeWithCallSignature", r[r.ObjectType = 11] = "ObjectType";
            })(Je = e.TypeReferenceSerializationKind || (e.TypeReferenceSerializationKind = {}));
            var qe;
            (function(r) {
              r[r.None = 0] = "None", r[r.FunctionScopedVariable = 1] = "FunctionScopedVariable", r[r.BlockScopedVariable = 2] = "BlockScopedVariable", r[r.Property = 4] = "Property", r[r.EnumMember = 8] = "EnumMember", r[r.Function = 16] = "Function", r[r.Class = 32] = "Class", r[r.Interface = 64] = "Interface", r[r.ConstEnum = 128] = "ConstEnum", r[r.RegularEnum = 256] = "RegularEnum", r[r.ValueModule = 512] = "ValueModule", r[r.NamespaceModule = 1024] = "NamespaceModule", r[r.TypeLiteral = 2048] = "TypeLiteral", r[r.ObjectLiteral = 4096] = "ObjectLiteral", r[r.Method = 8192] = "Method", r[r.Constructor = 16384] = "Constructor", r[r.GetAccessor = 32768] = "GetAccessor", r[r.SetAccessor = 65536] = "SetAccessor", r[r.Signature = 131072] = "Signature", r[r.TypeParameter = 262144] = "TypeParameter", r[r.TypeAlias = 524288] = "TypeAlias", r[r.ExportValue = 1048576] = "ExportValue", r[r.Alias = 2097152] = "Alias", r[r.Prototype = 4194304] = "Prototype", r[r.ExportStar = 8388608] = "ExportStar", r[r.Optional = 16777216] = "Optional", r[r.Transient = 33554432] = "Transient", r[r.Assignment = 67108864] = "Assignment", r[r.ModuleExports = 134217728] = "ModuleExports", r[r.All = 67108863] = "All", r[r.Enum = 384] = "Enum", r[r.Variable = 3] = "Variable", r[r.Value = 111551] = "Value", r[r.Type = 788968] = "Type", r[r.Namespace = 1920] = "Namespace", r[r.Module = 1536] = "Module", r[r.Accessor = 98304] = "Accessor", r[r.FunctionScopedVariableExcludes = 111550] = "FunctionScopedVariableExcludes", r[r.BlockScopedVariableExcludes = 111551] = "BlockScopedVariableExcludes", r[r.ParameterExcludes = 111551] = "ParameterExcludes", r[r.PropertyExcludes = 0] = "PropertyExcludes", r[r.EnumMemberExcludes = 900095] = "EnumMemberExcludes", r[r.FunctionExcludes = 110991] = "FunctionExcludes", r[r.ClassExcludes = 899503] = "ClassExcludes", r[r.InterfaceExcludes = 788872] = "InterfaceExcludes", r[r.RegularEnumExcludes = 899327] = "RegularEnumExcludes", r[r.ConstEnumExcludes = 899967] = "ConstEnumExcludes", r[r.ValueModuleExcludes = 110735] = "ValueModuleExcludes", r[r.NamespaceModuleExcludes = 0] = "NamespaceModuleExcludes", r[r.MethodExcludes = 103359] = "MethodExcludes", r[r.GetAccessorExcludes = 46015] = "GetAccessorExcludes", r[r.SetAccessorExcludes = 78783] = "SetAccessorExcludes", r[r.AccessorExcludes = 13247] = "AccessorExcludes", r[r.TypeParameterExcludes = 526824] = "TypeParameterExcludes", r[r.TypeAliasExcludes = 788968] = "TypeAliasExcludes", r[r.AliasExcludes = 2097152] = "AliasExcludes", r[r.ModuleMember = 2623475] = "ModuleMember", r[r.ExportHasLocal = 944] = "ExportHasLocal", r[r.BlockScoped = 418] = "BlockScoped", r[r.PropertyOrAccessor = 98308] = "PropertyOrAccessor", r[r.ClassMember = 106500] = "ClassMember", r[r.ExportSupportsDefaultModifier = 112] = "ExportSupportsDefaultModifier", r[r.ExportDoesNotSupportDefaultModifier = -113] = "ExportDoesNotSupportDefaultModifier", r[r.Classifiable = 2885600] = "Classifiable", r[r.LateBindingContainer = 6256] = "LateBindingContainer";
            })(qe = e.SymbolFlags || (e.SymbolFlags = {}));
            var ge;
            (function(r) {
              r[r.Numeric = 0] = "Numeric", r[r.Literal = 1] = "Literal";
            })(ge = e.EnumKind || (e.EnumKind = {}));
            var ie;
            (function(r) {
              r[r.Instantiated = 1] = "Instantiated", r[r.SyntheticProperty = 2] = "SyntheticProperty", r[r.SyntheticMethod = 4] = "SyntheticMethod", r[r.Readonly = 8] = "Readonly", r[r.ReadPartial = 16] = "ReadPartial", r[r.WritePartial = 32] = "WritePartial", r[r.HasNonUniformType = 64] = "HasNonUniformType", r[r.HasLiteralType = 128] = "HasLiteralType", r[r.ContainsPublic = 256] = "ContainsPublic", r[r.ContainsProtected = 512] = "ContainsProtected", r[r.ContainsPrivate = 1024] = "ContainsPrivate", r[r.ContainsStatic = 2048] = "ContainsStatic", r[r.Late = 4096] = "Late", r[r.ReverseMapped = 8192] = "ReverseMapped", r[r.OptionalParameter = 16384] = "OptionalParameter", r[r.RestParameter = 32768] = "RestParameter", r[r.DeferredType = 65536] = "DeferredType", r[r.HasNeverType = 131072] = "HasNeverType", r[r.Mapped = 262144] = "Mapped", r[r.StripOptional = 524288] = "StripOptional", r[r.Unresolved = 1048576] = "Unresolved", r[r.Synthetic = 6] = "Synthetic", r[r.Discriminant = 192] = "Discriminant", r[r.Partial = 48] = "Partial";
            })(ie = e.CheckFlags || (e.CheckFlags = {}));
            var G;
            (function(r) {
              r.Call = "__call", r.Constructor = "__constructor", r.New = "__new", r.Index = "__index", r.ExportStar = "__export", r.Global = "__global", r.Missing = "__missing", r.Type = "__type", r.Object = "__object", r.JSXAttributes = "__jsxAttributes", r.Class = "__class", r.Function = "__function", r.Computed = "__computed", r.Resolving = "__resolving__", r.ExportEquals = "export=", r.Default = "default", r.This = "this";
            })(G = e.InternalSymbolName || (e.InternalSymbolName = {}));
            var pe;
            (function(r) {
              r[r.TypeChecked = 1] = "TypeChecked", r[r.LexicalThis = 2] = "LexicalThis", r[r.CaptureThis = 4] = "CaptureThis", r[r.CaptureNewTarget = 8] = "CaptureNewTarget", r[r.SuperInstance = 256] = "SuperInstance", r[r.SuperStatic = 512] = "SuperStatic", r[r.ContextChecked = 1024] = "ContextChecked", r[r.MethodWithSuperPropertyAccessInAsync = 2048] = "MethodWithSuperPropertyAccessInAsync", r[r.MethodWithSuperPropertyAssignmentInAsync = 4096] = "MethodWithSuperPropertyAssignmentInAsync", r[r.CaptureArguments = 8192] = "CaptureArguments", r[r.EnumValuesComputed = 16384] = "EnumValuesComputed", r[r.LexicalModuleMergesWithClass = 32768] = "LexicalModuleMergesWithClass", r[r.LoopWithCapturedBlockScopedBinding = 65536] = "LoopWithCapturedBlockScopedBinding", r[r.ContainsCapturedBlockScopeBinding = 131072] = "ContainsCapturedBlockScopeBinding", r[r.CapturedBlockScopedBinding = 262144] = "CapturedBlockScopedBinding", r[r.BlockScopedBindingInLoop = 524288] = "BlockScopedBindingInLoop", r[r.ClassWithBodyScopedClassBinding = 1048576] = "ClassWithBodyScopedClassBinding", r[r.BodyScopedClassBinding = 2097152] = "BodyScopedClassBinding", r[r.NeedsLoopOutParameter = 4194304] = "NeedsLoopOutParameter", r[r.AssignmentsMarked = 8388608] = "AssignmentsMarked", r[r.ClassWithConstructorReference = 16777216] = "ClassWithConstructorReference", r[r.ConstructorReferenceInClass = 33554432] = "ConstructorReferenceInClass", r[r.ContainsClassWithPrivateIdentifiers = 67108864] = "ContainsClassWithPrivateIdentifiers", r[r.ContainsSuperPropertyInStaticInitializer = 134217728] = "ContainsSuperPropertyInStaticInitializer", r[r.InCheckIdentifier = 268435456] = "InCheckIdentifier";
            })(pe = e.NodeCheckFlags || (e.NodeCheckFlags = {}));
            var j;
            (function(r) {
              r[r.Any = 1] = "Any", r[r.Unknown = 2] = "Unknown", r[r.String = 4] = "String", r[r.Number = 8] = "Number", r[r.Boolean = 16] = "Boolean", r[r.Enum = 32] = "Enum", r[r.BigInt = 64] = "BigInt", r[r.StringLiteral = 128] = "StringLiteral", r[r.NumberLiteral = 256] = "NumberLiteral", r[r.BooleanLiteral = 512] = "BooleanLiteral", r[r.EnumLiteral = 1024] = "EnumLiteral", r[r.BigIntLiteral = 2048] = "BigIntLiteral", r[r.ESSymbol = 4096] = "ESSymbol", r[r.UniqueESSymbol = 8192] = "UniqueESSymbol", r[r.Void = 16384] = "Void", r[r.Undefined = 32768] = "Undefined", r[r.Null = 65536] = "Null", r[r.Never = 131072] = "Never", r[r.TypeParameter = 262144] = "TypeParameter", r[r.Object = 524288] = "Object", r[r.Union = 1048576] = "Union", r[r.Intersection = 2097152] = "Intersection", r[r.Index = 4194304] = "Index", r[r.IndexedAccess = 8388608] = "IndexedAccess", r[r.Conditional = 16777216] = "Conditional", r[r.Substitution = 33554432] = "Substitution", r[r.NonPrimitive = 67108864] = "NonPrimitive", r[r.TemplateLiteral = 134217728] = "TemplateLiteral", r[r.StringMapping = 268435456] = "StringMapping", r[r.AnyOrUnknown = 3] = "AnyOrUnknown", r[r.Nullable = 98304] = "Nullable", r[r.Literal = 2944] = "Literal", r[r.Unit = 109440] = "Unit", r[r.StringOrNumberLiteral = 384] = "StringOrNumberLiteral", r[r.StringOrNumberLiteralOrUnique = 8576] = "StringOrNumberLiteralOrUnique", r[r.DefinitelyFalsy = 117632] = "DefinitelyFalsy", r[r.PossiblyFalsy = 117724] = "PossiblyFalsy", r[r.Intrinsic = 67359327] = "Intrinsic", r[r.Primitive = 131068] = "Primitive", r[r.StringLike = 402653316] = "StringLike", r[r.NumberLike = 296] = "NumberLike", r[r.BigIntLike = 2112] = "BigIntLike", r[r.BooleanLike = 528] = "BooleanLike", r[r.EnumLike = 1056] = "EnumLike", r[r.ESSymbolLike = 12288] = "ESSymbolLike", r[r.VoidLike = 49152] = "VoidLike", r[r.DefinitelyNonNullable = 470302716] = "DefinitelyNonNullable", r[r.DisjointDomains = 469892092] = "DisjointDomains", r[r.UnionOrIntersection = 3145728] = "UnionOrIntersection", r[r.StructuredType = 3670016] = "StructuredType", r[r.TypeVariable = 8650752] = "TypeVariable", r[r.InstantiableNonPrimitive = 58982400] = "InstantiableNonPrimitive", r[r.InstantiablePrimitive = 406847488] = "InstantiablePrimitive", r[r.Instantiable = 465829888] = "Instantiable", r[r.StructuredOrInstantiable = 469499904] = "StructuredOrInstantiable", r[r.ObjectFlagsType = 3899393] = "ObjectFlagsType", r[r.Simplifiable = 25165824] = "Simplifiable", r[r.Singleton = 67358815] = "Singleton", r[r.Narrowable = 536624127] = "Narrowable", r[r.IncludesMask = 205258751] = "IncludesMask", r[r.IncludesMissingType = 262144] = "IncludesMissingType", r[r.IncludesNonWideningType = 4194304] = "IncludesNonWideningType", r[r.IncludesWildcard = 8388608] = "IncludesWildcard", r[r.IncludesEmptyObject = 16777216] = "IncludesEmptyObject", r[r.IncludesInstantiable = 33554432] = "IncludesInstantiable", r[r.NotPrimitiveUnion = 36323363] = "NotPrimitiveUnion";
            })(j = e.TypeFlags || (e.TypeFlags = {}));
            var be;
            (function(r) {
              r[r.Class = 1] = "Class", r[r.Interface = 2] = "Interface", r[r.Reference = 4] = "Reference", r[r.Tuple = 8] = "Tuple", r[r.Anonymous = 16] = "Anonymous", r[r.Mapped = 32] = "Mapped", r[r.Instantiated = 64] = "Instantiated", r[r.ObjectLiteral = 128] = "ObjectLiteral", r[r.EvolvingArray = 256] = "EvolvingArray", r[r.ObjectLiteralPatternWithComputedProperties = 512] = "ObjectLiteralPatternWithComputedProperties", r[r.ReverseMapped = 1024] = "ReverseMapped", r[r.JsxAttributes = 2048] = "JsxAttributes", r[r.JSLiteral = 4096] = "JSLiteral", r[r.FreshLiteral = 8192] = "FreshLiteral", r[r.ArrayLiteral = 16384] = "ArrayLiteral", r[r.PrimitiveUnion = 32768] = "PrimitiveUnion", r[r.ContainsWideningType = 65536] = "ContainsWideningType", r[r.ContainsObjectOrArrayLiteral = 131072] = "ContainsObjectOrArrayLiteral", r[r.NonInferrableType = 262144] = "NonInferrableType", r[r.CouldContainTypeVariablesComputed = 524288] = "CouldContainTypeVariablesComputed", r[r.CouldContainTypeVariables = 1048576] = "CouldContainTypeVariables", r[r.ClassOrInterface = 3] = "ClassOrInterface", r[r.RequiresWidening = 196608] = "RequiresWidening", r[r.PropagatingFlags = 458752] = "PropagatingFlags", r[r.ObjectTypeKindMask = 1343] = "ObjectTypeKindMask", r[r.ContainsSpread = 2097152] = "ContainsSpread", r[r.ObjectRestType = 4194304] = "ObjectRestType", r[r.InstantiationExpressionType = 8388608] = "InstantiationExpressionType", r[r.IsClassInstanceClone = 16777216] = "IsClassInstanceClone", r[r.IdenticalBaseTypeCalculated = 33554432] = "IdenticalBaseTypeCalculated", r[r.IdenticalBaseTypeExists = 67108864] = "IdenticalBaseTypeExists", r[r.IsGenericTypeComputed = 2097152] = "IsGenericTypeComputed", r[r.IsGenericObjectType = 4194304] = "IsGenericObjectType", r[r.IsGenericIndexType = 8388608] = "IsGenericIndexType", r[r.IsGenericType = 12582912] = "IsGenericType", r[r.ContainsIntersections = 16777216] = "ContainsIntersections", r[r.IsUnknownLikeUnionComputed = 33554432] = "IsUnknownLikeUnionComputed", r[r.IsUnknownLikeUnion = 67108864] = "IsUnknownLikeUnion", r[r.IsNeverIntersectionComputed = 16777216] = "IsNeverIntersectionComputed", r[r.IsNeverIntersection = 33554432] = "IsNeverIntersection";
            })(be = e.ObjectFlags || (e.ObjectFlags = {}));
            var $e;
            (function(r) {
              r[r.Invariant = 0] = "Invariant", r[r.Covariant = 1] = "Covariant", r[r.Contravariant = 2] = "Contravariant", r[r.Bivariant = 3] = "Bivariant", r[r.Independent = 4] = "Independent", r[r.VarianceMask = 7] = "VarianceMask", r[r.Unmeasurable = 8] = "Unmeasurable", r[r.Unreliable = 16] = "Unreliable", r[r.AllowsStructuralFallback = 24] = "AllowsStructuralFallback";
            })($e = e.VarianceFlags || (e.VarianceFlags = {}));
            var Re;
            (function(r) {
              r[r.Required = 1] = "Required", r[r.Optional = 2] = "Optional", r[r.Rest = 4] = "Rest", r[r.Variadic = 8] = "Variadic", r[r.Fixed = 3] = "Fixed", r[r.Variable = 12] = "Variable", r[r.NonRequired = 14] = "NonRequired", r[r.NonRest = 11] = "NonRest";
            })(Re = e.ElementFlags || (e.ElementFlags = {}));
            var Fe;
            (function(r) {
              r[r.None = 0] = "None", r[r.IncludeUndefined = 1] = "IncludeUndefined", r[r.NoIndexSignatures = 2] = "NoIndexSignatures", r[r.Writing = 4] = "Writing", r[r.CacheSymbol = 8] = "CacheSymbol", r[r.NoTupleBoundsCheck = 16] = "NoTupleBoundsCheck", r[r.ExpressionPosition = 32] = "ExpressionPosition", r[r.ReportDeprecated = 64] = "ReportDeprecated", r[r.SuppressNoImplicitAnyError = 128] = "SuppressNoImplicitAnyError", r[r.Contextual = 256] = "Contextual", r[r.Persistent = 1] = "Persistent";
            })(Fe = e.AccessFlags || (e.AccessFlags = {}));
            var dr;
            (function(r) {
              r[r.Component = 0] = "Component", r[r.Function = 1] = "Function", r[r.Mixed = 2] = "Mixed";
            })(dr = e.JsxReferenceKind || (e.JsxReferenceKind = {}));
            var ze;
            (function(r) {
              r[r.Call = 0] = "Call", r[r.Construct = 1] = "Construct";
            })(ze = e.SignatureKind || (e.SignatureKind = {}));
            var ve;
            (function(r) {
              r[r.None = 0] = "None", r[r.HasRestParameter = 1] = "HasRestParameter", r[r.HasLiteralTypes = 2] = "HasLiteralTypes", r[r.Abstract = 4] = "Abstract", r[r.IsInnerCallChain = 8] = "IsInnerCallChain", r[r.IsOuterCallChain = 16] = "IsOuterCallChain", r[r.IsUntypedSignatureInJSFile = 32] = "IsUntypedSignatureInJSFile", r[r.PropagatingFlags = 39] = "PropagatingFlags", r[r.CallChainFlags = 24] = "CallChainFlags";
            })(ve = e.SignatureFlags || (e.SignatureFlags = {}));
            var er;
            (function(r) {
              r[r.String = 0] = "String", r[r.Number = 1] = "Number";
            })(er = e.IndexKind || (e.IndexKind = {}));
            var ar;
            (function(r) {
              r[r.Simple = 0] = "Simple", r[r.Array = 1] = "Array", r[r.Deferred = 2] = "Deferred", r[r.Function = 3] = "Function", r[r.Composite = 4] = "Composite", r[r.Merged = 5] = "Merged";
            })(ar = e.TypeMapKind || (e.TypeMapKind = {}));
            var Cr;
            (function(r) {
              r[r.NakedTypeVariable = 1] = "NakedTypeVariable", r[r.SpeculativeTuple = 2] = "SpeculativeTuple", r[r.SubstituteSource = 4] = "SubstituteSource", r[r.HomomorphicMappedType = 8] = "HomomorphicMappedType", r[r.PartialHomomorphicMappedType = 16] = "PartialHomomorphicMappedType", r[r.MappedTypeConstraint = 32] = "MappedTypeConstraint", r[r.ContravariantConditional = 64] = "ContravariantConditional", r[r.ReturnType = 128] = "ReturnType", r[r.LiteralKeyof = 256] = "LiteralKeyof", r[r.NoConstraints = 512] = "NoConstraints", r[r.AlwaysStrict = 1024] = "AlwaysStrict", r[r.MaxValue = 2048] = "MaxValue", r[r.PriorityImpliesCombination = 416] = "PriorityImpliesCombination", r[r.Circularity = -1] = "Circularity";
            })(Cr = e.InferencePriority || (e.InferencePriority = {}));
            var Ce;
            (function(r) {
              r[r.None = 0] = "None", r[r.NoDefault = 1] = "NoDefault", r[r.AnyDefault = 2] = "AnyDefault", r[r.SkippedGenericFunction = 4] = "SkippedGenericFunction";
            })(Ce = e.InferenceFlags || (e.InferenceFlags = {}));
            var Xe;
            (function(r) {
              r[r.False = 0] = "False", r[r.Unknown = 1] = "Unknown", r[r.Maybe = 3] = "Maybe", r[r.True = -1] = "True";
            })(Xe = e.Ternary || (e.Ternary = {}));
            var gr;
            (function(r) {
              r[r.None = 0] = "None", r[r.ExportsProperty = 1] = "ExportsProperty", r[r.ModuleExports = 2] = "ModuleExports", r[r.PrototypeProperty = 3] = "PrototypeProperty", r[r.ThisProperty = 4] = "ThisProperty", r[r.Property = 5] = "Property", r[r.Prototype = 6] = "Prototype", r[r.ObjectDefinePropertyValue = 7] = "ObjectDefinePropertyValue", r[r.ObjectDefinePropertyExports = 8] = "ObjectDefinePropertyExports", r[r.ObjectDefinePrototypeProperty = 9] = "ObjectDefinePrototypeProperty";
            })(gr = e.AssignmentDeclarationKind || (e.AssignmentDeclarationKind = {}));
            var X;
            (function(r) {
              r[r.Warning = 0] = "Warning", r[r.Error = 1] = "Error", r[r.Suggestion = 2] = "Suggestion", r[r.Message = 3] = "Message";
            })(X = e.DiagnosticCategory || (e.DiagnosticCategory = {}));
            function Ee(r, ct) {
              ct === void 0 && (ct = true);
              var ft = X[r.category];
              return ct ? ft.toLowerCase() : ft;
            }
            __name(Ee, "Ee");
            e.diagnosticCategoryName = Ee;
            var we;
            (function(r) {
              r[r.Classic = 1] = "Classic", r[r.NodeJs = 2] = "NodeJs", r[r.Node16 = 3] = "Node16", r[r.NodeNext = 99] = "NodeNext";
            })(we = e.ModuleResolutionKind || (e.ModuleResolutionKind = {}));
            var he;
            (function(r) {
              r[r.Legacy = 1] = "Legacy", r[r.Auto = 2] = "Auto", r[r.Force = 3] = "Force";
            })(he = e.ModuleDetectionKind || (e.ModuleDetectionKind = {}));
            var yr;
            (function(r) {
              r[r.FixedPollingInterval = 0] = "FixedPollingInterval", r[r.PriorityPollingInterval = 1] = "PriorityPollingInterval", r[r.DynamicPriorityPolling = 2] = "DynamicPriorityPolling", r[r.FixedChunkSizePolling = 3] = "FixedChunkSizePolling", r[r.UseFsEvents = 4] = "UseFsEvents", r[r.UseFsEventsOnParentDirectory = 5] = "UseFsEventsOnParentDirectory";
            })(yr = e.WatchFileKind || (e.WatchFileKind = {}));
            var kr;
            (function(r) {
              r[r.UseFsEvents = 0] = "UseFsEvents", r[r.FixedPollingInterval = 1] = "FixedPollingInterval", r[r.DynamicPriorityPolling = 2] = "DynamicPriorityPolling", r[r.FixedChunkSizePolling = 3] = "FixedChunkSizePolling";
            })(kr = e.WatchDirectoryKind || (e.WatchDirectoryKind = {}));
            var nr;
            (function(r) {
              r[r.FixedInterval = 0] = "FixedInterval", r[r.PriorityInterval = 1] = "PriorityInterval", r[r.DynamicPriority = 2] = "DynamicPriority", r[r.FixedChunkSize = 3] = "FixedChunkSize";
            })(nr = e.PollingWatchKind || (e.PollingWatchKind = {}));
            var tr;
            (function(r) {
              r[r.None = 0] = "None", r[r.CommonJS = 1] = "CommonJS", r[r.AMD = 2] = "AMD", r[r.UMD = 3] = "UMD", r[r.System = 4] = "System", r[r.ES2015 = 5] = "ES2015", r[r.ES2020 = 6] = "ES2020", r[r.ES2022 = 7] = "ES2022", r[r.ESNext = 99] = "ESNext", r[r.Node16 = 100] = "Node16", r[r.NodeNext = 199] = "NodeNext";
            })(tr = e.ModuleKind || (e.ModuleKind = {}));
            var Lr;
            (function(r) {
              r[r.None = 0] = "None", r[r.Preserve = 1] = "Preserve", r[r.React = 2] = "React", r[r.ReactNative = 3] = "ReactNative", r[r.ReactJSX = 4] = "ReactJSX", r[r.ReactJSXDev = 5] = "ReactJSXDev";
            })(Lr = e.JsxEmit || (e.JsxEmit = {}));
            var zr;
            (function(r) {
              r[r.Remove = 0] = "Remove", r[r.Preserve = 1] = "Preserve", r[r.Error = 2] = "Error";
            })(zr = e.ImportsNotUsedAsValues || (e.ImportsNotUsedAsValues = {}));
            var ye;
            (function(r) {
              r[r.CarriageReturnLineFeed = 0] = "CarriageReturnLineFeed", r[r.LineFeed = 1] = "LineFeed";
            })(ye = e.NewLineKind || (e.NewLineKind = {}));
            var ir;
            (function(r) {
              r[r.Unknown = 0] = "Unknown", r[r.JS = 1] = "JS", r[r.JSX = 2] = "JSX", r[r.TS = 3] = "TS", r[r.TSX = 4] = "TSX", r[r.External = 5] = "External", r[r.JSON = 6] = "JSON", r[r.Deferred = 7] = "Deferred";
            })(ir = e.ScriptKind || (e.ScriptKind = {}));
            var Dr;
            (function(r) {
              r[r.ES3 = 0] = "ES3", r[r.ES5 = 1] = "ES5", r[r.ES2015 = 2] = "ES2015", r[r.ES2016 = 3] = "ES2016", r[r.ES2017 = 4] = "ES2017", r[r.ES2018 = 5] = "ES2018", r[r.ES2019 = 6] = "ES2019", r[r.ES2020 = 7] = "ES2020", r[r.ES2021 = 8] = "ES2021", r[r.ES2022 = 9] = "ES2022", r[r.ESNext = 99] = "ESNext", r[r.JSON = 100] = "JSON", r[r.Latest = 99] = "Latest";
            })(Dr = e.ScriptTarget || (e.ScriptTarget = {}));
            var Pr;
            (function(r) {
              r[r.Standard = 0] = "Standard", r[r.JSX = 1] = "JSX";
            })(Pr = e.LanguageVariant || (e.LanguageVariant = {}));
            var Br;
            (function(r) {
              r[r.None = 0] = "None", r[r.Recursive = 1] = "Recursive";
            })(Br = e.WatchDirectoryFlags || (e.WatchDirectoryFlags = {}));
            var ut;
            (function(r) {
              r[r.nullCharacter = 0] = "nullCharacter", r[r.maxAsciiCharacter = 127] = "maxAsciiCharacter", r[r.lineFeed = 10] = "lineFeed", r[r.carriageReturn = 13] = "carriageReturn", r[r.lineSeparator = 8232] = "lineSeparator", r[r.paragraphSeparator = 8233] = "paragraphSeparator", r[r.nextLine = 133] = "nextLine", r[r.space = 32] = "space", r[r.nonBreakingSpace = 160] = "nonBreakingSpace", r[r.enQuad = 8192] = "enQuad", r[r.emQuad = 8193] = "emQuad", r[r.enSpace = 8194] = "enSpace", r[r.emSpace = 8195] = "emSpace", r[r.threePerEmSpace = 8196] = "threePerEmSpace", r[r.fourPerEmSpace = 8197] = "fourPerEmSpace", r[r.sixPerEmSpace = 8198] = "sixPerEmSpace", r[r.figureSpace = 8199] = "figureSpace", r[r.punctuationSpace = 8200] = "punctuationSpace", r[r.thinSpace = 8201] = "thinSpace", r[r.hairSpace = 8202] = "hairSpace", r[r.zeroWidthSpace = 8203] = "zeroWidthSpace", r[r.narrowNoBreakSpace = 8239] = "narrowNoBreakSpace", r[r.ideographicSpace = 12288] = "ideographicSpace", r[r.mathematicalSpace = 8287] = "mathematicalSpace", r[r.ogham = 5760] = "ogham", r[r._ = 95] = "_", r[r.$ = 36] = "$", r[r._0 = 48] = "_0", r[r._1 = 49] = "_1", r[r._2 = 50] = "_2", r[r._3 = 51] = "_3", r[r._4 = 52] = "_4", r[r._5 = 53] = "_5", r[r._6 = 54] = "_6", r[r._7 = 55] = "_7", r[r._8 = 56] = "_8", r[r._9 = 57] = "_9", r[r.a = 97] = "a", r[r.b = 98] = "b", r[r.c = 99] = "c", r[r.d = 100] = "d", r[r.e = 101] = "e", r[r.f = 102] = "f", r[r.g = 103] = "g", r[r.h = 104] = "h", r[r.i = 105] = "i", r[r.j = 106] = "j", r[r.k = 107] = "k", r[r.l = 108] = "l", r[r.m = 109] = "m", r[r.n = 110] = "n", r[r.o = 111] = "o", r[r.p = 112] = "p", r[r.q = 113] = "q", r[r.r = 114] = "r", r[r.s = 115] = "s", r[r.t = 116] = "t", r[r.u = 117] = "u", r[r.v = 118] = "v", r[r.w = 119] = "w", r[r.x = 120] = "x", r[r.y = 121] = "y", r[r.z = 122] = "z", r[r.A = 65] = "A", r[r.B = 66] = "B", r[r.C = 67] = "C", r[r.D = 68] = "D", r[r.E = 69] = "E", r[r.F = 70] = "F", r[r.G = 71] = "G", r[r.H = 72] = "H", r[r.I = 73] = "I", r[r.J = 74] = "J", r[r.K = 75] = "K", r[r.L = 76] = "L", r[r.M = 77] = "M", r[r.N = 78] = "N", r[r.O = 79] = "O", r[r.P = 80] = "P", r[r.Q = 81] = "Q", r[r.R = 82] = "R", r[r.S = 83] = "S", r[r.T = 84] = "T", r[r.U = 85] = "U", r[r.V = 86] = "V", r[r.W = 87] = "W", r[r.X = 88] = "X", r[r.Y = 89] = "Y", r[r.Z = 90] = "Z", r[r.ampersand = 38] = "ampersand", r[r.asterisk = 42] = "asterisk", r[r.at = 64] = "at", r[r.backslash = 92] = "backslash", r[r.backtick = 96] = "backtick", r[r.bar = 124] = "bar", r[r.caret = 94] = "caret", r[r.closeBrace = 125] = "closeBrace", r[r.closeBracket = 93] = "closeBracket", r[r.closeParen = 41] = "closeParen", r[r.colon = 58] = "colon", r[r.comma = 44] = "comma", r[r.dot = 46] = "dot", r[r.doubleQuote = 34] = "doubleQuote", r[r.equals = 61] = "equals", r[r.exclamation = 33] = "exclamation", r[r.greaterThan = 62] = "greaterThan", r[r.hash = 35] = "hash", r[r.lessThan = 60] = "lessThan", r[r.minus = 45] = "minus", r[r.openBrace = 123] = "openBrace", r[r.openBracket = 91] = "openBracket", r[r.openParen = 40] = "openParen", r[r.percent = 37] = "percent", r[r.plus = 43] = "plus", r[r.question = 63] = "question", r[r.semicolon = 59] = "semicolon", r[r.singleQuote = 39] = "singleQuote", r[r.slash = 47] = "slash", r[r.tilde = 126] = "tilde", r[r.backspace = 8] = "backspace", r[r.formFeed = 12] = "formFeed", r[r.byteOrderMark = 65279] = "byteOrderMark", r[r.tab = 9] = "tab", r[r.verticalTab = 11] = "verticalTab";
            })(ut = e.CharacterCodes || (e.CharacterCodes = {}));
            var rt;
            (function(r) {
              r.Ts = ".ts", r.Tsx = ".tsx", r.Dts = ".d.ts", r.Js = ".js", r.Jsx = ".jsx", r.Json = ".json", r.TsBuildInfo = ".tsbuildinfo", r.Mjs = ".mjs", r.Mts = ".mts", r.Dmts = ".d.mts", r.Cjs = ".cjs", r.Cts = ".cts", r.Dcts = ".d.cts";
            })(rt = e.Extension || (e.Extension = {}));
            var Z;
            (function(r) {
              r[r.None = 0] = "None", r[r.ContainsTypeScript = 1] = "ContainsTypeScript", r[r.ContainsJsx = 2] = "ContainsJsx", r[r.ContainsESNext = 4] = "ContainsESNext", r[r.ContainsES2022 = 8] = "ContainsES2022", r[r.ContainsES2021 = 16] = "ContainsES2021", r[r.ContainsES2020 = 32] = "ContainsES2020", r[r.ContainsES2019 = 64] = "ContainsES2019", r[r.ContainsES2018 = 128] = "ContainsES2018", r[r.ContainsES2017 = 256] = "ContainsES2017", r[r.ContainsES2016 = 512] = "ContainsES2016", r[r.ContainsES2015 = 1024] = "ContainsES2015", r[r.ContainsGenerator = 2048] = "ContainsGenerator", r[r.ContainsDestructuringAssignment = 4096] = "ContainsDestructuringAssignment", r[r.ContainsTypeScriptClassSyntax = 8192] = "ContainsTypeScriptClassSyntax", r[r.ContainsLexicalThis = 16384] = "ContainsLexicalThis", r[r.ContainsRestOrSpread = 32768] = "ContainsRestOrSpread", r[r.ContainsObjectRestOrSpread = 65536] = "ContainsObjectRestOrSpread", r[r.ContainsComputedPropertyName = 131072] = "ContainsComputedPropertyName", r[r.ContainsBlockScopedBinding = 262144] = "ContainsBlockScopedBinding", r[r.ContainsBindingPattern = 524288] = "ContainsBindingPattern", r[r.ContainsYield = 1048576] = "ContainsYield", r[r.ContainsAwait = 2097152] = "ContainsAwait", r[r.ContainsHoistedDeclarationOrCompletion = 4194304] = "ContainsHoistedDeclarationOrCompletion", r[r.ContainsDynamicImport = 8388608] = "ContainsDynamicImport", r[r.ContainsClassFields = 16777216] = "ContainsClassFields", r[r.ContainsDecorators = 33554432] = "ContainsDecorators", r[r.ContainsPossibleTopLevelAwait = 67108864] = "ContainsPossibleTopLevelAwait", r[r.ContainsLexicalSuper = 134217728] = "ContainsLexicalSuper", r[r.ContainsUpdateExpressionForIdentifier = 268435456] = "ContainsUpdateExpressionForIdentifier", r[r.ContainsPrivateIdentifierInExpression = 536870912] = "ContainsPrivateIdentifierInExpression", r[r.HasComputedFlags = -2147483648] = "HasComputedFlags", r[r.AssertTypeScript = 1] = "AssertTypeScript", r[r.AssertJsx = 2] = "AssertJsx", r[r.AssertESNext = 4] = "AssertESNext", r[r.AssertES2022 = 8] = "AssertES2022", r[r.AssertES2021 = 16] = "AssertES2021", r[r.AssertES2020 = 32] = "AssertES2020", r[r.AssertES2019 = 64] = "AssertES2019", r[r.AssertES2018 = 128] = "AssertES2018", r[r.AssertES2017 = 256] = "AssertES2017", r[r.AssertES2016 = 512] = "AssertES2016", r[r.AssertES2015 = 1024] = "AssertES2015", r[r.AssertGenerator = 2048] = "AssertGenerator", r[r.AssertDestructuringAssignment = 4096] = "AssertDestructuringAssignment", r[r.OuterExpressionExcludes = -2147483648] = "OuterExpressionExcludes", r[r.PropertyAccessExcludes = -2147483648] = "PropertyAccessExcludes", r[r.NodeExcludes = -2147483648] = "NodeExcludes", r[r.ArrowFunctionExcludes = -2072174592] = "ArrowFunctionExcludes", r[r.FunctionExcludes = -1937940480] = "FunctionExcludes", r[r.ConstructorExcludes = -1937948672] = "ConstructorExcludes", r[r.MethodOrAccessorExcludes = -2005057536] = "MethodOrAccessorExcludes", r[r.PropertyExcludes = -2013249536] = "PropertyExcludes", r[r.ClassExcludes = -2147344384] = "ClassExcludes", r[r.ModuleExcludes = -1941676032] = "ModuleExcludes", r[r.TypeExcludes = -2] = "TypeExcludes", r[r.ObjectLiteralExcludes = -2147278848] = "ObjectLiteralExcludes", r[r.ArrayLiteralOrCallOrNewExcludes = -2147450880] = "ArrayLiteralOrCallOrNewExcludes", r[r.VariableDeclarationListExcludes = -2146893824] = "VariableDeclarationListExcludes", r[r.ParameterExcludes = -2147483648] = "ParameterExcludes", r[r.CatchClauseExcludes = -2147418112] = "CatchClauseExcludes", r[r.BindingPatternExcludes = -2147450880] = "BindingPatternExcludes", r[r.ContainsLexicalThisOrSuper = 134234112] = "ContainsLexicalThisOrSuper", r[r.PropertyNamePropagatingFlags = 134234112] = "PropertyNamePropagatingFlags";
            })(Z = e.TransformFlags || (e.TransformFlags = {}));
            var f;
            (function(r) {
              r[r.TabStop = 0] = "TabStop", r[r.Placeholder = 1] = "Placeholder", r[r.Choice = 2] = "Choice", r[r.Variable = 3] = "Variable";
            })(f = e.SnippetKind || (e.SnippetKind = {}));
            var h;
            (function(r) {
              r[r.None = 0] = "None", r[r.SingleLine = 1] = "SingleLine", r[r.AdviseOnEmitNode = 2] = "AdviseOnEmitNode", r[r.NoSubstitution = 4] = "NoSubstitution", r[r.CapturesThis = 8] = "CapturesThis", r[r.NoLeadingSourceMap = 16] = "NoLeadingSourceMap", r[r.NoTrailingSourceMap = 32] = "NoTrailingSourceMap", r[r.NoSourceMap = 48] = "NoSourceMap", r[r.NoNestedSourceMaps = 64] = "NoNestedSourceMaps", r[r.NoTokenLeadingSourceMaps = 128] = "NoTokenLeadingSourceMaps", r[r.NoTokenTrailingSourceMaps = 256] = "NoTokenTrailingSourceMaps", r[r.NoTokenSourceMaps = 384] = "NoTokenSourceMaps", r[r.NoLeadingComments = 512] = "NoLeadingComments", r[r.NoTrailingComments = 1024] = "NoTrailingComments", r[r.NoComments = 1536] = "NoComments", r[r.NoNestedComments = 2048] = "NoNestedComments", r[r.HelperName = 4096] = "HelperName", r[r.ExportName = 8192] = "ExportName", r[r.LocalName = 16384] = "LocalName", r[r.InternalName = 32768] = "InternalName", r[r.Indented = 65536] = "Indented", r[r.NoIndentation = 131072] = "NoIndentation", r[r.AsyncFunctionBody = 262144] = "AsyncFunctionBody", r[r.ReuseTempVariableScope = 524288] = "ReuseTempVariableScope", r[r.CustomPrologue = 1048576] = "CustomPrologue", r[r.NoHoisting = 2097152] = "NoHoisting", r[r.HasEndOfDeclarationMarker = 4194304] = "HasEndOfDeclarationMarker", r[r.Iterator = 8388608] = "Iterator", r[r.NoAsciiEscaping = 16777216] = "NoAsciiEscaping", r[r.TypeScriptClassWrapper = 33554432] = "TypeScriptClassWrapper", r[r.NeverApplyImportHelper = 67108864] = "NeverApplyImportHelper", r[r.IgnoreSourceNewlines = 134217728] = "IgnoreSourceNewlines", r[r.Immutable = 268435456] = "Immutable", r[r.IndirectCall = 536870912] = "IndirectCall";
            })(h = e.EmitFlags || (e.EmitFlags = {}));
            var ae;
            (function(r) {
              r[r.Extends = 1] = "Extends", r[r.Assign = 2] = "Assign", r[r.Rest = 4] = "Rest", r[r.Decorate = 8] = "Decorate", r[r.Metadata = 16] = "Metadata", r[r.Param = 32] = "Param", r[r.Awaiter = 64] = "Awaiter", r[r.Generator = 128] = "Generator", r[r.Values = 256] = "Values", r[r.Read = 512] = "Read", r[r.SpreadArray = 1024] = "SpreadArray", r[r.Await = 2048] = "Await", r[r.AsyncGenerator = 4096] = "AsyncGenerator", r[r.AsyncDelegator = 8192] = "AsyncDelegator", r[r.AsyncValues = 16384] = "AsyncValues", r[r.ExportStar = 32768] = "ExportStar", r[r.ImportStar = 65536] = "ImportStar", r[r.ImportDefault = 131072] = "ImportDefault", r[r.MakeTemplateObject = 262144] = "MakeTemplateObject", r[r.ClassPrivateFieldGet = 524288] = "ClassPrivateFieldGet", r[r.ClassPrivateFieldSet = 1048576] = "ClassPrivateFieldSet", r[r.ClassPrivateFieldIn = 2097152] = "ClassPrivateFieldIn", r[r.CreateBinding = 4194304] = "CreateBinding", r[r.FirstEmitHelper = 1] = "FirstEmitHelper", r[r.LastEmitHelper = 4194304] = "LastEmitHelper", r[r.ForOfIncludes = 256] = "ForOfIncludes", r[r.ForAwaitOfIncludes = 16384] = "ForAwaitOfIncludes", r[r.AsyncGeneratorIncludes = 6144] = "AsyncGeneratorIncludes", r[r.AsyncDelegatorIncludes = 26624] = "AsyncDelegatorIncludes", r[r.SpreadIncludes = 1536] = "SpreadIncludes";
            })(ae = e.ExternalEmitHelpers || (e.ExternalEmitHelpers = {}));
            var xr;
            (function(r) {
              r[r.SourceFile = 0] = "SourceFile", r[r.Expression = 1] = "Expression", r[r.IdentifierName = 2] = "IdentifierName", r[r.MappedTypeParameter = 3] = "MappedTypeParameter", r[r.Unspecified = 4] = "Unspecified", r[r.EmbeddedStatement = 5] = "EmbeddedStatement", r[r.JsxAttributeValue = 6] = "JsxAttributeValue";
            })(xr = e.EmitHint || (e.EmitHint = {}));
            var jr;
            (function(r) {
              r[r.Parentheses = 1] = "Parentheses", r[r.TypeAssertions = 2] = "TypeAssertions", r[r.NonNullAssertions = 4] = "NonNullAssertions", r[r.PartiallyEmittedExpressions = 8] = "PartiallyEmittedExpressions", r[r.Assertions = 6] = "Assertions", r[r.All = 15] = "All", r[r.ExcludeJSDocTypeAssertion = 16] = "ExcludeJSDocTypeAssertion";
            })(jr = e.OuterExpressionKinds || (e.OuterExpressionKinds = {}));
            var qr;
            (function(r) {
              r[r.None = 0] = "None", r[r.InParameters = 1] = "InParameters", r[r.VariablesHoistedInParameters = 2] = "VariablesHoistedInParameters";
            })(qr = e.LexicalEnvironmentFlags || (e.LexicalEnvironmentFlags = {}));
            var pt;
            (function(r) {
              r.Prologue = "prologue", r.EmitHelpers = "emitHelpers", r.NoDefaultLib = "no-default-lib", r.Reference = "reference", r.Type = "type", r.TypeResolutionModeRequire = "type-require", r.TypeResolutionModeImport = "type-import", r.Lib = "lib", r.Prepend = "prepend", r.Text = "text", r.Internal = "internal";
            })(pt = e.BundleFileSectionKind || (e.BundleFileSectionKind = {}));
            var Ge;
            (function(r) {
              r[r.None = 0] = "None", r[r.SingleLine = 0] = "SingleLine", r[r.MultiLine = 1] = "MultiLine", r[r.PreserveLines = 2] = "PreserveLines", r[r.LinesMask = 3] = "LinesMask", r[r.NotDelimited = 0] = "NotDelimited", r[r.BarDelimited = 4] = "BarDelimited", r[r.AmpersandDelimited = 8] = "AmpersandDelimited", r[r.CommaDelimited = 16] = "CommaDelimited", r[r.AsteriskDelimited = 32] = "AsteriskDelimited", r[r.DelimitersMask = 60] = "DelimitersMask", r[r.AllowTrailingComma = 64] = "AllowTrailingComma", r[r.Indented = 128] = "Indented", r[r.SpaceBetweenBraces = 256] = "SpaceBetweenBraces", r[r.SpaceBetweenSiblings = 512] = "SpaceBetweenSiblings", r[r.Braces = 1024] = "Braces", r[r.Parenthesis = 2048] = "Parenthesis", r[r.AngleBrackets = 4096] = "AngleBrackets", r[r.SquareBrackets = 8192] = "SquareBrackets", r[r.BracketsMask = 15360] = "BracketsMask", r[r.OptionalIfUndefined = 16384] = "OptionalIfUndefined", r[r.OptionalIfEmpty = 32768] = "OptionalIfEmpty", r[r.Optional = 49152] = "Optional", r[r.PreferNewLine = 65536] = "PreferNewLine", r[r.NoTrailingNewLine = 131072] = "NoTrailingNewLine", r[r.NoInterveningComments = 262144] = "NoInterveningComments", r[r.NoSpaceIfEmpty = 524288] = "NoSpaceIfEmpty", r[r.SingleElement = 1048576] = "SingleElement", r[r.SpaceAfterList = 2097152] = "SpaceAfterList", r[r.Modifiers = 2359808] = "Modifiers", r[r.HeritageClauses = 512] = "HeritageClauses", r[r.SingleLineTypeLiteralMembers = 768] = "SingleLineTypeLiteralMembers", r[r.MultiLineTypeLiteralMembers = 32897] = "MultiLineTypeLiteralMembers", r[r.SingleLineTupleTypeElements = 528] = "SingleLineTupleTypeElements", r[r.MultiLineTupleTypeElements = 657] = "MultiLineTupleTypeElements", r[r.UnionTypeConstituents = 516] = "UnionTypeConstituents", r[r.IntersectionTypeConstituents = 520] = "IntersectionTypeConstituents", r[r.ObjectBindingPatternElements = 525136] = "ObjectBindingPatternElements", r[r.ArrayBindingPatternElements = 524880] = "ArrayBindingPatternElements", r[r.ObjectLiteralExpressionProperties = 526226] = "ObjectLiteralExpressionProperties", r[r.ImportClauseEntries = 526226] = "ImportClauseEntries", r[r.ArrayLiteralExpressionElements = 8914] = "ArrayLiteralExpressionElements", r[r.CommaListElements = 528] = "CommaListElements", r[r.CallExpressionArguments = 2576] = "CallExpressionArguments", r[r.NewExpressionArguments = 18960] = "NewExpressionArguments", r[r.TemplateExpressionSpans = 262144] = "TemplateExpressionSpans", r[r.SingleLineBlockStatements = 768] = "SingleLineBlockStatements", r[r.MultiLineBlockStatements = 129] = "MultiLineBlockStatements", r[r.VariableDeclarationList = 528] = "VariableDeclarationList", r[r.SingleLineFunctionBodyStatements = 768] = "SingleLineFunctionBodyStatements", r[r.MultiLineFunctionBodyStatements = 1] = "MultiLineFunctionBodyStatements", r[r.ClassHeritageClauses = 0] = "ClassHeritageClauses", r[r.ClassMembers = 129] = "ClassMembers", r[r.InterfaceMembers = 129] = "InterfaceMembers", r[r.EnumMembers = 145] = "EnumMembers", r[r.CaseBlockClauses = 129] = "CaseBlockClauses", r[r.NamedImportsOrExportsElements = 525136] = "NamedImportsOrExportsElements", r[r.JsxElementOrFragmentChildren = 262144] = "JsxElementOrFragmentChildren", r[r.JsxElementAttributes = 262656] = "JsxElementAttributes", r[r.CaseOrDefaultClauseStatements = 163969] = "CaseOrDefaultClauseStatements", r[r.HeritageClauseTypes = 528] = "HeritageClauseTypes", r[r.SourceFileStatements = 131073] = "SourceFileStatements", r[r.Decorators = 2146305] = "Decorators", r[r.TypeArguments = 53776] = "TypeArguments", r[r.TypeParameters = 53776] = "TypeParameters", r[r.Parameters = 2576] = "Parameters", r[r.IndexSignatureParameters = 8848] = "IndexSignatureParameters", r[r.JSDocComment = 33] = "JSDocComment";
            })(Ge = e.ListFormat || (e.ListFormat = {}));
            var K;
            (function(r) {
              r[r.None = 0] = "None", r[r.TripleSlashXML = 1] = "TripleSlashXML", r[r.SingleLine = 2] = "SingleLine", r[r.MultiLine = 4] = "MultiLine", r[r.All = 7] = "All", r[r.Default = 7] = "Default";
            })(K = e.PragmaKindFlags || (e.PragmaKindFlags = {})), e.commentPragmas = { reference: { args: [{ name: "types", optional: true, captureSpan: true }, { name: "lib", optional: true, captureSpan: true }, { name: "path", optional: true, captureSpan: true }, { name: "no-default-lib", optional: true }, { name: "resolution-mode", optional: true }], kind: 1 }, "amd-dependency": { args: [{ name: "path" }, { name: "name", optional: true }], kind: 1 }, "amd-module": { args: [{ name: "name" }], kind: 1 }, "ts-check": { kind: 2 }, "ts-nocheck": { kind: 2 }, jsx: { args: [{ name: "factory" }], kind: 4 }, jsxfrag: { args: [{ name: "factory" }], kind: 4 }, jsximportsource: { args: [{ name: "factory" }], kind: 4 }, jsxruntime: { args: [{ name: "factory" }], kind: 4 } };
          })(N || (N = {}));
          var N;
          (function(e) {
            e.directorySeparator = "/", e.altDirectorySeparator = "\\";
            var t = "://", x = /\\/g;
            function s(ye) {
              return ye === 47 || ye === 92;
            }
            __name(s, "s");
            e.isAnyDirectorySeparator = s;
            function q(ye) {
              return B(ye) < 0;
            }
            __name(q, "q");
            e.isUrl = q;
            function F(ye) {
              return B(ye) > 0;
            }
            __name(F, "F");
            e.isRootedDiskPath = F;
            function fe(ye) {
              var ir = B(ye);
              return ir > 0 && ir === ye.length;
            }
            __name(fe, "fe");
            e.isDiskPathRoot = fe;
            function Te(ye) {
              return B(ye) !== 0;
            }
            __name(Te, "Te");
            e.pathIsAbsolute = Te;
            function Se(ye) {
              return /^\.\.?($|[\\/])/.test(ye);
            }
            __name(Se, "Se");
            e.pathIsRelative = Se;
            function J(ye) {
              return !Te(ye) && !Se(ye);
            }
            __name(J, "J");
            e.pathIsBareSpecifier = J;
            function se(ye) {
              return e.stringContains(v(ye), ".");
            }
            __name(se, "se");
            e.hasExtension = se;
            function Le(ye, ir) {
              return ye.length > ir.length && e.endsWith(ye, ir);
            }
            __name(Le, "Le");
            e.fileExtensionIs = Le;
            function Q(ye, ir) {
              for (var Dr = 0, Pr = ir; Dr < Pr.length; Dr++) {
                var Br = Pr[Dr];
                if (Le(ye, Br))
                  return true;
              }
              return false;
            }
            __name(Q, "Q");
            e.fileExtensionIsOneOf = Q;
            function Be(ye) {
              return ye.length > 0 && s(ye.charCodeAt(ye.length - 1));
            }
            __name(Be, "Be");
            e.hasTrailingDirectorySeparator = Be;
            function je(ye) {
              return ye >= 97 && ye <= 122 || ye >= 65 && ye <= 90;
            }
            __name(je, "je");
            function W(ye, ir) {
              var Dr = ye.charCodeAt(ir);
              if (Dr === 58)
                return ir + 1;
              if (Dr === 37 && ye.charCodeAt(ir + 1) === 51) {
                var Pr = ye.charCodeAt(ir + 2);
                if (Pr === 97 || Pr === 65)
                  return ir + 3;
              }
              return -1;
            }
            __name(W, "W");
            function B(ye) {
              if (!ye)
                return 0;
              var ir = ye.charCodeAt(0);
              if (ir === 47 || ir === 92) {
                if (ye.charCodeAt(1) !== ir)
                  return 1;
                var Dr = ye.indexOf(ir === 47 ? e.directorySeparator : e.altDirectorySeparator, 2);
                return Dr < 0 ? ye.length : Dr + 1;
              }
              if (je(ir) && ye.charCodeAt(1) === 58) {
                var Pr = ye.charCodeAt(2);
                if (Pr === 47 || Pr === 92)
                  return 3;
                if (ye.length === 2)
                  return 2;
              }
              var Br = ye.indexOf(t);
              if (Br !== -1) {
                var ut = Br + t.length, rt = ye.indexOf(e.directorySeparator, ut);
                if (rt !== -1) {
                  var Z = ye.slice(0, Br), f = ye.slice(ut, rt);
                  if (Z === "file" && (f === "" || f === "localhost") && je(ye.charCodeAt(rt + 1))) {
                    var h = W(ye, rt + 2);
                    if (h !== -1) {
                      if (ye.charCodeAt(h) === 47)
                        return ~(h + 1);
                      if (h === ye.length)
                        return ~h;
                    }
                  }
                  return ~(rt + 1);
                }
                return ~ye.length;
              }
              return 0;
            }
            __name(B, "B");
            function U(ye) {
              var ir = B(ye);
              return ir < 0 ? ~ir : ir;
            }
            __name(U, "U");
            e.getRootLength = U;
            function m(ye) {
              ye = ge(ye);
              var ir = U(ye);
              return ir === ye.length ? ye : (ye = ze(ye), ye.slice(0, Math.max(ir, ye.lastIndexOf(e.directorySeparator))));
            }
            __name(m, "m");
            e.getDirectoryPath = m;
            function v(ye, ir, Dr) {
              ye = ge(ye);
              var Pr = U(ye);
              if (Pr === ye.length)
                return "";
              ye = ze(ye);
              var Br = ye.slice(Math.max(U(ye), ye.lastIndexOf(e.directorySeparator) + 1)), ut = ir !== void 0 && Dr !== void 0 ? S(Br, ir, Dr) : void 0;
              return ut ? Br.slice(0, Br.length - ut.length) : Br;
            }
            __name(v, "v");
            e.getBaseFileName = v;
            function g(ye, ir, Dr) {
              if (e.startsWith(ir, ".") || (ir = "." + ir), ye.length >= ir.length && ye.charCodeAt(ye.length - ir.length) === 46) {
                var Pr = ye.slice(ye.length - ir.length);
                if (Dr(Pr, ir))
                  return Pr;
              }
            }
            __name(g, "g");
            function O(ye, ir, Dr) {
              if (typeof ir == "string")
                return g(ye, ir, Dr) || "";
              for (var Pr = 0, Br = ir; Pr < Br.length; Pr++) {
                var ut = Br[Pr], rt = g(ye, ut, Dr);
                if (rt)
                  return rt;
              }
              return "";
            }
            __name(O, "O");
            function S(ye, ir, Dr) {
              if (ir)
                return O(ze(ye), ir, Dr ? e.equateStringsCaseInsensitive : e.equateStringsCaseSensitive);
              var Pr = v(ye), Br = Pr.lastIndexOf(".");
              return Br >= 0 ? Pr.substring(Br) : "";
            }
            __name(S, "S");
            e.getAnyExtensionFromPath = S;
            function te(ye, ir) {
              var Dr = ye.substring(0, ir), Pr = ye.substring(ir).split(e.directorySeparator);
              return Pr.length && !e.lastOrUndefined(Pr) && Pr.pop(), A([Dr], Pr, true);
            }
            __name(te, "te");
            function Je(ye, ir) {
              return ir === void 0 && (ir = ""), ye = G(ir, ye), te(ye, U(ye));
            }
            __name(Je, "Je");
            e.getPathComponents = Je;
            function qe(ye) {
              if (ye.length === 0)
                return "";
              var ir = ye[0] && ve(ye[0]);
              return ir + ye.slice(1).join(e.directorySeparator);
            }
            __name(qe, "qe");
            e.getPathFromPathComponents = qe;
            function ge(ye) {
              return ye.indexOf("\\") !== -1 ? ye.replace(x, e.directorySeparator) : ye;
            }
            __name(ge, "ge");
            e.normalizeSlashes = ge;
            function ie(ye) {
              if (!e.some(ye))
                return [];
              for (var ir = [ye[0]], Dr = 1; Dr < ye.length; Dr++) {
                var Pr = ye[Dr];
                if (!!Pr && Pr !== ".") {
                  if (Pr === "..") {
                    if (ir.length > 1) {
                      if (ir[ir.length - 1] !== "..") {
                        ir.pop();
                        continue;
                      }
                    } else if (ir[0])
                      continue;
                  }
                  ir.push(Pr);
                }
              }
              return ir;
            }
            __name(ie, "ie");
            e.reducePathComponents = ie;
            function G(ye) {
              for (var ir = [], Dr = 1; Dr < arguments.length; Dr++)
                ir[Dr - 1] = arguments[Dr];
              ye && (ye = ge(ye));
              for (var Pr = 0, Br = ir; Pr < Br.length; Pr++) {
                var ut = Br[Pr];
                !ut || (ut = ge(ut), !ye || U(ut) !== 0 ? ye = ut : ye = ve(ye) + ut);
              }
              return ye;
            }
            __name(G, "G");
            e.combinePaths = G;
            function pe(ye) {
              for (var ir = [], Dr = 1; Dr < arguments.length; Dr++)
                ir[Dr - 1] = arguments[Dr];
              return $e(e.some(ir) ? G.apply(void 0, A([ye], ir, false)) : ge(ye));
            }
            __name(pe, "pe");
            e.resolvePath = pe;
            function j(ye, ir) {
              return ie(Je(ye, ir));
            }
            __name(j, "j");
            e.getNormalizedPathComponents = j;
            function be(ye, ir) {
              return qe(j(ye, ir));
            }
            __name(be, "be");
            e.getNormalizedAbsolutePath = be;
            function $e(ye) {
              if (ye = ge(ye), !Cr.test(ye))
                return ye;
              var ir = ye.replace(/\/\.\//g, "/").replace(/^\.\//, "");
              if (ir !== ye && (ye = ir, !Cr.test(ye)))
                return ye;
              var Dr = qe(ie(Je(ye)));
              return Dr && Be(ye) ? ve(Dr) : Dr;
            }
            __name($e, "$e");
            e.normalizePath = $e;
            function Re(ye) {
              return ye.length === 0 ? "" : ye.slice(1).join(e.directorySeparator);
            }
            __name(Re, "Re");
            function Fe(ye, ir) {
              return Re(j(ye, ir));
            }
            __name(Fe, "Fe");
            e.getNormalizedAbsolutePathWithoutRoot = Fe;
            function dr(ye, ir, Dr) {
              var Pr = F(ye) ? $e(ye) : be(ye, ir);
              return Dr(Pr);
            }
            __name(dr, "dr");
            e.toPath = dr;
            function ze(ye) {
              return Be(ye) ? ye.substr(0, ye.length - 1) : ye;
            }
            __name(ze, "ze");
            e.removeTrailingDirectorySeparator = ze;
            function ve(ye) {
              return Be(ye) ? ye : ye + e.directorySeparator;
            }
            __name(ve, "ve");
            e.ensureTrailingDirectorySeparator = ve;
            function er(ye) {
              return !Te(ye) && !Se(ye) ? "./" + ye : ye;
            }
            __name(er, "er");
            e.ensurePathIsNonModuleName = er;
            function ar(ye, ir, Dr, Pr) {
              var Br = Dr !== void 0 && Pr !== void 0 ? S(ye, Dr, Pr) : S(ye);
              return Br ? ye.slice(0, ye.length - Br.length) + (e.startsWith(ir, ".") ? ir : "." + ir) : ye;
            }
            __name(ar, "ar");
            e.changeAnyExtension = ar;
            var Cr = /(?:\/\/)|(?:^|\/)\.\.?(?:$|\/)/;
            function Ce(ye, ir, Dr) {
              if (ye === ir)
                return 0;
              if (ye === void 0)
                return -1;
              if (ir === void 0)
                return 1;
              var Pr = ye.substring(0, U(ye)), Br = ir.substring(0, U(ir)), ut = e.compareStringsCaseInsensitive(Pr, Br);
              if (ut !== 0)
                return ut;
              var rt = ye.substring(Pr.length), Z = ir.substring(Br.length);
              if (!Cr.test(rt) && !Cr.test(Z))
                return Dr(rt, Z);
              for (var f = ie(Je(ye)), h = ie(Je(ir)), ae = Math.min(f.length, h.length), xr = 1; xr < ae; xr++) {
                var jr = Dr(f[xr], h[xr]);
                if (jr !== 0)
                  return jr;
              }
              return e.compareValues(f.length, h.length);
            }
            __name(Ce, "Ce");
            function Xe(ye, ir) {
              return Ce(ye, ir, e.compareStringsCaseSensitive);
            }
            __name(Xe, "Xe");
            e.comparePathsCaseSensitive = Xe;
            function gr(ye, ir) {
              return Ce(ye, ir, e.compareStringsCaseInsensitive);
            }
            __name(gr, "gr");
            e.comparePathsCaseInsensitive = gr;
            function X(ye, ir, Dr, Pr) {
              return typeof Dr == "string" ? (ye = G(Dr, ye), ir = G(Dr, ir)) : typeof Dr == "boolean" && (Pr = Dr), Ce(ye, ir, e.getStringComparer(Pr));
            }
            __name(X, "X");
            e.comparePaths = X;
            function Ee(ye, ir, Dr, Pr) {
              if (typeof Dr == "string" ? (ye = G(Dr, ye), ir = G(Dr, ir)) : typeof Dr == "boolean" && (Pr = Dr), ye === void 0 || ir === void 0)
                return false;
              if (ye === ir)
                return true;
              var Br = ie(Je(ye)), ut = ie(Je(ir));
              if (ut.length < Br.length)
                return false;
              for (var rt = Pr ? e.equateStringsCaseInsensitive : e.equateStringsCaseSensitive, Z = 0; Z < Br.length; Z++) {
                var f = Z === 0 ? e.equateStringsCaseInsensitive : rt;
                if (!f(Br[Z], ut[Z]))
                  return false;
              }
              return true;
            }
            __name(Ee, "Ee");
            e.containsPath = Ee;
            function we(ye, ir, Dr) {
              var Pr = Dr(ye), Br = Dr(ir);
              return e.startsWith(Pr, Br + "/") || e.startsWith(Pr, Br + "\\");
            }
            __name(we, "we");
            e.startsWithDirectory = we;
            function he(ye, ir, Dr, Pr) {
              var Br = ie(Je(ye)), ut = ie(Je(ir)), rt;
              for (rt = 0; rt < Br.length && rt < ut.length; rt++) {
                var Z = Pr(Br[rt]), f = Pr(ut[rt]), h = rt === 0 ? e.equateStringsCaseInsensitive : Dr;
                if (!h(Z, f))
                  break;
              }
              if (rt === 0)
                return ut;
              for (var ae = ut.slice(rt), xr = []; rt < Br.length; rt++)
                xr.push("..");
              return A(A([""], xr, true), ae, true);
            }
            __name(he, "he");
            e.getPathComponentsRelativeTo = he;
            function yr(ye, ir, Dr) {
              e.Debug.assert(U(ye) > 0 == U(ir) > 0, "Paths must either both be absolute or both be relative");
              var Pr = typeof Dr == "function" ? Dr : e.identity, Br = typeof Dr == "boolean" ? Dr : false, ut = he(ye, ir, Br ? e.equateStringsCaseInsensitive : e.equateStringsCaseSensitive, Pr);
              return qe(ut);
            }
            __name(yr, "yr");
            e.getRelativePathFromDirectory = yr;
            function kr(ye, ir, Dr) {
              return F(ye) ? tr(ir, ye, ir, Dr, false) : ye;
            }
            __name(kr, "kr");
            e.convertToRelativePath = kr;
            function nr(ye, ir, Dr) {
              return er(yr(m(ye), ir, Dr));
            }
            __name(nr, "nr");
            e.getRelativePathFromFile = nr;
            function tr(ye, ir, Dr, Pr, Br) {
              var ut = he(pe(Dr, ye), pe(Dr, ir), e.equateStringsCaseSensitive, Pr), rt = ut[0];
              if (Br && F(rt)) {
                var Z = rt.charAt(0) === e.directorySeparator ? "file://" : "file:///";
                ut[0] = Z + rt;
              }
              return qe(ut);
            }
            __name(tr, "tr");
            e.getRelativePathToDirectoryOrUrl = tr;
            function Lr(ye, ir) {
              for (; ; ) {
                var Dr = ir(ye);
                if (Dr !== void 0)
                  return Dr;
                var Pr = m(ye);
                if (Pr === ye)
                  return;
                ye = Pr;
              }
            }
            __name(Lr, "Lr");
            e.forEachAncestorDirectory = Lr;
            function zr(ye) {
              return e.endsWith(ye, "/node_modules");
            }
            __name(zr, "zr");
            e.isNodeModulesDirectory = zr;
          })(N || (N = {}));
          var N;
          (function(e) {
            function t(x, s, q, F, fe, Te, Se) {
              return { code: x, category: s, key: q, message: F, reportsUnnecessary: fe, elidedInCompatabilityPyramid: Te, reportsDeprecated: Se };
            }
            __name(t, "t");
            e.Diagnostics = { Unterminated_string_literal: t(1002, e.DiagnosticCategory.Error, "Unterminated_string_literal_1002", "Unterminated string literal."), Identifier_expected: t(1003, e.DiagnosticCategory.Error, "Identifier_expected_1003", "Identifier expected."), _0_expected: t(1005, e.DiagnosticCategory.Error, "_0_expected_1005", "'{0}' expected."), A_file_cannot_have_a_reference_to_itself: t(1006, e.DiagnosticCategory.Error, "A_file_cannot_have_a_reference_to_itself_1006", "A file cannot have a reference to itself."), The_parser_expected_to_find_a_1_to_match_the_0_token_here: t(1007, e.DiagnosticCategory.Error, "The_parser_expected_to_find_a_1_to_match_the_0_token_here_1007", "The parser expected to find a '{1}' to match the '{0}' token here."), Trailing_comma_not_allowed: t(1009, e.DiagnosticCategory.Error, "Trailing_comma_not_allowed_1009", "Trailing comma not allowed."), Asterisk_Slash_expected: t(1010, e.DiagnosticCategory.Error, "Asterisk_Slash_expected_1010", "'*/' expected."), An_element_access_expression_should_take_an_argument: t(1011, e.DiagnosticCategory.Error, "An_element_access_expression_should_take_an_argument_1011", "An element access expression should take an argument."), Unexpected_token: t(1012, e.DiagnosticCategory.Error, "Unexpected_token_1012", "Unexpected token."), A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma: t(1013, e.DiagnosticCategory.Error, "A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma_1013", "A rest parameter or binding pattern may not have a trailing comma."), A_rest_parameter_must_be_last_in_a_parameter_list: t(1014, e.DiagnosticCategory.Error, "A_rest_parameter_must_be_last_in_a_parameter_list_1014", "A rest parameter must be last in a parameter list."), Parameter_cannot_have_question_mark_and_initializer: t(1015, e.DiagnosticCategory.Error, "Parameter_cannot_have_question_mark_and_initializer_1015", "Parameter cannot have question mark and initializer."), A_required_parameter_cannot_follow_an_optional_parameter: t(1016, e.DiagnosticCategory.Error, "A_required_parameter_cannot_follow_an_optional_parameter_1016", "A required parameter cannot follow an optional parameter."), An_index_signature_cannot_have_a_rest_parameter: t(1017, e.DiagnosticCategory.Error, "An_index_signature_cannot_have_a_rest_parameter_1017", "An index signature cannot have a rest parameter."), An_index_signature_parameter_cannot_have_an_accessibility_modifier: t(1018, e.DiagnosticCategory.Error, "An_index_signature_parameter_cannot_have_an_accessibility_modifier_1018", "An index signature parameter cannot have an accessibility modifier."), An_index_signature_parameter_cannot_have_a_question_mark: t(1019, e.DiagnosticCategory.Error, "An_index_signature_parameter_cannot_have_a_question_mark_1019", "An index signature parameter cannot have a question mark."), An_index_signature_parameter_cannot_have_an_initializer: t(1020, e.DiagnosticCategory.Error, "An_index_signature_parameter_cannot_have_an_initializer_1020", "An index signature parameter cannot have an initializer."), An_index_signature_must_have_a_type_annotation: t(1021, e.DiagnosticCategory.Error, "An_index_signature_must_have_a_type_annotation_1021", "An index signature must have a type annotation."), An_index_signature_parameter_must_have_a_type_annotation: t(1022, e.DiagnosticCategory.Error, "An_index_signature_parameter_must_have_a_type_annotation_1022", "An index signature parameter must have a type annotation."), readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature: t(1024, e.DiagnosticCategory.Error, "readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature_1024", "'readonly' modifier can only appear on a property declaration or index signature."), An_index_signature_cannot_have_a_trailing_comma: t(1025, e.DiagnosticCategory.Error, "An_index_signature_cannot_have_a_trailing_comma_1025", "An index signature cannot have a trailing comma."), Accessibility_modifier_already_seen: t(1028, e.DiagnosticCategory.Error, "Accessibility_modifier_already_seen_1028", "Accessibility modifier already seen."), _0_modifier_must_precede_1_modifier: t(1029, e.DiagnosticCategory.Error, "_0_modifier_must_precede_1_modifier_1029", "'{0}' modifier must precede '{1}' modifier."), _0_modifier_already_seen: t(1030, e.DiagnosticCategory.Error, "_0_modifier_already_seen_1030", "'{0}' modifier already seen."), _0_modifier_cannot_appear_on_class_elements_of_this_kind: t(1031, e.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_class_elements_of_this_kind_1031", "'{0}' modifier cannot appear on class elements of this kind."), super_must_be_followed_by_an_argument_list_or_member_access: t(1034, e.DiagnosticCategory.Error, "super_must_be_followed_by_an_argument_list_or_member_access_1034", "'super' must be followed by an argument list or member access."), Only_ambient_modules_can_use_quoted_names: t(1035, e.DiagnosticCategory.Error, "Only_ambient_modules_can_use_quoted_names_1035", "Only ambient modules can use quoted names."), Statements_are_not_allowed_in_ambient_contexts: t(1036, e.DiagnosticCategory.Error, "Statements_are_not_allowed_in_ambient_contexts_1036", "Statements are not allowed in ambient contexts."), A_declare_modifier_cannot_be_used_in_an_already_ambient_context: t(1038, e.DiagnosticCategory.Error, "A_declare_modifier_cannot_be_used_in_an_already_ambient_context_1038", "A 'declare' modifier cannot be used in an already ambient context."), Initializers_are_not_allowed_in_ambient_contexts: t(1039, e.DiagnosticCategory.Error, "Initializers_are_not_allowed_in_ambient_contexts_1039", "Initializers are not allowed in ambient contexts."), _0_modifier_cannot_be_used_in_an_ambient_context: t(1040, e.DiagnosticCategory.Error, "_0_modifier_cannot_be_used_in_an_ambient_context_1040", "'{0}' modifier cannot be used in an ambient context."), _0_modifier_cannot_be_used_here: t(1042, e.DiagnosticCategory.Error, "_0_modifier_cannot_be_used_here_1042", "'{0}' modifier cannot be used here."), _0_modifier_cannot_appear_on_a_module_or_namespace_element: t(1044, e.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_module_or_namespace_element_1044", "'{0}' modifier cannot appear on a module or namespace element."), Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier: t(1046, e.DiagnosticCategory.Error, "Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier_1046", "Top-level declarations in .d.ts files must start with either a 'declare' or 'export' modifier."), A_rest_parameter_cannot_be_optional: t(1047, e.DiagnosticCategory.Error, "A_rest_parameter_cannot_be_optional_1047", "A rest parameter cannot be optional."), A_rest_parameter_cannot_have_an_initializer: t(1048, e.DiagnosticCategory.Error, "A_rest_parameter_cannot_have_an_initializer_1048", "A rest parameter cannot have an initializer."), A_set_accessor_must_have_exactly_one_parameter: t(1049, e.DiagnosticCategory.Error, "A_set_accessor_must_have_exactly_one_parameter_1049", "A 'set' accessor must have exactly one parameter."), A_set_accessor_cannot_have_an_optional_parameter: t(1051, e.DiagnosticCategory.Error, "A_set_accessor_cannot_have_an_optional_parameter_1051", "A 'set' accessor cannot have an optional parameter."), A_set_accessor_parameter_cannot_have_an_initializer: t(1052, e.DiagnosticCategory.Error, "A_set_accessor_parameter_cannot_have_an_initializer_1052", "A 'set' accessor parameter cannot have an initializer."), A_set_accessor_cannot_have_rest_parameter: t(1053, e.DiagnosticCategory.Error, "A_set_accessor_cannot_have_rest_parameter_1053", "A 'set' accessor cannot have rest parameter."), A_get_accessor_cannot_have_parameters: t(1054, e.DiagnosticCategory.Error, "A_get_accessor_cannot_have_parameters_1054", "A 'get' accessor cannot have parameters."), Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value: t(1055, e.DiagnosticCategory.Error, "Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Prom_1055", "Type '{0}' is not a valid async function return type in ES5/ES3 because it does not refer to a Promise-compatible constructor value."), Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: t(1056, e.DiagnosticCategory.Error, "Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher_1056", "Accessors are only available when targeting ECMAScript 5 and higher."), The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: t(1058, e.DiagnosticCategory.Error, "The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_t_1058", "The return type of an async function must either be a valid promise or must not contain a callable 'then' member."), A_promise_must_have_a_then_method: t(1059, e.DiagnosticCategory.Error, "A_promise_must_have_a_then_method_1059", "A promise must have a 'then' method."), The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback: t(1060, e.DiagnosticCategory.Error, "The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback_1060", "The first parameter of the 'then' method of a promise must be a callback."), Enum_member_must_have_initializer: t(1061, e.DiagnosticCategory.Error, "Enum_member_must_have_initializer_1061", "Enum member must have initializer."), Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method: t(1062, e.DiagnosticCategory.Error, "Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method_1062", "Type is referenced directly or indirectly in the fulfillment callback of its own 'then' method."), An_export_assignment_cannot_be_used_in_a_namespace: t(1063, e.DiagnosticCategory.Error, "An_export_assignment_cannot_be_used_in_a_namespace_1063", "An export assignment cannot be used in a namespace."), The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0: t(1064, e.DiagnosticCategory.Error, "The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_wri_1064", "The return type of an async function or method must be the global Promise<T> type. Did you mean to write 'Promise<{0}>'?"), In_ambient_enum_declarations_member_initializer_must_be_constant_expression: t(1066, e.DiagnosticCategory.Error, "In_ambient_enum_declarations_member_initializer_must_be_constant_expression_1066", "In ambient enum declarations member initializer must be constant expression."), Unexpected_token_A_constructor_method_accessor_or_property_was_expected: t(1068, e.DiagnosticCategory.Error, "Unexpected_token_A_constructor_method_accessor_or_property_was_expected_1068", "Unexpected token. A constructor, method, accessor, or property was expected."), Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces: t(1069, e.DiagnosticCategory.Error, "Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces_1069", "Unexpected token. A type parameter name was expected without curly braces."), _0_modifier_cannot_appear_on_a_type_member: t(1070, e.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_type_member_1070", "'{0}' modifier cannot appear on a type member."), _0_modifier_cannot_appear_on_an_index_signature: t(1071, e.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_an_index_signature_1071", "'{0}' modifier cannot appear on an index signature."), A_0_modifier_cannot_be_used_with_an_import_declaration: t(1079, e.DiagnosticCategory.Error, "A_0_modifier_cannot_be_used_with_an_import_declaration_1079", "A '{0}' modifier cannot be used with an import declaration."), Invalid_reference_directive_syntax: t(1084, e.DiagnosticCategory.Error, "Invalid_reference_directive_syntax_1084", "Invalid 'reference' directive syntax."), Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0: t(1085, e.DiagnosticCategory.Error, "Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0_1085", "Octal literals are not available when targeting ECMAScript 5 and higher. Use the syntax '{0}'."), _0_modifier_cannot_appear_on_a_constructor_declaration: t(1089, e.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_constructor_declaration_1089", "'{0}' modifier cannot appear on a constructor declaration."), _0_modifier_cannot_appear_on_a_parameter: t(1090, e.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_parameter_1090", "'{0}' modifier cannot appear on a parameter."), Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: t(1091, e.DiagnosticCategory.Error, "Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement_1091", "Only a single variable declaration is allowed in a 'for...in' statement."), Type_parameters_cannot_appear_on_a_constructor_declaration: t(1092, e.DiagnosticCategory.Error, "Type_parameters_cannot_appear_on_a_constructor_declaration_1092", "Type parameters cannot appear on a constructor declaration."), Type_annotation_cannot_appear_on_a_constructor_declaration: t(1093, e.DiagnosticCategory.Error, "Type_annotation_cannot_appear_on_a_constructor_declaration_1093", "Type annotation cannot appear on a constructor declaration."), An_accessor_cannot_have_type_parameters: t(1094, e.DiagnosticCategory.Error, "An_accessor_cannot_have_type_parameters_1094", "An accessor cannot have type parameters."), A_set_accessor_cannot_have_a_return_type_annotation: t(1095, e.DiagnosticCategory.Error, "A_set_accessor_cannot_have_a_return_type_annotation_1095", "A 'set' accessor cannot have a return type annotation."), An_index_signature_must_have_exactly_one_parameter: t(1096, e.DiagnosticCategory.Error, "An_index_signature_must_have_exactly_one_parameter_1096", "An index signature must have exactly one parameter."), _0_list_cannot_be_empty: t(1097, e.DiagnosticCategory.Error, "_0_list_cannot_be_empty_1097", "'{0}' list cannot be empty."), Type_parameter_list_cannot_be_empty: t(1098, e.DiagnosticCategory.Error, "Type_parameter_list_cannot_be_empty_1098", "Type parameter list cannot be empty."), Type_argument_list_cannot_be_empty: t(1099, e.DiagnosticCategory.Error, "Type_argument_list_cannot_be_empty_1099", "Type argument list cannot be empty."), Invalid_use_of_0_in_strict_mode: t(1100, e.DiagnosticCategory.Error, "Invalid_use_of_0_in_strict_mode_1100", "Invalid use of '{0}' in strict mode."), with_statements_are_not_allowed_in_strict_mode: t(1101, e.DiagnosticCategory.Error, "with_statements_are_not_allowed_in_strict_mode_1101", "'with' statements are not allowed in strict mode."), delete_cannot_be_called_on_an_identifier_in_strict_mode: t(1102, e.DiagnosticCategory.Error, "delete_cannot_be_called_on_an_identifier_in_strict_mode_1102", "'delete' cannot be called on an identifier in strict mode."), for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules: t(1103, e.DiagnosticCategory.Error, "for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1103", "'for await' loops are only allowed within async functions and at the top levels of modules."), A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: t(1104, e.DiagnosticCategory.Error, "A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement_1104", "A 'continue' statement can only be used within an enclosing iteration statement."), A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: t(1105, e.DiagnosticCategory.Error, "A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement_1105", "A 'break' statement can only be used within an enclosing iteration or switch statement."), The_left_hand_side_of_a_for_of_statement_may_not_be_async: t(1106, e.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_of_statement_may_not_be_async_1106", "The left-hand side of a 'for...of' statement may not be 'async'."), Jump_target_cannot_cross_function_boundary: t(1107, e.DiagnosticCategory.Error, "Jump_target_cannot_cross_function_boundary_1107", "Jump target cannot cross function boundary."), A_return_statement_can_only_be_used_within_a_function_body: t(1108, e.DiagnosticCategory.Error, "A_return_statement_can_only_be_used_within_a_function_body_1108", "A 'return' statement can only be used within a function body."), Expression_expected: t(1109, e.DiagnosticCategory.Error, "Expression_expected_1109", "Expression expected."), Type_expected: t(1110, e.DiagnosticCategory.Error, "Type_expected_1110", "Type expected."), A_default_clause_cannot_appear_more_than_once_in_a_switch_statement: t(1113, e.DiagnosticCategory.Error, "A_default_clause_cannot_appear_more_than_once_in_a_switch_statement_1113", "A 'default' clause cannot appear more than once in a 'switch' statement."), Duplicate_label_0: t(1114, e.DiagnosticCategory.Error, "Duplicate_label_0_1114", "Duplicate label '{0}'."), A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement: t(1115, e.DiagnosticCategory.Error, "A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement_1115", "A 'continue' statement can only jump to a label of an enclosing iteration statement."), A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement: t(1116, e.DiagnosticCategory.Error, "A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement_1116", "A 'break' statement can only jump to a label of an enclosing statement."), An_object_literal_cannot_have_multiple_properties_with_the_same_name: t(1117, e.DiagnosticCategory.Error, "An_object_literal_cannot_have_multiple_properties_with_the_same_name_1117", "An object literal cannot have multiple properties with the same name."), An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name: t(1118, e.DiagnosticCategory.Error, "An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name_1118", "An object literal cannot have multiple get/set accessors with the same name."), An_object_literal_cannot_have_property_and_accessor_with_the_same_name: t(1119, e.DiagnosticCategory.Error, "An_object_literal_cannot_have_property_and_accessor_with_the_same_name_1119", "An object literal cannot have property and accessor with the same name."), An_export_assignment_cannot_have_modifiers: t(1120, e.DiagnosticCategory.Error, "An_export_assignment_cannot_have_modifiers_1120", "An export assignment cannot have modifiers."), Octal_literals_are_not_allowed_in_strict_mode: t(1121, e.DiagnosticCategory.Error, "Octal_literals_are_not_allowed_in_strict_mode_1121", "Octal literals are not allowed in strict mode."), Variable_declaration_list_cannot_be_empty: t(1123, e.DiagnosticCategory.Error, "Variable_declaration_list_cannot_be_empty_1123", "Variable declaration list cannot be empty."), Digit_expected: t(1124, e.DiagnosticCategory.Error, "Digit_expected_1124", "Digit expected."), Hexadecimal_digit_expected: t(1125, e.DiagnosticCategory.Error, "Hexadecimal_digit_expected_1125", "Hexadecimal digit expected."), Unexpected_end_of_text: t(1126, e.DiagnosticCategory.Error, "Unexpected_end_of_text_1126", "Unexpected end of text."), Invalid_character: t(1127, e.DiagnosticCategory.Error, "Invalid_character_1127", "Invalid character."), Declaration_or_statement_expected: t(1128, e.DiagnosticCategory.Error, "Declaration_or_statement_expected_1128", "Declaration or statement expected."), Statement_expected: t(1129, e.DiagnosticCategory.Error, "Statement_expected_1129", "Statement expected."), case_or_default_expected: t(1130, e.DiagnosticCategory.Error, "case_or_default_expected_1130", "'case' or 'default' expected."), Property_or_signature_expected: t(1131, e.DiagnosticCategory.Error, "Property_or_signature_expected_1131", "Property or signature expected."), Enum_member_expected: t(1132, e.DiagnosticCategory.Error, "Enum_member_expected_1132", "Enum member expected."), Variable_declaration_expected: t(1134, e.DiagnosticCategory.Error, "Variable_declaration_expected_1134", "Variable declaration expected."), Argument_expression_expected: t(1135, e.DiagnosticCategory.Error, "Argument_expression_expected_1135", "Argument expression expected."), Property_assignment_expected: t(1136, e.DiagnosticCategory.Error, "Property_assignment_expected_1136", "Property assignment expected."), Expression_or_comma_expected: t(1137, e.DiagnosticCategory.Error, "Expression_or_comma_expected_1137", "Expression or comma expected."), Parameter_declaration_expected: t(1138, e.DiagnosticCategory.Error, "Parameter_declaration_expected_1138", "Parameter declaration expected."), Type_parameter_declaration_expected: t(1139, e.DiagnosticCategory.Error, "Type_parameter_declaration_expected_1139", "Type parameter declaration expected."), Type_argument_expected: t(1140, e.DiagnosticCategory.Error, "Type_argument_expected_1140", "Type argument expected."), String_literal_expected: t(1141, e.DiagnosticCategory.Error, "String_literal_expected_1141", "String literal expected."), Line_break_not_permitted_here: t(1142, e.DiagnosticCategory.Error, "Line_break_not_permitted_here_1142", "Line break not permitted here."), or_expected: t(1144, e.DiagnosticCategory.Error, "or_expected_1144", "'{' or ';' expected."), or_JSX_element_expected: t(1145, e.DiagnosticCategory.Error, "or_JSX_element_expected_1145", "'{' or JSX element expected."), Declaration_expected: t(1146, e.DiagnosticCategory.Error, "Declaration_expected_1146", "Declaration expected."), Import_declarations_in_a_namespace_cannot_reference_a_module: t(1147, e.DiagnosticCategory.Error, "Import_declarations_in_a_namespace_cannot_reference_a_module_1147", "Import declarations in a namespace cannot reference a module."), Cannot_use_imports_exports_or_module_augmentations_when_module_is_none: t(1148, e.DiagnosticCategory.Error, "Cannot_use_imports_exports_or_module_augmentations_when_module_is_none_1148", "Cannot use imports, exports, or module augmentations when '--module' is 'none'."), File_name_0_differs_from_already_included_file_name_1_only_in_casing: t(1149, e.DiagnosticCategory.Error, "File_name_0_differs_from_already_included_file_name_1_only_in_casing_1149", "File name '{0}' differs from already included file name '{1}' only in casing."), const_declarations_must_be_initialized: t(1155, e.DiagnosticCategory.Error, "const_declarations_must_be_initialized_1155", "'const' declarations must be initialized."), const_declarations_can_only_be_declared_inside_a_block: t(1156, e.DiagnosticCategory.Error, "const_declarations_can_only_be_declared_inside_a_block_1156", "'const' declarations can only be declared inside a block."), let_declarations_can_only_be_declared_inside_a_block: t(1157, e.DiagnosticCategory.Error, "let_declarations_can_only_be_declared_inside_a_block_1157", "'let' declarations can only be declared inside a block."), Unterminated_template_literal: t(1160, e.DiagnosticCategory.Error, "Unterminated_template_literal_1160", "Unterminated template literal."), Unterminated_regular_expression_literal: t(1161, e.DiagnosticCategory.Error, "Unterminated_regular_expression_literal_1161", "Unterminated regular expression literal."), An_object_member_cannot_be_declared_optional: t(1162, e.DiagnosticCategory.Error, "An_object_member_cannot_be_declared_optional_1162", "An object member cannot be declared optional."), A_yield_expression_is_only_allowed_in_a_generator_body: t(1163, e.DiagnosticCategory.Error, "A_yield_expression_is_only_allowed_in_a_generator_body_1163", "A 'yield' expression is only allowed in a generator body."), Computed_property_names_are_not_allowed_in_enums: t(1164, e.DiagnosticCategory.Error, "Computed_property_names_are_not_allowed_in_enums_1164", "Computed property names are not allowed in enums."), A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: t(1165, e.DiagnosticCategory.Error, "A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_t_1165", "A computed property name in an ambient context must refer to an expression whose type is a literal type or a 'unique symbol' type."), A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type: t(1166, e.DiagnosticCategory.Error, "A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_1166", "A computed property name in a class property declaration must have a simple literal type or a 'unique symbol' type."), A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: t(1168, e.DiagnosticCategory.Error, "A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_ty_1168", "A computed property name in a method overload must refer to an expression whose type is a literal type or a 'unique symbol' type."), A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: t(1169, e.DiagnosticCategory.Error, "A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_1169", "A computed property name in an interface must refer to an expression whose type is a literal type or a 'unique symbol' type."), A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: t(1170, e.DiagnosticCategory.Error, "A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type__1170", "A computed property name in a type literal must refer to an expression whose type is a literal type or a 'unique symbol' type."), A_comma_expression_is_not_allowed_in_a_computed_property_name: t(1171, e.DiagnosticCategory.Error, "A_comma_expression_is_not_allowed_in_a_computed_property_name_1171", "A comma expression is not allowed in a computed property name."), extends_clause_already_seen: t(1172, e.DiagnosticCategory.Error, "extends_clause_already_seen_1172", "'extends' clause already seen."), extends_clause_must_precede_implements_clause: t(1173, e.DiagnosticCategory.Error, "extends_clause_must_precede_implements_clause_1173", "'extends' clause must precede 'implements' clause."), Classes_can_only_extend_a_single_class: t(1174, e.DiagnosticCategory.Error, "Classes_can_only_extend_a_single_class_1174", "Classes can only extend a single class."), implements_clause_already_seen: t(1175, e.DiagnosticCategory.Error, "implements_clause_already_seen_1175", "'implements' clause already seen."), Interface_declaration_cannot_have_implements_clause: t(1176, e.DiagnosticCategory.Error, "Interface_declaration_cannot_have_implements_clause_1176", "Interface declaration cannot have 'implements' clause."), Binary_digit_expected: t(1177, e.DiagnosticCategory.Error, "Binary_digit_expected_1177", "Binary digit expected."), Octal_digit_expected: t(1178, e.DiagnosticCategory.Error, "Octal_digit_expected_1178", "Octal digit expected."), Unexpected_token_expected: t(1179, e.DiagnosticCategory.Error, "Unexpected_token_expected_1179", "Unexpected token. '{' expected."), Property_destructuring_pattern_expected: t(1180, e.DiagnosticCategory.Error, "Property_destructuring_pattern_expected_1180", "Property destructuring pattern expected."), Array_element_destructuring_pattern_expected: t(1181, e.DiagnosticCategory.Error, "Array_element_destructuring_pattern_expected_1181", "Array element destructuring pattern expected."), A_destructuring_declaration_must_have_an_initializer: t(1182, e.DiagnosticCategory.Error, "A_destructuring_declaration_must_have_an_initializer_1182", "A destructuring declaration must have an initializer."), An_implementation_cannot_be_declared_in_ambient_contexts: t(1183, e.DiagnosticCategory.Error, "An_implementation_cannot_be_declared_in_ambient_contexts_1183", "An implementation cannot be declared in ambient contexts."), Modifiers_cannot_appear_here: t(1184, e.DiagnosticCategory.Error, "Modifiers_cannot_appear_here_1184", "Modifiers cannot appear here."), Merge_conflict_marker_encountered: t(1185, e.DiagnosticCategory.Error, "Merge_conflict_marker_encountered_1185", "Merge conflict marker encountered."), A_rest_element_cannot_have_an_initializer: t(1186, e.DiagnosticCategory.Error, "A_rest_element_cannot_have_an_initializer_1186", "A rest element cannot have an initializer."), A_parameter_property_may_not_be_declared_using_a_binding_pattern: t(1187, e.DiagnosticCategory.Error, "A_parameter_property_may_not_be_declared_using_a_binding_pattern_1187", "A parameter property may not be declared using a binding pattern."), Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement: t(1188, e.DiagnosticCategory.Error, "Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement_1188", "Only a single variable declaration is allowed in a 'for...of' statement."), The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer: t(1189, e.DiagnosticCategory.Error, "The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer_1189", "The variable declaration of a 'for...in' statement cannot have an initializer."), The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer: t(1190, e.DiagnosticCategory.Error, "The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer_1190", "The variable declaration of a 'for...of' statement cannot have an initializer."), An_import_declaration_cannot_have_modifiers: t(1191, e.DiagnosticCategory.Error, "An_import_declaration_cannot_have_modifiers_1191", "An import declaration cannot have modifiers."), Module_0_has_no_default_export: t(1192, e.DiagnosticCategory.Error, "Module_0_has_no_default_export_1192", "Module '{0}' has no default export."), An_export_declaration_cannot_have_modifiers: t(1193, e.DiagnosticCategory.Error, "An_export_declaration_cannot_have_modifiers_1193", "An export declaration cannot have modifiers."), Export_declarations_are_not_permitted_in_a_namespace: t(1194, e.DiagnosticCategory.Error, "Export_declarations_are_not_permitted_in_a_namespace_1194", "Export declarations are not permitted in a namespace."), export_Asterisk_does_not_re_export_a_default: t(1195, e.DiagnosticCategory.Error, "export_Asterisk_does_not_re_export_a_default_1195", "'export *' does not re-export a default."), Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified: t(1196, e.DiagnosticCategory.Error, "Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified_1196", "Catch clause variable type annotation must be 'any' or 'unknown' if specified."), Catch_clause_variable_cannot_have_an_initializer: t(1197, e.DiagnosticCategory.Error, "Catch_clause_variable_cannot_have_an_initializer_1197", "Catch clause variable cannot have an initializer."), An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive: t(1198, e.DiagnosticCategory.Error, "An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive_1198", "An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive."), Unterminated_Unicode_escape_sequence: t(1199, e.DiagnosticCategory.Error, "Unterminated_Unicode_escape_sequence_1199", "Unterminated Unicode escape sequence."), Line_terminator_not_permitted_before_arrow: t(1200, e.DiagnosticCategory.Error, "Line_terminator_not_permitted_before_arrow_1200", "Line terminator not permitted before arrow."), Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead: t(1202, e.DiagnosticCategory.Error, "Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_1202", `Import assignment cannot be used when targeting ECMAScript modules. Consider using 'import * as ns from "mod"', 'import {a} from "mod"', 'import d from "mod"', or another module format instead.`), Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead: t(1203, e.DiagnosticCategory.Error, "Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or__1203", "Export assignment cannot be used when targeting ECMAScript modules. Consider using 'export default' or another module format instead."), Re_exporting_a_type_when_the_isolatedModules_flag_is_provided_requires_using_export_type: t(1205, e.DiagnosticCategory.Error, "Re_exporting_a_type_when_the_isolatedModules_flag_is_provided_requires_using_export_type_1205", "Re-exporting a type when the '--isolatedModules' flag is provided requires using 'export type'."), Decorators_are_not_valid_here: t(1206, e.DiagnosticCategory.Error, "Decorators_are_not_valid_here_1206", "Decorators are not valid here."), Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name: t(1207, e.DiagnosticCategory.Error, "Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name_1207", "Decorators cannot be applied to multiple get/set accessors of the same name."), _0_cannot_be_compiled_under_isolatedModules_because_it_is_considered_a_global_script_file_Add_an_import_export_or_an_empty_export_statement_to_make_it_a_module: t(1208, e.DiagnosticCategory.Error, "_0_cannot_be_compiled_under_isolatedModules_because_it_is_considered_a_global_script_file_Add_an_imp_1208", "'{0}' cannot be compiled under '--isolatedModules' because it is considered a global script file. Add an import, export, or an empty 'export {}' statement to make it a module."), Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0: t(1209, e.DiagnosticCategory.Error, "Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0_1209", "Invalid optional chain from new expression. Did you mean to call '{0}()'?"), Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of_0_For_more_information_see_https_Colon_Slash_Slashdeveloper_mozilla_org_Slashen_US_Slashdocs_SlashWeb_SlashJavaScript_SlashReference_SlashStrict_mode: t(1210, e.DiagnosticCategory.Error, "Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of__1210", "Code contained in a class is evaluated in JavaScript's strict mode which does not allow this use of '{0}'. For more information, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode."), A_class_declaration_without_the_default_modifier_must_have_a_name: t(1211, e.DiagnosticCategory.Error, "A_class_declaration_without_the_default_modifier_must_have_a_name_1211", "A class declaration without the 'default' modifier must have a name."), Identifier_expected_0_is_a_reserved_word_in_strict_mode: t(1212, e.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_in_strict_mode_1212", "Identifier expected. '{0}' is a reserved word in strict mode."), Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode: t(1213, e.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_stric_1213", "Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode."), Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode: t(1214, e.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode_1214", "Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode."), Invalid_use_of_0_Modules_are_automatically_in_strict_mode: t(1215, e.DiagnosticCategory.Error, "Invalid_use_of_0_Modules_are_automatically_in_strict_mode_1215", "Invalid use of '{0}'. Modules are automatically in strict mode."), Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules: t(1216, e.DiagnosticCategory.Error, "Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules_1216", "Identifier expected. '__esModule' is reserved as an exported marker when transforming ECMAScript modules."), Export_assignment_is_not_supported_when_module_flag_is_system: t(1218, e.DiagnosticCategory.Error, "Export_assignment_is_not_supported_when_module_flag_is_system_1218", "Export assignment is not supported when '--module' flag is 'system'."), Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_in_your_tsconfig_or_jsconfig_to_remove_this_warning: t(1219, e.DiagnosticCategory.Error, "Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_t_1219", "Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option in your 'tsconfig' or 'jsconfig' to remove this warning."), Generators_are_not_allowed_in_an_ambient_context: t(1221, e.DiagnosticCategory.Error, "Generators_are_not_allowed_in_an_ambient_context_1221", "Generators are not allowed in an ambient context."), An_overload_signature_cannot_be_declared_as_a_generator: t(1222, e.DiagnosticCategory.Error, "An_overload_signature_cannot_be_declared_as_a_generator_1222", "An overload signature cannot be declared as a generator."), _0_tag_already_specified: t(1223, e.DiagnosticCategory.Error, "_0_tag_already_specified_1223", "'{0}' tag already specified."), Signature_0_must_be_a_type_predicate: t(1224, e.DiagnosticCategory.Error, "Signature_0_must_be_a_type_predicate_1224", "Signature '{0}' must be a type predicate."), Cannot_find_parameter_0: t(1225, e.DiagnosticCategory.Error, "Cannot_find_parameter_0_1225", "Cannot find parameter '{0}'."), Type_predicate_0_is_not_assignable_to_1: t(1226, e.DiagnosticCategory.Error, "Type_predicate_0_is_not_assignable_to_1_1226", "Type predicate '{0}' is not assignable to '{1}'."), Parameter_0_is_not_in_the_same_position_as_parameter_1: t(1227, e.DiagnosticCategory.Error, "Parameter_0_is_not_in_the_same_position_as_parameter_1_1227", "Parameter '{0}' is not in the same position as parameter '{1}'."), A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods: t(1228, e.DiagnosticCategory.Error, "A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods_1228", "A type predicate is only allowed in return type position for functions and methods."), A_type_predicate_cannot_reference_a_rest_parameter: t(1229, e.DiagnosticCategory.Error, "A_type_predicate_cannot_reference_a_rest_parameter_1229", "A type predicate cannot reference a rest parameter."), A_type_predicate_cannot_reference_element_0_in_a_binding_pattern: t(1230, e.DiagnosticCategory.Error, "A_type_predicate_cannot_reference_element_0_in_a_binding_pattern_1230", "A type predicate cannot reference element '{0}' in a binding pattern."), An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration: t(1231, e.DiagnosticCategory.Error, "An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration_1231", "An export assignment must be at the top level of a file or module declaration."), An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module: t(1232, e.DiagnosticCategory.Error, "An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module_1232", "An import declaration can only be used at the top level of a namespace or module."), An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module: t(1233, e.DiagnosticCategory.Error, "An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module_1233", "An export declaration can only be used at the top level of a namespace or module."), An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file: t(1234, e.DiagnosticCategory.Error, "An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file_1234", "An ambient module declaration is only allowed at the top level in a file."), A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module: t(1235, e.DiagnosticCategory.Error, "A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module_1235", "A namespace declaration is only allowed at the top level of a namespace or module."), The_return_type_of_a_property_decorator_function_must_be_either_void_or_any: t(1236, e.DiagnosticCategory.Error, "The_return_type_of_a_property_decorator_function_must_be_either_void_or_any_1236", "The return type of a property decorator function must be either 'void' or 'any'."), The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any: t(1237, e.DiagnosticCategory.Error, "The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any_1237", "The return type of a parameter decorator function must be either 'void' or 'any'."), Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression: t(1238, e.DiagnosticCategory.Error, "Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression_1238", "Unable to resolve signature of class decorator when called as an expression."), Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression: t(1239, e.DiagnosticCategory.Error, "Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression_1239", "Unable to resolve signature of parameter decorator when called as an expression."), Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression: t(1240, e.DiagnosticCategory.Error, "Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression_1240", "Unable to resolve signature of property decorator when called as an expression."), Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression: t(1241, e.DiagnosticCategory.Error, "Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression_1241", "Unable to resolve signature of method decorator when called as an expression."), abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration: t(1242, e.DiagnosticCategory.Error, "abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration_1242", "'abstract' modifier can only appear on a class, method, or property declaration."), _0_modifier_cannot_be_used_with_1_modifier: t(1243, e.DiagnosticCategory.Error, "_0_modifier_cannot_be_used_with_1_modifier_1243", "'{0}' modifier cannot be used with '{1}' modifier."), Abstract_methods_can_only_appear_within_an_abstract_class: t(1244, e.DiagnosticCategory.Error, "Abstract_methods_can_only_appear_within_an_abstract_class_1244", "Abstract methods can only appear within an abstract class."), Method_0_cannot_have_an_implementation_because_it_is_marked_abstract: t(1245, e.DiagnosticCategory.Error, "Method_0_cannot_have_an_implementation_because_it_is_marked_abstract_1245", "Method '{0}' cannot have an implementation because it is marked abstract."), An_interface_property_cannot_have_an_initializer: t(1246, e.DiagnosticCategory.Error, "An_interface_property_cannot_have_an_initializer_1246", "An interface property cannot have an initializer."), A_type_literal_property_cannot_have_an_initializer: t(1247, e.DiagnosticCategory.Error, "A_type_literal_property_cannot_have_an_initializer_1247", "A type literal property cannot have an initializer."), A_class_member_cannot_have_the_0_keyword: t(1248, e.DiagnosticCategory.Error, "A_class_member_cannot_have_the_0_keyword_1248", "A class member cannot have the '{0}' keyword."), A_decorator_can_only_decorate_a_method_implementation_not_an_overload: t(1249, e.DiagnosticCategory.Error, "A_decorator_can_only_decorate_a_method_implementation_not_an_overload_1249", "A decorator can only decorate a method implementation, not an overload."), Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5: t(1250, e.DiagnosticCategory.Error, "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_1250", "Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'."), Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_definitions_are_automatically_in_strict_mode: t(1251, e.DiagnosticCategory.Error, "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_d_1251", "Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Class definitions are automatically in strict mode."), Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_are_automatically_in_strict_mode: t(1252, e.DiagnosticCategory.Error, "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_1252", "Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Modules are automatically in strict mode."), A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference: t(1254, e.DiagnosticCategory.Error, "A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_refere_1254", "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."), A_definite_assignment_assertion_is_not_permitted_in_this_context: t(1255, e.DiagnosticCategory.Error, "A_definite_assignment_assertion_is_not_permitted_in_this_context_1255", "A definite assignment assertion '!' is not permitted in this context."), A_required_element_cannot_follow_an_optional_element: t(1257, e.DiagnosticCategory.Error, "A_required_element_cannot_follow_an_optional_element_1257", "A required element cannot follow an optional element."), A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration: t(1258, e.DiagnosticCategory.Error, "A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration_1258", "A default export must be at the top level of a file or module declaration."), Module_0_can_only_be_default_imported_using_the_1_flag: t(1259, e.DiagnosticCategory.Error, "Module_0_can_only_be_default_imported_using_the_1_flag_1259", "Module '{0}' can only be default-imported using the '{1}' flag"), Keywords_cannot_contain_escape_characters: t(1260, e.DiagnosticCategory.Error, "Keywords_cannot_contain_escape_characters_1260", "Keywords cannot contain escape characters."), Already_included_file_name_0_differs_from_file_name_1_only_in_casing: t(1261, e.DiagnosticCategory.Error, "Already_included_file_name_0_differs_from_file_name_1_only_in_casing_1261", "Already included file name '{0}' differs from file name '{1}' only in casing."), Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module: t(1262, e.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module_1262", "Identifier expected. '{0}' is a reserved word at the top-level of a module."), Declarations_with_initializers_cannot_also_have_definite_assignment_assertions: t(1263, e.DiagnosticCategory.Error, "Declarations_with_initializers_cannot_also_have_definite_assignment_assertions_1263", "Declarations with initializers cannot also have definite assignment assertions."), Declarations_with_definite_assignment_assertions_must_also_have_type_annotations: t(1264, e.DiagnosticCategory.Error, "Declarations_with_definite_assignment_assertions_must_also_have_type_annotations_1264", "Declarations with definite assignment assertions must also have type annotations."), A_rest_element_cannot_follow_another_rest_element: t(1265, e.DiagnosticCategory.Error, "A_rest_element_cannot_follow_another_rest_element_1265", "A rest element cannot follow another rest element."), An_optional_element_cannot_follow_a_rest_element: t(1266, e.DiagnosticCategory.Error, "An_optional_element_cannot_follow_a_rest_element_1266", "An optional element cannot follow a rest element."), Property_0_cannot_have_an_initializer_because_it_is_marked_abstract: t(1267, e.DiagnosticCategory.Error, "Property_0_cannot_have_an_initializer_because_it_is_marked_abstract_1267", "Property '{0}' cannot have an initializer because it is marked abstract."), An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type: t(1268, e.DiagnosticCategory.Error, "An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type_1268", "An index signature parameter type must be 'string', 'number', 'symbol', or a template literal type."), Cannot_use_export_import_on_a_type_or_type_only_namespace_when_the_isolatedModules_flag_is_provided: t(1269, e.DiagnosticCategory.Error, "Cannot_use_export_import_on_a_type_or_type_only_namespace_when_the_isolatedModules_flag_is_provided_1269", "Cannot use 'export import' on a type or type-only namespace when the '--isolatedModules' flag is provided."), Decorator_function_return_type_0_is_not_assignable_to_type_1: t(1270, e.DiagnosticCategory.Error, "Decorator_function_return_type_0_is_not_assignable_to_type_1_1270", "Decorator function return type '{0}' is not assignable to type '{1}'."), Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any: t(1271, e.DiagnosticCategory.Error, "Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any_1271", "Decorator function return type is '{0}' but is expected to be 'void' or 'any'."), A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled: t(1272, e.DiagnosticCategory.Error, "A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_w_1272", "A type referenced in a decorated signature must be imported with 'import type' or a namespace import when 'isolatedModules' and 'emitDecoratorMetadata' are enabled."), _0_modifier_cannot_appear_on_a_type_parameter: t(1273, e.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_type_parameter_1273", "'{0}' modifier cannot appear on a type parameter"), _0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias: t(1274, e.DiagnosticCategory.Error, "_0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias_1274", "'{0}' modifier can only appear on a type parameter of a class, interface or type alias"), accessor_modifier_can_only_appear_on_a_property_declaration: t(1275, e.DiagnosticCategory.Error, "accessor_modifier_can_only_appear_on_a_property_declaration_1275", "'accessor' modifier can only appear on a property declaration."), An_accessor_property_cannot_be_declared_optional: t(1276, e.DiagnosticCategory.Error, "An_accessor_property_cannot_be_declared_optional_1276", "An 'accessor' property cannot be declared optional."), with_statements_are_not_allowed_in_an_async_function_block: t(1300, e.DiagnosticCategory.Error, "with_statements_are_not_allowed_in_an_async_function_block_1300", "'with' statements are not allowed in an async function block."), await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules: t(1308, e.DiagnosticCategory.Error, "await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1308", "'await' expressions are only allowed within async functions and at the top levels of modules."), The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level: t(1309, e.DiagnosticCategory.Error, "The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level_1309", "The current file is a CommonJS module and cannot use 'await' at the top level."), Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern: t(1312, e.DiagnosticCategory.Error, "Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_1312", "Did you mean to use a ':'? An '=' can only follow a property name when the containing object literal is part of a destructuring pattern."), The_body_of_an_if_statement_cannot_be_the_empty_statement: t(1313, e.DiagnosticCategory.Error, "The_body_of_an_if_statement_cannot_be_the_empty_statement_1313", "The body of an 'if' statement cannot be the empty statement."), Global_module_exports_may_only_appear_in_module_files: t(1314, e.DiagnosticCategory.Error, "Global_module_exports_may_only_appear_in_module_files_1314", "Global module exports may only appear in module files."), Global_module_exports_may_only_appear_in_declaration_files: t(1315, e.DiagnosticCategory.Error, "Global_module_exports_may_only_appear_in_declaration_files_1315", "Global module exports may only appear in declaration files."), Global_module_exports_may_only_appear_at_top_level: t(1316, e.DiagnosticCategory.Error, "Global_module_exports_may_only_appear_at_top_level_1316", "Global module exports may only appear at top level."), A_parameter_property_cannot_be_declared_using_a_rest_parameter: t(1317, e.DiagnosticCategory.Error, "A_parameter_property_cannot_be_declared_using_a_rest_parameter_1317", "A parameter property cannot be declared using a rest parameter."), An_abstract_accessor_cannot_have_an_implementation: t(1318, e.DiagnosticCategory.Error, "An_abstract_accessor_cannot_have_an_implementation_1318", "An abstract accessor cannot have an implementation."), A_default_export_can_only_be_used_in_an_ECMAScript_style_module: t(1319, e.DiagnosticCategory.Error, "A_default_export_can_only_be_used_in_an_ECMAScript_style_module_1319", "A default export can only be used in an ECMAScript-style module."), Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: t(1320, e.DiagnosticCategory.Error, "Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member_1320", "Type of 'await' operand must either be a valid promise or must not contain a callable 'then' member."), Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: t(1321, e.DiagnosticCategory.Error, "Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_cal_1321", "Type of 'yield' operand in an async generator must either be a valid promise or must not contain a callable 'then' member."), Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: t(1322, e.DiagnosticCategory.Error, "Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_con_1322", "Type of iterated elements of a 'yield*' operand must either be a valid promise or must not contain a callable 'then' member."), Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext: t(1323, e.DiagnosticCategory.Error, "Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd__1323", "Dynamic imports are only supported when the '--module' flag is set to 'es2020', 'es2022', 'esnext', 'commonjs', 'amd', 'system', 'umd', 'node16', or 'nodenext'."), Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_or_nodenext: t(1324, e.DiagnosticCategory.Error, "Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_or_nod_1324", "Dynamic imports only support a second argument when the '--module' option is set to 'esnext', 'node16', or 'nodenext'."), Argument_of_dynamic_import_cannot_be_spread_element: t(1325, e.DiagnosticCategory.Error, "Argument_of_dynamic_import_cannot_be_spread_element_1325", "Argument of dynamic import cannot be spread element."), This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments: t(1326, e.DiagnosticCategory.Error, "This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot__1326", "This use of 'import' is invalid. 'import()' calls can be written, but they must have parentheses and cannot have type arguments."), String_literal_with_double_quotes_expected: t(1327, e.DiagnosticCategory.Error, "String_literal_with_double_quotes_expected_1327", "String literal with double quotes expected."), Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal: t(1328, e.DiagnosticCategory.Error, "Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_li_1328", "Property value can only be string literal, numeric literal, 'true', 'false', 'null', object literal or array literal."), _0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0: t(1329, e.DiagnosticCategory.Error, "_0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write__1329", "'{0}' accepts too few arguments to be used as a decorator here. Did you mean to call it first and write '@{0}()'?"), A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly: t(1330, e.DiagnosticCategory.Error, "A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly_1330", "A property of an interface or type literal whose type is a 'unique symbol' type must be 'readonly'."), A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly: t(1331, e.DiagnosticCategory.Error, "A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly_1331", "A property of a class whose type is a 'unique symbol' type must be both 'static' and 'readonly'."), A_variable_whose_type_is_a_unique_symbol_type_must_be_const: t(1332, e.DiagnosticCategory.Error, "A_variable_whose_type_is_a_unique_symbol_type_must_be_const_1332", "A variable whose type is a 'unique symbol' type must be 'const'."), unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name: t(1333, e.DiagnosticCategory.Error, "unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name_1333", "'unique symbol' types may not be used on a variable declaration with a binding name."), unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement: t(1334, e.DiagnosticCategory.Error, "unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement_1334", "'unique symbol' types are only allowed on variables in a variable statement."), unique_symbol_types_are_not_allowed_here: t(1335, e.DiagnosticCategory.Error, "unique_symbol_types_are_not_allowed_here_1335", "'unique symbol' types are not allowed here."), An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead: t(1337, e.DiagnosticCategory.Error, "An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_o_1337", "An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead."), infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type: t(1338, e.DiagnosticCategory.Error, "infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type_1338", "'infer' declarations are only permitted in the 'extends' clause of a conditional type."), Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here: t(1339, e.DiagnosticCategory.Error, "Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here_1339", "Module '{0}' does not refer to a value, but is used as a value here."), Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0: t(1340, e.DiagnosticCategory.Error, "Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0_1340", "Module '{0}' does not refer to a type, but is used as a type here. Did you mean 'typeof import('{0}')'?"), Class_constructor_may_not_be_an_accessor: t(1341, e.DiagnosticCategory.Error, "Class_constructor_may_not_be_an_accessor_1341", "Class constructor may not be an accessor."), Type_arguments_cannot_be_used_here: t(1342, e.DiagnosticCategory.Error, "Type_arguments_cannot_be_used_here_1342", "Type arguments cannot be used here."), The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext: t(1343, e.DiagnosticCategory.Error, "The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system__1343", "The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'es2022', 'esnext', 'system', 'node16', or 'nodenext'."), A_label_is_not_allowed_here: t(1344, e.DiagnosticCategory.Error, "A_label_is_not_allowed_here_1344", "'A label is not allowed here."), An_expression_of_type_void_cannot_be_tested_for_truthiness: t(1345, e.DiagnosticCategory.Error, "An_expression_of_type_void_cannot_be_tested_for_truthiness_1345", "An expression of type 'void' cannot be tested for truthiness."), This_parameter_is_not_allowed_with_use_strict_directive: t(1346, e.DiagnosticCategory.Error, "This_parameter_is_not_allowed_with_use_strict_directive_1346", "This parameter is not allowed with 'use strict' directive."), use_strict_directive_cannot_be_used_with_non_simple_parameter_list: t(1347, e.DiagnosticCategory.Error, "use_strict_directive_cannot_be_used_with_non_simple_parameter_list_1347", "'use strict' directive cannot be used with non-simple parameter list."), Non_simple_parameter_declared_here: t(1348, e.DiagnosticCategory.Error, "Non_simple_parameter_declared_here_1348", "Non-simple parameter declared here."), use_strict_directive_used_here: t(1349, e.DiagnosticCategory.Error, "use_strict_directive_used_here_1349", "'use strict' directive used here."), Print_the_final_configuration_instead_of_building: t(1350, e.DiagnosticCategory.Message, "Print_the_final_configuration_instead_of_building_1350", "Print the final configuration instead of building."), An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal: t(1351, e.DiagnosticCategory.Error, "An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal_1351", "An identifier or keyword cannot immediately follow a numeric literal."), A_bigint_literal_cannot_use_exponential_notation: t(1352, e.DiagnosticCategory.Error, "A_bigint_literal_cannot_use_exponential_notation_1352", "A bigint literal cannot use exponential notation."), A_bigint_literal_must_be_an_integer: t(1353, e.DiagnosticCategory.Error, "A_bigint_literal_must_be_an_integer_1353", "A bigint literal must be an integer."), readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types: t(1354, e.DiagnosticCategory.Error, "readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types_1354", "'readonly' type modifier is only permitted on array and tuple literal types."), A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals: t(1355, e.DiagnosticCategory.Error, "A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array__1355", "A 'const' assertions can only be applied to references to enum members, or string, number, boolean, array, or object literals."), Did_you_mean_to_mark_this_function_as_async: t(1356, e.DiagnosticCategory.Error, "Did_you_mean_to_mark_this_function_as_async_1356", "Did you mean to mark this function as 'async'?"), An_enum_member_name_must_be_followed_by_a_or: t(1357, e.DiagnosticCategory.Error, "An_enum_member_name_must_be_followed_by_a_or_1357", "An enum member name must be followed by a ',', '=', or '}'."), Tagged_template_expressions_are_not_permitted_in_an_optional_chain: t(1358, e.DiagnosticCategory.Error, "Tagged_template_expressions_are_not_permitted_in_an_optional_chain_1358", "Tagged template expressions are not permitted in an optional chain."), Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here: t(1359, e.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here_1359", "Identifier expected. '{0}' is a reserved word that cannot be used here."), Type_0_does_not_satisfy_the_expected_type_1: t(1360, e.DiagnosticCategory.Error, "Type_0_does_not_satisfy_the_expected_type_1_1360", "Type '{0}' does not satisfy the expected type '{1}'."), _0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type: t(1361, e.DiagnosticCategory.Error, "_0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type_1361", "'{0}' cannot be used as a value because it was imported using 'import type'."), _0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type: t(1362, e.DiagnosticCategory.Error, "_0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type_1362", "'{0}' cannot be used as a value because it was exported using 'export type'."), A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both: t(1363, e.DiagnosticCategory.Error, "A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both_1363", "A type-only import can specify a default import or named bindings, but not both."), Convert_to_type_only_export: t(1364, e.DiagnosticCategory.Message, "Convert_to_type_only_export_1364", "Convert to type-only export"), Convert_all_re_exported_types_to_type_only_exports: t(1365, e.DiagnosticCategory.Message, "Convert_all_re_exported_types_to_type_only_exports_1365", "Convert all re-exported types to type-only exports"), Split_into_two_separate_import_declarations: t(1366, e.DiagnosticCategory.Message, "Split_into_two_separate_import_declarations_1366", "Split into two separate import declarations"), Split_all_invalid_type_only_imports: t(1367, e.DiagnosticCategory.Message, "Split_all_invalid_type_only_imports_1367", "Split all invalid type-only imports"), Class_constructor_may_not_be_a_generator: t(1368, e.DiagnosticCategory.Error, "Class_constructor_may_not_be_a_generator_1368", "Class constructor may not be a generator."), Did_you_mean_0: t(1369, e.DiagnosticCategory.Message, "Did_you_mean_0_1369", "Did you mean '{0}'?"), This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set_to_error: t(1371, e.DiagnosticCategory.Error, "This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set__1371", "This import is never used as a value and must use 'import type' because 'importsNotUsedAsValues' is set to 'error'."), Convert_to_type_only_import: t(1373, e.DiagnosticCategory.Message, "Convert_to_type_only_import_1373", "Convert to type-only import"), Convert_all_imports_not_used_as_a_value_to_type_only_imports: t(1374, e.DiagnosticCategory.Message, "Convert_all_imports_not_used_as_a_value_to_type_only_imports_1374", "Convert all imports not used as a value to type-only imports"), await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module: t(1375, e.DiagnosticCategory.Error, "await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_fi_1375", "'await' expressions are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module."), _0_was_imported_here: t(1376, e.DiagnosticCategory.Message, "_0_was_imported_here_1376", "'{0}' was imported here."), _0_was_exported_here: t(1377, e.DiagnosticCategory.Message, "_0_was_exported_here_1377", "'{0}' was exported here."), Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher: t(1378, e.DiagnosticCategory.Error, "Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_n_1378", "Top-level 'await' expressions are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', or 'nodenext', and the 'target' option is set to 'es2017' or higher."), An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type: t(1379, e.DiagnosticCategory.Error, "An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type_1379", "An import alias cannot reference a declaration that was exported using 'export type'."), An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type: t(1380, e.DiagnosticCategory.Error, "An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type_1380", "An import alias cannot reference a declaration that was imported using 'import type'."), Unexpected_token_Did_you_mean_or_rbrace: t(1381, e.DiagnosticCategory.Error, "Unexpected_token_Did_you_mean_or_rbrace_1381", "Unexpected token. Did you mean `{'}'}` or `&rbrace;`?"), Unexpected_token_Did_you_mean_or_gt: t(1382, e.DiagnosticCategory.Error, "Unexpected_token_Did_you_mean_or_gt_1382", "Unexpected token. Did you mean `{'>'}` or `&gt;`?"), Only_named_exports_may_use_export_type: t(1383, e.DiagnosticCategory.Error, "Only_named_exports_may_use_export_type_1383", "Only named exports may use 'export type'."), Function_type_notation_must_be_parenthesized_when_used_in_a_union_type: t(1385, e.DiagnosticCategory.Error, "Function_type_notation_must_be_parenthesized_when_used_in_a_union_type_1385", "Function type notation must be parenthesized when used in a union type."), Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type: t(1386, e.DiagnosticCategory.Error, "Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type_1386", "Constructor type notation must be parenthesized when used in a union type."), Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type: t(1387, e.DiagnosticCategory.Error, "Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1387", "Function type notation must be parenthesized when used in an intersection type."), Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type: t(1388, e.DiagnosticCategory.Error, "Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1388", "Constructor type notation must be parenthesized when used in an intersection type."), _0_is_not_allowed_as_a_variable_declaration_name: t(1389, e.DiagnosticCategory.Error, "_0_is_not_allowed_as_a_variable_declaration_name_1389", "'{0}' is not allowed as a variable declaration name."), _0_is_not_allowed_as_a_parameter_name: t(1390, e.DiagnosticCategory.Error, "_0_is_not_allowed_as_a_parameter_name_1390", "'{0}' is not allowed as a parameter name."), An_import_alias_cannot_use_import_type: t(1392, e.DiagnosticCategory.Error, "An_import_alias_cannot_use_import_type_1392", "An import alias cannot use 'import type'"), Imported_via_0_from_file_1: t(1393, e.DiagnosticCategory.Message, "Imported_via_0_from_file_1_1393", "Imported via {0} from file '{1}'"), Imported_via_0_from_file_1_with_packageId_2: t(1394, e.DiagnosticCategory.Message, "Imported_via_0_from_file_1_with_packageId_2_1394", "Imported via {0} from file '{1}' with packageId '{2}'"), Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions: t(1395, e.DiagnosticCategory.Message, "Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions_1395", "Imported via {0} from file '{1}' to import 'importHelpers' as specified in compilerOptions"), Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions: t(1396, e.DiagnosticCategory.Message, "Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions_1396", "Imported via {0} from file '{1}' with packageId '{2}' to import 'importHelpers' as specified in compilerOptions"), Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions: t(1397, e.DiagnosticCategory.Message, "Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions_1397", "Imported via {0} from file '{1}' to import 'jsx' and 'jsxs' factory functions"), Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions: t(1398, e.DiagnosticCategory.Message, "Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions_1398", "Imported via {0} from file '{1}' with packageId '{2}' to import 'jsx' and 'jsxs' factory functions"), File_is_included_via_import_here: t(1399, e.DiagnosticCategory.Message, "File_is_included_via_import_here_1399", "File is included via import here."), Referenced_via_0_from_file_1: t(1400, e.DiagnosticCategory.Message, "Referenced_via_0_from_file_1_1400", "Referenced via '{0}' from file '{1}'"), File_is_included_via_reference_here: t(1401, e.DiagnosticCategory.Message, "File_is_included_via_reference_here_1401", "File is included via reference here."), Type_library_referenced_via_0_from_file_1: t(1402, e.DiagnosticCategory.Message, "Type_library_referenced_via_0_from_file_1_1402", "Type library referenced via '{0}' from file '{1}'"), Type_library_referenced_via_0_from_file_1_with_packageId_2: t(1403, e.DiagnosticCategory.Message, "Type_library_referenced_via_0_from_file_1_with_packageId_2_1403", "Type library referenced via '{0}' from file '{1}' with packageId '{2}'"), File_is_included_via_type_library_reference_here: t(1404, e.DiagnosticCategory.Message, "File_is_included_via_type_library_reference_here_1404", "File is included via type library reference here."), Library_referenced_via_0_from_file_1: t(1405, e.DiagnosticCategory.Message, "Library_referenced_via_0_from_file_1_1405", "Library referenced via '{0}' from file '{1}'"), File_is_included_via_library_reference_here: t(1406, e.DiagnosticCategory.Message, "File_is_included_via_library_reference_here_1406", "File is included via library reference here."), Matched_by_include_pattern_0_in_1: t(1407, e.DiagnosticCategory.Message, "Matched_by_include_pattern_0_in_1_1407", "Matched by include pattern '{0}' in '{1}'"), File_is_matched_by_include_pattern_specified_here: t(1408, e.DiagnosticCategory.Message, "File_is_matched_by_include_pattern_specified_here_1408", "File is matched by include pattern specified here."), Part_of_files_list_in_tsconfig_json: t(1409, e.DiagnosticCategory.Message, "Part_of_files_list_in_tsconfig_json_1409", "Part of 'files' list in tsconfig.json"), File_is_matched_by_files_list_specified_here: t(1410, e.DiagnosticCategory.Message, "File_is_matched_by_files_list_specified_here_1410", "File is matched by 'files' list specified here."), Output_from_referenced_project_0_included_because_1_specified: t(1411, e.DiagnosticCategory.Message, "Output_from_referenced_project_0_included_because_1_specified_1411", "Output from referenced project '{0}' included because '{1}' specified"), Output_from_referenced_project_0_included_because_module_is_specified_as_none: t(1412, e.DiagnosticCategory.Message, "Output_from_referenced_project_0_included_because_module_is_specified_as_none_1412", "Output from referenced project '{0}' included because '--module' is specified as 'none'"), File_is_output_from_referenced_project_specified_here: t(1413, e.DiagnosticCategory.Message, "File_is_output_from_referenced_project_specified_here_1413", "File is output from referenced project specified here."), Source_from_referenced_project_0_included_because_1_specified: t(1414, e.DiagnosticCategory.Message, "Source_from_referenced_project_0_included_because_1_specified_1414", "Source from referenced project '{0}' included because '{1}' specified"), Source_from_referenced_project_0_included_because_module_is_specified_as_none: t(1415, e.DiagnosticCategory.Message, "Source_from_referenced_project_0_included_because_module_is_specified_as_none_1415", "Source from referenced project '{0}' included because '--module' is specified as 'none'"), File_is_source_from_referenced_project_specified_here: t(1416, e.DiagnosticCategory.Message, "File_is_source_from_referenced_project_specified_here_1416", "File is source from referenced project specified here."), Entry_point_of_type_library_0_specified_in_compilerOptions: t(1417, e.DiagnosticCategory.Message, "Entry_point_of_type_library_0_specified_in_compilerOptions_1417", "Entry point of type library '{0}' specified in compilerOptions"), Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1: t(1418, e.DiagnosticCategory.Message, "Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1_1418", "Entry point of type library '{0}' specified in compilerOptions with packageId '{1}'"), File_is_entry_point_of_type_library_specified_here: t(1419, e.DiagnosticCategory.Message, "File_is_entry_point_of_type_library_specified_here_1419", "File is entry point of type library specified here."), Entry_point_for_implicit_type_library_0: t(1420, e.DiagnosticCategory.Message, "Entry_point_for_implicit_type_library_0_1420", "Entry point for implicit type library '{0}'"), Entry_point_for_implicit_type_library_0_with_packageId_1: t(1421, e.DiagnosticCategory.Message, "Entry_point_for_implicit_type_library_0_with_packageId_1_1421", "Entry point for implicit type library '{0}' with packageId '{1}'"), Library_0_specified_in_compilerOptions: t(1422, e.DiagnosticCategory.Message, "Library_0_specified_in_compilerOptions_1422", "Library '{0}' specified in compilerOptions"), File_is_library_specified_here: t(1423, e.DiagnosticCategory.Message, "File_is_library_specified_here_1423", "File is library specified here."), Default_library: t(1424, e.DiagnosticCategory.Message, "Default_library_1424", "Default library"), Default_library_for_target_0: t(1425, e.DiagnosticCategory.Message, "Default_library_for_target_0_1425", "Default library for target '{0}'"), File_is_default_library_for_target_specified_here: t(1426, e.DiagnosticCategory.Message, "File_is_default_library_for_target_specified_here_1426", "File is default library for target specified here."), Root_file_specified_for_compilation: t(1427, e.DiagnosticCategory.Message, "Root_file_specified_for_compilation_1427", "Root file specified for compilation"), File_is_output_of_project_reference_source_0: t(1428, e.DiagnosticCategory.Message, "File_is_output_of_project_reference_source_0_1428", "File is output of project reference source '{0}'"), File_redirects_to_file_0: t(1429, e.DiagnosticCategory.Message, "File_redirects_to_file_0_1429", "File redirects to file '{0}'"), The_file_is_in_the_program_because_Colon: t(1430, e.DiagnosticCategory.Message, "The_file_is_in_the_program_because_Colon_1430", "The file is in the program because:"), for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module: t(1431, e.DiagnosticCategory.Error, "for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_1431", "'for await' loops are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module."), Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher: t(1432, e.DiagnosticCategory.Error, "Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_nod_1432", "Top-level 'for await' loops are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', or 'nodenext', and the 'target' option is set to 'es2017' or higher."), Decorators_may_not_be_applied_to_this_parameters: t(1433, e.DiagnosticCategory.Error, "Decorators_may_not_be_applied_to_this_parameters_1433", "Decorators may not be applied to 'this' parameters."), Unexpected_keyword_or_identifier: t(1434, e.DiagnosticCategory.Error, "Unexpected_keyword_or_identifier_1434", "Unexpected keyword or identifier."), Unknown_keyword_or_identifier_Did_you_mean_0: t(1435, e.DiagnosticCategory.Error, "Unknown_keyword_or_identifier_Did_you_mean_0_1435", "Unknown keyword or identifier. Did you mean '{0}'?"), Decorators_must_precede_the_name_and_all_keywords_of_property_declarations: t(1436, e.DiagnosticCategory.Error, "Decorators_must_precede_the_name_and_all_keywords_of_property_declarations_1436", "Decorators must precede the name and all keywords of property declarations."), Namespace_must_be_given_a_name: t(1437, e.DiagnosticCategory.Error, "Namespace_must_be_given_a_name_1437", "Namespace must be given a name."), Interface_must_be_given_a_name: t(1438, e.DiagnosticCategory.Error, "Interface_must_be_given_a_name_1438", "Interface must be given a name."), Type_alias_must_be_given_a_name: t(1439, e.DiagnosticCategory.Error, "Type_alias_must_be_given_a_name_1439", "Type alias must be given a name."), Variable_declaration_not_allowed_at_this_location: t(1440, e.DiagnosticCategory.Error, "Variable_declaration_not_allowed_at_this_location_1440", "Variable declaration not allowed at this location."), Cannot_start_a_function_call_in_a_type_annotation: t(1441, e.DiagnosticCategory.Error, "Cannot_start_a_function_call_in_a_type_annotation_1441", "Cannot start a function call in a type annotation."), Expected_for_property_initializer: t(1442, e.DiagnosticCategory.Error, "Expected_for_property_initializer_1442", "Expected '=' for property initializer."), Module_declaration_names_may_only_use_or_quoted_strings: t(1443, e.DiagnosticCategory.Error, "Module_declaration_names_may_only_use_or_quoted_strings_1443", `Module declaration names may only use ' or " quoted strings.`), _0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled: t(1444, e.DiagnosticCategory.Error, "_0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedMod_1444", "'{0}' is a type and must be imported using a type-only import when 'preserveValueImports' and 'isolatedModules' are both enabled."), _0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled: t(1446, e.DiagnosticCategory.Error, "_0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveVa_1446", "'{0}' resolves to a type-only declaration and must be imported using a type-only import when 'preserveValueImports' and 'isolatedModules' are both enabled."), _0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_isolatedModules_is_enabled: t(1448, e.DiagnosticCategory.Error, "_0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_isol_1448", "'{0}' resolves to a type-only declaration and must be re-exported using a type-only re-export when 'isolatedModules' is enabled."), Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed: t(1449, e.DiagnosticCategory.Message, "Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed_1449", "Preserve unused imported values in the JavaScript output that would otherwise be removed."), Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments: t(1450, e.DiagnosticCategory.Message, "Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments_1450", "Dynamic imports can only accept a module specifier and an optional assertion as arguments"), Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression: t(1451, e.DiagnosticCategory.Error, "Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member__1451", "Private identifiers are only allowed in class bodies and may only be used as part of a class member declaration, property access, or on the left-hand-side of an 'in' expression"), resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext: t(1452, e.DiagnosticCategory.Error, "resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext_1452", "'resolution-mode' assertions are only supported when `moduleResolution` is `node16` or `nodenext`."), resolution_mode_should_be_either_require_or_import: t(1453, e.DiagnosticCategory.Error, "resolution_mode_should_be_either_require_or_import_1453", "`resolution-mode` should be either `require` or `import`."), resolution_mode_can_only_be_set_for_type_only_imports: t(1454, e.DiagnosticCategory.Error, "resolution_mode_can_only_be_set_for_type_only_imports_1454", "`resolution-mode` can only be set for type-only imports."), resolution_mode_is_the_only_valid_key_for_type_import_assertions: t(1455, e.DiagnosticCategory.Error, "resolution_mode_is_the_only_valid_key_for_type_import_assertions_1455", "`resolution-mode` is the only valid key for type import assertions."), Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require: t(1456, e.DiagnosticCategory.Error, "Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require_1456", "Type import assertions should have exactly one key - `resolution-mode` - with value `import` or `require`."), Matched_by_default_include_pattern_Asterisk_Asterisk_Slash_Asterisk: t(1457, e.DiagnosticCategory.Message, "Matched_by_default_include_pattern_Asterisk_Asterisk_Slash_Asterisk_1457", "Matched by default include pattern '**/*'"), File_is_ECMAScript_module_because_0_has_field_type_with_value_module: t(1458, e.DiagnosticCategory.Message, "File_is_ECMAScript_module_because_0_has_field_type_with_value_module_1458", `File is ECMAScript module because '{0}' has field "type" with value "module"`), File_is_CommonJS_module_because_0_has_field_type_whose_value_is_not_module: t(1459, e.DiagnosticCategory.Message, "File_is_CommonJS_module_because_0_has_field_type_whose_value_is_not_module_1459", `File is CommonJS module because '{0}' has field "type" whose value is not "module"`), File_is_CommonJS_module_because_0_does_not_have_field_type: t(1460, e.DiagnosticCategory.Message, "File_is_CommonJS_module_because_0_does_not_have_field_type_1460", `File is CommonJS module because '{0}' does not have field "type"`), File_is_CommonJS_module_because_package_json_was_not_found: t(1461, e.DiagnosticCategory.Message, "File_is_CommonJS_module_because_package_json_was_not_found_1461", "File is CommonJS module because 'package.json' was not found"), The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output: t(1470, e.DiagnosticCategory.Error, "The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output_1470", "The 'import.meta' meta-property is not allowed in files which will build into CommonJS output."), Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead: t(1471, e.DiagnosticCategory.Error, "Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_c_1471", "Module '{0}' cannot be imported using this construct. The specifier only resolves to an ES module, which cannot be imported with 'require'. Use an ECMAScript import instead."), catch_or_finally_expected: t(1472, e.DiagnosticCategory.Error, "catch_or_finally_expected_1472", "'catch' or 'finally' expected."), An_import_declaration_can_only_be_used_at_the_top_level_of_a_module: t(1473, e.DiagnosticCategory.Error, "An_import_declaration_can_only_be_used_at_the_top_level_of_a_module_1473", "An import declaration can only be used at the top level of a module."), An_export_declaration_can_only_be_used_at_the_top_level_of_a_module: t(1474, e.DiagnosticCategory.Error, "An_export_declaration_can_only_be_used_at_the_top_level_of_a_module_1474", "An export declaration can only be used at the top level of a module."), Control_what_method_is_used_to_detect_module_format_JS_files: t(1475, e.DiagnosticCategory.Message, "Control_what_method_is_used_to_detect_module_format_JS_files_1475", "Control what method is used to detect module-format JS files."), auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_with_module_Colon_node16_as_modules: t(1476, e.DiagnosticCategory.Message, "auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_w_1476", '"auto": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.'), An_instantiation_expression_cannot_be_followed_by_a_property_access: t(1477, e.DiagnosticCategory.Error, "An_instantiation_expression_cannot_be_followed_by_a_property_access_1477", "An instantiation expression cannot be followed by a property access."), Identifier_or_string_literal_expected: t(1478, e.DiagnosticCategory.Error, "Identifier_or_string_literal_expected_1478", "Identifier or string literal expected."), The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead: t(1479, e.DiagnosticCategory.Error, "The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_reference_1479", `The current file is a CommonJS module whose imports will produce 'require' calls; however, the referenced file is an ECMAScript module and cannot be imported with 'require'. Consider writing a dynamic 'import("{0}")' call instead.`), To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_package_json_file_with_type_Colon_module: t(1480, e.DiagnosticCategory.Message, "To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_packag_1480", 'To convert this file to an ECMAScript module, change its file extension to \'{0}\' or create a local package.json file with `{ "type": "module" }`.'), To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Colon_module_to_1: t(1481, e.DiagnosticCategory.Message, "To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Co_1481", `To convert this file to an ECMAScript module, change its file extension to '{0}', or add the field \`"type": "module"\` to '{1}'.`), To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0: t(1482, e.DiagnosticCategory.Message, "To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0_1482", 'To convert this file to an ECMAScript module, add the field `"type": "module"` to \'{0}\'.'), To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_Colon_module: t(1483, e.DiagnosticCategory.Message, "To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_Colon_module_1483", 'To convert this file to an ECMAScript module, create a local package.json file with `{ "type": "module" }`.'), The_types_of_0_are_incompatible_between_these_types: t(2200, e.DiagnosticCategory.Error, "The_types_of_0_are_incompatible_between_these_types_2200", "The types of '{0}' are incompatible between these types."), The_types_returned_by_0_are_incompatible_between_these_types: t(2201, e.DiagnosticCategory.Error, "The_types_returned_by_0_are_incompatible_between_these_types_2201", "The types returned by '{0}' are incompatible between these types."), Call_signature_return_types_0_and_1_are_incompatible: t(2202, e.DiagnosticCategory.Error, "Call_signature_return_types_0_and_1_are_incompatible_2202", "Call signature return types '{0}' and '{1}' are incompatible.", void 0, true), Construct_signature_return_types_0_and_1_are_incompatible: t(2203, e.DiagnosticCategory.Error, "Construct_signature_return_types_0_and_1_are_incompatible_2203", "Construct signature return types '{0}' and '{1}' are incompatible.", void 0, true), Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1: t(2204, e.DiagnosticCategory.Error, "Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2204", "Call signatures with no arguments have incompatible return types '{0}' and '{1}'.", void 0, true), Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1: t(2205, e.DiagnosticCategory.Error, "Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2205", "Construct signatures with no arguments have incompatible return types '{0}' and '{1}'.", void 0, true), The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement: t(2206, e.DiagnosticCategory.Error, "The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement_2206", "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."), The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement: t(2207, e.DiagnosticCategory.Error, "The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement_2207", "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."), This_type_parameter_might_need_an_extends_0_constraint: t(2208, e.DiagnosticCategory.Error, "This_type_parameter_might_need_an_extends_0_constraint_2208", "This type parameter might need an `extends {0}` constraint."), The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate: t(2209, e.DiagnosticCategory.Error, "The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_roo_2209", "The project root is ambiguous, but is required to resolve export map entry '{0}' in file '{1}'. Supply the `rootDir` compiler option to disambiguate."), The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate: t(2210, e.DiagnosticCategory.Error, "The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_roo_2210", "The project root is ambiguous, but is required to resolve import map entry '{0}' in file '{1}'. Supply the `rootDir` compiler option to disambiguate."), Add_extends_constraint: t(2211, e.DiagnosticCategory.Message, "Add_extends_constraint_2211", "Add `extends` constraint."), Add_extends_constraint_to_all_type_parameters: t(2212, e.DiagnosticCategory.Message, "Add_extends_constraint_to_all_type_parameters_2212", "Add `extends` constraint to all type parameters"), Duplicate_identifier_0: t(2300, e.DiagnosticCategory.Error, "Duplicate_identifier_0_2300", "Duplicate identifier '{0}'."), Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: t(2301, e.DiagnosticCategory.Error, "Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2301", "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor."), Static_members_cannot_reference_class_type_parameters: t(2302, e.DiagnosticCategory.Error, "Static_members_cannot_reference_class_type_parameters_2302", "Static members cannot reference class type parameters."), Circular_definition_of_import_alias_0: t(2303, e.DiagnosticCategory.Error, "Circular_definition_of_import_alias_0_2303", "Circular definition of import alias '{0}'."), Cannot_find_name_0: t(2304, e.DiagnosticCategory.Error, "Cannot_find_name_0_2304", "Cannot find name '{0}'."), Module_0_has_no_exported_member_1: t(2305, e.DiagnosticCategory.Error, "Module_0_has_no_exported_member_1_2305", "Module '{0}' has no exported member '{1}'."), File_0_is_not_a_module: t(2306, e.DiagnosticCategory.Error, "File_0_is_not_a_module_2306", "File '{0}' is not a module."), Cannot_find_module_0_or_its_corresponding_type_declarations: t(2307, e.DiagnosticCategory.Error, "Cannot_find_module_0_or_its_corresponding_type_declarations_2307", "Cannot find module '{0}' or its corresponding type declarations."), Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity: t(2308, e.DiagnosticCategory.Error, "Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambig_2308", "Module {0} has already exported a member named '{1}'. Consider explicitly re-exporting to resolve the ambiguity."), An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements: t(2309, e.DiagnosticCategory.Error, "An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements_2309", "An export assignment cannot be used in a module with other exported elements."), Type_0_recursively_references_itself_as_a_base_type: t(2310, e.DiagnosticCategory.Error, "Type_0_recursively_references_itself_as_a_base_type_2310", "Type '{0}' recursively references itself as a base type."), Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function: t(2311, e.DiagnosticCategory.Error, "Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function_2311", "Cannot find name '{0}'. Did you mean to write this in an async function?"), An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members: t(2312, e.DiagnosticCategory.Error, "An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_me_2312", "An interface can only extend an object type or intersection of object types with statically known members."), Type_parameter_0_has_a_circular_constraint: t(2313, e.DiagnosticCategory.Error, "Type_parameter_0_has_a_circular_constraint_2313", "Type parameter '{0}' has a circular constraint."), Generic_type_0_requires_1_type_argument_s: t(2314, e.DiagnosticCategory.Error, "Generic_type_0_requires_1_type_argument_s_2314", "Generic type '{0}' requires {1} type argument(s)."), Type_0_is_not_generic: t(2315, e.DiagnosticCategory.Error, "Type_0_is_not_generic_2315", "Type '{0}' is not generic."), Global_type_0_must_be_a_class_or_interface_type: t(2316, e.DiagnosticCategory.Error, "Global_type_0_must_be_a_class_or_interface_type_2316", "Global type '{0}' must be a class or interface type."), Global_type_0_must_have_1_type_parameter_s: t(2317, e.DiagnosticCategory.Error, "Global_type_0_must_have_1_type_parameter_s_2317", "Global type '{0}' must have {1} type parameter(s)."), Cannot_find_global_type_0: t(2318, e.DiagnosticCategory.Error, "Cannot_find_global_type_0_2318", "Cannot find global type '{0}'."), Named_property_0_of_types_1_and_2_are_not_identical: t(2319, e.DiagnosticCategory.Error, "Named_property_0_of_types_1_and_2_are_not_identical_2319", "Named property '{0}' of types '{1}' and '{2}' are not identical."), Interface_0_cannot_simultaneously_extend_types_1_and_2: t(2320, e.DiagnosticCategory.Error, "Interface_0_cannot_simultaneously_extend_types_1_and_2_2320", "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'."), Excessive_stack_depth_comparing_types_0_and_1: t(2321, e.DiagnosticCategory.Error, "Excessive_stack_depth_comparing_types_0_and_1_2321", "Excessive stack depth comparing types '{0}' and '{1}'."), Type_0_is_not_assignable_to_type_1: t(2322, e.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_2322", "Type '{0}' is not assignable to type '{1}'."), Cannot_redeclare_exported_variable_0: t(2323, e.DiagnosticCategory.Error, "Cannot_redeclare_exported_variable_0_2323", "Cannot redeclare exported variable '{0}'."), Property_0_is_missing_in_type_1: t(2324, e.DiagnosticCategory.Error, "Property_0_is_missing_in_type_1_2324", "Property '{0}' is missing in type '{1}'."), Property_0_is_private_in_type_1_but_not_in_type_2: t(2325, e.DiagnosticCategory.Error, "Property_0_is_private_in_type_1_but_not_in_type_2_2325", "Property '{0}' is private in type '{1}' but not in type '{2}'."), Types_of_property_0_are_incompatible: t(2326, e.DiagnosticCategory.Error, "Types_of_property_0_are_incompatible_2326", "Types of property '{0}' are incompatible."), Property_0_is_optional_in_type_1_but_required_in_type_2: t(2327, e.DiagnosticCategory.Error, "Property_0_is_optional_in_type_1_but_required_in_type_2_2327", "Property '{0}' is optional in type '{1}' but required in type '{2}'."), Types_of_parameters_0_and_1_are_incompatible: t(2328, e.DiagnosticCategory.Error, "Types_of_parameters_0_and_1_are_incompatible_2328", "Types of parameters '{0}' and '{1}' are incompatible."), Index_signature_for_type_0_is_missing_in_type_1: t(2329, e.DiagnosticCategory.Error, "Index_signature_for_type_0_is_missing_in_type_1_2329", "Index signature for type '{0}' is missing in type '{1}'."), _0_and_1_index_signatures_are_incompatible: t(2330, e.DiagnosticCategory.Error, "_0_and_1_index_signatures_are_incompatible_2330", "'{0}' and '{1}' index signatures are incompatible."), this_cannot_be_referenced_in_a_module_or_namespace_body: t(2331, e.DiagnosticCategory.Error, "this_cannot_be_referenced_in_a_module_or_namespace_body_2331", "'this' cannot be referenced in a module or namespace body."), this_cannot_be_referenced_in_current_location: t(2332, e.DiagnosticCategory.Error, "this_cannot_be_referenced_in_current_location_2332", "'this' cannot be referenced in current location."), this_cannot_be_referenced_in_constructor_arguments: t(2333, e.DiagnosticCategory.Error, "this_cannot_be_referenced_in_constructor_arguments_2333", "'this' cannot be referenced in constructor arguments."), this_cannot_be_referenced_in_a_static_property_initializer: t(2334, e.DiagnosticCategory.Error, "this_cannot_be_referenced_in_a_static_property_initializer_2334", "'this' cannot be referenced in a static property initializer."), super_can_only_be_referenced_in_a_derived_class: t(2335, e.DiagnosticCategory.Error, "super_can_only_be_referenced_in_a_derived_class_2335", "'super' can only be referenced in a derived class."), super_cannot_be_referenced_in_constructor_arguments: t(2336, e.DiagnosticCategory.Error, "super_cannot_be_referenced_in_constructor_arguments_2336", "'super' cannot be referenced in constructor arguments."), Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: t(2337, e.DiagnosticCategory.Error, "Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors_2337", "Super calls are not permitted outside constructors or in nested functions inside constructors."), super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: t(2338, e.DiagnosticCategory.Error, "super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_der_2338", "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class."), Property_0_does_not_exist_on_type_1: t(2339, e.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_2339", "Property '{0}' does not exist on type '{1}'."), Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword: t(2340, e.DiagnosticCategory.Error, "Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword_2340", "Only public and protected methods of the base class are accessible via the 'super' keyword."), Property_0_is_private_and_only_accessible_within_class_1: t(2341, e.DiagnosticCategory.Error, "Property_0_is_private_and_only_accessible_within_class_1_2341", "Property '{0}' is private and only accessible within class '{1}'."), This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0: t(2343, e.DiagnosticCategory.Error, "This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_ve_2343", "This syntax requires an imported helper named '{1}' which does not exist in '{0}'. Consider upgrading your version of '{0}'."), Type_0_does_not_satisfy_the_constraint_1: t(2344, e.DiagnosticCategory.Error, "Type_0_does_not_satisfy_the_constraint_1_2344", "Type '{0}' does not satisfy the constraint '{1}'."), Argument_of_type_0_is_not_assignable_to_parameter_of_type_1: t(2345, e.DiagnosticCategory.Error, "Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_2345", "Argument of type '{0}' is not assignable to parameter of type '{1}'."), Call_target_does_not_contain_any_signatures: t(2346, e.DiagnosticCategory.Error, "Call_target_does_not_contain_any_signatures_2346", "Call target does not contain any signatures."), Untyped_function_calls_may_not_accept_type_arguments: t(2347, e.DiagnosticCategory.Error, "Untyped_function_calls_may_not_accept_type_arguments_2347", "Untyped function calls may not accept type arguments."), Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: t(2348, e.DiagnosticCategory.Error, "Value_of_type_0_is_not_callable_Did_you_mean_to_include_new_2348", "Value of type '{0}' is not callable. Did you mean to include 'new'?"), This_expression_is_not_callable: t(2349, e.DiagnosticCategory.Error, "This_expression_is_not_callable_2349", "This expression is not callable."), Only_a_void_function_can_be_called_with_the_new_keyword: t(2350, e.DiagnosticCategory.Error, "Only_a_void_function_can_be_called_with_the_new_keyword_2350", "Only a void function can be called with the 'new' keyword."), This_expression_is_not_constructable: t(2351, e.DiagnosticCategory.Error, "This_expression_is_not_constructable_2351", "This expression is not constructable."), Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first: t(2352, e.DiagnosticCategory.Error, "Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the__2352", "Conversion of type '{0}' to type '{1}' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first."), Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1: t(2353, e.DiagnosticCategory.Error, "Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1_2353", "Object literal may only specify known properties, and '{0}' does not exist in type '{1}'."), This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found: t(2354, e.DiagnosticCategory.Error, "This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found_2354", "This syntax requires an imported helper but module '{0}' cannot be found."), A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value: t(2355, e.DiagnosticCategory.Error, "A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_2355", "A function whose declared type is neither 'void' nor 'any' must return a value."), An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type: t(2356, e.DiagnosticCategory.Error, "An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type_2356", "An arithmetic operand must be of type 'any', 'number', 'bigint' or an enum type."), The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access: t(2357, e.DiagnosticCategory.Error, "The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access_2357", "The operand of an increment or decrement operator must be a variable or a property access."), The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: t(2358, e.DiagnosticCategory.Error, "The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_paramete_2358", "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter."), The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: t(2359, e.DiagnosticCategory.Error, "The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_F_2359", "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type."), The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type: t(2362, e.DiagnosticCategory.Error, "The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2362", "The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type."), The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type: t(2363, e.DiagnosticCategory.Error, "The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2363", "The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type."), The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access: t(2364, e.DiagnosticCategory.Error, "The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access_2364", "The left-hand side of an assignment expression must be a variable or a property access."), Operator_0_cannot_be_applied_to_types_1_and_2: t(2365, e.DiagnosticCategory.Error, "Operator_0_cannot_be_applied_to_types_1_and_2_2365", "Operator '{0}' cannot be applied to types '{1}' and '{2}'."), Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined: t(2366, e.DiagnosticCategory.Error, "Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined_2366", "Function lacks ending return statement and return type does not include 'undefined'."), This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap: t(2367, e.DiagnosticCategory.Error, "This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap_2367", "This comparison appears to be unintentional because the types '{0}' and '{1}' have no overlap."), Type_parameter_name_cannot_be_0: t(2368, e.DiagnosticCategory.Error, "Type_parameter_name_cannot_be_0_2368", "Type parameter name cannot be '{0}'."), A_parameter_property_is_only_allowed_in_a_constructor_implementation: t(2369, e.DiagnosticCategory.Error, "A_parameter_property_is_only_allowed_in_a_constructor_implementation_2369", "A parameter property is only allowed in a constructor implementation."), A_rest_parameter_must_be_of_an_array_type: t(2370, e.DiagnosticCategory.Error, "A_rest_parameter_must_be_of_an_array_type_2370", "A rest parameter must be of an array type."), A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: t(2371, e.DiagnosticCategory.Error, "A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation_2371", "A parameter initializer is only allowed in a function or constructor implementation."), Parameter_0_cannot_reference_itself: t(2372, e.DiagnosticCategory.Error, "Parameter_0_cannot_reference_itself_2372", "Parameter '{0}' cannot reference itself."), Parameter_0_cannot_reference_identifier_1_declared_after_it: t(2373, e.DiagnosticCategory.Error, "Parameter_0_cannot_reference_identifier_1_declared_after_it_2373", "Parameter '{0}' cannot reference identifier '{1}' declared after it."), Duplicate_index_signature_for_type_0: t(2374, e.DiagnosticCategory.Error, "Duplicate_index_signature_for_type_0_2374", "Duplicate index signature for type '{0}'."), Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties: t(2375, e.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefi_2375", "Type '{0}' is not assignable to type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties."), A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers: t(2376, e.DiagnosticCategory.Error, "A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_2376", "A 'super' call must be the first statement in the constructor to refer to 'super' or 'this' when a derived class contains initialized properties, parameter properties, or private identifiers."), Constructors_for_derived_classes_must_contain_a_super_call: t(2377, e.DiagnosticCategory.Error, "Constructors_for_derived_classes_must_contain_a_super_call_2377", "Constructors for derived classes must contain a 'super' call."), A_get_accessor_must_return_a_value: t(2378, e.DiagnosticCategory.Error, "A_get_accessor_must_return_a_value_2378", "A 'get' accessor must return a value."), Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties: t(2379, e.DiagnosticCategory.Error, "Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_tr_2379", "Argument of type '{0}' is not assignable to parameter of type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties."), The_return_type_of_a_get_accessor_must_be_assignable_to_its_set_accessor_type: t(2380, e.DiagnosticCategory.Error, "The_return_type_of_a_get_accessor_must_be_assignable_to_its_set_accessor_type_2380", "The return type of a 'get' accessor must be assignable to its 'set' accessor type"), Overload_signatures_must_all_be_exported_or_non_exported: t(2383, e.DiagnosticCategory.Error, "Overload_signatures_must_all_be_exported_or_non_exported_2383", "Overload signatures must all be exported or non-exported."), Overload_signatures_must_all_be_ambient_or_non_ambient: t(2384, e.DiagnosticCategory.Error, "Overload_signatures_must_all_be_ambient_or_non_ambient_2384", "Overload signatures must all be ambient or non-ambient."), Overload_signatures_must_all_be_public_private_or_protected: t(2385, e.DiagnosticCategory.Error, "Overload_signatures_must_all_be_public_private_or_protected_2385", "Overload signatures must all be public, private or protected."), Overload_signatures_must_all_be_optional_or_required: t(2386, e.DiagnosticCategory.Error, "Overload_signatures_must_all_be_optional_or_required_2386", "Overload signatures must all be optional or required."), Function_overload_must_be_static: t(2387, e.DiagnosticCategory.Error, "Function_overload_must_be_static_2387", "Function overload must be static."), Function_overload_must_not_be_static: t(2388, e.DiagnosticCategory.Error, "Function_overload_must_not_be_static_2388", "Function overload must not be static."), Function_implementation_name_must_be_0: t(2389, e.DiagnosticCategory.Error, "Function_implementation_name_must_be_0_2389", "Function implementation name must be '{0}'."), Constructor_implementation_is_missing: t(2390, e.DiagnosticCategory.Error, "Constructor_implementation_is_missing_2390", "Constructor implementation is missing."), Function_implementation_is_missing_or_not_immediately_following_the_declaration: t(2391, e.DiagnosticCategory.Error, "Function_implementation_is_missing_or_not_immediately_following_the_declaration_2391", "Function implementation is missing or not immediately following the declaration."), Multiple_constructor_implementations_are_not_allowed: t(2392, e.DiagnosticCategory.Error, "Multiple_constructor_implementations_are_not_allowed_2392", "Multiple constructor implementations are not allowed."), Duplicate_function_implementation: t(2393, e.DiagnosticCategory.Error, "Duplicate_function_implementation_2393", "Duplicate function implementation."), This_overload_signature_is_not_compatible_with_its_implementation_signature: t(2394, e.DiagnosticCategory.Error, "This_overload_signature_is_not_compatible_with_its_implementation_signature_2394", "This overload signature is not compatible with its implementation signature."), Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local: t(2395, e.DiagnosticCategory.Error, "Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local_2395", "Individual declarations in merged declaration '{0}' must be all exported or all local."), Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: t(2396, e.DiagnosticCategory.Error, "Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters_2396", "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters."), Declaration_name_conflicts_with_built_in_global_identifier_0: t(2397, e.DiagnosticCategory.Error, "Declaration_name_conflicts_with_built_in_global_identifier_0_2397", "Declaration name conflicts with built-in global identifier '{0}'."), constructor_cannot_be_used_as_a_parameter_property_name: t(2398, e.DiagnosticCategory.Error, "constructor_cannot_be_used_as_a_parameter_property_name_2398", "'constructor' cannot be used as a parameter property name."), Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: t(2399, e.DiagnosticCategory.Error, "Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference_2399", "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference."), Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: t(2400, e.DiagnosticCategory.Error, "Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference_2400", "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference."), A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers: t(2401, e.DiagnosticCategory.Error, "A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_in_2401", "A 'super' call must be a root-level statement within a constructor of a derived class that contains initialized properties, parameter properties, or private identifiers."), Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: t(2402, e.DiagnosticCategory.Error, "Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference_2402", "Expression resolves to '_super' that compiler uses to capture base class reference."), Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: t(2403, e.DiagnosticCategory.Error, "Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_t_2403", "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'."), The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation: t(2404, e.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation_2404", "The left-hand side of a 'for...in' statement cannot use a type annotation."), The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any: t(2405, e.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any_2405", "The left-hand side of a 'for...in' statement must be of type 'string' or 'any'."), The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access: t(2406, e.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access_2406", "The left-hand side of a 'for...in' statement must be a variable or a property access."), The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0: t(2407, e.DiagnosticCategory.Error, "The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_2407", "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter, but here has type '{0}'."), Setters_cannot_return_a_value: t(2408, e.DiagnosticCategory.Error, "Setters_cannot_return_a_value_2408", "Setters cannot return a value."), Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: t(2409, e.DiagnosticCategory.Error, "Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class_2409", "Return type of constructor signature must be assignable to the instance type of the class."), The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any: t(2410, e.DiagnosticCategory.Error, "The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any_2410", "The 'with' statement is not supported. All symbols in a 'with' block will have type 'any'."), Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target: t(2412, e.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefi_2412", "Type '{0}' is not assignable to type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target."), Property_0_of_type_1_is_not_assignable_to_2_index_type_3: t(2411, e.DiagnosticCategory.Error, "Property_0_of_type_1_is_not_assignable_to_2_index_type_3_2411", "Property '{0}' of type '{1}' is not assignable to '{2}' index type '{3}'."), _0_index_type_1_is_not_assignable_to_2_index_type_3: t(2413, e.DiagnosticCategory.Error, "_0_index_type_1_is_not_assignable_to_2_index_type_3_2413", "'{0}' index type '{1}' is not assignable to '{2}' index type '{3}'."), Class_name_cannot_be_0: t(2414, e.DiagnosticCategory.Error, "Class_name_cannot_be_0_2414", "Class name cannot be '{0}'."), Class_0_incorrectly_extends_base_class_1: t(2415, e.DiagnosticCategory.Error, "Class_0_incorrectly_extends_base_class_1_2415", "Class '{0}' incorrectly extends base class '{1}'."), Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2: t(2416, e.DiagnosticCategory.Error, "Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2_2416", "Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'."), Class_static_side_0_incorrectly_extends_base_class_static_side_1: t(2417, e.DiagnosticCategory.Error, "Class_static_side_0_incorrectly_extends_base_class_static_side_1_2417", "Class static side '{0}' incorrectly extends base class static side '{1}'."), Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1: t(2418, e.DiagnosticCategory.Error, "Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1_2418", "Type of computed property's value is '{0}', which is not assignable to type '{1}'."), Types_of_construct_signatures_are_incompatible: t(2419, e.DiagnosticCategory.Error, "Types_of_construct_signatures_are_incompatible_2419", "Types of construct signatures are incompatible."), Class_0_incorrectly_implements_interface_1: t(2420, e.DiagnosticCategory.Error, "Class_0_incorrectly_implements_interface_1_2420", "Class '{0}' incorrectly implements interface '{1}'."), A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members: t(2422, e.DiagnosticCategory.Error, "A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_memb_2422", "A class can only implement an object type or intersection of object types with statically known members."), Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: t(2423, e.DiagnosticCategory.Error, "Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_access_2423", "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor."), Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: t(2425, e.DiagnosticCategory.Error, "Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_functi_2425", "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function."), Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: t(2426, e.DiagnosticCategory.Error, "Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_functi_2426", "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function."), Interface_name_cannot_be_0: t(2427, e.DiagnosticCategory.Error, "Interface_name_cannot_be_0_2427", "Interface name cannot be '{0}'."), All_declarations_of_0_must_have_identical_type_parameters: t(2428, e.DiagnosticCategory.Error, "All_declarations_of_0_must_have_identical_type_parameters_2428", "All declarations of '{0}' must have identical type parameters."), Interface_0_incorrectly_extends_interface_1: t(2430, e.DiagnosticCategory.Error, "Interface_0_incorrectly_extends_interface_1_2430", "Interface '{0}' incorrectly extends interface '{1}'."), Enum_name_cannot_be_0: t(2431, e.DiagnosticCategory.Error, "Enum_name_cannot_be_0_2431", "Enum name cannot be '{0}'."), In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element: t(2432, e.DiagnosticCategory.Error, "In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enu_2432", "In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element."), A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged: t(2433, e.DiagnosticCategory.Error, "A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merg_2433", "A namespace declaration cannot be in a different file from a class or function with which it is merged."), A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged: t(2434, e.DiagnosticCategory.Error, "A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged_2434", "A namespace declaration cannot be located prior to a class or function with which it is merged."), Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces: t(2435, e.DiagnosticCategory.Error, "Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces_2435", "Ambient modules cannot be nested in other modules or namespaces."), Ambient_module_declaration_cannot_specify_relative_module_name: t(2436, e.DiagnosticCategory.Error, "Ambient_module_declaration_cannot_specify_relative_module_name_2436", "Ambient module declaration cannot specify relative module name."), Module_0_is_hidden_by_a_local_declaration_with_the_same_name: t(2437, e.DiagnosticCategory.Error, "Module_0_is_hidden_by_a_local_declaration_with_the_same_name_2437", "Module '{0}' is hidden by a local declaration with the same name."), Import_name_cannot_be_0: t(2438, e.DiagnosticCategory.Error, "Import_name_cannot_be_0_2438", "Import name cannot be '{0}'."), Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name: t(2439, e.DiagnosticCategory.Error, "Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relati_2439", "Import or export declaration in an ambient module declaration cannot reference module through relative module name."), Import_declaration_conflicts_with_local_declaration_of_0: t(2440, e.DiagnosticCategory.Error, "Import_declaration_conflicts_with_local_declaration_of_0_2440", "Import declaration conflicts with local declaration of '{0}'."), Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module: t(2441, e.DiagnosticCategory.Error, "Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_2441", "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module."), Types_have_separate_declarations_of_a_private_property_0: t(2442, e.DiagnosticCategory.Error, "Types_have_separate_declarations_of_a_private_property_0_2442", "Types have separate declarations of a private property '{0}'."), Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2: t(2443, e.DiagnosticCategory.Error, "Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2_2443", "Property '{0}' is protected but type '{1}' is not a class derived from '{2}'."), Property_0_is_protected_in_type_1_but_public_in_type_2: t(2444, e.DiagnosticCategory.Error, "Property_0_is_protected_in_type_1_but_public_in_type_2_2444", "Property '{0}' is protected in type '{1}' but public in type '{2}'."), Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses: t(2445, e.DiagnosticCategory.Error, "Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses_2445", "Property '{0}' is protected and only accessible within class '{1}' and its subclasses."), Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2: t(2446, e.DiagnosticCategory.Error, "Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_cl_2446", "Property '{0}' is protected and only accessible through an instance of class '{1}'. This is an instance of class '{2}'."), The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead: t(2447, e.DiagnosticCategory.Error, "The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead_2447", "The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead."), Block_scoped_variable_0_used_before_its_declaration: t(2448, e.DiagnosticCategory.Error, "Block_scoped_variable_0_used_before_its_declaration_2448", "Block-scoped variable '{0}' used before its declaration."), Class_0_used_before_its_declaration: t(2449, e.DiagnosticCategory.Error, "Class_0_used_before_its_declaration_2449", "Class '{0}' used before its declaration."), Enum_0_used_before_its_declaration: t(2450, e.DiagnosticCategory.Error, "Enum_0_used_before_its_declaration_2450", "Enum '{0}' used before its declaration."), Cannot_redeclare_block_scoped_variable_0: t(2451, e.DiagnosticCategory.Error, "Cannot_redeclare_block_scoped_variable_0_2451", "Cannot redeclare block-scoped variable '{0}'."), An_enum_member_cannot_have_a_numeric_name: t(2452, e.DiagnosticCategory.Error, "An_enum_member_cannot_have_a_numeric_name_2452", "An enum member cannot have a numeric name."), Variable_0_is_used_before_being_assigned: t(2454, e.DiagnosticCategory.Error, "Variable_0_is_used_before_being_assigned_2454", "Variable '{0}' is used before being assigned."), Type_alias_0_circularly_references_itself: t(2456, e.DiagnosticCategory.Error, "Type_alias_0_circularly_references_itself_2456", "Type alias '{0}' circularly references itself."), Type_alias_name_cannot_be_0: t(2457, e.DiagnosticCategory.Error, "Type_alias_name_cannot_be_0_2457", "Type alias name cannot be '{0}'."), An_AMD_module_cannot_have_multiple_name_assignments: t(2458, e.DiagnosticCategory.Error, "An_AMD_module_cannot_have_multiple_name_assignments_2458", "An AMD module cannot have multiple name assignments."), Module_0_declares_1_locally_but_it_is_not_exported: t(2459, e.DiagnosticCategory.Error, "Module_0_declares_1_locally_but_it_is_not_exported_2459", "Module '{0}' declares '{1}' locally, but it is not exported."), Module_0_declares_1_locally_but_it_is_exported_as_2: t(2460, e.DiagnosticCategory.Error, "Module_0_declares_1_locally_but_it_is_exported_as_2_2460", "Module '{0}' declares '{1}' locally, but it is exported as '{2}'."), Type_0_is_not_an_array_type: t(2461, e.DiagnosticCategory.Error, "Type_0_is_not_an_array_type_2461", "Type '{0}' is not an array type."), A_rest_element_must_be_last_in_a_destructuring_pattern: t(2462, e.DiagnosticCategory.Error, "A_rest_element_must_be_last_in_a_destructuring_pattern_2462", "A rest element must be last in a destructuring pattern."), A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature: t(2463, e.DiagnosticCategory.Error, "A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature_2463", "A binding pattern parameter cannot be optional in an implementation signature."), A_computed_property_name_must_be_of_type_string_number_symbol_or_any: t(2464, e.DiagnosticCategory.Error, "A_computed_property_name_must_be_of_type_string_number_symbol_or_any_2464", "A computed property name must be of type 'string', 'number', 'symbol', or 'any'."), this_cannot_be_referenced_in_a_computed_property_name: t(2465, e.DiagnosticCategory.Error, "this_cannot_be_referenced_in_a_computed_property_name_2465", "'this' cannot be referenced in a computed property name."), super_cannot_be_referenced_in_a_computed_property_name: t(2466, e.DiagnosticCategory.Error, "super_cannot_be_referenced_in_a_computed_property_name_2466", "'super' cannot be referenced in a computed property name."), A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type: t(2467, e.DiagnosticCategory.Error, "A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type_2467", "A computed property name cannot reference a type parameter from its containing type."), Cannot_find_global_value_0: t(2468, e.DiagnosticCategory.Error, "Cannot_find_global_value_0_2468", "Cannot find global value '{0}'."), The_0_operator_cannot_be_applied_to_type_symbol: t(2469, e.DiagnosticCategory.Error, "The_0_operator_cannot_be_applied_to_type_symbol_2469", "The '{0}' operator cannot be applied to type 'symbol'."), Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher: t(2472, e.DiagnosticCategory.Error, "Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher_2472", "Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher."), Enum_declarations_must_all_be_const_or_non_const: t(2473, e.DiagnosticCategory.Error, "Enum_declarations_must_all_be_const_or_non_const_2473", "Enum declarations must all be const or non-const."), const_enum_member_initializers_can_only_contain_literal_values_and_other_computed_enum_values: t(2474, e.DiagnosticCategory.Error, "const_enum_member_initializers_can_only_contain_literal_values_and_other_computed_enum_values_2474", "const enum member initializers can only contain literal values and other computed enum values."), const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query: t(2475, e.DiagnosticCategory.Error, "const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_im_2475", "'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment or type query."), A_const_enum_member_can_only_be_accessed_using_a_string_literal: t(2476, e.DiagnosticCategory.Error, "A_const_enum_member_can_only_be_accessed_using_a_string_literal_2476", "A const enum member can only be accessed using a string literal."), const_enum_member_initializer_was_evaluated_to_a_non_finite_value: t(2477, e.DiagnosticCategory.Error, "const_enum_member_initializer_was_evaluated_to_a_non_finite_value_2477", "'const' enum member initializer was evaluated to a non-finite value."), const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN: t(2478, e.DiagnosticCategory.Error, "const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN_2478", "'const' enum member initializer was evaluated to disallowed value 'NaN'."), let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations: t(2480, e.DiagnosticCategory.Error, "let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations_2480", "'let' is not allowed to be used as a name in 'let' or 'const' declarations."), Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1: t(2481, e.DiagnosticCategory.Error, "Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1_2481", "Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'."), The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation: t(2483, e.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation_2483", "The left-hand side of a 'for...of' statement cannot use a type annotation."), Export_declaration_conflicts_with_exported_declaration_of_0: t(2484, e.DiagnosticCategory.Error, "Export_declaration_conflicts_with_exported_declaration_of_0_2484", "Export declaration conflicts with exported declaration of '{0}'."), The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access: t(2487, e.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access_2487", "The left-hand side of a 'for...of' statement must be a variable or a property access."), Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator: t(2488, e.DiagnosticCategory.Error, "Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator_2488", "Type '{0}' must have a '[Symbol.iterator]()' method that returns an iterator."), An_iterator_must_have_a_next_method: t(2489, e.DiagnosticCategory.Error, "An_iterator_must_have_a_next_method_2489", "An iterator must have a 'next()' method."), The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property: t(2490, e.DiagnosticCategory.Error, "The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property_2490", "The type returned by the '{0}()' method of an iterator must have a 'value' property."), The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern: t(2491, e.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern_2491", "The left-hand side of a 'for...in' statement cannot be a destructuring pattern."), Cannot_redeclare_identifier_0_in_catch_clause: t(2492, e.DiagnosticCategory.Error, "Cannot_redeclare_identifier_0_in_catch_clause_2492", "Cannot redeclare identifier '{0}' in catch clause."), Tuple_type_0_of_length_1_has_no_element_at_index_2: t(2493, e.DiagnosticCategory.Error, "Tuple_type_0_of_length_1_has_no_element_at_index_2_2493", "Tuple type '{0}' of length '{1}' has no element at index '{2}'."), Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher: t(2494, e.DiagnosticCategory.Error, "Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher_2494", "Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher."), Type_0_is_not_an_array_type_or_a_string_type: t(2495, e.DiagnosticCategory.Error, "Type_0_is_not_an_array_type_or_a_string_type_2495", "Type '{0}' is not an array type or a string type."), The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression: t(2496, e.DiagnosticCategory.Error, "The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_stand_2496", "The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression."), This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export: t(2497, e.DiagnosticCategory.Error, "This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_2497", "This module can only be referenced with ECMAScript imports/exports by turning on the '{0}' flag and referencing its default export."), Module_0_uses_export_and_cannot_be_used_with_export_Asterisk: t(2498, e.DiagnosticCategory.Error, "Module_0_uses_export_and_cannot_be_used_with_export_Asterisk_2498", "Module '{0}' uses 'export =' and cannot be used with 'export *'."), An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments: t(2499, e.DiagnosticCategory.Error, "An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments_2499", "An interface can only extend an identifier/qualified-name with optional type arguments."), A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments: t(2500, e.DiagnosticCategory.Error, "A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments_2500", "A class can only implement an identifier/qualified-name with optional type arguments."), A_rest_element_cannot_contain_a_binding_pattern: t(2501, e.DiagnosticCategory.Error, "A_rest_element_cannot_contain_a_binding_pattern_2501", "A rest element cannot contain a binding pattern."), _0_is_referenced_directly_or_indirectly_in_its_own_type_annotation: t(2502, e.DiagnosticCategory.Error, "_0_is_referenced_directly_or_indirectly_in_its_own_type_annotation_2502", "'{0}' is referenced directly or indirectly in its own type annotation."), Cannot_find_namespace_0: t(2503, e.DiagnosticCategory.Error, "Cannot_find_namespace_0_2503", "Cannot find namespace '{0}'."), Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator: t(2504, e.DiagnosticCategory.Error, "Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator_2504", "Type '{0}' must have a '[Symbol.asyncIterator]()' method that returns an async iterator."), A_generator_cannot_have_a_void_type_annotation: t(2505, e.DiagnosticCategory.Error, "A_generator_cannot_have_a_void_type_annotation_2505", "A generator cannot have a 'void' type annotation."), _0_is_referenced_directly_or_indirectly_in_its_own_base_expression: t(2506, e.DiagnosticCategory.Error, "_0_is_referenced_directly_or_indirectly_in_its_own_base_expression_2506", "'{0}' is referenced directly or indirectly in its own base expression."), Type_0_is_not_a_constructor_function_type: t(2507, e.DiagnosticCategory.Error, "Type_0_is_not_a_constructor_function_type_2507", "Type '{0}' is not a constructor function type."), No_base_constructor_has_the_specified_number_of_type_arguments: t(2508, e.DiagnosticCategory.Error, "No_base_constructor_has_the_specified_number_of_type_arguments_2508", "No base constructor has the specified number of type arguments."), Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members: t(2509, e.DiagnosticCategory.Error, "Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_2509", "Base constructor return type '{0}' is not an object type or intersection of object types with statically known members."), Base_constructors_must_all_have_the_same_return_type: t(2510, e.DiagnosticCategory.Error, "Base_constructors_must_all_have_the_same_return_type_2510", "Base constructors must all have the same return type."), Cannot_create_an_instance_of_an_abstract_class: t(2511, e.DiagnosticCategory.Error, "Cannot_create_an_instance_of_an_abstract_class_2511", "Cannot create an instance of an abstract class."), Overload_signatures_must_all_be_abstract_or_non_abstract: t(2512, e.DiagnosticCategory.Error, "Overload_signatures_must_all_be_abstract_or_non_abstract_2512", "Overload signatures must all be abstract or non-abstract."), Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression: t(2513, e.DiagnosticCategory.Error, "Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression_2513", "Abstract method '{0}' in class '{1}' cannot be accessed via super expression."), A_tuple_type_cannot_be_indexed_with_a_negative_value: t(2514, e.DiagnosticCategory.Error, "A_tuple_type_cannot_be_indexed_with_a_negative_value_2514", "A tuple type cannot be indexed with a negative value."), Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2: t(2515, e.DiagnosticCategory.Error, "Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2_2515", "Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'."), All_declarations_of_an_abstract_method_must_be_consecutive: t(2516, e.DiagnosticCategory.Error, "All_declarations_of_an_abstract_method_must_be_consecutive_2516", "All declarations of an abstract method must be consecutive."), Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type: t(2517, e.DiagnosticCategory.Error, "Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type_2517", "Cannot assign an abstract constructor type to a non-abstract constructor type."), A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard: t(2518, e.DiagnosticCategory.Error, "A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard_2518", "A 'this'-based type guard is not compatible with a parameter-based type guard."), An_async_iterator_must_have_a_next_method: t(2519, e.DiagnosticCategory.Error, "An_async_iterator_must_have_a_next_method_2519", "An async iterator must have a 'next()' method."), Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions: t(2520, e.DiagnosticCategory.Error, "Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions_2520", "Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions."), The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method: t(2522, e.DiagnosticCategory.Error, "The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_usi_2522", "The 'arguments' object cannot be referenced in an async function or method in ES3 and ES5. Consider using a standard function or method."), yield_expressions_cannot_be_used_in_a_parameter_initializer: t(2523, e.DiagnosticCategory.Error, "yield_expressions_cannot_be_used_in_a_parameter_initializer_2523", "'yield' expressions cannot be used in a parameter initializer."), await_expressions_cannot_be_used_in_a_parameter_initializer: t(2524, e.DiagnosticCategory.Error, "await_expressions_cannot_be_used_in_a_parameter_initializer_2524", "'await' expressions cannot be used in a parameter initializer."), Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value: t(2525, e.DiagnosticCategory.Error, "Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value_2525", "Initializer provides no value for this binding element and the binding element has no default value."), A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface: t(2526, e.DiagnosticCategory.Error, "A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface_2526", "A 'this' type is available only in a non-static member of a class or interface."), The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary: t(2527, e.DiagnosticCategory.Error, "The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary_2527", "The inferred type of '{0}' references an inaccessible '{1}' type. A type annotation is necessary."), A_module_cannot_have_multiple_default_exports: t(2528, e.DiagnosticCategory.Error, "A_module_cannot_have_multiple_default_exports_2528", "A module cannot have multiple default exports."), Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions: t(2529, e.DiagnosticCategory.Error, "Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_func_2529", "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions."), Property_0_is_incompatible_with_index_signature: t(2530, e.DiagnosticCategory.Error, "Property_0_is_incompatible_with_index_signature_2530", "Property '{0}' is incompatible with index signature."), Object_is_possibly_null: t(2531, e.DiagnosticCategory.Error, "Object_is_possibly_null_2531", "Object is possibly 'null'."), Object_is_possibly_undefined: t(2532, e.DiagnosticCategory.Error, "Object_is_possibly_undefined_2532", "Object is possibly 'undefined'."), Object_is_possibly_null_or_undefined: t(2533, e.DiagnosticCategory.Error, "Object_is_possibly_null_or_undefined_2533", "Object is possibly 'null' or 'undefined'."), A_function_returning_never_cannot_have_a_reachable_end_point: t(2534, e.DiagnosticCategory.Error, "A_function_returning_never_cannot_have_a_reachable_end_point_2534", "A function returning 'never' cannot have a reachable end point."), Enum_type_0_has_members_with_initializers_that_are_not_literals: t(2535, e.DiagnosticCategory.Error, "Enum_type_0_has_members_with_initializers_that_are_not_literals_2535", "Enum type '{0}' has members with initializers that are not literals."), Type_0_cannot_be_used_to_index_type_1: t(2536, e.DiagnosticCategory.Error, "Type_0_cannot_be_used_to_index_type_1_2536", "Type '{0}' cannot be used to index type '{1}'."), Type_0_has_no_matching_index_signature_for_type_1: t(2537, e.DiagnosticCategory.Error, "Type_0_has_no_matching_index_signature_for_type_1_2537", "Type '{0}' has no matching index signature for type '{1}'."), Type_0_cannot_be_used_as_an_index_type: t(2538, e.DiagnosticCategory.Error, "Type_0_cannot_be_used_as_an_index_type_2538", "Type '{0}' cannot be used as an index type."), Cannot_assign_to_0_because_it_is_not_a_variable: t(2539, e.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_not_a_variable_2539", "Cannot assign to '{0}' because it is not a variable."), Cannot_assign_to_0_because_it_is_a_read_only_property: t(2540, e.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_read_only_property_2540", "Cannot assign to '{0}' because it is a read-only property."), Index_signature_in_type_0_only_permits_reading: t(2542, e.DiagnosticCategory.Error, "Index_signature_in_type_0_only_permits_reading_2542", "Index signature in type '{0}' only permits reading."), Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference: t(2543, e.DiagnosticCategory.Error, "Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_me_2543", "Duplicate identifier '_newTarget'. Compiler uses variable declaration '_newTarget' to capture 'new.target' meta-property reference."), Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference: t(2544, e.DiagnosticCategory.Error, "Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta__2544", "Expression resolves to variable declaration '_newTarget' that compiler uses to capture 'new.target' meta-property reference."), A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any: t(2545, e.DiagnosticCategory.Error, "A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any_2545", "A mixin class must have a constructor with a single rest parameter of type 'any[]'."), The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property: t(2547, e.DiagnosticCategory.Error, "The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_pro_2547", "The type returned by the '{0}()' method of an async iterator must be a promise for a type with a 'value' property."), Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: t(2548, e.DiagnosticCategory.Error, "Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator_2548", "Type '{0}' is not an array type or does not have a '[Symbol.iterator]()' method that returns an iterator."), Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: t(2549, e.DiagnosticCategory.Error, "Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns__2549", "Type '{0}' is not an array type or a string type or does not have a '[Symbol.iterator]()' method that returns an iterator."), Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later: t(2550, e.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_c_2550", "Property '{0}' does not exist on type '{1}'. Do you need to change your target library? Try changing the 'lib' compiler option to '{2}' or later."), Property_0_does_not_exist_on_type_1_Did_you_mean_2: t(2551, e.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_Did_you_mean_2_2551", "Property '{0}' does not exist on type '{1}'. Did you mean '{2}'?"), Cannot_find_name_0_Did_you_mean_1: t(2552, e.DiagnosticCategory.Error, "Cannot_find_name_0_Did_you_mean_1_2552", "Cannot find name '{0}'. Did you mean '{1}'?"), Computed_values_are_not_permitted_in_an_enum_with_string_valued_members: t(2553, e.DiagnosticCategory.Error, "Computed_values_are_not_permitted_in_an_enum_with_string_valued_members_2553", "Computed values are not permitted in an enum with string valued members."), Expected_0_arguments_but_got_1: t(2554, e.DiagnosticCategory.Error, "Expected_0_arguments_but_got_1_2554", "Expected {0} arguments, but got {1}."), Expected_at_least_0_arguments_but_got_1: t(2555, e.DiagnosticCategory.Error, "Expected_at_least_0_arguments_but_got_1_2555", "Expected at least {0} arguments, but got {1}."), A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter: t(2556, e.DiagnosticCategory.Error, "A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter_2556", "A spread argument must either have a tuple type or be passed to a rest parameter."), Expected_0_type_arguments_but_got_1: t(2558, e.DiagnosticCategory.Error, "Expected_0_type_arguments_but_got_1_2558", "Expected {0} type arguments, but got {1}."), Type_0_has_no_properties_in_common_with_type_1: t(2559, e.DiagnosticCategory.Error, "Type_0_has_no_properties_in_common_with_type_1_2559", "Type '{0}' has no properties in common with type '{1}'."), Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it: t(2560, e.DiagnosticCategory.Error, "Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it_2560", "Value of type '{0}' has no properties in common with type '{1}'. Did you mean to call it?"), Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2: t(2561, e.DiagnosticCategory.Error, "Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_writ_2561", "Object literal may only specify known properties, but '{0}' does not exist in type '{1}'. Did you mean to write '{2}'?"), Base_class_expressions_cannot_reference_class_type_parameters: t(2562, e.DiagnosticCategory.Error, "Base_class_expressions_cannot_reference_class_type_parameters_2562", "Base class expressions cannot reference class type parameters."), The_containing_function_or_module_body_is_too_large_for_control_flow_analysis: t(2563, e.DiagnosticCategory.Error, "The_containing_function_or_module_body_is_too_large_for_control_flow_analysis_2563", "The containing function or module body is too large for control flow analysis."), Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor: t(2564, e.DiagnosticCategory.Error, "Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor_2564", "Property '{0}' has no initializer and is not definitely assigned in the constructor."), Property_0_is_used_before_being_assigned: t(2565, e.DiagnosticCategory.Error, "Property_0_is_used_before_being_assigned_2565", "Property '{0}' is used before being assigned."), A_rest_element_cannot_have_a_property_name: t(2566, e.DiagnosticCategory.Error, "A_rest_element_cannot_have_a_property_name_2566", "A rest element cannot have a property name."), Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations: t(2567, e.DiagnosticCategory.Error, "Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations_2567", "Enum declarations can only merge with namespace or other enum declarations."), Property_0_may_not_exist_on_type_1_Did_you_mean_2: t(2568, e.DiagnosticCategory.Error, "Property_0_may_not_exist_on_type_1_Did_you_mean_2_2568", "Property '{0}' may not exist on type '{1}'. Did you mean '{2}'?"), Could_not_find_name_0_Did_you_mean_1: t(2570, e.DiagnosticCategory.Error, "Could_not_find_name_0_Did_you_mean_1_2570", "Could not find name '{0}'. Did you mean '{1}'?"), Object_is_of_type_unknown: t(2571, e.DiagnosticCategory.Error, "Object_is_of_type_unknown_2571", "Object is of type 'unknown'."), A_rest_element_type_must_be_an_array_type: t(2574, e.DiagnosticCategory.Error, "A_rest_element_type_must_be_an_array_type_2574", "A rest element type must be an array type."), No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments: t(2575, e.DiagnosticCategory.Error, "No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments_2575", "No overload expects {0} arguments, but overloads do exist that expect either {1} or {2} arguments."), Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead: t(2576, e.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead_2576", "Property '{0}' does not exist on type '{1}'. Did you mean to access the static member '{2}' instead?"), Return_type_annotation_circularly_references_itself: t(2577, e.DiagnosticCategory.Error, "Return_type_annotation_circularly_references_itself_2577", "Return type annotation circularly references itself."), Unused_ts_expect_error_directive: t(2578, e.DiagnosticCategory.Error, "Unused_ts_expect_error_directive_2578", "Unused '@ts-expect-error' directive."), Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode: t(2580, e.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashno_2580", "Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node`."), Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery: t(2581, e.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slash_2581", "Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery`."), Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha: t(2582, e.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2582", "Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha`."), Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later: t(2583, e.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2583", "Cannot find name '{0}'. Do you need to change your target library? Try changing the 'lib' compiler option to '{1}' or later."), Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom: t(2584, e.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2584", "Cannot find name '{0}'. Do you need to change your target library? Try changing the 'lib' compiler option to include 'dom'."), _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later: t(2585, e.DiagnosticCategory.Error, "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_2585", "'{0}' only refers to a type, but is being used as a value here. Do you need to change your target library? Try changing the 'lib' compiler option to es2015 or later."), Cannot_assign_to_0_because_it_is_a_constant: t(2588, e.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_constant_2588", "Cannot assign to '{0}' because it is a constant."), Type_instantiation_is_excessively_deep_and_possibly_infinite: t(2589, e.DiagnosticCategory.Error, "Type_instantiation_is_excessively_deep_and_possibly_infinite_2589", "Type instantiation is excessively deep and possibly infinite."), Expression_produces_a_union_type_that_is_too_complex_to_represent: t(2590, e.DiagnosticCategory.Error, "Expression_produces_a_union_type_that_is_too_complex_to_represent_2590", "Expression produces a union type that is too complex to represent."), Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig: t(2591, e.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashno_2591", "Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node` and then add 'node' to the types field in your tsconfig."), Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig: t(2592, e.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slash_2592", "Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery` and then add 'jquery' to the types field in your tsconfig."), Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig: t(2593, e.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2593", "Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig."), This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag: t(2594, e.DiagnosticCategory.Error, "This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag_2594", "This module is declared with 'export =', and can only be used with a default import when using the '{0}' flag."), _0_can_only_be_imported_by_using_a_default_import: t(2595, e.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_a_default_import_2595", "'{0}' can only be imported by using a default import."), _0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: t(2596, e.DiagnosticCategory.Error, "_0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import_2596", "'{0}' can only be imported by turning on the 'esModuleInterop' flag and using a default import."), _0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import: t(2597, e.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import_2597", "'{0}' can only be imported by using a 'require' call or by using a default import."), _0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: t(2598, e.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using__2598", "'{0}' can only be imported by using a 'require' call or by turning on the 'esModuleInterop' flag and using a default import."), JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist: t(2602, e.DiagnosticCategory.Error, "JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist_2602", "JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist."), Property_0_in_type_1_is_not_assignable_to_type_2: t(2603, e.DiagnosticCategory.Error, "Property_0_in_type_1_is_not_assignable_to_type_2_2603", "Property '{0}' in type '{1}' is not assignable to type '{2}'."), JSX_element_type_0_does_not_have_any_construct_or_call_signatures: t(2604, e.DiagnosticCategory.Error, "JSX_element_type_0_does_not_have_any_construct_or_call_signatures_2604", "JSX element type '{0}' does not have any construct or call signatures."), Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property: t(2606, e.DiagnosticCategory.Error, "Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property_2606", "Property '{0}' of JSX spread attribute is not assignable to target property."), JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property: t(2607, e.DiagnosticCategory.Error, "JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property_2607", "JSX element class does not support attributes because it does not have a '{0}' property."), The_global_type_JSX_0_may_not_have_more_than_one_property: t(2608, e.DiagnosticCategory.Error, "The_global_type_JSX_0_may_not_have_more_than_one_property_2608", "The global type 'JSX.{0}' may not have more than one property."), JSX_spread_child_must_be_an_array_type: t(2609, e.DiagnosticCategory.Error, "JSX_spread_child_must_be_an_array_type_2609", "JSX spread child must be an array type."), _0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property: t(2610, e.DiagnosticCategory.Error, "_0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property_2610", "'{0}' is defined as an accessor in class '{1}', but is overridden here in '{2}' as an instance property."), _0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor: t(2611, e.DiagnosticCategory.Error, "_0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor_2611", "'{0}' is defined as a property in class '{1}', but is overridden here in '{2}' as an accessor."), Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration: t(2612, e.DiagnosticCategory.Error, "Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_2612", "Property '{0}' will overwrite the base property in '{1}'. If this is intentional, add an initializer. Otherwise, add a 'declare' modifier or remove the redundant declaration."), Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead: t(2613, e.DiagnosticCategory.Error, "Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead_2613", "Module '{0}' has no default export. Did you mean to use 'import { {1} } from {0}' instead?"), Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead: t(2614, e.DiagnosticCategory.Error, "Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead_2614", "Module '{0}' has no exported member '{1}'. Did you mean to use 'import {1} from {0}' instead?"), Type_of_property_0_circularly_references_itself_in_mapped_type_1: t(2615, e.DiagnosticCategory.Error, "Type_of_property_0_circularly_references_itself_in_mapped_type_1_2615", "Type of property '{0}' circularly references itself in mapped type '{1}'."), _0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import: t(2616, e.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import_2616", "'{0}' can only be imported by using 'import {1} = require({2})' or a default import."), _0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: t(2617, e.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_us_2617", "'{0}' can only be imported by using 'import {1} = require({2})' or by turning on the 'esModuleInterop' flag and using a default import."), Source_has_0_element_s_but_target_requires_1: t(2618, e.DiagnosticCategory.Error, "Source_has_0_element_s_but_target_requires_1_2618", "Source has {0} element(s) but target requires {1}."), Source_has_0_element_s_but_target_allows_only_1: t(2619, e.DiagnosticCategory.Error, "Source_has_0_element_s_but_target_allows_only_1_2619", "Source has {0} element(s) but target allows only {1}."), Target_requires_0_element_s_but_source_may_have_fewer: t(2620, e.DiagnosticCategory.Error, "Target_requires_0_element_s_but_source_may_have_fewer_2620", "Target requires {0} element(s) but source may have fewer."), Target_allows_only_0_element_s_but_source_may_have_more: t(2621, e.DiagnosticCategory.Error, "Target_allows_only_0_element_s_but_source_may_have_more_2621", "Target allows only {0} element(s) but source may have more."), Source_provides_no_match_for_required_element_at_position_0_in_target: t(2623, e.DiagnosticCategory.Error, "Source_provides_no_match_for_required_element_at_position_0_in_target_2623", "Source provides no match for required element at position {0} in target."), Source_provides_no_match_for_variadic_element_at_position_0_in_target: t(2624, e.DiagnosticCategory.Error, "Source_provides_no_match_for_variadic_element_at_position_0_in_target_2624", "Source provides no match for variadic element at position {0} in target."), Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target: t(2625, e.DiagnosticCategory.Error, "Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target_2625", "Variadic element at position {0} in source does not match element at position {1} in target."), Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target: t(2626, e.DiagnosticCategory.Error, "Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target_2626", "Type at position {0} in source is not compatible with type at position {1} in target."), Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target: t(2627, e.DiagnosticCategory.Error, "Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target_2627", "Type at positions {0} through {1} in source is not compatible with type at position {2} in target."), Cannot_assign_to_0_because_it_is_an_enum: t(2628, e.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_an_enum_2628", "Cannot assign to '{0}' because it is an enum."), Cannot_assign_to_0_because_it_is_a_class: t(2629, e.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_class_2629", "Cannot assign to '{0}' because it is a class."), Cannot_assign_to_0_because_it_is_a_function: t(2630, e.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_function_2630", "Cannot assign to '{0}' because it is a function."), Cannot_assign_to_0_because_it_is_a_namespace: t(2631, e.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_namespace_2631", "Cannot assign to '{0}' because it is a namespace."), Cannot_assign_to_0_because_it_is_an_import: t(2632, e.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_an_import_2632", "Cannot assign to '{0}' because it is an import."), JSX_property_access_expressions_cannot_include_JSX_namespace_names: t(2633, e.DiagnosticCategory.Error, "JSX_property_access_expressions_cannot_include_JSX_namespace_names_2633", "JSX property access expressions cannot include JSX namespace names"), _0_index_signatures_are_incompatible: t(2634, e.DiagnosticCategory.Error, "_0_index_signatures_are_incompatible_2634", "'{0}' index signatures are incompatible."), Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable: t(2635, e.DiagnosticCategory.Error, "Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable_2635", "Type '{0}' has no signatures for which the type argument list is applicable."), Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation: t(2636, e.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation_2636", "Type '{0}' is not assignable to type '{1}' as implied by variance annotation."), Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types: t(2637, e.DiagnosticCategory.Error, "Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_t_2637", "Variance annotations are only supported in type aliases for object, function, constructor, and mapped types."), Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator: t(2638, e.DiagnosticCategory.Error, "Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operato_2638", "Type '{0}' may represent a primitive value, which is not permitted as the right operand of the 'in' operator."), Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity: t(2649, e.DiagnosticCategory.Error, "Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity_2649", "Cannot augment module '{0}' with value exports because it resolves to a non-module entity."), A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums: t(2651, e.DiagnosticCategory.Error, "A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_memb_2651", "A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums."), Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead: t(2652, e.DiagnosticCategory.Error, "Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_d_2652", "Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead."), Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1: t(2653, e.DiagnosticCategory.Error, "Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1_2653", "Non-abstract class expression does not implement inherited abstract member '{0}' from class '{1}'."), JSX_expressions_must_have_one_parent_element: t(2657, e.DiagnosticCategory.Error, "JSX_expressions_must_have_one_parent_element_2657", "JSX expressions must have one parent element."), Type_0_provides_no_match_for_the_signature_1: t(2658, e.DiagnosticCategory.Error, "Type_0_provides_no_match_for_the_signature_1_2658", "Type '{0}' provides no match for the signature '{1}'."), super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher: t(2659, e.DiagnosticCategory.Error, "super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_highe_2659", "'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher."), super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions: t(2660, e.DiagnosticCategory.Error, "super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions_2660", "'super' can only be referenced in members of derived classes or object literal expressions."), Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module: t(2661, e.DiagnosticCategory.Error, "Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module_2661", "Cannot export '{0}'. Only local declarations can be exported from a module."), Cannot_find_name_0_Did_you_mean_the_static_member_1_0: t(2662, e.DiagnosticCategory.Error, "Cannot_find_name_0_Did_you_mean_the_static_member_1_0_2662", "Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?"), Cannot_find_name_0_Did_you_mean_the_instance_member_this_0: t(2663, e.DiagnosticCategory.Error, "Cannot_find_name_0_Did_you_mean_the_instance_member_this_0_2663", "Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?"), Invalid_module_name_in_augmentation_module_0_cannot_be_found: t(2664, e.DiagnosticCategory.Error, "Invalid_module_name_in_augmentation_module_0_cannot_be_found_2664", "Invalid module name in augmentation, module '{0}' cannot be found."), Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented: t(2665, e.DiagnosticCategory.Error, "Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augm_2665", "Invalid module name in augmentation. Module '{0}' resolves to an untyped module at '{1}', which cannot be augmented."), Exports_and_export_assignments_are_not_permitted_in_module_augmentations: t(2666, e.DiagnosticCategory.Error, "Exports_and_export_assignments_are_not_permitted_in_module_augmentations_2666", "Exports and export assignments are not permitted in module augmentations."), Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module: t(2667, e.DiagnosticCategory.Error, "Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_mod_2667", "Imports are not permitted in module augmentations. Consider moving them to the enclosing external module."), export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible: t(2668, e.DiagnosticCategory.Error, "export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always__2668", "'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible."), Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations: t(2669, e.DiagnosticCategory.Error, "Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_2669", "Augmentations for the global scope can only be directly nested in external modules or ambient module declarations."), Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context: t(2670, e.DiagnosticCategory.Error, "Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambien_2670", "Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context."), Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity: t(2671, e.DiagnosticCategory.Error, "Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity_2671", "Cannot augment module '{0}' because it resolves to a non-module entity."), Cannot_assign_a_0_constructor_type_to_a_1_constructor_type: t(2672, e.DiagnosticCategory.Error, "Cannot_assign_a_0_constructor_type_to_a_1_constructor_type_2672", "Cannot assign a '{0}' constructor type to a '{1}' constructor type."), Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration: t(2673, e.DiagnosticCategory.Error, "Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration_2673", "Constructor of class '{0}' is private and only accessible within the class declaration."), Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration: t(2674, e.DiagnosticCategory.Error, "Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration_2674", "Constructor of class '{0}' is protected and only accessible within the class declaration."), Cannot_extend_a_class_0_Class_constructor_is_marked_as_private: t(2675, e.DiagnosticCategory.Error, "Cannot_extend_a_class_0_Class_constructor_is_marked_as_private_2675", "Cannot extend a class '{0}'. Class constructor is marked as private."), Accessors_must_both_be_abstract_or_non_abstract: t(2676, e.DiagnosticCategory.Error, "Accessors_must_both_be_abstract_or_non_abstract_2676", "Accessors must both be abstract or non-abstract."), A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type: t(2677, e.DiagnosticCategory.Error, "A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type_2677", "A type predicate's type must be assignable to its parameter's type."), Type_0_is_not_comparable_to_type_1: t(2678, e.DiagnosticCategory.Error, "Type_0_is_not_comparable_to_type_1_2678", "Type '{0}' is not comparable to type '{1}'."), A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void: t(2679, e.DiagnosticCategory.Error, "A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void_2679", "A function that is called with the 'new' keyword cannot have a 'this' type that is 'void'."), A_0_parameter_must_be_the_first_parameter: t(2680, e.DiagnosticCategory.Error, "A_0_parameter_must_be_the_first_parameter_2680", "A '{0}' parameter must be the first parameter."), A_constructor_cannot_have_a_this_parameter: t(2681, e.DiagnosticCategory.Error, "A_constructor_cannot_have_a_this_parameter_2681", "A constructor cannot have a 'this' parameter."), this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation: t(2683, e.DiagnosticCategory.Error, "this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_2683", "'this' implicitly has type 'any' because it does not have a type annotation."), The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1: t(2684, e.DiagnosticCategory.Error, "The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1_2684", "The 'this' context of type '{0}' is not assignable to method's 'this' of type '{1}'."), The_this_types_of_each_signature_are_incompatible: t(2685, e.DiagnosticCategory.Error, "The_this_types_of_each_signature_are_incompatible_2685", "The 'this' types of each signature are incompatible."), _0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead: t(2686, e.DiagnosticCategory.Error, "_0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead_2686", "'{0}' refers to a UMD global, but the current file is a module. Consider adding an import instead."), All_declarations_of_0_must_have_identical_modifiers: t(2687, e.DiagnosticCategory.Error, "All_declarations_of_0_must_have_identical_modifiers_2687", "All declarations of '{0}' must have identical modifiers."), Cannot_find_type_definition_file_for_0: t(2688, e.DiagnosticCategory.Error, "Cannot_find_type_definition_file_for_0_2688", "Cannot find type definition file for '{0}'."), Cannot_extend_an_interface_0_Did_you_mean_implements: t(2689, e.DiagnosticCategory.Error, "Cannot_extend_an_interface_0_Did_you_mean_implements_2689", "Cannot extend an interface '{0}'. Did you mean 'implements'?"), _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0: t(2690, e.DiagnosticCategory.Error, "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0_2690", "'{0}' only refers to a type, but is being used as a value here. Did you mean to use '{1} in {0}'?"), An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead: t(2691, e.DiagnosticCategory.Error, "An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead_2691", "An import path cannot end with a '{0}' extension. Consider importing '{1}' instead."), _0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible: t(2692, e.DiagnosticCategory.Error, "_0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible_2692", "'{0}' is a primitive, but '{1}' is a wrapper object. Prefer using '{0}' when possible."), _0_only_refers_to_a_type_but_is_being_used_as_a_value_here: t(2693, e.DiagnosticCategory.Error, "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_2693", "'{0}' only refers to a type, but is being used as a value here."), Namespace_0_has_no_exported_member_1: t(2694, e.DiagnosticCategory.Error, "Namespace_0_has_no_exported_member_1_2694", "Namespace '{0}' has no exported member '{1}'."), Left_side_of_comma_operator_is_unused_and_has_no_side_effects: t(2695, e.DiagnosticCategory.Error, "Left_side_of_comma_operator_is_unused_and_has_no_side_effects_2695", "Left side of comma operator is unused and has no side effects.", true), The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead: t(2696, e.DiagnosticCategory.Error, "The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead_2696", "The 'Object' type is assignable to very few other types. Did you mean to use the 'any' type instead?"), An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: t(2697, e.DiagnosticCategory.Error, "An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_in_2697", "An async function or method must return a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your '--lib' option."), Spread_types_may_only_be_created_from_object_types: t(2698, e.DiagnosticCategory.Error, "Spread_types_may_only_be_created_from_object_types_2698", "Spread types may only be created from object types."), Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1: t(2699, e.DiagnosticCategory.Error, "Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1_2699", "Static property '{0}' conflicts with built-in property 'Function.{0}' of constructor function '{1}'."), Rest_types_may_only_be_created_from_object_types: t(2700, e.DiagnosticCategory.Error, "Rest_types_may_only_be_created_from_object_types_2700", "Rest types may only be created from object types."), The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access: t(2701, e.DiagnosticCategory.Error, "The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access_2701", "The target of an object rest assignment must be a variable or a property access."), _0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here: t(2702, e.DiagnosticCategory.Error, "_0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here_2702", "'{0}' only refers to a type, but is being used as a namespace here."), The_operand_of_a_delete_operator_must_be_a_property_reference: t(2703, e.DiagnosticCategory.Error, "The_operand_of_a_delete_operator_must_be_a_property_reference_2703", "The operand of a 'delete' operator must be a property reference."), The_operand_of_a_delete_operator_cannot_be_a_read_only_property: t(2704, e.DiagnosticCategory.Error, "The_operand_of_a_delete_operator_cannot_be_a_read_only_property_2704", "The operand of a 'delete' operator cannot be a read-only property."), An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: t(2705, e.DiagnosticCategory.Error, "An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_de_2705", "An async function or method in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your '--lib' option."), Required_type_parameters_may_not_follow_optional_type_parameters: t(2706, e.DiagnosticCategory.Error, "Required_type_parameters_may_not_follow_optional_type_parameters_2706", "Required type parameters may not follow optional type parameters."), Generic_type_0_requires_between_1_and_2_type_arguments: t(2707, e.DiagnosticCategory.Error, "Generic_type_0_requires_between_1_and_2_type_arguments_2707", "Generic type '{0}' requires between {1} and {2} type arguments."), Cannot_use_namespace_0_as_a_value: t(2708, e.DiagnosticCategory.Error, "Cannot_use_namespace_0_as_a_value_2708", "Cannot use namespace '{0}' as a value."), Cannot_use_namespace_0_as_a_type: t(2709, e.DiagnosticCategory.Error, "Cannot_use_namespace_0_as_a_type_2709", "Cannot use namespace '{0}' as a type."), _0_are_specified_twice_The_attribute_named_0_will_be_overwritten: t(2710, e.DiagnosticCategory.Error, "_0_are_specified_twice_The_attribute_named_0_will_be_overwritten_2710", "'{0}' are specified twice. The attribute named '{0}' will be overwritten."), A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: t(2711, e.DiagnosticCategory.Error, "A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES20_2711", "A dynamic import call returns a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your '--lib' option."), A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: t(2712, e.DiagnosticCategory.Error, "A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declarat_2712", "A dynamic import call in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your '--lib' option."), Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1: t(2713, e.DiagnosticCategory.Error, "Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_p_2713", `Cannot access '{0}.{1}' because '{0}' is a type, but not a namespace. Did you mean to retrieve the type of the property '{1}' in '{0}' with '{0}["{1}"]'?`), The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context: t(2714, e.DiagnosticCategory.Error, "The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context_2714", "The expression of an export assignment must be an identifier or qualified name in an ambient context."), Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor: t(2715, e.DiagnosticCategory.Error, "Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor_2715", "Abstract property '{0}' in class '{1}' cannot be accessed in the constructor."), Type_parameter_0_has_a_circular_default: t(2716, e.DiagnosticCategory.Error, "Type_parameter_0_has_a_circular_default_2716", "Type parameter '{0}' has a circular default."), Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2: t(2717, e.DiagnosticCategory.Error, "Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_t_2717", "Subsequent property declarations must have the same type.  Property '{0}' must be of type '{1}', but here has type '{2}'."), Duplicate_property_0: t(2718, e.DiagnosticCategory.Error, "Duplicate_property_0_2718", "Duplicate property '{0}'."), Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated: t(2719, e.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated_2719", "Type '{0}' is not assignable to type '{1}'. Two different types with this name exist, but they are unrelated."), Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass: t(2720, e.DiagnosticCategory.Error, "Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclas_2720", "Class '{0}' incorrectly implements class '{1}'. Did you mean to extend '{1}' and inherit its members as a subclass?"), Cannot_invoke_an_object_which_is_possibly_null: t(2721, e.DiagnosticCategory.Error, "Cannot_invoke_an_object_which_is_possibly_null_2721", "Cannot invoke an object which is possibly 'null'."), Cannot_invoke_an_object_which_is_possibly_undefined: t(2722, e.DiagnosticCategory.Error, "Cannot_invoke_an_object_which_is_possibly_undefined_2722", "Cannot invoke an object which is possibly 'undefined'."), Cannot_invoke_an_object_which_is_possibly_null_or_undefined: t(2723, e.DiagnosticCategory.Error, "Cannot_invoke_an_object_which_is_possibly_null_or_undefined_2723", "Cannot invoke an object which is possibly 'null' or 'undefined'."), _0_has_no_exported_member_named_1_Did_you_mean_2: t(2724, e.DiagnosticCategory.Error, "_0_has_no_exported_member_named_1_Did_you_mean_2_2724", "'{0}' has no exported member named '{1}'. Did you mean '{2}'?"), Class_name_cannot_be_Object_when_targeting_ES5_with_module_0: t(2725, e.DiagnosticCategory.Error, "Class_name_cannot_be_Object_when_targeting_ES5_with_module_0_2725", "Class name cannot be 'Object' when targeting ES5 with module {0}."), Cannot_find_lib_definition_for_0: t(2726, e.DiagnosticCategory.Error, "Cannot_find_lib_definition_for_0_2726", "Cannot find lib definition for '{0}'."), Cannot_find_lib_definition_for_0_Did_you_mean_1: t(2727, e.DiagnosticCategory.Error, "Cannot_find_lib_definition_for_0_Did_you_mean_1_2727", "Cannot find lib definition for '{0}'. Did you mean '{1}'?"), _0_is_declared_here: t(2728, e.DiagnosticCategory.Message, "_0_is_declared_here_2728", "'{0}' is declared here."), Property_0_is_used_before_its_initialization: t(2729, e.DiagnosticCategory.Error, "Property_0_is_used_before_its_initialization_2729", "Property '{0}' is used before its initialization."), An_arrow_function_cannot_have_a_this_parameter: t(2730, e.DiagnosticCategory.Error, "An_arrow_function_cannot_have_a_this_parameter_2730", "An arrow function cannot have a 'this' parameter."), Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String: t(2731, e.DiagnosticCategory.Error, "Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_i_2731", "Implicit conversion of a 'symbol' to a 'string' will fail at runtime. Consider wrapping this expression in 'String(...)'."), Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension: t(2732, e.DiagnosticCategory.Error, "Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension_2732", "Cannot find module '{0}'. Consider using '--resolveJsonModule' to import module with '.json' extension."), Property_0_was_also_declared_here: t(2733, e.DiagnosticCategory.Error, "Property_0_was_also_declared_here_2733", "Property '{0}' was also declared here."), Are_you_missing_a_semicolon: t(2734, e.DiagnosticCategory.Error, "Are_you_missing_a_semicolon_2734", "Are you missing a semicolon?"), Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1: t(2735, e.DiagnosticCategory.Error, "Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1_2735", "Did you mean for '{0}' to be constrained to type 'new (...args: any[]) => {1}'?"), Operator_0_cannot_be_applied_to_type_1: t(2736, e.DiagnosticCategory.Error, "Operator_0_cannot_be_applied_to_type_1_2736", "Operator '{0}' cannot be applied to type '{1}'."), BigInt_literals_are_not_available_when_targeting_lower_than_ES2020: t(2737, e.DiagnosticCategory.Error, "BigInt_literals_are_not_available_when_targeting_lower_than_ES2020_2737", "BigInt literals are not available when targeting lower than ES2020."), An_outer_value_of_this_is_shadowed_by_this_container: t(2738, e.DiagnosticCategory.Message, "An_outer_value_of_this_is_shadowed_by_this_container_2738", "An outer value of 'this' is shadowed by this container."), Type_0_is_missing_the_following_properties_from_type_1_Colon_2: t(2739, e.DiagnosticCategory.Error, "Type_0_is_missing_the_following_properties_from_type_1_Colon_2_2739", "Type '{0}' is missing the following properties from type '{1}': {2}"), Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more: t(2740, e.DiagnosticCategory.Error, "Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more_2740", "Type '{0}' is missing the following properties from type '{1}': {2}, and {3} more."), Property_0_is_missing_in_type_1_but_required_in_type_2: t(2741, e.DiagnosticCategory.Error, "Property_0_is_missing_in_type_1_but_required_in_type_2_2741", "Property '{0}' is missing in type '{1}' but required in type '{2}'."), The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_annotation_is_necessary: t(2742, e.DiagnosticCategory.Error, "The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_a_2742", "The inferred type of '{0}' cannot be named without a reference to '{1}'. This is likely not portable. A type annotation is necessary."), No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments: t(2743, e.DiagnosticCategory.Error, "No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments_2743", "No overload expects {0} type arguments, but overloads do exist that expect either {1} or {2} type arguments."), Type_parameter_defaults_can_only_reference_previously_declared_type_parameters: t(2744, e.DiagnosticCategory.Error, "Type_parameter_defaults_can_only_reference_previously_declared_type_parameters_2744", "Type parameter defaults can only reference previously declared type parameters."), This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided: t(2745, e.DiagnosticCategory.Error, "This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_pr_2745", "This JSX tag's '{0}' prop expects type '{1}' which requires multiple children, but only a single child was provided."), This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided: t(2746, e.DiagnosticCategory.Error, "This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided_2746", "This JSX tag's '{0}' prop expects a single child of type '{1}', but multiple children were provided."), _0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2: t(2747, e.DiagnosticCategory.Error, "_0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_t_2747", "'{0}' components don't accept text as child elements. Text in JSX has the type 'string', but the expected type of '{1}' is '{2}'."), Cannot_access_ambient_const_enums_when_the_isolatedModules_flag_is_provided: t(2748, e.DiagnosticCategory.Error, "Cannot_access_ambient_const_enums_when_the_isolatedModules_flag_is_provided_2748", "Cannot access ambient const enums when the '--isolatedModules' flag is provided."), _0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0: t(2749, e.DiagnosticCategory.Error, "_0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0_2749", "'{0}' refers to a value, but is being used as a type here. Did you mean 'typeof {0}'?"), The_implementation_signature_is_declared_here: t(2750, e.DiagnosticCategory.Error, "The_implementation_signature_is_declared_here_2750", "The implementation signature is declared here."), Circularity_originates_in_type_at_this_location: t(2751, e.DiagnosticCategory.Error, "Circularity_originates_in_type_at_this_location_2751", "Circularity originates in type at this location."), The_first_export_default_is_here: t(2752, e.DiagnosticCategory.Error, "The_first_export_default_is_here_2752", "The first export default is here."), Another_export_default_is_here: t(2753, e.DiagnosticCategory.Error, "Another_export_default_is_here_2753", "Another export default is here."), super_may_not_use_type_arguments: t(2754, e.DiagnosticCategory.Error, "super_may_not_use_type_arguments_2754", "'super' may not use type arguments."), No_constituent_of_type_0_is_callable: t(2755, e.DiagnosticCategory.Error, "No_constituent_of_type_0_is_callable_2755", "No constituent of type '{0}' is callable."), Not_all_constituents_of_type_0_are_callable: t(2756, e.DiagnosticCategory.Error, "Not_all_constituents_of_type_0_are_callable_2756", "Not all constituents of type '{0}' are callable."), Type_0_has_no_call_signatures: t(2757, e.DiagnosticCategory.Error, "Type_0_has_no_call_signatures_2757", "Type '{0}' has no call signatures."), Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other: t(2758, e.DiagnosticCategory.Error, "Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_2758", "Each member of the union type '{0}' has signatures, but none of those signatures are compatible with each other."), No_constituent_of_type_0_is_constructable: t(2759, e.DiagnosticCategory.Error, "No_constituent_of_type_0_is_constructable_2759", "No constituent of type '{0}' is constructable."), Not_all_constituents_of_type_0_are_constructable: t(2760, e.DiagnosticCategory.Error, "Not_all_constituents_of_type_0_are_constructable_2760", "Not all constituents of type '{0}' are constructable."), Type_0_has_no_construct_signatures: t(2761, e.DiagnosticCategory.Error, "Type_0_has_no_construct_signatures_2761", "Type '{0}' has no construct signatures."), Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other: t(2762, e.DiagnosticCategory.Error, "Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_2762", "Each member of the union type '{0}' has construct signatures, but none of those signatures are compatible with each other."), Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0: t(2763, e.DiagnosticCategory.Error, "Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_s_2763", "Cannot iterate value because the 'next' method of its iterator expects type '{1}', but for-of will always send '{0}'."), Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0: t(2764, e.DiagnosticCategory.Error, "Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_al_2764", "Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array spread will always send '{0}'."), Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0: t(2765, e.DiagnosticCategory.Error, "Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring__2765", "Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array destructuring will always send '{0}'."), Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0: t(2766, e.DiagnosticCategory.Error, "Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_co_2766", "Cannot delegate iteration to value because the 'next' method of its iterator expects type '{1}', but the containing generator will always send '{0}'."), The_0_property_of_an_iterator_must_be_a_method: t(2767, e.DiagnosticCategory.Error, "The_0_property_of_an_iterator_must_be_a_method_2767", "The '{0}' property of an iterator must be a method."), The_0_property_of_an_async_iterator_must_be_a_method: t(2768, e.DiagnosticCategory.Error, "The_0_property_of_an_async_iterator_must_be_a_method_2768", "The '{0}' property of an async iterator must be a method."), No_overload_matches_this_call: t(2769, e.DiagnosticCategory.Error, "No_overload_matches_this_call_2769", "No overload matches this call."), The_last_overload_gave_the_following_error: t(2770, e.DiagnosticCategory.Error, "The_last_overload_gave_the_following_error_2770", "The last overload gave the following error."), The_last_overload_is_declared_here: t(2771, e.DiagnosticCategory.Error, "The_last_overload_is_declared_here_2771", "The last overload is declared here."), Overload_0_of_1_2_gave_the_following_error: t(2772, e.DiagnosticCategory.Error, "Overload_0_of_1_2_gave_the_following_error_2772", "Overload {0} of {1}, '{2}', gave the following error."), Did_you_forget_to_use_await: t(2773, e.DiagnosticCategory.Error, "Did_you_forget_to_use_await_2773", "Did you forget to use 'await'?"), This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead: t(2774, e.DiagnosticCategory.Error, "This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_2774", "This condition will always return true since this function is always defined. Did you mean to call it instead?"), Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation: t(2775, e.DiagnosticCategory.Error, "Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation_2775", "Assertions require every name in the call target to be declared with an explicit type annotation."), Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name: t(2776, e.DiagnosticCategory.Error, "Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name_2776", "Assertions require the call target to be an identifier or qualified name."), The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access: t(2777, e.DiagnosticCategory.Error, "The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access_2777", "The operand of an increment or decrement operator may not be an optional property access."), The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access: t(2778, e.DiagnosticCategory.Error, "The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access_2778", "The target of an object rest assignment may not be an optional property access."), The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access: t(2779, e.DiagnosticCategory.Error, "The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access_2779", "The left-hand side of an assignment expression may not be an optional property access."), The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access: t(2780, e.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access_2780", "The left-hand side of a 'for...in' statement may not be an optional property access."), The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access: t(2781, e.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access_2781", "The left-hand side of a 'for...of' statement may not be an optional property access."), _0_needs_an_explicit_type_annotation: t(2782, e.DiagnosticCategory.Message, "_0_needs_an_explicit_type_annotation_2782", "'{0}' needs an explicit type annotation."), _0_is_specified_more_than_once_so_this_usage_will_be_overwritten: t(2783, e.DiagnosticCategory.Error, "_0_is_specified_more_than_once_so_this_usage_will_be_overwritten_2783", "'{0}' is specified more than once, so this usage will be overwritten."), get_and_set_accessors_cannot_declare_this_parameters: t(2784, e.DiagnosticCategory.Error, "get_and_set_accessors_cannot_declare_this_parameters_2784", "'get' and 'set' accessors cannot declare 'this' parameters."), This_spread_always_overwrites_this_property: t(2785, e.DiagnosticCategory.Error, "This_spread_always_overwrites_this_property_2785", "This spread always overwrites this property."), _0_cannot_be_used_as_a_JSX_component: t(2786, e.DiagnosticCategory.Error, "_0_cannot_be_used_as_a_JSX_component_2786", "'{0}' cannot be used as a JSX component."), Its_return_type_0_is_not_a_valid_JSX_element: t(2787, e.DiagnosticCategory.Error, "Its_return_type_0_is_not_a_valid_JSX_element_2787", "Its return type '{0}' is not a valid JSX element."), Its_instance_type_0_is_not_a_valid_JSX_element: t(2788, e.DiagnosticCategory.Error, "Its_instance_type_0_is_not_a_valid_JSX_element_2788", "Its instance type '{0}' is not a valid JSX element."), Its_element_type_0_is_not_a_valid_JSX_element: t(2789, e.DiagnosticCategory.Error, "Its_element_type_0_is_not_a_valid_JSX_element_2789", "Its element type '{0}' is not a valid JSX element."), The_operand_of_a_delete_operator_must_be_optional: t(2790, e.DiagnosticCategory.Error, "The_operand_of_a_delete_operator_must_be_optional_2790", "The operand of a 'delete' operator must be optional."), Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later: t(2791, e.DiagnosticCategory.Error, "Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_lat_2791", "Exponentiation cannot be performed on 'bigint' values unless the 'target' option is set to 'es2016' or later."), Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_node_or_to_add_aliases_to_the_paths_option: t(2792, e.DiagnosticCategory.Error, "Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_node_or_to_add_aliases_to_th_2792", "Cannot find module '{0}'. Did you mean to set the 'moduleResolution' option to 'node', or to add aliases to the 'paths' option?"), The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible: t(2793, e.DiagnosticCategory.Error, "The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_2793", "The call would have succeeded against this implementation, but implementation signatures of overloads are not externally visible."), Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise: t(2794, e.DiagnosticCategory.Error, "Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise_2794", "Expected {0} arguments, but got {1}. Did you forget to include 'void' in your type argument to 'Promise'?"), The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types: t(2795, e.DiagnosticCategory.Error, "The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types_2795", "The 'intrinsic' keyword can only be used to declare compiler provided intrinsic types."), It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked: t(2796, e.DiagnosticCategory.Error, "It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tag_2796", "It is likely that you are missing a comma to separate these two template expressions. They form a tagged template expression which cannot be invoked."), A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract: t(2797, e.DiagnosticCategory.Error, "A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_2797", "A mixin class that extends from a type variable containing an abstract construct signature must also be declared 'abstract'."), The_declaration_was_marked_as_deprecated_here: t(2798, e.DiagnosticCategory.Error, "The_declaration_was_marked_as_deprecated_here_2798", "The declaration was marked as deprecated here."), Type_produces_a_tuple_type_that_is_too_large_to_represent: t(2799, e.DiagnosticCategory.Error, "Type_produces_a_tuple_type_that_is_too_large_to_represent_2799", "Type produces a tuple type that is too large to represent."), Expression_produces_a_tuple_type_that_is_too_large_to_represent: t(2800, e.DiagnosticCategory.Error, "Expression_produces_a_tuple_type_that_is_too_large_to_represent_2800", "Expression produces a tuple type that is too large to represent."), This_condition_will_always_return_true_since_this_0_is_always_defined: t(2801, e.DiagnosticCategory.Error, "This_condition_will_always_return_true_since_this_0_is_always_defined_2801", "This condition will always return true since this '{0}' is always defined."), Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher: t(2802, e.DiagnosticCategory.Error, "Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es201_2802", "Type '{0}' can only be iterated through when using the '--downlevelIteration' flag or with a '--target' of 'es2015' or higher."), Cannot_assign_to_private_method_0_Private_methods_are_not_writable: t(2803, e.DiagnosticCategory.Error, "Cannot_assign_to_private_method_0_Private_methods_are_not_writable_2803", "Cannot assign to private method '{0}'. Private methods are not writable."), Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name: t(2804, e.DiagnosticCategory.Error, "Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name_2804", "Duplicate identifier '{0}'. Static and instance elements cannot share the same private name."), Private_accessor_was_defined_without_a_getter: t(2806, e.DiagnosticCategory.Error, "Private_accessor_was_defined_without_a_getter_2806", "Private accessor was defined without a getter."), This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0: t(2807, e.DiagnosticCategory.Error, "This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_o_2807", "This syntax requires an imported helper named '{1}' with {2} parameters, which is not compatible with the one in '{0}'. Consider upgrading your version of '{0}'."), A_get_accessor_must_be_at_least_as_accessible_as_the_setter: t(2808, e.DiagnosticCategory.Error, "A_get_accessor_must_be_at_least_as_accessible_as_the_setter_2808", "A get accessor must be at least as accessible as the setter"), Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_the_whole_assignment_in_parentheses: t(2809, e.DiagnosticCategory.Error, "Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_d_2809", "Declaration or statement expected. This '=' follows a block of statements, so if you intended to write a destructuring assignment, you might need to wrap the the whole assignment in parentheses."), Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments: t(2810, e.DiagnosticCategory.Error, "Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_2810", "Expected 1 argument, but got 0. 'new Promise()' needs a JSDoc hint to produce a 'resolve' that can be called without arguments."), Initializer_for_property_0: t(2811, e.DiagnosticCategory.Error, "Initializer_for_property_0_2811", "Initializer for property '{0}'"), Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom: t(2812, e.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom_2812", "Property '{0}' does not exist on type '{1}'. Try changing the 'lib' compiler option to include 'dom'."), Class_declaration_cannot_implement_overload_list_for_0: t(2813, e.DiagnosticCategory.Error, "Class_declaration_cannot_implement_overload_list_for_0_2813", "Class declaration cannot implement overload list for '{0}'."), Function_with_bodies_can_only_merge_with_classes_that_are_ambient: t(2814, e.DiagnosticCategory.Error, "Function_with_bodies_can_only_merge_with_classes_that_are_ambient_2814", "Function with bodies can only merge with classes that are ambient."), arguments_cannot_be_referenced_in_property_initializers: t(2815, e.DiagnosticCategory.Error, "arguments_cannot_be_referenced_in_property_initializers_2815", "'arguments' cannot be referenced in property initializers."), Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class: t(2816, e.DiagnosticCategory.Error, "Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class_2816", "Cannot use 'this' in a static property initializer of a decorated class."), Property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block: t(2817, e.DiagnosticCategory.Error, "Property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block_2817", "Property '{0}' has no initializer and is not definitely assigned in a class static block."), Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers: t(2818, e.DiagnosticCategory.Error, "Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializer_2818", "Duplicate identifier '{0}'. Compiler reserves name '{1}' when emitting 'super' references in static initializers."), Namespace_name_cannot_be_0: t(2819, e.DiagnosticCategory.Error, "Namespace_name_cannot_be_0_2819", "Namespace name cannot be '{0}'."), Type_0_is_not_assignable_to_type_1_Did_you_mean_2: t(2820, e.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_Did_you_mean_2_2820", "Type '{0}' is not assignable to type '{1}'. Did you mean '{2}'?"), Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext: t(2821, e.DiagnosticCategory.Error, "Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext_2821", "Import assertions are only supported when the '--module' option is set to 'esnext' or 'nodenext'."), Import_assertions_cannot_be_used_with_type_only_imports_or_exports: t(2822, e.DiagnosticCategory.Error, "Import_assertions_cannot_be_used_with_type_only_imports_or_exports_2822", "Import assertions cannot be used with type-only imports or exports."), Cannot_find_namespace_0_Did_you_mean_1: t(2833, e.DiagnosticCategory.Error, "Cannot_find_namespace_0_Did_you_mean_1_2833", "Cannot find namespace '{0}'. Did you mean '{1}'?"), Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path: t(2834, e.DiagnosticCategory.Error, "Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_n_2834", "Relative import paths need explicit file extensions in EcmaScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Consider adding an extension to the import path."), Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0: t(2835, e.DiagnosticCategory.Error, "Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_n_2835", "Relative import paths need explicit file extensions in EcmaScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Did you mean '{0}'?"), Import_assertions_are_not_allowed_on_statements_that_transpile_to_commonjs_require_calls: t(2836, e.DiagnosticCategory.Error, "Import_assertions_are_not_allowed_on_statements_that_transpile_to_commonjs_require_calls_2836", "Import assertions are not allowed on statements that transpile to commonjs 'require' calls."), Import_assertion_values_must_be_string_literal_expressions: t(2837, e.DiagnosticCategory.Error, "Import_assertion_values_must_be_string_literal_expressions_2837", "Import assertion values must be string literal expressions."), All_declarations_of_0_must_have_identical_constraints: t(2838, e.DiagnosticCategory.Error, "All_declarations_of_0_must_have_identical_constraints_2838", "All declarations of '{0}' must have identical constraints."), This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value: t(2839, e.DiagnosticCategory.Error, "This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value_2839", "This condition will always return '{0}' since JavaScript compares objects by reference, not value."), An_interface_cannot_extend_a_primitive_type_like_0_an_interface_can_only_extend_named_types_and_classes: t(2840, e.DiagnosticCategory.Error, "An_interface_cannot_extend_a_primitive_type_like_0_an_interface_can_only_extend_named_types_and_clas_2840", "An interface cannot extend a primitive type like '{0}'; an interface can only extend named types and classes"), The_type_of_this_expression_cannot_be_named_without_a_resolution_mode_assertion_which_is_an_unstable_feature_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: t(2841, e.DiagnosticCategory.Error, "The_type_of_this_expression_cannot_be_named_without_a_resolution_mode_assertion_which_is_an_unstable_2841", "The type of this expression cannot be named without a 'resolution-mode' assertion, which is an unstable feature. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'."), _0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation: t(2842, e.DiagnosticCategory.Error, "_0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation_2842", "'{0}' is an unused renaming of '{1}'. Did you intend to use it as a type annotation?"), We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here: t(2843, e.DiagnosticCategory.Error, "We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here_2843", "We can only write a type for '{0}' by adding a type for the entire parameter here."), Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: t(2844, e.DiagnosticCategory.Error, "Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2844", "Type of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor."), This_condition_will_always_return_0: t(2845, e.DiagnosticCategory.Error, "This_condition_will_always_return_0_2845", "This condition will always return '{0}'."), Import_declaration_0_is_using_private_name_1: t(4e3, e.DiagnosticCategory.Error, "Import_declaration_0_is_using_private_name_1_4000", "Import declaration '{0}' is using private name '{1}'."), Type_parameter_0_of_exported_class_has_or_is_using_private_name_1: t(4002, e.DiagnosticCategory.Error, "Type_parameter_0_of_exported_class_has_or_is_using_private_name_1_4002", "Type parameter '{0}' of exported class has or is using private name '{1}'."), Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1: t(4004, e.DiagnosticCategory.Error, "Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1_4004", "Type parameter '{0}' of exported interface has or is using private name '{1}'."), Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: t(4006, e.DiagnosticCategory.Error, "Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4006", "Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'."), Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: t(4008, e.DiagnosticCategory.Error, "Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4008", "Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'."), Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: t(4010, e.DiagnosticCategory.Error, "Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4010", "Type parameter '{0}' of public static method from exported class has or is using private name '{1}'."), Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: t(4012, e.DiagnosticCategory.Error, "Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4012", "Type parameter '{0}' of public method from exported class has or is using private name '{1}'."), Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: t(4014, e.DiagnosticCategory.Error, "Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4014", "Type parameter '{0}' of method from exported interface has or is using private name '{1}'."), Type_parameter_0_of_exported_function_has_or_is_using_private_name_1: t(4016, e.DiagnosticCategory.Error, "Type_parameter_0_of_exported_function_has_or_is_using_private_name_1_4016", "Type parameter '{0}' of exported function has or is using private name '{1}'."), Implements_clause_of_exported_class_0_has_or_is_using_private_name_1: t(4019, e.DiagnosticCategory.Error, "Implements_clause_of_exported_class_0_has_or_is_using_private_name_1_4019", "Implements clause of exported class '{0}' has or is using private name '{1}'."), extends_clause_of_exported_class_0_has_or_is_using_private_name_1: t(4020, e.DiagnosticCategory.Error, "extends_clause_of_exported_class_0_has_or_is_using_private_name_1_4020", "'extends' clause of exported class '{0}' has or is using private name '{1}'."), extends_clause_of_exported_class_has_or_is_using_private_name_0: t(4021, e.DiagnosticCategory.Error, "extends_clause_of_exported_class_has_or_is_using_private_name_0_4021", "'extends' clause of exported class has or is using private name '{0}'."), extends_clause_of_exported_interface_0_has_or_is_using_private_name_1: t(4022, e.DiagnosticCategory.Error, "extends_clause_of_exported_interface_0_has_or_is_using_private_name_1_4022", "'extends' clause of exported interface '{0}' has or is using private name '{1}'."), Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: t(4023, e.DiagnosticCategory.Error, "Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4023", "Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named."), Exported_variable_0_has_or_is_using_name_1_from_private_module_2: t(4024, e.DiagnosticCategory.Error, "Exported_variable_0_has_or_is_using_name_1_from_private_module_2_4024", "Exported variable '{0}' has or is using name '{1}' from private module '{2}'."), Exported_variable_0_has_or_is_using_private_name_1: t(4025, e.DiagnosticCategory.Error, "Exported_variable_0_has_or_is_using_private_name_1_4025", "Exported variable '{0}' has or is using private name '{1}'."), Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: t(4026, e.DiagnosticCategory.Error, "Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot__4026", "Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."), Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: t(4027, e.DiagnosticCategory.Error, "Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4027", "Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'."), Public_static_property_0_of_exported_class_has_or_is_using_private_name_1: t(4028, e.DiagnosticCategory.Error, "Public_static_property_0_of_exported_class_has_or_is_using_private_name_1_4028", "Public static property '{0}' of exported class has or is using private name '{1}'."), Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: t(4029, e.DiagnosticCategory.Error, "Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_name_4029", "Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."), Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: t(4030, e.DiagnosticCategory.Error, "Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4030", "Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'."), Public_property_0_of_exported_class_has_or_is_using_private_name_1: t(4031, e.DiagnosticCategory.Error, "Public_property_0_of_exported_class_has_or_is_using_private_name_1_4031", "Public property '{0}' of exported class has or is using private name '{1}'."), Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: t(4032, e.DiagnosticCategory.Error, "Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4032", "Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'."), Property_0_of_exported_interface_has_or_is_using_private_name_1: t(4033, e.DiagnosticCategory.Error, "Property_0_of_exported_interface_has_or_is_using_private_name_1_4033", "Property '{0}' of exported interface has or is using private name '{1}'."), Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: t(4034, e.DiagnosticCategory.Error, "Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_mod_4034", "Parameter type of public static setter '{0}' from exported class has or is using name '{1}' from private module '{2}'."), Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1: t(4035, e.DiagnosticCategory.Error, "Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1_4035", "Parameter type of public static setter '{0}' from exported class has or is using private name '{1}'."), Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: t(4036, e.DiagnosticCategory.Error, "Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4036", "Parameter type of public setter '{0}' from exported class has or is using name '{1}' from private module '{2}'."), Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1: t(4037, e.DiagnosticCategory.Error, "Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1_4037", "Parameter type of public setter '{0}' from exported class has or is using private name '{1}'."), Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: t(4038, e.DiagnosticCategory.Error, "Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_modul_4038", "Return type of public static getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named."), Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: t(4039, e.DiagnosticCategory.Error, "Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_4039", "Return type of public static getter '{0}' from exported class has or is using name '{1}' from private module '{2}'."), Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1: t(4040, e.DiagnosticCategory.Error, "Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1_4040", "Return type of public static getter '{0}' from exported class has or is using private name '{1}'."), Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: t(4041, e.DiagnosticCategory.Error, "Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_4041", "Return type of public getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named."), Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: t(4042, e.DiagnosticCategory.Error, "Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4042", "Return type of public getter '{0}' from exported class has or is using name '{1}' from private module '{2}'."), Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1: t(4043, e.DiagnosticCategory.Error, "Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1_4043", "Return type of public getter '{0}' from exported class has or is using private name '{1}'."), Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: t(4044, e.DiagnosticCategory.Error, "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_mod_4044", "Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'."), Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0: t(4045, e.DiagnosticCategory.Error, "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0_4045", "Return type of constructor signature from exported interface has or is using private name '{0}'."), Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: t(4046, e.DiagnosticCategory.Error, "Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4046", "Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'."), Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0: t(4047, e.DiagnosticCategory.Error, "Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0_4047", "Return type of call signature from exported interface has or is using private name '{0}'."), Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: t(4048, e.DiagnosticCategory.Error, "Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4048", "Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'."), Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0: t(4049, e.DiagnosticCategory.Error, "Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0_4049", "Return type of index signature from exported interface has or is using private name '{0}'."), Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: t(4050, e.DiagnosticCategory.Error, "Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module__4050", "Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named."), Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: t(4051, e.DiagnosticCategory.Error, "Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4051", "Return type of public static method from exported class has or is using name '{0}' from private module '{1}'."), Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0: t(4052, e.DiagnosticCategory.Error, "Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0_4052", "Return type of public static method from exported class has or is using private name '{0}'."), Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: t(4053, e.DiagnosticCategory.Error, "Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_c_4053", "Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named."), Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: t(4054, e.DiagnosticCategory.Error, "Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4054", "Return type of public method from exported class has or is using name '{0}' from private module '{1}'."), Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0: t(4055, e.DiagnosticCategory.Error, "Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0_4055", "Return type of public method from exported class has or is using private name '{0}'."), Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1: t(4056, e.DiagnosticCategory.Error, "Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4056", "Return type of method from exported interface has or is using name '{0}' from private module '{1}'."), Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0: t(4057, e.DiagnosticCategory.Error, "Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0_4057", "Return type of method from exported interface has or is using private name '{0}'."), Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: t(4058, e.DiagnosticCategory.Error, "Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named_4058", "Return type of exported function has or is using name '{0}' from external module {1} but cannot be named."), Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1: t(4059, e.DiagnosticCategory.Error, "Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1_4059", "Return type of exported function has or is using name '{0}' from private module '{1}'."), Return_type_of_exported_function_has_or_is_using_private_name_0: t(4060, e.DiagnosticCategory.Error, "Return_type_of_exported_function_has_or_is_using_private_name_0_4060", "Return type of exported function has or is using private name '{0}'."), Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: t(4061, e.DiagnosticCategory.Error, "Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_can_4061", "Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named."), Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2: t(4062, e.DiagnosticCategory.Error, "Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2_4062", "Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'."), Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1: t(4063, e.DiagnosticCategory.Error, "Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1_4063", "Parameter '{0}' of constructor from exported class has or is using private name '{1}'."), Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: t(4064, e.DiagnosticCategory.Error, "Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_mod_4064", "Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'."), Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: t(4065, e.DiagnosticCategory.Error, "Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4065", "Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'."), Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: t(4066, e.DiagnosticCategory.Error, "Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4066", "Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'."), Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: t(4067, e.DiagnosticCategory.Error, "Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4067", "Parameter '{0}' of call signature from exported interface has or is using private name '{1}'."), Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: t(4068, e.DiagnosticCategory.Error, "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module__4068", "Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named."), Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: t(4069, e.DiagnosticCategory.Error, "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4069", "Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'."), Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: t(4070, e.DiagnosticCategory.Error, "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4070", "Parameter '{0}' of public static method from exported class has or is using private name '{1}'."), Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: t(4071, e.DiagnosticCategory.Error, "Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_c_4071", "Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named."), Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: t(4072, e.DiagnosticCategory.Error, "Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4072", "Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'."), Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: t(4073, e.DiagnosticCategory.Error, "Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4073", "Parameter '{0}' of public method from exported class has or is using private name '{1}'."), Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: t(4074, e.DiagnosticCategory.Error, "Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4074", "Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'."), Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: t(4075, e.DiagnosticCategory.Error, "Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4075", "Parameter '{0}' of method from exported interface has or is using private name '{1}'."), Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: t(4076, e.DiagnosticCategory.Error, "Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4076", "Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named."), Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: t(4077, e.DiagnosticCategory.Error, "Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2_4077", "Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'."), Parameter_0_of_exported_function_has_or_is_using_private_name_1: t(4078, e.DiagnosticCategory.Error, "Parameter_0_of_exported_function_has_or_is_using_private_name_1_4078", "Parameter '{0}' of exported function has or is using private name '{1}'."), Exported_type_alias_0_has_or_is_using_private_name_1: t(4081, e.DiagnosticCategory.Error, "Exported_type_alias_0_has_or_is_using_private_name_1_4081", "Exported type alias '{0}' has or is using private name '{1}'."), Default_export_of_the_module_has_or_is_using_private_name_0: t(4082, e.DiagnosticCategory.Error, "Default_export_of_the_module_has_or_is_using_private_name_0_4082", "Default export of the module has or is using private name '{0}'."), Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1: t(4083, e.DiagnosticCategory.Error, "Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1_4083", "Type parameter '{0}' of exported type alias has or is using private name '{1}'."), Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2: t(4084, e.DiagnosticCategory.Error, "Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2_4084", "Exported type alias '{0}' has or is using private name '{1}' from module {2}."), Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_library_to_resolve_the_conflict: t(4090, e.DiagnosticCategory.Error, "Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_librar_4090", "Conflicting definitions for '{0}' found at '{1}' and '{2}'. Consider installing a specific version of this library to resolve the conflict."), Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: t(4091, e.DiagnosticCategory.Error, "Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4091", "Parameter '{0}' of index signature from exported interface has or is using name '{1}' from private module '{2}'."), Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1: t(4092, e.DiagnosticCategory.Error, "Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1_4092", "Parameter '{0}' of index signature from exported interface has or is using private name '{1}'."), Property_0_of_exported_class_expression_may_not_be_private_or_protected: t(4094, e.DiagnosticCategory.Error, "Property_0_of_exported_class_expression_may_not_be_private_or_protected_4094", "Property '{0}' of exported class expression may not be private or protected."), Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: t(4095, e.DiagnosticCategory.Error, "Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_4095", "Public static method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."), Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: t(4096, e.DiagnosticCategory.Error, "Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4096", "Public static method '{0}' of exported class has or is using name '{1}' from private module '{2}'."), Public_static_method_0_of_exported_class_has_or_is_using_private_name_1: t(4097, e.DiagnosticCategory.Error, "Public_static_method_0_of_exported_class_has_or_is_using_private_name_1_4097", "Public static method '{0}' of exported class has or is using private name '{1}'."), Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: t(4098, e.DiagnosticCategory.Error, "Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4098", "Public method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."), Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: t(4099, e.DiagnosticCategory.Error, "Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4099", "Public method '{0}' of exported class has or is using name '{1}' from private module '{2}'."), Public_method_0_of_exported_class_has_or_is_using_private_name_1: t(4100, e.DiagnosticCategory.Error, "Public_method_0_of_exported_class_has_or_is_using_private_name_1_4100", "Public method '{0}' of exported class has or is using private name '{1}'."), Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: t(4101, e.DiagnosticCategory.Error, "Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4101", "Method '{0}' of exported interface has or is using name '{1}' from private module '{2}'."), Method_0_of_exported_interface_has_or_is_using_private_name_1: t(4102, e.DiagnosticCategory.Error, "Method_0_of_exported_interface_has_or_is_using_private_name_1_4102", "Method '{0}' of exported interface has or is using private name '{1}'."), Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1: t(4103, e.DiagnosticCategory.Error, "Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1_4103", "Type parameter '{0}' of exported mapped object type is using private name '{1}'."), The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1: t(4104, e.DiagnosticCategory.Error, "The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1_4104", "The type '{0}' is 'readonly' and cannot be assigned to the mutable type '{1}'."), Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter: t(4105, e.DiagnosticCategory.Error, "Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter_4105", "Private or protected member '{0}' cannot be accessed on a type parameter."), Parameter_0_of_accessor_has_or_is_using_private_name_1: t(4106, e.DiagnosticCategory.Error, "Parameter_0_of_accessor_has_or_is_using_private_name_1_4106", "Parameter '{0}' of accessor has or is using private name '{1}'."), Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2: t(4107, e.DiagnosticCategory.Error, "Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2_4107", "Parameter '{0}' of accessor has or is using name '{1}' from private module '{2}'."), Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: t(4108, e.DiagnosticCategory.Error, "Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4108", "Parameter '{0}' of accessor has or is using name '{1}' from external module '{2}' but cannot be named."), Type_arguments_for_0_circularly_reference_themselves: t(4109, e.DiagnosticCategory.Error, "Type_arguments_for_0_circularly_reference_themselves_4109", "Type arguments for '{0}' circularly reference themselves."), Tuple_type_arguments_circularly_reference_themselves: t(4110, e.DiagnosticCategory.Error, "Tuple_type_arguments_circularly_reference_themselves_4110", "Tuple type arguments circularly reference themselves."), Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0: t(4111, e.DiagnosticCategory.Error, "Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0_4111", "Property '{0}' comes from an index signature, so it must be accessed with ['{0}']."), This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class: t(4112, e.DiagnosticCategory.Error, "This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another__4112", "This member cannot have an 'override' modifier because its containing class '{0}' does not extend another class."), This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0: t(4113, e.DiagnosticCategory.Error, "This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_4113", "This member cannot have an 'override' modifier because it is not declared in the base class '{0}'."), This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0: t(4114, e.DiagnosticCategory.Error, "This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0_4114", "This member must have an 'override' modifier because it overrides a member in the base class '{0}'."), This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0: t(4115, e.DiagnosticCategory.Error, "This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0_4115", "This parameter property must have an 'override' modifier because it overrides a member in base class '{0}'."), This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0: t(4116, e.DiagnosticCategory.Error, "This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared__4116", "This member must have an 'override' modifier because it overrides an abstract method that is declared in the base class '{0}'."), This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1: t(4117, e.DiagnosticCategory.Error, "This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you__4117", "This member cannot have an 'override' modifier because it is not declared in the base class '{0}'. Did you mean '{1}'?"), The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized: t(4118, e.DiagnosticCategory.Error, "The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized_4118", "The type of this node cannot be serialized because its property '{0}' cannot be serialized."), This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0: t(4119, e.DiagnosticCategory.Error, "This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_4119", "This member must have a JSDoc comment with an '@override' tag because it overrides a member in the base class '{0}'."), This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0: t(4120, e.DiagnosticCategory.Error, "This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_4120", "This parameter property must have a JSDoc comment with an '@override' tag because it overrides a member in the base class '{0}'."), This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class: t(4121, e.DiagnosticCategory.Error, "This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_4121", "This member cannot have a JSDoc comment with an '@override' tag because its containing class '{0}' does not extend another class."), This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0: t(4122, e.DiagnosticCategory.Error, "This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base__4122", "This member cannot have a JSDoc comment with an '@override' tag because it is not declared in the base class '{0}'."), This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1: t(4123, e.DiagnosticCategory.Error, "This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base__4123", "This member cannot have a JSDoc comment with an 'override' tag because it is not declared in the base class '{0}'. Did you mean '{1}'?"), Compiler_option_0_of_value_1_is_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: t(4124, e.DiagnosticCategory.Error, "Compiler_option_0_of_value_1_is_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_w_4124", "Compiler option '{0}' of value '{1}' is unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'."), resolution_mode_assertions_are_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: t(4125, e.DiagnosticCategory.Error, "resolution_mode_assertions_are_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_wi_4125", "'resolution-mode' assertions are unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'."), The_current_host_does_not_support_the_0_option: t(5001, e.DiagnosticCategory.Error, "The_current_host_does_not_support_the_0_option_5001", "The current host does not support the '{0}' option."), Cannot_find_the_common_subdirectory_path_for_the_input_files: t(5009, e.DiagnosticCategory.Error, "Cannot_find_the_common_subdirectory_path_for_the_input_files_5009", "Cannot find the common subdirectory path for the input files."), File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: t(5010, e.DiagnosticCategory.Error, "File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0_5010", "File specification cannot end in a recursive directory wildcard ('**'): '{0}'."), Cannot_read_file_0_Colon_1: t(5012, e.DiagnosticCategory.Error, "Cannot_read_file_0_Colon_1_5012", "Cannot read file '{0}': {1}."), Failed_to_parse_file_0_Colon_1: t(5014, e.DiagnosticCategory.Error, "Failed_to_parse_file_0_Colon_1_5014", "Failed to parse file '{0}': {1}."), Unknown_compiler_option_0: t(5023, e.DiagnosticCategory.Error, "Unknown_compiler_option_0_5023", "Unknown compiler option '{0}'."), Compiler_option_0_requires_a_value_of_type_1: t(5024, e.DiagnosticCategory.Error, "Compiler_option_0_requires_a_value_of_type_1_5024", "Compiler option '{0}' requires a value of type {1}."), Unknown_compiler_option_0_Did_you_mean_1: t(5025, e.DiagnosticCategory.Error, "Unknown_compiler_option_0_Did_you_mean_1_5025", "Unknown compiler option '{0}'. Did you mean '{1}'?"), Could_not_write_file_0_Colon_1: t(5033, e.DiagnosticCategory.Error, "Could_not_write_file_0_Colon_1_5033", "Could not write file '{0}': {1}."), Option_project_cannot_be_mixed_with_source_files_on_a_command_line: t(5042, e.DiagnosticCategory.Error, "Option_project_cannot_be_mixed_with_source_files_on_a_command_line_5042", "Option 'project' cannot be mixed with source files on a command line."), Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES2015_or_higher: t(5047, e.DiagnosticCategory.Error, "Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES_5047", "Option 'isolatedModules' can only be used when either option '--module' is provided or option 'target' is 'ES2015' or higher."), Option_0_cannot_be_specified_when_option_target_is_ES3: t(5048, e.DiagnosticCategory.Error, "Option_0_cannot_be_specified_when_option_target_is_ES3_5048", "Option '{0}' cannot be specified when option 'target' is 'ES3'."), Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided: t(5051, e.DiagnosticCategory.Error, "Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided_5051", "Option '{0} can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided."), Option_0_cannot_be_specified_without_specifying_option_1: t(5052, e.DiagnosticCategory.Error, "Option_0_cannot_be_specified_without_specifying_option_1_5052", "Option '{0}' cannot be specified without specifying option '{1}'."), Option_0_cannot_be_specified_with_option_1: t(5053, e.DiagnosticCategory.Error, "Option_0_cannot_be_specified_with_option_1_5053", "Option '{0}' cannot be specified with option '{1}'."), A_tsconfig_json_file_is_already_defined_at_Colon_0: t(5054, e.DiagnosticCategory.Error, "A_tsconfig_json_file_is_already_defined_at_Colon_0_5054", "A 'tsconfig.json' file is already defined at: '{0}'."), Cannot_write_file_0_because_it_would_overwrite_input_file: t(5055, e.DiagnosticCategory.Error, "Cannot_write_file_0_because_it_would_overwrite_input_file_5055", "Cannot write file '{0}' because it would overwrite input file."), Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files: t(5056, e.DiagnosticCategory.Error, "Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files_5056", "Cannot write file '{0}' because it would be overwritten by multiple input files."), Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0: t(5057, e.DiagnosticCategory.Error, "Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0_5057", "Cannot find a tsconfig.json file at the specified directory: '{0}'."), The_specified_path_does_not_exist_Colon_0: t(5058, e.DiagnosticCategory.Error, "The_specified_path_does_not_exist_Colon_0_5058", "The specified path does not exist: '{0}'."), Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier: t(5059, e.DiagnosticCategory.Error, "Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier_5059", "Invalid value for '--reactNamespace'. '{0}' is not a valid identifier."), Pattern_0_can_have_at_most_one_Asterisk_character: t(5061, e.DiagnosticCategory.Error, "Pattern_0_can_have_at_most_one_Asterisk_character_5061", "Pattern '{0}' can have at most one '*' character."), Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character: t(5062, e.DiagnosticCategory.Error, "Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character_5062", "Substitution '{0}' in pattern '{1}' can have at most one '*' character."), Substitutions_for_pattern_0_should_be_an_array: t(5063, e.DiagnosticCategory.Error, "Substitutions_for_pattern_0_should_be_an_array_5063", "Substitutions for pattern '{0}' should be an array."), Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2: t(5064, e.DiagnosticCategory.Error, "Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2_5064", "Substitution '{0}' for pattern '{1}' has incorrect type, expected 'string', got '{2}'."), File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: t(5065, e.DiagnosticCategory.Error, "File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildca_5065", "File specification cannot contain a parent directory ('..') that appears after a recursive directory wildcard ('**'): '{0}'."), Substitutions_for_pattern_0_shouldn_t_be_an_empty_array: t(5066, e.DiagnosticCategory.Error, "Substitutions_for_pattern_0_shouldn_t_be_an_empty_array_5066", "Substitutions for pattern '{0}' shouldn't be an empty array."), Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name: t(5067, e.DiagnosticCategory.Error, "Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name_5067", "Invalid value for 'jsxFactory'. '{0}' is not a valid identifier or qualified-name."), Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript_files_Learn_more_at_https_Colon_Slash_Slashaka_ms_Slashtsconfig: t(5068, e.DiagnosticCategory.Error, "Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript__5068", "Adding a tsconfig.json file will help organize projects that contain both TypeScript and JavaScript files. Learn more at https://aka.ms/tsconfig."), Option_0_cannot_be_specified_without_specifying_option_1_or_option_2: t(5069, e.DiagnosticCategory.Error, "Option_0_cannot_be_specified_without_specifying_option_1_or_option_2_5069", "Option '{0}' cannot be specified without specifying option '{1}' or option '{2}'."), Option_resolveJsonModule_cannot_be_specified_without_node_module_resolution_strategy: t(5070, e.DiagnosticCategory.Error, "Option_resolveJsonModule_cannot_be_specified_without_node_module_resolution_strategy_5070", "Option '--resolveJsonModule' cannot be specified without 'node' module resolution strategy."), Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_esNext: t(5071, e.DiagnosticCategory.Error, "Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_5071", "Option '--resolveJsonModule' can only be specified when module code generation is 'commonjs', 'amd', 'es2015' or 'esNext'."), Unknown_build_option_0: t(5072, e.DiagnosticCategory.Error, "Unknown_build_option_0_5072", "Unknown build option '{0}'."), Build_option_0_requires_a_value_of_type_1: t(5073, e.DiagnosticCategory.Error, "Build_option_0_requires_a_value_of_type_1_5073", "Build option '{0}' requires a value of type {1}."), Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBuildInfoFile_is_specified: t(5074, e.DiagnosticCategory.Error, "Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBui_5074", "Option '--incremental' can only be specified using tsconfig, emitting to single file or when option '--tsBuildInfoFile' is specified."), _0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2: t(5075, e.DiagnosticCategory.Error, "_0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_5075", "'{0}' is assignable to the constraint of type '{1}', but '{1}' could be instantiated with a different subtype of constraint '{2}'."), _0_and_1_operations_cannot_be_mixed_without_parentheses: t(5076, e.DiagnosticCategory.Error, "_0_and_1_operations_cannot_be_mixed_without_parentheses_5076", "'{0}' and '{1}' operations cannot be mixed without parentheses."), Unknown_build_option_0_Did_you_mean_1: t(5077, e.DiagnosticCategory.Error, "Unknown_build_option_0_Did_you_mean_1_5077", "Unknown build option '{0}'. Did you mean '{1}'?"), Unknown_watch_option_0: t(5078, e.DiagnosticCategory.Error, "Unknown_watch_option_0_5078", "Unknown watch option '{0}'."), Unknown_watch_option_0_Did_you_mean_1: t(5079, e.DiagnosticCategory.Error, "Unknown_watch_option_0_Did_you_mean_1_5079", "Unknown watch option '{0}'. Did you mean '{1}'?"), Watch_option_0_requires_a_value_of_type_1: t(5080, e.DiagnosticCategory.Error, "Watch_option_0_requires_a_value_of_type_1_5080", "Watch option '{0}' requires a value of type {1}."), Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0: t(5081, e.DiagnosticCategory.Error, "Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0_5081", "Cannot find a tsconfig.json file at the current directory: {0}."), _0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1: t(5082, e.DiagnosticCategory.Error, "_0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1_5082", "'{0}' could be instantiated with an arbitrary type which could be unrelated to '{1}'."), Cannot_read_file_0: t(5083, e.DiagnosticCategory.Error, "Cannot_read_file_0_5083", "Cannot read file '{0}'."), Tuple_members_must_all_have_names_or_all_not_have_names: t(5084, e.DiagnosticCategory.Error, "Tuple_members_must_all_have_names_or_all_not_have_names_5084", "Tuple members must all have names or all not have names."), A_tuple_member_cannot_be_both_optional_and_rest: t(5085, e.DiagnosticCategory.Error, "A_tuple_member_cannot_be_both_optional_and_rest_5085", "A tuple member cannot be both optional and rest."), A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type: t(5086, e.DiagnosticCategory.Error, "A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_c_5086", "A labeled tuple element is declared as optional with a question mark after the name and before the colon, rather than after the type."), A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type: t(5087, e.DiagnosticCategory.Error, "A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type_5087", "A labeled tuple element is declared as rest with a '...' before the name, rather than before the type."), The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialized_A_type_annotation_is_necessary: t(5088, e.DiagnosticCategory.Error, "The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialize_5088", "The inferred type of '{0}' references a type with a cyclic structure which cannot be trivially serialized. A type annotation is necessary."), Option_0_cannot_be_specified_when_option_jsx_is_1: t(5089, e.DiagnosticCategory.Error, "Option_0_cannot_be_specified_when_option_jsx_is_1_5089", "Option '{0}' cannot be specified when option 'jsx' is '{1}'."), Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash: t(5090, e.DiagnosticCategory.Error, "Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash_5090", "Non-relative paths are not allowed when 'baseUrl' is not set. Did you forget a leading './'?"), Option_preserveConstEnums_cannot_be_disabled_when_isolatedModules_is_enabled: t(5091, e.DiagnosticCategory.Error, "Option_preserveConstEnums_cannot_be_disabled_when_isolatedModules_is_enabled_5091", "Option 'preserveConstEnums' cannot be disabled when 'isolatedModules' is enabled."), The_root_value_of_a_0_file_must_be_an_object: t(5092, e.DiagnosticCategory.Error, "The_root_value_of_a_0_file_must_be_an_object_5092", "The root value of a '{0}' file must be an object."), Compiler_option_0_may_only_be_used_with_build: t(5093, e.DiagnosticCategory.Error, "Compiler_option_0_may_only_be_used_with_build_5093", "Compiler option '--{0}' may only be used with '--build'."), Compiler_option_0_may_not_be_used_with_build: t(5094, e.DiagnosticCategory.Error, "Compiler_option_0_may_not_be_used_with_build_5094", "Compiler option '--{0}' may not be used with '--build'."), Option_preserveValueImports_can_only_be_used_when_module_is_set_to_es2015_or_later: t(5095, e.DiagnosticCategory.Error, "Option_preserveValueImports_can_only_be_used_when_module_is_set_to_es2015_or_later_5095", "Option 'preserveValueImports' can only be used when 'module' is set to 'es2015' or later."), Generates_a_sourcemap_for_each_corresponding_d_ts_file: t(6e3, e.DiagnosticCategory.Message, "Generates_a_sourcemap_for_each_corresponding_d_ts_file_6000", "Generates a sourcemap for each corresponding '.d.ts' file."), Concatenate_and_emit_output_to_single_file: t(6001, e.DiagnosticCategory.Message, "Concatenate_and_emit_output_to_single_file_6001", "Concatenate and emit output to single file."), Generates_corresponding_d_ts_file: t(6002, e.DiagnosticCategory.Message, "Generates_corresponding_d_ts_file_6002", "Generates corresponding '.d.ts' file."), Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: t(6004, e.DiagnosticCategory.Message, "Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations_6004", "Specify the location where debugger should locate TypeScript files instead of source locations."), Watch_input_files: t(6005, e.DiagnosticCategory.Message, "Watch_input_files_6005", "Watch input files."), Redirect_output_structure_to_the_directory: t(6006, e.DiagnosticCategory.Message, "Redirect_output_structure_to_the_directory_6006", "Redirect output structure to the directory."), Do_not_erase_const_enum_declarations_in_generated_code: t(6007, e.DiagnosticCategory.Message, "Do_not_erase_const_enum_declarations_in_generated_code_6007", "Do not erase const enum declarations in generated code."), Do_not_emit_outputs_if_any_errors_were_reported: t(6008, e.DiagnosticCategory.Message, "Do_not_emit_outputs_if_any_errors_were_reported_6008", "Do not emit outputs if any errors were reported."), Do_not_emit_comments_to_output: t(6009, e.DiagnosticCategory.Message, "Do_not_emit_comments_to_output_6009", "Do not emit comments to output."), Do_not_emit_outputs: t(6010, e.DiagnosticCategory.Message, "Do_not_emit_outputs_6010", "Do not emit outputs."), Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typechecking: t(6011, e.DiagnosticCategory.Message, "Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typech_6011", "Allow default imports from modules with no default export. This does not affect code emit, just typechecking."), Skip_type_checking_of_declaration_files: t(6012, e.DiagnosticCategory.Message, "Skip_type_checking_of_declaration_files_6012", "Skip type checking of declaration files."), Do_not_resolve_the_real_path_of_symlinks: t(6013, e.DiagnosticCategory.Message, "Do_not_resolve_the_real_path_of_symlinks_6013", "Do not resolve the real path of symlinks."), Only_emit_d_ts_declaration_files: t(6014, e.DiagnosticCategory.Message, "Only_emit_d_ts_declaration_files_6014", "Only emit '.d.ts' declaration files."), Specify_ECMAScript_target_version: t(6015, e.DiagnosticCategory.Message, "Specify_ECMAScript_target_version_6015", "Specify ECMAScript target version."), Specify_module_code_generation: t(6016, e.DiagnosticCategory.Message, "Specify_module_code_generation_6016", "Specify module code generation."), Print_this_message: t(6017, e.DiagnosticCategory.Message, "Print_this_message_6017", "Print this message."), Print_the_compiler_s_version: t(6019, e.DiagnosticCategory.Message, "Print_the_compiler_s_version_6019", "Print the compiler's version."), Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json: t(6020, e.DiagnosticCategory.Message, "Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json_6020", "Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'."), Syntax_Colon_0: t(6023, e.DiagnosticCategory.Message, "Syntax_Colon_0_6023", "Syntax: {0}"), options: t(6024, e.DiagnosticCategory.Message, "options_6024", "options"), file: t(6025, e.DiagnosticCategory.Message, "file_6025", "file"), Examples_Colon_0: t(6026, e.DiagnosticCategory.Message, "Examples_Colon_0_6026", "Examples: {0}"), Options_Colon: t(6027, e.DiagnosticCategory.Message, "Options_Colon_6027", "Options:"), Version_0: t(6029, e.DiagnosticCategory.Message, "Version_0_6029", "Version {0}"), Insert_command_line_options_and_files_from_a_file: t(6030, e.DiagnosticCategory.Message, "Insert_command_line_options_and_files_from_a_file_6030", "Insert command line options and files from a file."), Starting_compilation_in_watch_mode: t(6031, e.DiagnosticCategory.Message, "Starting_compilation_in_watch_mode_6031", "Starting compilation in watch mode..."), File_change_detected_Starting_incremental_compilation: t(6032, e.DiagnosticCategory.Message, "File_change_detected_Starting_incremental_compilation_6032", "File change detected. Starting incremental compilation..."), KIND: t(6034, e.DiagnosticCategory.Message, "KIND_6034", "KIND"), FILE: t(6035, e.DiagnosticCategory.Message, "FILE_6035", "FILE"), VERSION: t(6036, e.DiagnosticCategory.Message, "VERSION_6036", "VERSION"), LOCATION: t(6037, e.DiagnosticCategory.Message, "LOCATION_6037", "LOCATION"), DIRECTORY: t(6038, e.DiagnosticCategory.Message, "DIRECTORY_6038", "DIRECTORY"), STRATEGY: t(6039, e.DiagnosticCategory.Message, "STRATEGY_6039", "STRATEGY"), FILE_OR_DIRECTORY: t(6040, e.DiagnosticCategory.Message, "FILE_OR_DIRECTORY_6040", "FILE OR DIRECTORY"), Errors_Files: t(6041, e.DiagnosticCategory.Message, "Errors_Files_6041", "Errors  Files"), Generates_corresponding_map_file: t(6043, e.DiagnosticCategory.Message, "Generates_corresponding_map_file_6043", "Generates corresponding '.map' file."), Compiler_option_0_expects_an_argument: t(6044, e.DiagnosticCategory.Error, "Compiler_option_0_expects_an_argument_6044", "Compiler option '{0}' expects an argument."), Unterminated_quoted_string_in_response_file_0: t(6045, e.DiagnosticCategory.Error, "Unterminated_quoted_string_in_response_file_0_6045", "Unterminated quoted string in response file '{0}'."), Argument_for_0_option_must_be_Colon_1: t(6046, e.DiagnosticCategory.Error, "Argument_for_0_option_must_be_Colon_1_6046", "Argument for '{0}' option must be: {1}."), Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: t(6048, e.DiagnosticCategory.Error, "Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1_6048", "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'."), Unable_to_open_file_0: t(6050, e.DiagnosticCategory.Error, "Unable_to_open_file_0_6050", "Unable to open file '{0}'."), Corrupted_locale_file_0: t(6051, e.DiagnosticCategory.Error, "Corrupted_locale_file_0_6051", "Corrupted locale file {0}."), Raise_error_on_expressions_and_declarations_with_an_implied_any_type: t(6052, e.DiagnosticCategory.Message, "Raise_error_on_expressions_and_declarations_with_an_implied_any_type_6052", "Raise error on expressions and declarations with an implied 'any' type."), File_0_not_found: t(6053, e.DiagnosticCategory.Error, "File_0_not_found_6053", "File '{0}' not found."), File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1: t(6054, e.DiagnosticCategory.Error, "File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1_6054", "File '{0}' has an unsupported extension. The only supported extensions are {1}."), Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures: t(6055, e.DiagnosticCategory.Message, "Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures_6055", "Suppress noImplicitAny errors for indexing objects lacking index signatures."), Do_not_emit_declarations_for_code_that_has_an_internal_annotation: t(6056, e.DiagnosticCategory.Message, "Do_not_emit_declarations_for_code_that_has_an_internal_annotation_6056", "Do not emit declarations for code that has an '@internal' annotation."), Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir: t(6058, e.DiagnosticCategory.Message, "Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir_6058", "Specify the root directory of input files. Use to control the output directory structure with --outDir."), File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files: t(6059, e.DiagnosticCategory.Error, "File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files_6059", "File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files."), Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix: t(6060, e.DiagnosticCategory.Message, "Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix_6060", "Specify the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix)."), NEWLINE: t(6061, e.DiagnosticCategory.Message, "NEWLINE_6061", "NEWLINE"), Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line: t(6064, e.DiagnosticCategory.Error, "Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line_6064", "Option '{0}' can only be specified in 'tsconfig.json' file or set to 'null' on command line."), Enables_experimental_support_for_ES7_decorators: t(6065, e.DiagnosticCategory.Message, "Enables_experimental_support_for_ES7_decorators_6065", "Enables experimental support for ES7 decorators."), Enables_experimental_support_for_emitting_type_metadata_for_decorators: t(6066, e.DiagnosticCategory.Message, "Enables_experimental_support_for_emitting_type_metadata_for_decorators_6066", "Enables experimental support for emitting type metadata for decorators."), Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6: t(6069, e.DiagnosticCategory.Message, "Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6_6069", "Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6)."), Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file: t(6070, e.DiagnosticCategory.Message, "Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file_6070", "Initializes a TypeScript project and creates a tsconfig.json file."), Successfully_created_a_tsconfig_json_file: t(6071, e.DiagnosticCategory.Message, "Successfully_created_a_tsconfig_json_file_6071", "Successfully created a tsconfig.json file."), Suppress_excess_property_checks_for_object_literals: t(6072, e.DiagnosticCategory.Message, "Suppress_excess_property_checks_for_object_literals_6072", "Suppress excess property checks for object literals."), Stylize_errors_and_messages_using_color_and_context_experimental: t(6073, e.DiagnosticCategory.Message, "Stylize_errors_and_messages_using_color_and_context_experimental_6073", "Stylize errors and messages using color and context (experimental)."), Do_not_report_errors_on_unused_labels: t(6074, e.DiagnosticCategory.Message, "Do_not_report_errors_on_unused_labels_6074", "Do not report errors on unused labels."), Report_error_when_not_all_code_paths_in_function_return_a_value: t(6075, e.DiagnosticCategory.Message, "Report_error_when_not_all_code_paths_in_function_return_a_value_6075", "Report error when not all code paths in function return a value."), Report_errors_for_fallthrough_cases_in_switch_statement: t(6076, e.DiagnosticCategory.Message, "Report_errors_for_fallthrough_cases_in_switch_statement_6076", "Report errors for fallthrough cases in switch statement."), Do_not_report_errors_on_unreachable_code: t(6077, e.DiagnosticCategory.Message, "Do_not_report_errors_on_unreachable_code_6077", "Do not report errors on unreachable code."), Disallow_inconsistently_cased_references_to_the_same_file: t(6078, e.DiagnosticCategory.Message, "Disallow_inconsistently_cased_references_to_the_same_file_6078", "Disallow inconsistently-cased references to the same file."), Specify_library_files_to_be_included_in_the_compilation: t(6079, e.DiagnosticCategory.Message, "Specify_library_files_to_be_included_in_the_compilation_6079", "Specify library files to be included in the compilation."), Specify_JSX_code_generation: t(6080, e.DiagnosticCategory.Message, "Specify_JSX_code_generation_6080", "Specify JSX code generation."), File_0_has_an_unsupported_extension_so_skipping_it: t(6081, e.DiagnosticCategory.Message, "File_0_has_an_unsupported_extension_so_skipping_it_6081", "File '{0}' has an unsupported extension, so skipping it."), Only_amd_and_system_modules_are_supported_alongside_0: t(6082, e.DiagnosticCategory.Error, "Only_amd_and_system_modules_are_supported_alongside_0_6082", "Only 'amd' and 'system' modules are supported alongside --{0}."), Base_directory_to_resolve_non_absolute_module_names: t(6083, e.DiagnosticCategory.Message, "Base_directory_to_resolve_non_absolute_module_names_6083", "Base directory to resolve non-absolute module names."), Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react_JSX_emit: t(6084, e.DiagnosticCategory.Message, "Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react__6084", "[Deprecated] Use '--jsxFactory' instead. Specify the object invoked for createElement when targeting 'react' JSX emit"), Enable_tracing_of_the_name_resolution_process: t(6085, e.DiagnosticCategory.Message, "Enable_tracing_of_the_name_resolution_process_6085", "Enable tracing of the name resolution process."), Resolving_module_0_from_1: t(6086, e.DiagnosticCategory.Message, "Resolving_module_0_from_1_6086", "======== Resolving module '{0}' from '{1}'. ========"), Explicitly_specified_module_resolution_kind_Colon_0: t(6087, e.DiagnosticCategory.Message, "Explicitly_specified_module_resolution_kind_Colon_0_6087", "Explicitly specified module resolution kind: '{0}'."), Module_resolution_kind_is_not_specified_using_0: t(6088, e.DiagnosticCategory.Message, "Module_resolution_kind_is_not_specified_using_0_6088", "Module resolution kind is not specified, using '{0}'."), Module_name_0_was_successfully_resolved_to_1: t(6089, e.DiagnosticCategory.Message, "Module_name_0_was_successfully_resolved_to_1_6089", "======== Module name '{0}' was successfully resolved to '{1}'. ========"), Module_name_0_was_not_resolved: t(6090, e.DiagnosticCategory.Message, "Module_name_0_was_not_resolved_6090", "======== Module name '{0}' was not resolved. ========"), paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0: t(6091, e.DiagnosticCategory.Message, "paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0_6091", "'paths' option is specified, looking for a pattern to match module name '{0}'."), Module_name_0_matched_pattern_1: t(6092, e.DiagnosticCategory.Message, "Module_name_0_matched_pattern_1_6092", "Module name '{0}', matched pattern '{1}'."), Trying_substitution_0_candidate_module_location_Colon_1: t(6093, e.DiagnosticCategory.Message, "Trying_substitution_0_candidate_module_location_Colon_1_6093", "Trying substitution '{0}', candidate module location: '{1}'."), Resolving_module_name_0_relative_to_base_url_1_2: t(6094, e.DiagnosticCategory.Message, "Resolving_module_name_0_relative_to_base_url_1_2_6094", "Resolving module name '{0}' relative to base url '{1}' - '{2}'."), Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1: t(6095, e.DiagnosticCategory.Message, "Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1_6095", "Loading module as file / folder, candidate module location '{0}', target file type '{1}'."), File_0_does_not_exist: t(6096, e.DiagnosticCategory.Message, "File_0_does_not_exist_6096", "File '{0}' does not exist."), File_0_exist_use_it_as_a_name_resolution_result: t(6097, e.DiagnosticCategory.Message, "File_0_exist_use_it_as_a_name_resolution_result_6097", "File '{0}' exist - use it as a name resolution result."), Loading_module_0_from_node_modules_folder_target_file_type_1: t(6098, e.DiagnosticCategory.Message, "Loading_module_0_from_node_modules_folder_target_file_type_1_6098", "Loading module '{0}' from 'node_modules' folder, target file type '{1}'."), Found_package_json_at_0: t(6099, e.DiagnosticCategory.Message, "Found_package_json_at_0_6099", "Found 'package.json' at '{0}'."), package_json_does_not_have_a_0_field: t(6100, e.DiagnosticCategory.Message, "package_json_does_not_have_a_0_field_6100", "'package.json' does not have a '{0}' field."), package_json_has_0_field_1_that_references_2: t(6101, e.DiagnosticCategory.Message, "package_json_has_0_field_1_that_references_2_6101", "'package.json' has '{0}' field '{1}' that references '{2}'."), Allow_javascript_files_to_be_compiled: t(6102, e.DiagnosticCategory.Message, "Allow_javascript_files_to_be_compiled_6102", "Allow javascript files to be compiled."), Checking_if_0_is_the_longest_matching_prefix_for_1_2: t(6104, e.DiagnosticCategory.Message, "Checking_if_0_is_the_longest_matching_prefix_for_1_2_6104", "Checking if '{0}' is the longest matching prefix for '{1}' - '{2}'."), Expected_type_of_0_field_in_package_json_to_be_1_got_2: t(6105, e.DiagnosticCategory.Message, "Expected_type_of_0_field_in_package_json_to_be_1_got_2_6105", "Expected type of '{0}' field in 'package.json' to be '{1}', got '{2}'."), baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1: t(6106, e.DiagnosticCategory.Message, "baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1_6106", "'baseUrl' option is set to '{0}', using this value to resolve non-relative module name '{1}'."), rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0: t(6107, e.DiagnosticCategory.Message, "rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0_6107", "'rootDirs' option is set, using it to resolve relative module name '{0}'."), Longest_matching_prefix_for_0_is_1: t(6108, e.DiagnosticCategory.Message, "Longest_matching_prefix_for_0_is_1_6108", "Longest matching prefix for '{0}' is '{1}'."), Loading_0_from_the_root_dir_1_candidate_location_2: t(6109, e.DiagnosticCategory.Message, "Loading_0_from_the_root_dir_1_candidate_location_2_6109", "Loading '{0}' from the root dir '{1}', candidate location '{2}'."), Trying_other_entries_in_rootDirs: t(6110, e.DiagnosticCategory.Message, "Trying_other_entries_in_rootDirs_6110", "Trying other entries in 'rootDirs'."), Module_resolution_using_rootDirs_has_failed: t(6111, e.DiagnosticCategory.Message, "Module_resolution_using_rootDirs_has_failed_6111", "Module resolution using 'rootDirs' has failed."), Do_not_emit_use_strict_directives_in_module_output: t(6112, e.DiagnosticCategory.Message, "Do_not_emit_use_strict_directives_in_module_output_6112", "Do not emit 'use strict' directives in module output."), Enable_strict_null_checks: t(6113, e.DiagnosticCategory.Message, "Enable_strict_null_checks_6113", "Enable strict null checks."), Unknown_option_excludes_Did_you_mean_exclude: t(6114, e.DiagnosticCategory.Error, "Unknown_option_excludes_Did_you_mean_exclude_6114", "Unknown option 'excludes'. Did you mean 'exclude'?"), Raise_error_on_this_expressions_with_an_implied_any_type: t(6115, e.DiagnosticCategory.Message, "Raise_error_on_this_expressions_with_an_implied_any_type_6115", "Raise error on 'this' expressions with an implied 'any' type."), Resolving_type_reference_directive_0_containing_file_1_root_directory_2: t(6116, e.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_1_root_directory_2_6116", "======== Resolving type reference directive '{0}', containing file '{1}', root directory '{2}'. ========"), Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2: t(6119, e.DiagnosticCategory.Message, "Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2_6119", "======== Type reference directive '{0}' was successfully resolved to '{1}', primary: {2}. ========"), Type_reference_directive_0_was_not_resolved: t(6120, e.DiagnosticCategory.Message, "Type_reference_directive_0_was_not_resolved_6120", "======== Type reference directive '{0}' was not resolved. ========"), Resolving_with_primary_search_path_0: t(6121, e.DiagnosticCategory.Message, "Resolving_with_primary_search_path_0_6121", "Resolving with primary search path '{0}'."), Root_directory_cannot_be_determined_skipping_primary_search_paths: t(6122, e.DiagnosticCategory.Message, "Root_directory_cannot_be_determined_skipping_primary_search_paths_6122", "Root directory cannot be determined, skipping primary search paths."), Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set: t(6123, e.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set_6123", "======== Resolving type reference directive '{0}', containing file '{1}', root directory not set. ========"), Type_declaration_files_to_be_included_in_compilation: t(6124, e.DiagnosticCategory.Message, "Type_declaration_files_to_be_included_in_compilation_6124", "Type declaration files to be included in compilation."), Looking_up_in_node_modules_folder_initial_location_0: t(6125, e.DiagnosticCategory.Message, "Looking_up_in_node_modules_folder_initial_location_0_6125", "Looking up in 'node_modules' folder, initial location '{0}'."), Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder: t(6126, e.DiagnosticCategory.Message, "Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_mod_6126", "Containing file is not specified and root directory cannot be determined, skipping lookup in 'node_modules' folder."), Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1: t(6127, e.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1_6127", "======== Resolving type reference directive '{0}', containing file not set, root directory '{1}'. ========"), Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set: t(6128, e.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set_6128", "======== Resolving type reference directive '{0}', containing file not set, root directory not set. ========"), Resolving_real_path_for_0_result_1: t(6130, e.DiagnosticCategory.Message, "Resolving_real_path_for_0_result_1_6130", "Resolving real path for '{0}', result '{1}'."), Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system: t(6131, e.DiagnosticCategory.Error, "Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system_6131", "Cannot compile modules using option '{0}' unless the '--module' flag is 'amd' or 'system'."), File_name_0_has_a_1_extension_stripping_it: t(6132, e.DiagnosticCategory.Message, "File_name_0_has_a_1_extension_stripping_it_6132", "File name '{0}' has a '{1}' extension - stripping it."), _0_is_declared_but_its_value_is_never_read: t(6133, e.DiagnosticCategory.Error, "_0_is_declared_but_its_value_is_never_read_6133", "'{0}' is declared but its value is never read.", true), Report_errors_on_unused_locals: t(6134, e.DiagnosticCategory.Message, "Report_errors_on_unused_locals_6134", "Report errors on unused locals."), Report_errors_on_unused_parameters: t(6135, e.DiagnosticCategory.Message, "Report_errors_on_unused_parameters_6135", "Report errors on unused parameters."), The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files: t(6136, e.DiagnosticCategory.Message, "The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files_6136", "The maximum dependency depth to search under node_modules and load JavaScript files."), Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1: t(6137, e.DiagnosticCategory.Error, "Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1_6137", "Cannot import type declaration files. Consider importing '{0}' instead of '{1}'."), Property_0_is_declared_but_its_value_is_never_read: t(6138, e.DiagnosticCategory.Error, "Property_0_is_declared_but_its_value_is_never_read_6138", "Property '{0}' is declared but its value is never read.", true), Import_emit_helpers_from_tslib: t(6139, e.DiagnosticCategory.Message, "Import_emit_helpers_from_tslib_6139", "Import emit helpers from 'tslib'."), Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2: t(6140, e.DiagnosticCategory.Error, "Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using__6140", "Auto discovery for typings is enabled in project '{0}'. Running extra resolution pass for module '{1}' using cache location '{2}'."), Parse_in_strict_mode_and_emit_use_strict_for_each_source_file: t(6141, e.DiagnosticCategory.Message, "Parse_in_strict_mode_and_emit_use_strict_for_each_source_file_6141", 'Parse in strict mode and emit "use strict" for each source file.'), Module_0_was_resolved_to_1_but_jsx_is_not_set: t(6142, e.DiagnosticCategory.Error, "Module_0_was_resolved_to_1_but_jsx_is_not_set_6142", "Module '{0}' was resolved to '{1}', but '--jsx' is not set."), Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1: t(6144, e.DiagnosticCategory.Message, "Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1_6144", "Module '{0}' was resolved as locally declared ambient module in file '{1}'."), Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified: t(6145, e.DiagnosticCategory.Message, "Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified_6145", "Module '{0}' was resolved as ambient module declared in '{1}' since this file was not modified."), Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h: t(6146, e.DiagnosticCategory.Message, "Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h_6146", "Specify the JSX factory function to use when targeting 'react' JSX emit, e.g. 'React.createElement' or 'h'."), Resolution_for_module_0_was_found_in_cache_from_location_1: t(6147, e.DiagnosticCategory.Message, "Resolution_for_module_0_was_found_in_cache_from_location_1_6147", "Resolution for module '{0}' was found in cache from location '{1}'."), Directory_0_does_not_exist_skipping_all_lookups_in_it: t(6148, e.DiagnosticCategory.Message, "Directory_0_does_not_exist_skipping_all_lookups_in_it_6148", "Directory '{0}' does not exist, skipping all lookups in it."), Show_diagnostic_information: t(6149, e.DiagnosticCategory.Message, "Show_diagnostic_information_6149", "Show diagnostic information."), Show_verbose_diagnostic_information: t(6150, e.DiagnosticCategory.Message, "Show_verbose_diagnostic_information_6150", "Show verbose diagnostic information."), Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file: t(6151, e.DiagnosticCategory.Message, "Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file_6151", "Emit a single file with source maps instead of having a separate file."), Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap_to_be_set: t(6152, e.DiagnosticCategory.Message, "Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap__6152", "Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set."), Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule: t(6153, e.DiagnosticCategory.Message, "Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule_6153", "Transpile each file as a separate module (similar to 'ts.transpileModule')."), Print_names_of_generated_files_part_of_the_compilation: t(6154, e.DiagnosticCategory.Message, "Print_names_of_generated_files_part_of_the_compilation_6154", "Print names of generated files part of the compilation."), Print_names_of_files_part_of_the_compilation: t(6155, e.DiagnosticCategory.Message, "Print_names_of_files_part_of_the_compilation_6155", "Print names of files part of the compilation."), The_locale_used_when_displaying_messages_to_the_user_e_g_en_us: t(6156, e.DiagnosticCategory.Message, "The_locale_used_when_displaying_messages_to_the_user_e_g_en_us_6156", "The locale used when displaying messages to the user (e.g. 'en-us')"), Do_not_generate_custom_helper_functions_like_extends_in_compiled_output: t(6157, e.DiagnosticCategory.Message, "Do_not_generate_custom_helper_functions_like_extends_in_compiled_output_6157", "Do not generate custom helper functions like '__extends' in compiled output."), Do_not_include_the_default_library_file_lib_d_ts: t(6158, e.DiagnosticCategory.Message, "Do_not_include_the_default_library_file_lib_d_ts_6158", "Do not include the default library file (lib.d.ts)."), Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files: t(6159, e.DiagnosticCategory.Message, "Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files_6159", "Do not add triple-slash references or imported modules to the list of compiled files."), Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files: t(6160, e.DiagnosticCategory.Message, "Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files_6160", "[Deprecated] Use '--skipLibCheck' instead. Skip type checking of default library declaration files."), List_of_folders_to_include_type_definitions_from: t(6161, e.DiagnosticCategory.Message, "List_of_folders_to_include_type_definitions_from_6161", "List of folders to include type definitions from."), Disable_size_limitations_on_JavaScript_projects: t(6162, e.DiagnosticCategory.Message, "Disable_size_limitations_on_JavaScript_projects_6162", "Disable size limitations on JavaScript projects."), The_character_set_of_the_input_files: t(6163, e.DiagnosticCategory.Message, "The_character_set_of_the_input_files_6163", "The character set of the input files."), Do_not_truncate_error_messages: t(6165, e.DiagnosticCategory.Message, "Do_not_truncate_error_messages_6165", "Do not truncate error messages."), Output_directory_for_generated_declaration_files: t(6166, e.DiagnosticCategory.Message, "Output_directory_for_generated_declaration_files_6166", "Output directory for generated declaration files."), A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl: t(6167, e.DiagnosticCategory.Message, "A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl_6167", "A series of entries which re-map imports to lookup locations relative to the 'baseUrl'."), List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime: t(6168, e.DiagnosticCategory.Message, "List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime_6168", "List of root folders whose combined content represents the structure of the project at runtime."), Show_all_compiler_options: t(6169, e.DiagnosticCategory.Message, "Show_all_compiler_options_6169", "Show all compiler options."), Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file: t(6170, e.DiagnosticCategory.Message, "Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file_6170", "[Deprecated] Use '--outFile' instead. Concatenate and emit output to single file"), Command_line_Options: t(6171, e.DiagnosticCategory.Message, "Command_line_Options_6171", "Command-line Options"), Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3: t(6179, e.DiagnosticCategory.Message, "Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3_6179", "Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'."), Enable_all_strict_type_checking_options: t(6180, e.DiagnosticCategory.Message, "Enable_all_strict_type_checking_options_6180", "Enable all strict type-checking options."), Scoped_package_detected_looking_in_0: t(6182, e.DiagnosticCategory.Message, "Scoped_package_detected_looking_in_0_6182", "Scoped package detected, looking in '{0}'"), Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2: t(6183, e.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_6183", "Reusing resolution of module '{0}' from '{1}' of old program, it was successfully resolved to '{2}'."), Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3: t(6184, e.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package__6184", "Reusing resolution of module '{0}' from '{1}' of old program, it was successfully resolved to '{2}' with Package ID '{3}'."), Enable_strict_checking_of_function_types: t(6186, e.DiagnosticCategory.Message, "Enable_strict_checking_of_function_types_6186", "Enable strict checking of function types."), Enable_strict_checking_of_property_initialization_in_classes: t(6187, e.DiagnosticCategory.Message, "Enable_strict_checking_of_property_initialization_in_classes_6187", "Enable strict checking of property initialization in classes."), Numeric_separators_are_not_allowed_here: t(6188, e.DiagnosticCategory.Error, "Numeric_separators_are_not_allowed_here_6188", "Numeric separators are not allowed here."), Multiple_consecutive_numeric_separators_are_not_permitted: t(6189, e.DiagnosticCategory.Error, "Multiple_consecutive_numeric_separators_are_not_permitted_6189", "Multiple consecutive numeric separators are not permitted."), Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen: t(6191, e.DiagnosticCategory.Message, "Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen_6191", "Whether to keep outdated console output in watch mode instead of clearing the screen."), All_imports_in_import_declaration_are_unused: t(6192, e.DiagnosticCategory.Error, "All_imports_in_import_declaration_are_unused_6192", "All imports in import declaration are unused.", true), Found_1_error_Watching_for_file_changes: t(6193, e.DiagnosticCategory.Message, "Found_1_error_Watching_for_file_changes_6193", "Found 1 error. Watching for file changes."), Found_0_errors_Watching_for_file_changes: t(6194, e.DiagnosticCategory.Message, "Found_0_errors_Watching_for_file_changes_6194", "Found {0} errors. Watching for file changes."), Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols: t(6195, e.DiagnosticCategory.Message, "Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols_6195", "Resolve 'keyof' to string valued property names only (no numbers or symbols)."), _0_is_declared_but_never_used: t(6196, e.DiagnosticCategory.Error, "_0_is_declared_but_never_used_6196", "'{0}' is declared but never used.", true), Include_modules_imported_with_json_extension: t(6197, e.DiagnosticCategory.Message, "Include_modules_imported_with_json_extension_6197", "Include modules imported with '.json' extension"), All_destructured_elements_are_unused: t(6198, e.DiagnosticCategory.Error, "All_destructured_elements_are_unused_6198", "All destructured elements are unused.", true), All_variables_are_unused: t(6199, e.DiagnosticCategory.Error, "All_variables_are_unused_6199", "All variables are unused.", true), Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0: t(6200, e.DiagnosticCategory.Error, "Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0_6200", "Definitions of the following identifiers conflict with those in another file: {0}"), Conflicts_are_in_this_file: t(6201, e.DiagnosticCategory.Message, "Conflicts_are_in_this_file_6201", "Conflicts are in this file."), Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0: t(6202, e.DiagnosticCategory.Error, "Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0_6202", "Project references may not form a circular graph. Cycle detected: {0}"), _0_was_also_declared_here: t(6203, e.DiagnosticCategory.Message, "_0_was_also_declared_here_6203", "'{0}' was also declared here."), and_here: t(6204, e.DiagnosticCategory.Message, "and_here_6204", "and here."), All_type_parameters_are_unused: t(6205, e.DiagnosticCategory.Error, "All_type_parameters_are_unused_6205", "All type parameters are unused."), package_json_has_a_typesVersions_field_with_version_specific_path_mappings: t(6206, e.DiagnosticCategory.Message, "package_json_has_a_typesVersions_field_with_version_specific_path_mappings_6206", "'package.json' has a 'typesVersions' field with version-specific path mappings."), package_json_does_not_have_a_typesVersions_entry_that_matches_version_0: t(6207, e.DiagnosticCategory.Message, "package_json_does_not_have_a_typesVersions_entry_that_matches_version_0_6207", "'package.json' does not have a 'typesVersions' entry that matches version '{0}'."), package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2: t(6208, e.DiagnosticCategory.Message, "package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_ma_6208", "'package.json' has a 'typesVersions' entry '{0}' that matches compiler version '{1}', looking for a pattern to match module name '{2}'."), package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range: t(6209, e.DiagnosticCategory.Message, "package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range_6209", "'package.json' has a 'typesVersions' entry '{0}' that is not a valid semver range."), An_argument_for_0_was_not_provided: t(6210, e.DiagnosticCategory.Message, "An_argument_for_0_was_not_provided_6210", "An argument for '{0}' was not provided."), An_argument_matching_this_binding_pattern_was_not_provided: t(6211, e.DiagnosticCategory.Message, "An_argument_matching_this_binding_pattern_was_not_provided_6211", "An argument matching this binding pattern was not provided."), Did_you_mean_to_call_this_expression: t(6212, e.DiagnosticCategory.Message, "Did_you_mean_to_call_this_expression_6212", "Did you mean to call this expression?"), Did_you_mean_to_use_new_with_this_expression: t(6213, e.DiagnosticCategory.Message, "Did_you_mean_to_use_new_with_this_expression_6213", "Did you mean to use 'new' with this expression?"), Enable_strict_bind_call_and_apply_methods_on_functions: t(6214, e.DiagnosticCategory.Message, "Enable_strict_bind_call_and_apply_methods_on_functions_6214", "Enable strict 'bind', 'call', and 'apply' methods on functions."), Using_compiler_options_of_project_reference_redirect_0: t(6215, e.DiagnosticCategory.Message, "Using_compiler_options_of_project_reference_redirect_0_6215", "Using compiler options of project reference redirect '{0}'."), Found_1_error: t(6216, e.DiagnosticCategory.Message, "Found_1_error_6216", "Found 1 error."), Found_0_errors: t(6217, e.DiagnosticCategory.Message, "Found_0_errors_6217", "Found {0} errors."), Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2: t(6218, e.DiagnosticCategory.Message, "Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2_6218", "======== Module name '{0}' was successfully resolved to '{1}' with Package ID '{2}'. ========"), Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3: t(6219, e.DiagnosticCategory.Message, "Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3_6219", "======== Type reference directive '{0}' was successfully resolved to '{1}' with Package ID '{2}', primary: {3}. ========"), package_json_had_a_falsy_0_field: t(6220, e.DiagnosticCategory.Message, "package_json_had_a_falsy_0_field_6220", "'package.json' had a falsy '{0}' field."), Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects: t(6221, e.DiagnosticCategory.Message, "Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects_6221", "Disable use of source files instead of declaration files from referenced projects."), Emit_class_fields_with_Define_instead_of_Set: t(6222, e.DiagnosticCategory.Message, "Emit_class_fields_with_Define_instead_of_Set_6222", "Emit class fields with Define instead of Set."), Generates_a_CPU_profile: t(6223, e.DiagnosticCategory.Message, "Generates_a_CPU_profile_6223", "Generates a CPU profile."), Disable_solution_searching_for_this_project: t(6224, e.DiagnosticCategory.Message, "Disable_solution_searching_for_this_project_6224", "Disable solution searching for this project."), Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling_UseFsEvents_UseFsEventsOnParentDirectory: t(6225, e.DiagnosticCategory.Message, "Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_Dynami_6225", "Specify strategy for watching file: 'FixedPollingInterval' (default), 'PriorityPollingInterval', 'DynamicPriorityPolling', 'FixedChunkSizePolling', 'UseFsEvents', 'UseFsEventsOnParentDirectory'."), Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively_Colon_UseFsEvents_default_FixedPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling: t(6226, e.DiagnosticCategory.Message, "Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively__6226", "Specify strategy for watching directory on platforms that don't support recursive watching natively: 'UseFsEvents' (default), 'FixedPollingInterval', 'DynamicPriorityPolling', 'FixedChunkSizePolling'."), Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_FixedInterval_default_PriorityInterval_DynamicPriority_FixedChunkSize: t(6227, e.DiagnosticCategory.Message, "Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_6227", "Specify strategy for creating a polling watch when it fails to create using file system events: 'FixedInterval' (default), 'PriorityInterval', 'DynamicPriority', 'FixedChunkSize'."), Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3: t(6229, e.DiagnosticCategory.Error, "Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3_6229", "Tag '{0}' expects at least '{1}' arguments, but the JSX factory '{2}' provides at most '{3}'."), Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line: t(6230, e.DiagnosticCategory.Error, "Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line_6230", "Option '{0}' can only be specified in 'tsconfig.json' file or set to 'false' or 'null' on command line."), Could_not_resolve_the_path_0_with_the_extensions_Colon_1: t(6231, e.DiagnosticCategory.Error, "Could_not_resolve_the_path_0_with_the_extensions_Colon_1_6231", "Could not resolve the path '{0}' with the extensions: {1}."), Declaration_augments_declaration_in_another_file_This_cannot_be_serialized: t(6232, e.DiagnosticCategory.Error, "Declaration_augments_declaration_in_another_file_This_cannot_be_serialized_6232", "Declaration augments declaration in another file. This cannot be serialized."), This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_file: t(6233, e.DiagnosticCategory.Error, "This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_fil_6233", "This is the declaration being augmented. Consider moving the augmenting declaration into the same file."), This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without: t(6234, e.DiagnosticCategory.Error, "This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without_6234", "This expression is not callable because it is a 'get' accessor. Did you mean to use it without '()'?"), Disable_loading_referenced_projects: t(6235, e.DiagnosticCategory.Message, "Disable_loading_referenced_projects_6235", "Disable loading referenced projects."), Arguments_for_the_rest_parameter_0_were_not_provided: t(6236, e.DiagnosticCategory.Error, "Arguments_for_the_rest_parameter_0_were_not_provided_6236", "Arguments for the rest parameter '{0}' were not provided."), Generates_an_event_trace_and_a_list_of_types: t(6237, e.DiagnosticCategory.Message, "Generates_an_event_trace_and_a_list_of_types_6237", "Generates an event trace and a list of types."), Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react: t(6238, e.DiagnosticCategory.Error, "Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react_6238", "Specify the module specifier to be used to import the 'jsx' and 'jsxs' factory functions from. eg, react"), File_0_exists_according_to_earlier_cached_lookups: t(6239, e.DiagnosticCategory.Message, "File_0_exists_according_to_earlier_cached_lookups_6239", "File '{0}' exists according to earlier cached lookups."), File_0_does_not_exist_according_to_earlier_cached_lookups: t(6240, e.DiagnosticCategory.Message, "File_0_does_not_exist_according_to_earlier_cached_lookups_6240", "File '{0}' does not exist according to earlier cached lookups."), Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1: t(6241, e.DiagnosticCategory.Message, "Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1_6241", "Resolution for type reference directive '{0}' was found in cache from location '{1}'."), Resolving_type_reference_directive_0_containing_file_1: t(6242, e.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_1_6242", "======== Resolving type reference directive '{0}', containing file '{1}'. ========"), Interpret_optional_property_types_as_written_rather_than_adding_undefined: t(6243, e.DiagnosticCategory.Message, "Interpret_optional_property_types_as_written_rather_than_adding_undefined_6243", "Interpret optional property types as written, rather than adding 'undefined'."), Modules: t(6244, e.DiagnosticCategory.Message, "Modules_6244", "Modules"), File_Management: t(6245, e.DiagnosticCategory.Message, "File_Management_6245", "File Management"), Emit: t(6246, e.DiagnosticCategory.Message, "Emit_6246", "Emit"), JavaScript_Support: t(6247, e.DiagnosticCategory.Message, "JavaScript_Support_6247", "JavaScript Support"), Type_Checking: t(6248, e.DiagnosticCategory.Message, "Type_Checking_6248", "Type Checking"), Editor_Support: t(6249, e.DiagnosticCategory.Message, "Editor_Support_6249", "Editor Support"), Watch_and_Build_Modes: t(6250, e.DiagnosticCategory.Message, "Watch_and_Build_Modes_6250", "Watch and Build Modes"), Compiler_Diagnostics: t(6251, e.DiagnosticCategory.Message, "Compiler_Diagnostics_6251", "Compiler Diagnostics"), Interop_Constraints: t(6252, e.DiagnosticCategory.Message, "Interop_Constraints_6252", "Interop Constraints"), Backwards_Compatibility: t(6253, e.DiagnosticCategory.Message, "Backwards_Compatibility_6253", "Backwards Compatibility"), Language_and_Environment: t(6254, e.DiagnosticCategory.Message, "Language_and_Environment_6254", "Language and Environment"), Projects: t(6255, e.DiagnosticCategory.Message, "Projects_6255", "Projects"), Output_Formatting: t(6256, e.DiagnosticCategory.Message, "Output_Formatting_6256", "Output Formatting"), Completeness: t(6257, e.DiagnosticCategory.Message, "Completeness_6257", "Completeness"), _0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file: t(6258, e.DiagnosticCategory.Error, "_0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file_6258", "'{0}' should be set inside the 'compilerOptions' object of the config json file"), Found_1_error_in_1: t(6259, e.DiagnosticCategory.Message, "Found_1_error_in_1_6259", "Found 1 error in {1}"), Found_0_errors_in_the_same_file_starting_at_Colon_1: t(6260, e.DiagnosticCategory.Message, "Found_0_errors_in_the_same_file_starting_at_Colon_1_6260", "Found {0} errors in the same file, starting at: {1}"), Found_0_errors_in_1_files: t(6261, e.DiagnosticCategory.Message, "Found_0_errors_in_1_files_6261", "Found {0} errors in {1} files."), Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve: t(6270, e.DiagnosticCategory.Message, "Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve_6270", "Directory '{0}' has no containing package.json scope. Imports will not resolve."), Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1: t(6271, e.DiagnosticCategory.Message, "Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1_6271", "Import specifier '{0}' does not exist in package.json scope at path '{1}'."), Invalid_import_specifier_0_has_no_possible_resolutions: t(6272, e.DiagnosticCategory.Message, "Invalid_import_specifier_0_has_no_possible_resolutions_6272", "Invalid import specifier '{0}' has no possible resolutions."), package_json_scope_0_has_no_imports_defined: t(6273, e.DiagnosticCategory.Message, "package_json_scope_0_has_no_imports_defined_6273", "package.json scope '{0}' has no imports defined."), package_json_scope_0_explicitly_maps_specifier_1_to_null: t(6274, e.DiagnosticCategory.Message, "package_json_scope_0_explicitly_maps_specifier_1_to_null_6274", "package.json scope '{0}' explicitly maps specifier '{1}' to null."), package_json_scope_0_has_invalid_type_for_target_of_specifier_1: t(6275, e.DiagnosticCategory.Message, "package_json_scope_0_has_invalid_type_for_target_of_specifier_1_6275", "package.json scope '{0}' has invalid type for target of specifier '{1}'"), Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1: t(6276, e.DiagnosticCategory.Message, "Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1_6276", "Export specifier '{0}' does not exist in package.json scope at path '{1}'."), Enable_project_compilation: t(6302, e.DiagnosticCategory.Message, "Enable_project_compilation_6302", "Enable project compilation"), Composite_projects_may_not_disable_declaration_emit: t(6304, e.DiagnosticCategory.Error, "Composite_projects_may_not_disable_declaration_emit_6304", "Composite projects may not disable declaration emit."), Output_file_0_has_not_been_built_from_source_file_1: t(6305, e.DiagnosticCategory.Error, "Output_file_0_has_not_been_built_from_source_file_1_6305", "Output file '{0}' has not been built from source file '{1}'."), Referenced_project_0_must_have_setting_composite_Colon_true: t(6306, e.DiagnosticCategory.Error, "Referenced_project_0_must_have_setting_composite_Colon_true_6306", `Referenced project '{0}' must have setting "composite": true.`), File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_include_pattern: t(6307, e.DiagnosticCategory.Error, "File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_includ_6307", "File '{0}' is not listed within the file list of project '{1}'. Projects must list all files or use an 'include' pattern."), Cannot_prepend_project_0_because_it_does_not_have_outFile_set: t(6308, e.DiagnosticCategory.Error, "Cannot_prepend_project_0_because_it_does_not_have_outFile_set_6308", "Cannot prepend project '{0}' because it does not have 'outFile' set"), Output_file_0_from_project_1_does_not_exist: t(6309, e.DiagnosticCategory.Error, "Output_file_0_from_project_1_does_not_exist_6309", "Output file '{0}' from project '{1}' does not exist"), Referenced_project_0_may_not_disable_emit: t(6310, e.DiagnosticCategory.Error, "Referenced_project_0_may_not_disable_emit_6310", "Referenced project '{0}' may not disable emit."), Project_0_is_out_of_date_because_output_1_is_older_than_input_2: t(6350, e.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_output_1_is_older_than_input_2_6350", "Project '{0}' is out of date because output '{1}' is older than input '{2}'"), Project_0_is_up_to_date_because_newest_input_1_is_older_than_output_2: t(6351, e.DiagnosticCategory.Message, "Project_0_is_up_to_date_because_newest_input_1_is_older_than_output_2_6351", "Project '{0}' is up to date because newest input '{1}' is older than output '{2}'"), Project_0_is_out_of_date_because_output_file_1_does_not_exist: t(6352, e.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_output_file_1_does_not_exist_6352", "Project '{0}' is out of date because output file '{1}' does not exist"), Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date: t(6353, e.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date_6353", "Project '{0}' is out of date because its dependency '{1}' is out of date"), Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies: t(6354, e.DiagnosticCategory.Message, "Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies_6354", "Project '{0}' is up to date with .d.ts files from its dependencies"), Projects_in_this_build_Colon_0: t(6355, e.DiagnosticCategory.Message, "Projects_in_this_build_Colon_0_6355", "Projects in this build: {0}"), A_non_dry_build_would_delete_the_following_files_Colon_0: t(6356, e.DiagnosticCategory.Message, "A_non_dry_build_would_delete_the_following_files_Colon_0_6356", "A non-dry build would delete the following files: {0}"), A_non_dry_build_would_build_project_0: t(6357, e.DiagnosticCategory.Message, "A_non_dry_build_would_build_project_0_6357", "A non-dry build would build project '{0}'"), Building_project_0: t(6358, e.DiagnosticCategory.Message, "Building_project_0_6358", "Building project '{0}'..."), Updating_output_timestamps_of_project_0: t(6359, e.DiagnosticCategory.Message, "Updating_output_timestamps_of_project_0_6359", "Updating output timestamps of project '{0}'..."), Project_0_is_up_to_date: t(6361, e.DiagnosticCategory.Message, "Project_0_is_up_to_date_6361", "Project '{0}' is up to date"), Skipping_build_of_project_0_because_its_dependency_1_has_errors: t(6362, e.DiagnosticCategory.Message, "Skipping_build_of_project_0_because_its_dependency_1_has_errors_6362", "Skipping build of project '{0}' because its dependency '{1}' has errors"), Project_0_can_t_be_built_because_its_dependency_1_has_errors: t(6363, e.DiagnosticCategory.Message, "Project_0_can_t_be_built_because_its_dependency_1_has_errors_6363", "Project '{0}' can't be built because its dependency '{1}' has errors"), Build_one_or_more_projects_and_their_dependencies_if_out_of_date: t(6364, e.DiagnosticCategory.Message, "Build_one_or_more_projects_and_their_dependencies_if_out_of_date_6364", "Build one or more projects and their dependencies, if out of date"), Delete_the_outputs_of_all_projects: t(6365, e.DiagnosticCategory.Message, "Delete_the_outputs_of_all_projects_6365", "Delete the outputs of all projects."), Show_what_would_be_built_or_deleted_if_specified_with_clean: t(6367, e.DiagnosticCategory.Message, "Show_what_would_be_built_or_deleted_if_specified_with_clean_6367", "Show what would be built (or deleted, if specified with '--clean')"), Option_build_must_be_the_first_command_line_argument: t(6369, e.DiagnosticCategory.Error, "Option_build_must_be_the_first_command_line_argument_6369", "Option '--build' must be the first command line argument."), Options_0_and_1_cannot_be_combined: t(6370, e.DiagnosticCategory.Error, "Options_0_and_1_cannot_be_combined_6370", "Options '{0}' and '{1}' cannot be combined."), Updating_unchanged_output_timestamps_of_project_0: t(6371, e.DiagnosticCategory.Message, "Updating_unchanged_output_timestamps_of_project_0_6371", "Updating unchanged output timestamps of project '{0}'..."), Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed: t(6372, e.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed_6372", "Project '{0}' is out of date because output of its dependency '{1}' has changed"), Updating_output_of_project_0: t(6373, e.DiagnosticCategory.Message, "Updating_output_of_project_0_6373", "Updating output of project '{0}'..."), A_non_dry_build_would_update_timestamps_for_output_of_project_0: t(6374, e.DiagnosticCategory.Message, "A_non_dry_build_would_update_timestamps_for_output_of_project_0_6374", "A non-dry build would update timestamps for output of project '{0}'"), A_non_dry_build_would_update_output_of_project_0: t(6375, e.DiagnosticCategory.Message, "A_non_dry_build_would_update_output_of_project_0_6375", "A non-dry build would update output of project '{0}'"), Cannot_update_output_of_project_0_because_there_was_error_reading_file_1: t(6376, e.DiagnosticCategory.Message, "Cannot_update_output_of_project_0_because_there_was_error_reading_file_1_6376", "Cannot update output of project '{0}' because there was error reading file '{1}'"), Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1: t(6377, e.DiagnosticCategory.Error, "Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1_6377", "Cannot write file '{0}' because it will overwrite '.tsbuildinfo' file generated by referenced project '{1}'"), Composite_projects_may_not_disable_incremental_compilation: t(6379, e.DiagnosticCategory.Error, "Composite_projects_may_not_disable_incremental_compilation_6379", "Composite projects may not disable incremental compilation."), Specify_file_to_store_incremental_compilation_information: t(6380, e.DiagnosticCategory.Message, "Specify_file_to_store_incremental_compilation_information_6380", "Specify file to store incremental compilation information"), Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_current_version_2: t(6381, e.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_curren_6381", "Project '{0}' is out of date because output for it was generated with version '{1}' that differs with current version '{2}'"), Skipping_build_of_project_0_because_its_dependency_1_was_not_built: t(6382, e.DiagnosticCategory.Message, "Skipping_build_of_project_0_because_its_dependency_1_was_not_built_6382", "Skipping build of project '{0}' because its dependency '{1}' was not built"), Project_0_can_t_be_built_because_its_dependency_1_was_not_built: t(6383, e.DiagnosticCategory.Message, "Project_0_can_t_be_built_because_its_dependency_1_was_not_built_6383", "Project '{0}' can't be built because its dependency '{1}' was not built"), Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it: t(6384, e.DiagnosticCategory.Message, "Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_di_6384", "Have recompiles in '--incremental' and '--watch' assume that changes within a file will only affect files directly depending on it."), _0_is_deprecated: t(6385, e.DiagnosticCategory.Suggestion, "_0_is_deprecated_6385", "'{0}' is deprecated.", void 0, void 0, true), Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_native_implementation_of_the_Web_Performance_API_could_not_be_found: t(6386, e.DiagnosticCategory.Message, "Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_nativ_6386", "Performance timings for '--diagnostics' or '--extendedDiagnostics' are not available in this session. A native implementation of the Web Performance API could not be found."), The_signature_0_of_1_is_deprecated: t(6387, e.DiagnosticCategory.Suggestion, "The_signature_0_of_1_is_deprecated_6387", "The signature '{0}' of '{1}' is deprecated.", void 0, void 0, true), Project_0_is_being_forcibly_rebuilt: t(6388, e.DiagnosticCategory.Message, "Project_0_is_being_forcibly_rebuilt_6388", "Project '{0}' is being forcibly rebuilt"), Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved: t(6389, e.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved_6389", "Reusing resolution of module '{0}' from '{1}' of old program, it was not resolved."), Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2: t(6390, e.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved__6390", "Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was successfully resolved to '{2}'."), Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3: t(6391, e.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved__6391", "Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was successfully resolved to '{2}' with Package ID '{3}'."), Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved: t(6392, e.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved_6392", "Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was not resolved."), Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3: t(6393, e.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_6393", "Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}'."), Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4: t(6394, e.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_6394", "Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}' with Package ID '{4}'."), Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved: t(6395, e.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved_6395", "Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was not resolved."), Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3: t(6396, e.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_succes_6396", "Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}'."), Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4: t(6397, e.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_succes_6397", "Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}' with Package ID '{4}'."), Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_resolved: t(6398, e.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_re_6398", "Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was not resolved."), Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_some_of_the_changes_were_not_emitted: t(6399, e.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_some_of_the_changes_were_not_emitte_6399", "Project '{0}' is out of date because buildinfo file '{1}' indicates that some of the changes were not emitted"), Project_0_is_up_to_date_but_needs_to_update_timestamps_of_output_files_that_are_older_than_input_files: t(6400, e.DiagnosticCategory.Message, "Project_0_is_up_to_date_but_needs_to_update_timestamps_of_output_files_that_are_older_than_input_fil_6400", "Project '{0}' is up to date but needs to update timestamps of output files that are older than input files"), Project_0_is_out_of_date_because_there_was_error_reading_file_1: t(6401, e.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_there_was_error_reading_file_1_6401", "Project '{0}' is out of date because there was error reading file '{1}'"), Resolving_in_0_mode_with_conditions_1: t(6402, e.DiagnosticCategory.Message, "Resolving_in_0_mode_with_conditions_1_6402", "Resolving in {0} mode with conditions {1}."), Matched_0_condition_1: t(6403, e.DiagnosticCategory.Message, "Matched_0_condition_1_6403", "Matched '{0}' condition '{1}'."), Using_0_subpath_1_with_target_2: t(6404, e.DiagnosticCategory.Message, "Using_0_subpath_1_with_target_2_6404", "Using '{0}' subpath '{1}' with target '{2}'."), Saw_non_matching_condition_0: t(6405, e.DiagnosticCategory.Message, "Saw_non_matching_condition_0_6405", "Saw non-matching condition '{0}'."), The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1: t(6500, e.DiagnosticCategory.Message, "The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1_6500", "The expected type comes from property '{0}' which is declared here on type '{1}'"), The_expected_type_comes_from_this_index_signature: t(6501, e.DiagnosticCategory.Message, "The_expected_type_comes_from_this_index_signature_6501", "The expected type comes from this index signature."), The_expected_type_comes_from_the_return_type_of_this_signature: t(6502, e.DiagnosticCategory.Message, "The_expected_type_comes_from_the_return_type_of_this_signature_6502", "The expected type comes from the return type of this signature."), Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing: t(6503, e.DiagnosticCategory.Message, "Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing_6503", "Print names of files that are part of the compilation and then stop processing."), File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option: t(6504, e.DiagnosticCategory.Error, "File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option_6504", "File '{0}' is a JavaScript file. Did you mean to enable the 'allowJs' option?"), Print_names_of_files_and_the_reason_they_are_part_of_the_compilation: t(6505, e.DiagnosticCategory.Message, "Print_names_of_files_and_the_reason_they_are_part_of_the_compilation_6505", "Print names of files and the reason they are part of the compilation."), Consider_adding_a_declare_modifier_to_this_class: t(6506, e.DiagnosticCategory.Message, "Consider_adding_a_declare_modifier_to_this_class_6506", "Consider adding a 'declare' modifier to this class."), Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these_files: t(6600, e.DiagnosticCategory.Message, "Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these__6600", "Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files."), Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export: t(6601, e.DiagnosticCategory.Message, "Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export_6601", "Allow 'import x from y' when a module doesn't have a default export."), Allow_accessing_UMD_globals_from_modules: t(6602, e.DiagnosticCategory.Message, "Allow_accessing_UMD_globals_from_modules_6602", "Allow accessing UMD globals from modules."), Disable_error_reporting_for_unreachable_code: t(6603, e.DiagnosticCategory.Message, "Disable_error_reporting_for_unreachable_code_6603", "Disable error reporting for unreachable code."), Disable_error_reporting_for_unused_labels: t(6604, e.DiagnosticCategory.Message, "Disable_error_reporting_for_unused_labels_6604", "Disable error reporting for unused labels."), Ensure_use_strict_is_always_emitted: t(6605, e.DiagnosticCategory.Message, "Ensure_use_strict_is_always_emitted_6605", "Ensure 'use strict' is always emitted."), Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it: t(6606, e.DiagnosticCategory.Message, "Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_wi_6606", "Have recompiles in projects that use 'incremental' and 'watch' mode assume that changes within a file will only affect files directly depending on it."), Specify_the_base_directory_to_resolve_non_relative_module_names: t(6607, e.DiagnosticCategory.Message, "Specify_the_base_directory_to_resolve_non_relative_module_names_6607", "Specify the base directory to resolve non-relative module names."), No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files: t(6608, e.DiagnosticCategory.Message, "No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files_6608", "No longer supported. In early versions, manually set the text encoding for reading files."), Enable_error_reporting_in_type_checked_JavaScript_files: t(6609, e.DiagnosticCategory.Message, "Enable_error_reporting_in_type_checked_JavaScript_files_6609", "Enable error reporting in type-checked JavaScript files."), Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references: t(6611, e.DiagnosticCategory.Message, "Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references_6611", "Enable constraints that allow a TypeScript project to be used with project references."), Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project: t(6612, e.DiagnosticCategory.Message, "Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project_6612", "Generate .d.ts files from TypeScript and JavaScript files in your project."), Specify_the_output_directory_for_generated_declaration_files: t(6613, e.DiagnosticCategory.Message, "Specify_the_output_directory_for_generated_declaration_files_6613", "Specify the output directory for generated declaration files."), Create_sourcemaps_for_d_ts_files: t(6614, e.DiagnosticCategory.Message, "Create_sourcemaps_for_d_ts_files_6614", "Create sourcemaps for d.ts files."), Output_compiler_performance_information_after_building: t(6615, e.DiagnosticCategory.Message, "Output_compiler_performance_information_after_building_6615", "Output compiler performance information after building."), Disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project: t(6616, e.DiagnosticCategory.Message, "Disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project_6616", "Disables inference for type acquisition by looking at filenames in a project."), Reduce_the_number_of_projects_loaded_automatically_by_TypeScript: t(6617, e.DiagnosticCategory.Message, "Reduce_the_number_of_projects_loaded_automatically_by_TypeScript_6617", "Reduce the number of projects loaded automatically by TypeScript."), Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server: t(6618, e.DiagnosticCategory.Message, "Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server_6618", "Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server."), Opt_a_project_out_of_multi_project_reference_checking_when_editing: t(6619, e.DiagnosticCategory.Message, "Opt_a_project_out_of_multi_project_reference_checking_when_editing_6619", "Opt a project out of multi-project reference checking when editing."), Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects: t(6620, e.DiagnosticCategory.Message, "Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects_6620", "Disable preferring source files instead of declaration files when referencing composite projects."), Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration: t(6621, e.DiagnosticCategory.Message, "Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration_6621", "Emit more compliant, but verbose and less performant JavaScript for iteration."), Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files: t(6622, e.DiagnosticCategory.Message, "Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files_6622", "Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files."), Only_output_d_ts_files_and_not_JavaScript_files: t(6623, e.DiagnosticCategory.Message, "Only_output_d_ts_files_and_not_JavaScript_files_6623", "Only output d.ts files and not JavaScript files."), Emit_design_type_metadata_for_decorated_declarations_in_source_files: t(6624, e.DiagnosticCategory.Message, "Emit_design_type_metadata_for_decorated_declarations_in_source_files_6624", "Emit design-type metadata for decorated declarations in source files."), Disable_the_type_acquisition_for_JavaScript_projects: t(6625, e.DiagnosticCategory.Message, "Disable_the_type_acquisition_for_JavaScript_projects_6625", "Disable the type acquisition for JavaScript projects"), Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheticDefaultImports_for_type_compatibility: t(6626, e.DiagnosticCategory.Message, "Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheti_6626", "Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility."), Filters_results_from_the_include_option: t(6627, e.DiagnosticCategory.Message, "Filters_results_from_the_include_option_6627", "Filters results from the `include` option."), Remove_a_list_of_directories_from_the_watch_process: t(6628, e.DiagnosticCategory.Message, "Remove_a_list_of_directories_from_the_watch_process_6628", "Remove a list of directories from the watch process."), Remove_a_list_of_files_from_the_watch_mode_s_processing: t(6629, e.DiagnosticCategory.Message, "Remove_a_list_of_files_from_the_watch_mode_s_processing_6629", "Remove a list of files from the watch mode's processing."), Enable_experimental_support_for_TC39_stage_2_draft_decorators: t(6630, e.DiagnosticCategory.Message, "Enable_experimental_support_for_TC39_stage_2_draft_decorators_6630", "Enable experimental support for TC39 stage 2 draft decorators."), Print_files_read_during_the_compilation_including_why_it_was_included: t(6631, e.DiagnosticCategory.Message, "Print_files_read_during_the_compilation_including_why_it_was_included_6631", "Print files read during the compilation including why it was included."), Output_more_detailed_compiler_performance_information_after_building: t(6632, e.DiagnosticCategory.Message, "Output_more_detailed_compiler_performance_information_after_building_6632", "Output more detailed compiler performance information after building."), Specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_are_inherited: t(6633, e.DiagnosticCategory.Message, "Specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_a_6633", "Specify one or more path or node module references to base configuration files from which settings are inherited."), Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers: t(6634, e.DiagnosticCategory.Message, "Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers_6634", "Specify what approach the watcher should use if the system runs out of native file watchers."), Include_a_list_of_files_This_does_not_support_glob_patterns_as_opposed_to_include: t(6635, e.DiagnosticCategory.Message, "Include_a_list_of_files_This_does_not_support_glob_patterns_as_opposed_to_include_6635", "Include a list of files. This does not support glob patterns, as opposed to `include`."), Build_all_projects_including_those_that_appear_to_be_up_to_date: t(6636, e.DiagnosticCategory.Message, "Build_all_projects_including_those_that_appear_to_be_up_to_date_6636", "Build all projects, including those that appear to be up to date."), Ensure_that_casing_is_correct_in_imports: t(6637, e.DiagnosticCategory.Message, "Ensure_that_casing_is_correct_in_imports_6637", "Ensure that casing is correct in imports."), Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging: t(6638, e.DiagnosticCategory.Message, "Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging_6638", "Emit a v8 CPU profile of the compiler run for debugging."), Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file: t(6639, e.DiagnosticCategory.Message, "Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file_6639", "Allow importing helper functions from tslib once per project, instead of including them per-file."), Specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation: t(6641, e.DiagnosticCategory.Message, "Specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation_6641", "Specify a list of glob patterns that match files to be included in compilation."), Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects: t(6642, e.DiagnosticCategory.Message, "Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects_6642", "Save .tsbuildinfo files to allow for incremental compilation of projects."), Include_sourcemap_files_inside_the_emitted_JavaScript: t(6643, e.DiagnosticCategory.Message, "Include_sourcemap_files_inside_the_emitted_JavaScript_6643", "Include sourcemap files inside the emitted JavaScript."), Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript: t(6644, e.DiagnosticCategory.Message, "Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript_6644", "Include source code in the sourcemaps inside the emitted JavaScript."), Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports: t(6645, e.DiagnosticCategory.Message, "Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports_6645", "Ensure that each file can be safely transpiled without relying on other imports."), Specify_what_JSX_code_is_generated: t(6646, e.DiagnosticCategory.Message, "Specify_what_JSX_code_is_generated_6646", "Specify what JSX code is generated."), Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h: t(6647, e.DiagnosticCategory.Message, "Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h_6647", "Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'."), Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragment_or_Fragment: t(6648, e.DiagnosticCategory.Message, "Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragme_6648", "Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'."), Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Asterisk: t(6649, e.DiagnosticCategory.Message, "Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Ast_6649", "Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'."), Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option: t(6650, e.DiagnosticCategory.Message, "Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option_6650", "Make keyof only return strings instead of string, numbers or symbols. Legacy option."), Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment: t(6651, e.DiagnosticCategory.Message, "Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment_6651", "Specify a set of bundled library declaration files that describe the target runtime environment."), Print_the_names_of_emitted_files_after_a_compilation: t(6652, e.DiagnosticCategory.Message, "Print_the_names_of_emitted_files_after_a_compilation_6652", "Print the names of emitted files after a compilation."), Print_all_of_the_files_read_during_the_compilation: t(6653, e.DiagnosticCategory.Message, "Print_all_of_the_files_read_during_the_compilation_6653", "Print all of the files read during the compilation."), Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit: t(6654, e.DiagnosticCategory.Message, "Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit_6654", "Set the language of the messaging from TypeScript. This does not affect emit."), Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: t(6655, e.DiagnosticCategory.Message, "Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations_6655", "Specify the location where debugger should locate map files instead of generated locations."), Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicable_with_allowJs: t(6656, e.DiagnosticCategory.Message, "Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicabl_6656", "Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'."), Specify_what_module_code_is_generated: t(6657, e.DiagnosticCategory.Message, "Specify_what_module_code_is_generated_6657", "Specify what module code is generated."), Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier: t(6658, e.DiagnosticCategory.Message, "Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier_6658", "Specify how TypeScript looks up a file from a given module specifier."), Set_the_newline_character_for_emitting_files: t(6659, e.DiagnosticCategory.Message, "Set_the_newline_character_for_emitting_files_6659", "Set the newline character for emitting files."), Disable_emitting_files_from_a_compilation: t(6660, e.DiagnosticCategory.Message, "Disable_emitting_files_from_a_compilation_6660", "Disable emitting files from a compilation."), Disable_generating_custom_helper_functions_like_extends_in_compiled_output: t(6661, e.DiagnosticCategory.Message, "Disable_generating_custom_helper_functions_like_extends_in_compiled_output_6661", "Disable generating custom helper functions like '__extends' in compiled output."), Disable_emitting_files_if_any_type_checking_errors_are_reported: t(6662, e.DiagnosticCategory.Message, "Disable_emitting_files_if_any_type_checking_errors_are_reported_6662", "Disable emitting files if any type checking errors are reported."), Disable_truncating_types_in_error_messages: t(6663, e.DiagnosticCategory.Message, "Disable_truncating_types_in_error_messages_6663", "Disable truncating types in error messages."), Enable_error_reporting_for_fallthrough_cases_in_switch_statements: t(6664, e.DiagnosticCategory.Message, "Enable_error_reporting_for_fallthrough_cases_in_switch_statements_6664", "Enable error reporting for fallthrough cases in switch statements."), Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type: t(6665, e.DiagnosticCategory.Message, "Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type_6665", "Enable error reporting for expressions and declarations with an implied 'any' type."), Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier: t(6666, e.DiagnosticCategory.Message, "Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier_6666", "Ensure overriding members in derived classes are marked with an override modifier."), Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function: t(6667, e.DiagnosticCategory.Message, "Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function_6667", "Enable error reporting for codepaths that do not explicitly return in a function."), Enable_error_reporting_when_this_is_given_the_type_any: t(6668, e.DiagnosticCategory.Message, "Enable_error_reporting_when_this_is_given_the_type_any_6668", "Enable error reporting when 'this' is given the type 'any'."), Disable_adding_use_strict_directives_in_emitted_JavaScript_files: t(6669, e.DiagnosticCategory.Message, "Disable_adding_use_strict_directives_in_emitted_JavaScript_files_6669", "Disable adding 'use strict' directives in emitted JavaScript files."), Disable_including_any_library_files_including_the_default_lib_d_ts: t(6670, e.DiagnosticCategory.Message, "Disable_including_any_library_files_including_the_default_lib_d_ts_6670", "Disable including any library files, including the default lib.d.ts."), Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type: t(6671, e.DiagnosticCategory.Message, "Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type_6671", "Enforces using indexed accessors for keys declared using an indexed type."), Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add_to_a_project: t(6672, e.DiagnosticCategory.Message, "Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add__6672", "Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project."), Disable_strict_checking_of_generic_signatures_in_function_types: t(6673, e.DiagnosticCategory.Message, "Disable_strict_checking_of_generic_signatures_in_function_types_6673", "Disable strict checking of generic signatures in function types."), Add_undefined_to_a_type_when_accessed_using_an_index: t(6674, e.DiagnosticCategory.Message, "Add_undefined_to_a_type_when_accessed_using_an_index_6674", "Add 'undefined' to a type when accessed using an index."), Enable_error_reporting_when_local_variables_aren_t_read: t(6675, e.DiagnosticCategory.Message, "Enable_error_reporting_when_local_variables_aren_t_read_6675", "Enable error reporting when local variables aren't read."), Raise_an_error_when_a_function_parameter_isn_t_read: t(6676, e.DiagnosticCategory.Message, "Raise_an_error_when_a_function_parameter_isn_t_read_6676", "Raise an error when a function parameter isn't read."), Deprecated_setting_Use_outFile_instead: t(6677, e.DiagnosticCategory.Message, "Deprecated_setting_Use_outFile_instead_6677", "Deprecated setting. Use 'outFile' instead."), Specify_an_output_folder_for_all_emitted_files: t(6678, e.DiagnosticCategory.Message, "Specify_an_output_folder_for_all_emitted_files_6678", "Specify an output folder for all emitted files."), Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designates_a_file_that_bundles_all_d_ts_output: t(6679, e.DiagnosticCategory.Message, "Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designa_6679", "Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output."), Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations: t(6680, e.DiagnosticCategory.Message, "Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations_6680", "Specify a set of entries that re-map imports to additional lookup locations."), Specify_a_list_of_language_service_plugins_to_include: t(6681, e.DiagnosticCategory.Message, "Specify_a_list_of_language_service_plugins_to_include_6681", "Specify a list of language service plugins to include."), Disable_erasing_const_enum_declarations_in_generated_code: t(6682, e.DiagnosticCategory.Message, "Disable_erasing_const_enum_declarations_in_generated_code_6682", "Disable erasing 'const enum' declarations in generated code."), Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node: t(6683, e.DiagnosticCategory.Message, "Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node_6683", "Disable resolving symlinks to their realpath. This correlates to the same flag in node."), Disable_wiping_the_console_in_watch_mode: t(6684, e.DiagnosticCategory.Message, "Disable_wiping_the_console_in_watch_mode_6684", "Disable wiping the console in watch mode."), Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read: t(6685, e.DiagnosticCategory.Message, "Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read_6685", "Enable color and formatting in TypeScript's output to make compiler errors easier to read."), Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit: t(6686, e.DiagnosticCategory.Message, "Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit_6686", "Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit."), Specify_an_array_of_objects_that_specify_paths_for_projects_Used_in_project_references: t(6687, e.DiagnosticCategory.Message, "Specify_an_array_of_objects_that_specify_paths_for_projects_Used_in_project_references_6687", "Specify an array of objects that specify paths for projects. Used in project references."), Disable_emitting_comments: t(6688, e.DiagnosticCategory.Message, "Disable_emitting_comments_6688", "Disable emitting comments."), Enable_importing_json_files: t(6689, e.DiagnosticCategory.Message, "Enable_importing_json_files_6689", "Enable importing .json files."), Specify_the_root_folder_within_your_source_files: t(6690, e.DiagnosticCategory.Message, "Specify_the_root_folder_within_your_source_files_6690", "Specify the root folder within your source files."), Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules: t(6691, e.DiagnosticCategory.Message, "Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules_6691", "Allow multiple folders to be treated as one when resolving modules."), Skip_type_checking_d_ts_files_that_are_included_with_TypeScript: t(6692, e.DiagnosticCategory.Message, "Skip_type_checking_d_ts_files_that_are_included_with_TypeScript_6692", "Skip type checking .d.ts files that are included with TypeScript."), Skip_type_checking_all_d_ts_files: t(6693, e.DiagnosticCategory.Message, "Skip_type_checking_all_d_ts_files_6693", "Skip type checking all .d.ts files."), Create_source_map_files_for_emitted_JavaScript_files: t(6694, e.DiagnosticCategory.Message, "Create_source_map_files_for_emitted_JavaScript_files_6694", "Create source map files for emitted JavaScript files."), Specify_the_root_path_for_debuggers_to_find_the_reference_source_code: t(6695, e.DiagnosticCategory.Message, "Specify_the_root_path_for_debuggers_to_find_the_reference_source_code_6695", "Specify the root path for debuggers to find the reference source code."), Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function: t(6697, e.DiagnosticCategory.Message, "Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function_6697", "Check that the arguments for 'bind', 'call', and 'apply' methods match the original function."), When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible: t(6698, e.DiagnosticCategory.Message, "When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible_6698", "When assigning functions, check to ensure parameters and the return values are subtype-compatible."), When_type_checking_take_into_account_null_and_undefined: t(6699, e.DiagnosticCategory.Message, "When_type_checking_take_into_account_null_and_undefined_6699", "When type checking, take into account 'null' and 'undefined'."), Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor: t(6700, e.DiagnosticCategory.Message, "Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor_6700", "Check for class properties that are declared but not set in the constructor."), Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments: t(6701, e.DiagnosticCategory.Message, "Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments_6701", "Disable emitting declarations that have '@internal' in their JSDoc comments."), Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals: t(6702, e.DiagnosticCategory.Message, "Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals_6702", "Disable reporting of excess property errors during the creation of object literals."), Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures: t(6703, e.DiagnosticCategory.Message, "Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures_6703", "Suppress 'noImplicitAny' errors when indexing objects that lack index signatures."), Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_support_recursive_watching_natively: t(6704, e.DiagnosticCategory.Message, "Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_supp_6704", "Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively."), Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declarations: t(6705, e.DiagnosticCategory.Message, "Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declaratio_6705", "Set the JavaScript language version for emitted JavaScript and include compatible library declarations."), Log_paths_used_during_the_moduleResolution_process: t(6706, e.DiagnosticCategory.Message, "Log_paths_used_during_the_moduleResolution_process_6706", "Log paths used during the 'moduleResolution' process."), Specify_the_path_to_tsbuildinfo_incremental_compilation_file: t(6707, e.DiagnosticCategory.Message, "Specify_the_path_to_tsbuildinfo_incremental_compilation_file_6707", "Specify the path to .tsbuildinfo incremental compilation file."), Specify_options_for_automatic_acquisition_of_declaration_files: t(6709, e.DiagnosticCategory.Message, "Specify_options_for_automatic_acquisition_of_declaration_files_6709", "Specify options for automatic acquisition of declaration files."), Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types: t(6710, e.DiagnosticCategory.Message, "Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types_6710", "Specify multiple folders that act like './node_modules/@types'."), Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file: t(6711, e.DiagnosticCategory.Message, "Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file_6711", "Specify type package names to be included without being referenced in a source file."), Emit_ECMAScript_standard_compliant_class_fields: t(6712, e.DiagnosticCategory.Message, "Emit_ECMAScript_standard_compliant_class_fields_6712", "Emit ECMAScript-standard-compliant class fields."), Enable_verbose_logging: t(6713, e.DiagnosticCategory.Message, "Enable_verbose_logging_6713", "Enable verbose logging."), Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality: t(6714, e.DiagnosticCategory.Message, "Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality_6714", "Specify how directories are watched on systems that lack recursive file-watching functionality."), Specify_how_the_TypeScript_watch_mode_works: t(6715, e.DiagnosticCategory.Message, "Specify_how_the_TypeScript_watch_mode_works_6715", "Specify how the TypeScript watch mode works."), Require_undeclared_properties_from_index_signatures_to_use_element_accesses: t(6717, e.DiagnosticCategory.Message, "Require_undeclared_properties_from_index_signatures_to_use_element_accesses_6717", "Require undeclared properties from index signatures to use element accesses."), Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types: t(6718, e.DiagnosticCategory.Message, "Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types_6718", "Specify emit/checking behavior for imports that are only used for types."), Default_catch_clause_variables_as_unknown_instead_of_any: t(6803, e.DiagnosticCategory.Message, "Default_catch_clause_variables_as_unknown_instead_of_any_6803", "Default catch clause variables as 'unknown' instead of 'any'."), one_of_Colon: t(6900, e.DiagnosticCategory.Message, "one_of_Colon_6900", "one of:"), one_or_more_Colon: t(6901, e.DiagnosticCategory.Message, "one_or_more_Colon_6901", "one or more:"), type_Colon: t(6902, e.DiagnosticCategory.Message, "type_Colon_6902", "type:"), default_Colon: t(6903, e.DiagnosticCategory.Message, "default_Colon_6903", "default:"), module_system_or_esModuleInterop: t(6904, e.DiagnosticCategory.Message, "module_system_or_esModuleInterop_6904", 'module === "system" or esModuleInterop'), false_unless_strict_is_set: t(6905, e.DiagnosticCategory.Message, "false_unless_strict_is_set_6905", "`false`, unless `strict` is set"), false_unless_composite_is_set: t(6906, e.DiagnosticCategory.Message, "false_unless_composite_is_set_6906", "`false`, unless `composite` is set"), node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified: t(6907, e.DiagnosticCategory.Message, "node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified_6907", '`["node_modules", "bower_components", "jspm_packages"]`, plus the value of `outDir` if one is specified.'), if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk: t(6908, e.DiagnosticCategory.Message, "if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk_6908", '`[]` if `files` is specified, otherwise `["**/*"]`'), true_if_composite_false_otherwise: t(6909, e.DiagnosticCategory.Message, "true_if_composite_false_otherwise_6909", "`true` if `composite`, `false` otherwise"), module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node: t(69010, e.DiagnosticCategory.Message, "module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node_69010", "module === `AMD` or `UMD` or `System` or `ES6`, then `Classic`, Otherwise `Node`"), Computed_from_the_list_of_input_files: t(6911, e.DiagnosticCategory.Message, "Computed_from_the_list_of_input_files_6911", "Computed from the list of input files"), Platform_specific: t(6912, e.DiagnosticCategory.Message, "Platform_specific_6912", "Platform specific"), You_can_learn_about_all_of_the_compiler_options_at_0: t(6913, e.DiagnosticCategory.Message, "You_can_learn_about_all_of_the_compiler_options_at_0_6913", "You can learn about all of the compiler options at {0}"), Including_watch_w_will_start_watching_the_current_project_for_the_file_changes_Once_set_you_can_config_watch_mode_with_Colon: t(6914, e.DiagnosticCategory.Message, "Including_watch_w_will_start_watching_the_current_project_for_the_file_changes_Once_set_you_can_conf_6914", "Including --watch, -w will start watching the current project for the file changes. Once set, you can config watch mode with:"), Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_trigger_building_composite_projects_which_you_can_learn_more_about_at_0: t(6915, e.DiagnosticCategory.Message, "Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_tr_6915", "Using --build, -b will make tsc behave more like a build orchestrator than a compiler. This is used to trigger building composite projects which you can learn more about at {0}"), COMMON_COMMANDS: t(6916, e.DiagnosticCategory.Message, "COMMON_COMMANDS_6916", "COMMON COMMANDS"), ALL_COMPILER_OPTIONS: t(6917, e.DiagnosticCategory.Message, "ALL_COMPILER_OPTIONS_6917", "ALL COMPILER OPTIONS"), WATCH_OPTIONS: t(6918, e.DiagnosticCategory.Message, "WATCH_OPTIONS_6918", "WATCH OPTIONS"), BUILD_OPTIONS: t(6919, e.DiagnosticCategory.Message, "BUILD_OPTIONS_6919", "BUILD OPTIONS"), COMMON_COMPILER_OPTIONS: t(6920, e.DiagnosticCategory.Message, "COMMON_COMPILER_OPTIONS_6920", "COMMON COMPILER OPTIONS"), COMMAND_LINE_FLAGS: t(6921, e.DiagnosticCategory.Message, "COMMAND_LINE_FLAGS_6921", "COMMAND LINE FLAGS"), tsc_Colon_The_TypeScript_Compiler: t(6922, e.DiagnosticCategory.Message, "tsc_Colon_The_TypeScript_Compiler_6922", "tsc: The TypeScript Compiler"), Compiles_the_current_project_tsconfig_json_in_the_working_directory: t(6923, e.DiagnosticCategory.Message, "Compiles_the_current_project_tsconfig_json_in_the_working_directory_6923", "Compiles the current project (tsconfig.json in the working directory.)"), Ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options: t(6924, e.DiagnosticCategory.Message, "Ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options_6924", "Ignoring tsconfig.json, compiles the specified files with default compiler options."), Build_a_composite_project_in_the_working_directory: t(6925, e.DiagnosticCategory.Message, "Build_a_composite_project_in_the_working_directory_6925", "Build a composite project in the working directory."), Creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory: t(6926, e.DiagnosticCategory.Message, "Creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory_6926", "Creates a tsconfig.json with the recommended settings in the working directory."), Compiles_the_TypeScript_project_located_at_the_specified_path: t(6927, e.DiagnosticCategory.Message, "Compiles_the_TypeScript_project_located_at_the_specified_path_6927", "Compiles the TypeScript project located at the specified path."), An_expanded_version_of_this_information_showing_all_possible_compiler_options: t(6928, e.DiagnosticCategory.Message, "An_expanded_version_of_this_information_showing_all_possible_compiler_options_6928", "An expanded version of this information, showing all possible compiler options"), Compiles_the_current_project_with_additional_settings: t(6929, e.DiagnosticCategory.Message, "Compiles_the_current_project_with_additional_settings_6929", "Compiles the current project, with additional settings."), true_for_ES2022_and_above_including_ESNext: t(6930, e.DiagnosticCategory.Message, "true_for_ES2022_and_above_including_ESNext_6930", "`true` for ES2022 and above, including ESNext."), List_of_file_name_suffixes_to_search_when_resolving_a_module: t(6931, e.DiagnosticCategory.Error, "List_of_file_name_suffixes_to_search_when_resolving_a_module_6931", "List of file name suffixes to search when resolving a module."), Variable_0_implicitly_has_an_1_type: t(7005, e.DiagnosticCategory.Error, "Variable_0_implicitly_has_an_1_type_7005", "Variable '{0}' implicitly has an '{1}' type."), Parameter_0_implicitly_has_an_1_type: t(7006, e.DiagnosticCategory.Error, "Parameter_0_implicitly_has_an_1_type_7006", "Parameter '{0}' implicitly has an '{1}' type."), Member_0_implicitly_has_an_1_type: t(7008, e.DiagnosticCategory.Error, "Member_0_implicitly_has_an_1_type_7008", "Member '{0}' implicitly has an '{1}' type."), new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type: t(7009, e.DiagnosticCategory.Error, "new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type_7009", "'new' expression, whose target lacks a construct signature, implicitly has an 'any' type."), _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type: t(7010, e.DiagnosticCategory.Error, "_0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type_7010", "'{0}', which lacks return-type annotation, implicitly has an '{1}' return type."), Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: t(7011, e.DiagnosticCategory.Error, "Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7011", "Function expression, which lacks return-type annotation, implicitly has an '{0}' return type."), Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: t(7013, e.DiagnosticCategory.Error, "Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7013", "Construct signature, which lacks return-type annotation, implicitly has an 'any' return type."), Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: t(7014, e.DiagnosticCategory.Error, "Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7014", "Function type, which lacks return-type annotation, implicitly has an '{0}' return type."), Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number: t(7015, e.DiagnosticCategory.Error, "Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number_7015", "Element implicitly has an 'any' type because index expression is not of type 'number'."), Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type: t(7016, e.DiagnosticCategory.Error, "Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type_7016", "Could not find a declaration file for module '{0}'. '{1}' implicitly has an 'any' type."), Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature: t(7017, e.DiagnosticCategory.Error, "Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_7017", "Element implicitly has an 'any' type because type '{0}' has no index signature."), Object_literal_s_property_0_implicitly_has_an_1_type: t(7018, e.DiagnosticCategory.Error, "Object_literal_s_property_0_implicitly_has_an_1_type_7018", "Object literal's property '{0}' implicitly has an '{1}' type."), Rest_parameter_0_implicitly_has_an_any_type: t(7019, e.DiagnosticCategory.Error, "Rest_parameter_0_implicitly_has_an_any_type_7019", "Rest parameter '{0}' implicitly has an 'any[]' type."), Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: t(7020, e.DiagnosticCategory.Error, "Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7020", "Call signature, which lacks return-type annotation, implicitly has an 'any' return type."), _0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer: t(7022, e.DiagnosticCategory.Error, "_0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or__7022", "'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer."), _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: t(7023, e.DiagnosticCategory.Error, "_0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_reference_7023", "'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions."), Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: t(7024, e.DiagnosticCategory.Error, "Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_ref_7024", "Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions."), Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation: t(7025, e.DiagnosticCategory.Error, "Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_retu_7025", "Generator implicitly has yield type '{0}' because it does not yield any values. Consider supplying a return type annotation."), JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists: t(7026, e.DiagnosticCategory.Error, "JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists_7026", "JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists."), Unreachable_code_detected: t(7027, e.DiagnosticCategory.Error, "Unreachable_code_detected_7027", "Unreachable code detected.", true), Unused_label: t(7028, e.DiagnosticCategory.Error, "Unused_label_7028", "Unused label.", true), Fallthrough_case_in_switch: t(7029, e.DiagnosticCategory.Error, "Fallthrough_case_in_switch_7029", "Fallthrough case in switch."), Not_all_code_paths_return_a_value: t(7030, e.DiagnosticCategory.Error, "Not_all_code_paths_return_a_value_7030", "Not all code paths return a value."), Binding_element_0_implicitly_has_an_1_type: t(7031, e.DiagnosticCategory.Error, "Binding_element_0_implicitly_has_an_1_type_7031", "Binding element '{0}' implicitly has an '{1}' type."), Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation: t(7032, e.DiagnosticCategory.Error, "Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation_7032", "Property '{0}' implicitly has type 'any', because its set accessor lacks a parameter type annotation."), Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation: t(7033, e.DiagnosticCategory.Error, "Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation_7033", "Property '{0}' implicitly has type 'any', because its get accessor lacks a return type annotation."), Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined: t(7034, e.DiagnosticCategory.Error, "Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined_7034", "Variable '{0}' implicitly has type '{1}' in some locations where its type cannot be determined."), Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0: t(7035, e.DiagnosticCategory.Error, "Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare__7035", "Try `npm i --save-dev @types/{1}` if it exists or add a new declaration (.d.ts) file containing `declare module '{0}';`"), Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0: t(7036, e.DiagnosticCategory.Error, "Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0_7036", "Dynamic import's specifier must be of type 'string', but here has type '{0}'."), Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for_all_imports_Implies_allowSyntheticDefaultImports: t(7037, e.DiagnosticCategory.Message, "Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for__7037", "Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'."), Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead: t(7038, e.DiagnosticCategory.Message, "Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cau_7038", "Type originates at this import. A namespace-style import cannot be called or constructed, and will cause a failure at runtime. Consider using a default import or import require here instead."), Mapped_object_type_implicitly_has_an_any_template_type: t(7039, e.DiagnosticCategory.Error, "Mapped_object_type_implicitly_has_an_any_template_type_7039", "Mapped object type implicitly has an 'any' template type."), If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1: t(7040, e.DiagnosticCategory.Error, "If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_S_7040", "If the '{0}' package actually exposes this module, consider sending a pull request to amend 'https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/{1}'"), The_containing_arrow_function_captures_the_global_value_of_this: t(7041, e.DiagnosticCategory.Error, "The_containing_arrow_function_captures_the_global_value_of_this_7041", "The containing arrow function captures the global value of 'this'."), Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used: t(7042, e.DiagnosticCategory.Error, "Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used_7042", "Module '{0}' was resolved to '{1}', but '--resolveJsonModule' is not used."), Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: t(7043, e.DiagnosticCategory.Suggestion, "Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7043", "Variable '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."), Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: t(7044, e.DiagnosticCategory.Suggestion, "Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7044", "Parameter '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."), Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: t(7045, e.DiagnosticCategory.Suggestion, "Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7045", "Member '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."), Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage: t(7046, e.DiagnosticCategory.Suggestion, "Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage_7046", "Variable '{0}' implicitly has type '{1}' in some locations, but a better type may be inferred from usage."), Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage: t(7047, e.DiagnosticCategory.Suggestion, "Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage_7047", "Rest parameter '{0}' implicitly has an 'any[]' type, but a better type may be inferred from usage."), Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage: t(7048, e.DiagnosticCategory.Suggestion, "Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage_7048", "Property '{0}' implicitly has type 'any', but a better type for its get accessor may be inferred from usage."), Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage: t(7049, e.DiagnosticCategory.Suggestion, "Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage_7049", "Property '{0}' implicitly has type 'any', but a better type for its set accessor may be inferred from usage."), _0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage: t(7050, e.DiagnosticCategory.Suggestion, "_0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage_7050", "'{0}' implicitly has an '{1}' return type, but a better type may be inferred from usage."), Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1: t(7051, e.DiagnosticCategory.Error, "Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1_7051", "Parameter has a name but no type. Did you mean '{0}: {1}'?"), Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1: t(7052, e.DiagnosticCategory.Error, "Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1_7052", "Element implicitly has an 'any' type because type '{0}' has no index signature. Did you mean to call '{1}'?"), Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1: t(7053, e.DiagnosticCategory.Error, "Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1_7053", "Element implicitly has an 'any' type because expression of type '{0}' can't be used to index type '{1}'."), No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1: t(7054, e.DiagnosticCategory.Error, "No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1_7054", "No index signature with a parameter of type '{0}' was found on type '{1}'."), _0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type: t(7055, e.DiagnosticCategory.Error, "_0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type_7055", "'{0}', which lacks return-type annotation, implicitly has an '{1}' yield type."), The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_type_annotation_is_needed: t(7056, e.DiagnosticCategory.Error, "The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_ty_7056", "The inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed."), yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation: t(7057, e.DiagnosticCategory.Error, "yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_t_7057", "'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation."), If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_declare_module_1: t(7058, e.DiagnosticCategory.Error, "If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_decl_7058", "If the '{0}' package actually exposes this module, try adding a new declaration (.d.ts) file containing `declare module '{1}';`"), This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead: t(7059, e.DiagnosticCategory.Error, "This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead_7059", "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead."), This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint: t(7060, e.DiagnosticCategory.Error, "This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_cons_7060", "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma or explicit constraint."), A_mapped_type_may_not_declare_properties_or_methods: t(7061, e.DiagnosticCategory.Error, "A_mapped_type_may_not_declare_properties_or_methods_7061", "A mapped type may not declare properties or methods."), You_cannot_rename_this_element: t(8e3, e.DiagnosticCategory.Error, "You_cannot_rename_this_element_8000", "You cannot rename this element."), You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library: t(8001, e.DiagnosticCategory.Error, "You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library_8001", "You cannot rename elements that are defined in the standard TypeScript library."), import_can_only_be_used_in_TypeScript_files: t(8002, e.DiagnosticCategory.Error, "import_can_only_be_used_in_TypeScript_files_8002", "'import ... =' can only be used in TypeScript files."), export_can_only_be_used_in_TypeScript_files: t(8003, e.DiagnosticCategory.Error, "export_can_only_be_used_in_TypeScript_files_8003", "'export =' can only be used in TypeScript files."), Type_parameter_declarations_can_only_be_used_in_TypeScript_files: t(8004, e.DiagnosticCategory.Error, "Type_parameter_declarations_can_only_be_used_in_TypeScript_files_8004", "Type parameter declarations can only be used in TypeScript files."), implements_clauses_can_only_be_used_in_TypeScript_files: t(8005, e.DiagnosticCategory.Error, "implements_clauses_can_only_be_used_in_TypeScript_files_8005", "'implements' clauses can only be used in TypeScript files."), _0_declarations_can_only_be_used_in_TypeScript_files: t(8006, e.DiagnosticCategory.Error, "_0_declarations_can_only_be_used_in_TypeScript_files_8006", "'{0}' declarations can only be used in TypeScript files."), Type_aliases_can_only_be_used_in_TypeScript_files: t(8008, e.DiagnosticCategory.Error, "Type_aliases_can_only_be_used_in_TypeScript_files_8008", "Type aliases can only be used in TypeScript files."), The_0_modifier_can_only_be_used_in_TypeScript_files: t(8009, e.DiagnosticCategory.Error, "The_0_modifier_can_only_be_used_in_TypeScript_files_8009", "The '{0}' modifier can only be used in TypeScript files."), Type_annotations_can_only_be_used_in_TypeScript_files: t(8010, e.DiagnosticCategory.Error, "Type_annotations_can_only_be_used_in_TypeScript_files_8010", "Type annotations can only be used in TypeScript files."), Type_arguments_can_only_be_used_in_TypeScript_files: t(8011, e.DiagnosticCategory.Error, "Type_arguments_can_only_be_used_in_TypeScript_files_8011", "Type arguments can only be used in TypeScript files."), Parameter_modifiers_can_only_be_used_in_TypeScript_files: t(8012, e.DiagnosticCategory.Error, "Parameter_modifiers_can_only_be_used_in_TypeScript_files_8012", "Parameter modifiers can only be used in TypeScript files."), Non_null_assertions_can_only_be_used_in_TypeScript_files: t(8013, e.DiagnosticCategory.Error, "Non_null_assertions_can_only_be_used_in_TypeScript_files_8013", "Non-null assertions can only be used in TypeScript files."), Type_assertion_expressions_can_only_be_used_in_TypeScript_files: t(8016, e.DiagnosticCategory.Error, "Type_assertion_expressions_can_only_be_used_in_TypeScript_files_8016", "Type assertion expressions can only be used in TypeScript files."), Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0: t(8017, e.DiagnosticCategory.Error, "Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0_8017", "Octal literal types must use ES2015 syntax. Use the syntax '{0}'."), Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0: t(8018, e.DiagnosticCategory.Error, "Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0_8018", "Octal literals are not allowed in enums members initializer. Use the syntax '{0}'."), Report_errors_in_js_files: t(8019, e.DiagnosticCategory.Message, "Report_errors_in_js_files_8019", "Report errors in .js files."), JSDoc_types_can_only_be_used_inside_documentation_comments: t(8020, e.DiagnosticCategory.Error, "JSDoc_types_can_only_be_used_inside_documentation_comments_8020", "JSDoc types can only be used inside documentation comments."), JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags: t(8021, e.DiagnosticCategory.Error, "JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags_8021", "JSDoc '@typedef' tag should either have a type annotation or be followed by '@property' or '@member' tags."), JSDoc_0_is_not_attached_to_a_class: t(8022, e.DiagnosticCategory.Error, "JSDoc_0_is_not_attached_to_a_class_8022", "JSDoc '@{0}' is not attached to a class."), JSDoc_0_1_does_not_match_the_extends_2_clause: t(8023, e.DiagnosticCategory.Error, "JSDoc_0_1_does_not_match_the_extends_2_clause_8023", "JSDoc '@{0} {1}' does not match the 'extends {2}' clause."), JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name: t(8024, e.DiagnosticCategory.Error, "JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_8024", "JSDoc '@param' tag has name '{0}', but there is no parameter with that name."), Class_declarations_cannot_have_more_than_one_augments_or_extends_tag: t(8025, e.DiagnosticCategory.Error, "Class_declarations_cannot_have_more_than_one_augments_or_extends_tag_8025", "Class declarations cannot have more than one '@augments' or '@extends' tag."), Expected_0_type_arguments_provide_these_with_an_extends_tag: t(8026, e.DiagnosticCategory.Error, "Expected_0_type_arguments_provide_these_with_an_extends_tag_8026", "Expected {0} type arguments; provide these with an '@extends' tag."), Expected_0_1_type_arguments_provide_these_with_an_extends_tag: t(8027, e.DiagnosticCategory.Error, "Expected_0_1_type_arguments_provide_these_with_an_extends_tag_8027", "Expected {0}-{1} type arguments; provide these with an '@extends' tag."), JSDoc_may_only_appear_in_the_last_parameter_of_a_signature: t(8028, e.DiagnosticCategory.Error, "JSDoc_may_only_appear_in_the_last_parameter_of_a_signature_8028", "JSDoc '...' may only appear in the last parameter of a signature."), JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type: t(8029, e.DiagnosticCategory.Error, "JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_h_8029", "JSDoc '@param' tag has name '{0}', but there is no parameter with that name. It would match 'arguments' if it had an array type."), The_type_of_a_function_declaration_must_match_the_function_s_signature: t(8030, e.DiagnosticCategory.Error, "The_type_of_a_function_declaration_must_match_the_function_s_signature_8030", "The type of a function declaration must match the function's signature."), You_cannot_rename_a_module_via_a_global_import: t(8031, e.DiagnosticCategory.Error, "You_cannot_rename_a_module_via_a_global_import_8031", "You cannot rename a module via a global import."), Qualified_name_0_is_not_allowed_without_a_leading_param_object_1: t(8032, e.DiagnosticCategory.Error, "Qualified_name_0_is_not_allowed_without_a_leading_param_object_1_8032", "Qualified name '{0}' is not allowed without a leading '@param {object} {1}'."), A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags: t(8033, e.DiagnosticCategory.Error, "A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags_8033", "A JSDoc '@typedef' comment may not contain multiple '@type' tags."), The_tag_was_first_specified_here: t(8034, e.DiagnosticCategory.Error, "The_tag_was_first_specified_here_8034", "The tag was first specified here."), You_cannot_rename_elements_that_are_defined_in_a_node_modules_folder: t(8035, e.DiagnosticCategory.Error, "You_cannot_rename_elements_that_are_defined_in_a_node_modules_folder_8035", "You cannot rename elements that are defined in a 'node_modules' folder."), You_cannot_rename_elements_that_are_defined_in_another_node_modules_folder: t(8036, e.DiagnosticCategory.Error, "You_cannot_rename_elements_that_are_defined_in_another_node_modules_folder_8036", "You cannot rename elements that are defined in another 'node_modules' folder."), Type_satisfaction_expressions_can_only_be_used_in_TypeScript_files: t(8037, e.DiagnosticCategory.Error, "Type_satisfaction_expressions_can_only_be_used_in_TypeScript_files_8037", "Type satisfaction expressions can only be used in TypeScript files."), Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_declaration_emit: t(9005, e.DiagnosticCategory.Error, "Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_9005", "Declaration emit for this file requires using private name '{0}'. An explicit type annotation may unblock declaration emit."), Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotation_may_unblock_declaration_emit: t(9006, e.DiagnosticCategory.Error, "Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotati_9006", "Declaration emit for this file requires using private name '{0}' from module '{1}'. An explicit type annotation may unblock declaration emit."), JSX_attributes_must_only_be_assigned_a_non_empty_expression: t(17e3, e.DiagnosticCategory.Error, "JSX_attributes_must_only_be_assigned_a_non_empty_expression_17000", "JSX attributes must only be assigned a non-empty 'expression'."), JSX_elements_cannot_have_multiple_attributes_with_the_same_name: t(17001, e.DiagnosticCategory.Error, "JSX_elements_cannot_have_multiple_attributes_with_the_same_name_17001", "JSX elements cannot have multiple attributes with the same name."), Expected_corresponding_JSX_closing_tag_for_0: t(17002, e.DiagnosticCategory.Error, "Expected_corresponding_JSX_closing_tag_for_0_17002", "Expected corresponding JSX closing tag for '{0}'."), Cannot_use_JSX_unless_the_jsx_flag_is_provided: t(17004, e.DiagnosticCategory.Error, "Cannot_use_JSX_unless_the_jsx_flag_is_provided_17004", "Cannot use JSX unless the '--jsx' flag is provided."), A_constructor_cannot_contain_a_super_call_when_its_class_extends_null: t(17005, e.DiagnosticCategory.Error, "A_constructor_cannot_contain_a_super_call_when_its_class_extends_null_17005", "A constructor cannot contain a 'super' call when its class extends 'null'."), An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: t(17006, e.DiagnosticCategory.Error, "An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_ex_17006", "An unary expression with the '{0}' operator is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses."), A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: t(17007, e.DiagnosticCategory.Error, "A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Con_17007", "A type assertion expression is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses."), JSX_element_0_has_no_corresponding_closing_tag: t(17008, e.DiagnosticCategory.Error, "JSX_element_0_has_no_corresponding_closing_tag_17008", "JSX element '{0}' has no corresponding closing tag."), super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class: t(17009, e.DiagnosticCategory.Error, "super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class_17009", "'super' must be called before accessing 'this' in the constructor of a derived class."), Unknown_type_acquisition_option_0: t(17010, e.DiagnosticCategory.Error, "Unknown_type_acquisition_option_0_17010", "Unknown type acquisition option '{0}'."), super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class: t(17011, e.DiagnosticCategory.Error, "super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class_17011", "'super' must be called before accessing a property of 'super' in the constructor of a derived class."), _0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2: t(17012, e.DiagnosticCategory.Error, "_0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2_17012", "'{0}' is not a valid meta-property for keyword '{1}'. Did you mean '{2}'?"), Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor: t(17013, e.DiagnosticCategory.Error, "Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constru_17013", "Meta-property '{0}' is only allowed in the body of a function declaration, function expression, or constructor."), JSX_fragment_has_no_corresponding_closing_tag: t(17014, e.DiagnosticCategory.Error, "JSX_fragment_has_no_corresponding_closing_tag_17014", "JSX fragment has no corresponding closing tag."), Expected_corresponding_closing_tag_for_JSX_fragment: t(17015, e.DiagnosticCategory.Error, "Expected_corresponding_closing_tag_for_JSX_fragment_17015", "Expected corresponding closing tag for JSX fragment."), The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option: t(17016, e.DiagnosticCategory.Error, "The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_com_17016", "The 'jsxFragmentFactory' compiler option must be provided to use JSX fragments with the 'jsxFactory' compiler option."), An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments: t(17017, e.DiagnosticCategory.Error, "An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments_17017", "An @jsxFrag pragma is required when using an @jsx pragma with JSX fragments."), Unknown_type_acquisition_option_0_Did_you_mean_1: t(17018, e.DiagnosticCategory.Error, "Unknown_type_acquisition_option_0_Did_you_mean_1_17018", "Unknown type acquisition option '{0}'. Did you mean '{1}'?"), Circularity_detected_while_resolving_configuration_Colon_0: t(18e3, e.DiagnosticCategory.Error, "Circularity_detected_while_resolving_configuration_Colon_0_18000", "Circularity detected while resolving configuration: {0}"), The_files_list_in_config_file_0_is_empty: t(18002, e.DiagnosticCategory.Error, "The_files_list_in_config_file_0_is_empty_18002", "The 'files' list in config file '{0}' is empty."), No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2: t(18003, e.DiagnosticCategory.Error, "No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2_18003", "No inputs were found in config file '{0}'. Specified 'include' paths were '{1}' and 'exclude' paths were '{2}'."), File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module: t(80001, e.DiagnosticCategory.Suggestion, "File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module_80001", "File is a CommonJS module; it may be converted to an ES module."), This_constructor_function_may_be_converted_to_a_class_declaration: t(80002, e.DiagnosticCategory.Suggestion, "This_constructor_function_may_be_converted_to_a_class_declaration_80002", "This constructor function may be converted to a class declaration."), Import_may_be_converted_to_a_default_import: t(80003, e.DiagnosticCategory.Suggestion, "Import_may_be_converted_to_a_default_import_80003", "Import may be converted to a default import."), JSDoc_types_may_be_moved_to_TypeScript_types: t(80004, e.DiagnosticCategory.Suggestion, "JSDoc_types_may_be_moved_to_TypeScript_types_80004", "JSDoc types may be moved to TypeScript types."), require_call_may_be_converted_to_an_import: t(80005, e.DiagnosticCategory.Suggestion, "require_call_may_be_converted_to_an_import_80005", "'require' call may be converted to an import."), This_may_be_converted_to_an_async_function: t(80006, e.DiagnosticCategory.Suggestion, "This_may_be_converted_to_an_async_function_80006", "This may be converted to an async function."), await_has_no_effect_on_the_type_of_this_expression: t(80007, e.DiagnosticCategory.Suggestion, "await_has_no_effect_on_the_type_of_this_expression_80007", "'await' has no effect on the type of this expression."), Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers: t(80008, e.DiagnosticCategory.Suggestion, "Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accur_80008", "Numeric literals with absolute values equal to 2^53 or greater are too large to be represented accurately as integers."), Add_missing_super_call: t(90001, e.DiagnosticCategory.Message, "Add_missing_super_call_90001", "Add missing 'super()' call"), Make_super_call_the_first_statement_in_the_constructor: t(90002, e.DiagnosticCategory.Message, "Make_super_call_the_first_statement_in_the_constructor_90002", "Make 'super()' call the first statement in the constructor"), Change_extends_to_implements: t(90003, e.DiagnosticCategory.Message, "Change_extends_to_implements_90003", "Change 'extends' to 'implements'"), Remove_unused_declaration_for_Colon_0: t(90004, e.DiagnosticCategory.Message, "Remove_unused_declaration_for_Colon_0_90004", "Remove unused declaration for: '{0}'"), Remove_import_from_0: t(90005, e.DiagnosticCategory.Message, "Remove_import_from_0_90005", "Remove import from '{0}'"), Implement_interface_0: t(90006, e.DiagnosticCategory.Message, "Implement_interface_0_90006", "Implement interface '{0}'"), Implement_inherited_abstract_class: t(90007, e.DiagnosticCategory.Message, "Implement_inherited_abstract_class_90007", "Implement inherited abstract class"), Add_0_to_unresolved_variable: t(90008, e.DiagnosticCategory.Message, "Add_0_to_unresolved_variable_90008", "Add '{0}.' to unresolved variable"), Remove_variable_statement: t(90010, e.DiagnosticCategory.Message, "Remove_variable_statement_90010", "Remove variable statement"), Remove_template_tag: t(90011, e.DiagnosticCategory.Message, "Remove_template_tag_90011", "Remove template tag"), Remove_type_parameters: t(90012, e.DiagnosticCategory.Message, "Remove_type_parameters_90012", "Remove type parameters"), Import_0_from_1: t(90013, e.DiagnosticCategory.Message, "Import_0_from_1_90013", `Import '{0}' from "{1}"`), Change_0_to_1: t(90014, e.DiagnosticCategory.Message, "Change_0_to_1_90014", "Change '{0}' to '{1}'"), Declare_property_0: t(90016, e.DiagnosticCategory.Message, "Declare_property_0_90016", "Declare property '{0}'"), Add_index_signature_for_property_0: t(90017, e.DiagnosticCategory.Message, "Add_index_signature_for_property_0_90017", "Add index signature for property '{0}'"), Disable_checking_for_this_file: t(90018, e.DiagnosticCategory.Message, "Disable_checking_for_this_file_90018", "Disable checking for this file"), Ignore_this_error_message: t(90019, e.DiagnosticCategory.Message, "Ignore_this_error_message_90019", "Ignore this error message"), Initialize_property_0_in_the_constructor: t(90020, e.DiagnosticCategory.Message, "Initialize_property_0_in_the_constructor_90020", "Initialize property '{0}' in the constructor"), Initialize_static_property_0: t(90021, e.DiagnosticCategory.Message, "Initialize_static_property_0_90021", "Initialize static property '{0}'"), Change_spelling_to_0: t(90022, e.DiagnosticCategory.Message, "Change_spelling_to_0_90022", "Change spelling to '{0}'"), Declare_method_0: t(90023, e.DiagnosticCategory.Message, "Declare_method_0_90023", "Declare method '{0}'"), Declare_static_method_0: t(90024, e.DiagnosticCategory.Message, "Declare_static_method_0_90024", "Declare static method '{0}'"), Prefix_0_with_an_underscore: t(90025, e.DiagnosticCategory.Message, "Prefix_0_with_an_underscore_90025", "Prefix '{0}' with an underscore"), Rewrite_as_the_indexed_access_type_0: t(90026, e.DiagnosticCategory.Message, "Rewrite_as_the_indexed_access_type_0_90026", "Rewrite as the indexed access type '{0}'"), Declare_static_property_0: t(90027, e.DiagnosticCategory.Message, "Declare_static_property_0_90027", "Declare static property '{0}'"), Call_decorator_expression: t(90028, e.DiagnosticCategory.Message, "Call_decorator_expression_90028", "Call decorator expression"), Add_async_modifier_to_containing_function: t(90029, e.DiagnosticCategory.Message, "Add_async_modifier_to_containing_function_90029", "Add async modifier to containing function"), Replace_infer_0_with_unknown: t(90030, e.DiagnosticCategory.Message, "Replace_infer_0_with_unknown_90030", "Replace 'infer {0}' with 'unknown'"), Replace_all_unused_infer_with_unknown: t(90031, e.DiagnosticCategory.Message, "Replace_all_unused_infer_with_unknown_90031", "Replace all unused 'infer' with 'unknown'"), Add_parameter_name: t(90034, e.DiagnosticCategory.Message, "Add_parameter_name_90034", "Add parameter name"), Declare_private_property_0: t(90035, e.DiagnosticCategory.Message, "Declare_private_property_0_90035", "Declare private property '{0}'"), Replace_0_with_Promise_1: t(90036, e.DiagnosticCategory.Message, "Replace_0_with_Promise_1_90036", "Replace '{0}' with 'Promise<{1}>'"), Fix_all_incorrect_return_type_of_an_async_functions: t(90037, e.DiagnosticCategory.Message, "Fix_all_incorrect_return_type_of_an_async_functions_90037", "Fix all incorrect return type of an async functions"), Declare_private_method_0: t(90038, e.DiagnosticCategory.Message, "Declare_private_method_0_90038", "Declare private method '{0}'"), Remove_unused_destructuring_declaration: t(90039, e.DiagnosticCategory.Message, "Remove_unused_destructuring_declaration_90039", "Remove unused destructuring declaration"), Remove_unused_declarations_for_Colon_0: t(90041, e.DiagnosticCategory.Message, "Remove_unused_declarations_for_Colon_0_90041", "Remove unused declarations for: '{0}'"), Declare_a_private_field_named_0: t(90053, e.DiagnosticCategory.Message, "Declare_a_private_field_named_0_90053", "Declare a private field named '{0}'."), Includes_imports_of_types_referenced_by_0: t(90054, e.DiagnosticCategory.Message, "Includes_imports_of_types_referenced_by_0_90054", "Includes imports of types referenced by '{0}'"), Remove_type_from_import_declaration_from_0: t(90055, e.DiagnosticCategory.Message, "Remove_type_from_import_declaration_from_0_90055", `Remove 'type' from import declaration from "{0}"`), Remove_type_from_import_of_0_from_1: t(90056, e.DiagnosticCategory.Message, "Remove_type_from_import_of_0_from_1_90056", `Remove 'type' from import of '{0}' from "{1}"`), Add_import_from_0: t(90057, e.DiagnosticCategory.Message, "Add_import_from_0_90057", 'Add import from "{0}"'), Update_import_from_0: t(90058, e.DiagnosticCategory.Message, "Update_import_from_0_90058", 'Update import from "{0}"'), Export_0_from_module_1: t(90059, e.DiagnosticCategory.Message, "Export_0_from_module_1_90059", "Export '{0}' from module '{1}'"), Export_all_referenced_locals: t(90060, e.DiagnosticCategory.Message, "Export_all_referenced_locals_90060", "Export all referenced locals"), Convert_function_to_an_ES2015_class: t(95001, e.DiagnosticCategory.Message, "Convert_function_to_an_ES2015_class_95001", "Convert function to an ES2015 class"), Convert_0_to_1_in_0: t(95003, e.DiagnosticCategory.Message, "Convert_0_to_1_in_0_95003", "Convert '{0}' to '{1} in {0}'"), Extract_to_0_in_1: t(95004, e.DiagnosticCategory.Message, "Extract_to_0_in_1_95004", "Extract to {0} in {1}"), Extract_function: t(95005, e.DiagnosticCategory.Message, "Extract_function_95005", "Extract function"), Extract_constant: t(95006, e.DiagnosticCategory.Message, "Extract_constant_95006", "Extract constant"), Extract_to_0_in_enclosing_scope: t(95007, e.DiagnosticCategory.Message, "Extract_to_0_in_enclosing_scope_95007", "Extract to {0} in enclosing scope"), Extract_to_0_in_1_scope: t(95008, e.DiagnosticCategory.Message, "Extract_to_0_in_1_scope_95008", "Extract to {0} in {1} scope"), Annotate_with_type_from_JSDoc: t(95009, e.DiagnosticCategory.Message, "Annotate_with_type_from_JSDoc_95009", "Annotate with type from JSDoc"), Infer_type_of_0_from_usage: t(95011, e.DiagnosticCategory.Message, "Infer_type_of_0_from_usage_95011", "Infer type of '{0}' from usage"), Infer_parameter_types_from_usage: t(95012, e.DiagnosticCategory.Message, "Infer_parameter_types_from_usage_95012", "Infer parameter types from usage"), Convert_to_default_import: t(95013, e.DiagnosticCategory.Message, "Convert_to_default_import_95013", "Convert to default import"), Install_0: t(95014, e.DiagnosticCategory.Message, "Install_0_95014", "Install '{0}'"), Replace_import_with_0: t(95015, e.DiagnosticCategory.Message, "Replace_import_with_0_95015", "Replace import with '{0}'."), Use_synthetic_default_member: t(95016, e.DiagnosticCategory.Message, "Use_synthetic_default_member_95016", "Use synthetic 'default' member."), Convert_to_ES_module: t(95017, e.DiagnosticCategory.Message, "Convert_to_ES_module_95017", "Convert to ES module"), Add_undefined_type_to_property_0: t(95018, e.DiagnosticCategory.Message, "Add_undefined_type_to_property_0_95018", "Add 'undefined' type to property '{0}'"), Add_initializer_to_property_0: t(95019, e.DiagnosticCategory.Message, "Add_initializer_to_property_0_95019", "Add initializer to property '{0}'"), Add_definite_assignment_assertion_to_property_0: t(95020, e.DiagnosticCategory.Message, "Add_definite_assignment_assertion_to_property_0_95020", "Add definite assignment assertion to property '{0}'"), Convert_all_type_literals_to_mapped_type: t(95021, e.DiagnosticCategory.Message, "Convert_all_type_literals_to_mapped_type_95021", "Convert all type literals to mapped type"), Add_all_missing_members: t(95022, e.DiagnosticCategory.Message, "Add_all_missing_members_95022", "Add all missing members"), Infer_all_types_from_usage: t(95023, e.DiagnosticCategory.Message, "Infer_all_types_from_usage_95023", "Infer all types from usage"), Delete_all_unused_declarations: t(95024, e.DiagnosticCategory.Message, "Delete_all_unused_declarations_95024", "Delete all unused declarations"), Prefix_all_unused_declarations_with_where_possible: t(95025, e.DiagnosticCategory.Message, "Prefix_all_unused_declarations_with_where_possible_95025", "Prefix all unused declarations with '_' where possible"), Fix_all_detected_spelling_errors: t(95026, e.DiagnosticCategory.Message, "Fix_all_detected_spelling_errors_95026", "Fix all detected spelling errors"), Add_initializers_to_all_uninitialized_properties: t(95027, e.DiagnosticCategory.Message, "Add_initializers_to_all_uninitialized_properties_95027", "Add initializers to all uninitialized properties"), Add_definite_assignment_assertions_to_all_uninitialized_properties: t(95028, e.DiagnosticCategory.Message, "Add_definite_assignment_assertions_to_all_uninitialized_properties_95028", "Add definite assignment assertions to all uninitialized properties"), Add_undefined_type_to_all_uninitialized_properties: t(95029, e.DiagnosticCategory.Message, "Add_undefined_type_to_all_uninitialized_properties_95029", "Add undefined type to all uninitialized properties"), Change_all_jsdoc_style_types_to_TypeScript: t(95030, e.DiagnosticCategory.Message, "Change_all_jsdoc_style_types_to_TypeScript_95030", "Change all jsdoc-style types to TypeScript"), Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types: t(95031, e.DiagnosticCategory.Message, "Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types_95031", "Change all jsdoc-style types to TypeScript (and add '| undefined' to nullable types)"), Implement_all_unimplemented_interfaces: t(95032, e.DiagnosticCategory.Message, "Implement_all_unimplemented_interfaces_95032", "Implement all unimplemented interfaces"), Install_all_missing_types_packages: t(95033, e.DiagnosticCategory.Message, "Install_all_missing_types_packages_95033", "Install all missing types packages"), Rewrite_all_as_indexed_access_types: t(95034, e.DiagnosticCategory.Message, "Rewrite_all_as_indexed_access_types_95034", "Rewrite all as indexed access types"), Convert_all_to_default_imports: t(95035, e.DiagnosticCategory.Message, "Convert_all_to_default_imports_95035", "Convert all to default imports"), Make_all_super_calls_the_first_statement_in_their_constructor: t(95036, e.DiagnosticCategory.Message, "Make_all_super_calls_the_first_statement_in_their_constructor_95036", "Make all 'super()' calls the first statement in their constructor"), Add_qualifier_to_all_unresolved_variables_matching_a_member_name: t(95037, e.DiagnosticCategory.Message, "Add_qualifier_to_all_unresolved_variables_matching_a_member_name_95037", "Add qualifier to all unresolved variables matching a member name"), Change_all_extended_interfaces_to_implements: t(95038, e.DiagnosticCategory.Message, "Change_all_extended_interfaces_to_implements_95038", "Change all extended interfaces to 'implements'"), Add_all_missing_super_calls: t(95039, e.DiagnosticCategory.Message, "Add_all_missing_super_calls_95039", "Add all missing super calls"), Implement_all_inherited_abstract_classes: t(95040, e.DiagnosticCategory.Message, "Implement_all_inherited_abstract_classes_95040", "Implement all inherited abstract classes"), Add_all_missing_async_modifiers: t(95041, e.DiagnosticCategory.Message, "Add_all_missing_async_modifiers_95041", "Add all missing 'async' modifiers"), Add_ts_ignore_to_all_error_messages: t(95042, e.DiagnosticCategory.Message, "Add_ts_ignore_to_all_error_messages_95042", "Add '@ts-ignore' to all error messages"), Annotate_everything_with_types_from_JSDoc: t(95043, e.DiagnosticCategory.Message, "Annotate_everything_with_types_from_JSDoc_95043", "Annotate everything with types from JSDoc"), Add_to_all_uncalled_decorators: t(95044, e.DiagnosticCategory.Message, "Add_to_all_uncalled_decorators_95044", "Add '()' to all uncalled decorators"), Convert_all_constructor_functions_to_classes: t(95045, e.DiagnosticCategory.Message, "Convert_all_constructor_functions_to_classes_95045", "Convert all constructor functions to classes"), Generate_get_and_set_accessors: t(95046, e.DiagnosticCategory.Message, "Generate_get_and_set_accessors_95046", "Generate 'get' and 'set' accessors"), Convert_require_to_import: t(95047, e.DiagnosticCategory.Message, "Convert_require_to_import_95047", "Convert 'require' to 'import'"), Convert_all_require_to_import: t(95048, e.DiagnosticCategory.Message, "Convert_all_require_to_import_95048", "Convert all 'require' to 'import'"), Move_to_a_new_file: t(95049, e.DiagnosticCategory.Message, "Move_to_a_new_file_95049", "Move to a new file"), Remove_unreachable_code: t(95050, e.DiagnosticCategory.Message, "Remove_unreachable_code_95050", "Remove unreachable code"), Remove_all_unreachable_code: t(95051, e.DiagnosticCategory.Message, "Remove_all_unreachable_code_95051", "Remove all unreachable code"), Add_missing_typeof: t(95052, e.DiagnosticCategory.Message, "Add_missing_typeof_95052", "Add missing 'typeof'"), Remove_unused_label: t(95053, e.DiagnosticCategory.Message, "Remove_unused_label_95053", "Remove unused label"), Remove_all_unused_labels: t(95054, e.DiagnosticCategory.Message, "Remove_all_unused_labels_95054", "Remove all unused labels"), Convert_0_to_mapped_object_type: t(95055, e.DiagnosticCategory.Message, "Convert_0_to_mapped_object_type_95055", "Convert '{0}' to mapped object type"), Convert_namespace_import_to_named_imports: t(95056, e.DiagnosticCategory.Message, "Convert_namespace_import_to_named_imports_95056", "Convert namespace import to named imports"), Convert_named_imports_to_namespace_import: t(95057, e.DiagnosticCategory.Message, "Convert_named_imports_to_namespace_import_95057", "Convert named imports to namespace import"), Add_or_remove_braces_in_an_arrow_function: t(95058, e.DiagnosticCategory.Message, "Add_or_remove_braces_in_an_arrow_function_95058", "Add or remove braces in an arrow function"), Add_braces_to_arrow_function: t(95059, e.DiagnosticCategory.Message, "Add_braces_to_arrow_function_95059", "Add braces to arrow function"), Remove_braces_from_arrow_function: t(95060, e.DiagnosticCategory.Message, "Remove_braces_from_arrow_function_95060", "Remove braces from arrow function"), Convert_default_export_to_named_export: t(95061, e.DiagnosticCategory.Message, "Convert_default_export_to_named_export_95061", "Convert default export to named export"), Convert_named_export_to_default_export: t(95062, e.DiagnosticCategory.Message, "Convert_named_export_to_default_export_95062", "Convert named export to default export"), Add_missing_enum_member_0: t(95063, e.DiagnosticCategory.Message, "Add_missing_enum_member_0_95063", "Add missing enum member '{0}'"), Add_all_missing_imports: t(95064, e.DiagnosticCategory.Message, "Add_all_missing_imports_95064", "Add all missing imports"), Convert_to_async_function: t(95065, e.DiagnosticCategory.Message, "Convert_to_async_function_95065", "Convert to async function"), Convert_all_to_async_functions: t(95066, e.DiagnosticCategory.Message, "Convert_all_to_async_functions_95066", "Convert all to async functions"), Add_missing_call_parentheses: t(95067, e.DiagnosticCategory.Message, "Add_missing_call_parentheses_95067", "Add missing call parentheses"), Add_all_missing_call_parentheses: t(95068, e.DiagnosticCategory.Message, "Add_all_missing_call_parentheses_95068", "Add all missing call parentheses"), Add_unknown_conversion_for_non_overlapping_types: t(95069, e.DiagnosticCategory.Message, "Add_unknown_conversion_for_non_overlapping_types_95069", "Add 'unknown' conversion for non-overlapping types"), Add_unknown_to_all_conversions_of_non_overlapping_types: t(95070, e.DiagnosticCategory.Message, "Add_unknown_to_all_conversions_of_non_overlapping_types_95070", "Add 'unknown' to all conversions of non-overlapping types"), Add_missing_new_operator_to_call: t(95071, e.DiagnosticCategory.Message, "Add_missing_new_operator_to_call_95071", "Add missing 'new' operator to call"), Add_missing_new_operator_to_all_calls: t(95072, e.DiagnosticCategory.Message, "Add_missing_new_operator_to_all_calls_95072", "Add missing 'new' operator to all calls"), Add_names_to_all_parameters_without_names: t(95073, e.DiagnosticCategory.Message, "Add_names_to_all_parameters_without_names_95073", "Add names to all parameters without names"), Enable_the_experimentalDecorators_option_in_your_configuration_file: t(95074, e.DiagnosticCategory.Message, "Enable_the_experimentalDecorators_option_in_your_configuration_file_95074", "Enable the 'experimentalDecorators' option in your configuration file"), Convert_parameters_to_destructured_object: t(95075, e.DiagnosticCategory.Message, "Convert_parameters_to_destructured_object_95075", "Convert parameters to destructured object"), Extract_type: t(95077, e.DiagnosticCategory.Message, "Extract_type_95077", "Extract type"), Extract_to_type_alias: t(95078, e.DiagnosticCategory.Message, "Extract_to_type_alias_95078", "Extract to type alias"), Extract_to_typedef: t(95079, e.DiagnosticCategory.Message, "Extract_to_typedef_95079", "Extract to typedef"), Infer_this_type_of_0_from_usage: t(95080, e.DiagnosticCategory.Message, "Infer_this_type_of_0_from_usage_95080", "Infer 'this' type of '{0}' from usage"), Add_const_to_unresolved_variable: t(95081, e.DiagnosticCategory.Message, "Add_const_to_unresolved_variable_95081", "Add 'const' to unresolved variable"), Add_const_to_all_unresolved_variables: t(95082, e.DiagnosticCategory.Message, "Add_const_to_all_unresolved_variables_95082", "Add 'const' to all unresolved variables"), Add_await: t(95083, e.DiagnosticCategory.Message, "Add_await_95083", "Add 'await'"), Add_await_to_initializer_for_0: t(95084, e.DiagnosticCategory.Message, "Add_await_to_initializer_for_0_95084", "Add 'await' to initializer for '{0}'"), Fix_all_expressions_possibly_missing_await: t(95085, e.DiagnosticCategory.Message, "Fix_all_expressions_possibly_missing_await_95085", "Fix all expressions possibly missing 'await'"), Remove_unnecessary_await: t(95086, e.DiagnosticCategory.Message, "Remove_unnecessary_await_95086", "Remove unnecessary 'await'"), Remove_all_unnecessary_uses_of_await: t(95087, e.DiagnosticCategory.Message, "Remove_all_unnecessary_uses_of_await_95087", "Remove all unnecessary uses of 'await'"), Enable_the_jsx_flag_in_your_configuration_file: t(95088, e.DiagnosticCategory.Message, "Enable_the_jsx_flag_in_your_configuration_file_95088", "Enable the '--jsx' flag in your configuration file"), Add_await_to_initializers: t(95089, e.DiagnosticCategory.Message, "Add_await_to_initializers_95089", "Add 'await' to initializers"), Extract_to_interface: t(95090, e.DiagnosticCategory.Message, "Extract_to_interface_95090", "Extract to interface"), Convert_to_a_bigint_numeric_literal: t(95091, e.DiagnosticCategory.Message, "Convert_to_a_bigint_numeric_literal_95091", "Convert to a bigint numeric literal"), Convert_all_to_bigint_numeric_literals: t(95092, e.DiagnosticCategory.Message, "Convert_all_to_bigint_numeric_literals_95092", "Convert all to bigint numeric literals"), Convert_const_to_let: t(95093, e.DiagnosticCategory.Message, "Convert_const_to_let_95093", "Convert 'const' to 'let'"), Prefix_with_declare: t(95094, e.DiagnosticCategory.Message, "Prefix_with_declare_95094", "Prefix with 'declare'"), Prefix_all_incorrect_property_declarations_with_declare: t(95095, e.DiagnosticCategory.Message, "Prefix_all_incorrect_property_declarations_with_declare_95095", "Prefix all incorrect property declarations with 'declare'"), Convert_to_template_string: t(95096, e.DiagnosticCategory.Message, "Convert_to_template_string_95096", "Convert to template string"), Add_export_to_make_this_file_into_a_module: t(95097, e.DiagnosticCategory.Message, "Add_export_to_make_this_file_into_a_module_95097", "Add 'export {}' to make this file into a module"), Set_the_target_option_in_your_configuration_file_to_0: t(95098, e.DiagnosticCategory.Message, "Set_the_target_option_in_your_configuration_file_to_0_95098", "Set the 'target' option in your configuration file to '{0}'"), Set_the_module_option_in_your_configuration_file_to_0: t(95099, e.DiagnosticCategory.Message, "Set_the_module_option_in_your_configuration_file_to_0_95099", "Set the 'module' option in your configuration file to '{0}'"), Convert_invalid_character_to_its_html_entity_code: t(95100, e.DiagnosticCategory.Message, "Convert_invalid_character_to_its_html_entity_code_95100", "Convert invalid character to its html entity code"), Convert_all_invalid_characters_to_HTML_entity_code: t(95101, e.DiagnosticCategory.Message, "Convert_all_invalid_characters_to_HTML_entity_code_95101", "Convert all invalid characters to HTML entity code"), Convert_all_const_to_let: t(95102, e.DiagnosticCategory.Message, "Convert_all_const_to_let_95102", "Convert all 'const' to 'let'"), Convert_function_expression_0_to_arrow_function: t(95105, e.DiagnosticCategory.Message, "Convert_function_expression_0_to_arrow_function_95105", "Convert function expression '{0}' to arrow function"), Convert_function_declaration_0_to_arrow_function: t(95106, e.DiagnosticCategory.Message, "Convert_function_declaration_0_to_arrow_function_95106", "Convert function declaration '{0}' to arrow function"), Fix_all_implicit_this_errors: t(95107, e.DiagnosticCategory.Message, "Fix_all_implicit_this_errors_95107", "Fix all implicit-'this' errors"), Wrap_invalid_character_in_an_expression_container: t(95108, e.DiagnosticCategory.Message, "Wrap_invalid_character_in_an_expression_container_95108", "Wrap invalid character in an expression container"), Wrap_all_invalid_characters_in_an_expression_container: t(95109, e.DiagnosticCategory.Message, "Wrap_all_invalid_characters_in_an_expression_container_95109", "Wrap all invalid characters in an expression container"), Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file: t(95110, e.DiagnosticCategory.Message, "Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file_95110", "Visit https://aka.ms/tsconfig to read more about this file"), Add_a_return_statement: t(95111, e.DiagnosticCategory.Message, "Add_a_return_statement_95111", "Add a return statement"), Remove_braces_from_arrow_function_body: t(95112, e.DiagnosticCategory.Message, "Remove_braces_from_arrow_function_body_95112", "Remove braces from arrow function body"), Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal: t(95113, e.DiagnosticCategory.Message, "Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal_95113", "Wrap the following body with parentheses which should be an object literal"), Add_all_missing_return_statement: t(95114, e.DiagnosticCategory.Message, "Add_all_missing_return_statement_95114", "Add all missing return statement"), Remove_braces_from_all_arrow_function_bodies_with_relevant_issues: t(95115, e.DiagnosticCategory.Message, "Remove_braces_from_all_arrow_function_bodies_with_relevant_issues_95115", "Remove braces from all arrow function bodies with relevant issues"), Wrap_all_object_literal_with_parentheses: t(95116, e.DiagnosticCategory.Message, "Wrap_all_object_literal_with_parentheses_95116", "Wrap all object literal with parentheses"), Move_labeled_tuple_element_modifiers_to_labels: t(95117, e.DiagnosticCategory.Message, "Move_labeled_tuple_element_modifiers_to_labels_95117", "Move labeled tuple element modifiers to labels"), Convert_overload_list_to_single_signature: t(95118, e.DiagnosticCategory.Message, "Convert_overload_list_to_single_signature_95118", "Convert overload list to single signature"), Generate_get_and_set_accessors_for_all_overriding_properties: t(95119, e.DiagnosticCategory.Message, "Generate_get_and_set_accessors_for_all_overriding_properties_95119", "Generate 'get' and 'set' accessors for all overriding properties"), Wrap_in_JSX_fragment: t(95120, e.DiagnosticCategory.Message, "Wrap_in_JSX_fragment_95120", "Wrap in JSX fragment"), Wrap_all_unparented_JSX_in_JSX_fragment: t(95121, e.DiagnosticCategory.Message, "Wrap_all_unparented_JSX_in_JSX_fragment_95121", "Wrap all unparented JSX in JSX fragment"), Convert_arrow_function_or_function_expression: t(95122, e.DiagnosticCategory.Message, "Convert_arrow_function_or_function_expression_95122", "Convert arrow function or function expression"), Convert_to_anonymous_function: t(95123, e.DiagnosticCategory.Message, "Convert_to_anonymous_function_95123", "Convert to anonymous function"), Convert_to_named_function: t(95124, e.DiagnosticCategory.Message, "Convert_to_named_function_95124", "Convert to named function"), Convert_to_arrow_function: t(95125, e.DiagnosticCategory.Message, "Convert_to_arrow_function_95125", "Convert to arrow function"), Remove_parentheses: t(95126, e.DiagnosticCategory.Message, "Remove_parentheses_95126", "Remove parentheses"), Could_not_find_a_containing_arrow_function: t(95127, e.DiagnosticCategory.Message, "Could_not_find_a_containing_arrow_function_95127", "Could not find a containing arrow function"), Containing_function_is_not_an_arrow_function: t(95128, e.DiagnosticCategory.Message, "Containing_function_is_not_an_arrow_function_95128", "Containing function is not an arrow function"), Could_not_find_export_statement: t(95129, e.DiagnosticCategory.Message, "Could_not_find_export_statement_95129", "Could not find export statement"), This_file_already_has_a_default_export: t(95130, e.DiagnosticCategory.Message, "This_file_already_has_a_default_export_95130", "This file already has a default export"), Could_not_find_import_clause: t(95131, e.DiagnosticCategory.Message, "Could_not_find_import_clause_95131", "Could not find import clause"), Could_not_find_namespace_import_or_named_imports: t(95132, e.DiagnosticCategory.Message, "Could_not_find_namespace_import_or_named_imports_95132", "Could not find namespace import or named imports"), Selection_is_not_a_valid_type_node: t(95133, e.DiagnosticCategory.Message, "Selection_is_not_a_valid_type_node_95133", "Selection is not a valid type node"), No_type_could_be_extracted_from_this_type_node: t(95134, e.DiagnosticCategory.Message, "No_type_could_be_extracted_from_this_type_node_95134", "No type could be extracted from this type node"), Could_not_find_property_for_which_to_generate_accessor: t(95135, e.DiagnosticCategory.Message, "Could_not_find_property_for_which_to_generate_accessor_95135", "Could not find property for which to generate accessor"), Name_is_not_valid: t(95136, e.DiagnosticCategory.Message, "Name_is_not_valid_95136", "Name is not valid"), Can_only_convert_property_with_modifier: t(95137, e.DiagnosticCategory.Message, "Can_only_convert_property_with_modifier_95137", "Can only convert property with modifier"), Switch_each_misused_0_to_1: t(95138, e.DiagnosticCategory.Message, "Switch_each_misused_0_to_1_95138", "Switch each misused '{0}' to '{1}'"), Convert_to_optional_chain_expression: t(95139, e.DiagnosticCategory.Message, "Convert_to_optional_chain_expression_95139", "Convert to optional chain expression"), Could_not_find_convertible_access_expression: t(95140, e.DiagnosticCategory.Message, "Could_not_find_convertible_access_expression_95140", "Could not find convertible access expression"), Could_not_find_matching_access_expressions: t(95141, e.DiagnosticCategory.Message, "Could_not_find_matching_access_expressions_95141", "Could not find matching access expressions"), Can_only_convert_logical_AND_access_chains: t(95142, e.DiagnosticCategory.Message, "Can_only_convert_logical_AND_access_chains_95142", "Can only convert logical AND access chains"), Add_void_to_Promise_resolved_without_a_value: t(95143, e.DiagnosticCategory.Message, "Add_void_to_Promise_resolved_without_a_value_95143", "Add 'void' to Promise resolved without a value"), Add_void_to_all_Promises_resolved_without_a_value: t(95144, e.DiagnosticCategory.Message, "Add_void_to_all_Promises_resolved_without_a_value_95144", "Add 'void' to all Promises resolved without a value"), Use_element_access_for_0: t(95145, e.DiagnosticCategory.Message, "Use_element_access_for_0_95145", "Use element access for '{0}'"), Use_element_access_for_all_undeclared_properties: t(95146, e.DiagnosticCategory.Message, "Use_element_access_for_all_undeclared_properties_95146", "Use element access for all undeclared properties."), Delete_all_unused_imports: t(95147, e.DiagnosticCategory.Message, "Delete_all_unused_imports_95147", "Delete all unused imports"), Infer_function_return_type: t(95148, e.DiagnosticCategory.Message, "Infer_function_return_type_95148", "Infer function return type"), Return_type_must_be_inferred_from_a_function: t(95149, e.DiagnosticCategory.Message, "Return_type_must_be_inferred_from_a_function_95149", "Return type must be inferred from a function"), Could_not_determine_function_return_type: t(95150, e.DiagnosticCategory.Message, "Could_not_determine_function_return_type_95150", "Could not determine function return type"), Could_not_convert_to_arrow_function: t(95151, e.DiagnosticCategory.Message, "Could_not_convert_to_arrow_function_95151", "Could not convert to arrow function"), Could_not_convert_to_named_function: t(95152, e.DiagnosticCategory.Message, "Could_not_convert_to_named_function_95152", "Could not convert to named function"), Could_not_convert_to_anonymous_function: t(95153, e.DiagnosticCategory.Message, "Could_not_convert_to_anonymous_function_95153", "Could not convert to anonymous function"), Can_only_convert_string_concatenation: t(95154, e.DiagnosticCategory.Message, "Can_only_convert_string_concatenation_95154", "Can only convert string concatenation"), Selection_is_not_a_valid_statement_or_statements: t(95155, e.DiagnosticCategory.Message, "Selection_is_not_a_valid_statement_or_statements_95155", "Selection is not a valid statement or statements"), Add_missing_function_declaration_0: t(95156, e.DiagnosticCategory.Message, "Add_missing_function_declaration_0_95156", "Add missing function declaration '{0}'"), Add_all_missing_function_declarations: t(95157, e.DiagnosticCategory.Message, "Add_all_missing_function_declarations_95157", "Add all missing function declarations"), Method_not_implemented: t(95158, e.DiagnosticCategory.Message, "Method_not_implemented_95158", "Method not implemented."), Function_not_implemented: t(95159, e.DiagnosticCategory.Message, "Function_not_implemented_95159", "Function not implemented."), Add_override_modifier: t(95160, e.DiagnosticCategory.Message, "Add_override_modifier_95160", "Add 'override' modifier"), Remove_override_modifier: t(95161, e.DiagnosticCategory.Message, "Remove_override_modifier_95161", "Remove 'override' modifier"), Add_all_missing_override_modifiers: t(95162, e.DiagnosticCategory.Message, "Add_all_missing_override_modifiers_95162", "Add all missing 'override' modifiers"), Remove_all_unnecessary_override_modifiers: t(95163, e.DiagnosticCategory.Message, "Remove_all_unnecessary_override_modifiers_95163", "Remove all unnecessary 'override' modifiers"), Can_only_convert_named_export: t(95164, e.DiagnosticCategory.Message, "Can_only_convert_named_export_95164", "Can only convert named export"), Add_missing_properties: t(95165, e.DiagnosticCategory.Message, "Add_missing_properties_95165", "Add missing properties"), Add_all_missing_properties: t(95166, e.DiagnosticCategory.Message, "Add_all_missing_properties_95166", "Add all missing properties"), Add_missing_attributes: t(95167, e.DiagnosticCategory.Message, "Add_missing_attributes_95167", "Add missing attributes"), Add_all_missing_attributes: t(95168, e.DiagnosticCategory.Message, "Add_all_missing_attributes_95168", "Add all missing attributes"), Add_undefined_to_optional_property_type: t(95169, e.DiagnosticCategory.Message, "Add_undefined_to_optional_property_type_95169", "Add 'undefined' to optional property type"), Convert_named_imports_to_default_import: t(95170, e.DiagnosticCategory.Message, "Convert_named_imports_to_default_import_95170", "Convert named imports to default import"), Delete_unused_param_tag_0: t(95171, e.DiagnosticCategory.Message, "Delete_unused_param_tag_0_95171", "Delete unused '@param' tag '{0}'"), Delete_all_unused_param_tags: t(95172, e.DiagnosticCategory.Message, "Delete_all_unused_param_tags_95172", "Delete all unused '@param' tags"), Rename_param_tag_name_0_to_1: t(95173, e.DiagnosticCategory.Message, "Rename_param_tag_name_0_to_1_95173", "Rename '@param' tag name '{0}' to '{1}'"), Use_0: t(95174, e.DiagnosticCategory.Message, "Use_0_95174", "Use `{0}`."), Use_Number_isNaN_in_all_conditions: t(95175, e.DiagnosticCategory.Message, "Use_Number_isNaN_in_all_conditions_95175", "Use `Number.isNaN` in all conditions."), No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer: t(18004, e.DiagnosticCategory.Error, "No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer_18004", "No value exists in scope for the shorthand property '{0}'. Either declare one or provide an initializer."), Classes_may_not_have_a_field_named_constructor: t(18006, e.DiagnosticCategory.Error, "Classes_may_not_have_a_field_named_constructor_18006", "Classes may not have a field named 'constructor'."), JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array: t(18007, e.DiagnosticCategory.Error, "JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array_18007", "JSX expressions may not use the comma operator. Did you mean to write an array?"), Private_identifiers_cannot_be_used_as_parameters: t(18009, e.DiagnosticCategory.Error, "Private_identifiers_cannot_be_used_as_parameters_18009", "Private identifiers cannot be used as parameters."), An_accessibility_modifier_cannot_be_used_with_a_private_identifier: t(18010, e.DiagnosticCategory.Error, "An_accessibility_modifier_cannot_be_used_with_a_private_identifier_18010", "An accessibility modifier cannot be used with a private identifier."), The_operand_of_a_delete_operator_cannot_be_a_private_identifier: t(18011, e.DiagnosticCategory.Error, "The_operand_of_a_delete_operator_cannot_be_a_private_identifier_18011", "The operand of a 'delete' operator cannot be a private identifier."), constructor_is_a_reserved_word: t(18012, e.DiagnosticCategory.Error, "constructor_is_a_reserved_word_18012", "'#constructor' is a reserved word."), Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier: t(18013, e.DiagnosticCategory.Error, "Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier_18013", "Property '{0}' is not accessible outside class '{1}' because it has a private identifier."), The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling: t(18014, e.DiagnosticCategory.Error, "The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_priv_18014", "The property '{0}' cannot be accessed on type '{1}' within this class because it is shadowed by another private identifier with the same spelling."), Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2: t(18015, e.DiagnosticCategory.Error, "Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2_18015", "Property '{0}' in type '{1}' refers to a different member that cannot be accessed from within type '{2}'."), Private_identifiers_are_not_allowed_outside_class_bodies: t(18016, e.DiagnosticCategory.Error, "Private_identifiers_are_not_allowed_outside_class_bodies_18016", "Private identifiers are not allowed outside class bodies."), The_shadowing_declaration_of_0_is_defined_here: t(18017, e.DiagnosticCategory.Error, "The_shadowing_declaration_of_0_is_defined_here_18017", "The shadowing declaration of '{0}' is defined here"), The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here: t(18018, e.DiagnosticCategory.Error, "The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here_18018", "The declaration of '{0}' that you probably intended to use is defined here"), _0_modifier_cannot_be_used_with_a_private_identifier: t(18019, e.DiagnosticCategory.Error, "_0_modifier_cannot_be_used_with_a_private_identifier_18019", "'{0}' modifier cannot be used with a private identifier."), An_enum_member_cannot_be_named_with_a_private_identifier: t(18024, e.DiagnosticCategory.Error, "An_enum_member_cannot_be_named_with_a_private_identifier_18024", "An enum member cannot be named with a private identifier."), can_only_be_used_at_the_start_of_a_file: t(18026, e.DiagnosticCategory.Error, "can_only_be_used_at_the_start_of_a_file_18026", "'#!' can only be used at the start of a file."), Compiler_reserves_name_0_when_emitting_private_identifier_downlevel: t(18027, e.DiagnosticCategory.Error, "Compiler_reserves_name_0_when_emitting_private_identifier_downlevel_18027", "Compiler reserves name '{0}' when emitting private identifier downlevel."), Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher: t(18028, e.DiagnosticCategory.Error, "Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher_18028", "Private identifiers are only available when targeting ECMAScript 2015 and higher."), Private_identifiers_are_not_allowed_in_variable_declarations: t(18029, e.DiagnosticCategory.Error, "Private_identifiers_are_not_allowed_in_variable_declarations_18029", "Private identifiers are not allowed in variable declarations."), An_optional_chain_cannot_contain_private_identifiers: t(18030, e.DiagnosticCategory.Error, "An_optional_chain_cannot_contain_private_identifiers_18030", "An optional chain cannot contain private identifiers."), The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents: t(18031, e.DiagnosticCategory.Error, "The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituent_18031", "The intersection '{0}' was reduced to 'never' because property '{1}' has conflicting types in some constituents."), The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some: t(18032, e.DiagnosticCategory.Error, "The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_pr_18032", "The intersection '{0}' was reduced to 'never' because property '{1}' exists in multiple constituents and is private in some."), Only_numeric_enums_can_have_computed_members_but_this_expression_has_type_0_If_you_do_not_need_exhaustiveness_checks_consider_using_an_object_literal_instead: t(18033, e.DiagnosticCategory.Error, "Only_numeric_enums_can_have_computed_members_but_this_expression_has_type_0_If_you_do_not_need_exhau_18033", "Only numeric enums can have computed members, but this expression has type '{0}'. If you do not need exhaustiveness checks, consider using an object literal instead."), Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compiler_option_is_specified_e_g_Fragment: t(18034, e.DiagnosticCategory.Message, "Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compi_18034", "Specify the JSX fragment factory function to use when targeting 'react' JSX emit with 'jsxFactory' compiler option is specified, e.g. 'Fragment'."), Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name: t(18035, e.DiagnosticCategory.Error, "Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name_18035", "Invalid value for 'jsxFragmentFactory'. '{0}' is not a valid identifier or qualified-name."), Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator: t(18036, e.DiagnosticCategory.Error, "Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_dec_18036", "Class decorators can't be used with static private identifier. Consider removing the experimental decorator."), Await_expression_cannot_be_used_inside_a_class_static_block: t(18037, e.DiagnosticCategory.Error, "Await_expression_cannot_be_used_inside_a_class_static_block_18037", "Await expression cannot be used inside a class static block."), For_await_loops_cannot_be_used_inside_a_class_static_block: t(18038, e.DiagnosticCategory.Error, "For_await_loops_cannot_be_used_inside_a_class_static_block_18038", "'For await' loops cannot be used inside a class static block."), Invalid_use_of_0_It_cannot_be_used_inside_a_class_static_block: t(18039, e.DiagnosticCategory.Error, "Invalid_use_of_0_It_cannot_be_used_inside_a_class_static_block_18039", "Invalid use of '{0}'. It cannot be used inside a class static block."), A_return_statement_cannot_be_used_inside_a_class_static_block: t(18041, e.DiagnosticCategory.Error, "A_return_statement_cannot_be_used_inside_a_class_static_block_18041", "A 'return' statement cannot be used inside a class static block."), _0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation: t(18042, e.DiagnosticCategory.Error, "_0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation_18042", "'{0}' is a type and cannot be imported in JavaScript files. Use '{1}' in a JSDoc type annotation."), Types_cannot_appear_in_export_declarations_in_JavaScript_files: t(18043, e.DiagnosticCategory.Error, "Types_cannot_appear_in_export_declarations_in_JavaScript_files_18043", "Types cannot appear in export declarations in JavaScript files."), _0_is_automatically_exported_here: t(18044, e.DiagnosticCategory.Message, "_0_is_automatically_exported_here_18044", "'{0}' is automatically exported here."), Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher: t(18045, e.DiagnosticCategory.Error, "Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher_18045", "Properties with the 'accessor' modifier are only available when targeting ECMAScript 2015 and higher."), _0_is_of_type_unknown: t(18046, e.DiagnosticCategory.Error, "_0_is_of_type_unknown_18046", "'{0}' is of type 'unknown'."), _0_is_possibly_null: t(18047, e.DiagnosticCategory.Error, "_0_is_possibly_null_18047", "'{0}' is possibly 'null'."), _0_is_possibly_undefined: t(18048, e.DiagnosticCategory.Error, "_0_is_possibly_undefined_18048", "'{0}' is possibly 'undefined'."), _0_is_possibly_null_or_undefined: t(18049, e.DiagnosticCategory.Error, "_0_is_possibly_null_or_undefined_18049", "'{0}' is possibly 'null' or 'undefined'."), The_value_0_cannot_be_used_here: t(18050, e.DiagnosticCategory.Error, "The_value_0_cannot_be_used_here_18050", "The value '{0}' cannot be used here.") };
          })(N || (N = {}));
          var N;
          (function(e) {
            var t;
            function x(f) {
              return f >= 79;
            }
            __name(x, "x");
            e.tokenIsIdentifierOrKeyword = x;
            function s(f) {
              return f === 31 || x(f);
            }
            __name(s, "s");
            e.tokenIsIdentifierOrKeywordOrGreaterThan = s, e.textToKeywordObj = (t = { abstract: 126, accessor: 127, any: 131, as: 128, asserts: 129, assert: 130, bigint: 160, boolean: 134, break: 81, case: 82, catch: 83, class: 84, continue: 86, const: 85 }, t.constructor = 135, t.debugger = 87, t.declare = 136, t.default = 88, t.delete = 89, t.do = 90, t.else = 91, t.enum = 92, t.export = 93, t.extends = 94, t.false = 95, t.finally = 96, t.for = 97, t.from = 158, t.function = 98, t.get = 137, t.if = 99, t.implements = 117, t.import = 100, t.in = 101, t.infer = 138, t.instanceof = 102, t.interface = 118, t.intrinsic = 139, t.is = 140, t.keyof = 141, t.let = 119, t.module = 142, t.namespace = 143, t.never = 144, t.new = 103, t.null = 104, t.number = 148, t.object = 149, t.package = 120, t.private = 121, t.protected = 122, t.public = 123, t.override = 161, t.out = 145, t.readonly = 146, t.require = 147, t.global = 159, t.return = 105, t.satisfies = 150, t.set = 151, t.static = 124, t.string = 152, t.super = 106, t.switch = 107, t.symbol = 153, t.this = 108, t.throw = 109, t.true = 110, t.try = 111, t.type = 154, t.typeof = 112, t.undefined = 155, t.unique = 156, t.unknown = 157, t.var = 113, t.void = 114, t.while = 115, t.with = 116, t.yield = 125, t.async = 132, t.await = 133, t.of = 162, t);
            var q = new e.Map(e.getEntries(e.textToKeywordObj)), F = new e.Map(e.getEntries(T(T({}, e.textToKeywordObj), { "{": 18, "}": 19, "(": 20, ")": 21, "[": 22, "]": 23, ".": 24, "...": 25, ";": 26, ",": 27, "<": 29, ">": 31, "<=": 32, ">=": 33, "==": 34, "!=": 35, "===": 36, "!==": 37, "=>": 38, "+": 39, "-": 40, "**": 42, "*": 41, "/": 43, "%": 44, "++": 45, "--": 46, "<<": 47, "</": 30, ">>": 48, ">>>": 49, "&": 50, "|": 51, "^": 52, "!": 53, "~": 54, "&&": 55, "||": 56, "?": 57, "??": 60, "?.": 28, ":": 58, "=": 63, "+=": 64, "-=": 65, "*=": 66, "**=": 67, "/=": 68, "%=": 69, "<<=": 70, ">>=": 71, ">>>=": 72, "&=": 73, "|=": 74, "^=": 78, "||=": 75, "&&=": 76, "??=": 77, "@": 59, "#": 62, "`": 61 }))), fe = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500], Te = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500], Se = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6e3, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43e3, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500], J = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6e3, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43e3, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500], se = [65, 90, 97, 122, 170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 895, 895, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1488, 1514, 1519, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2144, 2154, 2208, 2228, 2230, 2237, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2432, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2556, 2556, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2809, 2809, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3133, 3160, 3162, 3168, 3169, 3200, 3200, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3412, 3414, 3423, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6e3, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6264, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6430, 6480, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7401, 7404, 7406, 7411, 7413, 7414, 7418, 7418, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12443, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40943, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42653, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42943, 42946, 42950, 42999, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43261, 43262, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43488, 43492, 43494, 43503, 43514, 43518, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43646, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43879, 43888, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66176, 66204, 66208, 66256, 66304, 66335, 66349, 66378, 66384, 66421, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68096, 68112, 68115, 68117, 68119, 68121, 68149, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68324, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68899, 69376, 69404, 69415, 69415, 69424, 69445, 69600, 69622, 69635, 69687, 69763, 69807, 69840, 69864, 69891, 69926, 69956, 69956, 69968, 70002, 70006, 70006, 70019, 70066, 70081, 70084, 70106, 70106, 70108, 70108, 70144, 70161, 70163, 70187, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70366, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70461, 70461, 70480, 70480, 70493, 70497, 70656, 70708, 70727, 70730, 70751, 70751, 70784, 70831, 70852, 70853, 70855, 70855, 71040, 71086, 71128, 71131, 71168, 71215, 71236, 71236, 71296, 71338, 71352, 71352, 71424, 71450, 71680, 71723, 71840, 71903, 71935, 71935, 72096, 72103, 72106, 72144, 72161, 72161, 72163, 72163, 72192, 72192, 72203, 72242, 72250, 72250, 72272, 72272, 72284, 72329, 72349, 72349, 72384, 72440, 72704, 72712, 72714, 72750, 72768, 72768, 72818, 72847, 72960, 72966, 72968, 72969, 72971, 73008, 73030, 73030, 73056, 73061, 73063, 73064, 73066, 73097, 73112, 73112, 73440, 73458, 73728, 74649, 74752, 74862, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92766, 92880, 92909, 92928, 92975, 92992, 92995, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94032, 94032, 94099, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101106, 110592, 110878, 110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 123136, 123180, 123191, 123197, 123214, 123214, 123584, 123627, 124928, 125124, 125184, 125251, 125259, 125259, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101], Le = [48, 57, 65, 90, 95, 95, 97, 122, 170, 170, 181, 181, 183, 183, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 895, 895, 902, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1519, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2045, 2045, 2048, 2093, 2112, 2139, 2144, 2154, 2208, 2228, 2230, 2237, 2259, 2273, 2275, 2403, 2406, 2415, 2417, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2556, 2556, 2558, 2558, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2809, 2815, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3072, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3162, 3168, 3171, 3174, 3183, 3200, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3328, 3331, 3333, 3340, 3342, 3344, 3346, 3396, 3398, 3400, 3402, 3406, 3412, 3415, 3423, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3558, 3567, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4969, 4977, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6e3, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6264, 6272, 6314, 6320, 6389, 6400, 6430, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6618, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6832, 6845, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7376, 7378, 7380, 7418, 7424, 7673, 7675, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40943, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42737, 42775, 42783, 42786, 42888, 42891, 42943, 42946, 42950, 42999, 43047, 43072, 43123, 43136, 43205, 43216, 43225, 43232, 43255, 43259, 43259, 43261, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43488, 43518, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43879, 43888, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65071, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66045, 66045, 66176, 66204, 66208, 66256, 66272, 66272, 66304, 66335, 66349, 66378, 66384, 66426, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68099, 68101, 68102, 68108, 68115, 68117, 68119, 68121, 68149, 68152, 68154, 68159, 68159, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68326, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68903, 68912, 68921, 69376, 69404, 69415, 69415, 69424, 69456, 69600, 69622, 69632, 69702, 69734, 69743, 69759, 69818, 69840, 69864, 69872, 69881, 69888, 69940, 69942, 69951, 69956, 69958, 69968, 70003, 70006, 70006, 70016, 70084, 70089, 70092, 70096, 70106, 70108, 70108, 70144, 70161, 70163, 70199, 70206, 70206, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70378, 70384, 70393, 70400, 70403, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70459, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70730, 70736, 70745, 70750, 70751, 70784, 70853, 70855, 70855, 70864, 70873, 71040, 71093, 71096, 71104, 71128, 71133, 71168, 71232, 71236, 71236, 71248, 71257, 71296, 71352, 71360, 71369, 71424, 71450, 71453, 71467, 71472, 71481, 71680, 71738, 71840, 71913, 71935, 71935, 72096, 72103, 72106, 72151, 72154, 72161, 72163, 72164, 72192, 72254, 72263, 72263, 72272, 72345, 72349, 72349, 72384, 72440, 72704, 72712, 72714, 72758, 72760, 72768, 72784, 72793, 72818, 72847, 72850, 72871, 72873, 72886, 72960, 72966, 72968, 72969, 72971, 73014, 73018, 73018, 73020, 73021, 73023, 73031, 73040, 73049, 73056, 73061, 73063, 73064, 73066, 73102, 73104, 73105, 73107, 73112, 73120, 73129, 73440, 73462, 73728, 74649, 74752, 74862, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92766, 92768, 92777, 92880, 92909, 92912, 92916, 92928, 92982, 92992, 92995, 93008, 93017, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94031, 94087, 94095, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101106, 110592, 110878, 110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113821, 113822, 119141, 119145, 119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213, 119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 120782, 120831, 121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476, 121499, 121503, 121505, 121519, 122880, 122886, 122888, 122904, 122907, 122913, 122915, 122916, 122918, 122922, 123136, 123180, 123184, 123197, 123200, 123209, 123214, 123214, 123584, 123641, 124928, 125124, 125136, 125142, 125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 917760, 917999], Q = /^\/\/\/?\s*@(ts-expect-error|ts-ignore)/, Be = /^(?:\/|\*)*\s*@(ts-expect-error|ts-ignore)/;
            function je(f, h) {
              if (f < h[0])
                return false;
              for (var ae = 0, xr = h.length, jr; ae + 1 < xr; ) {
                if (jr = ae + (xr - ae) / 2, jr -= jr % 2, h[jr] <= f && f <= h[jr + 1])
                  return true;
                f < h[jr] ? xr = jr : ae = jr + 2;
              }
              return false;
            }
            __name(je, "je");
            function W(f, h) {
              return h >= 2 ? je(f, se) : h === 1 ? je(f, Se) : je(f, fe);
            }
            __name(W, "W");
            e.isUnicodeIdentifierStart = W;
            function B(f, h) {
              return h >= 2 ? je(f, Le) : h === 1 ? je(f, J) : je(f, Te);
            }
            __name(B, "B");
            function U(f) {
              var h = [];
              return f.forEach(function(ae, xr) {
                h[ae] = xr;
              }), h;
            }
            __name(U, "U");
            var m = U(F);
            function v(f) {
              return m[f];
            }
            __name(v, "v");
            e.tokenToString = v;
            function g(f) {
              return F.get(f);
            }
            __name(g, "g");
            e.stringToToken = g;
            function O(f) {
              for (var h = [], ae = 0, xr = 0; ae < f.length; ) {
                var jr = f.charCodeAt(ae);
                switch (ae++, jr) {
                  case 13:
                    f.charCodeAt(ae) === 10 && ae++;
                  case 10:
                    h.push(xr), xr = ae;
                    break;
                  default:
                    jr > 127 && be(jr) && (h.push(xr), xr = ae);
                    break;
                }
              }
              return h.push(xr), h;
            }
            __name(O, "O");
            e.computeLineStarts = O;
            function S(f, h, ae, xr) {
              return f.getPositionOfLineAndCharacter ? f.getPositionOfLineAndCharacter(h, ae, xr) : te(Je(f), h, ae, f.text, xr);
            }
            __name(S, "S");
            e.getPositionOfLineAndCharacter = S;
            function te(f, h, ae, xr, jr) {
              (h < 0 || h >= f.length) && (jr ? h = h < 0 ? 0 : h >= f.length ? f.length - 1 : h : e.Debug.fail("Bad line number. Line: ".concat(h, ", lineStarts.length: ").concat(f.length, " , line map is correct? ").concat(xr !== void 0 ? e.arraysEqual(f, O(xr)) : "unknown")));
              var qr = f[h] + ae;
              return jr ? qr > f[h + 1] ? f[h + 1] : typeof xr == "string" && qr > xr.length ? xr.length : qr : (h < f.length - 1 ? e.Debug.assert(qr < f[h + 1]) : xr !== void 0 && e.Debug.assert(qr <= xr.length), qr);
            }
            __name(te, "te");
            e.computePositionOfLineAndCharacter = te;
            function Je(f) {
              return f.lineMap || (f.lineMap = O(f.text));
            }
            __name(Je, "Je");
            e.getLineStarts = Je;
            function qe(f, h) {
              var ae = ge(f, h);
              return { line: ae, character: h - f[ae] };
            }
            __name(qe, "qe");
            e.computeLineAndCharacterOfPosition = qe;
            function ge(f, h, ae) {
              var xr = e.binarySearch(f, h, e.identity, e.compareValues, ae);
              return xr < 0 && (xr = ~xr - 1, e.Debug.assert(xr !== -1, "position cannot precede the beginning of the file")), xr;
            }
            __name(ge, "ge");
            e.computeLineOfPosition = ge;
            function ie(f, h, ae) {
              if (h === ae)
                return 0;
              var xr = Je(f), jr = Math.min(h, ae), qr = jr === ae, pt = qr ? h : ae, Ge = ge(xr, jr), K = ge(xr, pt, Ge);
              return qr ? Ge - K : K - Ge;
            }
            __name(ie, "ie");
            e.getLinesBetweenPositions = ie;
            function G(f, h) {
              return qe(Je(f), h);
            }
            __name(G, "G");
            e.getLineAndCharacterOfPosition = G;
            function pe(f) {
              return j(f) || be(f);
            }
            __name(pe, "pe");
            e.isWhiteSpaceLike = pe;
            function j(f) {
              return f === 32 || f === 9 || f === 11 || f === 12 || f === 160 || f === 133 || f === 5760 || f >= 8192 && f <= 8203 || f === 8239 || f === 8287 || f === 12288 || f === 65279;
            }
            __name(j, "j");
            e.isWhiteSpaceSingleLine = j;
            function be(f) {
              return f === 10 || f === 13 || f === 8232 || f === 8233;
            }
            __name(be, "be");
            e.isLineBreak = be;
            function $e(f) {
              return f >= 48 && f <= 57;
            }
            __name($e, "$e");
            function Re(f) {
              return $e(f) || f >= 65 && f <= 70 || f >= 97 && f <= 102;
            }
            __name(Re, "Re");
            function Fe(f) {
              return f <= 1114111;
            }
            __name(Fe, "Fe");
            function dr(f) {
              return f >= 48 && f <= 55;
            }
            __name(dr, "dr");
            e.isOctalDigit = dr;
            function ze(f, h) {
              var ae = f.charCodeAt(h);
              switch (ae) {
                case 13:
                case 10:
                case 9:
                case 11:
                case 12:
                case 32:
                case 47:
                case 60:
                case 124:
                case 61:
                case 62:
                  return true;
                case 35:
                  return h === 0;
                default:
                  return ae > 127;
              }
            }
            __name(ze, "ze");
            e.couldStartTrivia = ze;
            function ve(f, h, ae, xr, jr) {
              if (e.positionIsSynthesized(h))
                return h;
              for (var qr = false; ; ) {
                var pt = f.charCodeAt(h);
                switch (pt) {
                  case 13:
                    f.charCodeAt(h + 1) === 10 && h++;
                  case 10:
                    if (h++, ae)
                      return h;
                    qr = !!jr;
                    continue;
                  case 9:
                  case 11:
                  case 12:
                  case 32:
                    h++;
                    continue;
                  case 47:
                    if (xr)
                      break;
                    if (f.charCodeAt(h + 1) === 47) {
                      for (h += 2; h < f.length && !be(f.charCodeAt(h)); )
                        h++;
                      qr = false;
                      continue;
                    }
                    if (f.charCodeAt(h + 1) === 42) {
                      for (h += 2; h < f.length; ) {
                        if (f.charCodeAt(h) === 42 && f.charCodeAt(h + 1) === 47) {
                          h += 2;
                          break;
                        }
                        h++;
                      }
                      qr = false;
                      continue;
                    }
                    break;
                  case 60:
                  case 124:
                  case 61:
                  case 62:
                    if (ar(f, h)) {
                      h = Cr(f, h), qr = false;
                      continue;
                    }
                    break;
                  case 35:
                    if (h === 0 && Xe(f, h)) {
                      h = gr(f, h), qr = false;
                      continue;
                    }
                    break;
                  case 42:
                    if (qr) {
                      h++, qr = false;
                      continue;
                    }
                    break;
                  default:
                    if (pt > 127 && pe(pt)) {
                      h++;
                      continue;
                    }
                    break;
                }
                return h;
              }
            }
            __name(ve, "ve");
            e.skipTrivia = ve;
            var er = 7;
            function ar(f, h) {
              if (e.Debug.assert(h >= 0), h === 0 || be(f.charCodeAt(h - 1))) {
                var ae = f.charCodeAt(h);
                if (h + er < f.length) {
                  for (var xr = 0; xr < er; xr++)
                    if (f.charCodeAt(h + xr) !== ae)
                      return false;
                  return ae === 61 || f.charCodeAt(h + er) === 32;
                }
              }
              return false;
            }
            __name(ar, "ar");
            function Cr(f, h, ae) {
              ae && ae(e.Diagnostics.Merge_conflict_marker_encountered, h, er);
              var xr = f.charCodeAt(h), jr = f.length;
              if (xr === 60 || xr === 62)
                for (; h < jr && !be(f.charCodeAt(h)); )
                  h++;
              else
                for (e.Debug.assert(xr === 124 || xr === 61); h < jr; ) {
                  var qr = f.charCodeAt(h);
                  if ((qr === 61 || qr === 62) && qr !== xr && ar(f, h))
                    break;
                  h++;
                }
              return h;
            }
            __name(Cr, "Cr");
            var Ce = /^#!.*/;
            function Xe(f, h) {
              return e.Debug.assert(h === 0), Ce.test(f);
            }
            __name(Xe, "Xe");
            e.isShebangTrivia = Xe;
            function gr(f, h) {
              var ae = Ce.exec(f)[0];
              return h = h + ae.length, h;
            }
            __name(gr, "gr");
            e.scanShebangTrivia = gr;
            function X(f, h, ae, xr, jr, qr, pt) {
              var Ge, K, r, ct, ft = false, Ie = xr, me = pt;
              if (ae === 0) {
                Ie = true;
                var xe = Lr(h);
                xe && (ae = xe.length);
              }
              e:
                for (; ae >= 0 && ae < h.length; ) {
                  var Ye = h.charCodeAt(ae);
                  switch (Ye) {
                    case 13:
                      h.charCodeAt(ae + 1) === 10 && ae++;
                    case 10:
                      if (ae++, xr)
                        break e;
                      Ie = true, ft && (ct = true);
                      continue;
                    case 9:
                    case 11:
                    case 12:
                    case 32:
                      ae++;
                      continue;
                    case 47:
                      var vr = h.charCodeAt(ae + 1), nt = false;
                      if (vr === 47 || vr === 42) {
                        var pr = vr === 47 ? 2 : 3, Mr = ae;
                        if (ae += 2, vr === 47)
                          for (; ae < h.length; ) {
                            if (be(h.charCodeAt(ae))) {
                              nt = true;
                              break;
                            }
                            ae++;
                          }
                        else
                          for (; ae < h.length; ) {
                            if (h.charCodeAt(ae) === 42 && h.charCodeAt(ae + 1) === 47) {
                              ae += 2;
                              break;
                            }
                            ae++;
                          }
                        if (Ie) {
                          if (ft && (me = jr(Ge, K, r, ct, qr, me), !f && me))
                            return me;
                          Ge = Mr, K = ae, r = pr, ct = nt, ft = true;
                        }
                        continue;
                      }
                      break e;
                    default:
                      if (Ye > 127 && pe(Ye)) {
                        ft && be(Ye) && (ct = true), ae++;
                        continue;
                      }
                      break e;
                  }
                }
              return ft && (me = jr(Ge, K, r, ct, qr, me)), me;
            }
            __name(X, "X");
            function Ee(f, h, ae, xr) {
              return X(false, f, h, false, ae, xr);
            }
            __name(Ee, "Ee");
            e.forEachLeadingCommentRange = Ee;
            function we(f, h, ae, xr) {
              return X(false, f, h, true, ae, xr);
            }
            __name(we, "we");
            e.forEachTrailingCommentRange = we;
            function he(f, h, ae, xr, jr) {
              return X(true, f, h, false, ae, xr, jr);
            }
            __name(he, "he");
            e.reduceEachLeadingCommentRange = he;
            function yr(f, h, ae, xr, jr) {
              return X(true, f, h, true, ae, xr, jr);
            }
            __name(yr, "yr");
            e.reduceEachTrailingCommentRange = yr;
            function kr(f, h, ae, xr, jr, qr) {
              return qr || (qr = []), qr.push({ kind: ae, pos: f, end: h, hasTrailingNewLine: xr }), qr;
            }
            __name(kr, "kr");
            function nr(f, h) {
              return he(f, h, kr, void 0, void 0);
            }
            __name(nr, "nr");
            e.getLeadingCommentRanges = nr;
            function tr(f, h) {
              return yr(f, h, kr, void 0, void 0);
            }
            __name(tr, "tr");
            e.getTrailingCommentRanges = tr;
            function Lr(f) {
              var h = Ce.exec(f);
              if (h)
                return h[0];
            }
            __name(Lr, "Lr");
            e.getShebang = Lr;
            function zr(f, h) {
              return f >= 65 && f <= 90 || f >= 97 && f <= 122 || f === 36 || f === 95 || f > 127 && W(f, h);
            }
            __name(zr, "zr");
            e.isIdentifierStart = zr;
            function ye(f, h, ae) {
              return f >= 65 && f <= 90 || f >= 97 && f <= 122 || f >= 48 && f <= 57 || f === 36 || f === 95 || (ae === 1 ? f === 45 || f === 58 : false) || f > 127 && B(f, h);
            }
            __name(ye, "ye");
            e.isIdentifierPart = ye;
            function ir(f, h, ae) {
              var xr = Pr(f, 0);
              if (!zr(xr, h))
                return false;
              for (var jr = Br(xr); jr < f.length; jr += Br(xr))
                if (!ye(xr = Pr(f, jr), h, ae))
                  return false;
              return true;
            }
            __name(ir, "ir");
            e.isIdentifierText = ir;
            function Dr(f, h, ae, xr, jr, qr, pt) {
              ae === void 0 && (ae = 0);
              var Ge = xr, K, r, ct, ft, Ie, me, xe, Ye, vr = 0;
              Zn(Ge, qr, pt);
              var nt = { getStartPos: function() {
                return ct;
              }, getTextPos: function() {
                return K;
              }, getToken: function() {
                return Ie;
              }, getTokenPos: function() {
                return ft;
              }, getTokenText: function() {
                return Ge.substring(ft, K);
              }, getTokenValue: function() {
                return me;
              }, hasUnicodeEscape: function() {
                return (xe & 1024) !== 0;
              }, hasExtendedUnicodeEscape: function() {
                return (xe & 8) !== 0;
              }, hasPrecedingLineBreak: function() {
                return (xe & 1) !== 0;
              }, hasPrecedingJSDocComment: function() {
                return (xe & 2) !== 0;
              }, isIdentifier: function() {
                return Ie === 79 || Ie > 116;
              }, isReservedWord: function() {
                return Ie >= 81 && Ie <= 116;
              }, isUnterminated: function() {
                return (xe & 4) !== 0;
              }, getCommentDirectives: function() {
                return Ye;
              }, getNumericLiteralFlags: function() {
                return xe & 1008;
              }, getTokenFlags: function() {
                return xe;
              }, reScanGreaterToken: Ct, reScanAsteriskEqualsToken: Xt, reScanSlashToken: cn, reScanTemplateToken: hn, reScanTemplateHeadOrNoSubstitutionTemplate: ln, scanJsxIdentifier: ri, scanJsxAttributeValue: bi, reScanJsxAttributeValue: Qn, reScanJsxToken: En, reScanLessThanToken: Vt, reScanHashToken: ui, reScanQuestionToken: ei, reScanInvalidIdentifier: Kr, scanJsxToken: vi, scanJsDocToken: Yn, scan: Sr, getText: si, clearCommentDirectives: mi, setText: Zn, setScriptTarget: gt, setLanguageVariant: gi, setOnError: Fn, setTextPos: dn, setInJSDocType: On, tryScan: Kn, lookAhead: Dn, scanRange: Ei };
              return e.Debug.isDebugging && Object.defineProperty(nt, "__debugShowCurrentPositionInText", { get: function() {
                var br = nt.getText();
                return br.slice(0, nt.getStartPos()) + "\u2551" + br.slice(nt.getStartPos());
              } }), nt;
              function pr(br, Ae, ur) {
                if (Ae === void 0 && (Ae = K), jr) {
                  var L = K;
                  K = Ae, jr(br, ur || 0), K = L;
                }
              }
              __name(pr, "pr");
              function Mr() {
                for (var br = K, Ae = false, ur = false, L = ""; ; ) {
                  var qt = Ge.charCodeAt(K);
                  if (qt === 95) {
                    xe |= 512, Ae ? (Ae = false, ur = true, L += Ge.substring(br, K)) : pr(ur ? e.Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted : e.Diagnostics.Numeric_separators_are_not_allowed_here, K, 1), K++, br = K;
                    continue;
                  }
                  if ($e(qt)) {
                    Ae = true, ur = false, K++;
                    continue;
                  }
                  break;
                }
                return Ge.charCodeAt(K - 1) === 95 && pr(e.Diagnostics.Numeric_separators_are_not_allowed_here, K - 1, 1), L + Ge.substring(br, K);
              }
              __name(Mr, "Mr");
              function ot() {
                var br = K, Ae = Mr(), ur, L;
                Ge.charCodeAt(K) === 46 && (K++, ur = Mr());
                var qt = K;
                if (Ge.charCodeAt(K) === 69 || Ge.charCodeAt(K) === 101) {
                  K++, xe |= 16, (Ge.charCodeAt(K) === 43 || Ge.charCodeAt(K) === 45) && K++;
                  var nn = K, fr = Mr();
                  fr ? (L = Ge.substring(qt, nn) + fr, qt = K) : pr(e.Diagnostics.Digit_expected);
                }
                var Me;
                if (xe & 512 ? (Me = Ae, ur && (Me += "." + ur), L && (Me += L)) : Me = Ge.substring(br, qt), ur !== void 0 || xe & 16)
                  return At(br, ur === void 0 && !!(xe & 16)), { type: 8, value: "" + +Me };
                me = Me;
                var Ve = Qe();
                return At(br), { type: Ve, value: me };
              }
              __name(ot, "ot");
              function At(br, Ae) {
                if (!!zr(Pr(Ge, K), f)) {
                  var ur = K, L = at().length;
                  L === 1 && Ge[ur] === "n" ? pr(Ae ? e.Diagnostics.A_bigint_literal_cannot_use_exponential_notation : e.Diagnostics.A_bigint_literal_must_be_an_integer, br, ur - br + 1) : (pr(e.Diagnostics.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal, ur, L), K = ur);
                }
              }
              __name(At, "At");
              function re() {
                for (var br = K; dr(Ge.charCodeAt(K)); )
                  K++;
                return +Ge.substring(br, K);
              }
              __name(re, "re");
              function de(br, Ae) {
                var ur = Nr(br, false, Ae);
                return ur ? parseInt(ur, 16) : -1;
              }
              __name(de, "de");
              function He(br, Ae) {
                return Nr(br, true, Ae);
              }
              __name(He, "He");
              function Nr(br, Ae, ur) {
                for (var L = [], qt = false, nn = false; L.length < br || Ae; ) {
                  var fr = Ge.charCodeAt(K);
                  if (ur && fr === 95) {
                    xe |= 512, qt ? (qt = false, nn = true) : pr(nn ? e.Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted : e.Diagnostics.Numeric_separators_are_not_allowed_here, K, 1), K++;
                    continue;
                  }
                  if (qt = ur, fr >= 65 && fr <= 70)
                    fr += 97 - 65;
                  else if (!(fr >= 48 && fr <= 57 || fr >= 97 && fr <= 102))
                    break;
                  L.push(fr), K++, nn = false;
                }
                return L.length < br && (L = []), Ge.charCodeAt(K - 1) === 95 && pr(e.Diagnostics.Numeric_separators_are_not_allowed_here, K - 1, 1), String.fromCharCode.apply(String, L);
              }
              __name(Nr, "Nr");
              function Yr(br) {
                br === void 0 && (br = false);
                var Ae = Ge.charCodeAt(K);
                K++;
                for (var ur = "", L = K; ; ) {
                  if (K >= r) {
                    ur += Ge.substring(L, K), xe |= 4, pr(e.Diagnostics.Unterminated_string_literal);
                    break;
                  }
                  var qt = Ge.charCodeAt(K);
                  if (qt === Ae) {
                    ur += Ge.substring(L, K), K++;
                    break;
                  }
                  if (qt === 92 && !br) {
                    ur += Ge.substring(L, K), ur += Dt(), L = K;
                    continue;
                  }
                  if (be(qt) && !br) {
                    ur += Ge.substring(L, K), xe |= 4, pr(e.Diagnostics.Unterminated_string_literal);
                    break;
                  }
                  K++;
                }
                return ur;
              }
              __name(Yr, "Yr");
              function St(br) {
                var Ae = Ge.charCodeAt(K) === 96;
                K++;
                for (var ur = K, L = "", qt; ; ) {
                  if (K >= r) {
                    L += Ge.substring(ur, K), xe |= 4, pr(e.Diagnostics.Unterminated_template_literal), qt = Ae ? 14 : 17;
                    break;
                  }
                  var nn = Ge.charCodeAt(K);
                  if (nn === 96) {
                    L += Ge.substring(ur, K), K++, qt = Ae ? 14 : 17;
                    break;
                  }
                  if (nn === 36 && K + 1 < r && Ge.charCodeAt(K + 1) === 123) {
                    L += Ge.substring(ur, K), K += 2, qt = Ae ? 15 : 16;
                    break;
                  }
                  if (nn === 92) {
                    L += Ge.substring(ur, K), L += Dt(br), ur = K;
                    continue;
                  }
                  if (nn === 13) {
                    L += Ge.substring(ur, K), K++, K < r && Ge.charCodeAt(K) === 10 && K++, L += `
`, ur = K;
                    continue;
                  }
                  K++;
                }
                return e.Debug.assert(qt !== void 0), me = L, qt;
              }
              __name(St, "St");
              function Dt(br) {
                var Ae = K;
                if (K++, K >= r)
                  return pr(e.Diagnostics.Unexpected_end_of_text), "";
                var ur = Ge.charCodeAt(K);
                switch (K++, ur) {
                  case 48:
                    return br && K < r && $e(Ge.charCodeAt(K)) ? (K++, xe |= 2048, Ge.substring(Ae, K)) : "\0";
                  case 98:
                    return "\b";
                  case 116:
                    return "	";
                  case 110:
                    return `
`;
                  case 118:
                    return "\v";
                  case 102:
                    return "\f";
                  case 114:
                    return "\r";
                  case 39:
                    return "'";
                  case 34:
                    return '"';
                  case 117:
                    if (br) {
                      for (var L = K; L < K + 4; L++)
                        if (L < r && !Re(Ge.charCodeAt(L)) && Ge.charCodeAt(L) !== 123)
                          return K = L, xe |= 2048, Ge.substring(Ae, K);
                    }
                    if (K < r && Ge.charCodeAt(K) === 123) {
                      if (K++, br && !Re(Ge.charCodeAt(K)))
                        return xe |= 2048, Ge.substring(Ae, K);
                      if (br) {
                        var qt = K, nn = He(1, false), fr = nn ? parseInt(nn, 16) : -1;
                        if (!Fe(fr) || Ge.charCodeAt(K) !== 125)
                          return xe |= 2048, Ge.substring(Ae, K);
                        K = qt;
                      }
                      return xe |= 8, zt();
                    }
                    return xe |= 1024, Lt(4);
                  case 120:
                    if (br)
                      if (Re(Ge.charCodeAt(K))) {
                        if (!Re(Ge.charCodeAt(K + 1)))
                          return K++, xe |= 2048, Ge.substring(Ae, K);
                      } else
                        return xe |= 2048, Ge.substring(Ae, K);
                    return Lt(2);
                  case 13:
                    K < r && Ge.charCodeAt(K) === 10 && K++;
                  case 10:
                  case 8232:
                  case 8233:
                    return "";
                  default:
                    return String.fromCharCode(ur);
                }
              }
              __name(Dt, "Dt");
              function Lt(br) {
                var Ae = de(br, false);
                return Ae >= 0 ? String.fromCharCode(Ae) : (pr(e.Diagnostics.Hexadecimal_digit_expected), "");
              }
              __name(Lt, "Lt");
              function zt() {
                var br = He(1, false), Ae = br ? parseInt(br, 16) : -1, ur = false;
                return Ae < 0 ? (pr(e.Diagnostics.Hexadecimal_digit_expected), ur = true) : Ae > 1114111 && (pr(e.Diagnostics.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive), ur = true), K >= r ? (pr(e.Diagnostics.Unexpected_end_of_text), ur = true) : Ge.charCodeAt(K) === 125 ? K++ : (pr(e.Diagnostics.Unterminated_Unicode_escape_sequence), ur = true), ur ? "" : Z(Ae);
              }
              __name(zt, "zt");
              function Zt() {
                if (K + 5 < r && Ge.charCodeAt(K + 1) === 117) {
                  var br = K;
                  K += 2;
                  var Ae = de(4, false);
                  return K = br, Ae;
                }
                return -1;
              }
              __name(Zt, "Zt");
              function mt() {
                if (Pr(Ge, K + 1) === 117 && Pr(Ge, K + 2) === 123) {
                  var br = K;
                  K += 3;
                  var Ae = He(1, false), ur = Ae ? parseInt(Ae, 16) : -1;
                  return K = br, ur;
                }
                return -1;
              }
              __name(mt, "mt");
              function at() {
                for (var br = "", Ae = K; K < r; ) {
                  var ur = Pr(Ge, K);
                  if (ye(ur, f))
                    K += Br(ur);
                  else if (ur === 92) {
                    if (ur = mt(), ur >= 0 && ye(ur, f)) {
                      K += 3, xe |= 8, br += zt(), Ae = K;
                      continue;
                    }
                    if (ur = Zt(), !(ur >= 0 && ye(ur, f)))
                      break;
                    xe |= 1024, br += Ge.substring(Ae, K), br += Z(ur), K += 6, Ae = K;
                  } else
                    break;
                }
                return br += Ge.substring(Ae, K), br;
              }
              __name(at, "at");
              function k() {
                var br = me.length;
                if (br >= 2 && br <= 12) {
                  var Ae = me.charCodeAt(0);
                  if (Ae >= 97 && Ae <= 122) {
                    var ur = q.get(me);
                    if (ur !== void 0)
                      return Ie = ur;
                  }
                }
                return Ie = 79;
              }
              __name(k, "k");
              function ue(br) {
                for (var Ae = "", ur = false, L = false; ; ) {
                  var qt = Ge.charCodeAt(K);
                  if (qt === 95) {
                    xe |= 512, ur ? (ur = false, L = true) : pr(L ? e.Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted : e.Diagnostics.Numeric_separators_are_not_allowed_here, K, 1), K++;
                    continue;
                  }
                  if (ur = true, !$e(qt) || qt - 48 >= br)
                    break;
                  Ae += Ge[K], K++, L = false;
                }
                return Ge.charCodeAt(K - 1) === 95 && pr(e.Diagnostics.Numeric_separators_are_not_allowed_here, K - 1, 1), Ae;
              }
              __name(ue, "ue");
              function Qe() {
                if (Ge.charCodeAt(K) === 110)
                  return me += "n", xe & 384 && (me = e.parsePseudoBigInt(me) + "n"), K++, 9;
                var br = xe & 128 ? parseInt(me.slice(2), 2) : xe & 256 ? parseInt(me.slice(2), 8) : +me;
                return me = "" + br, 8;
              }
              __name(Qe, "Qe");
              function Sr() {
                var br;
                ct = K, xe = 0;
                for (var Ae = false; ; ) {
                  if (ft = K, K >= r)
                    return Ie = 1;
                  var ur = Pr(Ge, K);
                  if (ur === 35 && K === 0 && Xe(Ge, K)) {
                    if (K = gr(Ge, K), h)
                      continue;
                    return Ie = 6;
                  }
                  switch (ur) {
                    case 10:
                    case 13:
                      if (xe |= 1, h) {
                        K++;
                        continue;
                      } else
                        return ur === 13 && K + 1 < r && Ge.charCodeAt(K + 1) === 10 ? K += 2 : K++, Ie = 4;
                    case 9:
                    case 11:
                    case 12:
                    case 32:
                    case 160:
                    case 5760:
                    case 8192:
                    case 8193:
                    case 8194:
                    case 8195:
                    case 8196:
                    case 8197:
                    case 8198:
                    case 8199:
                    case 8200:
                    case 8201:
                    case 8202:
                    case 8203:
                    case 8239:
                    case 8287:
                    case 12288:
                    case 65279:
                      if (h) {
                        K++;
                        continue;
                      } else {
                        for (; K < r && j(Ge.charCodeAt(K)); )
                          K++;
                        return Ie = 5;
                      }
                    case 33:
                      return Ge.charCodeAt(K + 1) === 61 ? Ge.charCodeAt(K + 2) === 61 ? (K += 3, Ie = 37) : (K += 2, Ie = 35) : (K++, Ie = 53);
                    case 34:
                    case 39:
                      return me = Yr(), Ie = 10;
                    case 96:
                      return Ie = St(false);
                    case 37:
                      return Ge.charCodeAt(K + 1) === 61 ? (K += 2, Ie = 69) : (K++, Ie = 44);
                    case 38:
                      return Ge.charCodeAt(K + 1) === 38 ? Ge.charCodeAt(K + 2) === 61 ? (K += 3, Ie = 76) : (K += 2, Ie = 55) : Ge.charCodeAt(K + 1) === 61 ? (K += 2, Ie = 73) : (K++, Ie = 50);
                    case 40:
                      return K++, Ie = 20;
                    case 41:
                      return K++, Ie = 21;
                    case 42:
                      if (Ge.charCodeAt(K + 1) === 61)
                        return K += 2, Ie = 66;
                      if (Ge.charCodeAt(K + 1) === 42)
                        return Ge.charCodeAt(K + 2) === 61 ? (K += 3, Ie = 67) : (K += 2, Ie = 42);
                      if (K++, vr && !Ae && xe & 1) {
                        Ae = true;
                        continue;
                      }
                      return Ie = 41;
                    case 43:
                      return Ge.charCodeAt(K + 1) === 43 ? (K += 2, Ie = 45) : Ge.charCodeAt(K + 1) === 61 ? (K += 2, Ie = 64) : (K++, Ie = 39);
                    case 44:
                      return K++, Ie = 27;
                    case 45:
                      return Ge.charCodeAt(K + 1) === 45 ? (K += 2, Ie = 46) : Ge.charCodeAt(K + 1) === 61 ? (K += 2, Ie = 65) : (K++, Ie = 40);
                    case 46:
                      return $e(Ge.charCodeAt(K + 1)) ? (me = ot().value, Ie = 8) : Ge.charCodeAt(K + 1) === 46 && Ge.charCodeAt(K + 2) === 46 ? (K += 3, Ie = 25) : (K++, Ie = 24);
                    case 47:
                      if (Ge.charCodeAt(K + 1) === 47) {
                        for (K += 2; K < r && !be(Ge.charCodeAt(K)); )
                          K++;
                        if (Ye = In(Ye, Ge.slice(ft, K), Q, ft), h)
                          continue;
                        return Ie = 2;
                      }
                      if (Ge.charCodeAt(K + 1) === 42) {
                        K += 2, Ge.charCodeAt(K) === 42 && Ge.charCodeAt(K + 1) !== 47 && (xe |= 2);
                        for (var L = false, qt = ft; K < r; ) {
                          var nn = Ge.charCodeAt(K);
                          if (nn === 42 && Ge.charCodeAt(K + 1) === 47) {
                            K += 2, L = true;
                            break;
                          }
                          K++, be(nn) && (qt = K, xe |= 1);
                        }
                        if (Ye = In(Ye, Ge.slice(qt, K), Be, qt), L || pr(e.Diagnostics.Asterisk_Slash_expected), h)
                          continue;
                        return L || (xe |= 4), Ie = 3;
                      }
                      return Ge.charCodeAt(K + 1) === 61 ? (K += 2, Ie = 68) : (K++, Ie = 43);
                    case 48:
                      if (K + 2 < r && (Ge.charCodeAt(K + 1) === 88 || Ge.charCodeAt(K + 1) === 120))
                        return K += 2, me = He(1, true), me || (pr(e.Diagnostics.Hexadecimal_digit_expected), me = "0"), me = "0x" + me, xe |= 64, Ie = Qe();
                      if (K + 2 < r && (Ge.charCodeAt(K + 1) === 66 || Ge.charCodeAt(K + 1) === 98))
                        return K += 2, me = ue(2), me || (pr(e.Diagnostics.Binary_digit_expected), me = "0"), me = "0b" + me, xe |= 128, Ie = Qe();
                      if (K + 2 < r && (Ge.charCodeAt(K + 1) === 79 || Ge.charCodeAt(K + 1) === 111))
                        return K += 2, me = ue(8), me || (pr(e.Diagnostics.Octal_digit_expected), me = "0"), me = "0o" + me, xe |= 256, Ie = Qe();
                      if (K + 1 < r && dr(Ge.charCodeAt(K + 1)))
                        return me = "" + re(), xe |= 32, Ie = 8;
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                      return br = ot(), Ie = br.type, me = br.value, Ie;
                    case 58:
                      return K++, Ie = 58;
                    case 59:
                      return K++, Ie = 26;
                    case 60:
                      if (ar(Ge, K)) {
                        if (K = Cr(Ge, K, pr), h)
                          continue;
                        return Ie = 7;
                      }
                      return Ge.charCodeAt(K + 1) === 60 ? Ge.charCodeAt(K + 2) === 61 ? (K += 3, Ie = 70) : (K += 2, Ie = 47) : Ge.charCodeAt(K + 1) === 61 ? (K += 2, Ie = 32) : ae === 1 && Ge.charCodeAt(K + 1) === 47 && Ge.charCodeAt(K + 2) !== 42 ? (K += 2, Ie = 30) : (K++, Ie = 29);
                    case 61:
                      if (ar(Ge, K)) {
                        if (K = Cr(Ge, K, pr), h)
                          continue;
                        return Ie = 7;
                      }
                      return Ge.charCodeAt(K + 1) === 61 ? Ge.charCodeAt(K + 2) === 61 ? (K += 3, Ie = 36) : (K += 2, Ie = 34) : Ge.charCodeAt(K + 1) === 62 ? (K += 2, Ie = 38) : (K++, Ie = 63);
                    case 62:
                      if (ar(Ge, K)) {
                        if (K = Cr(Ge, K, pr), h)
                          continue;
                        return Ie = 7;
                      }
                      return K++, Ie = 31;
                    case 63:
                      return Ge.charCodeAt(K + 1) === 46 && !$e(Ge.charCodeAt(K + 2)) ? (K += 2, Ie = 28) : Ge.charCodeAt(K + 1) === 63 ? Ge.charCodeAt(K + 2) === 61 ? (K += 3, Ie = 77) : (K += 2, Ie = 60) : (K++, Ie = 57);
                    case 91:
                      return K++, Ie = 22;
                    case 93:
                      return K++, Ie = 23;
                    case 94:
                      return Ge.charCodeAt(K + 1) === 61 ? (K += 2, Ie = 78) : (K++, Ie = 52);
                    case 123:
                      return K++, Ie = 18;
                    case 124:
                      if (ar(Ge, K)) {
                        if (K = Cr(Ge, K, pr), h)
                          continue;
                        return Ie = 7;
                      }
                      return Ge.charCodeAt(K + 1) === 124 ? Ge.charCodeAt(K + 2) === 61 ? (K += 3, Ie = 75) : (K += 2, Ie = 56) : Ge.charCodeAt(K + 1) === 61 ? (K += 2, Ie = 74) : (K++, Ie = 51);
                    case 125:
                      return K++, Ie = 19;
                    case 126:
                      return K++, Ie = 54;
                    case 64:
                      return K++, Ie = 59;
                    case 92:
                      var fr = mt();
                      if (fr >= 0 && zr(fr, f))
                        return K += 3, xe |= 8, me = zt() + at(), Ie = k();
                      var Me = Zt();
                      return Me >= 0 && zr(Me, f) ? (K += 6, xe |= 1024, me = String.fromCharCode(Me) + at(), Ie = k()) : (pr(e.Diagnostics.Invalid_character), K++, Ie = 0);
                    case 35:
                      if (K !== 0 && Ge[K + 1] === "!")
                        return pr(e.Diagnostics.can_only_be_used_at_the_start_of_a_file), K++, Ie = 0;
                      var Ve = Pr(Ge, K + 1);
                      if (Ve === 92) {
                        K++;
                        var _r = mt();
                        if (_r >= 0 && zr(_r, f))
                          return K += 3, xe |= 8, me = "#" + zt() + at(), Ie = 80;
                        var lr = Zt();
                        if (lr >= 0 && zr(lr, f))
                          return K += 6, xe |= 1024, me = "#" + String.fromCharCode(lr) + at(), Ie = 80;
                        K--;
                      }
                      return zr(Ve, f) ? (K++, Hr(Ve, f)) : (me = "#", pr(e.Diagnostics.Invalid_character, K++, Br(ur))), Ie = 80;
                    default:
                      var Vr = Hr(ur, f);
                      if (Vr)
                        return Ie = Vr;
                      if (j(ur)) {
                        K += Br(ur);
                        continue;
                      } else if (be(ur)) {
                        xe |= 1, K += Br(ur);
                        continue;
                      }
                      var tt = Br(ur);
                      return pr(e.Diagnostics.Invalid_character, K, tt), K += tt, Ie = 0;
                  }
                }
              }
              __name(Sr, "Sr");
              function Kr() {
                e.Debug.assert(Ie === 0, "'reScanInvalidIdentifier' should only be called when the current token is 'SyntaxKind.Unknown'."), K = ft = ct, xe = 0;
                var br = Pr(Ge, K), Ae = Hr(br, 99);
                return Ae ? Ie = Ae : (K += Br(br), Ie);
              }
              __name(Kr, "Kr");
              function Hr(br, Ae) {
                var ur = br;
                if (zr(ur, Ae)) {
                  for (K += Br(ur); K < r && ye(ur = Pr(Ge, K), Ae); )
                    K += Br(ur);
                  return me = Ge.substring(ft, K), ur === 92 && (me += at()), k();
                }
              }
              __name(Hr, "Hr");
              function Ct() {
                if (Ie === 31) {
                  if (Ge.charCodeAt(K) === 62)
                    return Ge.charCodeAt(K + 1) === 62 ? Ge.charCodeAt(K + 2) === 61 ? (K += 3, Ie = 72) : (K += 2, Ie = 49) : Ge.charCodeAt(K + 1) === 61 ? (K += 2, Ie = 71) : (K++, Ie = 48);
                  if (Ge.charCodeAt(K) === 61)
                    return K++, Ie = 33;
                }
                return Ie;
              }
              __name(Ct, "Ct");
              function Xt() {
                return e.Debug.assert(Ie === 66, "'reScanAsteriskEqualsToken' should only be called on a '*='"), K = ft + 1, Ie = 63;
              }
              __name(Xt, "Xt");
              function cn() {
                if (Ie === 43 || Ie === 68) {
                  for (var br = ft + 1, Ae = false, ur = false; ; ) {
                    if (br >= r) {
                      xe |= 4, pr(e.Diagnostics.Unterminated_regular_expression_literal);
                      break;
                    }
                    var L = Ge.charCodeAt(br);
                    if (be(L)) {
                      xe |= 4, pr(e.Diagnostics.Unterminated_regular_expression_literal);
                      break;
                    }
                    if (Ae)
                      Ae = false;
                    else if (L === 47 && !ur) {
                      br++;
                      break;
                    } else
                      L === 91 ? ur = true : L === 92 ? Ae = true : L === 93 && (ur = false);
                    br++;
                  }
                  for (; br < r && ye(Ge.charCodeAt(br), f); )
                    br++;
                  K = br, me = Ge.substring(ft, K), Ie = 13;
                }
                return Ie;
              }
              __name(cn, "cn");
              function In(br, Ae, ur, L) {
                var qt = yn(e.trimStringStart(Ae), ur);
                return qt === void 0 ? br : e.append(br, { range: { pos: L, end: K }, type: qt });
              }
              __name(In, "In");
              function yn(br, Ae) {
                var ur = Ae.exec(br);
                if (!!ur)
                  switch (ur[1]) {
                    case "ts-expect-error":
                      return 0;
                    case "ts-ignore":
                      return 1;
                  }
              }
              __name(yn, "yn");
              function hn(br) {
                return e.Debug.assert(Ie === 19, "'reScanTemplateToken' should only be called on a '}'"), K = ft, Ie = St(br);
              }
              __name(hn, "hn");
              function ln() {
                return K = ft, Ie = St(true);
              }
              __name(ln, "ln");
              function En(br) {
                return br === void 0 && (br = true), K = ft = ct, Ie = vi(br);
              }
              __name(En, "En");
              function Vt() {
                return Ie === 47 ? (K = ft + 1, Ie = 29) : Ie;
              }
              __name(Vt, "Vt");
              function ui() {
                return Ie === 80 ? (K = ft + 1, Ie = 62) : Ie;
              }
              __name(ui, "ui");
              function ei() {
                return e.Debug.assert(Ie === 60, "'reScanQuestionToken' should only be called on a '??'"), K = ft + 1, Ie = 57;
              }
              __name(ei, "ei");
              function vi(br) {
                if (br === void 0 && (br = true), ct = ft = K, K >= r)
                  return Ie = 1;
                var Ae = Ge.charCodeAt(K);
                if (Ae === 60)
                  return Ge.charCodeAt(K + 1) === 47 ? (K += 2, Ie = 30) : (K++, Ie = 29);
                if (Ae === 123)
                  return K++, Ie = 18;
                for (var ur = 0; K < r && (Ae = Ge.charCodeAt(K), Ae !== 123); ) {
                  if (Ae === 60) {
                    if (ar(Ge, K))
                      return K = Cr(Ge, K, pr), Ie = 7;
                    break;
                  }
                  if (Ae === 62 && pr(e.Diagnostics.Unexpected_token_Did_you_mean_or_gt, K, 1), Ae === 125 && pr(e.Diagnostics.Unexpected_token_Did_you_mean_or_rbrace, K, 1), be(Ae) && ur === 0)
                    ur = -1;
                  else {
                    if (!br && be(Ae) && ur > 0)
                      break;
                    pe(Ae) || (ur = K);
                  }
                  K++;
                }
                return me = Ge.substring(ct, K), ur === -1 ? 12 : 11;
              }
              __name(vi, "vi");
              function ri() {
                if (x(Ie)) {
                  for (var br = false; K < r; ) {
                    var Ae = Ge.charCodeAt(K);
                    if (Ae === 45) {
                      me += "-", K++;
                      continue;
                    } else if (Ae === 58 && !br) {
                      me += ":", K++, br = true, Ie = 79;
                      continue;
                    }
                    var ur = K;
                    if (me += at(), K === ur)
                      break;
                  }
                  return me.slice(-1) === ":" && (me = me.slice(0, -1), K--), k();
                }
                return Ie;
              }
              __name(ri, "ri");
              function bi() {
                switch (ct = K, Ge.charCodeAt(K)) {
                  case 34:
                  case 39:
                    return me = Yr(true), Ie = 10;
                  default:
                    return Sr();
                }
              }
              __name(bi, "bi");
              function Qn() {
                return K = ft = ct, bi();
              }
              __name(Qn, "Qn");
              function Yn() {
                if (ct = ft = K, xe = 0, K >= r)
                  return Ie = 1;
                var br = Pr(Ge, K);
                switch (K += Br(br), br) {
                  case 9:
                  case 11:
                  case 12:
                  case 32:
                    for (; K < r && j(Ge.charCodeAt(K)); )
                      K++;
                    return Ie = 5;
                  case 64:
                    return Ie = 59;
                  case 13:
                    Ge.charCodeAt(K) === 10 && K++;
                  case 10:
                    return xe |= 1, Ie = 4;
                  case 42:
                    return Ie = 41;
                  case 123:
                    return Ie = 18;
                  case 125:
                    return Ie = 19;
                  case 91:
                    return Ie = 22;
                  case 93:
                    return Ie = 23;
                  case 60:
                    return Ie = 29;
                  case 62:
                    return Ie = 31;
                  case 61:
                    return Ie = 63;
                  case 44:
                    return Ie = 27;
                  case 46:
                    return Ie = 24;
                  case 96:
                    return Ie = 61;
                  case 35:
                    return Ie = 62;
                  case 92:
                    K--;
                    var Ae = mt();
                    if (Ae >= 0 && zr(Ae, f))
                      return K += 3, xe |= 8, me = zt() + at(), Ie = k();
                    var ur = Zt();
                    return ur >= 0 && zr(ur, f) ? (K += 6, xe |= 1024, me = String.fromCharCode(ur) + at(), Ie = k()) : (K++, Ie = 0);
                }
                if (zr(br, f)) {
                  for (var L = br; K < r && ye(L = Pr(Ge, K), f) || Ge.charCodeAt(K) === 45; )
                    K += Br(L);
                  return me = Ge.substring(ft, K), L === 92 && (me += at()), Ie = k();
                } else
                  return Ie = 0;
              }
              __name(Yn, "Yn");
              function oi(br, Ae) {
                var ur = K, L = ct, qt = ft, nn = Ie, fr = me, Me = xe, Ve = br();
                return (!Ve || Ae) && (K = ur, ct = L, ft = qt, Ie = nn, me = fr, xe = Me), Ve;
              }
              __name(oi, "oi");
              function Ei(br, Ae, ur) {
                var L = r, qt = K, nn = ct, fr = ft, Me = Ie, Ve = me, _r = xe, lr = Ye;
                Zn(Ge, br, Ae);
                var Vr = ur();
                return r = L, K = qt, ct = nn, ft = fr, Ie = Me, me = Ve, xe = _r, Ye = lr, Vr;
              }
              __name(Ei, "Ei");
              function Dn(br) {
                return oi(br, true);
              }
              __name(Dn, "Dn");
              function Kn(br) {
                return oi(br, false);
              }
              __name(Kn, "Kn");
              function si() {
                return Ge;
              }
              __name(si, "si");
              function mi() {
                Ye = void 0;
              }
              __name(mi, "mi");
              function Zn(br, Ae, ur) {
                Ge = br || "", r = ur === void 0 ? Ge.length : Ae + ur, dn(Ae || 0);
              }
              __name(Zn, "Zn");
              function Fn(br) {
                jr = br;
              }
              __name(Fn, "Fn");
              function gt(br) {
                f = br;
              }
              __name(gt, "gt");
              function gi(br) {
                ae = br;
              }
              __name(gi, "gi");
              function dn(br) {
                e.Debug.assert(br >= 0), K = br, ct = br, ft = br, Ie = 0, me = void 0, xe = 0;
              }
              __name(dn, "dn");
              function On(br) {
                vr += br ? 1 : -1;
              }
              __name(On, "On");
            }
            __name(Dr, "Dr");
            e.createScanner = Dr;
            var Pr = String.prototype.codePointAt ? function(f, h) {
              return f.codePointAt(h);
            } : function(h, ae) {
              var xr = h.length;
              if (!(ae < 0 || ae >= xr)) {
                var jr = h.charCodeAt(ae);
                if (jr >= 55296 && jr <= 56319 && xr > ae + 1) {
                  var qr = h.charCodeAt(ae + 1);
                  if (qr >= 56320 && qr <= 57343)
                    return (jr - 55296) * 1024 + qr - 56320 + 65536;
                }
                return jr;
              }
            };
            function Br(f) {
              return f >= 65536 ? 2 : 1;
            }
            __name(Br, "Br");
            function ut(f) {
              if (e.Debug.assert(0 <= f && f <= 1114111), f <= 65535)
                return String.fromCharCode(f);
              var h = Math.floor((f - 65536) / 1024) + 55296, ae = (f - 65536) % 1024 + 56320;
              return String.fromCharCode(h, ae);
            }
            __name(ut, "ut");
            var rt = String.fromCodePoint ? function(f) {
              return String.fromCodePoint(f);
            } : ut;
            function Z(f) {
              return rt(f);
            }
            __name(Z, "Z");
            e.utf16EncodeAsString = Z;
          })(N || (N = {}));
          var N;
          (function(e) {
            function t(y) {
              return e.pathIsRelative(y) || e.isRootedDiskPath(y);
            }
            __name(t, "t");
            e.isExternalModuleNameRelative = t;
            function x(y) {
              return e.sortAndDeduplicate(y, e.compareDiagnostics);
            }
            __name(x, "x");
            e.sortAndDeduplicateDiagnostics = x;
            function s(y) {
              switch (e.getEmitScriptTarget(y)) {
                case 99:
                  return "lib.esnext.full.d.ts";
                case 9:
                  return "lib.es2022.full.d.ts";
                case 8:
                  return "lib.es2021.full.d.ts";
                case 7:
                  return "lib.es2020.full.d.ts";
                case 6:
                  return "lib.es2019.full.d.ts";
                case 5:
                  return "lib.es2018.full.d.ts";
                case 4:
                  return "lib.es2017.full.d.ts";
                case 3:
                  return "lib.es2016.full.d.ts";
                case 2:
                  return "lib.es6.d.ts";
                default:
                  return "lib.d.ts";
              }
            }
            __name(s, "s");
            e.getDefaultLibFileName = s;
            function q(y) {
              return y.start + y.length;
            }
            __name(q, "q");
            e.textSpanEnd = q;
            function F(y) {
              return y.length === 0;
            }
            __name(F, "F");
            e.textSpanIsEmpty = F;
            function fe(y, De) {
              return De >= y.start && De < q(y);
            }
            __name(fe, "fe");
            e.textSpanContainsPosition = fe;
            function Te(y, De) {
              return De >= y.pos && De <= y.end;
            }
            __name(Te, "Te");
            e.textRangeContainsPositionInclusive = Te;
            function Se(y, De) {
              return De.start >= y.start && q(De) <= q(y);
            }
            __name(Se, "Se");
            e.textSpanContainsTextSpan = Se;
            function J(y, De) {
              return se(y, De) !== void 0;
            }
            __name(J, "J");
            e.textSpanOverlapsWith = J;
            function se(y, De) {
              var R = W(y, De);
              return R && R.length === 0 ? void 0 : R;
            }
            __name(se, "se");
            e.textSpanOverlap = se;
            function Le(y, De) {
              return Be(y.start, y.length, De.start, De.length);
            }
            __name(Le, "Le");
            e.textSpanIntersectsWithTextSpan = Le;
            function Q(y, De, R) {
              return Be(y.start, y.length, De, R);
            }
            __name(Q, "Q");
            e.textSpanIntersectsWith = Q;
            function Be(y, De, R, Jt) {
              var Qt = y + De, qn = R + Jt;
              return R <= Qt && qn >= y;
            }
            __name(Be, "Be");
            e.decodedTextSpanIntersectsWith = Be;
            function je(y, De) {
              return De <= q(y) && De >= y.start;
            }
            __name(je, "je");
            e.textSpanIntersectsWithPosition = je;
            function W(y, De) {
              var R = Math.max(y.start, De.start), Jt = Math.min(q(y), q(De));
              return R <= Jt ? U(R, Jt) : void 0;
            }
            __name(W, "W");
            e.textSpanIntersection = W;
            function B(y, De) {
              if (y < 0)
                throw new Error("start < 0");
              if (De < 0)
                throw new Error("length < 0");
              return { start: y, length: De };
            }
            __name(B, "B");
            e.createTextSpan = B;
            function U(y, De) {
              return B(y, De - y);
            }
            __name(U, "U");
            e.createTextSpanFromBounds = U;
            function m(y) {
              return B(y.span.start, y.newLength);
            }
            __name(m, "m");
            e.textChangeRangeNewSpan = m;
            function v(y) {
              return F(y.span) && y.newLength === 0;
            }
            __name(v, "v");
            e.textChangeRangeIsUnchanged = v;
            function g(y, De) {
              if (De < 0)
                throw new Error("newLength < 0");
              return { span: y, newLength: De };
            }
            __name(g, "g");
            e.createTextChangeRange = g, e.unchangedTextChangeRange = g(B(0, 0), 0);
            function O(y) {
              if (y.length === 0)
                return e.unchangedTextChangeRange;
              if (y.length === 1)
                return y[0];
              for (var De = y[0], R = De.span.start, Jt = q(De.span), Qt = R + De.newLength, qn = 1; qn < y.length; qn++) {
                var Ii = y[qn], ca = R, ji = Jt, ua = Qt, Qi = Ii.span.start, ta = q(Ii.span), Ta = Qi + Ii.newLength;
                R = Math.min(ca, Qi), Jt = Math.max(ji, ji + (ta - ua)), Qt = Math.max(Ta, Ta + (ua - ta));
              }
              return g(U(R, Jt), Qt - R);
            }
            __name(O, "O");
            e.collapseTextChangeRangesAcrossMultipleVersions = O;
            function S(y) {
              if (y && y.kind === 165) {
                for (var De = y; De; De = De.parent)
                  if (ur(De) || lr(De) || De.kind === 261)
                    return De;
              }
            }
            __name(S, "S");
            e.getTypeParameterOwner = S;
            function te(y, De) {
              return e.hasSyntacticModifier(y, 16476) && De.kind === 173;
            }
            __name(te, "te");
            e.isParameterPropertyDeclaration = te;
            function Je(y) {
              return Ot(y) ? e.every(y.elements, qe) : false;
            }
            __name(Je, "Je");
            e.isEmptyBindingPattern = Je;
            function qe(y) {
              return e.isOmittedExpression(y) ? true : Je(y.name);
            }
            __name(qe, "qe");
            e.isEmptyBindingElement = qe;
            function ge(y) {
              for (var De = y.parent; e.isBindingElement(De.parent); )
                De = De.parent.parent;
              return De.parent;
            }
            __name(ge, "ge");
            e.walkUpBindingElementsAndPatterns = ge;
            function ie(y, De) {
              e.isBindingElement(y) && (y = ge(y));
              var R = De(y);
              return y.kind === 257 && (y = y.parent), y && y.kind === 258 && (R |= De(y), y = y.parent), y && y.kind === 240 && (R |= De(y)), R;
            }
            __name(ie, "ie");
            function G(y) {
              return ie(y, e.getEffectiveModifierFlags);
            }
            __name(G, "G");
            e.getCombinedModifierFlags = G;
            function pe(y) {
              return ie(y, e.getEffectiveModifierFlagsAlwaysIncludeJSDoc);
            }
            __name(pe, "pe");
            e.getCombinedNodeFlagsAlwaysIncludeJSDoc = pe;
            function j(y) {
              return ie(y, function(De) {
                return De.flags;
              });
            }
            __name(j, "j");
            e.getCombinedNodeFlags = j, e.supportedLocaleDirectories = ["cs", "de", "es", "fr", "it", "ja", "ko", "pl", "pt-br", "ru", "tr", "zh-cn", "zh-tw"];
            function be(y, De, R) {
              var Jt = y.toLowerCase(), Qt = /^([a-z]+)([_\-]([a-z]+))?$/.exec(Jt);
              if (!Qt) {
                R && R.push(e.createCompilerDiagnostic(e.Diagnostics.Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1, "en", "ja-jp"));
                return;
              }
              var qn = Qt[1], Ii = Qt[3];
              e.contains(e.supportedLocaleDirectories, Jt) && !ca(qn, Ii, R) && ca(qn, void 0, R), e.setUILocale(y);
              function ca(ji, ua, Qi) {
                var ta = e.normalizePath(De.getExecutingFilePath()), Ta = e.getDirectoryPath(ta), zi = e.combinePaths(Ta, ji);
                if (ua && (zi = zi + "-" + ua), zi = De.resolvePath(e.combinePaths(zi, "diagnosticMessages.generated.json")), !De.fileExists(zi))
                  return false;
                var Ji = "";
                try {
                  Ji = De.readFile(zi);
                } catch {
                  return Qi && Qi.push(e.createCompilerDiagnostic(e.Diagnostics.Unable_to_open_file_0, zi)), false;
                }
                try {
                  e.setLocalizedDiagnosticMessages(JSON.parse(Ji));
                } catch {
                  return Qi && Qi.push(e.createCompilerDiagnostic(e.Diagnostics.Corrupted_locale_file_0, zi)), false;
                }
                return true;
              }
              __name(ca, "ca");
            }
            __name(be, "be");
            e.validateLocaleAndSetLanguage = be;
            function $e(y, De) {
              if (y)
                for (; y.original !== void 0; )
                  y = y.original;
              return !De || De(y) ? y : void 0;
            }
            __name($e, "$e");
            e.getOriginalNode = $e;
            function Re(y, De) {
              for (; y; ) {
                var R = De(y);
                if (R === "quit")
                  return;
                if (R)
                  return y;
                y = y.parent;
              }
            }
            __name(Re, "Re");
            e.findAncestor = Re;
            function Fe(y) {
              return (y.flags & 8) === 0;
            }
            __name(Fe, "Fe");
            e.isParseTreeNode = Fe;
            function dr(y, De) {
              if (y === void 0 || Fe(y))
                return y;
              for (y = y.original; y; ) {
                if (Fe(y))
                  return !De || De(y) ? y : void 0;
                y = y.original;
              }
            }
            __name(dr, "dr");
            e.getParseTreeNode = dr;
            function ze(y) {
              return y.length >= 2 && y.charCodeAt(0) === 95 && y.charCodeAt(1) === 95 ? "_" + y : y;
            }
            __name(ze, "ze");
            e.escapeLeadingUnderscores = ze;
            function ve(y) {
              var De = y;
              return De.length >= 3 && De.charCodeAt(0) === 95 && De.charCodeAt(1) === 95 && De.charCodeAt(2) === 95 ? De.substr(1) : De;
            }
            __name(ve, "ve");
            e.unescapeLeadingUnderscores = ve;
            function er(y) {
              return ve(y.escapedText);
            }
            __name(er, "er");
            e.idText = er;
            function ar(y) {
              return y.valueDeclaration && mi(y.valueDeclaration) ? er(y.valueDeclaration.name) : ve(y.escapedName);
            }
            __name(ar, "ar");
            e.symbolName = ar;
            function Cr(y) {
              var De = y.parent.parent;
              if (!!De) {
                if (Ut(De))
                  return Ce(De);
                switch (De.kind) {
                  case 240:
                    if (De.declarationList && De.declarationList.declarations[0])
                      return Ce(De.declarationList.declarations[0]);
                    break;
                  case 241:
                    var R = De.expression;
                    switch (R.kind === 223 && R.operatorToken.kind === 63 && (R = R.left), R.kind) {
                      case 208:
                        return R.name;
                      case 209:
                        var Jt = R.argumentExpression;
                        if (e.isIdentifier(Jt))
                          return Jt;
                    }
                    break;
                  case 214:
                    return Ce(De.expression);
                  case 253: {
                    if (Ut(De.statement) || Bn(De.statement))
                      return Ce(De.statement);
                    break;
                  }
                }
              }
            }
            __name(Cr, "Cr");
            function Ce(y) {
              var De = we(y);
              return De && e.isIdentifier(De) ? De : void 0;
            }
            __name(Ce, "Ce");
            function Xe(y, De) {
              return !!(X(y) && e.isIdentifier(y.name) && er(y.name) === er(De) || e.isVariableStatement(y) && e.some(y.declarationList.declarations, function(R) {
                return Xe(R, De);
              }));
            }
            __name(Xe, "Xe");
            e.nodeHasName = Xe;
            function gr(y) {
              return y.name || Cr(y);
            }
            __name(gr, "gr");
            e.getNameOfJSDocTypedef = gr;
            function X(y) {
              return !!y.name;
            }
            __name(X, "X");
            e.isNamedDeclaration = X;
            function Ee(y) {
              switch (y.kind) {
                case 79:
                  return y;
                case 350:
                case 343: {
                  var De = y.name;
                  if (De.kind === 163)
                    return De.right;
                  break;
                }
                case 210:
                case 223: {
                  var R = y;
                  switch (e.getAssignmentDeclarationKind(R)) {
                    case 1:
                    case 4:
                    case 5:
                    case 3:
                      return e.getElementOrPropertyAccessArgumentExpressionOrName(R.left);
                    case 7:
                    case 8:
                    case 9:
                      return R.arguments[1];
                    default:
                      return;
                  }
                }
                case 348:
                  return gr(y);
                case 342:
                  return Cr(y);
                case 274: {
                  var Jt = y.expression;
                  return e.isIdentifier(Jt) ? Jt : void 0;
                }
                case 209:
                  var Qt = y;
                  if (e.isBindableStaticElementAccessExpression(Qt))
                    return Qt.argumentExpression;
              }
              return y.name;
            }
            __name(Ee, "Ee");
            e.getNonAssignedNameOfDeclaration = Ee;
            function we(y) {
              if (y !== void 0)
                return Ee(y) || (e.isFunctionExpression(y) || e.isArrowFunction(y) || e.isClassExpression(y) ? he(y) : void 0);
            }
            __name(we, "we");
            e.getNameOfDeclaration = we;
            function he(y) {
              if (y.parent) {
                if (e.isPropertyAssignment(y.parent) || e.isBindingElement(y.parent))
                  return y.parent.name;
                if (e.isBinaryExpression(y.parent) && y === y.parent.right) {
                  if (e.isIdentifier(y.parent.left))
                    return y.parent.left;
                  if (e.isAccessExpression(y.parent.left))
                    return e.getElementOrPropertyAccessArgumentExpressionOrName(y.parent.left);
                } else if (e.isVariableDeclaration(y.parent) && e.isIdentifier(y.parent.name))
                  return y.parent.name;
              } else
                return;
            }
            __name(he, "he");
            e.getAssignedName = he;
            function yr(y) {
              if (e.hasDecorators(y))
                return e.filter(y.modifiers, e.isDecorator);
            }
            __name(yr, "yr");
            e.getDecorators = yr;
            function kr(y) {
              if (e.hasSyntacticModifier(y, 126975))
                return e.filter(y.modifiers, dn);
            }
            __name(kr, "kr");
            e.getModifiers = kr;
            function nr(y, De) {
              if (y.name)
                if (e.isIdentifier(y.name)) {
                  var R = y.name.escapedText;
                  return vr(y.parent, De).filter(function(qn) {
                    return e.isJSDocParameterTag(qn) && e.isIdentifier(qn.name) && qn.name.escapedText === R;
                  });
                } else {
                  var Jt = y.parent.parameters.indexOf(y);
                  e.Debug.assert(Jt > -1, "Parameters should always be in their parents' parameter list");
                  var Qt = vr(y.parent, De).filter(e.isJSDocParameterTag);
                  if (Jt < Qt.length)
                    return [Qt[Jt]];
                }
              return e.emptyArray;
            }
            __name(nr, "nr");
            function tr(y) {
              return nr(y, false);
            }
            __name(tr, "tr");
            e.getJSDocParameterTags = tr;
            function Lr(y) {
              return nr(y, true);
            }
            __name(Lr, "Lr");
            e.getJSDocParameterTagsNoCache = Lr;
            function zr(y, De) {
              var R = y.name.escapedText;
              return vr(y.parent, De).filter(function(Jt) {
                return e.isJSDocTemplateTag(Jt) && Jt.typeParameters.some(function(Qt) {
                  return Qt.name.escapedText === R;
                });
              });
            }
            __name(zr, "zr");
            function ye(y) {
              return zr(y, false);
            }
            __name(ye, "ye");
            e.getJSDocTypeParameterTags = ye;
            function ir(y) {
              return zr(y, true);
            }
            __name(ir, "ir");
            e.getJSDocTypeParameterTagsNoCache = ir;
            function Dr(y) {
              return !!Mr(y, e.isJSDocParameterTag);
            }
            __name(Dr, "Dr");
            e.hasJSDocParameterTags = Dr;
            function Pr(y) {
              return Mr(y, e.isJSDocAugmentsTag);
            }
            __name(Pr, "Pr");
            e.getJSDocAugmentsTag = Pr;
            function Br(y) {
              return ot(y, e.isJSDocImplementsTag);
            }
            __name(Br, "Br");
            e.getJSDocImplementsTags = Br;
            function ut(y) {
              return Mr(y, e.isJSDocClassTag);
            }
            __name(ut, "ut");
            e.getJSDocClassTag = ut;
            function rt(y) {
              return Mr(y, e.isJSDocPublicTag);
            }
            __name(rt, "rt");
            e.getJSDocPublicTag = rt;
            function Z(y) {
              return Mr(y, e.isJSDocPublicTag, true);
            }
            __name(Z, "Z");
            e.getJSDocPublicTagNoCache = Z;
            function f(y) {
              return Mr(y, e.isJSDocPrivateTag);
            }
            __name(f, "f");
            e.getJSDocPrivateTag = f;
            function h(y) {
              return Mr(y, e.isJSDocPrivateTag, true);
            }
            __name(h, "h");
            e.getJSDocPrivateTagNoCache = h;
            function ae(y) {
              return Mr(y, e.isJSDocProtectedTag);
            }
            __name(ae, "ae");
            e.getJSDocProtectedTag = ae;
            function xr(y) {
              return Mr(y, e.isJSDocProtectedTag, true);
            }
            __name(xr, "xr");
            e.getJSDocProtectedTagNoCache = xr;
            function jr(y) {
              return Mr(y, e.isJSDocReadonlyTag);
            }
            __name(jr, "jr");
            e.getJSDocReadonlyTag = jr;
            function qr(y) {
              return Mr(y, e.isJSDocReadonlyTag, true);
            }
            __name(qr, "qr");
            e.getJSDocReadonlyTagNoCache = qr;
            function pt(y) {
              return Mr(y, e.isJSDocOverrideTag, true);
            }
            __name(pt, "pt");
            e.getJSDocOverrideTagNoCache = pt;
            function Ge(y) {
              return Mr(y, e.isJSDocDeprecatedTag);
            }
            __name(Ge, "Ge");
            e.getJSDocDeprecatedTag = Ge;
            function K(y) {
              return Mr(y, e.isJSDocDeprecatedTag, true);
            }
            __name(K, "K");
            e.getJSDocDeprecatedTagNoCache = K;
            function r(y) {
              return Mr(y, e.isJSDocEnumTag);
            }
            __name(r, "r");
            e.getJSDocEnumTag = r;
            function ct(y) {
              return Mr(y, e.isJSDocThisTag);
            }
            __name(ct, "ct");
            e.getJSDocThisTag = ct;
            function ft(y) {
              return Mr(y, e.isJSDocReturnTag);
            }
            __name(ft, "ft");
            e.getJSDocReturnTag = ft;
            function Ie(y) {
              return Mr(y, e.isJSDocTemplateTag);
            }
            __name(Ie, "Ie");
            e.getJSDocTemplateTag = Ie;
            function me(y) {
              var De = Mr(y, e.isJSDocTypeTag);
              if (De && De.typeExpression && De.typeExpression.type)
                return De;
            }
            __name(me, "me");
            e.getJSDocTypeTag = me;
            function xe(y) {
              var De = Mr(y, e.isJSDocTypeTag);
              return !De && e.isParameter(y) && (De = e.find(tr(y), function(R) {
                return !!R.typeExpression;
              })), De && De.typeExpression && De.typeExpression.type;
            }
            __name(xe, "xe");
            e.getJSDocType = xe;
            function Ye(y) {
              var De = ft(y);
              if (De && De.typeExpression)
                return De.typeExpression.type;
              var R = me(y);
              if (R && R.typeExpression) {
                var Jt = R.typeExpression.type;
                if (e.isTypeLiteralNode(Jt)) {
                  var Qt = e.find(Jt.members, e.isCallSignatureDeclaration);
                  return Qt && Qt.type;
                }
                if (e.isFunctionTypeNode(Jt) || e.isJSDocFunctionType(Jt))
                  return Jt.type;
              }
            }
            __name(Ye, "Ye");
            e.getJSDocReturnType = Ye;
            function vr(y, De) {
              var R = y.jsDocCache;
              if (R === void 0 || De) {
                var Jt = e.getJSDocCommentsAndTags(y, De);
                e.Debug.assert(Jt.length < 2 || Jt[0] !== Jt[1]), R = e.flatMap(Jt, function(Qt) {
                  return e.isJSDoc(Qt) ? Qt.tags : Qt;
                }), De || (y.jsDocCache = R);
              }
              return R;
            }
            __name(vr, "vr");
            function nt(y) {
              return vr(y, false);
            }
            __name(nt, "nt");
            e.getJSDocTags = nt;
            function pr(y) {
              return vr(y, true);
            }
            __name(pr, "pr");
            e.getJSDocTagsNoCache = pr;
            function Mr(y, De, R) {
              return e.find(vr(y, R), De);
            }
            __name(Mr, "Mr");
            function ot(y, De) {
              return nt(y).filter(De);
            }
            __name(ot, "ot");
            e.getAllJSDocTags = ot;
            function At(y, De) {
              return nt(y).filter(function(R) {
                return R.kind === De;
              });
            }
            __name(At, "At");
            e.getAllJSDocTagsOfKind = At;
            function re(y) {
              return typeof y == "string" ? y : y == null ? void 0 : y.map(function(De) {
                return De.kind === 324 ? De.text : de(De);
              }).join("");
            }
            __name(re, "re");
            e.getTextOfJSDocComment = re;
            function de(y) {
              var De = y.kind === 327 ? "link" : y.kind === 328 ? "linkcode" : "linkplain", R = y.name ? e.entityNameToString(y.name) : "", Jt = y.name && y.text.startsWith("://") ? "" : " ";
              return "{@".concat(De, " ").concat(R).concat(Jt).concat(y.text, "}");
            }
            __name(de, "de");
            function He(y) {
              if (e.isJSDocSignature(y))
                return e.emptyArray;
              if (e.isJSDocTypeAlias(y))
                return e.Debug.assert(y.parent.kind === 323), e.flatMap(y.parent.tags, function(Jt) {
                  return e.isJSDocTemplateTag(Jt) ? Jt.typeParameters : void 0;
                });
              if (y.typeParameters || e.canHaveIllegalTypeParameters(y) && y.typeParameters)
                return y.typeParameters;
              if (e.isInJSFile(y)) {
                var De = e.getJSDocTypeParameterDeclarations(y);
                if (De.length)
                  return De;
                var R = xe(y);
                if (R && e.isFunctionTypeNode(R) && R.typeParameters)
                  return R.typeParameters;
              }
              return e.emptyArray;
            }
            __name(He, "He");
            e.getEffectiveTypeParameterDeclarations = He;
            function Nr(y) {
              return y.constraint ? y.constraint : e.isJSDocTemplateTag(y.parent) && y === y.parent.typeParameters[0] ? y.parent.constraint : void 0;
            }
            __name(Nr, "Nr");
            e.getEffectiveConstraintOfTypeParameter = Nr;
            function Yr(y) {
              return y.kind === 79 || y.kind === 80;
            }
            __name(Yr, "Yr");
            e.isMemberName = Yr;
            function St(y) {
              return y.kind === 175 || y.kind === 174;
            }
            __name(St, "St");
            e.isGetOrSetAccessorDeclaration = St;
            function Dt(y) {
              return e.isPropertyAccessExpression(y) && !!(y.flags & 32);
            }
            __name(Dt, "Dt");
            e.isPropertyAccessChain = Dt;
            function Lt(y) {
              return e.isElementAccessExpression(y) && !!(y.flags & 32);
            }
            __name(Lt, "Lt");
            e.isElementAccessChain = Lt;
            function zt(y) {
              return e.isCallExpression(y) && !!(y.flags & 32);
            }
            __name(zt, "zt");
            e.isCallChain = zt;
            function Zt(y) {
              var De = y.kind;
              return !!(y.flags & 32) && (De === 208 || De === 209 || De === 210 || De === 232);
            }
            __name(Zt, "Zt");
            e.isOptionalChain = Zt;
            function mt(y) {
              return Zt(y) && !e.isNonNullExpression(y) && !!y.questionDotToken;
            }
            __name(mt, "mt");
            e.isOptionalChainRoot = mt;
            function at(y) {
              return mt(y.parent) && y.parent.expression === y;
            }
            __name(at, "at");
            e.isExpressionOfOptionalChainRoot = at;
            function k(y) {
              return !Zt(y.parent) || mt(y.parent) || y !== y.parent.expression;
            }
            __name(k, "k");
            e.isOutermostOptionalChain = k;
            function ue(y) {
              return y.kind === 223 && y.operatorToken.kind === 60;
            }
            __name(ue, "ue");
            e.isNullishCoalesce = ue;
            function Qe(y) {
              return e.isTypeReferenceNode(y) && e.isIdentifier(y.typeName) && y.typeName.escapedText === "const" && !y.typeArguments;
            }
            __name(Qe, "Qe");
            e.isConstTypeReference = Qe;
            function Sr(y) {
              return e.skipOuterExpressions(y, 8);
            }
            __name(Sr, "Sr");
            e.skipPartiallyEmittedExpressions = Sr;
            function Kr(y) {
              return e.isNonNullExpression(y) && !!(y.flags & 32);
            }
            __name(Kr, "Kr");
            e.isNonNullChain = Kr;
            function Hr(y) {
              return y.kind === 249 || y.kind === 248;
            }
            __name(Hr, "Hr");
            e.isBreakOrContinueStatement = Hr;
            function Ct(y) {
              return y.kind === 277 || y.kind === 276;
            }
            __name(Ct, "Ct");
            e.isNamedExportBindings = Ct;
            function Xt(y) {
              switch (y.kind) {
                case 305:
                case 306:
                  return true;
                default:
                  return false;
              }
            }
            __name(Xt, "Xt");
            e.isUnparsedTextLike = Xt;
            function cn(y) {
              return Xt(y) || y.kind === 303 || y.kind === 307;
            }
            __name(cn, "cn");
            e.isUnparsedNode = cn;
            function In(y) {
              return y.kind === 350 || y.kind === 343;
            }
            __name(In, "In");
            e.isJSDocPropertyLikeTag = In;
            function yn(y) {
              return hn(y.kind);
            }
            __name(yn, "yn");
            e.isNode = yn;
            function hn(y) {
              return y >= 163;
            }
            __name(hn, "hn");
            e.isNodeKind = hn;
            function ln(y) {
              return y >= 0 && y <= 162;
            }
            __name(ln, "ln");
            e.isTokenKind = ln;
            function En(y) {
              return ln(y.kind);
            }
            __name(En, "En");
            e.isToken = En;
            function Vt(y) {
              return e.hasProperty(y, "pos") && e.hasProperty(y, "end");
            }
            __name(Vt, "Vt");
            e.isNodeArray = Vt;
            function ui(y) {
              return 8 <= y && y <= 14;
            }
            __name(ui, "ui");
            e.isLiteralKind = ui;
            function ei(y) {
              return ui(y.kind);
            }
            __name(ei, "ei");
            e.isLiteralExpression = ei;
            function vi(y) {
              switch (y.kind) {
                case 207:
                case 206:
                case 13:
                case 215:
                case 228:
                  return true;
              }
              return false;
            }
            __name(vi, "vi");
            e.isLiteralExpressionOfObject = vi;
            function ri(y) {
              return 14 <= y && y <= 17;
            }
            __name(ri, "ri");
            e.isTemplateLiteralKind = ri;
            function bi(y) {
              return ri(y.kind);
            }
            __name(bi, "bi");
            e.isTemplateLiteralToken = bi;
            function Qn(y) {
              var De = y.kind;
              return De === 16 || De === 17;
            }
            __name(Qn, "Qn");
            e.isTemplateMiddleOrTemplateTail = Qn;
            function Yn(y) {
              return e.isImportSpecifier(y) || e.isExportSpecifier(y);
            }
            __name(Yn, "Yn");
            e.isImportOrExportSpecifier = Yn;
            function oi(y) {
              switch (y.kind) {
                case 273:
                case 278:
                  return y.isTypeOnly || y.parent.parent.isTypeOnly;
                case 271:
                  return y.parent.isTypeOnly;
                case 270:
                case 268:
                  return y.isTypeOnly;
                default:
                  return false;
              }
            }
            __name(oi, "oi");
            e.isTypeOnlyImportOrExportDeclaration = oi;
            function Ei(y) {
              return e.isStringLiteral(y) || e.isIdentifier(y);
            }
            __name(Ei, "Ei");
            e.isAssertionKey = Ei;
            function Dn(y) {
              return y.kind === 10 || ri(y.kind);
            }
            __name(Dn, "Dn");
            e.isStringTextContainingNode = Dn;
            function Kn(y) {
              return e.isIdentifier(y) && (y.autoGenerateFlags & 7) > 0;
            }
            __name(Kn, "Kn");
            e.isGeneratedIdentifier = Kn;
            function si(y) {
              return e.isPrivateIdentifier(y) && (y.autoGenerateFlags & 7) > 0;
            }
            __name(si, "si");
            e.isGeneratedPrivateIdentifier = si;
            function mi(y) {
              return (e.isPropertyDeclaration(y) || dt(y)) && e.isPrivateIdentifier(y.name);
            }
            __name(mi, "mi");
            e.isPrivateIdentifierClassElementDeclaration = mi;
            function Zn(y) {
              return e.isPropertyAccessExpression(y) && e.isPrivateIdentifier(y.name);
            }
            __name(Zn, "Zn");
            e.isPrivateIdentifierPropertyAccessExpression = Zn;
            function Fn(y) {
              switch (y) {
                case 126:
                case 127:
                case 132:
                case 85:
                case 136:
                case 88:
                case 93:
                case 101:
                case 123:
                case 121:
                case 122:
                case 146:
                case 124:
                case 145:
                case 161:
                  return true;
              }
              return false;
            }
            __name(Fn, "Fn");
            e.isModifierKind = Fn;
            function gt(y) {
              return !!(e.modifierToFlag(y) & 16476);
            }
            __name(gt, "gt");
            e.isParameterPropertyModifier = gt;
            function gi(y) {
              return gt(y) || y === 124 || y === 161 || y === 127;
            }
            __name(gi, "gi");
            e.isClassMemberModifier = gi;
            function dn(y) {
              return Fn(y.kind);
            }
            __name(dn, "dn");
            e.isModifier = dn;
            function On(y) {
              var De = y.kind;
              return De === 163 || De === 79;
            }
            __name(On, "On");
            e.isEntityName = On;
            function br(y) {
              var De = y.kind;
              return De === 79 || De === 80 || De === 10 || De === 8 || De === 164;
            }
            __name(br, "br");
            e.isPropertyName = br;
            function Ae(y) {
              var De = y.kind;
              return De === 79 || De === 203 || De === 204;
            }
            __name(Ae, "Ae");
            e.isBindingName = Ae;
            function ur(y) {
              return !!y && Me(y.kind);
            }
            __name(ur, "ur");
            e.isFunctionLike = ur;
            function L(y) {
              return !!y && (Me(y.kind) || e.isClassStaticBlockDeclaration(y));
            }
            __name(L, "L");
            e.isFunctionLikeOrClassStaticBlockDeclaration = L;
            function qt(y) {
              return y && fr(y.kind);
            }
            __name(qt, "qt");
            e.isFunctionLikeDeclaration = qt;
            function nn(y) {
              return y.kind === 110 || y.kind === 95;
            }
            __name(nn, "nn");
            e.isBooleanLiteral = nn;
            function fr(y) {
              switch (y) {
                case 259:
                case 171:
                case 173:
                case 174:
                case 175:
                case 215:
                case 216:
                  return true;
                default:
                  return false;
              }
            }
            __name(fr, "fr");
            function Me(y) {
              switch (y) {
                case 170:
                case 176:
                case 326:
                case 177:
                case 178:
                case 181:
                case 320:
                case 182:
                  return true;
                default:
                  return fr(y);
              }
            }
            __name(Me, "Me");
            e.isFunctionLikeKind = Me;
            function Ve(y) {
              return e.isSourceFile(y) || e.isModuleBlock(y) || e.isBlock(y) && ur(y.parent);
            }
            __name(Ve, "Ve");
            e.isFunctionOrModuleBlock = Ve;
            function _r(y) {
              var De = y.kind;
              return De === 173 || De === 169 || De === 171 || De === 174 || De === 175 || De === 178 || De === 172 || De === 237;
            }
            __name(_r, "_r");
            e.isClassElement = _r;
            function lr(y) {
              return y && (y.kind === 260 || y.kind === 228);
            }
            __name(lr, "lr");
            e.isClassLike = lr;
            function Vr(y) {
              return y && (y.kind === 174 || y.kind === 175);
            }
            __name(Vr, "Vr");
            e.isAccessor = Vr;
            function tt(y) {
              return e.isPropertyDeclaration(y) && e.hasAccessorModifier(y);
            }
            __name(tt, "tt");
            e.isAutoAccessorPropertyDeclaration = tt;
            function dt(y) {
              switch (y.kind) {
                case 171:
                case 174:
                case 175:
                  return true;
                default:
                  return false;
              }
            }
            __name(dt, "dt");
            e.isMethodOrAccessor = dt;
            function It(y) {
              switch (y.kind) {
                case 171:
                case 174:
                case 175:
                case 169:
                  return true;
                default:
                  return false;
              }
            }
            __name(It, "It");
            e.isNamedClassElement = It;
            function an(y) {
              return dn(y) || e.isDecorator(y);
            }
            __name(an, "an");
            e.isModifierLike = an;
            function sn(y) {
              var De = y.kind;
              return De === 177 || De === 176 || De === 168 || De === 170 || De === 178 || De === 174 || De === 175;
            }
            __name(sn, "sn");
            e.isTypeElement = sn;
            function _e(y) {
              return sn(y) || _r(y);
            }
            __name(_e, "_e");
            e.isClassOrTypeElement = _e;
            function Gr(y) {
              var De = y.kind;
              return De === 299 || De === 300 || De === 301 || De === 171 || De === 174 || De === 175;
            }
            __name(Gr, "Gr");
            e.isObjectLiteralElementLike = Gr;
            function Kt(y) {
              return e.isTypeNodeKind(y.kind);
            }
            __name(Kt, "Kt");
            e.isTypeNode = Kt;
            function en(y) {
              switch (y.kind) {
                case 181:
                case 182:
                  return true;
              }
              return false;
            }
            __name(en, "en");
            e.isFunctionOrConstructorTypeNode = en;
            function Ot(y) {
              if (y) {
                var De = y.kind;
                return De === 204 || De === 203;
              }
              return false;
            }
            __name(Ot, "Ot");
            e.isBindingPattern = Ot;
            function rr(y) {
              var De = y.kind;
              return De === 206 || De === 207;
            }
            __name(rr, "rr");
            e.isAssignmentPattern = rr;
            function Hn(y) {
              var De = y.kind;
              return De === 205 || De === 229;
            }
            __name(Hn, "Hn");
            e.isArrayBindingElement = Hn;
            function rn(y) {
              switch (y.kind) {
                case 257:
                case 166:
                case 205:
                  return true;
              }
              return false;
            }
            __name(rn, "rn");
            e.isDeclarationBindingElement = rn;
            function xn(y) {
              return Mn(y) || kn(y);
            }
            __name(xn, "xn");
            e.isBindingOrAssignmentPattern = xn;
            function Mn(y) {
              switch (y.kind) {
                case 203:
                case 207:
                  return true;
              }
              return false;
            }
            __name(Mn, "Mn");
            e.isObjectBindingOrAssignmentPattern = Mn;
            function Rn(y) {
              switch (y.kind) {
                case 205:
                case 299:
                case 300:
                case 301:
                  return true;
              }
              return false;
            }
            __name(Rn, "Rn");
            e.isObjectBindingOrAssignmentElement = Rn;
            function kn(y) {
              switch (y.kind) {
                case 204:
                case 206:
                  return true;
              }
              return false;
            }
            __name(kn, "kn");
            e.isArrayBindingOrAssignmentPattern = kn;
            function on(y) {
              var De = y.kind;
              return De === 208 || De === 163 || De === 202;
            }
            __name(on, "on");
            e.isPropertyAccessOrQualifiedNameOrImportTypeNode = on;
            function Xr(y) {
              var De = y.kind;
              return De === 208 || De === 163;
            }
            __name(Xr, "Xr");
            e.isPropertyAccessOrQualifiedName = Xr;
            function wr(y) {
              switch (y.kind) {
                case 283:
                case 282:
                case 210:
                case 211:
                case 212:
                case 167:
                  return true;
                default:
                  return false;
              }
            }
            __name(wr, "wr");
            e.isCallLikeExpression = wr;
            function fn(y) {
              return y.kind === 210 || y.kind === 211;
            }
            __name(fn, "fn");
            e.isCallOrNewExpression = fn;
            function mn(y) {
              var De = y.kind;
              return De === 225 || De === 14;
            }
            __name(mn, "mn");
            e.isTemplateLiteral = mn;
            function Li(y) {
              return An(Sr(y).kind);
            }
            __name(Li, "Li");
            e.isLeftHandSideExpression = Li;
            function An(y) {
              switch (y) {
                case 208:
                case 209:
                case 211:
                case 210:
                case 281:
                case 282:
                case 285:
                case 212:
                case 206:
                case 214:
                case 207:
                case 228:
                case 215:
                case 79:
                case 80:
                case 13:
                case 8:
                case 9:
                case 10:
                case 14:
                case 225:
                case 95:
                case 104:
                case 108:
                case 110:
                case 106:
                case 232:
                case 230:
                case 233:
                case 100:
                  return true;
                default:
                  return false;
              }
            }
            __name(An, "An");
            function wi(y) {
              return ti(Sr(y).kind);
            }
            __name(wi, "wi");
            e.isUnaryExpression = wi;
            function ti(y) {
              switch (y) {
                case 221:
                case 222:
                case 217:
                case 218:
                case 219:
                case 220:
                case 213:
                  return true;
                default:
                  return An(y);
              }
            }
            __name(ti, "ti");
            function li(y) {
              switch (y.kind) {
                case 222:
                  return true;
                case 221:
                  return y.operator === 45 || y.operator === 46;
                default:
                  return false;
              }
            }
            __name(li, "li");
            e.isUnaryExpressionWithWrite = li;
            function Bn(y) {
              return vn(Sr(y).kind);
            }
            __name(Bn, "Bn");
            e.isExpression = Bn;
            function vn(y) {
              switch (y) {
                case 224:
                case 226:
                case 216:
                case 223:
                case 227:
                case 231:
                case 229:
                case 354:
                case 353:
                case 235:
                  return true;
                default:
                  return ti(y);
              }
            }
            __name(vn, "vn");
            function Ue(y) {
              var De = y.kind;
              return De === 213 || De === 231;
            }
            __name(Ue, "Ue");
            e.isAssertionExpression = Ue;
            function Vn(y) {
              return e.isNotEmittedStatement(y) || e.isPartiallyEmittedExpression(y);
            }
            __name(Vn, "Vn");
            e.isNotEmittedOrPartiallyEmittedNode = Vn;
            function Ti(y, De) {
              switch (y.kind) {
                case 245:
                case 246:
                case 247:
                case 243:
                case 244:
                  return true;
                case 253:
                  return De && Ti(y.statement, De);
              }
              return false;
            }
            __name(Ti, "Ti");
            e.isIterationStatement = Ti;
            function ni(y) {
              return e.isExportAssignment(y) || e.isExportDeclaration(y);
            }
            __name(ni, "ni");
            e.isScopeMarker = ni;
            function Bi(y) {
              return e.some(y, ni);
            }
            __name(Bi, "Bi");
            e.hasScopeMarker = Bi;
            function Tn(y) {
              return !e.isAnyImportOrReExport(y) && !e.isExportAssignment(y) && !e.hasSyntacticModifier(y, 1) && !e.isAmbientModule(y);
            }
            __name(Tn, "Tn");
            e.needsScopeMarker = Tn;
            function jn(y) {
              return e.isAnyImportOrReExport(y) || e.isExportAssignment(y) || e.hasSyntacticModifier(y, 1);
            }
            __name(jn, "jn");
            e.isExternalModuleIndicator = jn;
            function Si(y) {
              return y.kind === 246 || y.kind === 247;
            }
            __name(Si, "Si");
            e.isForInOrOfStatement = Si;
            function Ci(y) {
              return e.isBlock(y) || Bn(y);
            }
            __name(Ci, "Ci");
            e.isConciseBody = Ci;
            function C(y) {
              return e.isBlock(y);
            }
            __name(C, "C");
            e.isFunctionBody = C;
            function V(y) {
              return e.isVariableDeclarationList(y) || Bn(y);
            }
            __name(V, "V");
            e.isForInitializer = V;
            function ee(y) {
              var De = y.kind;
              return De === 265 || De === 264 || De === 79;
            }
            __name(ee, "ee");
            e.isModuleBody = ee;
            function le(y) {
              var De = y.kind;
              return De === 265 || De === 264;
            }
            __name(le, "le");
            e.isNamespaceBody = le;
            function Ze(y) {
              var De = y.kind;
              return De === 79 || De === 264;
            }
            __name(Ze, "Ze");
            e.isJSDocNamespaceBody = Ze;
            function Ir(y) {
              var De = y.kind;
              return De === 272 || De === 271;
            }
            __name(Ir, "Ir");
            e.isNamedImportBindings = Ir;
            function Ar(y) {
              return y.kind === 264 || y.kind === 263;
            }
            __name(Ar, "Ar");
            e.isModuleOrEnumDeclaration = Ar;
            function hr(y) {
              return y === 216 || y === 205 || y === 260 || y === 228 || y === 172 || y === 173 || y === 263 || y === 302 || y === 278 || y === 259 || y === 215 || y === 174 || y === 270 || y === 268 || y === 273 || y === 261 || y === 288 || y === 171 || y === 170 || y === 264 || y === 267 || y === 271 || y === 277 || y === 166 || y === 299 || y === 169 || y === 168 || y === 175 || y === 300 || y === 262 || y === 165 || y === 257 || y === 348 || y === 341 || y === 350;
            }
            __name(hr, "hr");
            function yt(y) {
              return y === 259 || y === 279 || y === 260 || y === 261 || y === 262 || y === 263 || y === 264 || y === 269 || y === 268 || y === 275 || y === 274 || y === 267;
            }
            __name(yt, "yt");
            function Pt(y) {
              return y === 249 || y === 248 || y === 256 || y === 243 || y === 241 || y === 239 || y === 246 || y === 247 || y === 245 || y === 242 || y === 253 || y === 250 || y === 252 || y === 254 || y === 255 || y === 240 || y === 244 || y === 251 || y === 352 || y === 356 || y === 355;
            }
            __name(Pt, "Pt");
            function Ut(y) {
              return y.kind === 165 ? y.parent && y.parent.kind !== 347 || e.isInJSFile(y) : hr(y.kind);
            }
            __name(Ut, "Ut");
            e.isDeclaration = Ut;
            function jt(y) {
              return yt(y.kind);
            }
            __name(jt, "jt");
            e.isDeclarationStatement = jt;
            function Ht(y) {
              return Pt(y.kind);
            }
            __name(Ht, "Ht");
            e.isStatementButNotDeclaration = Ht;
            function yi(y) {
              var De = y.kind;
              return Pt(De) || yt(De) || Ni(y);
            }
            __name(yi, "yi");
            e.isStatement = yi;
            function Ni(y) {
              return y.kind !== 238 || y.parent !== void 0 && (y.parent.kind === 255 || y.parent.kind === 295) ? false : !e.isFunctionBlock(y);
            }
            __name(Ni, "Ni");
            function Gn(y) {
              var De = y.kind;
              return Pt(De) || yt(De) || De === 238;
            }
            __name(Gn, "Gn");
            e.isStatementOrBlock = Gn;
            function qi(y) {
              var De = y.kind;
              return De === 280 || De === 163 || De === 79;
            }
            __name(qi, "qi");
            e.isModuleReference = qi;
            function sa(y) {
              var De = y.kind;
              return De === 108 || De === 79 || De === 208;
            }
            __name(sa, "sa");
            e.isJsxTagNameExpression = sa;
            function ea(y) {
              var De = y.kind;
              return De === 281 || De === 291 || De === 282 || De === 11 || De === 285;
            }
            __name(ea, "ea");
            e.isJsxChild = ea;
            function Hi(y) {
              var De = y.kind;
              return De === 288 || De === 290;
            }
            __name(Hi, "Hi");
            e.isJsxAttributeLike = Hi;
            function Ui(y) {
              var De = y.kind;
              return De === 10 || De === 291;
            }
            __name(Ui, "Ui");
            e.isStringLiteralOrJsxExpression = Ui;
            function Gi(y) {
              var De = y.kind;
              return De === 283 || De === 282;
            }
            __name(Gi, "Gi");
            e.isJsxOpeningLikeElement = Gi;
            function Xi(y) {
              var De = y.kind;
              return De === 292 || De === 293;
            }
            __name(Xi, "Xi");
            e.isCaseOrDefaultClause = Xi;
            function ma(y) {
              return y.kind >= 312 && y.kind <= 350;
            }
            __name(ma, "ma");
            e.isJSDocNode = ma;
            function Jn(y) {
              return y.kind === 323 || y.kind === 322 || y.kind === 324 || tn(y) || ra(y) || e.isJSDocTypeLiteral(y) || e.isJSDocSignature(y);
            }
            __name(Jn, "Jn");
            e.isJSDocCommentContainingNode = Jn;
            function ra(y) {
              return y.kind >= 330 && y.kind <= 350;
            }
            __name(ra, "ra");
            e.isJSDocTag = ra;
            function $i(y) {
              return y.kind === 175;
            }
            __name($i, "$i");
            e.isSetAccessor = $i;
            function _a(y) {
              return y.kind === 174;
            }
            __name(_a, "_a");
            e.isGetAccessor = _a;
            function Ri(y) {
              var De = y.jsDoc;
              return !!De && De.length > 0;
            }
            __name(Ri, "Ri");
            e.hasJSDocNodes = Ri;
            function p(y) {
              return !!y.type;
            }
            __name(p, "p");
            e.hasType = p;
            function ne(y) {
              return !!y.initializer;
            }
            __name(ne, "ne");
            e.hasInitializer = ne;
            function Ne(y) {
              switch (y.kind) {
                case 257:
                case 166:
                case 205:
                case 169:
                case 299:
                case 302:
                  return true;
                default:
                  return false;
              }
            }
            __name(Ne, "Ne");
            e.hasOnlyExpressionInitializer = Ne;
            function or(y) {
              return y.kind === 288 || y.kind === 290 || Gr(y);
            }
            __name(or, "or");
            e.isObjectLiteralElement = or;
            function it(y) {
              return y.kind === 180 || y.kind === 230;
            }
            __name(it, "it");
            e.isTypeReferenceType = it;
            var vt = 1073741823;
            function Et(y) {
              for (var De = vt, R = 0, Jt = y; R < Jt.length; R++) {
                var Qt = Jt[R];
                if (!!Qt.length) {
                  for (var qn = 0; qn < Qt.length && qn < De && e.isWhiteSpaceLike(Qt.charCodeAt(qn)); qn++)
                    ;
                  if (qn < De && (De = qn), De === 0)
                    return 0;
                }
              }
              return De === vt ? void 0 : De;
            }
            __name(Et, "Et");
            e.guessIndentation = Et;
            function Tt(y) {
              return y.kind === 10 || y.kind === 14;
            }
            __name(Tt, "Tt");
            e.isStringLiteralLike = Tt;
            function tn(y) {
              return y.kind === 327 || y.kind === 328 || y.kind === 329;
            }
            __name(tn, "tn");
            e.isJSDocLinkLike = tn;
            function Mt(y) {
              var De = e.lastOrUndefined(y.parameters);
              return !!De && $t(De);
            }
            __name(Mt, "Mt");
            e.hasRestParameter = Mt;
            function $t(y) {
              var De = e.isJSDocParameterTag(y) ? y.typeExpression && y.typeExpression.type : y.type;
              return y.dotDotDotToken !== void 0 || !!De && De.kind === 321;
            }
            __name($t, "$t");
            e.isRestParameter = $t;
          })(N || (N = {}));
          var N;
          (function(e) {
            e.resolvingEmptyArray = [], e.externalHelpersModuleNameText = "tslib", e.defaultMaximumTruncationLength = 160, e.noTruncationMaximumTruncationLength = 1e6;
            function t(n, _) {
              var D = n.declarations;
              if (D)
                for (var H = 0, Oe = D; H < Oe.length; H++) {
                  var mr = Oe[H];
                  if (mr.kind === _)
                    return mr;
                }
            }
            __name(t, "t");
            e.getDeclarationOfKind = t;
            function x(n, _) {
              return e.filter(n.declarations || e.emptyArray, function(D) {
                return D.kind === _;
              });
            }
            __name(x, "x");
            e.getDeclarationsOfKind = x;
            function s(n) {
              var _ = new e.Map();
              if (n)
                for (var D = 0, H = n; D < H.length; D++) {
                  var Oe = H[D];
                  _.set(Oe.escapedName, Oe);
                }
              return _;
            }
            __name(s, "s");
            e.createSymbolTable = s;
            function q(n) {
              return (n.flags & 33554432) !== 0;
            }
            __name(q, "q");
            e.isTransientSymbol = q;
            var F = fe();
            function fe() {
              var n = "", _ = /* @__PURE__ */ __name(function(D) {
                return n += D;
              }, "_");
              return { getText: function() {
                return n;
              }, write: _, rawWrite: _, writeKeyword: _, writeOperator: _, writePunctuation: _, writeSpace: _, writeStringLiteral: _, writeLiteral: _, writeParameter: _, writeProperty: _, writeSymbol: function(D, H) {
                return _(D);
              }, writeTrailingSemicolon: _, writeComment: _, getTextPos: function() {
                return n.length;
              }, getLine: function() {
                return 0;
              }, getColumn: function() {
                return 0;
              }, getIndent: function() {
                return 0;
              }, isAtStartOfLine: function() {
                return false;
              }, hasTrailingComment: function() {
                return false;
              }, hasTrailingWhitespace: function() {
                return !!n.length && e.isWhiteSpaceLike(n.charCodeAt(n.length - 1));
              }, writeLine: function() {
                return n += " ";
              }, increaseIndent: e.noop, decreaseIndent: e.noop, clear: function() {
                return n = "";
              }, trackSymbol: function() {
                return false;
              }, reportInaccessibleThisError: e.noop, reportInaccessibleUniqueSymbolError: e.noop, reportPrivateInBaseOfClassExpression: e.noop };
            }
            __name(fe, "fe");
            function Te(n, _) {
              return n.configFilePath !== _.configFilePath || Se(n, _);
            }
            __name(Te, "Te");
            e.changesAffectModuleResolution = Te;
            function Se(n, _) {
              return se(n, _, e.moduleResolutionOptionDeclarations);
            }
            __name(Se, "Se");
            e.optionsHaveModuleResolutionChanges = Se;
            function J(n, _) {
              return se(n, _, e.optionsAffectingProgramStructure);
            }
            __name(J, "J");
            e.changesAffectingProgramStructure = J;
            function se(n, _, D) {
              return n !== _ && D.some(function(H) {
                return !Wl($r(n, H), $r(_, H));
              });
            }
            __name(se, "se");
            e.optionsHaveChanges = se;
            function Le(n, _) {
              for (; ; ) {
                var D = _(n);
                if (D === "quit")
                  return;
                if (D !== void 0)
                  return D;
                if (e.isSourceFile(n))
                  return;
                n = n.parent;
              }
            }
            __name(Le, "Le");
            e.forEachAncestor = Le;
            function Q(n, _) {
              for (var D = n.entries(), H = D.next(); !H.done; H = D.next()) {
                var Oe = H.value, mr = Oe[0], Tr = Oe[1], Qr = _(Tr, mr);
                if (Qr)
                  return Qr;
              }
            }
            __name(Q, "Q");
            e.forEachEntry = Q;
            function Be(n, _) {
              for (var D = n.keys(), H = D.next(); !H.done; H = D.next()) {
                var Oe = _(H.value);
                if (Oe)
                  return Oe;
              }
            }
            __name(Be, "Be");
            e.forEachKey = Be;
            function je(n, _) {
              n.forEach(function(D, H) {
                _.set(H, D);
              });
            }
            __name(je, "je");
            e.copyEntries = je;
            function W(n) {
              var _ = F.getText();
              try {
                return n(F), F.getText();
              } finally {
                F.clear(), F.writeKeyword(_);
              }
            }
            __name(W, "W");
            e.usingSingleLineStringWriter = W;
            function B(n) {
              return n.end - n.pos;
            }
            __name(B, "B");
            e.getFullWidth = B;
            function U(n, _, D) {
              return n && n.resolvedModules && n.resolvedModules.get(_, D);
            }
            __name(U, "U");
            e.getResolvedModule = U;
            function m(n, _, D, H) {
              n.resolvedModules || (n.resolvedModules = e.createModeAwareCache()), n.resolvedModules.set(_, H, D);
            }
            __name(m, "m");
            e.setResolvedModule = m;
            function v(n, _, D) {
              n.resolvedTypeReferenceDirectiveNames || (n.resolvedTypeReferenceDirectiveNames = e.createModeAwareCache()), n.resolvedTypeReferenceDirectiveNames.set(_, void 0, D);
            }
            __name(v, "v");
            e.setResolvedTypeReferenceDirective = v;
            function g(n, _) {
              return n.path === _.path && !n.prepend == !_.prepend && !n.circular == !_.circular;
            }
            __name(g, "g");
            e.projectReferenceIsEqualTo = g;
            function O(n, _) {
              return n.isExternalLibraryImport === _.isExternalLibraryImport && n.extension === _.extension && n.resolvedFileName === _.resolvedFileName && n.originalPath === _.originalPath && S(n.packageId, _.packageId);
            }
            __name(O, "O");
            e.moduleResolutionIsEqualTo = O;
            function S(n, _) {
              return n === _ || !!n && !!_ && n.name === _.name && n.subModuleName === _.subModuleName && n.version === _.version;
            }
            __name(S, "S");
            function te(n) {
              var _ = n.name, D = n.subModuleName;
              return D ? "".concat(_, "/").concat(D) : _;
            }
            __name(te, "te");
            e.packageIdToPackageName = te;
            function Je(n) {
              return "".concat(te(n), "@").concat(n.version);
            }
            __name(Je, "Je");
            e.packageIdToString = Je;
            function qe(n, _) {
              return n.resolvedFileName === _.resolvedFileName && n.primary === _.primary && n.originalPath === _.originalPath;
            }
            __name(qe, "qe");
            e.typeDirectiveIsEqualTo = qe;
            function ge(n, _, D, H, Oe) {
              e.Debug.assert(n.length === _.length);
              for (var mr = 0; mr < n.length; mr++) {
                var Tr = _[mr], Qr = n[mr], bt = e.isString(Qr) ? Qr : Qr.fileName.toLowerCase(), lt = e.isString(Qr) ? H && e.getModeForResolutionAtIndex(H, mr) : e.getModeForFileReference(Qr, H == null ? void 0 : H.impliedNodeFormat), Yt = D && D.get(bt, lt), gn = Yt ? !Tr || !Oe(Yt, Tr) : Tr;
                if (gn)
                  return true;
              }
              return false;
            }
            __name(ge, "ge");
            e.hasChangesInResolutions = ge;
            function ie(n) {
              return G(n), (n.flags & 524288) !== 0;
            }
            __name(ie, "ie");
            e.containsParseError = ie;
            function G(n) {
              if (!(n.flags & 1048576)) {
                var _ = (n.flags & 131072) !== 0 || e.forEachChild(n, ie);
                _ && (n.flags |= 524288), n.flags |= 1048576;
              }
            }
            __name(G, "G");
            function pe(n) {
              for (; n && n.kind !== 308; )
                n = n.parent;
              return n;
            }
            __name(pe, "pe");
            e.getSourceFileOfNode = pe;
            function j(n) {
              return pe(n.valueDeclaration || Ye(n));
            }
            __name(j, "j");
            e.getSourceFileOfModule = j;
            function be(n, _) {
              return !!n && (n.scriptKind === 1 || n.scriptKind === 2) && !n.checkJsDirective && _ === void 0;
            }
            __name(be, "be");
            e.isPlainJsFile = be;
            function $e(n) {
              switch (n.kind) {
                case 238:
                case 266:
                case 245:
                case 246:
                case 247:
                  return true;
              }
              return false;
            }
            __name($e, "$e");
            e.isStatementWithLocals = $e;
            function Re(n, _) {
              return e.Debug.assert(n >= 0), e.getLineStarts(_)[n];
            }
            __name(Re, "Re");
            e.getStartPositionOfLine = Re;
            function Fe(n) {
              var _ = pe(n), D = e.getLineAndCharacterOfPosition(_, n.pos);
              return "".concat(_.fileName, "(").concat(D.line + 1, ",").concat(D.character + 1, ")");
            }
            __name(Fe, "Fe");
            e.nodePosToString = Fe;
            function dr(n, _) {
              e.Debug.assert(n >= 0);
              var D = e.getLineStarts(_), H = n, Oe = _.text;
              if (H + 1 === D.length)
                return Oe.length - 1;
              var mr = D[H], Tr = D[H + 1] - 1;
              for (e.Debug.assert(e.isLineBreak(Oe.charCodeAt(Tr))); mr <= Tr && e.isLineBreak(Oe.charCodeAt(Tr)); )
                Tr--;
              return Tr;
            }
            __name(dr, "dr");
            e.getEndLinePosition = dr;
            function ze(n, _, D) {
              return !(D && D(_)) && !n.identifiers.has(_);
            }
            __name(ze, "ze");
            e.isFileLevelUniqueName = ze;
            function ve(n) {
              return n === void 0 ? true : n.pos === n.end && n.pos >= 0 && n.kind !== 1;
            }
            __name(ve, "ve");
            e.nodeIsMissing = ve;
            function er(n) {
              return !ve(n);
            }
            __name(er, "er");
            e.nodeIsPresent = er;
            function ar(n, _, D) {
              if (_ === void 0 || _.length === 0)
                return n;
              for (var H = 0; H < n.length && D(n[H]); ++H)
                ;
              return n.splice.apply(n, A([H, 0], _, false)), n;
            }
            __name(ar, "ar");
            function Cr(n, _, D) {
              if (_ === void 0)
                return n;
              for (var H = 0; H < n.length && D(n[H]); ++H)
                ;
              return n.splice(H, 0, _), n;
            }
            __name(Cr, "Cr");
            function Ce(n) {
              return Dn(n) || !!(Br(n) & 1048576);
            }
            __name(Ce, "Ce");
            function Xe(n, _) {
              return ar(n, _, Dn);
            }
            __name(Xe, "Xe");
            e.insertStatementsAfterStandardPrologue = Xe;
            function gr(n, _) {
              return ar(n, _, Ce);
            }
            __name(gr, "gr");
            e.insertStatementsAfterCustomPrologue = gr;
            function X(n, _) {
              return Cr(n, _, Dn);
            }
            __name(X, "X");
            e.insertStatementAfterStandardPrologue = X;
            function Ee(n, _) {
              return Cr(n, _, Ce);
            }
            __name(Ee, "Ee");
            e.insertStatementAfterCustomPrologue = Ee;
            function we(n, _, D) {
              if (n.charCodeAt(_ + 1) === 47 && _ + 2 < D && n.charCodeAt(_ + 2) === 47) {
                var H = n.substring(_, D);
                return !!(e.fullTripleSlashReferencePathRegEx.test(H) || e.fullTripleSlashAMDReferencePathRegEx.test(H) || gi.test(H) || dn.test(H));
              }
              return false;
            }
            __name(we, "we");
            e.isRecognizedTripleSlashComment = we;
            function he(n, _) {
              return n.charCodeAt(_ + 1) === 42 && n.charCodeAt(_ + 2) === 33;
            }
            __name(he, "he");
            e.isPinnedComment = he;
            function yr(n, _) {
              var D = new e.Map(_.map(function(Tr) {
                return ["".concat(e.getLineAndCharacterOfPosition(n, Tr.range.end).line), Tr];
              })), H = new e.Map();
              return { getUnusedExpectations: Oe, markUsed: mr };
              function Oe() {
                return e.arrayFrom(D.entries()).filter(function(Tr) {
                  var Qr = Tr[0], bt = Tr[1];
                  return bt.type === 0 && !H.get(Qr);
                }).map(function(Tr) {
                  var Qr = Tr[0], bt = Tr[1];
                  return bt;
                });
              }
              __name(Oe, "Oe");
              function mr(Tr) {
                return D.has("".concat(Tr)) ? (H.set("".concat(Tr), true), true) : false;
              }
              __name(mr, "mr");
            }
            __name(yr, "yr");
            e.createCommentDirectivesMap = yr;
            function kr(n, _, D) {
              return ve(n) ? n.pos : e.isJSDocNode(n) || n.kind === 11 ? e.skipTrivia((_ || pe(n)).text, n.pos, false, true) : D && e.hasJSDocNodes(n) ? kr(n.jsDoc[0], _) : n.kind === 351 && n._children.length > 0 ? kr(n._children[0], _, D) : e.skipTrivia((_ || pe(n)).text, n.pos, false, false, Ut(n));
            }
            __name(kr, "kr");
            e.getTokenPosOfNode = kr;
            function nr(n, _) {
              var D = !ve(n) && e.canHaveModifiers(n) ? e.findLast(n.modifiers, e.isDecorator) : void 0;
              return D ? e.skipTrivia((_ || pe(n)).text, D.end) : kr(n, _);
            }
            __name(nr, "nr");
            e.getNonDecoratorTokenPosOfNode = nr;
            function tr(n, _, D) {
              return D === void 0 && (D = false), ye(n.text, _, D);
            }
            __name(tr, "tr");
            e.getSourceTextOfNodeFromSourceFile = tr;
            function Lr(n) {
              return !!e.findAncestor(n, e.isJSDocTypeExpression);
            }
            __name(Lr, "Lr");
            function zr(n) {
              return !!(e.isExportDeclaration(n) && n.exportClause && e.isNamespaceExport(n.exportClause) && n.exportClause.name.escapedText === "default");
            }
            __name(zr, "zr");
            e.isExportNamespaceAsDefaultDeclaration = zr;
            function ye(n, _, D) {
              if (D === void 0 && (D = false), ve(_))
                return "";
              var H = n.substring(D ? _.pos : e.skipTrivia(n, _.pos), _.end);
              return Lr(_) && (H = H.split(/\r\n|\n|\r/).map(function(Oe) {
                return e.trimStringStart(Oe.replace(/^\s*\*/, ""));
              }).join(`
`)), H;
            }
            __name(ye, "ye");
            e.getTextOfNodeFromSourceText = ye;
            function ir(n, _) {
              return _ === void 0 && (_ = false), tr(pe(n), n, _);
            }
            __name(ir, "ir");
            e.getTextOfNode = ir;
            function Dr(n) {
              return n.pos;
            }
            __name(Dr, "Dr");
            function Pr(n, _) {
              return e.binarySearch(n, _, Dr, e.compareValues);
            }
            __name(Pr, "Pr");
            e.indexOfNode = Pr;
            function Br(n) {
              var _ = n.emitNode;
              return _ && _.flags || 0;
            }
            __name(Br, "Br");
            e.getEmitFlags = Br;
            function ut() {
              return { es2015: { Array: ["find", "findIndex", "fill", "copyWithin", "entries", "keys", "values"], RegExp: ["flags", "sticky", "unicode"], Reflect: ["apply", "construct", "defineProperty", "deleteProperty", "get", " getOwnPropertyDescriptor", "getPrototypeOf", "has", "isExtensible", "ownKeys", "preventExtensions", "set", "setPrototypeOf"], ArrayConstructor: ["from", "of"], ObjectConstructor: ["assign", "getOwnPropertySymbols", "keys", "is", "setPrototypeOf"], NumberConstructor: ["isFinite", "isInteger", "isNaN", "isSafeInteger", "parseFloat", "parseInt"], Math: ["clz32", "imul", "sign", "log10", "log2", "log1p", "expm1", "cosh", "sinh", "tanh", "acosh", "asinh", "atanh", "hypot", "trunc", "fround", "cbrt"], Map: ["entries", "keys", "values"], Set: ["entries", "keys", "values"], Promise: e.emptyArray, PromiseConstructor: ["all", "race", "reject", "resolve"], Symbol: ["for", "keyFor"], WeakMap: ["entries", "keys", "values"], WeakSet: ["entries", "keys", "values"], Iterator: e.emptyArray, AsyncIterator: e.emptyArray, String: ["codePointAt", "includes", "endsWith", "normalize", "repeat", "startsWith", "anchor", "big", "blink", "bold", "fixed", "fontcolor", "fontsize", "italics", "link", "small", "strike", "sub", "sup"], StringConstructor: ["fromCodePoint", "raw"] }, es2016: { Array: ["includes"] }, es2017: { Atomics: e.emptyArray, SharedArrayBuffer: e.emptyArray, String: ["padStart", "padEnd"], ObjectConstructor: ["values", "entries", "getOwnPropertyDescriptors"], DateTimeFormat: ["formatToParts"] }, es2018: { Promise: ["finally"], RegExpMatchArray: ["groups"], RegExpExecArray: ["groups"], RegExp: ["dotAll"], Intl: ["PluralRules"], AsyncIterable: e.emptyArray, AsyncIterableIterator: e.emptyArray, AsyncGenerator: e.emptyArray, AsyncGeneratorFunction: e.emptyArray, NumberFormat: ["formatToParts"] }, es2019: { Array: ["flat", "flatMap"], ObjectConstructor: ["fromEntries"], String: ["trimStart", "trimEnd", "trimLeft", "trimRight"], Symbol: ["description"] }, es2020: { BigInt: e.emptyArray, BigInt64Array: e.emptyArray, BigUint64Array: e.emptyArray, PromiseConstructor: ["allSettled"], SymbolConstructor: ["matchAll"], String: ["matchAll"], DataView: ["setBigInt64", "setBigUint64", "getBigInt64", "getBigUint64"], RelativeTimeFormat: ["format", "formatToParts", "resolvedOptions"] }, es2021: { PromiseConstructor: ["any"], String: ["replaceAll"] }, es2022: { Array: ["at"], String: ["at"], Int8Array: ["at"], Uint8Array: ["at"], Uint8ClampedArray: ["at"], Int16Array: ["at"], Uint16Array: ["at"], Int32Array: ["at"], Uint32Array: ["at"], Float32Array: ["at"], Float64Array: ["at"], BigInt64Array: ["at"], BigUint64Array: ["at"], ObjectConstructor: ["hasOwn"], Error: ["cause"] } };
            }
            __name(ut, "ut");
            e.getScriptTargetFeatures = ut;
            var rt;
            (function(n) {
              n[n.None = 0] = "None", n[n.NeverAsciiEscape = 1] = "NeverAsciiEscape", n[n.JsxAttributeEscape = 2] = "JsxAttributeEscape", n[n.TerminateUnterminatedLiterals = 4] = "TerminateUnterminatedLiterals", n[n.AllowNumericSeparator = 8] = "AllowNumericSeparator";
            })(rt = e.GetLiteralTextFlags || (e.GetLiteralTextFlags = {}));
            function Z(n, _, D) {
              var H;
              if (_ && f(n, D))
                return tr(_, n);
              switch (n.kind) {
                case 10: {
                  var Oe = D & 2 ? K_ : D & 1 || Br(n) & 16777216 ? Oo : oo;
                  return n.singleQuote ? "'" + Oe(n.text, 39) + "'" : '"' + Oe(n.text, 34) + '"';
                }
                case 14:
                case 15:
                case 16:
                case 17: {
                  var Oe = D & 1 || Br(n) & 16777216 ? Oo : oo, mr = (H = n.rawText) !== null && H !== void 0 ? H : F_(Oe(n.text, 96));
                  switch (n.kind) {
                    case 14:
                      return "`" + mr + "`";
                    case 15:
                      return "`" + mr + "${";
                    case 16:
                      return "}" + mr + "${";
                    case 17:
                      return "}" + mr + "`";
                  }
                  break;
                }
                case 8:
                case 9:
                  return n.text;
                case 13:
                  return D & 4 && n.isUnterminated ? n.text + (n.text.charCodeAt(n.text.length - 1) === 92 ? " /" : "/") : n.text;
              }
              return e.Debug.fail("Literal kind '".concat(n.kind, "' not accounted for."));
            }
            __name(Z, "Z");
            e.getLiteralText = Z;
            function f(n, _) {
              return Ca(n) || !n.parent || _ & 4 && n.isUnterminated ? false : e.isNumericLiteral(n) && n.numericLiteralFlags & 512 ? !!(_ & 8) : !e.isBigIntLiteral(n);
            }
            __name(f, "f");
            function h(n) {
              return e.isString(n) ? '"' + oo(n) + '"' : "" + n;
            }
            __name(h, "h");
            e.getTextOfConstantValue = h;
            function ae(n) {
              return e.getBaseFileName(n).replace(/^(\d)/, "_$1").replace(/\W/g, "_");
            }
            __name(ae, "ae");
            e.makeIdentifierFromModuleName = ae;
            function xr(n) {
              return (e.getCombinedNodeFlags(n) & 3) !== 0 || jr(n);
            }
            __name(xr, "xr");
            e.isBlockOrCatchScoped = xr;
            function jr(n) {
              var _ = la(n);
              return _.kind === 257 && _.parent.kind === 295;
            }
            __name(jr, "jr");
            e.isCatchClauseVariableDeclarationOrBindingElement = jr;
            function qr(n) {
              return e.isModuleDeclaration(n) && (n.name.kind === 10 || Ie(n));
            }
            __name(qr, "qr");
            e.isAmbientModule = qr;
            function pt(n) {
              return e.isModuleDeclaration(n) && n.name.kind === 10;
            }
            __name(pt, "pt");
            e.isModuleWithStringLiteralName = pt;
            function Ge(n) {
              return e.isModuleDeclaration(n) && e.isStringLiteral(n.name);
            }
            __name(Ge, "Ge");
            e.isNonGlobalAmbientModule = Ge;
            function K(n) {
              return e.isModuleDeclaration(n) || e.isIdentifier(n);
            }
            __name(K, "K");
            e.isEffectiveModuleDeclaration = K;
            function r(n) {
              return ct(n.valueDeclaration);
            }
            __name(r, "r");
            e.isShorthandAmbientModuleSymbol = r;
            function ct(n) {
              return !!n && n.kind === 264 && !n.body;
            }
            __name(ct, "ct");
            function ft(n) {
              return n.kind === 308 || n.kind === 264 || e.isFunctionLikeOrClassStaticBlockDeclaration(n);
            }
            __name(ft, "ft");
            e.isBlockScopedContainerTopLevel = ft;
            function Ie(n) {
              return !!(n.flags & 1024);
            }
            __name(Ie, "Ie");
            e.isGlobalScopeAugmentation = Ie;
            function me(n) {
              return qr(n) && xe(n);
            }
            __name(me, "me");
            e.isExternalModuleAugmentation = me;
            function xe(n) {
              switch (n.parent.kind) {
                case 308:
                  return e.isExternalModule(n.parent);
                case 265:
                  return qr(n.parent.parent) && e.isSourceFile(n.parent.parent.parent) && !e.isExternalModule(n.parent.parent.parent);
              }
              return false;
            }
            __name(xe, "xe");
            e.isModuleAugmentationExternal = xe;
            function Ye(n) {
              var _;
              return (_ = n.declarations) === null || _ === void 0 ? void 0 : _.find(function(D) {
                return !me(D) && !(e.isModuleDeclaration(D) && Ie(D));
              });
            }
            __name(Ye, "Ye");
            e.getNonAugmentationDeclaration = Ye;
            function vr(n) {
              return n === e.ModuleKind.CommonJS || n === e.ModuleKind.Node16 || n === e.ModuleKind.NodeNext;
            }
            __name(vr, "vr");
            function nt(n, _) {
              return e.isExternalModule(n) || _.isolatedModules || vr(Wi(_)) && !!n.commonJsModuleIndicator;
            }
            __name(nt, "nt");
            e.isEffectiveExternalModule = nt;
            function pr(n, _) {
              switch (n.scriptKind) {
                case 1:
                case 3:
                case 2:
                case 4:
                  break;
                default:
                  return false;
              }
              return n.isDeclarationFile ? false : ku(_, "alwaysStrict") || e.startsWithUseStrict(n.statements) ? true : e.isExternalModule(n) || _.isolatedModules ? Wi(_) >= e.ModuleKind.ES2015 ? true : !_.noImplicitUseStrict : false;
            }
            __name(pr, "pr");
            e.isEffectiveStrictModeSourceFile = pr;
            function Mr(n) {
              return !!(n.flags & 16777216) || aa(n, 2);
            }
            __name(Mr, "Mr");
            e.isAmbientPropertyDeclaration = Mr;
            function ot(n, _) {
              switch (n.kind) {
                case 308:
                case 266:
                case 295:
                case 264:
                case 245:
                case 246:
                case 247:
                case 173:
                case 171:
                case 174:
                case 175:
                case 259:
                case 215:
                case 216:
                case 169:
                case 172:
                  return true;
                case 238:
                  return !e.isFunctionLikeOrClassStaticBlockDeclaration(_);
              }
              return false;
            }
            __name(ot, "ot");
            e.isBlockScope = ot;
            function At(n) {
              switch (n.kind) {
                case 341:
                case 348:
                case 326:
                  return true;
                default:
                  return e.assertType(n), re(n);
              }
            }
            __name(At, "At");
            e.isDeclarationWithTypeParameters = At;
            function re(n) {
              switch (n.kind) {
                case 176:
                case 177:
                case 170:
                case 178:
                case 181:
                case 182:
                case 320:
                case 260:
                case 228:
                case 261:
                case 262:
                case 347:
                case 259:
                case 171:
                case 173:
                case 174:
                case 175:
                case 215:
                case 216:
                  return true;
                default:
                  return e.assertType(n), false;
              }
            }
            __name(re, "re");
            e.isDeclarationWithTypeParameterChildren = re;
            function de(n) {
              switch (n.kind) {
                case 269:
                case 268:
                  return true;
                default:
                  return false;
              }
            }
            __name(de, "de");
            e.isAnyImportSyntax = de;
            function He(n) {
              return de(n) || Ni(n);
            }
            __name(He, "He");
            e.isAnyImportOrBareOrAccessedRequire = He;
            function Nr(n) {
              switch (n.kind) {
                case 269:
                case 268:
                case 240:
                case 260:
                case 259:
                case 264:
                case 262:
                case 261:
                case 263:
                  return true;
                default:
                  return false;
              }
            }
            __name(Nr, "Nr");
            e.isLateVisibilityPaintedStatement = Nr;
            function Yr(n) {
              return St(n) || e.isModuleDeclaration(n) || e.isImportTypeNode(n) || Yn(n);
            }
            __name(Yr, "Yr");
            e.hasPossibleExternalModuleReference = Yr;
            function St(n) {
              return de(n) || e.isExportDeclaration(n);
            }
            __name(St, "St");
            e.isAnyImportOrReExport = St;
            function Dt(n) {
              return e.findAncestor(n.parent, function(_) {
                return ot(_, _.parent);
              });
            }
            __name(Dt, "Dt");
            e.getEnclosingBlockScopeContainer = Dt;
            function Lt(n, _) {
              for (var D = Dt(n); D; )
                _(D), D = Dt(D);
            }
            __name(Lt, "Lt");
            e.forEachEnclosingBlockScopeContainer = Lt;
            function zt(n) {
              return !n || B(n) === 0 ? "(Missing)" : ir(n);
            }
            __name(zt, "zt");
            e.declarationNameToString = zt;
            function Zt(n) {
              return n.declaration ? zt(n.declaration.parameters[0].name) : void 0;
            }
            __name(Zt, "Zt");
            e.getNameFromIndexInfo = Zt;
            function mt(n) {
              return n.kind === 164 && !Pa(n.expression);
            }
            __name(mt, "mt");
            e.isComputedNonLiteralName = mt;
            function at(n) {
              switch (n.kind) {
                case 79:
                case 80:
                  return n.autoGenerateFlags ? void 0 : n.escapedText;
                case 10:
                case 8:
                case 14:
                  return e.escapeLeadingUnderscores(n.text);
                case 164:
                  return Pa(n.expression) ? e.escapeLeadingUnderscores(n.expression.text) : void 0;
                default:
                  return e.Debug.assertNever(n);
              }
            }
            __name(at, "at");
            e.tryGetTextOfPropertyName = at;
            function k(n) {
              return e.Debug.checkDefined(at(n));
            }
            __name(k, "k");
            e.getTextOfPropertyName = k;
            function ue(n) {
              switch (n.kind) {
                case 108:
                  return "this";
                case 80:
                case 79:
                  return B(n) === 0 ? e.idText(n) : ir(n);
                case 163:
                  return ue(n.left) + "." + ue(n.right);
                case 208:
                  return e.isIdentifier(n.name) || e.isPrivateIdentifier(n.name) ? ue(n.expression) + "." + ue(n.name) : e.Debug.assertNever(n.name);
                case 314:
                  return ue(n.left) + ue(n.right);
                default:
                  return e.Debug.assertNever(n);
              }
            }
            __name(ue, "ue");
            e.entityNameToString = ue;
            function Qe(n, _, D, H, Oe, mr) {
              var Tr = pe(n);
              return Kr(Tr, n, _, D, H, Oe, mr);
            }
            __name(Qe, "Qe");
            e.createDiagnosticForNode = Qe;
            function Sr(n, _, D, H, Oe, mr, Tr) {
              var Qr = e.skipTrivia(n.text, _.pos);
              return kt(n, Qr, _.end - Qr, D, H, Oe, mr, Tr);
            }
            __name(Sr, "Sr");
            e.createDiagnosticForNodeArray = Sr;
            function Kr(n, _, D, H, Oe, mr, Tr) {
              var Qr = En(n, _);
              return kt(n, Qr.start, Qr.length, D, H, Oe, mr, Tr);
            }
            __name(Kr, "Kr");
            e.createDiagnosticForNodeInSourceFile = Kr;
            function Hr(n, _, D) {
              var H = pe(n), Oe = En(H, n);
              return Xt(H, Oe.start, Oe.length, _, D);
            }
            __name(Hr, "Hr");
            e.createDiagnosticForNodeFromMessageChain = Hr;
            function Ct(n, _, D) {
              e.Debug.assertGreaterThanOrEqual(_, 0), e.Debug.assertGreaterThanOrEqual(D, 0), n && (e.Debug.assertLessThanOrEqual(_, n.text.length), e.Debug.assertLessThanOrEqual(_ + D, n.text.length));
            }
            __name(Ct, "Ct");
            function Xt(n, _, D, H, Oe) {
              return Ct(n, _, D), { file: n, start: _, length: D, code: H.code, category: H.category, messageText: H.next ? H : H.messageText, relatedInformation: Oe };
            }
            __name(Xt, "Xt");
            e.createFileDiagnosticFromMessageChain = Xt;
            function cn(n, _, D) {
              return { file: n, start: 0, length: 0, code: _.code, category: _.category, messageText: _.next ? _ : _.messageText, relatedInformation: D };
            }
            __name(cn, "cn");
            e.createDiagnosticForFileFromMessageChain = cn;
            function In(n) {
              return typeof n.messageText == "string" ? { code: n.code, category: n.category, messageText: n.messageText, next: n.next } : n.messageText;
            }
            __name(In, "In");
            e.createDiagnosticMessageChainFromDiagnostic = In;
            function yn(n, _, D) {
              return { file: n, start: _.pos, length: _.end - _.pos, code: D.code, category: D.category, messageText: D.message };
            }
            __name(yn, "yn");
            e.createDiagnosticForRange = yn;
            function hn(n, _) {
              var D = e.createScanner(n.languageVersion, true, n.languageVariant, n.text, void 0, _);
              D.scan();
              var H = D.getTokenPos();
              return e.createTextSpanFromBounds(H, D.getTextPos());
            }
            __name(hn, "hn");
            e.getSpanOfTokenAtPosition = hn;
            function ln(n, _) {
              var D = e.skipTrivia(n.text, _.pos);
              if (_.body && _.body.kind === 238) {
                var H = e.getLineAndCharacterOfPosition(n, _.body.pos).line, Oe = e.getLineAndCharacterOfPosition(n, _.body.end).line;
                if (H < Oe)
                  return e.createTextSpan(D, dr(H, n) - D + 1);
              }
              return e.createTextSpanFromBounds(D, _.end);
            }
            __name(ln, "ln");
            function En(n, _) {
              var D = _;
              switch (_.kind) {
                case 308:
                  var H = e.skipTrivia(n.text, 0, false);
                  return H === n.text.length ? e.createTextSpan(0, 0) : hn(n, H);
                case 257:
                case 205:
                case 260:
                case 228:
                case 261:
                case 264:
                case 263:
                case 302:
                case 259:
                case 215:
                case 171:
                case 174:
                case 175:
                case 262:
                case 169:
                case 168:
                case 271:
                  D = _.name;
                  break;
                case 216:
                  return ln(n, _);
                case 292:
                case 293:
                  var Oe = e.skipTrivia(n.text, _.pos), mr = _.statements.length > 0 ? _.statements[0].pos : _.end;
                  return e.createTextSpanFromBounds(Oe, mr);
              }
              if (D === void 0)
                return hn(n, _.pos);
              e.Debug.assert(!e.isJSDoc(D));
              var Tr = ve(D), Qr = Tr || e.isJsxText(_) ? D.pos : e.skipTrivia(n.text, D.pos);
              return Tr ? (e.Debug.assert(Qr === D.pos, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809"), e.Debug.assert(Qr === D.end, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809")) : (e.Debug.assert(Qr >= D.pos, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809"), e.Debug.assert(Qr <= D.end, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809")), e.createTextSpanFromBounds(Qr, D.end);
            }
            __name(En, "En");
            e.getErrorSpanForNode = En;
            function Vt(n) {
              return (n.externalModuleIndicator || n.commonJsModuleIndicator) !== void 0;
            }
            __name(Vt, "Vt");
            e.isExternalOrCommonJsModule = Vt;
            function ui(n) {
              return n.scriptKind === 6;
            }
            __name(ui, "ui");
            e.isJsonSourceFile = ui;
            function ei(n) {
              return !!(e.getCombinedModifierFlags(n) & 2048);
            }
            __name(ei, "ei");
            e.isEnumConst = ei;
            function vi(n) {
              return !!(e.getCombinedModifierFlags(n) & 64 && !e.isParameterPropertyDeclaration(n, n.parent));
            }
            __name(vi, "vi");
            e.isDeclarationReadonly = vi;
            function ri(n) {
              return !!(e.getCombinedNodeFlags(n) & 2);
            }
            __name(ri, "ri");
            e.isVarConst = ri;
            function bi(n) {
              return !!(e.getCombinedNodeFlags(n) & 1);
            }
            __name(bi, "bi");
            e.isLet = bi;
            function Qn(n) {
              return n.kind === 210 && n.expression.kind === 106;
            }
            __name(Qn, "Qn");
            e.isSuperCall = Qn;
            function Yn(n) {
              return n.kind === 210 && n.expression.kind === 100;
            }
            __name(Yn, "Yn");
            e.isImportCall = Yn;
            function oi(n) {
              return e.isMetaProperty(n) && n.keywordToken === 100 && n.name.escapedText === "meta";
            }
            __name(oi, "oi");
            e.isImportMeta = oi;
            function Ei(n) {
              return e.isImportTypeNode(n) && e.isLiteralTypeNode(n.argument) && e.isStringLiteral(n.argument.literal);
            }
            __name(Ei, "Ei");
            e.isLiteralImportTypeNode = Ei;
            function Dn(n) {
              return n.kind === 241 && n.expression.kind === 10;
            }
            __name(Dn, "Dn");
            e.isPrologueDirective = Dn;
            function Kn(n) {
              return !!(Br(n) & 1048576);
            }
            __name(Kn, "Kn");
            e.isCustomPrologue = Kn;
            function si(n) {
              return Kn(n) && e.isFunctionDeclaration(n);
            }
            __name(si, "si");
            e.isHoistedFunction = si;
            function mi(n) {
              return e.isIdentifier(n.name) && !n.initializer;
            }
            __name(mi, "mi");
            function Zn(n) {
              return Kn(n) && e.isVariableStatement(n) && e.every(n.declarationList.declarations, mi);
            }
            __name(Zn, "Zn");
            e.isHoistedVariableStatement = Zn;
            function Fn(n, _) {
              return n.kind !== 11 ? e.getLeadingCommentRanges(_.text, n.pos) : void 0;
            }
            __name(Fn, "Fn");
            e.getLeadingCommentRangesOfNode = Fn;
            function gt(n, _) {
              var D = n.kind === 166 || n.kind === 165 || n.kind === 215 || n.kind === 216 || n.kind === 214 || n.kind === 257 || n.kind === 278 ? e.concatenate(e.getTrailingCommentRanges(_, n.pos), e.getLeadingCommentRanges(_, n.pos)) : e.getLeadingCommentRanges(_, n.pos);
              return e.filter(D, function(H) {
                return _.charCodeAt(H.pos + 1) === 42 && _.charCodeAt(H.pos + 2) === 42 && _.charCodeAt(H.pos + 3) !== 47;
              });
            }
            __name(gt, "gt");
            e.getJSDocCommentRanges = gt, e.fullTripleSlashReferencePathRegEx = /^(\/\/\/\s*<reference\s+path\s*=\s*)(('[^']*')|("[^"]*")).*?\/>/;
            var gi = /^(\/\/\/\s*<reference\s+types\s*=\s*)(('[^']*')|("[^"]*")).*?\/>/;
            e.fullTripleSlashAMDReferencePathRegEx = /^(\/\/\/\s*<amd-dependency\s+path\s*=\s*)(('[^']*')|("[^"]*")).*?\/>/;
            var dn = /^(\/\/\/\s*<reference\s+no-default-lib\s*=\s*)(('[^']*')|("[^"]*"))\s*\/>/;
            function On(n) {
              if (179 <= n.kind && n.kind <= 202)
                return true;
              switch (n.kind) {
                case 131:
                case 157:
                case 148:
                case 160:
                case 152:
                case 134:
                case 153:
                case 149:
                case 155:
                case 144:
                  return true;
                case 114:
                  return n.parent.kind !== 219;
                case 230:
                  return e.isHeritageClause(n.parent) && !Oa(n);
                case 165:
                  return n.parent.kind === 197 || n.parent.kind === 192;
                case 79:
                  (n.parent.kind === 163 && n.parent.right === n || n.parent.kind === 208 && n.parent.name === n) && (n = n.parent), e.Debug.assert(n.kind === 79 || n.kind === 163 || n.kind === 208, "'node' was expected to be a qualified name, identifier or property access in 'isPartOfTypeNode'.");
                case 163:
                case 208:
                case 108: {
                  var _ = n.parent;
                  if (_.kind === 183)
                    return false;
                  if (_.kind === 202)
                    return !_.isTypeOf;
                  if (179 <= _.kind && _.kind <= 202)
                    return true;
                  switch (_.kind) {
                    case 230:
                      return e.isHeritageClause(_.parent) && !Oa(_);
                    case 165:
                      return n === _.constraint;
                    case 347:
                      return n === _.constraint;
                    case 169:
                    case 168:
                    case 166:
                    case 257:
                      return n === _.type;
                    case 259:
                    case 215:
                    case 216:
                    case 173:
                    case 171:
                    case 170:
                    case 174:
                    case 175:
                      return n === _.type;
                    case 176:
                    case 177:
                    case 178:
                      return n === _.type;
                    case 213:
                      return n === _.type;
                    case 210:
                    case 211:
                      return e.contains(_.typeArguments, n);
                    case 212:
                      return false;
                  }
                }
              }
              return false;
            }
            __name(On, "On");
            e.isPartOfTypeNode = On;
            function br(n, _) {
              for (; n; ) {
                if (n.kind === _)
                  return true;
                n = n.parent;
              }
              return false;
            }
            __name(br, "br");
            e.isChildOfNodeWithKind = br;
            function Ae(n, _) {
              return D(n);
              function D(H) {
                switch (H.kind) {
                  case 250:
                    return _(H);
                  case 266:
                  case 238:
                  case 242:
                  case 243:
                  case 244:
                  case 245:
                  case 246:
                  case 247:
                  case 251:
                  case 252:
                  case 292:
                  case 293:
                  case 253:
                  case 255:
                  case 295:
                    return e.forEachChild(H, D);
                }
              }
              __name(D, "D");
            }
            __name(Ae, "Ae");
            e.forEachReturnStatement = Ae;
            function ur(n, _) {
              return D(n);
              function D(H) {
                switch (H.kind) {
                  case 226:
                    _(H);
                    var Oe = H.expression;
                    Oe && D(Oe);
                    return;
                  case 263:
                  case 261:
                  case 264:
                  case 262:
                    return;
                  default:
                    if (e.isFunctionLike(H)) {
                      if (H.name && H.name.kind === 164) {
                        D(H.name.expression);
                        return;
                      }
                    } else
                      On(H) || e.forEachChild(H, D);
                }
              }
              __name(D, "D");
            }
            __name(ur, "ur");
            e.forEachYieldExpression = ur;
            function L(n) {
              return n && n.kind === 185 ? n.elementType : n && n.kind === 180 ? e.singleOrUndefined(n.typeArguments) : void 0;
            }
            __name(L, "L");
            e.getRestParameterElementType = L;
            function qt(n) {
              switch (n.kind) {
                case 261:
                case 260:
                case 228:
                case 184:
                  return n.members;
                case 207:
                  return n.properties;
              }
            }
            __name(qt, "qt");
            e.getMembersOfDeclaration = qt;
            function nn(n) {
              if (n)
                switch (n.kind) {
                  case 205:
                  case 302:
                  case 166:
                  case 299:
                  case 169:
                  case 168:
                  case 300:
                  case 257:
                    return true;
                }
              return false;
            }
            __name(nn, "nn");
            e.isVariableLike = nn;
            function fr(n) {
              return nn(n) || e.isAccessor(n);
            }
            __name(fr, "fr");
            e.isVariableLikeOrAccessor = fr;
            function Me(n) {
              return n.parent.kind === 258 && n.parent.parent.kind === 240;
            }
            __name(Me, "Me");
            e.isVariableDeclarationInVariableStatement = Me;
            function Ve(n) {
              return hr(n) ? e.isObjectLiteralExpression(n.parent) && e.isBinaryExpression(n.parent.parent) && it(n.parent.parent) === 2 || _r(n.parent) : false;
            }
            __name(Ve, "Ve");
            e.isCommonJsExportedExpression = Ve;
            function _r(n) {
              return hr(n) ? e.isBinaryExpression(n) && it(n) === 1 : false;
            }
            __name(_r, "_r");
            e.isCommonJsExportPropertyAssignment = _r;
            function lr(n) {
              return (e.isVariableDeclaration(n) ? ri(n) && e.isIdentifier(n.name) && Me(n) : e.isPropertyDeclaration(n) ? os(n) && u_(n) : e.isPropertySignature(n) && os(n)) || _r(n);
            }
            __name(lr, "lr");
            e.isValidESSymbolDeclaration = lr;
            function Vr(n) {
              switch (n.kind) {
                case 171:
                case 170:
                case 173:
                case 174:
                case 175:
                case 259:
                case 215:
                  return true;
              }
              return false;
            }
            __name(Vr, "Vr");
            e.introducesArgumentsExoticObject = Vr;
            function tt(n, _) {
              for (; ; ) {
                if (_ && _(n), n.statement.kind !== 253)
                  return n.statement;
                n = n.statement;
              }
            }
            __name(tt, "tt");
            e.unwrapInnermostStatementOfLabel = tt;
            function dt(n) {
              return n && n.kind === 238 && e.isFunctionLike(n.parent);
            }
            __name(dt, "dt");
            e.isFunctionBlock = dt;
            function It(n) {
              return n && n.kind === 171 && n.parent.kind === 207;
            }
            __name(It, "It");
            e.isObjectLiteralMethod = It;
            function an(n) {
              return (n.kind === 171 || n.kind === 174 || n.kind === 175) && (n.parent.kind === 207 || n.parent.kind === 228);
            }
            __name(an, "an");
            e.isObjectLiteralOrClassExpressionMethodOrAccessor = an;
            function sn(n) {
              return n && n.kind === 1;
            }
            __name(sn, "sn");
            e.isIdentifierTypePredicate = sn;
            function _e(n) {
              return n && n.kind === 0;
            }
            __name(_e, "_e");
            e.isThisTypePredicate = _e;
            function Gr(n, _, D) {
              return n.properties.filter(function(H) {
                if (H.kind === 299) {
                  var Oe = at(H.name);
                  return _ === Oe || !!D && D === Oe;
                }
                return false;
              });
            }
            __name(Gr, "Gr");
            e.getPropertyAssignment = Gr;
            function Kt(n, _, D) {
              return e.firstDefined(Gr(n, _), function(H) {
                return e.isArrayLiteralExpression(H.initializer) ? e.find(H.initializer.elements, function(Oe) {
                  return e.isStringLiteral(Oe) && Oe.text === D;
                }) : void 0;
              });
            }
            __name(Kt, "Kt");
            e.getPropertyArrayElementValue = Kt;
            function en(n) {
              if (n && n.statements.length) {
                var _ = n.statements[0].expression;
                return e.tryCast(_, e.isObjectLiteralExpression);
              }
            }
            __name(en, "en");
            e.getTsConfigObjectLiteralExpression = en;
            function Ot(n, _, D) {
              return e.firstDefined(rr(n, _), function(H) {
                return e.isArrayLiteralExpression(H.initializer) ? e.find(H.initializer.elements, function(Oe) {
                  return e.isStringLiteral(Oe) && Oe.text === D;
                }) : void 0;
              });
            }
            __name(Ot, "Ot");
            e.getTsConfigPropArrayElementValue = Ot;
            function rr(n, _) {
              var D = en(n);
              return D ? Gr(D, _) : e.emptyArray;
            }
            __name(rr, "rr");
            e.getTsConfigPropArray = rr;
            function Hn(n) {
              return e.findAncestor(n.parent, e.isFunctionLike);
            }
            __name(Hn, "Hn");
            e.getContainingFunction = Hn;
            function rn(n) {
              return e.findAncestor(n.parent, e.isFunctionLikeDeclaration);
            }
            __name(rn, "rn");
            e.getContainingFunctionDeclaration = rn;
            function xn(n) {
              return e.findAncestor(n.parent, e.isClassLike);
            }
            __name(xn, "xn");
            e.getContainingClass = xn;
            function Mn(n) {
              return e.findAncestor(n.parent, function(_) {
                return e.isClassLike(_) || e.isFunctionLike(_) ? "quit" : e.isClassStaticBlockDeclaration(_);
              });
            }
            __name(Mn, "Mn");
            e.getContainingClassStaticBlock = Mn;
            function Rn(n) {
              return e.findAncestor(n.parent, e.isFunctionLikeOrClassStaticBlockDeclaration);
            }
            __name(Rn, "Rn");
            e.getContainingFunctionOrClassStaticBlock = Rn;
            function kn(n, _) {
              for (e.Debug.assert(n.kind !== 308); ; ) {
                if (n = n.parent, !n)
                  return e.Debug.fail();
                switch (n.kind) {
                  case 164:
                    if (e.isClassLike(n.parent.parent))
                      return n;
                    n = n.parent;
                    break;
                  case 167:
                    n.parent.kind === 166 && e.isClassElement(n.parent.parent) ? n = n.parent.parent : e.isClassElement(n.parent) && (n = n.parent);
                    break;
                  case 216:
                    if (!_)
                      continue;
                  case 259:
                  case 215:
                  case 264:
                  case 172:
                  case 169:
                  case 168:
                  case 171:
                  case 170:
                  case 173:
                  case 174:
                  case 175:
                  case 176:
                  case 177:
                  case 178:
                  case 263:
                  case 308:
                    return n;
                }
              }
            }
            __name(kn, "kn");
            e.getThisContainer = kn;
            function on(n) {
              switch (n.kind) {
                case 216:
                case 259:
                case 215:
                case 169:
                  return true;
                case 238:
                  switch (n.parent.kind) {
                    case 173:
                    case 171:
                    case 174:
                    case 175:
                      return true;
                    default:
                      return false;
                  }
                default:
                  return false;
              }
            }
            __name(on, "on");
            e.isThisContainerOrFunctionBlock = on;
            function Xr(n) {
              e.isIdentifier(n) && (e.isClassDeclaration(n.parent) || e.isFunctionDeclaration(n.parent)) && n.parent.name === n && (n = n.parent);
              var _ = kn(n, true);
              return e.isSourceFile(_);
            }
            __name(Xr, "Xr");
            e.isInTopLevelContext = Xr;
            function wr(n) {
              var _ = kn(n, false);
              if (_)
                switch (_.kind) {
                  case 173:
                  case 259:
                  case 215:
                    return _;
                }
            }
            __name(wr, "wr");
            e.getNewTargetContainer = wr;
            function fn(n, _) {
              for (; ; ) {
                if (n = n.parent, !n)
                  return n;
                switch (n.kind) {
                  case 164:
                    n = n.parent;
                    break;
                  case 259:
                  case 215:
                  case 216:
                    if (!_)
                      continue;
                  case 169:
                  case 168:
                  case 171:
                  case 170:
                  case 173:
                  case 174:
                  case 175:
                  case 172:
                    return n;
                  case 167:
                    n.parent.kind === 166 && e.isClassElement(n.parent.parent) ? n = n.parent.parent : e.isClassElement(n.parent) && (n = n.parent);
                    break;
                }
              }
            }
            __name(fn, "fn");
            e.getSuperContainer = fn;
            function mn(n) {
              if (n.kind === 215 || n.kind === 216) {
                for (var _ = n, D = n.parent; D.kind === 214; )
                  _ = D, D = D.parent;
                if (D.kind === 210 && D.expression === _)
                  return D;
              }
            }
            __name(mn, "mn");
            e.getImmediatelyInvokedFunctionExpression = mn;
            function Li(n) {
              return n.kind === 106 || An(n);
            }
            __name(Li, "Li");
            e.isSuperOrSuperProperty = Li;
            function An(n) {
              var _ = n.kind;
              return (_ === 208 || _ === 209) && n.expression.kind === 106;
            }
            __name(An, "An");
            e.isSuperProperty = An;
            function wi(n) {
              var _ = n.kind;
              return (_ === 208 || _ === 209) && n.expression.kind === 108;
            }
            __name(wi, "wi");
            e.isThisProperty = wi;
            function ti(n) {
              var _;
              return !!n && e.isVariableDeclaration(n) && ((_ = n.initializer) === null || _ === void 0 ? void 0 : _.kind) === 108;
            }
            __name(ti, "ti");
            e.isThisInitializedDeclaration = ti;
            function li(n) {
              return !!n && (e.isShorthandPropertyAssignment(n) || e.isPropertyAssignment(n)) && e.isBinaryExpression(n.parent.parent) && n.parent.parent.operatorToken.kind === 63 && n.parent.parent.right.kind === 108;
            }
            __name(li, "li");
            e.isThisInitializedObjectBindingExpression = li;
            function Bn(n) {
              switch (n.kind) {
                case 180:
                  return n.typeName;
                case 230:
                  return Ma(n.expression) ? n.expression : void 0;
                case 79:
                case 163:
                  return n;
              }
            }
            __name(Bn, "Bn");
            e.getEntityNameFromTypeNode = Bn;
            function vn(n) {
              switch (n.kind) {
                case 212:
                  return n.tag;
                case 283:
                case 282:
                  return n.tagName;
                default:
                  return n.expression;
              }
            }
            __name(vn, "vn");
            e.getInvokedExpression = vn;
            function Ue(n, _, D) {
              if (e.isNamedDeclaration(n) && e.isPrivateIdentifier(n.name))
                return false;
              switch (n.kind) {
                case 260:
                  return true;
                case 169:
                  return _.kind === 260;
                case 174:
                case 175:
                case 171:
                  return n.body !== void 0 && _.kind === 260;
                case 166:
                  return _.body !== void 0 && (_.kind === 173 || _.kind === 171 || _.kind === 175) && D.kind === 260;
              }
              return false;
            }
            __name(Ue, "Ue");
            e.nodeCanBeDecorated = Ue;
            function Vn(n, _, D) {
              return ss(n) && Ue(n, _, D);
            }
            __name(Vn, "Vn");
            e.nodeIsDecorated = Vn;
            function Ti(n, _, D) {
              return Vn(n, _, D) || ni(n, _);
            }
            __name(Ti, "Ti");
            e.nodeOrChildIsDecorated = Ti;
            function ni(n, _) {
              switch (n.kind) {
                case 260:
                  return e.some(n.members, function(D) {
                    return Ti(D, n, _);
                  });
                case 171:
                case 175:
                case 173:
                  return e.some(n.parameters, function(D) {
                    return Vn(D, n, _);
                  });
                default:
                  return false;
              }
            }
            __name(ni, "ni");
            e.childIsDecorated = ni;
            function Bi(n) {
              if (Vn(n))
                return true;
              var _ = t_(n);
              return !!_ && ni(_, n);
            }
            __name(Bi, "Bi");
            e.classOrConstructorParameterIsDecorated = Bi;
            function Tn(n) {
              var _ = n.parent;
              return _.kind === 283 || _.kind === 282 || _.kind === 284 ? _.tagName === n : false;
            }
            __name(Tn, "Tn");
            e.isJSXTagName = Tn;
            function jn(n) {
              switch (n.kind) {
                case 106:
                case 104:
                case 110:
                case 95:
                case 13:
                case 206:
                case 207:
                case 208:
                case 209:
                case 210:
                case 211:
                case 212:
                case 231:
                case 213:
                case 235:
                case 232:
                case 214:
                case 215:
                case 228:
                case 216:
                case 219:
                case 217:
                case 218:
                case 221:
                case 222:
                case 223:
                case 224:
                case 227:
                case 225:
                case 229:
                case 281:
                case 282:
                case 285:
                case 226:
                case 220:
                case 233:
                  return true;
                case 230:
                  return !e.isHeritageClause(n.parent);
                case 163:
                  for (; n.parent.kind === 163; )
                    n = n.parent;
                  return n.parent.kind === 183 || e.isJSDocLinkLike(n.parent) || e.isJSDocNameReference(n.parent) || e.isJSDocMemberName(n.parent) || Tn(n);
                case 314:
                  for (; e.isJSDocMemberName(n.parent); )
                    n = n.parent;
                  return n.parent.kind === 183 || e.isJSDocLinkLike(n.parent) || e.isJSDocNameReference(n.parent) || e.isJSDocMemberName(n.parent) || Tn(n);
                case 80:
                  return e.isBinaryExpression(n.parent) && n.parent.left === n && n.parent.operatorToken.kind === 101;
                case 79:
                  if (n.parent.kind === 183 || e.isJSDocLinkLike(n.parent) || e.isJSDocNameReference(n.parent) || e.isJSDocMemberName(n.parent) || Tn(n))
                    return true;
                case 8:
                case 9:
                case 10:
                case 14:
                case 108:
                  return Si(n);
                default:
                  return false;
              }
            }
            __name(jn, "jn");
            e.isExpressionNode = jn;
            function Si(n) {
              var _ = n.parent;
              switch (_.kind) {
                case 257:
                case 166:
                case 169:
                case 168:
                case 302:
                case 299:
                case 205:
                  return _.initializer === n;
                case 241:
                case 242:
                case 243:
                case 244:
                case 250:
                case 251:
                case 252:
                case 292:
                case 254:
                  return _.expression === n;
                case 245:
                  var D = _;
                  return D.initializer === n && D.initializer.kind !== 258 || D.condition === n || D.incrementor === n;
                case 246:
                case 247:
                  var H = _;
                  return H.initializer === n && H.initializer.kind !== 258 || H.expression === n;
                case 213:
                case 231:
                  return n === _.expression;
                case 236:
                  return n === _.expression;
                case 164:
                  return n === _.expression;
                case 167:
                case 291:
                case 290:
                case 301:
                  return true;
                case 230:
                  return _.expression === n && !On(_);
                case 300:
                  return _.objectAssignmentInitializer === n;
                case 235:
                  return n === _.expression;
                default:
                  return jn(_);
              }
            }
            __name(Si, "Si");
            e.isInExpressionContext = Si;
            function Ci(n) {
              for (; n.kind === 163 || n.kind === 79; )
                n = n.parent;
              return n.kind === 183;
            }
            __name(Ci, "Ci");
            e.isPartOfTypeQuery = Ci;
            function C(n) {
              return e.isNamespaceExport(n) && !!n.parent.moduleSpecifier;
            }
            __name(C, "C");
            e.isNamespaceReexportDeclaration = C;
            function V(n) {
              return n.kind === 268 && n.moduleReference.kind === 280;
            }
            __name(V, "V");
            e.isExternalModuleImportEqualsDeclaration = V;
            function ee(n) {
              return e.Debug.assert(V(n)), n.moduleReference.expression;
            }
            __name(ee, "ee");
            e.getExternalModuleImportEqualsDeclarationExpression = ee;
            function le(n) {
              return Ni(n) && Gt(n.initializer).arguments[0];
            }
            __name(le, "le");
            e.getExternalModuleRequireArgument = le;
            function Ze(n) {
              return n.kind === 268 && n.moduleReference.kind !== 280;
            }
            __name(Ze, "Ze");
            e.isInternalModuleImportEqualsDeclaration = Ze;
            function Ir(n) {
              return hr(n);
            }
            __name(Ir, "Ir");
            e.isSourceFileJS = Ir;
            function Ar(n) {
              return !hr(n);
            }
            __name(Ar, "Ar");
            e.isSourceFileNotJS = Ar;
            function hr(n) {
              return !!n && !!(n.flags & 262144);
            }
            __name(hr, "hr");
            e.isInJSFile = hr;
            function yt(n) {
              return !!n && !!(n.flags & 67108864);
            }
            __name(yt, "yt");
            e.isInJsonFile = yt;
            function Pt(n) {
              return !ui(n);
            }
            __name(Pt, "Pt");
            e.isSourceFileNotJson = Pt;
            function Ut(n) {
              return !!n && !!(n.flags & 8388608);
            }
            __name(Ut, "Ut");
            e.isInJSDoc = Ut;
            function jt(n) {
              return e.isTypeReferenceNode(n) && e.isIdentifier(n.typeName) && n.typeName.escapedText === "Object" && n.typeArguments && n.typeArguments.length === 2 && (n.typeArguments[0].kind === 152 || n.typeArguments[0].kind === 148);
            }
            __name(jt, "jt");
            e.isJSDocIndexSignature = jt;
            function Ht(n, _) {
              if (n.kind !== 210)
                return false;
              var D = n, H = D.expression, Oe = D.arguments;
              if (H.kind !== 79 || H.escapedText !== "require" || Oe.length !== 1)
                return false;
              var mr = Oe[0];
              return !_ || e.isStringLiteralLike(mr);
            }
            __name(Ht, "Ht");
            e.isRequireCall = Ht;
            function yi(n) {
              return Gn(n, false);
            }
            __name(yi, "yi");
            e.isVariableDeclarationInitializedToRequire = yi;
            function Ni(n) {
              return Gn(n, true);
            }
            __name(Ni, "Ni");
            e.isVariableDeclarationInitializedToBareOrAccessedRequire = Ni;
            function Gn(n, _) {
              return e.isVariableDeclaration(n) && !!n.initializer && Ht(_ ? Gt(n.initializer) : n.initializer, true);
            }
            __name(Gn, "Gn");
            function qi(n) {
              return e.isVariableStatement(n) && n.declarationList.declarations.length > 0 && e.every(n.declarationList.declarations, function(_) {
                return yi(_);
              });
            }
            __name(qi, "qi");
            e.isRequireVariableStatement = qi;
            function sa(n) {
              return n === 39 || n === 34;
            }
            __name(sa, "sa");
            e.isSingleOrDoubleQuote = sa;
            function ea(n, _) {
              return tr(_, n).charCodeAt(0) === 34;
            }
            __name(ea, "ea");
            e.isStringDoubleQuoted = ea;
            function Hi(n) {
              return e.isBinaryExpression(n) || Rr(n) || e.isIdentifier(n) || e.isCallExpression(n);
            }
            __name(Hi, "Hi");
            e.isAssignmentDeclaration = Hi;
            function Ui(n) {
              return hr(n) && n.initializer && e.isBinaryExpression(n.initializer) && (n.initializer.operatorToken.kind === 56 || n.initializer.operatorToken.kind === 60) && n.name && Ma(n.name) && Ri(n.name, n.initializer.left) ? n.initializer.right : n.initializer;
            }
            __name(Ui, "Ui");
            e.getEffectiveInitializer = Ui;
            function Gi(n) {
              var _ = Ui(n);
              return _ && Jn(_, Va(n.name));
            }
            __name(Gi, "Gi");
            e.getDeclaredExpandoInitializer = Gi;
            function Xi(n, _) {
              return e.forEach(n.properties, function(D) {
                return e.isPropertyAssignment(D) && e.isIdentifier(D.name) && D.name.escapedText === "value" && D.initializer && Jn(D.initializer, _);
              });
            }
            __name(Xi, "Xi");
            function ma(n) {
              if (n && n.parent && e.isBinaryExpression(n.parent) && n.parent.operatorToken.kind === 63) {
                var _ = Va(n.parent.left);
                return Jn(n.parent.right, _) || ra(n.parent.left, n.parent.right, _);
              }
              if (n && e.isCallExpression(n) && vt(n)) {
                var D = Xi(n.arguments[2], n.arguments[1].text === "prototype");
                if (D)
                  return D;
              }
            }
            __name(ma, "ma");
            e.getAssignedExpandoInitializer = ma;
            function Jn(n, _) {
              if (e.isCallExpression(n)) {
                var D = _t(n.expression);
                return D.kind === 215 || D.kind === 216 ? n : void 0;
              }
              if (n.kind === 215 || n.kind === 228 || n.kind === 216 || e.isObjectLiteralExpression(n) && (n.properties.length === 0 || _))
                return n;
            }
            __name(Jn, "Jn");
            e.getExpandoInitializer = Jn;
            function ra(n, _, D) {
              var H = e.isBinaryExpression(_) && (_.operatorToken.kind === 56 || _.operatorToken.kind === 60) && Jn(_.right, D);
              if (H && Ri(n, _.left))
                return H;
            }
            __name(ra, "ra");
            function $i(n) {
              var _ = e.isVariableDeclaration(n.parent) ? n.parent.name : e.isBinaryExpression(n.parent) && n.parent.operatorToken.kind === 63 ? n.parent.left : void 0;
              return _ && Jn(n.right, Va(_)) && Ma(_) && Ri(_, n.left);
            }
            __name($i, "$i");
            e.isDefaultedExpandoInitializer = $i;
            function _a(n) {
              if (e.isBinaryExpression(n.parent)) {
                var _ = (n.parent.operatorToken.kind === 56 || n.parent.operatorToken.kind === 60) && e.isBinaryExpression(n.parent.parent) ? n.parent.parent : n.parent;
                if (_.operatorToken.kind === 63 && e.isIdentifier(_.left))
                  return _.left;
              } else if (e.isVariableDeclaration(n.parent))
                return n.parent.name;
            }
            __name(_a, "_a");
            e.getNameOfExpando = _a;
            function Ri(n, _) {
              return qs(n) && qs(_) ? Qo(n) === Qo(_) : e.isMemberName(n) && Et(_) && (_.expression.kind === 108 || e.isIdentifier(_.expression) && (_.expression.escapedText === "window" || _.expression.escapedText === "self" || _.expression.escapedText === "global")) ? Ri(n, y(_)) : Et(n) && Et(_) ? Qt(n) === Qt(_) && Ri(n.expression, _.expression) : false;
            }
            __name(Ri, "Ri");
            e.isSameEntityName = Ri;
            function p(n) {
              for (; us(n, true); )
                n = n.right;
              return n;
            }
            __name(p, "p");
            e.getRightMostAssignedExpression = p;
            function ne(n) {
              return e.isIdentifier(n) && n.escapedText === "exports";
            }
            __name(ne, "ne");
            e.isExportsIdentifier = ne;
            function Ne(n) {
              return e.isIdentifier(n) && n.escapedText === "module";
            }
            __name(Ne, "Ne");
            e.isModuleIdentifier = Ne;
            function or(n) {
              return (e.isPropertyAccessExpression(n) || Tt(n)) && Ne(n.expression) && Qt(n) === "exports";
            }
            __name(or, "or");
            e.isModuleExportsAccessExpression = or;
            function it(n) {
              var _ = De(n);
              return _ === 5 || hr(n) ? _ : 0;
            }
            __name(it, "it");
            e.getAssignmentDeclarationKind = it;
            function vt(n) {
              return e.length(n.arguments) === 3 && e.isPropertyAccessExpression(n.expression) && e.isIdentifier(n.expression.expression) && e.idText(n.expression.expression) === "Object" && e.idText(n.expression.name) === "defineProperty" && Pa(n.arguments[1]) && $t(n.arguments[0], true);
            }
            __name(vt, "vt");
            e.isBindableObjectDefinePropertyCall = vt;
            function Et(n) {
              return e.isPropertyAccessExpression(n) || Tt(n);
            }
            __name(Et, "Et");
            e.isLiteralLikeAccess = Et;
            function Tt(n) {
              return e.isElementAccessExpression(n) && Pa(n.argumentExpression);
            }
            __name(Tt, "Tt");
            e.isLiteralLikeElementAccess = Tt;
            function tn(n, _) {
              return e.isPropertyAccessExpression(n) && (!_ && n.expression.kind === 108 || e.isIdentifier(n.name) && $t(n.expression, true)) || Mt(n, _);
            }
            __name(tn, "tn");
            e.isBindableStaticAccessExpression = tn;
            function Mt(n, _) {
              return Tt(n) && (!_ && n.expression.kind === 108 || Ma(n.expression) || tn(n.expression, true));
            }
            __name(Mt, "Mt");
            e.isBindableStaticElementAccessExpression = Mt;
            function $t(n, _) {
              return Ma(n) || tn(n, _);
            }
            __name($t, "$t");
            e.isBindableStaticNameExpression = $t;
            function y(n) {
              return e.isPropertyAccessExpression(n) ? n.name : n.argumentExpression;
            }
            __name(y, "y");
            e.getNameOrArgument = y;
            function De(n) {
              if (e.isCallExpression(n)) {
                if (!vt(n))
                  return 0;
                var _ = n.arguments[0];
                return ne(_) || or(_) ? 8 : tn(_) && Qt(_) === "prototype" ? 9 : 7;
              }
              return n.operatorToken.kind !== 63 || !Rr(n.left) || R(p(n)) ? 0 : $t(n.left.expression, true) && Qt(n.left) === "prototype" && e.isObjectLiteralExpression(Ii(n)) ? 6 : qn(n.left);
            }
            __name(De, "De");
            function R(n) {
              return e.isVoidExpression(n) && e.isNumericLiteral(n.expression) && n.expression.text === "0";
            }
            __name(R, "R");
            function Jt(n) {
              if (e.isPropertyAccessExpression(n))
                return n.name;
              var _ = _t(n.argumentExpression);
              return e.isNumericLiteral(_) || e.isStringLiteralLike(_) ? _ : n;
            }
            __name(Jt, "Jt");
            e.getElementOrPropertyAccessArgumentExpressionOrName = Jt;
            function Qt(n) {
              var _ = Jt(n);
              if (_) {
                if (e.isIdentifier(_))
                  return _.escapedText;
                if (e.isStringLiteralLike(_) || e.isNumericLiteral(_))
                  return e.escapeLeadingUnderscores(_.text);
              }
            }
            __name(Qt, "Qt");
            e.getElementOrPropertyAccessName = Qt;
            function qn(n) {
              if (n.expression.kind === 108)
                return 4;
              if (or(n))
                return 2;
              if ($t(n.expression, true)) {
                if (Va(n.expression))
                  return 3;
                for (var _ = n; !e.isIdentifier(_.expression); )
                  _ = _.expression;
                var D = _.expression;
                if ((D.escapedText === "exports" || D.escapedText === "module" && Qt(_) === "exports") && tn(n))
                  return 1;
                if ($t(n, true) || e.isElementAccessExpression(n) && No(n))
                  return 5;
              }
              return 0;
            }
            __name(qn, "qn");
            e.getAssignmentDeclarationPropertyAccessKind = qn;
            function Ii(n) {
              for (; e.isBinaryExpression(n.right); )
                n = n.right;
              return n.right;
            }
            __name(Ii, "Ii");
            e.getInitializerOfBinaryExpression = Ii;
            function ca(n) {
              return e.isBinaryExpression(n) && it(n) === 3;
            }
            __name(ca, "ca");
            e.isPrototypePropertyAssignment = ca;
            function ji(n) {
              return hr(n) && n.parent && n.parent.kind === 241 && (!e.isElementAccessExpression(n) || Tt(n)) && !!e.getJSDocTypeTag(n.parent);
            }
            __name(ji, "ji");
            e.isSpecialPropertyDeclaration = ji;
            function ua(n, _) {
              var D = n.valueDeclaration;
              (!D || !(_.flags & 16777216 && !(D.flags & 16777216)) && Hi(D) && !Hi(_) || D.kind !== _.kind && K(D)) && (n.valueDeclaration = _);
            }
            __name(ua, "ua");
            e.setValueDeclaration = ua;
            function Qi(n) {
              if (!n || !n.valueDeclaration)
                return false;
              var _ = n.valueDeclaration;
              return _.kind === 259 || e.isVariableDeclaration(_) && _.initializer && e.isFunctionLike(_.initializer);
            }
            __name(Qi, "Qi");
            e.isFunctionSymbol = Qi;
            function ta(n) {
              var _, D;
              switch (n.kind) {
                case 257:
                  return (_ = e.findAncestor(n.initializer, function(H) {
                    return Ht(H, true);
                  })) === null || _ === void 0 ? void 0 : _.arguments[0];
                case 269:
                  return e.tryCast(n.moduleSpecifier, e.isStringLiteralLike);
                case 268:
                  return e.tryCast((D = e.tryCast(n.moduleReference, e.isExternalModuleReference)) === null || D === void 0 ? void 0 : D.expression, e.isStringLiteralLike);
                default:
                  e.Debug.assertNever(n);
              }
            }
            __name(ta, "ta");
            e.tryGetModuleSpecifierFromDeclaration = ta;
            function Ta(n) {
              return zi(n) || e.Debug.failBadSyntaxKind(n.parent);
            }
            __name(Ta, "Ta");
            e.importFromModuleSpecifier = Ta;
            function zi(n) {
              switch (n.parent.kind) {
                case 269:
                case 275:
                  return n.parent;
                case 280:
                  return n.parent.parent;
                case 210:
                  return Yn(n.parent) || Ht(n.parent, false) ? n.parent : void 0;
                case 198:
                  return e.Debug.assert(e.isStringLiteral(n)), e.tryCast(n.parent.parent, e.isImportTypeNode);
                default:
                  return;
              }
            }
            __name(zi, "zi");
            e.tryGetImportFromModuleSpecifier = zi;
            function Ji(n) {
              switch (n.kind) {
                case 269:
                case 275:
                  return n.moduleSpecifier;
                case 268:
                  return n.moduleReference.kind === 280 ? n.moduleReference.expression : void 0;
                case 202:
                  return Ei(n) ? n.argument.literal : void 0;
                case 210:
                  return n.arguments[0];
                case 264:
                  return n.name.kind === 10 ? n.name : void 0;
                default:
                  return e.Debug.assertNever(n);
              }
            }
            __name(Ji, "Ji");
            e.getExternalModuleName = Ji;
            function ga(n) {
              switch (n.kind) {
                case 269:
                  return n.importClause && e.tryCast(n.importClause.namedBindings, e.isNamespaceImport);
                case 268:
                  return n;
                case 275:
                  return n.exportClause && e.tryCast(n.exportClause, e.isNamespaceExport);
                default:
                  return e.Debug.assertNever(n);
              }
            }
            __name(ga, "ga");
            e.getNamespaceDeclarationNode = ga;
            function yo(n) {
              return n.kind === 269 && !!n.importClause && !!n.importClause.name;
            }
            __name(yo, "yo");
            e.isDefaultImport = yo;
            function Ns(n, _) {
              if (n.name) {
                var D = _(n);
                if (D)
                  return D;
              }
              if (n.namedBindings) {
                var D = e.isNamespaceImport(n.namedBindings) ? _(n.namedBindings) : e.forEach(n.namedBindings.elements, _);
                if (D)
                  return D;
              }
            }
            __name(Ns, "Ns");
            e.forEachImportClauseDeclaration = Ns;
            function wa(n) {
              if (n)
                switch (n.kind) {
                  case 166:
                  case 171:
                  case 170:
                  case 300:
                  case 299:
                  case 169:
                  case 168:
                    return n.questionToken !== void 0;
                }
              return false;
            }
            __name(wa, "wa");
            e.hasQuestionToken = wa;
            function Wo(n) {
              var _ = e.isJSDocFunctionType(n) ? e.firstOrUndefined(n.parameters) : void 0, D = e.tryCast(_ && _.name, e.isIdentifier);
              return !!D && D.escapedText === "new";
            }
            __name(Wo, "Wo");
            e.isJSDocConstructSignature = Wo;
            function Sa(n) {
              return n.kind === 348 || n.kind === 341 || n.kind === 342;
            }
            __name(Sa, "Sa");
            e.isJSDocTypeAlias = Sa;
            function Fa(n) {
              return Sa(n) || e.isTypeAliasDeclaration(n);
            }
            __name(Fa, "Fa");
            e.isTypeAlias = Fa;
            function ho(n) {
              return e.isExpressionStatement(n) && e.isBinaryExpression(n.expression) && n.expression.operatorToken.kind === 63 ? p(n.expression) : void 0;
            }
            __name(ho, "ho");
            function vo(n) {
              return e.isExpressionStatement(n) && e.isBinaryExpression(n.expression) && it(n.expression) !== 0 && e.isBinaryExpression(n.expression.right) && (n.expression.right.operatorToken.kind === 56 || n.expression.right.operatorToken.kind === 60) ? n.expression.right.right : void 0;
            }
            __name(vo, "vo");
            function eo(n) {
              switch (n.kind) {
                case 240:
                  var _ = Aa(n);
                  return _ && _.initializer;
                case 169:
                  return n.initializer;
                case 299:
                  return n.initializer;
              }
            }
            __name(eo, "eo");
            e.getSingleInitializerOfVariableStatementOrPropertyDeclaration = eo;
            function Aa(n) {
              return e.isVariableStatement(n) ? e.firstOrUndefined(n.declarationList.declarations) : void 0;
            }
            __name(Aa, "Aa");
            e.getSingleVariableOfVariableStatement = Aa;
            function bo(n) {
              return e.isModuleDeclaration(n) && n.body && n.body.kind === 264 ? n.body : void 0;
            }
            __name(bo, "bo");
            function Is(n, _) {
              var D;
              nn(n) && e.hasInitializer(n) && e.hasJSDocNodes(n.initializer) && (D = e.addRange(D, Eo(n, e.last(n.initializer.jsDoc))));
              for (var H = n; H && H.parent; ) {
                if (e.hasJSDocNodes(H) && (D = e.addRange(D, Eo(n, e.last(H.jsDoc)))), H.kind === 166) {
                  D = e.addRange(D, (_ ? e.getJSDocParameterTagsNoCache : e.getJSDocParameterTags)(H));
                  break;
                }
                if (H.kind === 165) {
                  D = e.addRange(D, (_ ? e.getJSDocTypeParameterTagsNoCache : e.getJSDocTypeParameterTags)(H));
                  break;
                }
                H = ka(H);
              }
              return D || e.emptyArray;
            }
            __name(Is, "Is");
            e.getJSDocCommentsAndTags = Is;
            function Eo(n, _) {
              if (e.isJSDoc(_)) {
                var D = e.filter(_.tags, function(H) {
                  return To(n, H);
                });
                return _.tags === D ? [_] : D;
              }
              return To(n, _) ? [_] : void 0;
            }
            __name(Eo, "Eo");
            function To(n, _) {
              return !e.isJSDocTypeTag(_) || !_.parent || !e.isJSDoc(_.parent) || !e.isParenthesizedExpression(_.parent.parent) || _.parent.parent === n;
            }
            __name(To, "To");
            function ka(n) {
              var _ = n.parent;
              if (_.kind === 299 || _.kind === 274 || _.kind === 169 || _.kind === 241 && n.kind === 208 || _.kind === 250 || bo(_) || e.isBinaryExpression(n) && n.operatorToken.kind === 63)
                return _;
              if (_.parent && (Aa(_.parent) === n || e.isBinaryExpression(_) && _.operatorToken.kind === 63))
                return _.parent;
              if (_.parent && _.parent.parent && (Aa(_.parent.parent) || eo(_.parent.parent) === n || vo(_.parent.parent)))
                return _.parent.parent;
            }
            __name(ka, "ka");
            e.getNextJSDocCommentLocation = ka;
            function ro(n) {
              if (n.symbol)
                return n.symbol;
              if (!!e.isIdentifier(n.name)) {
                var _ = n.name.escapedText, D = Oi(n);
                if (!!D) {
                  var H = e.find(D.parameters, function(Oe) {
                    return Oe.name.kind === 79 && Oe.name.escapedText === _;
                  });
                  return H && H.symbol;
                }
              }
            }
            __name(ro, "ro");
            e.getParameterSymbolFromJSDoc = ro;
            function Ko(n) {
              if (e.isJSDoc(n.parent) && n.parent.tags) {
                var _ = e.find(n.parent.tags, Sa);
                if (_)
                  return _;
              }
              return Oi(n);
            }
            __name(Ko, "Ko");
            e.getEffectiveContainerForJSDocTemplateTag = Ko;
            function Oi(n) {
              var _ = Ba(n);
              if (_)
                return e.isPropertySignature(_) && _.type && e.isFunctionLike(_.type) ? _.type : e.isFunctionLike(_) ? _ : void 0;
            }
            __name(Oi, "Oi");
            e.getHostSignatureFromJSDoc = Oi;
            function Ba(n) {
              var _ = to(n);
              if (_)
                return vo(_) || ho(_) || eo(_) || Aa(_) || bo(_) || _;
            }
            __name(Ba, "Ba");
            e.getEffectiveJSDocHost = Ba;
            function to(n) {
              var _ = So(n);
              if (!!_) {
                var D = _.parent;
                if (D && D.jsDoc && _ === e.lastOrUndefined(D.jsDoc))
                  return D;
              }
            }
            __name(to, "to");
            e.getJSDocHost = to;
            function So(n) {
              return e.findAncestor(n.parent, e.isJSDoc);
            }
            __name(So, "So");
            e.getJSDocRoot = So;
            function Co(n) {
              var _ = n.name.escapedText, D = n.parent.parent.parent.typeParameters;
              return D && e.find(D, function(H) {
                return H.name.escapedText === _;
              });
            }
            __name(Co, "Co");
            e.getTypeParameterFromJsDoc = Co;
            function Ho(n) {
              return !!n.typeArguments;
            }
            __name(Ho, "Ho");
            e.hasTypeArguments = Ho;
            var Go;
            (function(n) {
              n[n.None = 0] = "None", n[n.Definite = 1] = "Definite", n[n.Compound = 2] = "Compound";
            })(Go = e.AssignmentKind || (e.AssignmentKind = {}));
            function Vi(n) {
              for (var _ = n.parent; ; ) {
                switch (_.kind) {
                  case 223:
                    var D = _.operatorToken.kind;
                    return Ia(D) && _.left === n ? D === 63 || cs(D) ? 1 : 2 : 0;
                  case 221:
                  case 222:
                    var H = _.operator;
                    return H === 45 || H === 46 ? 2 : 0;
                  case 246:
                  case 247:
                    return _.initializer === n ? 1 : 0;
                  case 214:
                  case 206:
                  case 227:
                  case 232:
                    n = _;
                    break;
                  case 301:
                    n = _.parent;
                    break;
                  case 300:
                    if (_.name !== n)
                      return 0;
                    n = _.parent;
                    break;
                  case 299:
                    if (_.name === n)
                      return 0;
                    n = _.parent;
                    break;
                  default:
                    return 0;
                }
                _ = n.parent;
              }
            }
            __name(Vi, "Vi");
            e.getAssignmentTargetKind = Vi;
            function Os(n) {
              return Vi(n) !== 0;
            }
            __name(Os, "Os");
            e.isAssignmentTarget = Os;
            function Do(n) {
              switch (n.kind) {
                case 238:
                case 240:
                case 251:
                case 242:
                case 252:
                case 266:
                case 292:
                case 293:
                case 253:
                case 245:
                case 246:
                case 247:
                case 243:
                case 244:
                case 255:
                case 295:
                  return true;
              }
              return false;
            }
            __name(Do, "Do");
            e.isNodeWithPossibleHoistedDeclaration = Do;
            function l(n) {
              return e.isFunctionExpression(n) || e.isArrowFunction(n) || e.isMethodOrAccessor(n) || e.isFunctionDeclaration(n) || e.isConstructorDeclaration(n);
            }
            __name(l, "l");
            e.isValueSignatureDeclaration = l;
            function w(n, _) {
              for (; n && n.kind === _; )
                n = n.parent;
              return n;
            }
            __name(w, "w");
            function M(n) {
              return w(n, 193);
            }
            __name(M, "M");
            e.walkUpParenthesizedTypes = M;
            function ke(n) {
              return w(n, 214);
            }
            __name(ke, "ke");
            e.walkUpParenthesizedExpressions = ke;
            function cr(n) {
              for (var _; n && n.kind === 193; )
                _ = n, n = n.parent;
              return [_, n];
            }
            __name(cr, "cr");
            e.walkUpParenthesizedTypesAndGetParentAndChild = cr;
            function Zr(n) {
              for (; e.isParenthesizedTypeNode(n); )
                n = n.type;
              return n;
            }
            __name(Zr, "Zr");
            e.skipTypeParentheses = Zr;
            function _t(n, _) {
              var D = _ ? 17 : 1;
              return e.skipOuterExpressions(n, D);
            }
            __name(_t, "_t");
            e.skipParentheses = _t;
            function Rt(n) {
              return n.kind !== 208 && n.kind !== 209 ? false : (n = ke(n.parent), n && n.kind === 217);
            }
            __name(Rt, "Rt");
            e.isDeleteTarget = Rt;
            function un(n, _) {
              for (; n; ) {
                if (n === _)
                  return true;
                n = n.parent;
              }
              return false;
            }
            __name(un, "un");
            e.isNodeDescendantOf = un;
            function bn(n) {
              return !e.isSourceFile(n) && !e.isBindingPattern(n) && e.isDeclaration(n.parent) && n.parent.name === n;
            }
            __name(bn, "bn");
            e.isDeclarationName = bn;
            function _n(n) {
              var _ = n.parent;
              switch (n.kind) {
                case 10:
                case 14:
                case 8:
                  if (e.isComputedPropertyName(_))
                    return _.parent;
                case 79:
                  if (e.isDeclaration(_))
                    return _.name === n ? _ : void 0;
                  if (e.isQualifiedName(_)) {
                    var D = _.parent;
                    return e.isJSDocParameterTag(D) && D.name === _ ? D : void 0;
                  } else {
                    var H = _.parent;
                    return e.isBinaryExpression(H) && it(H) !== 0 && (H.left.symbol || H.symbol) && e.getNameOfDeclaration(H) === n ? H : void 0;
                  }
                case 80:
                  return e.isDeclaration(_) && _.name === n ? _ : void 0;
                default:
                  return;
              }
            }
            __name(_n, "_n");
            e.getDeclarationFromName = _n;
            function Nt(n) {
              return Pa(n) && n.parent.kind === 164 && e.isDeclaration(n.parent.parent);
            }
            __name(Nt, "Nt");
            e.isLiteralComputedPropertyDeclarationName = Nt;
            function Ft(n) {
              var _ = n.parent;
              switch (_.kind) {
                case 169:
                case 168:
                case 171:
                case 170:
                case 174:
                case 175:
                case 302:
                case 299:
                case 208:
                  return _.name === n;
                case 163:
                  return _.right === n;
                case 205:
                case 273:
                  return _.propertyName === n;
                case 278:
                case 288:
                case 282:
                case 283:
                case 284:
                  return true;
              }
              return false;
            }
            __name(Ft, "Ft");
            e.isIdentifierName = Ft;
            function Sn(n) {
              return n.kind === 268 || n.kind === 267 || n.kind === 270 && !!n.name || n.kind === 271 || n.kind === 277 || n.kind === 273 || n.kind === 278 || n.kind === 274 && Fi(n) ? true : hr(n) && (e.isBinaryExpression(n) && it(n) === 2 && Fi(n) || e.isPropertyAccessExpression(n) && e.isBinaryExpression(n.parent) && n.parent.left === n && n.parent.operatorToken.kind === 63 && Wn(n.parent.right));
            }
            __name(Sn, "Sn");
            e.isAliasSymbolDeclaration = Sn;
            function wn(n) {
              switch (n.parent.kind) {
                case 270:
                case 273:
                case 271:
                case 278:
                case 274:
                case 268:
                case 277:
                  return n.parent;
                case 163:
                  do
                    n = n.parent;
                  while (n.parent.kind === 163);
                  return wn(n);
              }
            }
            __name(wn, "wn");
            e.getAliasDeclarationFromName = wn;
            function Wn(n) {
              return Ma(n) || e.isClassExpression(n);
            }
            __name(Wn, "Wn");
            e.isAliasableExpression = Wn;
            function Fi(n) {
              var _ = qa(n);
              return Wn(_);
            }
            __name(Fi, "Fi");
            e.exportAssignmentIsAlias = Fi;
            function qa(n) {
              return e.isExportAssignment(n) ? n.expression : n.right;
            }
            __name(qa, "qa");
            e.getExportAssignmentExpression = qa;
            function xo(n) {
              return n.kind === 300 ? n.name : n.kind === 299 ? n.initializer : n.parent.right;
            }
            __name(xo, "xo");
            e.getPropertyAssignmentAliasLikeExpression = xo;
            function wo(n) {
              var _ = Ao(n);
              if (_ && hr(n)) {
                var D = e.getJSDocAugmentsTag(n);
                if (D)
                  return D.class;
              }
              return _;
            }
            __name(wo, "wo");
            e.getEffectiveBaseTypeNode = wo;
            function Ao(n) {
              var _ = ko(n.heritageClauses, 94);
              return _ && _.types.length > 0 ? _.types[0] : void 0;
            }
            __name(Ao, "Ao");
            e.getClassExtendsHeritageElement = Ao;
            function no(n) {
              if (hr(n))
                return e.getJSDocImplementsTags(n).map(function(D) {
                  return D.class;
                });
              var _ = ko(n.heritageClauses, 117);
              return _ == null ? void 0 : _.types;
            }
            __name(no, "no");
            e.getEffectiveImplementsTypeNodes = no;
            function Vc(n) {
              return e.isInterfaceDeclaration(n) ? Ms(n) || e.emptyArray : e.isClassLike(n) && e.concatenate(e.singleElementArray(wo(n)), no(n)) || e.emptyArray;
            }
            __name(Vc, "Vc");
            e.getAllSuperTypeNodes = Vc;
            function Ms(n) {
              var _ = ko(n.heritageClauses, 94);
              return _ ? _.types : void 0;
            }
            __name(Ms, "Ms");
            e.getInterfaceBaseTypeNodes = Ms;
            function ko(n, _) {
              if (n)
                for (var D = 0, H = n; D < H.length; D++) {
                  var Oe = H[D];
                  if (Oe.token === _)
                    return Oe;
                }
            }
            __name(ko, "ko");
            e.getHeritageClause = ko;
            function Ls(n, _) {
              for (; n; ) {
                if (n.kind === _)
                  return n;
                n = n.parent;
              }
            }
            __name(Ls, "Ls");
            e.getAncestor = Ls;
            function Xo(n) {
              return 81 <= n && n <= 162;
            }
            __name(Xo, "Xo");
            e.isKeyword = Xo;
            function $o(n) {
              return 126 <= n && n <= 162;
            }
            __name($o, "$o");
            e.isContextualKeyword = $o;
            function w_(n) {
              return Xo(n) && !$o(n);
            }
            __name(w_, "w_");
            e.isNonContextualKeyword = w_;
            function Rs(n) {
              return 117 <= n && n <= 125;
            }
            __name(Rs, "Rs");
            e.isFutureReservedKeyword = Rs;
            function js(n) {
              var _ = e.stringToToken(n);
              return _ !== void 0 && w_(_);
            }
            __name(js, "js");
            e.isStringANonContextualKeyword = js;
            function Js(n) {
              var _ = e.stringToToken(n);
              return _ !== void 0 && Xo(_);
            }
            __name(Js, "Js");
            e.isStringAKeyword = Js;
            function io(n) {
              var _ = n.originalKeywordKind;
              return !!_ && !$o(_);
            }
            __name(io, "io");
            e.isIdentifierANonContextualKeyword = io;
            function A_(n) {
              return 2 <= n && n <= 7;
            }
            __name(A_, "A_");
            e.isTrivia = A_;
            var Wc;
            (function(n) {
              n[n.Normal = 0] = "Normal", n[n.Generator = 1] = "Generator", n[n.Async = 2] = "Async", n[n.Invalid = 4] = "Invalid", n[n.AsyncGenerator = 3] = "AsyncGenerator";
            })(Wc = e.FunctionFlags || (e.FunctionFlags = {}));
            function Kc(n) {
              if (!n)
                return 4;
              var _ = 0;
              switch (n.kind) {
                case 259:
                case 215:
                case 171:
                  n.asteriskToken && (_ |= 1);
                case 216:
                  aa(n, 512) && (_ |= 2);
                  break;
              }
              return n.body || (_ |= 4), _;
            }
            __name(Kc, "Kc");
            e.getFunctionFlags = Kc;
            function Fs(n) {
              switch (n.kind) {
                case 259:
                case 215:
                case 216:
                case 171:
                  return n.body !== void 0 && n.asteriskToken === void 0 && aa(n, 512);
              }
              return false;
            }
            __name(Fs, "Fs");
            e.isAsyncFunction = Fs;
            function Pa(n) {
              return e.isStringLiteralLike(n) || e.isNumericLiteral(n);
            }
            __name(Pa, "Pa");
            e.isStringOrNumericLiteralLike = Pa;
            function Po(n) {
              return e.isPrefixUnaryExpression(n) && (n.operator === 39 || n.operator === 40) && e.isNumericLiteral(n.operand);
            }
            __name(Po, "Po");
            e.isSignedNumericLiteral = Po;
            function Bs(n) {
              var _ = e.getNameOfDeclaration(n);
              return !!_ && No(_);
            }
            __name(Bs, "Bs");
            e.hasDynamicName = Bs;
            function No(n) {
              if (!(n.kind === 164 || n.kind === 209))
                return false;
              var _ = e.isElementAccessExpression(n) ? _t(n.argumentExpression) : n.expression;
              return !Pa(_) && !Po(_);
            }
            __name(No, "No");
            e.isDynamicName = No;
            function ao(n) {
              switch (n.kind) {
                case 79:
                case 80:
                  return n.escapedText;
                case 10:
                case 8:
                  return e.escapeLeadingUnderscores(n.text);
                case 164:
                  var _ = n.expression;
                  return Pa(_) ? e.escapeLeadingUnderscores(_.text) : Po(_) ? _.operator === 40 ? e.tokenToString(_.operator) + _.operand.text : _.operand.text : void 0;
                default:
                  return e.Debug.assertNever(n);
              }
            }
            __name(ao, "ao");
            e.getPropertyNameForPropertyNameNode = ao;
            function qs(n) {
              switch (n.kind) {
                case 79:
                case 10:
                case 14:
                case 8:
                  return true;
                default:
                  return false;
              }
            }
            __name(qs, "qs");
            e.isPropertyNameLiteral = qs;
            function Qo(n) {
              return e.isMemberName(n) ? e.idText(n) : n.text;
            }
            __name(Qo, "Qo");
            e.getTextOfIdentifierOrLiteral = Qo;
            function k_(n) {
              return e.isMemberName(n) ? n.escapedText : e.escapeLeadingUnderscores(n.text);
            }
            __name(k_, "k_");
            e.getEscapedTextOfIdentifierOrLiteral = k_;
            function Us(n) {
              return "__@".concat(e.getSymbolId(n), "@").concat(n.escapedName);
            }
            __name(Us, "Us");
            e.getPropertyNameForUniqueESSymbol = Us;
            function P_(n, _) {
              return "__#".concat(e.getSymbolId(n), "@").concat(_);
            }
            __name(P_, "P_");
            e.getSymbolNameForPrivateIdentifier = P_;
            function Hc(n) {
              return e.startsWith(n.escapedName, "__@");
            }
            __name(Hc, "Hc");
            e.isKnownSymbol = Hc;
            function zs(n) {
              return e.startsWith(n.escapedName, "__#");
            }
            __name(zs, "zs");
            e.isPrivateIdentifierSymbol = zs;
            function N_(n) {
              return n.kind === 79 && n.escapedText === "Symbol";
            }
            __name(N_, "N_");
            e.isESSymbolIdentifier = N_;
            function Gc(n) {
              return n.escapedText === "push" || n.escapedText === "unshift";
            }
            __name(Gc, "Gc");
            e.isPushOrUnshiftIdentifier = Gc;
            function Un(n) {
              var _ = la(n);
              return _.kind === 166;
            }
            __name(Un, "Un");
            e.isParameterDeclaration = Un;
            function la(n) {
              for (; n.kind === 205; )
                n = n.parent.parent;
              return n;
            }
            __name(la, "la");
            e.getRootDeclaration = la;
            function I_(n) {
              var _ = n.kind;
              return _ === 173 || _ === 215 || _ === 259 || _ === 216 || _ === 171 || _ === 174 || _ === 175 || _ === 264 || _ === 308;
            }
            __name(I_, "I_");
            e.nodeStartsNewLexicalEnvironment = I_;
            function Ca(n) {
              return Jc(n.pos) || Jc(n.end);
            }
            __name(Ca, "Ca");
            e.nodeIsSynthesized = Ca;
            function O_(n) {
              return e.getParseTreeNode(n, e.isSourceFile) || n;
            }
            __name(O_, "O_");
            e.getOriginalSourceFile = O_;
            var pi;
            (function(n) {
              n[n.Left = 0] = "Left", n[n.Right = 1] = "Right";
            })(pi = e.Associativity || (e.Associativity = {}));
            function Na(n) {
              var _ = Vs(n), D = n.kind === 211 && n.arguments !== void 0;
              return Ai(n.kind, _, D);
            }
            __name(Na, "Na");
            e.getExpressionAssociativity = Na;
            function Ai(n, _, D) {
              switch (n) {
                case 211:
                  return D ? 0 : 1;
                case 221:
                case 218:
                case 219:
                case 217:
                case 220:
                case 224:
                case 226:
                  return 1;
                case 223:
                  switch (_) {
                    case 42:
                    case 63:
                    case 64:
                    case 65:
                    case 67:
                    case 66:
                    case 68:
                    case 69:
                    case 70:
                    case 71:
                    case 72:
                    case 73:
                    case 78:
                    case 74:
                    case 75:
                    case 76:
                    case 77:
                      return 1;
                  }
              }
              return 0;
            }
            __name(Ai, "Ai");
            e.getOperatorAssociativity = Ai;
            function M_(n) {
              var _ = Vs(n), D = n.kind === 211 && n.arguments !== void 0;
              return Ws(n.kind, _, D);
            }
            __name(M_, "M_");
            e.getExpressionPrecedence = M_;
            function Vs(n) {
              return n.kind === 223 ? n.operatorToken.kind : n.kind === 221 || n.kind === 222 ? n.operator : n.kind;
            }
            __name(Vs, "Vs");
            e.getOperator = Vs;
            var L_;
            (function(n) {
              n[n.Comma = 0] = "Comma", n[n.Spread = 1] = "Spread", n[n.Yield = 2] = "Yield", n[n.Assignment = 3] = "Assignment", n[n.Conditional = 4] = "Conditional", n[n.Coalesce = 4] = "Coalesce", n[n.LogicalOR = 5] = "LogicalOR", n[n.LogicalAND = 6] = "LogicalAND", n[n.BitwiseOR = 7] = "BitwiseOR", n[n.BitwiseXOR = 8] = "BitwiseXOR", n[n.BitwiseAND = 9] = "BitwiseAND", n[n.Equality = 10] = "Equality", n[n.Relational = 11] = "Relational", n[n.Shift = 12] = "Shift", n[n.Additive = 13] = "Additive", n[n.Multiplicative = 14] = "Multiplicative", n[n.Exponentiation = 15] = "Exponentiation", n[n.Unary = 16] = "Unary", n[n.Update = 17] = "Update", n[n.LeftHandSide = 18] = "LeftHandSide", n[n.Member = 19] = "Member", n[n.Primary = 20] = "Primary", n[n.Highest = 20] = "Highest", n[n.Lowest = 0] = "Lowest", n[n.Invalid = -1] = "Invalid";
            })(L_ = e.OperatorPrecedence || (e.OperatorPrecedence = {}));
            function Ws(n, _, D) {
              switch (n) {
                case 354:
                  return 0;
                case 227:
                  return 1;
                case 226:
                  return 2;
                case 224:
                  return 4;
                case 223:
                  switch (_) {
                    case 27:
                      return 0;
                    case 63:
                    case 64:
                    case 65:
                    case 67:
                    case 66:
                    case 68:
                    case 69:
                    case 70:
                    case 71:
                    case 72:
                    case 73:
                    case 78:
                    case 74:
                    case 75:
                    case 76:
                    case 77:
                      return 3;
                    default:
                      return R_(_);
                  }
                case 213:
                case 232:
                case 221:
                case 218:
                case 219:
                case 217:
                case 220:
                  return 16;
                case 222:
                  return 17;
                case 210:
                  return 18;
                case 211:
                  return D ? 19 : 18;
                case 212:
                case 208:
                case 209:
                case 233:
                  return 19;
                case 231:
                case 235:
                  return 11;
                case 108:
                case 106:
                case 79:
                case 80:
                case 104:
                case 110:
                case 95:
                case 8:
                case 9:
                case 10:
                case 206:
                case 207:
                case 215:
                case 216:
                case 228:
                case 13:
                case 14:
                case 225:
                case 214:
                case 229:
                case 281:
                case 282:
                case 285:
                  return 20;
                default:
                  return -1;
              }
            }
            __name(Ws, "Ws");
            e.getOperatorPrecedence = Ws;
            function R_(n) {
              switch (n) {
                case 60:
                  return 4;
                case 56:
                  return 5;
                case 55:
                  return 6;
                case 51:
                  return 7;
                case 52:
                  return 8;
                case 50:
                  return 9;
                case 34:
                case 35:
                case 36:
                case 37:
                  return 10;
                case 29:
                case 31:
                case 32:
                case 33:
                case 102:
                case 101:
                case 128:
                case 150:
                  return 11;
                case 47:
                case 48:
                case 49:
                  return 12;
                case 39:
                case 40:
                  return 13;
                case 41:
                case 43:
                case 44:
                  return 14;
                case 42:
                  return 15;
              }
              return -1;
            }
            __name(R_, "R_");
            e.getBinaryOperatorPrecedence = R_;
            function j_(n) {
              return e.filter(n, function(_) {
                switch (_.kind) {
                  case 291:
                    return !!_.expression;
                  case 11:
                    return !_.containsOnlyTriviaWhiteSpaces;
                  default:
                    return true;
                }
              });
            }
            __name(j_, "j_");
            e.getSemanticJsxChildren = j_;
            function J_() {
              var n = [], _ = [], D = new e.Map(), H = false;
              return { add: mr, lookup: Oe, getGlobalDiagnostics: Tr, getDiagnostics: Qr };
              function Oe(bt) {
                var lt;
                if (bt.file ? lt = D.get(bt.file.fileName) : lt = n, !!lt) {
                  var Yt = e.binarySearch(lt, bt, e.identity, Mc);
                  if (Yt >= 0)
                    return lt[Yt];
                }
              }
              __name(Oe, "Oe");
              function mr(bt) {
                var lt;
                bt.file ? (lt = D.get(bt.file.fileName), lt || (lt = [], D.set(bt.file.fileName, lt), e.insertSorted(_, bt.file.fileName, e.compareStringsCaseSensitive))) : (H && (H = false, n = n.slice()), lt = n), e.insertSorted(lt, bt, Mc);
              }
              __name(mr, "mr");
              function Tr() {
                return H = true, n;
              }
              __name(Tr, "Tr");
              function Qr(bt) {
                if (bt)
                  return D.get(bt) || [];
                var lt = e.flatMapToMutable(_, function(Yt) {
                  return D.get(Yt);
                });
                return n.length && lt.unshift.apply(lt, n), lt;
              }
              __name(Qr, "Qr");
            }
            __name(J_, "J_");
            e.createDiagnosticCollection = J_;
            var Xc = /\$\{/g;
            function F_(n) {
              return n.replace(Xc, "\\${");
            }
            __name(F_, "F_");
            function B_(n) {
              return n && !!(e.isNoSubstitutionTemplateLiteral(n) ? n.templateFlags : n.head.templateFlags || e.some(n.templateSpans, function(_) {
                return !!_.literal.templateFlags;
              }));
            }
            __name(B_, "B_");
            e.hasInvalidEscape = B_;
            var q_ = /[\\\"\u0000-\u001f\t\v\f\b\r\n\u2028\u2029\u0085]/g, Ks = /[\\\'\u0000-\u001f\t\v\f\b\r\n\u2028\u2029\u0085]/g, $c = /\r\n|[\\\`\u0000-\u001f\t\v\f\b\r\u2028\u2029\u0085]/g, Io = new e.Map(e.getEntries({ "	": "\\t", "\v": "\\v", "\f": "\\f", "\b": "\\b", "\r": "\\r", "\n": "\\n", "\\": "\\\\", '"': '\\"', "'": "\\'", "`": "\\`", "\u2028": "\\u2028", "\u2029": "\\u2029", "\x85": "\\u0085", "\r\n": "\\r\\n" }));
            function Hs(n) {
              var _ = n.toString(16).toUpperCase(), D = ("0000" + _).slice(-4);
              return "\\u" + D;
            }
            __name(Hs, "Hs");
            function Gs(n, _, D) {
              if (n.charCodeAt(0) === 0) {
                var H = D.charCodeAt(_ + n.length);
                return H >= 48 && H <= 57 ? "\\x00" : "\\0";
              }
              return Io.get(n) || Hs(n.charCodeAt(0));
            }
            __name(Gs, "Gs");
            function Oo(n, _) {
              var D = _ === 96 ? $c : _ === 39 ? Ks : q_;
              return n.replace(D, Gs);
            }
            __name(Oo, "Oo");
            e.escapeString = Oo;
            var Xs = /[^\u0000-\u007F]/g;
            function oo(n, _) {
              return n = Oo(n, _), Xs.test(n) ? n.replace(Xs, function(D) {
                return Hs(D.charCodeAt(0));
              }) : n;
            }
            __name(oo, "oo");
            e.escapeNonAsciiString = oo;
            var U_ = /[\"\u0000-\u001f\u2028\u2029\u0085]/g, z_ = /[\'\u0000-\u001f\u2028\u2029\u0085]/g, V_ = new e.Map(e.getEntries({ '"': "&quot;", "'": "&apos;" }));
            function Qc(n) {
              var _ = n.toString(16).toUpperCase();
              return "&#x" + _ + ";";
            }
            __name(Qc, "Qc");
            function W_(n) {
              return n.charCodeAt(0) === 0 ? "&#0;" : V_.get(n) || Qc(n.charCodeAt(0));
            }
            __name(W_, "W_");
            function K_(n, _) {
              var D = _ === 39 ? z_ : U_;
              return n.replace(D, W_);
            }
            __name(K_, "K_");
            e.escapeJsxAttributeString = K_;
            function H_(n) {
              var _ = n.length;
              return _ >= 2 && n.charCodeAt(0) === n.charCodeAt(_ - 1) && G_(n.charCodeAt(0)) ? n.substring(1, _ - 1) : n;
            }
            __name(H_, "H_");
            e.stripQuotes = H_;
            function G_(n) {
              return n === 39 || n === 34 || n === 96;
            }
            __name(G_, "G_");
            function Da(n) {
              var _ = n.charCodeAt(0);
              return _ >= 97 && _ <= 122 || e.stringContains(n, "-") || e.stringContains(n, ":");
            }
            __name(Da, "Da");
            e.isIntrinsicJsxName = Da;
            var Ua = ["", "    "];
            function Yo(n) {
              for (var _ = Ua[1], D = Ua.length; D <= n; D++)
                Ua.push(Ua[D - 1] + _);
              return Ua[n];
            }
            __name(Yo, "Yo");
            e.getIndentString = Yo;
            function na() {
              return Ua[1].length;
            }
            __name(na, "na");
            e.getIndentSize = na;
            function $s() {
              return e.stringContains(e.version, "-dev") || e.stringContains(e.version, "-insiders");
            }
            __name($s, "$s");
            e.isNightly = $s;
            function Yc(n) {
              var _, D, H, Oe, mr, Tr = false;
              function Qr(Nn) {
                var ba = e.computeLineStarts(Nn);
                ba.length > 1 ? (Oe = Oe + ba.length - 1, mr = _.length - Nn.length + e.last(ba), H = mr - _.length === 0) : H = false;
              }
              __name(Qr, "Qr");
              function bt(Nn) {
                Nn && Nn.length && (H && (Nn = Yo(D) + Nn, H = false), _ += Nn, Qr(Nn));
              }
              __name(bt, "bt");
              function lt(Nn) {
                Nn && (Tr = false), bt(Nn);
              }
              __name(lt, "lt");
              function Yt(Nn) {
                Nn && (Tr = true), bt(Nn);
              }
              __name(Yt, "Yt");
              function gn() {
                _ = "", D = 0, H = true, Oe = 0, mr = 0, Tr = false;
              }
              __name(gn, "gn");
              function ci(Nn) {
                Nn !== void 0 && (_ += Nn, Qr(Nn), Tr = false);
              }
              __name(ci, "ci");
              function ai(Nn) {
                Nn && Nn.length && lt(Nn);
              }
              __name(ai, "ai");
              function zn(Nn) {
                (!H || Nn) && (_ += n, Oe++, mr = _.length, H = true, Tr = false);
              }
              __name(zn, "zn");
              function Zi() {
                return H ? _.length : _.length + n.length;
              }
              __name(Zi, "Zi");
              return gn(), { write: lt, rawWrite: ci, writeLiteral: ai, writeLine: zn, increaseIndent: function() {
                D++;
              }, decreaseIndent: function() {
                D--;
              }, getIndent: function() {
                return D;
              }, getTextPos: function() {
                return _.length;
              }, getLine: function() {
                return Oe;
              }, getColumn: function() {
                return H ? D * na() : _.length - mr;
              }, getText: function() {
                return _;
              }, isAtStartOfLine: function() {
                return H;
              }, hasTrailingComment: function() {
                return Tr;
              }, hasTrailingWhitespace: function() {
                return !!_.length && e.isWhiteSpaceLike(_.charCodeAt(_.length - 1));
              }, clear: gn, reportInaccessibleThisError: e.noop, reportPrivateInBaseOfClassExpression: e.noop, reportInaccessibleUniqueSymbolError: e.noop, trackSymbol: function() {
                return false;
              }, writeKeyword: lt, writeOperator: lt, writeParameter: lt, writeProperty: lt, writePunctuation: lt, writeSpace: lt, writeStringLiteral: lt, writeSymbol: function(Nn, ba) {
                return lt(Nn);
              }, writeTrailingSemicolon: lt, writeComment: Yt, getTextPosWithWriteLine: Zi };
            }
            __name(Yc, "Yc");
            e.createTextWriter = Yc;
            function so(n) {
              var _ = false;
              function D() {
                _ && (n.writeTrailingSemicolon(";"), _ = false);
              }
              __name(D, "D");
              return T(T({}, n), { writeTrailingSemicolon: function() {
                _ = true;
              }, writeLiteral: function(H) {
                D(), n.writeLiteral(H);
              }, writeStringLiteral: function(H) {
                D(), n.writeStringLiteral(H);
              }, writeSymbol: function(H, Oe) {
                D(), n.writeSymbol(H, Oe);
              }, writePunctuation: function(H) {
                D(), n.writePunctuation(H);
              }, writeKeyword: function(H) {
                D(), n.writeKeyword(H);
              }, writeOperator: function(H) {
                D(), n.writeOperator(H);
              }, writeParameter: function(H) {
                D(), n.writeParameter(H);
              }, writeSpace: function(H) {
                D(), n.writeSpace(H);
              }, writeProperty: function(H) {
                D(), n.writeProperty(H);
              }, writeComment: function(H) {
                D(), n.writeComment(H);
              }, writeLine: function() {
                D(), n.writeLine();
              }, increaseIndent: function() {
                D(), n.increaseIndent();
              }, decreaseIndent: function() {
                D(), n.decreaseIndent();
              } });
            }
            __name(so, "so");
            e.getTrailingSemicolonDeferringWriter = so;
            function X_(n) {
              return n.useCaseSensitiveFileNames ? n.useCaseSensitiveFileNames() : false;
            }
            __name(X_, "X_");
            e.hostUsesCaseSensitiveFileNames = X_;
            function Qs(n) {
              return e.createGetCanonicalFileName(X_(n));
            }
            __name(Qs, "Qs");
            e.hostGetCanonicalFileName = Qs;
            function Ys(n, _, D) {
              return _.moduleName || Zo(n, _.fileName, D && D.fileName);
            }
            __name(Ys, "Ys");
            e.getResolvedExternalModuleName = Ys;
            function $_(n, _) {
              return n.getCanonicalFileName(e.getNormalizedAbsolutePath(_, n.getCurrentDirectory()));
            }
            __name($_, "$_");
            function Q_(n, _, D) {
              var H = _.getExternalModuleFileFromDeclaration(D);
              if (!(!H || H.isDeclarationFile)) {
                var Oe = Ji(D);
                if (!(Oe && e.isStringLiteralLike(Oe) && !e.pathIsRelative(Oe.text) && $_(n, H.path).indexOf($_(n, e.ensureTrailingDirectorySeparator(n.getCommonSourceDirectory()))) === -1))
                  return Ys(n, H);
              }
            }
            __name(Q_, "Q_");
            e.getExternalModuleNameFromDeclaration = Q_;
            function Zo(n, _, D) {
              var H = /* @__PURE__ */ __name(function(bt) {
                return n.getCanonicalFileName(bt);
              }, "H"), Oe = e.toPath(D ? e.getDirectoryPath(D) : n.getCommonSourceDirectory(), n.getCurrentDirectory(), H), mr = e.getNormalizedAbsolutePath(_, n.getCurrentDirectory()), Tr = e.getRelativePathToDirectoryOrUrl(Oe, mr, Oe, H, false), Qr = Pu(Tr);
              return D ? e.ensurePathIsNonModuleName(Qr) : Qr;
            }
            __name(Zo, "Zo");
            e.getExternalModuleNameFromPath = Zo;
            function Y_(n, _, D) {
              var H = _.getCompilerOptions(), Oe;
              return H.outDir ? Oe = Pu(Mo(n, _, H.outDir)) : Oe = Pu(n), Oe + D;
            }
            __name(Y_, "Y_");
            e.getOwnEmitOutputFilePath = Y_;
            function Z_(n, _) {
              return es(n, _.getCompilerOptions(), _.getCurrentDirectory(), _.getCommonSourceDirectory(), function(D) {
                return _.getCanonicalFileName(D);
              });
            }
            __name(Z_, "Z_");
            e.getDeclarationEmitOutputFilePath = Z_;
            function es(n, _, D, H, Oe) {
              var mr = _.declarationDir || _.outDir, Tr = mr ? r_(n, mr, D, H, Oe) : n, Qr = ec(Tr);
              return Pu(Tr) + Qr;
            }
            __name(es, "es");
            e.getDeclarationEmitOutputFilePathWorker = es;
            function ec(n) {
              return e.fileExtensionIsOneOf(n, [".mjs", ".mts"]) ? ".d.mts" : e.fileExtensionIsOneOf(n, [".cjs", ".cts"]) ? ".d.cts" : e.fileExtensionIsOneOf(n, [".json"]) ? ".json.d.ts" : ".d.ts";
            }
            __name(ec, "ec");
            e.getDeclarationEmitExtensionForPath = ec;
            function Zc(n) {
              return e.fileExtensionIsOneOf(n, [".d.mts", ".mjs", ".mts"]) ? [".mts", ".mjs"] : e.fileExtensionIsOneOf(n, [".d.cts", ".cjs", ".cts"]) ? [".cts", ".cjs"] : e.fileExtensionIsOneOf(n, [".json.d.ts"]) ? [".json"] : [".tsx", ".ts", ".jsx", ".js"];
            }
            __name(Zc, "Zc");
            e.getPossibleOriginalInputExtensionForExtension = Zc;
            function Zs(n) {
              return n.outFile || n.out;
            }
            __name(Zs, "Zs");
            e.outFile = Zs;
            function eu(n, _) {
              var D, H;
              if (!!n.paths)
                return (D = n.baseUrl) !== null && D !== void 0 ? D : e.Debug.checkDefined(n.pathsBasePath || ((H = _.getCurrentDirectory) === null || H === void 0 ? void 0 : H.call(_)), "Encountered 'paths' without a 'baseUrl', config file, or host 'getCurrentDirectory'.");
            }
            __name(eu, "eu");
            e.getPathsBasePath = eu;
            function rc(n, _, D) {
              var H = n.getCompilerOptions();
              if (Zs(H)) {
                var Oe = Wi(H), mr = H.emitDeclarationOnly || Oe === e.ModuleKind.AMD || Oe === e.ModuleKind.System;
                return e.filter(n.getSourceFiles(), function(Qr) {
                  return (mr || !e.isExternalModule(Qr)) && e_(Qr, n, D);
                });
              } else {
                var Tr = _ === void 0 ? n.getSourceFiles() : [_];
                return e.filter(Tr, function(Qr) {
                  return e_(Qr, n, D);
                });
              }
            }
            __name(rc, "rc");
            e.getSourceFilesToEmit = rc;
            function e_(n, _, D) {
              var H = _.getCompilerOptions();
              return !(H.noEmitForJsFiles && Ir(n)) && !n.isDeclarationFile && !_.isSourceFileFromExternalLibrary(n) && (D || !(ui(n) && _.getResolvedProjectReferenceToRedirect(n.fileName)) && !_.isSourceOfProjectReferenceRedirect(n.fileName));
            }
            __name(e_, "e_");
            e.sourceFileMayBeEmitted = e_;
            function Mo(n, _, D) {
              return r_(n, D, _.getCurrentDirectory(), _.getCommonSourceDirectory(), function(H) {
                return _.getCanonicalFileName(H);
              });
            }
            __name(Mo, "Mo");
            e.getSourceFilePathInNewDir = Mo;
            function r_(n, _, D, H, Oe) {
              var mr = e.getNormalizedAbsolutePath(n, D), Tr = Oe(mr).indexOf(Oe(H)) === 0;
              return mr = Tr ? mr.substring(H.length) : mr, e.combinePaths(_, mr);
            }
            __name(r_, "r_");
            e.getSourceFilePathInNewDirWorker = r_;
            function tc(n, _, D, H, Oe, mr, Tr) {
              n.writeFile(D, H, Oe, function(Qr) {
                _.add(fa(e.Diagnostics.Could_not_write_file_0_Colon_1, D, Qr));
              }, mr, Tr);
            }
            __name(tc, "tc");
            e.writeFile = tc;
            function Lo(n, _, D) {
              if (n.length > e.getRootLength(n) && !D(n)) {
                var H = e.getDirectoryPath(n);
                Lo(H, _, D), _(n);
              }
            }
            __name(Lo, "Lo");
            function ia(n, _, D, H, Oe, mr) {
              try {
                H(n, _, D);
              } catch {
                Lo(e.getDirectoryPath(e.normalizePath(n)), Oe, mr), H(n, _, D);
              }
            }
            __name(ia, "ia");
            e.writeFileEnsuringDirectories = ia;
            function Yi(n, _) {
              var D = e.getLineStarts(n);
              return e.computeLineOfPosition(D, _);
            }
            __name(Yi, "Yi");
            e.getLineOfLocalPosition = Yi;
            function pa(n, _) {
              return e.computeLineOfPosition(n, _);
            }
            __name(pa, "pa");
            e.getLineOfLocalPositionFromLineMap = pa;
            function t_(n) {
              return e.find(n.members, function(_) {
                return e.isConstructorDeclaration(_) && er(_.body);
              });
            }
            __name(t_, "t_");
            e.getFirstConstructorWithBody = t_;
            function _o(n) {
              if (n && n.parameters.length > 0) {
                var _ = n.parameters.length === 2 && rs(n.parameters[0]);
                return n.parameters[_ ? 1 : 0];
              }
            }
            __name(_o, "_o");
            e.getSetAccessorValueParameter = _o;
            function ru(n) {
              var _ = _o(n);
              return _ && _.type;
            }
            __name(ru, "ru");
            e.getSetAccessorTypeAnnotationNode = ru;
            function n_(n) {
              if (n.parameters.length && !e.isJSDocSignature(n)) {
                var _ = n.parameters[0];
                if (rs(_))
                  return _;
              }
            }
            __name(n_, "n_");
            e.getThisParameter = n_;
            function rs(n) {
              return ts(n.name);
            }
            __name(rs, "rs");
            e.parameterIsThisKeyword = rs;
            function ts(n) {
              return !!n && n.kind === 79 && i_(n);
            }
            __name(ts, "ts");
            e.isThisIdentifier = ts;
            function nc(n) {
              if (!ts(n))
                return false;
              for (; e.isQualifiedName(n.parent) && n.parent.left === n; )
                n = n.parent;
              return n.parent.kind === 183;
            }
            __name(nc, "nc");
            e.isThisInTypeQuery = nc;
            function i_(n) {
              return n.originalKeywordKind === 108;
            }
            __name(i_, "i_");
            e.identifierIsThisKeyword = i_;
            function ic(n, _) {
              var D, H, Oe, mr;
              return Bs(_) ? (D = _, _.kind === 174 ? Oe = _ : _.kind === 175 ? mr = _ : e.Debug.fail("Accessor has wrong kind")) : e.forEach(n, function(Tr) {
                if (e.isAccessor(Tr) && as(Tr) === as(_)) {
                  var Qr = ao(Tr.name), bt = ao(_.name);
                  Qr === bt && (D ? H || (H = Tr) : D = Tr, Tr.kind === 174 && !Oe && (Oe = Tr), Tr.kind === 175 && !mr && (mr = Tr));
                }
              }), { firstAccessor: D, secondAccessor: H, getAccessor: Oe, setAccessor: mr };
            }
            __name(ic, "ic");
            e.getAllAccessorDeclarations = ic;
            function ns(n) {
              if (!(!hr(n) && e.isFunctionDeclaration(n))) {
                var _ = n.type;
                return _ || !hr(n) ? _ : e.isJSDocPropertyLikeTag(n) ? n.typeExpression && n.typeExpression.type : e.getJSDocType(n);
              }
            }
            __name(ns, "ns");
            e.getEffectiveTypeAnnotationNode = ns;
            function a_(n) {
              return n.type;
            }
            __name(a_, "a_");
            e.getTypeAnnotationNode = a_;
            function o_(n) {
              return e.isJSDocSignature(n) ? n.type && n.type.typeExpression && n.type.typeExpression.type : n.type || (hr(n) ? e.getJSDocReturnType(n) : void 0);
            }
            __name(o_, "o_");
            e.getEffectiveReturnTypeNode = o_;
            function co(n) {
              return e.flatMap(e.getJSDocTags(n), function(_) {
                return tu(_) ? _.typeParameters : void 0;
              });
            }
            __name(co, "co");
            e.getJSDocTypeParameterDeclarations = co;
            function tu(n) {
              return e.isJSDocTemplateTag(n) && !(n.parent.kind === 323 && n.parent.tags.some(Sa));
            }
            __name(tu, "tu");
            function za(n) {
              var _ = _o(n);
              return _ && ns(_);
            }
            __name(za, "za");
            e.getEffectiveSetAccessorTypeAnnotationNode = za;
            function Ro(n, _, D, H) {
              s_(n, _, D.pos, H);
            }
            __name(Ro, "Ro");
            e.emitNewLineBeforeLeadingComments = Ro;
            function s_(n, _, D, H) {
              H && H.length && D !== H[0].pos && pa(n, D) !== pa(n, H[0].pos) && _.writeLine();
            }
            __name(s_, "s_");
            e.emitNewLineBeforeLeadingCommentsOfPosition = s_;
            function nu(n, _, D, H) {
              D !== H && pa(n, D) !== pa(n, H) && _.writeLine();
            }
            __name(nu, "nu");
            e.emitNewLineBeforeLeadingCommentOfPosition = nu;
            function __(n, _, D, H, Oe, mr, Tr, Qr) {
              if (H && H.length > 0) {
                Oe && D.writeSpace(" ");
                for (var bt = false, lt = 0, Yt = H; lt < Yt.length; lt++) {
                  var gn = Yt[lt];
                  bt && (D.writeSpace(" "), bt = false), Qr(n, _, D, gn.pos, gn.end, Tr), gn.hasTrailingNewLine ? D.writeLine() : bt = true;
                }
                bt && mr && D.writeSpace(" ");
              }
            }
            __name(__, "__");
            e.emitComments = __;
            function iu(n, _, D, H, Oe, mr, Tr) {
              var Qr, bt;
              if (Tr ? Oe.pos === 0 && (Qr = e.filter(e.getLeadingCommentRanges(n, Oe.pos), ba)) : Qr = e.getLeadingCommentRanges(n, Oe.pos), Qr) {
                for (var lt = [], Yt = void 0, gn = 0, ci = Qr; gn < ci.length; gn++) {
                  var ai = ci[gn];
                  if (Yt) {
                    var zn = pa(_, Yt.end), Zi = pa(_, ai.pos);
                    if (Zi >= zn + 2)
                      break;
                  }
                  lt.push(ai), Yt = ai;
                }
                if (lt.length) {
                  var zn = pa(_, e.last(lt).end), Nn = pa(_, e.skipTrivia(n, Oe.pos));
                  Nn >= zn + 2 && (Ro(_, D, Oe, Qr), __(n, _, D, lt, false, true, mr, H), bt = { nodePos: Oe.pos, detachedCommentEndPos: e.last(lt).end });
                }
              }
              return bt;
              function ba(ws) {
                return he(n, ws.pos);
              }
              __name(ba, "ba");
            }
            __name(iu, "iu");
            e.emitDetachedComments = iu;
            function ac(n, _, D, H, Oe, mr) {
              if (n.charCodeAt(H + 1) === 42)
                for (var Tr = e.computeLineAndCharacterOfPosition(_, H), Qr = _.length, bt = void 0, lt = H, Yt = Tr.line; lt < Oe; Yt++) {
                  var gn = Yt + 1 === Qr ? n.length + 1 : _[Yt + 1];
                  if (lt !== H) {
                    bt === void 0 && (bt = c_(n, _[Tr.line], H));
                    var ci = D.getIndent() * na(), ai = ci - bt + c_(n, lt, gn);
                    if (ai > 0) {
                      var zn = ai % na(), Zi = Yo((ai - zn) / na());
                      for (D.rawWrite(Zi); zn; )
                        D.rawWrite(" "), zn--;
                    } else
                      D.rawWrite("");
                  }
                  oc(n, Oe, D, mr, lt, gn), lt = gn;
                }
              else
                D.writeComment(n.substring(H, Oe));
            }
            __name(ac, "ac");
            e.writeCommentRange = ac;
            function oc(n, _, D, H, Oe, mr) {
              var Tr = Math.min(_, mr - 1), Qr = e.trimString(n.substring(Oe, Tr));
              Qr ? (D.writeComment(Qr), Tr !== _ && D.writeLine()) : D.rawWrite(H);
            }
            __name(oc, "oc");
            function c_(n, _, D) {
              for (var H = 0; _ < D && e.isWhiteSpaceSingleLine(n.charCodeAt(_)); _++)
                n.charCodeAt(_) === 9 ? H += na() - H % na() : H++;
              return H;
            }
            __name(c_, "c_");
            function au(n) {
              return f_(n) !== 0;
            }
            __name(au, "au");
            e.hasEffectiveModifiers = au;
            function ou(n) {
              return _s(n) !== 0;
            }
            __name(ou, "ou");
            e.hasSyntacticModifiers = ou;
            function is(n, _) {
              return !!l_(n, _);
            }
            __name(is, "is");
            e.hasEffectiveModifier = is;
            function aa(n, _) {
              return !!p_(n, _);
            }
            __name(aa, "aa");
            e.hasSyntacticModifier = aa;
            function as(n) {
              return e.isClassElement(n) && u_(n) || e.isClassStaticBlockDeclaration(n);
            }
            __name(as, "as");
            e.isStatic = as;
            function u_(n) {
              return aa(n, 32);
            }
            __name(u_, "u_");
            e.hasStaticModifier = u_;
            function sc(n) {
              return is(n, 16384);
            }
            __name(sc, "sc");
            e.hasOverrideModifier = sc;
            function su(n) {
              return aa(n, 256);
            }
            __name(su, "su");
            e.hasAbstractModifier = su;
            function _c(n) {
              return aa(n, 2);
            }
            __name(_c, "_c");
            e.hasAmbientModifier = _c;
            function _u(n) {
              return aa(n, 128);
            }
            __name(_u, "_u");
            e.hasAccessorModifier = _u;
            function os(n) {
              return is(n, 64);
            }
            __name(os, "os");
            e.hasEffectiveReadonlyModifier = os;
            function ss(n) {
              return aa(n, 131072);
            }
            __name(ss, "ss");
            e.hasDecorators = ss;
            function l_(n, _) {
              return f_(n) & _;
            }
            __name(l_, "l_");
            e.getSelectedEffectiveModifierFlags = l_;
            function p_(n, _) {
              return _s(n) & _;
            }
            __name(p_, "p_");
            e.getSelectedSyntacticModifierFlags = p_;
            function jo(n, _, D) {
              return n.kind >= 0 && n.kind <= 162 ? 0 : (n.modifierFlagsCache & 536870912 || (n.modifierFlagsCache = ki(n) | 536870912), _ && !(n.modifierFlagsCache & 4096) && (D || hr(n)) && n.parent && (n.modifierFlagsCache |= d_(n) | 4096), n.modifierFlagsCache & -536875009);
            }
            __name(jo, "jo");
            function f_(n) {
              return jo(n, true);
            }
            __name(f_, "f_");
            e.getEffectiveModifierFlags = f_;
            function Jo(n) {
              return jo(n, true, true);
            }
            __name(Jo, "Jo");
            e.getEffectiveModifierFlagsAlwaysIncludeJSDoc = Jo;
            function _s(n) {
              return jo(n, false);
            }
            __name(_s, "_s");
            e.getSyntacticModifierFlags = _s;
            function d_(n) {
              var _ = 0;
              return !!n.parent && !e.isParameter(n) && (hr(n) && (e.getJSDocPublicTagNoCache(n) && (_ |= 4), e.getJSDocPrivateTagNoCache(n) && (_ |= 8), e.getJSDocProtectedTagNoCache(n) && (_ |= 16), e.getJSDocReadonlyTagNoCache(n) && (_ |= 64), e.getJSDocOverrideTagNoCache(n) && (_ |= 16384)), e.getJSDocDeprecatedTagNoCache(n) && (_ |= 8192)), _;
            }
            __name(d_, "d_");
            function cu(n) {
              return ki(n) | d_(n);
            }
            __name(cu, "cu");
            e.getEffectiveModifierFlagsNoCache = cu;
            function ki(n) {
              var _ = e.canHaveModifiers(n) ? m_(n.modifiers) : 0;
              return (n.flags & 4 || n.kind === 79 && n.isInJSDocNamespace) && (_ |= 1), _;
            }
            __name(ki, "ki");
            e.getSyntacticModifierFlagsNoCache = ki;
            function m_(n) {
              var _ = 0;
              if (n)
                for (var D = 0, H = n; D < H.length; D++) {
                  var Oe = H[D];
                  _ |= uo(Oe.kind);
                }
              return _;
            }
            __name(m_, "m_");
            e.modifiersToFlags = m_;
            function uo(n) {
              switch (n) {
                case 124:
                  return 32;
                case 123:
                  return 4;
                case 122:
                  return 16;
                case 121:
                  return 8;
                case 126:
                  return 256;
                case 127:
                  return 128;
                case 93:
                  return 1;
                case 136:
                  return 2;
                case 85:
                  return 2048;
                case 88:
                  return 1024;
                case 132:
                  return 512;
                case 146:
                  return 64;
                case 161:
                  return 16384;
                case 101:
                  return 32768;
                case 145:
                  return 65536;
                case 167:
                  return 131072;
              }
              return 0;
            }
            __name(uo, "uo");
            e.modifierToFlag = uo;
            function uu(n) {
              return n === 56 || n === 55 || n === 53;
            }
            __name(uu, "uu");
            e.isLogicalOperator = uu;
            function cs(n) {
              return n === 75 || n === 76 || n === 77;
            }
            __name(cs, "cs");
            e.isLogicalOrCoalescingAssignmentOperator = cs;
            function lu(n) {
              return cs(n.operatorToken.kind);
            }
            __name(lu, "lu");
            e.isLogicalOrCoalescingAssignmentExpression = lu;
            function Ia(n) {
              return n >= 63 && n <= 78;
            }
            __name(Ia, "Ia");
            e.isAssignmentOperator = Ia;
            function cc(n) {
              var _ = g_(n);
              return _ && !_.isImplements ? _.class : void 0;
            }
            __name(cc, "cc");
            e.tryGetClassExtendingExpressionWithTypeArguments = cc;
            function g_(n) {
              return e.isExpressionWithTypeArguments(n) && e.isHeritageClause(n.parent) && e.isClassLike(n.parent.parent) ? { class: n.parent.parent, isImplements: n.parent.token === 117 } : void 0;
            }
            __name(g_, "g_");
            e.tryGetClassImplementingOrExtendingExpressionWithTypeArguments = g_;
            function us(n, _) {
              return e.isBinaryExpression(n) && (_ ? n.operatorToken.kind === 63 : Ia(n.operatorToken.kind)) && e.isLeftHandSideExpression(n.left);
            }
            __name(us, "us");
            e.isAssignmentExpression = us;
            function uc(n) {
              return us(n.parent) && n.parent.left === n;
            }
            __name(uc, "uc");
            e.isLeftHandSideOfAssignment = uc;
            function y_(n) {
              if (us(n, true)) {
                var _ = n.left.kind;
                return _ === 207 || _ === 206;
              }
              return false;
            }
            __name(y_, "y_");
            e.isDestructuringAssignment = y_;
            function Oa(n) {
              return cc(n) !== void 0;
            }
            __name(Oa, "Oa");
            e.isExpressionWithTypeArgumentsInClassExtendsClause = Oa;
            function Ma(n) {
              return n.kind === 79 || h_(n);
            }
            __name(Ma, "Ma");
            e.isEntityNameExpression = Ma;
            function ls(n) {
              switch (n.kind) {
                case 79:
                  return n;
                case 163:
                  do
                    n = n.left;
                  while (n.kind !== 79);
                  return n;
                case 208:
                  do
                    n = n.expression;
                  while (n.kind !== 79);
                  return n;
              }
            }
            __name(ls, "ls");
            e.getFirstIdentifier = ls;
            function ps(n) {
              return n.kind === 79 || n.kind === 108 || n.kind === 106 || n.kind === 233 || n.kind === 208 && ps(n.expression) || n.kind === 214 && ps(n.expression);
            }
            __name(ps, "ps");
            e.isDottedName = ps;
            function h_(n) {
              return e.isPropertyAccessExpression(n) && e.isIdentifier(n.name) && Ma(n.expression);
            }
            __name(h_, "h_");
            e.isPropertyAccessEntityNameExpression = h_;
            function Fo(n) {
              if (e.isPropertyAccessExpression(n)) {
                var _ = Fo(n.expression);
                if (_ !== void 0)
                  return _ + "." + ue(n.name);
              } else if (e.isElementAccessExpression(n)) {
                var _ = Fo(n.expression);
                if (_ !== void 0 && e.isPropertyName(n.argumentExpression))
                  return _ + "." + ao(n.argumentExpression);
              } else if (e.isIdentifier(n))
                return e.unescapeLeadingUnderscores(n.escapedText);
            }
            __name(Fo, "Fo");
            e.tryGetPropertyAccessOrIdentifierToString = Fo;
            function Va(n) {
              return tn(n) && Qt(n) === "prototype";
            }
            __name(Va, "Va");
            e.isPrototypeAccess = Va;
            function pu(n) {
              return n.parent.kind === 163 && n.parent.right === n || n.parent.kind === 208 && n.parent.name === n;
            }
            __name(pu, "pu");
            e.isRightSideOfQualifiedNameOrPropertyAccess = pu;
            function v_(n) {
              return e.isPropertyAccessExpression(n.parent) && n.parent.name === n || e.isElementAccessExpression(n.parent) && n.parent.argumentExpression === n;
            }
            __name(v_, "v_");
            e.isRightSideOfAccessExpression = v_;
            function lc(n) {
              return e.isQualifiedName(n.parent) && n.parent.right === n || e.isPropertyAccessExpression(n.parent) && n.parent.name === n || e.isJSDocMemberName(n.parent) && n.parent.right === n;
            }
            __name(lc, "lc");
            e.isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName = lc;
            function fs(n) {
              return n.kind === 207 && n.properties.length === 0;
            }
            __name(fs, "fs");
            e.isEmptyObjectLiteral = fs;
            function pc(n) {
              return n.kind === 206 && n.elements.length === 0;
            }
            __name(pc, "pc");
            e.isEmptyArrayLiteral = pc;
            function lo(n) {
              if (!(!fc(n) || !n.declarations))
                for (var _ = 0, D = n.declarations; _ < D.length; _++) {
                  var H = D[_];
                  if (H.localSymbol)
                    return H.localSymbol;
                }
            }
            __name(lo, "lo");
            e.getLocalSymbolForExportDefault = lo;
            function fc(n) {
              return n && e.length(n.declarations) > 0 && aa(n.declarations[0], 1024);
            }
            __name(fc, "fc");
            function fu(n) {
              return e.find(Ay, function(_) {
                return e.fileExtensionIs(n, _);
              });
            }
            __name(fu, "fu");
            e.tryExtractTSExtension = fu;
            function du(n) {
              for (var _ = [], D = n.length, H = 0; H < D; H++) {
                var Oe = n.charCodeAt(H);
                Oe < 128 ? _.push(Oe) : Oe < 2048 ? (_.push(Oe >> 6 | 192), _.push(Oe & 63 | 128)) : Oe < 65536 ? (_.push(Oe >> 12 | 224), _.push(Oe >> 6 & 63 | 128), _.push(Oe & 63 | 128)) : Oe < 131072 ? (_.push(Oe >> 18 | 240), _.push(Oe >> 12 & 63 | 128), _.push(Oe >> 6 & 63 | 128), _.push(Oe & 63 | 128)) : e.Debug.assert(false, "Unexpected code point");
              }
              return _;
            }
            __name(du, "du");
            var ya = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            function dc(n) {
              for (var _ = "", D = du(n), H = 0, Oe = D.length, mr, Tr, Qr, bt; H < Oe; )
                mr = D[H] >> 2, Tr = (D[H] & 3) << 4 | D[H + 1] >> 4, Qr = (D[H + 1] & 15) << 2 | D[H + 2] >> 6, bt = D[H + 2] & 63, H + 1 >= Oe ? Qr = bt = 64 : H + 2 >= Oe && (bt = 64), _ += ya.charAt(mr) + ya.charAt(Tr) + ya.charAt(Qr) + ya.charAt(bt), H += 3;
              return _;
            }
            __name(dc, "dc");
            e.convertToBase64 = dc;
            function po(n) {
              for (var _ = "", D = 0, H = n.length; D < H; ) {
                var Oe = n[D];
                if (Oe < 128)
                  _ += String.fromCharCode(Oe), D++;
                else if ((Oe & 192) === 192) {
                  var mr = Oe & 63;
                  D++;
                  for (var Tr = n[D]; (Tr & 192) === 128; )
                    mr = mr << 6 | Tr & 63, D++, Tr = n[D];
                  _ += String.fromCharCode(mr);
                } else
                  _ += String.fromCharCode(Oe), D++;
              }
              return _;
            }
            __name(po, "po");
            function mu(n, _) {
              return n && n.base64encode ? n.base64encode(_) : dc(_);
            }
            __name(mu, "mu");
            e.base64encode = mu;
            function Wa(n, _) {
              if (n && n.base64decode)
                return n.base64decode(_);
              for (var D = _.length, H = [], Oe = 0; Oe < D && _.charCodeAt(Oe) !== ya.charCodeAt(64); ) {
                var mr = ya.indexOf(_[Oe]), Tr = ya.indexOf(_[Oe + 1]), Qr = ya.indexOf(_[Oe + 2]), bt = ya.indexOf(_[Oe + 3]), lt = (mr & 63) << 2 | Tr >> 4 & 3, Yt = (Tr & 15) << 4 | Qr >> 2 & 15, gn = (Qr & 3) << 6 | bt & 63;
                Yt === 0 && Qr !== 0 ? H.push(lt) : gn === 0 && bt !== 0 ? H.push(lt, Yt) : H.push(lt, Yt, gn), Oe += 4;
              }
              return po(H);
            }
            __name(Wa, "Wa");
            e.base64decode = Wa;
            function xa(n, _) {
              var D = e.isString(_) ? _ : _.readFile(n);
              if (!!D) {
                var H = e.parseConfigFileTextToJson(n, D);
                return H.error ? void 0 : H.config;
              }
            }
            __name(xa, "xa");
            e.readJsonOrUndefined = xa;
            function mc(n, _) {
              return xa(n, _) || {};
            }
            __name(mc, "mc");
            e.readJson = mc;
            function gc(n, _) {
              return !_.directoryExists || _.directoryExists(n);
            }
            __name(gc, "gc");
            e.directoryProbablyExists = gc;
            var yc = `\r
`, hc = `
`;
            function ds(n, _) {
              switch (n.newLine) {
                case 0:
                  return yc;
                case 1:
                  return hc;
              }
              return _ ? _() : e.sys ? e.sys.newLine : yc;
            }
            __name(ds, "ds");
            e.getNewLineCharacter = ds;
            function ms(n, _) {
              return _ === void 0 && (_ = n), e.Debug.assert(_ >= n || _ === -1), { pos: n, end: _ };
            }
            __name(ms, "ms");
            e.createRange = ms;
            function gu(n, _) {
              return ms(n.pos, _);
            }
            __name(gu, "gu");
            e.moveRangeEnd = gu;
            function gs(n, _) {
              return ms(_, n.end);
            }
            __name(gs, "gs");
            e.moveRangePos = gs;
            function vc(n) {
              var _ = e.canHaveModifiers(n) ? e.findLast(n.modifiers, e.isDecorator) : void 0;
              return _ && !Jc(_.end) ? gs(n, _.end) : n;
            }
            __name(vc, "vc");
            e.moveRangePastDecorators = vc;
            function yu(n) {
              var _ = e.canHaveModifiers(n) ? e.lastOrUndefined(n.modifiers) : void 0;
              return _ && !Jc(_.end) ? gs(n, _.end) : vc(n);
            }
            __name(yu, "yu");
            e.moveRangePastModifiers = yu;
            function ys(n) {
              return n.pos === n.end;
            }
            __name(ys, "ys");
            e.isCollapsedRange = ys;
            function bc(n, _) {
              return ms(n, n + e.tokenToString(_).length);
            }
            __name(bc, "bc");
            e.createTokenRange = bc;
            function hu(n, _) {
              return Sc(n, n, _);
            }
            __name(hu, "hu");
            e.rangeIsOnSingleLine = hu;
            function Ec(n, _, D) {
              return Ka(fo(n, D, false), fo(_, D, false), D);
            }
            __name(Ec, "Ec");
            e.rangeStartPositionsAreOnSameLine = Ec;
            function Tc(n, _, D) {
              return Ka(n.end, _.end, D);
            }
            __name(Tc, "Tc");
            e.rangeEndPositionsAreOnSameLine = Tc;
            function Sc(n, _, D) {
              return Ka(fo(n, D, false), _.end, D);
            }
            __name(Sc, "Sc");
            e.rangeStartIsOnSameLineAsRangeEnd = Sc;
            function b_(n, _, D) {
              return Ka(n.end, fo(_, D, false), D);
            }
            __name(b_, "b_");
            e.rangeEndIsOnSameLineAsRangeStart = b_;
            function Cc(n, _, D, H) {
              var Oe = fo(_, D, H);
              return e.getLinesBetweenPositions(D, n.end, Oe);
            }
            __name(Cc, "Cc");
            e.getLinesBetweenRangeEndAndRangeStart = Cc;
            function Dc(n, _, D) {
              return e.getLinesBetweenPositions(D, n.end, _.end);
            }
            __name(Dc, "Dc");
            e.getLinesBetweenRangeEndPositions = Dc;
            function xc(n, _) {
              return !Ka(n.pos, n.end, _);
            }
            __name(xc, "xc");
            e.isNodeArrayMultiLine = xc;
            function Ka(n, _, D) {
              return e.getLinesBetweenPositions(D, n, _) === 0;
            }
            __name(Ka, "Ka");
            e.positionsAreOnSameLine = Ka;
            function fo(n, _, D) {
              return Jc(n.pos) ? -1 : e.skipTrivia(_.text, n.pos, false, D);
            }
            __name(fo, "fo");
            e.getStartPositionOfRange = fo;
            function hs(n, _, D, H) {
              var Oe = e.skipTrivia(D.text, n, false, H), mr = vu(Oe, _, D);
              return e.getLinesBetweenPositions(D, mr != null ? mr : _, Oe);
            }
            __name(hs, "hs");
            e.getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter = hs;
            function wc(n, _, D, H) {
              var Oe = e.skipTrivia(D.text, n, false, H);
              return e.getLinesBetweenPositions(D, n, Math.min(_, Oe));
            }
            __name(wc, "wc");
            e.getLinesBetweenPositionAndNextNonWhitespaceCharacter = wc;
            function vu(n, _, D) {
              for (_ === void 0 && (_ = 0); n-- > _; )
                if (!e.isWhiteSpaceLike(D.text.charCodeAt(n)))
                  return n;
            }
            __name(vu, "vu");
            function vs(n) {
              var _ = e.getParseTreeNode(n);
              if (_)
                switch (_.parent.kind) {
                  case 263:
                  case 264:
                    return _ === _.parent.name;
                }
              return false;
            }
            __name(vs, "vs");
            e.isDeclarationNameOfEnumOrNamespace = vs;
            function bu(n) {
              return e.filter(n.declarations, Eu);
            }
            __name(bu, "bu");
            e.getInitializedVariables = bu;
            function Eu(n) {
              return n.initializer !== void 0;
            }
            __name(Eu, "Eu");
            function E_(n) {
              return n.watch && e.hasProperty(n, "watch");
            }
            __name(E_, "E_");
            e.isWatchSet = E_;
            function Ha(n) {
              n.close();
            }
            __name(Ha, "Ha");
            e.closeFileWatcher = Ha;
            function Ac(n) {
              return n.flags & 33554432 ? n.checkFlags : 0;
            }
            __name(Ac, "Ac");
            e.getCheckFlags = Ac;
            function Tu(n, _) {
              if (_ === void 0 && (_ = false), n.valueDeclaration) {
                var D = _ && n.declarations && e.find(n.declarations, e.isSetAccessorDeclaration) || n.flags & 32768 && e.find(n.declarations, e.isGetAccessorDeclaration) || n.valueDeclaration, H = e.getCombinedModifierFlags(D);
                return n.parent && n.parent.flags & 32 ? H : H & -29;
              }
              if (Ac(n) & 6) {
                var Oe = n.checkFlags, mr = Oe & 1024 ? 8 : Oe & 256 ? 4 : 16, Tr = Oe & 2048 ? 32 : 0;
                return mr | Tr;
              }
              return n.flags & 4194304 ? 36 : 0;
            }
            __name(Tu, "Tu");
            e.getDeclarationModifierFlagsFromSymbol = Tu;
            function Su(n, _) {
              return n.flags & 2097152 ? _.getAliasedSymbol(n) : n;
            }
            __name(Su, "Su");
            e.skipAlias = Su;
            function bs(n) {
              return n.exportSymbol ? n.exportSymbol.flags | n.flags : n.flags;
            }
            __name(bs, "bs");
            e.getCombinedLocalAndExportSymbolFlags = bs;
            function Cu(n) {
              return La(n) === 1;
            }
            __name(Cu, "Cu");
            e.isWriteOnlyAccess = Cu;
            function Es(n) {
              return La(n) !== 0;
            }
            __name(Es, "Es");
            e.isWriteAccess = Es;
            var kc;
            (function(n) {
              n[n.Read = 0] = "Read", n[n.Write = 1] = "Write", n[n.ReadWrite = 2] = "ReadWrite";
            })(kc || (kc = {}));
            function La(n) {
              var _ = n.parent;
              if (!_)
                return 0;
              switch (_.kind) {
                case 214:
                  return La(_);
                case 222:
                case 221:
                  var D = _.operator;
                  return D === 45 || D === 46 ? Qr() : 0;
                case 223:
                  var H = _, Oe = H.left, mr = H.operatorToken;
                  return Oe === n && Ia(mr.kind) ? mr.kind === 63 ? 1 : Qr() : 0;
                case 208:
                  return _.name !== n ? 0 : La(_);
                case 299: {
                  var Tr = La(_.parent);
                  return n === _.name ? Du(Tr) : Tr;
                }
                case 300:
                  return n === _.objectAssignmentInitializer ? 0 : La(_.parent);
                case 206:
                  return La(_);
                default:
                  return 0;
              }
              function Qr() {
                return _.parent && ke(_.parent).kind === 241 ? 1 : 2;
              }
              __name(Qr, "Qr");
            }
            __name(La, "La");
            function Du(n) {
              switch (n) {
                case 0:
                  return 1;
                case 1:
                  return 0;
                case 2:
                  return 2;
                default:
                  return e.Debug.assertNever(n);
              }
            }
            __name(Du, "Du");
            function Ga(n, _) {
              if (!n || !_ || Object.keys(n).length !== Object.keys(_).length)
                return false;
              for (var D in n)
                if (typeof n[D] == "object") {
                  if (!Ga(n[D], _[D]))
                    return false;
                } else if (typeof n[D] != "function" && n[D] !== _[D])
                  return false;
              return true;
            }
            __name(Ga, "Ga");
            e.compareDataObjects = Ga;
            function Pc(n, _) {
              n.forEach(_), n.clear();
            }
            __name(Pc, "Pc");
            e.clearMap = Pc;
            function Nc(n, _, D) {
              var H = D.onDeleteValue, Oe = D.onExistingValue;
              n.forEach(function(mr, Tr) {
                var Qr = _.get(Tr);
                Qr === void 0 ? (n.delete(Tr), H(mr, Tr)) : Oe && Oe(mr, Qr, Tr);
              });
            }
            __name(Nc, "Nc");
            e.mutateMapSkippingNewValues = Nc;
            function xu(n, _, D) {
              Nc(n, _, D);
              var H = D.createNewValue;
              _.forEach(function(Oe, mr) {
                n.has(mr) || n.set(mr, H(mr, Oe));
              });
            }
            __name(xu, "xu");
            e.mutateMap = xu;
            function Ic(n) {
              if (n.flags & 32) {
                var _ = Ts(n);
                return !!_ && aa(_, 256);
              }
              return false;
            }
            __name(Ic, "Ic");
            e.isAbstractConstructorSymbol = Ic;
            function Ts(n) {
              var _;
              return (_ = n.declarations) === null || _ === void 0 ? void 0 : _.find(e.isClassLike);
            }
            __name(Ts, "Ts");
            e.getClassLikeDeclarationOfSymbol = Ts;
            function T_(n) {
              return n.flags & 3899393 ? n.objectFlags : 0;
            }
            __name(T_, "T_");
            e.getObjectFlags = T_;
            function Oc(n, _) {
              return _.getSignaturesOfType(n, 0).length !== 0 || _.getSignaturesOfType(n, 1).length !== 0;
            }
            __name(Oc, "Oc");
            e.typeHasCallOrConstructSignatures = Oc;
            function d(n, _) {
              return !!e.forEachAncestorDirectory(n, function(D) {
                return _(D) ? true : void 0;
              });
            }
            __name(d, "d");
            e.forSomeAncestorDirectory = d;
            function P(n) {
              return !!n && !!n.declarations && !!n.declarations[0] && e.isNamespaceExportDeclaration(n.declarations[0]);
            }
            __name(P, "P");
            e.isUMDExportSymbol = P;
            function $(n) {
              var _ = n.moduleSpecifier;
              return e.isStringLiteral(_) ? _.text : ir(_);
            }
            __name($, "$");
            e.showModuleSpecifier = $;
            function ce(n) {
              var _;
              return e.forEachChild(n, function(D) {
                er(D) && (_ = D);
              }, function(D) {
                for (var H = D.length - 1; H >= 0; H--)
                  if (er(D[H])) {
                    _ = D[H];
                    break;
                  }
              }), _;
            }
            __name(ce, "ce");
            e.getLastChild = ce;
            function Pe(n, _, D) {
              return D === void 0 && (D = true), n.has(_) ? false : (n.set(_, D), true);
            }
            __name(Pe, "Pe");
            e.addToSeen = Pe;
            function We(n) {
              return e.isClassLike(n) || e.isInterfaceDeclaration(n) || e.isTypeLiteralNode(n);
            }
            __name(We, "We");
            e.isObjectTypeDeclaration = We;
            function Er(n) {
              return n >= 179 && n <= 202 || n === 131 || n === 157 || n === 148 || n === 160 || n === 149 || n === 134 || n === 152 || n === 153 || n === 114 || n === 155 || n === 144 || n === 230 || n === 315 || n === 316 || n === 317 || n === 318 || n === 319 || n === 320 || n === 321;
            }
            __name(Er, "Er");
            e.isTypeNodeKind = Er;
            function Rr(n) {
              return n.kind === 208 || n.kind === 209;
            }
            __name(Rr, "Rr");
            e.isAccessExpression = Rr;
            function Fr(n) {
              return n.kind === 208 ? n.name : (e.Debug.assert(n.kind === 209), n.argumentExpression);
            }
            __name(Fr, "Fr");
            e.getNameOfAccessExpression = Fr;
            function et(n) {
              switch (n.kind) {
                case "text":
                case "internal":
                  return true;
                default:
                  return false;
              }
            }
            __name(et, "et");
            e.isBundleFileTextLike = et;
            function xt(n) {
              return n.kind === 272 || n.kind === 276;
            }
            __name(xt, "xt");
            e.isNamedImportsOrExports = xt;
            function Gt(n) {
              for (; Rr(n); )
                n = n.expression;
              return n;
            }
            __name(Gt, "Gt");
            e.getLeftmostAccessExpression = Gt;
            function Wt(n, _) {
              if (Rr(n.parent) && v_(n))
                return D(n.parent);
              function D(H) {
                if (H.kind === 208) {
                  var Oe = _(H.name);
                  if (Oe !== void 0)
                    return Oe;
                } else if (H.kind === 209)
                  if (e.isIdentifier(H.argumentExpression) || e.isStringLiteralLike(H.argumentExpression)) {
                    var Oe = _(H.argumentExpression);
                    if (Oe !== void 0)
                      return Oe;
                  } else
                    return;
                if (Rr(H.expression))
                  return D(H.expression);
                if (e.isIdentifier(H.expression))
                  return _(H.expression);
              }
              __name(D, "D");
            }
            __name(Wt, "Wt");
            e.forEachNameInAccessChainWalkingLeft = Wt;
            function pn(n, _) {
              for (; ; ) {
                switch (n.kind) {
                  case 222:
                    n = n.operand;
                    continue;
                  case 223:
                    n = n.left;
                    continue;
                  case 224:
                    n = n.condition;
                    continue;
                  case 212:
                    n = n.tag;
                    continue;
                  case 210:
                    if (_)
                      return n;
                  case 231:
                  case 209:
                  case 208:
                  case 232:
                  case 353:
                  case 235:
                    n = n.expression;
                    continue;
                }
                return n;
              }
            }
            __name(pn, "pn");
            e.getLeftmostExpression = pn;
            function Pn(n, _) {
              this.flags = n, this.escapedName = _, this.declarations = void 0, this.valueDeclaration = void 0, this.id = void 0, this.mergeId = void 0, this.parent = void 0;
            }
            __name(Pn, "Pn");
            function _i(n, _) {
              this.flags = _, (e.Debug.isDebugging || e.tracing) && (this.checker = n);
            }
            __name(_i, "_i");
            function Ln(n, _) {
              this.flags = _, e.Debug.isDebugging && (this.checker = n);
            }
            __name(Ln, "Ln");
            function ha(n, _, D) {
              this.pos = _, this.end = D, this.kind = n, this.id = 0, this.flags = 0, this.modifierFlagsCache = 0, this.transformFlags = 0, this.parent = void 0, this.original = void 0;
            }
            __name(ha, "ha");
            function Di(n, _, D) {
              this.pos = _, this.end = D, this.kind = n, this.id = 0, this.flags = 0, this.transformFlags = 0, this.parent = void 0;
            }
            __name(Di, "Di");
            function Xn(n, _, D) {
              this.pos = _, this.end = D, this.kind = n, this.id = 0, this.flags = 0, this.transformFlags = 0, this.parent = void 0, this.original = void 0, this.flowNode = void 0;
            }
            __name(Xn, "Xn");
            function Pi(n, _, D) {
              this.fileName = n, this.text = _, this.skipTrivia = D || function(H) {
                return H;
              };
            }
            __name(Pi, "Pi");
            e.objectAllocator = { getNodeConstructor: function() {
              return ha;
            }, getTokenConstructor: function() {
              return Di;
            }, getIdentifierConstructor: function() {
              return Xn;
            }, getPrivateIdentifierConstructor: function() {
              return ha;
            }, getSourceFileConstructor: function() {
              return ha;
            }, getSymbolConstructor: function() {
              return Pn;
            }, getTypeConstructor: function() {
              return _i;
            }, getSignatureConstructor: function() {
              return Ln;
            }, getSourceMapSourceConstructor: function() {
              return Pi;
            } };
            function oa(n) {
              Object.assign(e.objectAllocator, n);
            }
            __name(oa, "oa");
            e.setObjectAllocator = oa;
            function Xa(n, _, D) {
              return D === void 0 && (D = 0), n.replace(/{(\d+)}/g, function(H, Oe) {
                return "" + e.Debug.checkDefined(_[+Oe + D]);
              });
            }
            __name(Xa, "Xa");
            e.formatStringFromArgs = Xa;
            var ii;
            function i(n) {
              ii = n;
            }
            __name(i, "i");
            e.setLocalizedDiagnosticMessages = i;
            function o(n) {
              !ii && n && (ii = n());
            }
            __name(o, "o");
            e.maybeSetLocalizedDiagnosticMessages = o;
            function u(n) {
              return ii && ii[n.key] || n.message;
            }
            __name(u, "u");
            e.getLocaleSpecificMessage = u;
            function b(n, _, D, H) {
              Ct(void 0, _, D);
              var Oe = u(H);
              return arguments.length > 4 && (Oe = Xa(Oe, arguments, 4)), { file: void 0, start: _, length: D, messageText: Oe, category: H.category, code: H.code, reportsUnnecessary: H.reportsUnnecessary, fileName: n };
            }
            __name(b, "b");
            e.createDetachedDiagnostic = b;
            function Y(n) {
              return n.file === void 0 && n.start !== void 0 && n.length !== void 0 && typeof n.fileName == "string";
            }
            __name(Y, "Y");
            function Ke(n, _) {
              var D = _.fileName || "", H = _.text.length;
              e.Debug.assertEqual(n.fileName, D), e.Debug.assertLessThanOrEqual(n.start, H), e.Debug.assertLessThanOrEqual(n.start + n.length, H);
              var Oe = { file: _, start: n.start, length: n.length, messageText: n.messageText, category: n.category, code: n.code, reportsUnnecessary: n.reportsUnnecessary };
              if (n.relatedInformation) {
                Oe.relatedInformation = [];
                for (var mr = 0, Tr = n.relatedInformation; mr < Tr.length; mr++) {
                  var Qr = Tr[mr];
                  Y(Qr) && Qr.fileName === D ? (e.Debug.assertLessThanOrEqual(Qr.start, H), e.Debug.assertLessThanOrEqual(Qr.start + Qr.length, H), Oe.relatedInformation.push(Ke(Qr, _))) : Oe.relatedInformation.push(Qr);
                }
              }
              return Oe;
            }
            __name(Ke, "Ke");
            function Or(n, _) {
              for (var D = [], H = 0, Oe = n; H < Oe.length; H++) {
                var mr = Oe[H];
                D.push(Ke(mr, _));
              }
              return D;
            }
            __name(Or, "Or");
            e.attachFileToDiagnostics = Or;
            function kt(n, _, D, H) {
              Ct(n, _, D);
              var Oe = u(H);
              return arguments.length > 4 && (Oe = Xa(Oe, arguments, 4)), { file: n, start: _, length: D, messageText: Oe, category: H.category, code: H.code, reportsUnnecessary: H.reportsUnnecessary, reportsDeprecated: H.reportsDeprecated };
            }
            __name(kt, "kt");
            e.createFileDiagnostic = kt;
            function $n(n, _) {
              var D = u(_);
              return arguments.length > 2 && (D = Xa(D, arguments, 2)), D;
            }
            __name($n, "$n");
            e.formatMessage = $n;
            function fa(n) {
              var _ = u(n);
              return arguments.length > 1 && (_ = Xa(_, arguments, 1)), { file: void 0, start: void 0, length: void 0, messageText: _, category: n.category, code: n.code, reportsUnnecessary: n.reportsUnnecessary, reportsDeprecated: n.reportsDeprecated };
            }
            __name(fa, "fa");
            e.createCompilerDiagnostic = fa;
            function Bo(n, _) {
              return { file: void 0, start: void 0, length: void 0, code: n.code, category: n.category, messageText: n.next ? n : n.messageText, relatedInformation: _ };
            }
            __name(Bo, "Bo");
            e.createCompilerDiagnosticFromMessageChain = Bo;
            function $a(n, _) {
              var D = u(_);
              return arguments.length > 2 && (D = Xa(D, arguments, 2)), { messageText: D, category: _.category, code: _.code, next: n === void 0 || Array.isArray(n) ? n : [n] };
            }
            __name($a, "$a");
            e.chainDiagnosticMessages = $a;
            function Ss(n, _) {
              for (var D = n; D.next; )
                D = D.next[0];
              D.next = [_];
            }
            __name(Ss, "Ss");
            e.concatenateDiagnosticMessageChains = Ss;
            function Cs(n) {
              return n.file ? n.file.path : void 0;
            }
            __name(Cs, "Cs");
            function Fu(n, _) {
              return Mc(n, _) || Bu(n, _) || 0;
            }
            __name(Fu, "Fu");
            e.compareDiagnostics = Fu;
            function Mc(n, _) {
              return e.compareStringsCaseSensitive(Cs(n), Cs(_)) || e.compareValues(n.start, _.start) || e.compareValues(n.length, _.length) || e.compareValues(n.code, _.code) || qu(n.messageText, _.messageText) || 0;
            }
            __name(Mc, "Mc");
            e.compareDiagnosticsSkipRelatedInformation = Mc;
            function Bu(n, _) {
              return !n.relatedInformation && !_.relatedInformation ? 0 : n.relatedInformation && _.relatedInformation ? e.compareValues(n.relatedInformation.length, _.relatedInformation.length) || e.forEach(n.relatedInformation, function(D, H) {
                var Oe = _.relatedInformation[H];
                return Fu(D, Oe);
              }) || 0 : n.relatedInformation ? -1 : 1;
            }
            __name(Bu, "Bu");
            function qu(n, _) {
              if (typeof n == "string" && typeof _ == "string")
                return e.compareStringsCaseSensitive(n, _);
              if (typeof n == "string")
                return -1;
              if (typeof _ == "string")
                return 1;
              var D = e.compareStringsCaseSensitive(n.messageText, _.messageText);
              if (D)
                return D;
              if (!n.next && !_.next)
                return 0;
              if (!n.next)
                return -1;
              if (!_.next)
                return 1;
              for (var H = Math.min(n.next.length, _.next.length), Oe = 0; Oe < H; Oe++)
                if (D = qu(n.next[Oe], _.next[Oe]), D)
                  return D;
              return n.next.length < _.next.length ? -1 : n.next.length > _.next.length ? 1 : 0;
            }
            __name(qu, "qu");
            function Pl(n) {
              return n === 4 || n === 2 || n === 1 || n === 6 ? 1 : 0;
            }
            __name(Pl, "Pl");
            e.getLanguageVariant = Pl;
            function Uu(n) {
              if (!!(n.transformFlags & 2))
                return e.isJsxOpeningLikeElement(n) || e.isJsxFragment(n) ? n : e.forEachChild(n, Uu);
            }
            __name(Uu, "Uu");
            function Nl(n) {
              return n.isDeclarationFile ? void 0 : Uu(n);
            }
            __name(Nl, "Nl");
            function Il(n) {
              return (n.impliedNodeFormat === e.ModuleKind.ESNext || e.fileExtensionIsOneOf(n.fileName, [".cjs", ".cts", ".mjs", ".mts"])) && !n.isDeclarationFile ? true : void 0;
            }
            __name(Il, "Il");
            function zu(n) {
              switch (Vu(n)) {
                case e.ModuleDetectionKind.Force:
                  return function(Oe) {
                    Oe.externalModuleIndicator = e.isFileProbablyExternalModule(Oe) || !Oe.isDeclarationFile || void 0;
                  };
                case e.ModuleDetectionKind.Legacy:
                  return function(Oe) {
                    Oe.externalModuleIndicator = e.isFileProbablyExternalModule(Oe);
                  };
                case e.ModuleDetectionKind.Auto:
                  var _ = [e.isFileProbablyExternalModule];
                  (n.jsx === 4 || n.jsx === 5) && _.push(Nl), _.push(Il);
                  var D = e.or.apply(void 0, _), H = /* @__PURE__ */ __name(function(Oe) {
                    return void (Oe.externalModuleIndicator = D(Oe));
                  }, "H");
                  return H;
              }
            }
            __name(zu, "zu");
            e.getSetExternalModuleIndicator = zu;
            function wu(n) {
              return n.target || n.module === e.ModuleKind.Node16 && 9 || n.module === e.ModuleKind.NodeNext && 99 || 0;
            }
            __name(wu, "wu");
            e.getEmitScriptTarget = wu;
            function Wi(n) {
              return typeof n.module == "number" ? n.module : wu(n) >= 2 ? e.ModuleKind.ES2015 : e.ModuleKind.CommonJS;
            }
            __name(Wi, "Wi");
            e.getEmitModuleKind = Wi;
            function Ol(n) {
              var _ = n.moduleResolution;
              if (_ === void 0)
                switch (Wi(n)) {
                  case e.ModuleKind.CommonJS:
                    _ = e.ModuleResolutionKind.NodeJs;
                    break;
                  case e.ModuleKind.Node16:
                    _ = e.ModuleResolutionKind.Node16;
                    break;
                  case e.ModuleKind.NodeNext:
                    _ = e.ModuleResolutionKind.NodeNext;
                    break;
                  default:
                    _ = e.ModuleResolutionKind.Classic;
                    break;
                }
              return _;
            }
            __name(Ol, "Ol");
            e.getEmitModuleResolutionKind = Ol;
            function Vu(n) {
              return n.moduleDetection || (Wi(n) === e.ModuleKind.Node16 || Wi(n) === e.ModuleKind.NodeNext ? e.ModuleDetectionKind.Force : e.ModuleDetectionKind.Auto);
            }
            __name(Vu, "Vu");
            e.getEmitModuleDetectionKind = Vu;
            function Ml(n) {
              switch (Wi(n)) {
                case e.ModuleKind.CommonJS:
                case e.ModuleKind.AMD:
                case e.ModuleKind.ES2015:
                case e.ModuleKind.ES2020:
                case e.ModuleKind.ES2022:
                case e.ModuleKind.ESNext:
                case e.ModuleKind.Node16:
                case e.ModuleKind.NodeNext:
                  return true;
                default:
                  return false;
              }
            }
            __name(Ml, "Ml");
            e.hasJsonModuleEmitEnabled = Ml;
            function Au(n) {
              return n.allowUnreachableCode === false;
            }
            __name(Au, "Au");
            e.unreachableCodeIsError = Au;
            function Ll(n) {
              return n.allowUnusedLabels === false;
            }
            __name(Ll, "Ll");
            e.unusedLabelIsError = Ll;
            function Rl(n) {
              return !!(Lc(n) && n.declarationMap);
            }
            __name(Rl, "Rl");
            e.getAreDeclarationMapsEnabled = Rl;
            function Wu(n) {
              if (n.esModuleInterop !== void 0)
                return n.esModuleInterop;
              switch (Wi(n)) {
                case e.ModuleKind.Node16:
                case e.ModuleKind.NodeNext:
                  return true;
              }
            }
            __name(Wu, "Wu");
            e.getESModuleInterop = Wu;
            function jl(n) {
              var _ = Wi(n);
              return n.allowSyntheticDefaultImports !== void 0 ? n.allowSyntheticDefaultImports : Wu(n) || _ === e.ModuleKind.System;
            }
            __name(jl, "jl");
            e.getAllowSyntheticDefaultImports = jl;
            function Lc(n) {
              return !!(n.declaration || n.composite);
            }
            __name(Lc, "Lc");
            e.getEmitDeclarations = Lc;
            function Jl(n) {
              return !!(n.preserveConstEnums || n.isolatedModules);
            }
            __name(Jl, "Jl");
            e.shouldPreserveConstEnums = Jl;
            function Fl(n) {
              return !!(n.incremental || n.composite);
            }
            __name(Fl, "Fl");
            e.isIncrementalCompilation = Fl;
            function ku(n, _) {
              return n[_] === void 0 ? !!n.strict : !!n[_];
            }
            __name(ku, "ku");
            e.getStrictOptionValue = ku;
            function Ku(n) {
              return n.allowJs === void 0 ? !!n.checkJs : n.allowJs;
            }
            __name(Ku, "Ku");
            e.getAllowJSCompilerOption = Ku;
            function qo(n) {
              return n.useDefineForClassFields === void 0 ? wu(n) >= 9 : n.useDefineForClassFields;
            }
            __name(qo, "qo");
            e.getUseDefineForClassFields = qo;
            function Bl(n, _) {
              return se(_, n, e.semanticDiagnosticsOptionDeclarations);
            }
            __name(Bl, "Bl");
            e.compilerOptionsAffectSemanticDiagnostics = Bl;
            function mo(n, _) {
              return se(_, n, e.affectsEmitOptionDeclarations);
            }
            __name(mo, "mo");
            e.compilerOptionsAffectEmit = mo;
            function sr(n, _) {
              return se(_, n, e.affectsDeclarationPathOptionDeclarations);
            }
            __name(sr, "sr");
            e.compilerOptionsAffectDeclarationPath = sr;
            function $r(n, _) {
              return _.strictFlag ? ku(n, _.name) : n[_.name];
            }
            __name($r, "$r");
            e.getCompilerOptionValue = $r;
            function Wr(n) {
              var _ = n.jsx;
              return _ === 2 || _ === 4 || _ === 5;
            }
            __name(Wr, "Wr");
            e.getJSXTransformEnabled = Wr;
            function st(n, _) {
              var D = _ == null ? void 0 : _.pragmas.get("jsximportsource"), H = e.isArray(D) ? D[D.length - 1] : D;
              return n.jsx === 4 || n.jsx === 5 || n.jsxImportSource || H ? (H == null ? void 0 : H.arguments.factory) || n.jsxImportSource || "react" : void 0;
            }
            __name(st, "st");
            e.getJSXImplicitImportBase = st;
            function ht(n, _) {
              return n ? "".concat(n, "/").concat(_.jsx === 5 ? "jsx-dev-runtime" : "jsx-runtime") : void 0;
            }
            __name(ht, "ht");
            e.getJSXRuntimeImport = ht;
            function Bt(n) {
              for (var _ = false, D = 0; D < n.length; D++)
                if (n.charCodeAt(D) === 42)
                  if (!_)
                    _ = true;
                  else
                    return false;
              return true;
            }
            __name(Bt, "Bt");
            e.hasZeroOrOneAsteriskCharacter = Bt;
            function Cn(n, _) {
              var D, H, Oe, mr = false;
              return { getSymlinkedFiles: function() {
                return Oe;
              }, getSymlinkedDirectories: function() {
                return D;
              }, getSymlinkedDirectoriesByRealpath: function() {
                return H;
              }, setSymlinkedFile: function(Qr, bt) {
                return (Oe || (Oe = new e.Map())).set(Qr, bt);
              }, setSymlinkedDirectory: function(Qr, bt) {
                var lt = e.toPath(Qr, n, _);
                Cf(lt) || (lt = e.ensureTrailingDirectorySeparator(lt), bt !== false && !(D != null && D.has(lt)) && (H || (H = e.createMultiMap())).add(e.ensureTrailingDirectorySeparator(bt.realPath), Qr), (D || (D = new e.Map())).set(lt, bt));
              }, setSymlinksFromResolutions: function(Qr, bt) {
                var lt = this, Yt;
                e.Debug.assert(!mr), mr = true;
                for (var gn = 0, ci = Qr; gn < ci.length; gn++) {
                  var ai = ci[gn];
                  (Yt = ai.resolvedModules) === null || Yt === void 0 || Yt.forEach(function(zn) {
                    return Tr(lt, zn);
                  });
                }
                bt == null || bt.forEach(function(zn) {
                  return Tr(lt, zn);
                });
              }, hasProcessedResolutions: function() {
                return mr;
              } };
              function Tr(Qr, bt) {
                if (!(!bt || !bt.originalPath || !bt.resolvedFileName)) {
                  var lt = bt.resolvedFileName, Yt = bt.originalPath;
                  Qr.setSymlinkedFile(e.toPath(Yt, n, _), lt);
                  var gn = hi(lt, Yt, n, _) || e.emptyArray, ci = gn[0], ai = gn[1];
                  ci && ai && Qr.setSymlinkedDirectory(ai, { real: ci, realPath: e.toPath(ci, n, _) });
                }
              }
              __name(Tr, "Tr");
            }
            __name(Cn, "Cn");
            e.createSymlinkCache = Cn;
            function hi(n, _, D, H) {
              for (var Oe = e.getPathComponents(e.getNormalizedAbsolutePath(n, D)), mr = e.getPathComponents(e.getNormalizedAbsolutePath(_, D)), Tr = false; Oe.length >= 2 && mr.length >= 2 && !fi(Oe[Oe.length - 2], H) && !fi(mr[mr.length - 2], H) && H(Oe[Oe.length - 1]) === H(mr[mr.length - 1]); )
                Oe.pop(), mr.pop(), Tr = true;
              return Tr ? [e.getPathFromPathComponents(Oe), e.getPathFromPathComponents(mr)] : void 0;
            }
            __name(hi, "hi");
            function fi(n, _) {
              return n !== void 0 && (_(n) === "node_modules" || e.startsWith(n, "@"));
            }
            __name(fi, "fi");
            function Ki(n) {
              return e.isAnyDirectorySeparator(n.charCodeAt(0)) ? n.slice(1) : void 0;
            }
            __name(Ki, "Ki");
            function Mi(n, _, D) {
              var H = e.tryRemovePrefix(n, _, D);
              return H === void 0 ? void 0 : Ki(H);
            }
            __name(Mi, "Mi");
            e.tryRemoveDirectoryPrefix = Mi;
            var va = /[^\w\s\/]/g;
            function Ds(n) {
              return n.replace(va, Rc);
            }
            __name(Ds, "Ds");
            e.regExpEscape = Ds;
            function Rc(n) {
              return "\\" + n;
            }
            __name(Rc, "Rc");
            var jc = [42, 63];
            e.commonPackageFolders = ["node_modules", "bower_components", "jspm_packages"];
            var xs = "(?!(".concat(e.commonPackageFolders.join("|"), ")(/|$))"), Hu = { singleAsteriskRegexFragment: "([^./]|(\\.(?!min\\.js$))?)*", doubleAsteriskRegexFragment: "(/".concat(xs, "[^/.][^/]*)*?"), replaceWildcardCharacter: function(n) {
              return Ul(n, Hu.singleAsteriskRegexFragment);
            } }, sf = { singleAsteriskRegexFragment: "[^/]*", doubleAsteriskRegexFragment: "(/".concat(xs, "[^/.][^/]*)*?"), replaceWildcardCharacter: function(n) {
              return Ul(n, sf.singleAsteriskRegexFragment);
            } }, _f = { singleAsteriskRegexFragment: "[^/]*", doubleAsteriskRegexFragment: "(/.+?)?", replaceWildcardCharacter: function(n) {
              return Ul(n, _f.singleAsteriskRegexFragment);
            } }, cf = { files: Hu, directories: sf, exclude: _f };
            function Gu(n, _, D) {
              var H = ql(n, _, D);
              if (!(!H || !H.length)) {
                var Oe = H.map(function(Tr) {
                  return "(".concat(Tr, ")");
                }).join("|"), mr = D === "exclude" ? "($|/)" : "$";
                return "^(".concat(Oe, ")").concat(mr);
              }
            }
            __name(Gu, "Gu");
            e.getRegularExpressionForWildcard = Gu;
            function ql(n, _, D) {
              if (!(n === void 0 || n.length === 0))
                return e.flatMap(n, function(H) {
                  return H && lf(H, _, D, cf[D]);
                });
            }
            __name(ql, "ql");
            e.getRegularExpressionsForWildcards = ql;
            function uf(n) {
              return !/[.*?]/.test(n);
            }
            __name(uf, "uf");
            e.isImplicitGlob = uf;
            function Ty(n, _, D) {
              var H = n && lf(n, _, D, cf[D]);
              return H && "^(".concat(H, ")").concat(D === "exclude" ? "($|/)" : "$");
            }
            __name(Ty, "Ty");
            e.getPatternFromSpec = Ty;
            function lf(n, _, D, H) {
              var Oe = H.singleAsteriskRegexFragment, mr = H.doubleAsteriskRegexFragment, Tr = H.replaceWildcardCharacter, Qr = "", bt = false, lt = e.getNormalizedPathComponents(n, _), Yt = e.last(lt);
              if (!(D !== "exclude" && Yt === "**")) {
                lt[0] = e.removeTrailingDirectorySeparator(lt[0]), uf(Yt) && lt.push("**", "*");
                for (var gn = 0, ci = 0, ai = lt; ci < ai.length; ci++) {
                  var zn = ai[ci];
                  if (zn === "**")
                    Qr += mr;
                  else if (D === "directories" && (Qr += "(", gn++), bt && (Qr += e.directorySeparator), D !== "exclude") {
                    var Zi = "";
                    zn.charCodeAt(0) === 42 ? (Zi += "([^./]" + Oe + ")?", zn = zn.substr(1)) : zn.charCodeAt(0) === 63 && (Zi += "[^./]", zn = zn.substr(1)), Zi += zn.replace(va, Tr), Zi !== zn && (Qr += xs), Qr += Zi;
                  } else
                    Qr += zn.replace(va, Tr);
                  bt = true;
                }
                for (; gn > 0; )
                  Qr += ")?", gn--;
                return Qr;
              }
            }
            __name(lf, "lf");
            function Ul(n, _) {
              return n === "*" ? _ : n === "?" ? "[^/]" : "\\" + n;
            }
            __name(Ul, "Ul");
            function pf(n, _, D, H, Oe) {
              n = e.normalizePath(n), Oe = e.normalizePath(Oe);
              var mr = e.combinePaths(Oe, n);
              return { includeFilePatterns: e.map(ql(D, mr, "files"), function(Tr) {
                return "^".concat(Tr, "$");
              }), includeFilePattern: Gu(D, mr, "files"), includeDirectoryPattern: Gu(D, mr, "directories"), excludePattern: Gu(_, mr, "exclude"), basePaths: Cy(n, D, H) };
            }
            __name(pf, "pf");
            e.getFileMatcherPatterns = pf;
            function Xu(n, _) {
              return new RegExp(n, _ ? "" : "i");
            }
            __name(Xu, "Xu");
            e.getRegexFromPattern = Xu;
            function Sy(n, _, D, H, Oe, mr, Tr, Qr, bt) {
              n = e.normalizePath(n), mr = e.normalizePath(mr);
              for (var lt = pf(n, D, H, Oe, mr), Yt = lt.includeFilePatterns && lt.includeFilePatterns.map(function(Uo) {
                return Xu(Uo, Oe);
              }), gn = lt.includeDirectoryPattern && Xu(lt.includeDirectoryPattern, Oe), ci = lt.excludePattern && Xu(lt.excludePattern, Oe), ai = Yt ? Yt.map(function() {
                return [];
              }) : [[]], zn = new e.Map(), Zi = e.createGetCanonicalFileName(Oe), Nn = 0, ba = lt.basePaths; Nn < ba.length; Nn++) {
                var ws = ba[Nn];
                Nu(ws, e.combinePaths(mr, ws), Tr);
              }
              return e.flatten(ai);
              function Nu(Uo, Hl, Qu) {
                var Af = Zi(bt(Hl));
                if (!zn.has(Af)) {
                  zn.set(Af, true);
                  for (var kf = Qr(Uo), bh = kf.files, Eh = kf.directories, Th = function(If) {
                    var Ql = e.combinePaths(Uo, If), Of = e.combinePaths(Hl, If);
                    if (_ && !e.fileExtensionIsOneOf(Ql, _) || ci && ci.test(Of))
                      return "continue";
                    if (!Yt)
                      ai[0].push(Ql);
                    else {
                      var Mf = e.findIndex(Yt, function(Ch) {
                        return Ch.test(Of);
                      });
                      Mf !== -1 && ai[Mf].push(Ql);
                    }
                  }, Gl = 0, Pf = e.sort(bh, e.compareStringsCaseSensitive); Gl < Pf.length; Gl++) {
                    var Yu = Pf[Gl];
                    Th(Yu);
                  }
                  if (!(Qu !== void 0 && (Qu--, Qu === 0)))
                    for (var Xl = 0, Nf = e.sort(Eh, e.compareStringsCaseSensitive); Xl < Nf.length; Xl++) {
                      var Yu = Nf[Xl], Sh = e.combinePaths(Uo, Yu), $l = e.combinePaths(Hl, Yu);
                      (!gn || gn.test($l)) && (!ci || !ci.test($l)) && Nu(Sh, $l, Qu);
                    }
                }
              }
              __name(Nu, "Nu");
            }
            __name(Sy, "Sy");
            e.matchFiles = Sy;
            function Cy(n, _, D) {
              var H = [n];
              if (_) {
                for (var Oe = [], mr = 0, Tr = _; mr < Tr.length; mr++) {
                  var Qr = Tr[mr], bt = e.isRootedDiskPath(Qr) ? Qr : e.normalizePath(e.combinePaths(n, Qr));
                  Oe.push(Dy(bt));
                }
                Oe.sort(e.getStringComparer(!D));
                for (var lt = function(ai) {
                  e.every(H, function(zn) {
                    return !e.containsPath(zn, ai, n, !D);
                  }) && H.push(ai);
                }, Yt = 0, gn = Oe; Yt < gn.length; Yt++) {
                  var ci = gn[Yt];
                  lt(ci);
                }
              }
              return H;
            }
            __name(Cy, "Cy");
            function Dy(n) {
              var _ = e.indexOfAnyCharCode(n, jc);
              return _ < 0 ? e.hasExtension(n) ? e.removeTrailingDirectorySeparator(e.getDirectoryPath(n)) : n : n.substring(0, n.lastIndexOf(e.directorySeparator, _));
            }
            __name(Dy, "Dy");
            function xy(n, _) {
              return _ || ff(n) || 3;
            }
            __name(xy, "xy");
            e.ensureScriptKind = xy;
            function ff(n) {
              var _ = n.substr(n.lastIndexOf("."));
              switch (_.toLowerCase()) {
                case ".js":
                case ".cjs":
                case ".mjs":
                  return 1;
                case ".jsx":
                  return 2;
                case ".ts":
                case ".cts":
                case ".mts":
                  return 3;
                case ".tsx":
                  return 4;
                case ".json":
                  return 6;
                default:
                  return 0;
              }
            }
            __name(ff, "ff");
            e.getScriptKindFromFileName = ff, e.supportedTSExtensions = [[".ts", ".tsx", ".d.ts"], [".cts", ".d.cts"], [".mts", ".d.mts"]], e.supportedTSExtensionsFlat = e.flatten(e.supportedTSExtensions);
            var wy = A(A([], e.supportedTSExtensions, true), [[".json"]], false), Ay = [".d.ts", ".d.cts", ".d.mts", ".cts", ".mts", ".ts", ".tsx", ".cts", ".mts"];
            e.supportedJSExtensions = [[".js", ".jsx"], [".mjs"], [".cjs"]], e.supportedJSExtensionsFlat = e.flatten(e.supportedJSExtensions);
            var $u = [[".ts", ".tsx", ".d.ts", ".js", ".jsx"], [".cts", ".d.cts", ".cjs"], [".mts", ".d.mts", ".mjs"]], ky = A(A([], $u, true), [[".json"]], false);
            e.supportedDeclarationExtensions = [".d.ts", ".d.cts", ".d.mts"];
            function df(n, _) {
              var D = n && Ku(n);
              if (!_ || _.length === 0)
                return D ? $u : e.supportedTSExtensions;
              var H = D ? $u : e.supportedTSExtensions, Oe = e.flatten(H), mr = A(A([], H, true), e.mapDefined(_, function(Tr) {
                return Tr.scriptKind === 7 || D && Py(Tr.scriptKind) && Oe.indexOf(Tr.extension) === -1 ? [Tr.extension] : void 0;
              }), true);
              return mr;
            }
            __name(df, "df");
            e.getSupportedExtensions = df;
            function mf(n, _) {
              return !n || !n.resolveJsonModule ? _ : _ === $u ? ky : _ === e.supportedTSExtensions ? wy : A(A([], _, true), [[".json"]], false);
            }
            __name(mf, "mf");
            e.getSupportedExtensionsWithJsonIfResolveJsonModule = mf;
            function Py(n) {
              return n === 1 || n === 2;
            }
            __name(Py, "Py");
            function Ny(n) {
              return e.some(e.supportedJSExtensionsFlat, function(_) {
                return e.fileExtensionIs(n, _);
              });
            }
            __name(Ny, "Ny");
            e.hasJSFileExtension = Ny;
            function Iy(n) {
              return e.some(e.supportedTSExtensionsFlat, function(_) {
                return e.fileExtensionIs(n, _);
              });
            }
            __name(Iy, "Iy");
            e.hasTSFileExtension = Iy;
            function Oy(n, _, D) {
              if (!n)
                return false;
              for (var H = df(_, D), Oe = 0, mr = e.flatten(mf(_, H)); Oe < mr.length; Oe++) {
                var Tr = mr[Oe];
                if (e.fileExtensionIs(n, Tr))
                  return true;
              }
              return false;
            }
            __name(Oy, "Oy");
            e.isSupportedSourceFileName = Oy;
            function gf(n) {
              var _ = n.match(/\//g);
              return _ ? _.length : 0;
            }
            __name(gf, "gf");
            function My(n, _) {
              return e.compareValues(gf(n), gf(_));
            }
            __name(My, "My");
            e.compareNumberOfDirectorySeparators = My;
            var zl = [".d.ts", ".d.mts", ".d.cts", ".mjs", ".mts", ".cjs", ".cts", ".ts", ".js", ".tsx", ".jsx", ".json"];
            function Pu(n) {
              for (var _ = 0, D = zl; _ < D.length; _++) {
                var H = D[_], Oe = yf(n, H);
                if (Oe !== void 0)
                  return Oe;
              }
              return n;
            }
            __name(Pu, "Pu");
            e.removeFileExtension = Pu;
            function yf(n, _) {
              return e.fileExtensionIs(n, _) ? hf(n, _) : void 0;
            }
            __name(yf, "yf");
            e.tryRemoveExtension = yf;
            function hf(n, _) {
              return n.substring(0, n.length - _.length);
            }
            __name(hf, "hf");
            e.removeExtension = hf;
            function Ly(n, _) {
              return e.changeAnyExtension(n, _, zl, false);
            }
            __name(Ly, "Ly");
            e.changeExtension = Ly;
            function vf(n) {
              var _ = n.indexOf("*");
              return _ === -1 ? n : n.indexOf("*", _ + 1) !== -1 ? void 0 : { prefix: n.substr(0, _), suffix: n.substr(_ + 1) };
            }
            __name(vf, "vf");
            e.tryParsePattern = vf;
            function Ry(n) {
              return e.mapDefined(e.getOwnKeys(n), function(_) {
                return vf(_);
              });
            }
            __name(Ry, "Ry");
            e.tryParsePatterns = Ry;
            function Jc(n) {
              return !(n >= 0);
            }
            __name(Jc, "Jc");
            e.positionIsSynthesized = Jc;
            function bf(n) {
              return n === ".ts" || n === ".tsx" || n === ".d.ts" || n === ".cts" || n === ".mts" || n === ".d.mts" || n === ".d.cts";
            }
            __name(bf, "bf");
            e.extensionIsTS = bf;
            function jy(n) {
              return bf(n) || n === ".json";
            }
            __name(jy, "jy");
            e.resolutionExtensionIsTSOrJson = jy;
            function Jy(n) {
              var _ = Vl(n);
              return _ !== void 0 ? _ : e.Debug.fail("File ".concat(n, " has unknown extension."));
            }
            __name(Jy, "Jy");
            e.extensionFromPath = Jy;
            function Fy(n) {
              return Vl(n) !== void 0;
            }
            __name(Fy, "Fy");
            e.isAnySupportedFileExtension = Fy;
            function Vl(n) {
              return e.find(zl, function(_) {
                return e.fileExtensionIs(n, _);
              });
            }
            __name(Vl, "Vl");
            e.tryGetExtensionFromPath = Vl;
            function By(n, _) {
              return n.checkJsDirective ? n.checkJsDirective.enabled : _.checkJs;
            }
            __name(By, "By");
            e.isCheckJsEnabledForFile = By, e.emptyFileSystemEntries = { files: e.emptyArray, directories: e.emptyArray };
            function qy(n, _) {
              for (var D = [], H = 0, Oe = n; H < Oe.length; H++) {
                var mr = Oe[H];
                if (mr === _)
                  return _;
                e.isString(mr) || D.push(mr);
              }
              return e.findBestPatternMatch(D, function(Tr) {
                return Tr;
              }, _);
            }
            __name(qy, "qy");
            e.matchPatternOrExact = qy;
            function Uy(n, _) {
              var D = n.indexOf(_);
              return e.Debug.assert(D !== -1), n.slice(D);
            }
            __name(Uy, "Uy");
            e.sliceAfter = Uy;
            function zy(n) {
              for (var _, D = [], H = 1; H < arguments.length; H++)
                D[H - 1] = arguments[H];
              return D.length && (n.relatedInformation || (n.relatedInformation = []), e.Debug.assert(n.relatedInformation !== e.emptyArray, "Diagnostic had empty array singleton for related info, but is still being constructed!"), (_ = n.relatedInformation).push.apply(_, D)), n;
            }
            __name(zy, "zy");
            e.addRelatedInfo = zy;
            function Vy(n, _) {
              e.Debug.assert(n.length !== 0);
              for (var D = _(n[0]), H = D, Oe = 1; Oe < n.length; Oe++) {
                var mr = _(n[Oe]);
                mr < D ? D = mr : mr > H && (H = mr);
              }
              return { min: D, max: H };
            }
            __name(Vy, "Vy");
            e.minAndMax = Vy;
            function Wy(n) {
              return { pos: kr(n), end: n.end };
            }
            __name(Wy, "Wy");
            e.rangeOfNode = Wy;
            function Ky(n, _) {
              var D = _.pos - 1, H = e.skipTrivia(n.text, _.end) + 1;
              return { pos: D, end: H };
            }
            __name(Ky, "Ky");
            e.rangeOfTypeParameters = Ky;
            function Hy(n, _, D) {
              return _.skipLibCheck && n.isDeclarationFile || _.skipDefaultLibCheck && n.hasNoDefaultLib || D.isSourceOfProjectReferenceRedirect(n.fileName);
            }
            __name(Hy, "Hy");
            e.skipTypeChecking = Hy;
            function Wl(n, _) {
              return n === _ || typeof n == "object" && n !== null && typeof _ == "object" && _ !== null && e.equalOwnProperties(n, _, Wl);
            }
            __name(Wl, "Wl");
            e.isJsonEqual = Wl;
            function Gy(n) {
              var _;
              switch (n.charCodeAt(1)) {
                case 98:
                case 66:
                  _ = 1;
                  break;
                case 111:
                case 79:
                  _ = 3;
                  break;
                case 120:
                case 88:
                  _ = 4;
                  break;
                default:
                  for (var D = n.length - 1, H = 0; n.charCodeAt(H) === 48; )
                    H++;
                  return n.slice(H, D) || "0";
              }
              for (var Oe = 2, mr = n.length - 1, Tr = (mr - Oe) * _, Qr = new Uint16Array((Tr >>> 4) + (Tr & 15 ? 1 : 0)), bt = mr - 1, lt = 0; bt >= Oe; bt--, lt += _) {
                var Yt = lt >>> 4, gn = n.charCodeAt(bt), ci = gn <= 57 ? gn - 48 : 10 + gn - (gn <= 70 ? 65 : 97), ai = ci << (lt & 15);
                Qr[Yt] |= ai;
                var zn = ai >>> 16;
                zn && (Qr[Yt + 1] |= zn);
              }
              for (var Zi = "", Nn = Qr.length - 1, ba = true; ba; ) {
                var ws = 0;
                ba = false;
                for (var Yt = Nn; Yt >= 0; Yt--) {
                  var Nu = ws << 16 | Qr[Yt], Uo = Nu / 10 | 0;
                  Qr[Yt] = Uo, ws = Nu - Uo * 10, Uo && !ba && (Nn = Yt, ba = true);
                }
                Zi = ws + Zi;
              }
              return Zi;
            }
            __name(Gy, "Gy");
            e.parsePseudoBigInt = Gy;
            function Xy(n) {
              var _ = n.negative, D = n.base10Value;
              return (_ && D !== "0" ? "-" : "") + D;
            }
            __name(Xy, "Xy");
            e.pseudoBigIntToString = Xy;
            function $y(n) {
              return !!(n.flags & 16777216) || Ci(n) || Zy(n) || Yy(n) || !(jn(n) || Qy(n));
            }
            __name($y, "$y");
            e.isValidTypeOnlyAliasUseSite = $y;
            function Qy(n) {
              return e.isIdentifier(n) && e.isShorthandPropertyAssignment(n.parent) && n.parent.name === n;
            }
            __name(Qy, "Qy");
            function Yy(n) {
              for (; n.kind === 79 || n.kind === 208; )
                n = n.parent;
              if (n.kind !== 164)
                return false;
              if (aa(n.parent, 256))
                return true;
              var _ = n.parent.parent.kind;
              return _ === 261 || _ === 184;
            }
            __name(Yy, "Yy");
            function Zy(n) {
              if (n.kind !== 79)
                return false;
              var _ = e.findAncestor(n.parent, function(D) {
                switch (D.kind) {
                  case 294:
                    return true;
                  case 208:
                  case 230:
                    return false;
                  default:
                    return "quit";
                }
              });
              return (_ == null ? void 0 : _.token) === 117 || (_ == null ? void 0 : _.parent.kind) === 261;
            }
            __name(Zy, "Zy");
            function eh(n) {
              return e.isTypeReferenceNode(n) && e.isIdentifier(n.typeName);
            }
            __name(eh, "eh");
            e.isIdentifierTypeReference = eh;
            function rh(n, _) {
              if (_ === void 0 && (_ = e.equateValues), n.length < 2)
                return true;
              for (var D = n[0], H = 1, Oe = n.length; H < Oe; H++) {
                var mr = n[H];
                if (!_(D, mr))
                  return false;
              }
              return true;
            }
            __name(rh, "rh");
            e.arrayIsHomogeneous = rh;
            function Ef(n, _) {
              return n.pos = _, n;
            }
            __name(Ef, "Ef");
            e.setTextRangePos = Ef;
            function Tf(n, _) {
              return n.end = _, n;
            }
            __name(Tf, "Tf");
            e.setTextRangeEnd = Tf;
            function Sf(n, _, D) {
              return Tf(Ef(n, _), D);
            }
            __name(Sf, "Sf");
            e.setTextRangePosEnd = Sf;
            function th(n, _, D) {
              return Sf(n, _, _ + D);
            }
            __name(th, "th");
            e.setTextRangePosWidth = th;
            function nh(n, _) {
              return n && (n.flags = _), n;
            }
            __name(nh, "nh");
            e.setNodeFlags = nh;
            function Kl(n, _) {
              return n && _ && (n.parent = _), n;
            }
            __name(Kl, "Kl");
            e.setParent = Kl;
            function ih(n, _) {
              if (n)
                for (var D = 0, H = n; D < H.length; D++) {
                  var Oe = H[D];
                  Kl(Oe, _);
                }
              return n;
            }
            __name(ih, "ih");
            e.setEachParent = ih;
            function ah(n, _) {
              if (!n)
                return n;
              return e.forEachChildRecursively(n, e.isJSDocNode(n) ? D : Oe), n;
              function D(mr, Tr) {
                if (_ && mr.parent === Tr)
                  return "skip";
                Kl(mr, Tr);
              }
              __name(D, "D");
              function H(mr) {
                if (e.hasJSDocNodes(mr))
                  for (var Tr = 0, Qr = mr.jsDoc; Tr < Qr.length; Tr++) {
                    var bt = Qr[Tr];
                    D(bt, mr), e.forEachChildRecursively(bt, D);
                  }
              }
              __name(H, "H");
              function Oe(mr, Tr) {
                return D(mr, Tr) || H(mr);
              }
              __name(Oe, "Oe");
            }
            __name(ah, "ah");
            e.setParentRecursive = ah;
            function oh(n) {
              return !e.isOmittedExpression(n);
            }
            __name(oh, "oh");
            function sh(n) {
              return e.isArrayLiteralExpression(n) && e.every(n.elements, oh);
            }
            __name(sh, "sh");
            e.isPackedArrayLiteral = sh;
            function _h(n) {
              for (e.Debug.assertIsDefined(n.parent); ; ) {
                var _ = n.parent;
                if (e.isParenthesizedExpression(_)) {
                  n = _;
                  continue;
                }
                if (e.isExpressionStatement(_) || e.isVoidExpression(_) || e.isForStatement(_) && (_.initializer === n || _.incrementor === n))
                  return true;
                if (e.isCommaListExpression(_)) {
                  if (n !== e.last(_.elements))
                    return true;
                  n = _;
                  continue;
                }
                if (e.isBinaryExpression(_) && _.operatorToken.kind === 27) {
                  if (n === _.left)
                    return true;
                  n = _;
                  continue;
                }
                return false;
              }
            }
            __name(_h, "_h");
            e.expressionResultIsUnused = _h;
            function Cf(n) {
              return e.some(e.ignoredPaths, function(_) {
                return e.stringContains(n, _);
              });
            }
            __name(Cf, "Cf");
            e.containsIgnoredPath = Cf;
            function ch(n) {
              if (!!n.parent) {
                switch (n.kind) {
                  case 165:
                    var _ = n.parent;
                    return _.kind === 192 ? void 0 : _.typeParameters;
                  case 166:
                    return n.parent.parameters;
                  case 201:
                    return n.parent.templateSpans;
                  case 236:
                    return n.parent.templateSpans;
                  case 167: {
                    var D = n.parent;
                    return e.canHaveDecorators(D) ? D.modifiers : e.canHaveIllegalDecorators(D) ? D.illegalDecorators : void 0;
                  }
                  case 294:
                    return n.parent.heritageClauses;
                }
                var H = n.parent;
                if (e.isJSDocTag(n))
                  return e.isJSDocTypeLiteral(n.parent) ? void 0 : n.parent.tags;
                switch (H.kind) {
                  case 184:
                  case 261:
                    return e.isTypeElement(n) ? H.members : void 0;
                  case 189:
                  case 190:
                    return H.types;
                  case 186:
                  case 206:
                  case 354:
                  case 272:
                  case 276:
                    return H.elements;
                  case 207:
                  case 289:
                    return H.properties;
                  case 210:
                  case 211:
                    return e.isTypeNode(n) ? H.typeArguments : H.expression === n ? void 0 : H.arguments;
                  case 281:
                  case 285:
                    return e.isJsxChild(n) ? H.children : void 0;
                  case 283:
                  case 282:
                    return e.isTypeNode(n) ? H.typeArguments : void 0;
                  case 238:
                  case 292:
                  case 293:
                  case 265:
                    return H.statements;
                  case 266:
                    return H.clauses;
                  case 260:
                  case 228:
                    return e.isClassElement(n) ? H.members : void 0;
                  case 263:
                    return e.isEnumMember(n) ? H.members : void 0;
                  case 308:
                    return H.statements;
                }
              }
            }
            __name(ch, "ch");
            e.getContainingNodeArray = ch;
            function uh(n) {
              if (!n.typeParameters) {
                if (e.some(n.parameters, function(D) {
                  return !ns(D);
                }))
                  return true;
                if (n.kind !== 216) {
                  var _ = e.firstOrUndefined(n.parameters);
                  if (!(_ && rs(_)))
                    return true;
                }
              }
              return false;
            }
            __name(uh, "uh");
            e.hasContextSensitiveParameters = uh;
            function lh(n) {
              return n === "Infinity" || n === "-Infinity" || n === "NaN";
            }
            __name(lh, "lh");
            e.isInfinityOrNaNString = lh;
            function Df(n) {
              return n.kind === 257 && n.parent.kind === 295;
            }
            __name(Df, "Df");
            e.isCatchClauseVariableDeclaration = Df;
            function ph(n) {
              var _ = n.valueDeclaration && la(n.valueDeclaration);
              return !!_ && (e.isParameter(_) || Df(_));
            }
            __name(ph, "ph");
            e.isParameterOrCatchClauseVariable = ph;
            function fh(n) {
              return n.kind === 215 || n.kind === 216;
            }
            __name(fh, "fh");
            e.isFunctionExpressionOrArrowFunction = fh;
            function dh(n) {
              return n.replace(/\$/gm, function() {
                return "\\$";
              });
            }
            __name(dh, "dh");
            e.escapeSnippetText = dh;
            function xf(n) {
              return (+n).toString() === n;
            }
            __name(xf, "xf");
            e.isNumericLiteralName = xf;
            function mh(n, _, D, H) {
              return e.isIdentifierText(n, _) ? e.factory.createIdentifier(n) : !H && xf(n) && +n >= 0 ? e.factory.createNumericLiteral(+n) : e.factory.createStringLiteral(n, !!D);
            }
            __name(mh, "mh");
            e.createPropertyNameNodeForIdentifierOrLiteral = mh;
            function gh(n) {
              return !!(n.flags & 262144 && n.isThisType);
            }
            __name(gh, "gh");
            e.isThisTypeParameter = gh;
            function yh(n) {
              var _ = 0, D = 0, H = 0, Oe = 0, mr;
              (function(lt) {
                lt[lt.BeforeNodeModules = 0] = "BeforeNodeModules", lt[lt.NodeModules = 1] = "NodeModules", lt[lt.Scope = 2] = "Scope", lt[lt.PackageContent = 3] = "PackageContent";
              })(mr || (mr = {}));
              for (var Tr = 0, Qr = 0, bt = 0; Qr >= 0; )
                switch (Tr = Qr, Qr = n.indexOf("/", Tr + 1), bt) {
                  case 0:
                    n.indexOf(e.nodeModulesPathPart, Tr) === Tr && (_ = Tr, D = Qr, bt = 1);
                    break;
                  case 1:
                  case 2:
                    bt === 1 && n.charAt(Tr + 1) === "@" ? bt = 2 : (H = Qr, bt = 3);
                    break;
                  case 3:
                    n.indexOf(e.nodeModulesPathPart, Tr) === Tr ? bt = 1 : bt = 3;
                    break;
                }
              return Oe = Tr, bt > 1 ? { topLevelNodeModulesIndex: _, topLevelPackageNameIndex: D, packageRootIndex: H, fileNameIndex: Oe } : void 0;
            }
            __name(yh, "yh");
            e.getNodeModulePathParts = yh;
            function hh(n) {
              var _;
              return n.kind === 343 ? (_ = n.typeExpression) === null || _ === void 0 ? void 0 : _.type : n.type;
            }
            __name(hh, "hh");
            e.getParameterTypeNode = hh;
            function wf(n) {
              switch (n.kind) {
                case 165:
                case 260:
                case 261:
                case 262:
                case 263:
                case 348:
                case 341:
                case 342:
                  return true;
                case 270:
                  return n.isTypeOnly;
                case 273:
                case 278:
                  return n.parent.parent.isTypeOnly;
                default:
                  return false;
              }
            }
            __name(wf, "wf");
            e.isTypeDeclaration = wf;
            function vh(n) {
              return e.isEnumDeclaration(n) || e.isVariableStatement(n) || e.isFunctionDeclaration(n) || e.isClassDeclaration(n) || e.isInterfaceDeclaration(n) || wf(n) || e.isModuleDeclaration(n) && !me(n) && !Ie(n);
            }
            __name(vh, "vh");
            e.canHaveExportModifier = vh;
          })(N || (N = {}));
          var N;
          (function(e) {
            function t() {
              var x, s, q, F, fe;
              return { createBaseSourceFileNode: Te, createBaseIdentifierNode: Se, createBasePrivateIdentifierNode: J, createBaseTokenNode: se, createBaseNode: Le };
              function Te(Q) {
                return new (fe || (fe = e.objectAllocator.getSourceFileConstructor()))(Q, -1, -1);
              }
              __name(Te, "Te");
              function Se(Q) {
                return new (q || (q = e.objectAllocator.getIdentifierConstructor()))(Q, -1, -1);
              }
              __name(Se, "Se");
              function J(Q) {
                return new (F || (F = e.objectAllocator.getPrivateIdentifierConstructor()))(Q, -1, -1);
              }
              __name(J, "J");
              function se(Q) {
                return new (s || (s = e.objectAllocator.getTokenConstructor()))(Q, -1, -1);
              }
              __name(se, "se");
              function Le(Q) {
                return new (x || (x = e.objectAllocator.getNodeConstructor()))(Q, -1, -1);
              }
              __name(Le, "Le");
            }
            __name(t, "t");
            e.createBaseNodeFactory = t;
          })(N || (N = {}));
          var N;
          (function(e) {
            function t(x) {
              var s, q;
              return { getParenthesizeLeftSideOfBinaryForOperator: F, getParenthesizeRightSideOfBinaryForOperator: fe, parenthesizeLeftSideOfBinary: Le, parenthesizeRightSideOfBinary: Q, parenthesizeExpressionOfComputedPropertyName: Be, parenthesizeConditionOfConditionalExpression: je, parenthesizeBranchOfConditionalExpression: W, parenthesizeExpressionOfExportDefault: B, parenthesizeExpressionOfNew: U, parenthesizeLeftSideOfAccess: m, parenthesizeOperandOfPostfixUnary: v, parenthesizeOperandOfPrefixUnary: g, parenthesizeExpressionsOfCommaDelimitedList: O, parenthesizeExpressionForDisallowedComma: S, parenthesizeExpressionOfExpressionStatement: te, parenthesizeConciseBodyOfArrowFunction: Je, parenthesizeCheckTypeOfConditionalType: qe, parenthesizeExtendsTypeOfConditionalType: ge, parenthesizeConstituentTypesOfUnionType: G, parenthesizeConstituentTypeOfUnionType: ie, parenthesizeConstituentTypesOfIntersectionType: j, parenthesizeConstituentTypeOfIntersectionType: pe, parenthesizeOperandOfTypeOperator: be, parenthesizeOperandOfReadonlyTypeOperator: $e, parenthesizeNonArrayTypeOfPostfixType: Re, parenthesizeElementTypesOfTupleType: Fe, parenthesizeElementTypeOfTupleType: dr, parenthesizeTypeOfOptionalType: ve, parenthesizeTypeArguments: Cr, parenthesizeLeadingTypeArgument: er };
              function F(Ce) {
                s || (s = new e.Map());
                var Xe = s.get(Ce);
                return Xe || (Xe = /* @__PURE__ */ __name(function(gr) {
                  return Le(Ce, gr);
                }, "Xe"), s.set(Ce, Xe)), Xe;
              }
              __name(F, "F");
              function fe(Ce) {
                q || (q = new e.Map());
                var Xe = q.get(Ce);
                return Xe || (Xe = /* @__PURE__ */ __name(function(gr) {
                  return Q(Ce, void 0, gr);
                }, "Xe"), q.set(Ce, Xe)), Xe;
              }
              __name(fe, "fe");
              function Te(Ce, Xe, gr, X) {
                var Ee = e.getOperatorPrecedence(223, Ce), we = e.getOperatorAssociativity(223, Ce), he = e.skipPartiallyEmittedExpressions(Xe);
                if (!gr && Xe.kind === 216 && Ee > 3)
                  return true;
                var yr = e.getExpressionPrecedence(he);
                switch (e.compareValues(yr, Ee)) {
                  case -1:
                    return !(!gr && we === 1 && Xe.kind === 226);
                  case 1:
                    return false;
                  case 0:
                    if (gr)
                      return we === 1;
                    if (e.isBinaryExpression(he) && he.operatorToken.kind === Ce) {
                      if (Se(Ce))
                        return false;
                      if (Ce === 39) {
                        var kr = X ? J(X) : 0;
                        if (e.isLiteralKind(kr) && kr === J(he))
                          return false;
                      }
                    }
                    var nr = e.getExpressionAssociativity(he);
                    return nr === 0;
                }
              }
              __name(Te, "Te");
              function Se(Ce) {
                return Ce === 41 || Ce === 51 || Ce === 50 || Ce === 52 || Ce === 27;
              }
              __name(Se, "Se");
              function J(Ce) {
                if (Ce = e.skipPartiallyEmittedExpressions(Ce), e.isLiteralKind(Ce.kind))
                  return Ce.kind;
                if (Ce.kind === 223 && Ce.operatorToken.kind === 39) {
                  if (Ce.cachedLiteralKind !== void 0)
                    return Ce.cachedLiteralKind;
                  var Xe = J(Ce.left), gr = e.isLiteralKind(Xe) && Xe === J(Ce.right) ? Xe : 0;
                  return Ce.cachedLiteralKind = gr, gr;
                }
                return 0;
              }
              __name(J, "J");
              function se(Ce, Xe, gr, X) {
                var Ee = e.skipPartiallyEmittedExpressions(Xe);
                return Ee.kind === 214 ? Xe : Te(Ce, Xe, gr, X) ? x.createParenthesizedExpression(Xe) : Xe;
              }
              __name(se, "se");
              function Le(Ce, Xe) {
                return se(Ce, Xe, true);
              }
              __name(Le, "Le");
              function Q(Ce, Xe, gr) {
                return se(Ce, gr, false, Xe);
              }
              __name(Q, "Q");
              function Be(Ce) {
                return e.isCommaSequence(Ce) ? x.createParenthesizedExpression(Ce) : Ce;
              }
              __name(Be, "Be");
              function je(Ce) {
                var Xe = e.getOperatorPrecedence(224, 57), gr = e.skipPartiallyEmittedExpressions(Ce), X = e.getExpressionPrecedence(gr);
                return e.compareValues(X, Xe) !== 1 ? x.createParenthesizedExpression(Ce) : Ce;
              }
              __name(je, "je");
              function W(Ce) {
                var Xe = e.skipPartiallyEmittedExpressions(Ce);
                return e.isCommaSequence(Xe) ? x.createParenthesizedExpression(Ce) : Ce;
              }
              __name(W, "W");
              function B(Ce) {
                var Xe = e.skipPartiallyEmittedExpressions(Ce), gr = e.isCommaSequence(Xe);
                if (!gr)
                  switch (e.getLeftmostExpression(Xe, false).kind) {
                    case 228:
                    case 215:
                      gr = true;
                  }
                return gr ? x.createParenthesizedExpression(Ce) : Ce;
              }
              __name(B, "B");
              function U(Ce) {
                var Xe = e.getLeftmostExpression(Ce, true);
                switch (Xe.kind) {
                  case 210:
                    return x.createParenthesizedExpression(Ce);
                  case 211:
                    return Xe.arguments ? Ce : x.createParenthesizedExpression(Ce);
                }
                return m(Ce);
              }
              __name(U, "U");
              function m(Ce, Xe) {
                var gr = e.skipPartiallyEmittedExpressions(Ce);
                return e.isLeftHandSideExpression(gr) && (gr.kind !== 211 || gr.arguments) && (Xe || !e.isOptionalChain(gr)) ? Ce : e.setTextRange(x.createParenthesizedExpression(Ce), Ce);
              }
              __name(m, "m");
              function v(Ce) {
                return e.isLeftHandSideExpression(Ce) ? Ce : e.setTextRange(x.createParenthesizedExpression(Ce), Ce);
              }
              __name(v, "v");
              function g(Ce) {
                return e.isUnaryExpression(Ce) ? Ce : e.setTextRange(x.createParenthesizedExpression(Ce), Ce);
              }
              __name(g, "g");
              function O(Ce) {
                var Xe = e.sameMap(Ce, S);
                return e.setTextRange(x.createNodeArray(Xe, Ce.hasTrailingComma), Ce);
              }
              __name(O, "O");
              function S(Ce) {
                var Xe = e.skipPartiallyEmittedExpressions(Ce), gr = e.getExpressionPrecedence(Xe), X = e.getOperatorPrecedence(223, 27);
                return gr > X ? Ce : e.setTextRange(x.createParenthesizedExpression(Ce), Ce);
              }
              __name(S, "S");
              function te(Ce) {
                var Xe = e.skipPartiallyEmittedExpressions(Ce);
                if (e.isCallExpression(Xe)) {
                  var gr = Xe.expression, X = e.skipPartiallyEmittedExpressions(gr).kind;
                  if (X === 215 || X === 216) {
                    var Ee = x.updateCallExpression(Xe, e.setTextRange(x.createParenthesizedExpression(gr), gr), Xe.typeArguments, Xe.arguments);
                    return x.restoreOuterExpressions(Ce, Ee, 8);
                  }
                }
                var we = e.getLeftmostExpression(Xe, false).kind;
                return we === 207 || we === 215 ? e.setTextRange(x.createParenthesizedExpression(Ce), Ce) : Ce;
              }
              __name(te, "te");
              function Je(Ce) {
                return !e.isBlock(Ce) && (e.isCommaSequence(Ce) || e.getLeftmostExpression(Ce, false).kind === 207) ? e.setTextRange(x.createParenthesizedExpression(Ce), Ce) : Ce;
              }
              __name(Je, "Je");
              function qe(Ce) {
                switch (Ce.kind) {
                  case 181:
                  case 182:
                  case 191:
                    return x.createParenthesizedType(Ce);
                }
                return Ce;
              }
              __name(qe, "qe");
              function ge(Ce) {
                switch (Ce.kind) {
                  case 191:
                    return x.createParenthesizedType(Ce);
                }
                return Ce;
              }
              __name(ge, "ge");
              function ie(Ce) {
                switch (Ce.kind) {
                  case 189:
                  case 190:
                    return x.createParenthesizedType(Ce);
                }
                return qe(Ce);
              }
              __name(ie, "ie");
              function G(Ce) {
                return x.createNodeArray(e.sameMap(Ce, ie));
              }
              __name(G, "G");
              function pe(Ce) {
                switch (Ce.kind) {
                  case 189:
                  case 190:
                    return x.createParenthesizedType(Ce);
                }
                return ie(Ce);
              }
              __name(pe, "pe");
              function j(Ce) {
                return x.createNodeArray(e.sameMap(Ce, pe));
              }
              __name(j, "j");
              function be(Ce) {
                switch (Ce.kind) {
                  case 190:
                    return x.createParenthesizedType(Ce);
                }
                return pe(Ce);
              }
              __name(be, "be");
              function $e(Ce) {
                switch (Ce.kind) {
                  case 195:
                    return x.createParenthesizedType(Ce);
                }
                return be(Ce);
              }
              __name($e, "$e");
              function Re(Ce) {
                switch (Ce.kind) {
                  case 192:
                  case 195:
                  case 183:
                    return x.createParenthesizedType(Ce);
                }
                return be(Ce);
              }
              __name(Re, "Re");
              function Fe(Ce) {
                return x.createNodeArray(e.sameMap(Ce, dr));
              }
              __name(Fe, "Fe");
              function dr(Ce) {
                return ze(Ce) ? x.createParenthesizedType(Ce) : Ce;
              }
              __name(dr, "dr");
              function ze(Ce) {
                return e.isJSDocNullableType(Ce) ? Ce.postfix : e.isNamedTupleMember(Ce) || e.isFunctionTypeNode(Ce) || e.isConstructorTypeNode(Ce) || e.isTypeOperatorNode(Ce) ? ze(Ce.type) : e.isConditionalTypeNode(Ce) ? ze(Ce.falseType) : e.isUnionTypeNode(Ce) || e.isIntersectionTypeNode(Ce) ? ze(e.last(Ce.types)) : e.isInferTypeNode(Ce) ? !!Ce.typeParameter.constraint && ze(Ce.typeParameter.constraint) : false;
              }
              __name(ze, "ze");
              function ve(Ce) {
                return ze(Ce) ? x.createParenthesizedType(Ce) : Re(Ce);
              }
              __name(ve, "ve");
              function er(Ce) {
                return e.isFunctionOrConstructorTypeNode(Ce) && Ce.typeParameters ? x.createParenthesizedType(Ce) : Ce;
              }
              __name(er, "er");
              function ar(Ce, Xe) {
                return Xe === 0 ? er(Ce) : Ce;
              }
              __name(ar, "ar");
              function Cr(Ce) {
                if (e.some(Ce))
                  return x.createNodeArray(e.sameMap(Ce, ar));
              }
              __name(Cr, "Cr");
            }
            __name(t, "t");
            e.createParenthesizerRules = t, e.nullParenthesizerRules = { getParenthesizeLeftSideOfBinaryForOperator: function(x) {
              return e.identity;
            }, getParenthesizeRightSideOfBinaryForOperator: function(x) {
              return e.identity;
            }, parenthesizeLeftSideOfBinary: function(x, s) {
              return s;
            }, parenthesizeRightSideOfBinary: function(x, s, q) {
              return q;
            }, parenthesizeExpressionOfComputedPropertyName: e.identity, parenthesizeConditionOfConditionalExpression: e.identity, parenthesizeBranchOfConditionalExpression: e.identity, parenthesizeExpressionOfExportDefault: e.identity, parenthesizeExpressionOfNew: function(x) {
              return e.cast(x, e.isLeftHandSideExpression);
            }, parenthesizeLeftSideOfAccess: function(x) {
              return e.cast(x, e.isLeftHandSideExpression);
            }, parenthesizeOperandOfPostfixUnary: function(x) {
              return e.cast(x, e.isLeftHandSideExpression);
            }, parenthesizeOperandOfPrefixUnary: function(x) {
              return e.cast(x, e.isUnaryExpression);
            }, parenthesizeExpressionsOfCommaDelimitedList: function(x) {
              return e.cast(x, e.isNodeArray);
            }, parenthesizeExpressionForDisallowedComma: e.identity, parenthesizeExpressionOfExpressionStatement: e.identity, parenthesizeConciseBodyOfArrowFunction: e.identity, parenthesizeCheckTypeOfConditionalType: e.identity, parenthesizeExtendsTypeOfConditionalType: e.identity, parenthesizeConstituentTypesOfUnionType: function(x) {
              return e.cast(x, e.isNodeArray);
            }, parenthesizeConstituentTypeOfUnionType: e.identity, parenthesizeConstituentTypesOfIntersectionType: function(x) {
              return e.cast(x, e.isNodeArray);
            }, parenthesizeConstituentTypeOfIntersectionType: e.identity, parenthesizeOperandOfTypeOperator: e.identity, parenthesizeOperandOfReadonlyTypeOperator: e.identity, parenthesizeNonArrayTypeOfPostfixType: e.identity, parenthesizeElementTypesOfTupleType: function(x) {
              return e.cast(x, e.isNodeArray);
            }, parenthesizeElementTypeOfTupleType: e.identity, parenthesizeTypeOfOptionalType: e.identity, parenthesizeTypeArguments: function(x) {
              return x && e.cast(x, e.isNodeArray);
            }, parenthesizeLeadingTypeArgument: e.identity };
          })(N || (N = {}));
          var N;
          (function(e) {
            function t(x) {
              return { convertToFunctionBlock: s, convertToFunctionExpression: q, convertToArrayAssignmentElement: F, convertToObjectAssignmentElement: fe, convertToAssignmentPattern: Te, convertToObjectAssignmentPattern: Se, convertToArrayAssignmentPattern: J, convertToAssignmentElementTarget: se };
              function s(Le, Q) {
                if (e.isBlock(Le))
                  return Le;
                var Be = x.createReturnStatement(Le);
                e.setTextRange(Be, Le);
                var je = x.createBlock([Be], Q);
                return e.setTextRange(je, Le), je;
              }
              __name(s, "s");
              function q(Le) {
                if (!Le.body)
                  return e.Debug.fail("Cannot convert a FunctionDeclaration without a body");
                var Q = x.createFunctionExpression(Le.modifiers, Le.asteriskToken, Le.name, Le.typeParameters, Le.parameters, Le.type, Le.body);
                return e.setOriginalNode(Q, Le), e.setTextRange(Q, Le), e.getStartsOnNewLine(Le) && e.setStartsOnNewLine(Q, true), Q;
              }
              __name(q, "q");
              function F(Le) {
                if (e.isBindingElement(Le)) {
                  if (Le.dotDotDotToken)
                    return e.Debug.assertNode(Le.name, e.isIdentifier), e.setOriginalNode(e.setTextRange(x.createSpreadElement(Le.name), Le), Le);
                  var Q = se(Le.name);
                  return Le.initializer ? e.setOriginalNode(e.setTextRange(x.createAssignment(Q, Le.initializer), Le), Le) : Q;
                }
                return e.cast(Le, e.isExpression);
              }
              __name(F, "F");
              function fe(Le) {
                if (e.isBindingElement(Le)) {
                  if (Le.dotDotDotToken)
                    return e.Debug.assertNode(Le.name, e.isIdentifier), e.setOriginalNode(e.setTextRange(x.createSpreadAssignment(Le.name), Le), Le);
                  if (Le.propertyName) {
                    var Q = se(Le.name);
                    return e.setOriginalNode(e.setTextRange(x.createPropertyAssignment(Le.propertyName, Le.initializer ? x.createAssignment(Q, Le.initializer) : Q), Le), Le);
                  }
                  return e.Debug.assertNode(Le.name, e.isIdentifier), e.setOriginalNode(e.setTextRange(x.createShorthandPropertyAssignment(Le.name, Le.initializer), Le), Le);
                }
                return e.cast(Le, e.isObjectLiteralElementLike);
              }
              __name(fe, "fe");
              function Te(Le) {
                switch (Le.kind) {
                  case 204:
                  case 206:
                    return J(Le);
                  case 203:
                  case 207:
                    return Se(Le);
                }
              }
              __name(Te, "Te");
              function Se(Le) {
                return e.isObjectBindingPattern(Le) ? e.setOriginalNode(e.setTextRange(x.createObjectLiteralExpression(e.map(Le.elements, fe)), Le), Le) : e.cast(Le, e.isObjectLiteralExpression);
              }
              __name(Se, "Se");
              function J(Le) {
                return e.isArrayBindingPattern(Le) ? e.setOriginalNode(e.setTextRange(x.createArrayLiteralExpression(e.map(Le.elements, F)), Le), Le) : e.cast(Le, e.isArrayLiteralExpression);
              }
              __name(J, "J");
              function se(Le) {
                return e.isBindingPattern(Le) ? Te(Le) : e.cast(Le, e.isExpression);
              }
              __name(se, "se");
            }
            __name(t, "t");
            e.createNodeConverters = t, e.nullNodeConverters = { convertToFunctionBlock: e.notImplemented, convertToFunctionExpression: e.notImplemented, convertToArrayAssignmentElement: e.notImplemented, convertToObjectAssignmentElement: e.notImplemented, convertToAssignmentPattern: e.notImplemented, convertToObjectAssignmentPattern: e.notImplemented, convertToArrayAssignmentPattern: e.notImplemented, convertToAssignmentElementTarget: e.notImplemented };
          })(N || (N = {}));
          var N;
          (function(e) {
            var t = 0, x;
            (function(G) {
              G[G.None = 0] = "None", G[G.NoParenthesizerRules = 1] = "NoParenthesizerRules", G[G.NoNodeConverters = 2] = "NoNodeConverters", G[G.NoIndentationOnFreshPropertyAccess = 4] = "NoIndentationOnFreshPropertyAccess", G[G.NoOriginalNode = 8] = "NoOriginalNode";
            })(x = e.NodeFactoryFlags || (e.NodeFactoryFlags = {}));
            function s(G, pe) {
              var j = G & 8 ? q : F, be = e.memoize(function() {
                return G & 1 ? e.nullParenthesizerRules : e.createParenthesizerRules(Ee);
              }), $e = e.memoize(function() {
                return G & 2 ? e.nullNodeConverters : e.createNodeConverters(Ee);
              }), Re = e.memoizeOne(function(i) {
                return function(o, u) {
                  return ji(o, i, u);
                };
              }), Fe = e.memoizeOne(function(i) {
                return function(o) {
                  return Qt(i, o);
                };
              }), dr = e.memoizeOne(function(i) {
                return function(o) {
                  return Ii(o, i);
                };
              }), ze = e.memoizeOne(function(i) {
                return function() {
                  return Y_(i);
                };
              }), ve = e.memoizeOne(function(i) {
                return function(o) {
                  return es(i, o);
                };
              }), er = e.memoizeOne(function(i) {
                return function(o, u) {
                  return Zc(i, o, u);
                };
              }), ar = e.memoizeOne(function(i) {
                return function(o, u) {
                  return Z_(i, o, u);
                };
              }), Cr = e.memoizeOne(function(i) {
                return function(o, u) {
                  return ec(i, o, u);
                };
              }), Ce = e.memoizeOne(function(i) {
                return function(o, u) {
                  return is(i, o, u);
                };
              }), Xe = e.memoizeOne(function(i) {
                return function(o, u, b) {
                  return aa(i, o, u, b);
                };
              }), gr = e.memoizeOne(function(i) {
                return function(o, u, b) {
                  return as(i, o, u, b);
                };
              }), X = e.memoizeOne(function(i) {
                return function(o, u, b, Y) {
                  return u_(i, o, u, b, Y);
                };
              }), Ee = { get parenthesizer() {
                return be();
              }, get converters() {
                return $e();
              }, baseFactory: pe, flags: G, createNodeArray: we, createNumericLiteral: ut, createBigIntLiteral: rt, createStringLiteral: f, createStringLiteralFromNode: h, createRegularExpressionLiteral: ae, createLiteralLikeNode: xr, createIdentifier: pt, updateIdentifier: Ge, createTempVariable: K, createLoopVariable: r, createUniqueName: ct, getGeneratedNameForNode: ft, createPrivateIdentifier: me, createUniquePrivateName: Ye, getGeneratedPrivateNameForNode: vr, createToken: pr, createSuper: Mr, createThis: ot, createNull: At, createTrue: re, createFalse: de, createModifier: He, createModifiersFromModifierFlags: Nr, createQualifiedName: Yr, updateQualifiedName: St, createComputedPropertyName: Dt, updateComputedPropertyName: Lt, createTypeParameterDeclaration: zt, updateTypeParameterDeclaration: Zt, createParameterDeclaration: mt, updateParameterDeclaration: at, createDecorator: k, updateDecorator: ue, createPropertySignature: Qe, updatePropertySignature: Sr, createPropertyDeclaration: Hr, updatePropertyDeclaration: Ct, createMethodSignature: Xt, updateMethodSignature: cn, createMethodDeclaration: In, updateMethodDeclaration: yn, createConstructorDeclaration: ui, updateConstructorDeclaration: ei, createGetAccessorDeclaration: ri, updateGetAccessorDeclaration: bi, createSetAccessorDeclaration: Yn, updateSetAccessorDeclaration: oi, createCallSignature: Dn, updateCallSignature: Kn, createConstructSignature: si, updateConstructSignature: mi, createIndexSignature: Zn, updateIndexSignature: Fn, createClassStaticBlockDeclaration: ln, updateClassStaticBlockDeclaration: En, createTemplateLiteralTypeSpan: gt, updateTemplateLiteralTypeSpan: gi, createKeywordTypeNode: dn, createTypePredicateNode: On, updateTypePredicateNode: br, createTypeReferenceNode: Ae, updateTypeReferenceNode: ur, createFunctionTypeNode: L, updateFunctionTypeNode: qt, createConstructorTypeNode: fr, updateConstructorTypeNode: _r, createTypeQueryNode: tt, updateTypeQueryNode: dt, createTypeLiteralNode: It, updateTypeLiteralNode: an, createArrayTypeNode: sn, updateArrayTypeNode: _e, createTupleTypeNode: Gr, updateTupleTypeNode: Kt, createNamedTupleMember: en, updateNamedTupleMember: Ot, createOptionalTypeNode: rr, updateOptionalTypeNode: Hn, createRestTypeNode: rn, updateRestTypeNode: xn, createUnionTypeNode: kn, updateUnionTypeNode: on, createIntersectionTypeNode: Xr, updateIntersectionTypeNode: wr, createConditionalTypeNode: fn, updateConditionalTypeNode: mn, createInferTypeNode: Li, updateInferTypeNode: An, createImportTypeNode: li, updateImportTypeNode: Bn, createParenthesizedType: vn, updateParenthesizedType: Ue, createThisTypeNode: Vn, createTypeOperatorNode: Ti, updateTypeOperatorNode: ni, createIndexedAccessTypeNode: Bi, updateIndexedAccessTypeNode: Tn, createMappedTypeNode: jn, updateMappedTypeNode: Si, createLiteralTypeNode: Ci, updateLiteralTypeNode: C, createTemplateLiteralType: wi, updateTemplateLiteralType: ti, createObjectBindingPattern: V, updateObjectBindingPattern: ee, createArrayBindingPattern: le, updateArrayBindingPattern: Ze, createBindingElement: Ir, updateBindingElement: Ar, createArrayLiteralExpression: yt, updateArrayLiteralExpression: Pt, createObjectLiteralExpression: Ut, updateObjectLiteralExpression: jt, createPropertyAccessExpression: G & 4 ? function(i, o) {
                return e.setEmitFlags(Ht(i, o), 131072);
              } : Ht, updatePropertyAccessExpression: yi, createPropertyAccessChain: G & 4 ? function(i, o, u) {
                return e.setEmitFlags(Ni(i, o, u), 131072);
              } : Ni, updatePropertyAccessChain: Gn, createElementAccessExpression: qi, updateElementAccessExpression: sa, createElementAccessChain: ea, updateElementAccessChain: Hi, createCallExpression: Ui, updateCallExpression: Gi, createCallChain: Xi, updateCallChain: ma, createNewExpression: Jn, updateNewExpression: ra, createTaggedTemplateExpression: $i, updateTaggedTemplateExpression: _a, createTypeAssertion: Ri, updateTypeAssertion: p, createParenthesizedExpression: ne, updateParenthesizedExpression: Ne, createFunctionExpression: or, updateFunctionExpression: it, createArrowFunction: vt, updateArrowFunction: Et, createDeleteExpression: Tt, updateDeleteExpression: tn, createTypeOfExpression: Mt, updateTypeOfExpression: $t, createVoidExpression: y, updateVoidExpression: De, createAwaitExpression: R, updateAwaitExpression: Jt, createPrefixUnaryExpression: Qt, updatePrefixUnaryExpression: qn, createPostfixUnaryExpression: Ii, updatePostfixUnaryExpression: ca, createBinaryExpression: ji, updateBinaryExpression: Qi, createConditionalExpression: ta, updateConditionalExpression: Ta, createTemplateExpression: zi, updateTemplateExpression: Ji, createTemplateHead: Ns, createTemplateMiddle: wa, createTemplateTail: Wo, createNoSubstitutionTemplateLiteral: Sa, createTemplateLiteralLikeNode: yo, createYieldExpression: Fa, updateYieldExpression: ho, createSpreadElement: vo, updateSpreadElement: eo, createClassExpression: Aa, updateClassExpression: bo, createOmittedExpression: Is, createExpressionWithTypeArguments: Eo, updateExpressionWithTypeArguments: To, createAsExpression: ka, updateAsExpression: ro, createNonNullExpression: Ko, updateNonNullExpression: Oi, createSatisfiesExpression: Ba, updateSatisfiesExpression: to, createNonNullChain: So, updateNonNullChain: Co, createMetaProperty: Ho, updateMetaProperty: Go, createTemplateSpan: Vi, updateTemplateSpan: Os, createSemicolonClassElement: Do, createBlock: l, updateBlock: w, createVariableStatement: M, updateVariableStatement: ke, createEmptyStatement: cr, createExpressionStatement: Zr, updateExpressionStatement: _t, createIfStatement: Rt, updateIfStatement: un, createDoStatement: bn, updateDoStatement: _n, createWhileStatement: Nt, updateWhileStatement: Ft, createForStatement: Sn, updateForStatement: wn, createForInStatement: Wn, updateForInStatement: Fi, createForOfStatement: qa, updateForOfStatement: xo, createContinueStatement: wo, updateContinueStatement: Ao, createBreakStatement: no, updateBreakStatement: Vc, createReturnStatement: Ms, updateReturnStatement: ko, createWithStatement: Ls, updateWithStatement: Xo, createSwitchStatement: $o, updateSwitchStatement: w_, createLabeledStatement: Rs, updateLabeledStatement: js, createThrowStatement: Js, updateThrowStatement: io, createTryStatement: A_, updateTryStatement: Wc, createDebuggerStatement: Kc, createVariableDeclaration: Fs, updateVariableDeclaration: Pa, createVariableDeclarationList: Po, updateVariableDeclarationList: Bs, createFunctionDeclaration: No, updateFunctionDeclaration: ao, createClassDeclaration: Qo, updateClassDeclaration: k_, createInterfaceDeclaration: Us, updateInterfaceDeclaration: P_, createTypeAliasDeclaration: zs, updateTypeAliasDeclaration: N_, createEnumDeclaration: Un, updateEnumDeclaration: la, createModuleDeclaration: Ca, updateModuleDeclaration: O_, createModuleBlock: Na, updateModuleBlock: Ai, createCaseBlock: M_, updateCaseBlock: Vs, createNamespaceExportDeclaration: L_, updateNamespaceExportDeclaration: Ws, createImportEqualsDeclaration: j_, updateImportEqualsDeclaration: J_, createImportDeclaration: F_, updateImportDeclaration: B_, createImportClause: Ks, updateImportClause: $c, createAssertClause: Io, updateAssertClause: Hs, createAssertEntry: Gs, updateAssertEntry: Oo, createImportTypeAssertionContainer: Xs, updateImportTypeAssertionContainer: oo, createNamespaceImport: U_, updateNamespaceImport: z_, createNamespaceExport: V_, updateNamespaceExport: Qc, createNamedImports: W_, updateNamedImports: K_, createImportSpecifier: H_, updateImportSpecifier: G_, createExportAssignment: Da, updateExportAssignment: Ua, createExportDeclaration: na, updateExportDeclaration: $s, createNamedExports: so, updateNamedExports: X_, createExportSpecifier: Qs, updateExportSpecifier: Ys, createMissingDeclaration: $_, createExternalModuleReference: Q_, updateExternalModuleReference: Zo, get createJSDocAllType() {
                return ze(315);
              }, get createJSDocUnknownType() {
                return ze(316);
              }, get createJSDocNonNullableType() {
                return ar(318);
              }, get updateJSDocNonNullableType() {
                return Cr(318);
              }, get createJSDocNullableType() {
                return ar(317);
              }, get updateJSDocNullableType() {
                return Cr(317);
              }, get createJSDocOptionalType() {
                return ve(319);
              }, get updateJSDocOptionalType() {
                return er(319);
              }, get createJSDocVariadicType() {
                return ve(321);
              }, get updateJSDocVariadicType() {
                return er(321);
              }, get createJSDocNamepathType() {
                return ve(322);
              }, get updateJSDocNamepathType() {
                return er(322);
              }, createJSDocFunctionType: Zs, updateJSDocFunctionType: eu, createJSDocTypeLiteral: rc, updateJSDocTypeLiteral: e_, createJSDocTypeExpression: Mo, updateJSDocTypeExpression: r_, createJSDocSignature: tc, updateJSDocSignature: Lo, createJSDocTemplateTag: pa, updateJSDocTemplateTag: t_, createJSDocTypedefTag: _o, updateJSDocTypedefTag: ru, createJSDocParameterTag: n_, updateJSDocParameterTag: rs, createJSDocPropertyTag: ts, updateJSDocPropertyTag: nc, createJSDocCallbackTag: i_, updateJSDocCallbackTag: ic, createJSDocAugmentsTag: ns, updateJSDocAugmentsTag: a_, createJSDocImplementsTag: o_, updateJSDocImplementsTag: ou, createJSDocSeeTag: co, updateJSDocSeeTag: tu, createJSDocNameReference: za, updateJSDocNameReference: Ro, createJSDocMemberName: s_, updateJSDocMemberName: nu, createJSDocLink: __, updateJSDocLink: iu, createJSDocLinkCode: ac, updateJSDocLinkCode: oc, createJSDocLinkPlain: c_, updateJSDocLinkPlain: au, get createJSDocTypeTag() {
                return gr(346);
              }, get updateJSDocTypeTag() {
                return X(346);
              }, get createJSDocReturnTag() {
                return gr(344);
              }, get updateJSDocReturnTag() {
                return X(344);
              }, get createJSDocThisTag() {
                return gr(345);
              }, get updateJSDocThisTag() {
                return X(345);
              }, get createJSDocEnumTag() {
                return gr(342);
              }, get updateJSDocEnumTag() {
                return X(342);
              }, get createJSDocAuthorTag() {
                return Ce(333);
              }, get updateJSDocAuthorTag() {
                return Xe(333);
              }, get createJSDocClassTag() {
                return Ce(335);
              }, get updateJSDocClassTag() {
                return Xe(335);
              }, get createJSDocPublicTag() {
                return Ce(336);
              }, get updateJSDocPublicTag() {
                return Xe(336);
              }, get createJSDocPrivateTag() {
                return Ce(337);
              }, get updateJSDocPrivateTag() {
                return Xe(337);
              }, get createJSDocProtectedTag() {
                return Ce(338);
              }, get updateJSDocProtectedTag() {
                return Xe(338);
              }, get createJSDocReadonlyTag() {
                return Ce(339);
              }, get updateJSDocReadonlyTag() {
                return Xe(339);
              }, get createJSDocOverrideTag() {
                return Ce(340);
              }, get updateJSDocOverrideTag() {
                return Xe(340);
              }, get createJSDocDeprecatedTag() {
                return Ce(334);
              }, get updateJSDocDeprecatedTag() {
                return Xe(334);
              }, createJSDocUnknownTag: sc, updateJSDocUnknownTag: su, createJSDocText: _c, updateJSDocText: _u, createJSDocComment: os, updateJSDocComment: ss, createJsxElement: l_, updateJsxElement: p_, createJsxSelfClosingElement: jo, updateJsxSelfClosingElement: f_, createJsxOpeningElement: Jo, updateJsxOpeningElement: _s, createJsxClosingElement: d_, updateJsxClosingElement: cu, createJsxFragment: ki, createJsxText: uo, updateJsxText: uu, createJsxOpeningFragment: cs, createJsxJsxClosingFragment: lu, updateJsxFragment: m_, createJsxAttribute: Ia, updateJsxAttribute: cc, createJsxAttributes: g_, updateJsxAttributes: us, createJsxSpreadAttribute: uc, updateJsxSpreadAttribute: y_, createJsxExpression: Oa, updateJsxExpression: Ma, createCaseClause: ls, updateCaseClause: ps, createDefaultClause: h_, updateDefaultClause: Fo, createHeritageClause: Va, updateHeritageClause: pu, createCatchClause: v_, updateCatchClause: lc, createPropertyAssignment: fs, updatePropertyAssignment: pc, createShorthandPropertyAssignment: fc, updateShorthandPropertyAssignment: fu, createSpreadAssignment: ya, updateSpreadAssignment: dc, createEnumMember: po, updateEnumMember: mu, createSourceFile: Wa, updateSourceFile: mc, createBundle: gc, updateBundle: yc, createUnparsedSource: hc, createUnparsedPrologue: ms, createUnparsedPrepend: gu, createUnparsedTextLike: gs, createUnparsedSyntheticReference: vc, createInputFiles: yu, createSyntheticExpression: ys, createSyntaxList: bc, createNotEmittedStatement: hu, createPartiallyEmittedExpression: Ec, updatePartiallyEmittedExpression: Tc, createCommaListExpression: b_, updateCommaListExpression: Cc, createEndOfDeclarationMarker: Dc, createMergeDeclarationMarker: xc, createSyntheticReferenceExpression: Ka, updateSyntheticReferenceExpression: fo, cloneNode: hs, get createComma() {
                return Re(27);
              }, get createAssignment() {
                return Re(63);
              }, get createLogicalOr() {
                return Re(56);
              }, get createLogicalAnd() {
                return Re(55);
              }, get createBitwiseOr() {
                return Re(51);
              }, get createBitwiseXor() {
                return Re(52);
              }, get createBitwiseAnd() {
                return Re(50);
              }, get createStrictEquality() {
                return Re(36);
              }, get createStrictInequality() {
                return Re(37);
              }, get createEquality() {
                return Re(34);
              }, get createInequality() {
                return Re(35);
              }, get createLessThan() {
                return Re(29);
              }, get createLessThanEquals() {
                return Re(32);
              }, get createGreaterThan() {
                return Re(31);
              }, get createGreaterThanEquals() {
                return Re(33);
              }, get createLeftShift() {
                return Re(47);
              }, get createRightShift() {
                return Re(48);
              }, get createUnsignedRightShift() {
                return Re(49);
              }, get createAdd() {
                return Re(39);
              }, get createSubtract() {
                return Re(40);
              }, get createMultiply() {
                return Re(41);
              }, get createDivide() {
                return Re(43);
              }, get createModulo() {
                return Re(44);
              }, get createExponent() {
                return Re(42);
              }, get createPrefixPlus() {
                return Fe(39);
              }, get createPrefixMinus() {
                return Fe(40);
              }, get createPrefixIncrement() {
                return Fe(45);
              }, get createPrefixDecrement() {
                return Fe(46);
              }, get createBitwiseNot() {
                return Fe(54);
              }, get createLogicalNot() {
                return Fe(53);
              }, get createPostfixIncrement() {
                return dr(45);
              }, get createPostfixDecrement() {
                return dr(46);
              }, createImmediatelyInvokedFunctionExpression: wc, createImmediatelyInvokedArrowFunction: vu, createVoidZero: vs, createExportDefault: bu, createExternalModuleExport: Eu, createTypeCheck: E_, createMethodCall: Ha, createGlobalMethodCall: bs, createFunctionBindCall: Ac, createFunctionCallCall: Tu, createFunctionApplyCall: Su, createArraySliceCall: Cu, createArrayConcatCall: Es, createObjectDefinePropertyCall: kc, createReflectGetCall: La, createReflectSetCall: Du, createPropertyDescriptor: Pc, createCallBinding: Oc, createAssignmentTargetWrapper: d, inlineExpressions: P, getInternalName: ce, getLocalName: Pe, getExportName: We, getDeclarationName: Er, getNamespaceMemberName: Rr, getExternalModuleOrNamespaceExportName: Fr, restoreOuterExpressions: Ic, restoreEnclosingLabel: Ts, createUseStrictPrologue: Gt, copyPrologue: et, copyStandardPrologue: Wt, copyCustomPrologue: pn, ensureUseStrict: Pn, liftToBlock: _i, mergeLexicalEnvironment: ha, updateModifiers: Di };
              return Ee;
              function we(i, o) {
                if (i === void 0 || i === e.emptyArray)
                  i = [];
                else if (e.isNodeArray(i)) {
                  if (o === void 0 || i.hasTrailingComma === o)
                    return i.transformFlags === void 0 && je(i), e.Debug.attachNodeArrayDebugInfo(i), i;
                  var u = i.slice();
                  return u.pos = i.pos, u.end = i.end, u.hasTrailingComma = o, u.transformFlags = i.transformFlags, e.Debug.attachNodeArrayDebugInfo(u), u;
                }
                var b = i.length, Y = b >= 1 && b <= 4 ? i.slice() : i;
                return e.setTextRangePosEnd(Y, -1, -1), Y.hasTrailingComma = !!o, je(Y), e.Debug.attachNodeArrayDebugInfo(Y), Y;
              }
              __name(we, "we");
              function he(i) {
                return pe.createBaseNode(i);
              }
              __name(he, "he");
              function yr(i) {
                var o = he(i);
                return o.symbol = void 0, o.localSymbol = void 0, o.locals = void 0, o.nextContainer = void 0, o;
              }
              __name(yr, "yr");
              function kr(i, o, u) {
                var b = yr(i);
                if (u = Pi(u), b.name = u, e.canHaveModifiers(b) && (b.modifiers = Xn(o), b.transformFlags |= Be(b.modifiers)), u)
                  switch (b.kind) {
                    case 171:
                    case 174:
                    case 175:
                    case 169:
                    case 299:
                      if (e.isIdentifier(u)) {
                        b.transformFlags |= se(u);
                        break;
                      }
                    default:
                      b.transformFlags |= Q(u);
                      break;
                  }
                return b;
              }
              __name(kr, "kr");
              function nr(i, o, u, b) {
                var Y = kr(i, o, u);
                return Y.typeParameters = Xn(b), Y.transformFlags |= Be(Y.typeParameters), b && (Y.transformFlags |= 1), Y;
              }
              __name(nr, "nr");
              function tr(i, o, u, b, Y, Ke) {
                var Or = nr(i, o, u, b);
                return Or.parameters = we(Y), Or.type = Ke, Or.transformFlags |= Be(Or.parameters) | Q(Or.type), Ke && (Or.transformFlags |= 1), Or.typeArguments = void 0, Or;
              }
              __name(tr, "tr");
              function Lr(i, o) {
                return i !== o && (i.typeArguments = o.typeArguments), j(i, o);
              }
              __name(Lr, "Lr");
              function zr(i, o, u, b, Y, Ke, Or) {
                var kt = tr(i, o, u, b, Y, Ke);
                return kt.body = Or, kt.transformFlags |= Q(kt.body) & -67108865, Or || (kt.transformFlags |= 1), kt;
              }
              __name(zr, "zr");
              function ye(i, o, u, b, Y) {
                var Ke = nr(i, o, u, b);
                return Ke.heritageClauses = Xn(Y), Ke.transformFlags |= Be(Ke.heritageClauses), Ke;
              }
              __name(ye, "ye");
              function ir(i, o, u, b, Y, Ke) {
                var Or = ye(i, o, u, b, Y);
                return Or.members = we(Ke), Or.transformFlags |= Be(Or.members), Or;
              }
              __name(ir, "ir");
              function Dr(i, o, u, b) {
                var Y = kr(i, o, u);
                return Y.initializer = b, Y.transformFlags |= Q(Y.initializer), Y;
              }
              __name(Dr, "Dr");
              function Pr(i, o, u, b, Y) {
                var Ke = Dr(i, o, u, Y);
                return Ke.type = b, Ke.transformFlags |= Q(b), b && (Ke.transformFlags |= 1), Ke;
              }
              __name(Pr, "Pr");
              function Br(i, o) {
                var u = nt(i);
                return u.text = o, u;
              }
              __name(Br, "Br");
              function ut(i, o) {
                o === void 0 && (o = 0);
                var u = Br(8, typeof i == "number" ? i + "" : i);
                return u.numericLiteralFlags = o, o & 384 && (u.transformFlags |= 1024), u;
              }
              __name(ut, "ut");
              function rt(i) {
                var o = Br(9, typeof i == "string" ? i : e.pseudoBigIntToString(i) + "n");
                return o.transformFlags |= 4, o;
              }
              __name(rt, "rt");
              function Z(i, o) {
                var u = Br(10, i);
                return u.singleQuote = o, u;
              }
              __name(Z, "Z");
              function f(i, o, u) {
                var b = Z(i, o);
                return b.hasExtendedUnicodeEscape = u, u && (b.transformFlags |= 1024), b;
              }
              __name(f, "f");
              function h(i) {
                var o = Z(e.getTextOfIdentifierOrLiteral(i), void 0);
                return o.textSourceNode = i, o;
              }
              __name(h, "h");
              function ae(i) {
                var o = Br(13, i);
                return o;
              }
              __name(ae, "ae");
              function xr(i, o) {
                switch (i) {
                  case 8:
                    return ut(o, 0);
                  case 9:
                    return rt(o);
                  case 10:
                    return f(o, void 0);
                  case 11:
                    return uo(o, false);
                  case 12:
                    return uo(o, true);
                  case 13:
                    return ae(o);
                  case 14:
                    return yo(i, o, void 0, 0);
                }
              }
              __name(xr, "xr");
              function jr(i, o) {
                o === void 0 && i && (o = e.stringToToken(i)), o === 79 && (o = void 0);
                var u = pe.createBaseIdentifierNode(79);
                return u.originalKeywordKind = o, u.escapedText = e.escapeLeadingUnderscores(i), u;
              }
              __name(jr, "jr");
              function qr(i, o, u, b) {
                var Y = jr(i, void 0);
                return Y.autoGenerateFlags = o, Y.autoGenerateId = t, Y.autoGeneratePrefix = u, Y.autoGenerateSuffix = b, t++, Y;
              }
              __name(qr, "qr");
              function pt(i, o, u, b) {
                var Y = jr(i, u);
                return o && (Y.typeArguments = we(o)), Y.originalKeywordKind === 133 && (Y.transformFlags |= 67108864), b && (Y.hasExtendedUnicodeEscape = b, Y.transformFlags |= 1024), Y;
              }
              __name(pt, "pt");
              function Ge(i, o) {
                return i.typeArguments !== o ? j(pt(e.idText(i), o), i) : i;
              }
              __name(Ge, "Ge");
              function K(i, o, u, b) {
                var Y = 1;
                o && (Y |= 8);
                var Ke = qr("", Y, u, b);
                return i && i(Ke), Ke;
              }
              __name(K, "K");
              function r(i) {
                var o = 2;
                return i && (o |= 8), qr("", o, void 0, void 0);
              }
              __name(r, "r");
              function ct(i, o, u, b) {
                return o === void 0 && (o = 0), e.Debug.assert(!(o & 7), "Argument out of range: flags"), e.Debug.assert((o & 48) !== 32, "GeneratedIdentifierFlags.FileLevel cannot be set without also setting GeneratedIdentifierFlags.Optimistic"), qr(i, 3 | o, u, b);
              }
              __name(ct, "ct");
              function ft(i, o, u, b) {
                o === void 0 && (o = 0), e.Debug.assert(!(o & 7), "Argument out of range: flags");
                var Y = i ? e.isMemberName(i) ? e.formatGeneratedName(false, u, i, b, e.idText) : "generated@".concat(e.getNodeId(i)) : "";
                (u || b) && (o |= 16);
                var Ke = qr(Y, 4 | o, u, b);
                return Ke.original = i, Ke;
              }
              __name(ft, "ft");
              function Ie(i) {
                var o = pe.createBasePrivateIdentifierNode(80);
                return o.escapedText = e.escapeLeadingUnderscores(i), o.transformFlags |= 16777216, o;
              }
              __name(Ie, "Ie");
              function me(i) {
                return e.startsWith(i, "#") || e.Debug.fail("First character of private identifier must be #: " + i), Ie(i);
              }
              __name(me, "me");
              function xe(i, o, u, b) {
                var Y = Ie(i);
                return Y.autoGenerateFlags = o, Y.autoGenerateId = t, Y.autoGeneratePrefix = u, Y.autoGenerateSuffix = b, t++, Y;
              }
              __name(xe, "xe");
              function Ye(i, o, u) {
                i && !e.startsWith(i, "#") && e.Debug.fail("First character of private identifier must be #: " + i);
                var b = 8 | (i ? 3 : 1);
                return xe(i != null ? i : "", b, o, u);
              }
              __name(Ye, "Ye");
              function vr(i, o, u) {
                var b = e.isMemberName(i) ? e.formatGeneratedName(true, o, i, u, e.idText) : "#generated@".concat(e.getNodeId(i)), Y = o || u ? 16 : 0, Ke = xe(b, 4 | Y, o, u);
                return Ke.original = i, Ke;
              }
              __name(vr, "vr");
              function nt(i) {
                return pe.createBaseTokenNode(i);
              }
              __name(nt, "nt");
              function pr(i) {
                e.Debug.assert(i >= 0 && i <= 162, "Invalid token"), e.Debug.assert(i <= 14 || i >= 17, "Invalid token. Use 'createTemplateLiteralLikeNode' to create template literals."), e.Debug.assert(i <= 8 || i >= 14, "Invalid token. Use 'createLiteralLikeNode' to create literals."), e.Debug.assert(i !== 79, "Invalid token. Use 'createIdentifier' to create identifiers");
                var o = nt(i), u = 0;
                switch (i) {
                  case 132:
                    u = 384;
                    break;
                  case 123:
                  case 121:
                  case 122:
                  case 146:
                  case 126:
                  case 136:
                  case 85:
                  case 131:
                  case 148:
                  case 160:
                  case 144:
                  case 149:
                  case 101:
                  case 145:
                  case 161:
                  case 152:
                  case 134:
                  case 153:
                  case 114:
                  case 157:
                  case 155:
                    u = 1;
                    break;
                  case 106:
                    u = 134218752;
                    break;
                  case 124:
                    u = 1024;
                    break;
                  case 127:
                    u = 16777216;
                    break;
                  case 108:
                    u = 16384;
                    break;
                }
                return u && (o.transformFlags |= u), o;
              }
              __name(pr, "pr");
              function Mr() {
                return pr(106);
              }
              __name(Mr, "Mr");
              function ot() {
                return pr(108);
              }
              __name(ot, "ot");
              function At() {
                return pr(104);
              }
              __name(At, "At");
              function re() {
                return pr(110);
              }
              __name(re, "re");
              function de() {
                return pr(95);
              }
              __name(de, "de");
              function He(i) {
                return pr(i);
              }
              __name(He, "He");
              function Nr(i) {
                var o = [];
                return i & 1 && o.push(He(93)), i & 2 && o.push(He(136)), i & 1024 && o.push(He(88)), i & 2048 && o.push(He(85)), i & 4 && o.push(He(123)), i & 8 && o.push(He(121)), i & 16 && o.push(He(122)), i & 256 && o.push(He(126)), i & 32 && o.push(He(124)), i & 16384 && o.push(He(161)), i & 64 && o.push(He(146)), i & 128 && o.push(He(127)), i & 512 && o.push(He(132)), i & 32768 && o.push(He(101)), i & 65536 && o.push(He(145)), o.length ? o : void 0;
              }
              __name(Nr, "Nr");
              function Yr(i, o) {
                var u = he(163);
                return u.left = i, u.right = Pi(o), u.transformFlags |= Q(u.left) | se(u.right), u;
              }
              __name(Yr, "Yr");
              function St(i, o, u) {
                return i.left !== o || i.right !== u ? j(Yr(o, u), i) : i;
              }
              __name(St, "St");
              function Dt(i) {
                var o = he(164);
                return o.expression = be().parenthesizeExpressionOfComputedPropertyName(i), o.transformFlags |= Q(o.expression) | 1024 | 131072, o;
              }
              __name(Dt, "Dt");
              function Lt(i, o) {
                return i.expression !== o ? j(Dt(o), i) : i;
              }
              __name(Lt, "Lt");
              function zt(i, o, u, b) {
                var Y = kr(165, i, o);
                return Y.constraint = u, Y.default = b, Y.transformFlags = 1, Y;
              }
              __name(zt, "zt");
              function Zt(i, o, u, b, Y) {
                return i.modifiers !== o || i.name !== u || i.constraint !== b || i.default !== Y ? j(zt(o, u, b, Y), i) : i;
              }
              __name(Zt, "Zt");
              function mt(i, o, u, b, Y, Ke) {
                var Or = Pr(166, i, u, Y, Ke && be().parenthesizeExpressionForDisallowedComma(Ke));
                return Or.dotDotDotToken = o, Or.questionToken = b, e.isThisIdentifier(Or.name) ? Or.transformFlags = 1 : (Or.transformFlags |= Q(Or.dotDotDotToken) | Q(Or.questionToken), b && (Or.transformFlags |= 1), e.modifiersToFlags(Or.modifiers) & 16476 && (Or.transformFlags |= 8192), (Ke || o) && (Or.transformFlags |= 1024)), Or;
              }
              __name(mt, "mt");
              function at(i, o, u, b, Y, Ke, Or) {
                return i.modifiers !== o || i.dotDotDotToken !== u || i.name !== b || i.questionToken !== Y || i.type !== Ke || i.initializer !== Or ? j(mt(o, u, b, Y, Ke, Or), i) : i;
              }
              __name(at, "at");
              function k(i) {
                var o = he(167);
                return o.expression = be().parenthesizeLeftSideOfAccess(i, false), o.transformFlags |= Q(o.expression) | 1 | 8192 | 33554432, o;
              }
              __name(k, "k");
              function ue(i, o) {
                return i.expression !== o ? j(k(o), i) : i;
              }
              __name(ue, "ue");
              function Qe(i, o, u, b) {
                var Y = kr(168, i, o);
                return Y.type = b, Y.questionToken = u, Y.transformFlags = 1, Y.initializer = void 0, Y;
              }
              __name(Qe, "Qe");
              function Sr(i, o, u, b, Y) {
                return i.modifiers !== o || i.name !== u || i.questionToken !== b || i.type !== Y ? Kr(Qe(o, u, b, Y), i) : i;
              }
              __name(Sr, "Sr");
              function Kr(i, o) {
                return i !== o && (i.initializer = o.initializer), j(i, o);
              }
              __name(Kr, "Kr");
              function Hr(i, o, u, b, Y) {
                var Ke = Pr(169, i, o, b, Y);
                return Ke.questionToken = u && e.isQuestionToken(u) ? u : void 0, Ke.exclamationToken = u && e.isExclamationToken(u) ? u : void 0, Ke.transformFlags |= Q(Ke.questionToken) | Q(Ke.exclamationToken) | 16777216, (e.isComputedPropertyName(Ke.name) || e.hasStaticModifier(Ke) && Ke.initializer) && (Ke.transformFlags |= 8192), (u || e.modifiersToFlags(Ke.modifiers) & 2) && (Ke.transformFlags |= 1), Ke;
              }
              __name(Hr, "Hr");
              function Ct(i, o, u, b, Y, Ke) {
                return i.modifiers !== o || i.name !== u || i.questionToken !== (b !== void 0 && e.isQuestionToken(b) ? b : void 0) || i.exclamationToken !== (b !== void 0 && e.isExclamationToken(b) ? b : void 0) || i.type !== Y || i.initializer !== Ke ? j(Hr(o, u, b, Y, Ke), i) : i;
              }
              __name(Ct, "Ct");
              function Xt(i, o, u, b, Y, Ke) {
                var Or = tr(170, i, o, b, Y, Ke);
                return Or.questionToken = u, Or.transformFlags = 1, Or;
              }
              __name(Xt, "Xt");
              function cn(i, o, u, b, Y, Ke, Or) {
                return i.modifiers !== o || i.name !== u || i.questionToken !== b || i.typeParameters !== Y || i.parameters !== Ke || i.type !== Or ? Lr(Xt(o, u, b, Y, Ke, Or), i) : i;
              }
              __name(cn, "cn");
              function In(i, o, u, b, Y, Ke, Or, kt) {
                var $n = zr(171, i, u, Y, Ke, Or, kt);
                return $n.asteriskToken = o, $n.questionToken = b, $n.transformFlags |= Q($n.asteriskToken) | Q($n.questionToken) | 1024, b && ($n.transformFlags |= 1), e.modifiersToFlags($n.modifiers) & 512 ? o ? $n.transformFlags |= 128 : $n.transformFlags |= 256 : o && ($n.transformFlags |= 2048), $n.exclamationToken = void 0, $n;
              }
              __name(In, "In");
              function yn(i, o, u, b, Y, Ke, Or, kt, $n) {
                return i.modifiers !== o || i.asteriskToken !== u || i.name !== b || i.questionToken !== Y || i.typeParameters !== Ke || i.parameters !== Or || i.type !== kt || i.body !== $n ? hn(In(o, u, b, Y, Ke, Or, kt, $n), i) : i;
              }
              __name(yn, "yn");
              function hn(i, o) {
                return i !== o && (i.exclamationToken = o.exclamationToken), j(i, o);
              }
              __name(hn, "hn");
              function ln(i) {
                var o = nr(172, void 0, void 0, void 0);
                return o.body = i, o.transformFlags = Q(i) | 16777216, o.illegalDecorators = void 0, o.modifiers = void 0, o;
              }
              __name(ln, "ln");
              function En(i, o) {
                return i.body !== o ? Vt(ln(o), i) : i;
              }
              __name(En, "En");
              function Vt(i, o) {
                return i !== o && (i.illegalDecorators = o.illegalDecorators, i.modifiers = o.modifiers), j(i, o);
              }
              __name(Vt, "Vt");
              function ui(i, o, u) {
                var b = zr(173, i, void 0, void 0, o, void 0, u);
                return b.transformFlags |= 1024, b.illegalDecorators = void 0, b.typeParameters = void 0, b.type = void 0, b;
              }
              __name(ui, "ui");
              function ei(i, o, u, b) {
                return i.modifiers !== o || i.parameters !== u || i.body !== b ? vi(ui(o, u, b), i) : i;
              }
              __name(ei, "ei");
              function vi(i, o) {
                return i !== o && (i.illegalDecorators = o.illegalDecorators, i.typeParameters = o.typeParameters, i.type = o.type), Lr(i, o);
              }
              __name(vi, "vi");
              function ri(i, o, u, b, Y) {
                var Ke = zr(174, i, o, void 0, u, b, Y);
                return Ke.typeParameters = void 0, Ke;
              }
              __name(ri, "ri");
              function bi(i, o, u, b, Y, Ke) {
                return i.modifiers !== o || i.name !== u || i.parameters !== b || i.type !== Y || i.body !== Ke ? Qn(ri(o, u, b, Y, Ke), i) : i;
              }
              __name(bi, "bi");
              function Qn(i, o) {
                return i !== o && (i.typeParameters = o.typeParameters), Lr(i, o);
              }
              __name(Qn, "Qn");
              function Yn(i, o, u, b) {
                var Y = zr(175, i, o, void 0, u, void 0, b);
                return Y.typeParameters = void 0, Y.type = void 0, Y;
              }
              __name(Yn, "Yn");
              function oi(i, o, u, b, Y) {
                return i.modifiers !== o || i.name !== u || i.parameters !== b || i.body !== Y ? Ei(Yn(o, u, b, Y), i) : i;
              }
              __name(oi, "oi");
              function Ei(i, o) {
                return i !== o && (i.typeParameters = o.typeParameters, i.type = o.type), Lr(i, o);
              }
              __name(Ei, "Ei");
              function Dn(i, o, u) {
                var b = tr(176, void 0, void 0, i, o, u);
                return b.transformFlags = 1, b;
              }
              __name(Dn, "Dn");
              function Kn(i, o, u, b) {
                return i.typeParameters !== o || i.parameters !== u || i.type !== b ? Lr(Dn(o, u, b), i) : i;
              }
              __name(Kn, "Kn");
              function si(i, o, u) {
                var b = tr(177, void 0, void 0, i, o, u);
                return b.transformFlags = 1, b;
              }
              __name(si, "si");
              function mi(i, o, u, b) {
                return i.typeParameters !== o || i.parameters !== u || i.type !== b ? Lr(si(o, u, b), i) : i;
              }
              __name(mi, "mi");
              function Zn(i, o, u) {
                var b = tr(178, i, void 0, void 0, o, u);
                return b.transformFlags = 1, b;
              }
              __name(Zn, "Zn");
              function Fn(i, o, u, b) {
                return i.parameters !== u || i.type !== b || i.modifiers !== o ? Lr(Zn(o, u, b), i) : i;
              }
              __name(Fn, "Fn");
              function gt(i, o) {
                var u = he(201);
                return u.type = i, u.literal = o, u.transformFlags = 1, u;
              }
              __name(gt, "gt");
              function gi(i, o, u) {
                return i.type !== o || i.literal !== u ? j(gt(o, u), i) : i;
              }
              __name(gi, "gi");
              function dn(i) {
                return pr(i);
              }
              __name(dn, "dn");
              function On(i, o, u) {
                var b = he(179);
                return b.assertsModifier = i, b.parameterName = Pi(o), b.type = u, b.transformFlags = 1, b;
              }
              __name(On, "On");
              function br(i, o, u, b) {
                return i.assertsModifier !== o || i.parameterName !== u || i.type !== b ? j(On(o, u, b), i) : i;
              }
              __name(br, "br");
              function Ae(i, o) {
                var u = he(180);
                return u.typeName = Pi(i), u.typeArguments = o && be().parenthesizeTypeArguments(we(o)), u.transformFlags = 1, u;
              }
              __name(Ae, "Ae");
              function ur(i, o, u) {
                return i.typeName !== o || i.typeArguments !== u ? j(Ae(o, u), i) : i;
              }
              __name(ur, "ur");
              function L(i, o, u) {
                var b = tr(181, void 0, void 0, i, o, u);
                return b.transformFlags = 1, b.modifiers = void 0, b;
              }
              __name(L, "L");
              function qt(i, o, u, b) {
                return i.typeParameters !== o || i.parameters !== u || i.type !== b ? nn(L(o, u, b), i) : i;
              }
              __name(qt, "qt");
              function nn(i, o) {
                return i !== o && (i.modifiers = o.modifiers), Lr(i, o);
              }
              __name(nn, "nn");
              function fr() {
                for (var i = [], o = 0; o < arguments.length; o++)
                  i[o] = arguments[o];
                return i.length === 4 ? Me.apply(void 0, i) : i.length === 3 ? Ve.apply(void 0, i) : e.Debug.fail("Incorrect number of arguments specified.");
              }
              __name(fr, "fr");
              function Me(i, o, u, b) {
                var Y = tr(182, i, void 0, o, u, b);
                return Y.transformFlags = 1, Y;
              }
              __name(Me, "Me");
              function Ve(i, o, u) {
                return Me(void 0, i, o, u);
              }
              __name(Ve, "Ve");
              function _r() {
                for (var i = [], o = 0; o < arguments.length; o++)
                  i[o] = arguments[o];
                return i.length === 5 ? lr.apply(void 0, i) : i.length === 4 ? Vr.apply(void 0, i) : e.Debug.fail("Incorrect number of arguments specified.");
              }
              __name(_r, "_r");
              function lr(i, o, u, b, Y) {
                return i.modifiers !== o || i.typeParameters !== u || i.parameters !== b || i.type !== Y ? Lr(fr(o, u, b, Y), i) : i;
              }
              __name(lr, "lr");
              function Vr(i, o, u, b) {
                return lr(i, i.modifiers, o, u, b);
              }
              __name(Vr, "Vr");
              function tt(i, o) {
                var u = he(183);
                return u.exprName = i, u.typeArguments = o && be().parenthesizeTypeArguments(o), u.transformFlags = 1, u;
              }
              __name(tt, "tt");
              function dt(i, o, u) {
                return i.exprName !== o || i.typeArguments !== u ? j(tt(o, u), i) : i;
              }
              __name(dt, "dt");
              function It(i) {
                var o = he(184);
                return o.members = we(i), o.transformFlags = 1, o;
              }
              __name(It, "It");
              function an(i, o) {
                return i.members !== o ? j(It(o), i) : i;
              }
              __name(an, "an");
              function sn(i) {
                var o = he(185);
                return o.elementType = be().parenthesizeNonArrayTypeOfPostfixType(i), o.transformFlags = 1, o;
              }
              __name(sn, "sn");
              function _e(i, o) {
                return i.elementType !== o ? j(sn(o), i) : i;
              }
              __name(_e, "_e");
              function Gr(i) {
                var o = he(186);
                return o.elements = we(be().parenthesizeElementTypesOfTupleType(i)), o.transformFlags = 1, o;
              }
              __name(Gr, "Gr");
              function Kt(i, o) {
                return i.elements !== o ? j(Gr(o), i) : i;
              }
              __name(Kt, "Kt");
              function en(i, o, u, b) {
                var Y = he(199);
                return Y.dotDotDotToken = i, Y.name = o, Y.questionToken = u, Y.type = b, Y.transformFlags = 1, Y;
              }
              __name(en, "en");
              function Ot(i, o, u, b, Y) {
                return i.dotDotDotToken !== o || i.name !== u || i.questionToken !== b || i.type !== Y ? j(en(o, u, b, Y), i) : i;
              }
              __name(Ot, "Ot");
              function rr(i) {
                var o = he(187);
                return o.type = be().parenthesizeTypeOfOptionalType(i), o.transformFlags = 1, o;
              }
              __name(rr, "rr");
              function Hn(i, o) {
                return i.type !== o ? j(rr(o), i) : i;
              }
              __name(Hn, "Hn");
              function rn(i) {
                var o = he(188);
                return o.type = i, o.transformFlags = 1, o;
              }
              __name(rn, "rn");
              function xn(i, o) {
                return i.type !== o ? j(rn(o), i) : i;
              }
              __name(xn, "xn");
              function Mn(i, o, u) {
                var b = he(i);
                return b.types = Ee.createNodeArray(u(o)), b.transformFlags = 1, b;
              }
              __name(Mn, "Mn");
              function Rn(i, o, u) {
                return i.types !== o ? j(Mn(i.kind, o, u), i) : i;
              }
              __name(Rn, "Rn");
              function kn(i) {
                return Mn(189, i, be().parenthesizeConstituentTypesOfUnionType);
              }
              __name(kn, "kn");
              function on(i, o) {
                return Rn(i, o, be().parenthesizeConstituentTypesOfUnionType);
              }
              __name(on, "on");
              function Xr(i) {
                return Mn(190, i, be().parenthesizeConstituentTypesOfIntersectionType);
              }
              __name(Xr, "Xr");
              function wr(i, o) {
                return Rn(i, o, be().parenthesizeConstituentTypesOfIntersectionType);
              }
              __name(wr, "wr");
              function fn(i, o, u, b) {
                var Y = he(191);
                return Y.checkType = be().parenthesizeCheckTypeOfConditionalType(i), Y.extendsType = be().parenthesizeExtendsTypeOfConditionalType(o), Y.trueType = u, Y.falseType = b, Y.transformFlags = 1, Y;
              }
              __name(fn, "fn");
              function mn(i, o, u, b, Y) {
                return i.checkType !== o || i.extendsType !== u || i.trueType !== b || i.falseType !== Y ? j(fn(o, u, b, Y), i) : i;
              }
              __name(mn, "mn");
              function Li(i) {
                var o = he(192);
                return o.typeParameter = i, o.transformFlags = 1, o;
              }
              __name(Li, "Li");
              function An(i, o) {
                return i.typeParameter !== o ? j(Li(o), i) : i;
              }
              __name(An, "An");
              function wi(i, o) {
                var u = he(200);
                return u.head = i, u.templateSpans = we(o), u.transformFlags = 1, u;
              }
              __name(wi, "wi");
              function ti(i, o, u) {
                return i.head !== o || i.templateSpans !== u ? j(wi(o, u), i) : i;
              }
              __name(ti, "ti");
              function li(i, o, u, b, Y) {
                Y === void 0 && (Y = false);
                var Ke = he(202);
                return Ke.argument = i, Ke.assertions = o, Ke.qualifier = u, Ke.typeArguments = b && be().parenthesizeTypeArguments(b), Ke.isTypeOf = Y, Ke.transformFlags = 1, Ke;
              }
              __name(li, "li");
              function Bn(i, o, u, b, Y, Ke) {
                return Ke === void 0 && (Ke = i.isTypeOf), i.argument !== o || i.assertions !== u || i.qualifier !== b || i.typeArguments !== Y || i.isTypeOf !== Ke ? j(li(o, u, b, Y, Ke), i) : i;
              }
              __name(Bn, "Bn");
              function vn(i) {
                var o = he(193);
                return o.type = i, o.transformFlags = 1, o;
              }
              __name(vn, "vn");
              function Ue(i, o) {
                return i.type !== o ? j(vn(o), i) : i;
              }
              __name(Ue, "Ue");
              function Vn() {
                var i = he(194);
                return i.transformFlags = 1, i;
              }
              __name(Vn, "Vn");
              function Ti(i, o) {
                var u = he(195);
                return u.operator = i, u.type = i === 146 ? be().parenthesizeOperandOfReadonlyTypeOperator(o) : be().parenthesizeOperandOfTypeOperator(o), u.transformFlags = 1, u;
              }
              __name(Ti, "Ti");
              function ni(i, o) {
                return i.type !== o ? j(Ti(i.operator, o), i) : i;
              }
              __name(ni, "ni");
              function Bi(i, o) {
                var u = he(196);
                return u.objectType = be().parenthesizeNonArrayTypeOfPostfixType(i), u.indexType = o, u.transformFlags = 1, u;
              }
              __name(Bi, "Bi");
              function Tn(i, o, u) {
                return i.objectType !== o || i.indexType !== u ? j(Bi(o, u), i) : i;
              }
              __name(Tn, "Tn");
              function jn(i, o, u, b, Y, Ke) {
                var Or = he(197);
                return Or.readonlyToken = i, Or.typeParameter = o, Or.nameType = u, Or.questionToken = b, Or.type = Y, Or.members = Ke && we(Ke), Or.transformFlags = 1, Or;
              }
              __name(jn, "jn");
              function Si(i, o, u, b, Y, Ke, Or) {
                return i.readonlyToken !== o || i.typeParameter !== u || i.nameType !== b || i.questionToken !== Y || i.type !== Ke || i.members !== Or ? j(jn(o, u, b, Y, Ke, Or), i) : i;
              }
              __name(Si, "Si");
              function Ci(i) {
                var o = he(198);
                return o.literal = i, o.transformFlags = 1, o;
              }
              __name(Ci, "Ci");
              function C(i, o) {
                return i.literal !== o ? j(Ci(o), i) : i;
              }
              __name(C, "C");
              function V(i) {
                var o = he(203);
                return o.elements = we(i), o.transformFlags |= Be(o.elements) | 1024 | 524288, o.transformFlags & 32768 && (o.transformFlags |= 65664), o;
              }
              __name(V, "V");
              function ee(i, o) {
                return i.elements !== o ? j(V(o), i) : i;
              }
              __name(ee, "ee");
              function le(i) {
                var o = he(204);
                return o.elements = we(i), o.transformFlags |= Be(o.elements) | 1024 | 524288, o;
              }
              __name(le, "le");
              function Ze(i, o) {
                return i.elements !== o ? j(le(o), i) : i;
              }
              __name(Ze, "Ze");
              function Ir(i, o, u, b) {
                var Y = Dr(205, void 0, u, b && be().parenthesizeExpressionForDisallowedComma(b));
                return Y.propertyName = Pi(o), Y.dotDotDotToken = i, Y.transformFlags |= Q(Y.dotDotDotToken) | 1024, Y.propertyName && (Y.transformFlags |= e.isIdentifier(Y.propertyName) ? se(Y.propertyName) : Q(Y.propertyName)), i && (Y.transformFlags |= 32768), Y;
              }
              __name(Ir, "Ir");
              function Ar(i, o, u, b, Y) {
                return i.propertyName !== u || i.dotDotDotToken !== o || i.name !== b || i.initializer !== Y ? j(Ir(o, u, b, Y), i) : i;
              }
              __name(Ar, "Ar");
              function hr(i) {
                var o = he(i);
                return o;
              }
              __name(hr, "hr");
              function yt(i, o) {
                var u = hr(206), b = i && e.lastOrUndefined(i), Y = we(i, b && e.isOmittedExpression(b) ? true : void 0);
                return u.elements = be().parenthesizeExpressionsOfCommaDelimitedList(Y), u.multiLine = o, u.transformFlags |= Be(u.elements), u;
              }
              __name(yt, "yt");
              function Pt(i, o) {
                return i.elements !== o ? j(yt(o, i.multiLine), i) : i;
              }
              __name(Pt, "Pt");
              function Ut(i, o) {
                var u = hr(207);
                return u.properties = we(i), u.multiLine = o, u.transformFlags |= Be(u.properties), u;
              }
              __name(Ut, "Ut");
              function jt(i, o) {
                return i.properties !== o ? j(Ut(o, i.multiLine), i) : i;
              }
              __name(jt, "jt");
              function Ht(i, o) {
                var u = hr(208);
                return u.expression = be().parenthesizeLeftSideOfAccess(i, false), u.name = Pi(o), u.transformFlags = Q(u.expression) | (e.isIdentifier(u.name) ? se(u.name) : Q(u.name) | 536870912), e.isSuperKeyword(i) && (u.transformFlags |= 384), u;
              }
              __name(Ht, "Ht");
              function yi(i, o, u) {
                return e.isPropertyAccessChain(i) ? Gn(i, o, i.questionDotToken, e.cast(u, e.isIdentifier)) : i.expression !== o || i.name !== u ? j(Ht(o, u), i) : i;
              }
              __name(yi, "yi");
              function Ni(i, o, u) {
                var b = hr(208);
                return b.flags |= 32, b.expression = be().parenthesizeLeftSideOfAccess(i, true), b.questionDotToken = o, b.name = Pi(u), b.transformFlags |= 32 | Q(b.expression) | Q(b.questionDotToken) | (e.isIdentifier(b.name) ? se(b.name) : Q(b.name) | 536870912), b;
              }
              __name(Ni, "Ni");
              function Gn(i, o, u, b) {
                return e.Debug.assert(!!(i.flags & 32), "Cannot update a PropertyAccessExpression using updatePropertyAccessChain. Use updatePropertyAccess instead."), i.expression !== o || i.questionDotToken !== u || i.name !== b ? j(Ni(o, u, b), i) : i;
              }
              __name(Gn, "Gn");
              function qi(i, o) {
                var u = hr(209);
                return u.expression = be().parenthesizeLeftSideOfAccess(i, false), u.argumentExpression = oa(o), u.transformFlags |= Q(u.expression) | Q(u.argumentExpression), e.isSuperKeyword(i) && (u.transformFlags |= 384), u;
              }
              __name(qi, "qi");
              function sa(i, o, u) {
                return e.isElementAccessChain(i) ? Hi(i, o, i.questionDotToken, u) : i.expression !== o || i.argumentExpression !== u ? j(qi(o, u), i) : i;
              }
              __name(sa, "sa");
              function ea(i, o, u) {
                var b = hr(209);
                return b.flags |= 32, b.expression = be().parenthesizeLeftSideOfAccess(i, true), b.questionDotToken = o, b.argumentExpression = oa(u), b.transformFlags |= Q(b.expression) | Q(b.questionDotToken) | Q(b.argumentExpression) | 32, b;
              }
              __name(ea, "ea");
              function Hi(i, o, u, b) {
                return e.Debug.assert(!!(i.flags & 32), "Cannot update a ElementAccessExpression using updateElementAccessChain. Use updateElementAccess instead."), i.expression !== o || i.questionDotToken !== u || i.argumentExpression !== b ? j(ea(o, u, b), i) : i;
              }
              __name(Hi, "Hi");
              function Ui(i, o, u) {
                var b = hr(210);
                return b.expression = be().parenthesizeLeftSideOfAccess(i, false), b.typeArguments = Xn(o), b.arguments = be().parenthesizeExpressionsOfCommaDelimitedList(we(u)), b.transformFlags |= Q(b.expression) | Be(b.typeArguments) | Be(b.arguments), b.typeArguments && (b.transformFlags |= 1), e.isImportKeyword(b.expression) ? b.transformFlags |= 8388608 : e.isSuperProperty(b.expression) && (b.transformFlags |= 16384), b;
              }
              __name(Ui, "Ui");
              function Gi(i, o, u, b) {
                return e.isCallChain(i) ? ma(i, o, i.questionDotToken, u, b) : i.expression !== o || i.typeArguments !== u || i.arguments !== b ? j(Ui(o, u, b), i) : i;
              }
              __name(Gi, "Gi");
              function Xi(i, o, u, b) {
                var Y = hr(210);
                return Y.flags |= 32, Y.expression = be().parenthesizeLeftSideOfAccess(i, true), Y.questionDotToken = o, Y.typeArguments = Xn(u), Y.arguments = be().parenthesizeExpressionsOfCommaDelimitedList(we(b)), Y.transformFlags |= Q(Y.expression) | Q(Y.questionDotToken) | Be(Y.typeArguments) | Be(Y.arguments) | 32, Y.typeArguments && (Y.transformFlags |= 1), e.isSuperProperty(Y.expression) && (Y.transformFlags |= 16384), Y;
              }
              __name(Xi, "Xi");
              function ma(i, o, u, b, Y) {
                return e.Debug.assert(!!(i.flags & 32), "Cannot update a CallExpression using updateCallChain. Use updateCall instead."), i.expression !== o || i.questionDotToken !== u || i.typeArguments !== b || i.arguments !== Y ? j(Xi(o, u, b, Y), i) : i;
              }
              __name(ma, "ma");
              function Jn(i, o, u) {
                var b = hr(211);
                return b.expression = be().parenthesizeExpressionOfNew(i), b.typeArguments = Xn(o), b.arguments = u ? be().parenthesizeExpressionsOfCommaDelimitedList(u) : void 0, b.transformFlags |= Q(b.expression) | Be(b.typeArguments) | Be(b.arguments) | 32, b.typeArguments && (b.transformFlags |= 1), b;
              }
              __name(Jn, "Jn");
              function ra(i, o, u, b) {
                return i.expression !== o || i.typeArguments !== u || i.arguments !== b ? j(Jn(o, u, b), i) : i;
              }
              __name(ra, "ra");
              function $i(i, o, u) {
                var b = hr(212);
                return b.tag = be().parenthesizeLeftSideOfAccess(i, false), b.typeArguments = Xn(o), b.template = u, b.transformFlags |= Q(b.tag) | Be(b.typeArguments) | Q(b.template) | 1024, b.typeArguments && (b.transformFlags |= 1), e.hasInvalidEscape(b.template) && (b.transformFlags |= 128), b;
              }
              __name($i, "$i");
              function _a(i, o, u, b) {
                return i.tag !== o || i.typeArguments !== u || i.template !== b ? j($i(o, u, b), i) : i;
              }
              __name(_a, "_a");
              function Ri(i, o) {
                var u = hr(213);
                return u.expression = be().parenthesizeOperandOfPrefixUnary(o), u.type = i, u.transformFlags |= Q(u.expression) | Q(u.type) | 1, u;
              }
              __name(Ri, "Ri");
              function p(i, o, u) {
                return i.type !== o || i.expression !== u ? j(Ri(o, u), i) : i;
              }
              __name(p, "p");
              function ne(i) {
                var o = hr(214);
                return o.expression = i, o.transformFlags = Q(o.expression), o;
              }
              __name(ne, "ne");
              function Ne(i, o) {
                return i.expression !== o ? j(ne(o), i) : i;
              }
              __name(Ne, "Ne");
              function or(i, o, u, b, Y, Ke, Or) {
                var kt = zr(215, i, u, b, Y, Ke, Or);
                return kt.asteriskToken = o, kt.transformFlags |= Q(kt.asteriskToken), kt.typeParameters && (kt.transformFlags |= 1), e.modifiersToFlags(kt.modifiers) & 512 ? kt.asteriskToken ? kt.transformFlags |= 128 : kt.transformFlags |= 256 : kt.asteriskToken && (kt.transformFlags |= 2048), kt;
              }
              __name(or, "or");
              function it(i, o, u, b, Y, Ke, Or, kt) {
                return i.name !== b || i.modifiers !== o || i.asteriskToken !== u || i.typeParameters !== Y || i.parameters !== Ke || i.type !== Or || i.body !== kt ? Lr(or(o, u, b, Y, Ke, Or, kt), i) : i;
              }
              __name(it, "it");
              function vt(i, o, u, b, Y, Ke) {
                var Or = zr(216, i, void 0, o, u, b, be().parenthesizeConciseBodyOfArrowFunction(Ke));
                return Or.equalsGreaterThanToken = Y != null ? Y : pr(38), Or.transformFlags |= Q(Or.equalsGreaterThanToken) | 1024, e.modifiersToFlags(Or.modifiers) & 512 && (Or.transformFlags |= 16640), Or;
              }
              __name(vt, "vt");
              function Et(i, o, u, b, Y, Ke, Or) {
                return i.modifiers !== o || i.typeParameters !== u || i.parameters !== b || i.type !== Y || i.equalsGreaterThanToken !== Ke || i.body !== Or ? Lr(vt(o, u, b, Y, Ke, Or), i) : i;
              }
              __name(Et, "Et");
              function Tt(i) {
                var o = hr(217);
                return o.expression = be().parenthesizeOperandOfPrefixUnary(i), o.transformFlags |= Q(o.expression), o;
              }
              __name(Tt, "Tt");
              function tn(i, o) {
                return i.expression !== o ? j(Tt(o), i) : i;
              }
              __name(tn, "tn");
              function Mt(i) {
                var o = hr(218);
                return o.expression = be().parenthesizeOperandOfPrefixUnary(i), o.transformFlags |= Q(o.expression), o;
              }
              __name(Mt, "Mt");
              function $t(i, o) {
                return i.expression !== o ? j(Mt(o), i) : i;
              }
              __name($t, "$t");
              function y(i) {
                var o = hr(219);
                return o.expression = be().parenthesizeOperandOfPrefixUnary(i), o.transformFlags |= Q(o.expression), o;
              }
              __name(y, "y");
              function De(i, o) {
                return i.expression !== o ? j(y(o), i) : i;
              }
              __name(De, "De");
              function R(i) {
                var o = hr(220);
                return o.expression = be().parenthesizeOperandOfPrefixUnary(i), o.transformFlags |= Q(o.expression) | 256 | 128 | 2097152, o;
              }
              __name(R, "R");
              function Jt(i, o) {
                return i.expression !== o ? j(R(o), i) : i;
              }
              __name(Jt, "Jt");
              function Qt(i, o) {
                var u = hr(221);
                return u.operator = i, u.operand = be().parenthesizeOperandOfPrefixUnary(o), u.transformFlags |= Q(u.operand), (i === 45 || i === 46) && e.isIdentifier(u.operand) && !e.isGeneratedIdentifier(u.operand) && !e.isLocalName(u.operand) && (u.transformFlags |= 268435456), u;
              }
              __name(Qt, "Qt");
              function qn(i, o) {
                return i.operand !== o ? j(Qt(i.operator, o), i) : i;
              }
              __name(qn, "qn");
              function Ii(i, o) {
                var u = hr(222);
                return u.operator = o, u.operand = be().parenthesizeOperandOfPostfixUnary(i), u.transformFlags |= Q(u.operand), e.isIdentifier(u.operand) && !e.isGeneratedIdentifier(u.operand) && !e.isLocalName(u.operand) && (u.transformFlags |= 268435456), u;
              }
              __name(Ii, "Ii");
              function ca(i, o) {
                return i.operand !== o ? j(Ii(o, i.operator), i) : i;
              }
              __name(ca, "ca");
              function ji(i, o, u) {
                var b = hr(223), Y = Xa(o), Ke = Y.kind;
                return b.left = be().parenthesizeLeftSideOfBinary(Ke, i), b.operatorToken = Y, b.right = be().parenthesizeRightSideOfBinary(Ke, b.left, u), b.transformFlags |= Q(b.left) | Q(b.operatorToken) | Q(b.right), Ke === 60 ? b.transformFlags |= 32 : Ke === 63 ? e.isObjectLiteralExpression(b.left) ? b.transformFlags |= 5248 | ua(b.left) : e.isArrayLiteralExpression(b.left) && (b.transformFlags |= 5120 | ua(b.left)) : Ke === 42 || Ke === 67 ? b.transformFlags |= 512 : e.isLogicalOrCoalescingAssignmentOperator(Ke) && (b.transformFlags |= 16), Ke === 101 && e.isPrivateIdentifier(b.left) && (b.transformFlags |= 536870912), b;
              }
              __name(ji, "ji");
              function ua(i) {
                if (i.transformFlags & 65536)
                  return 65536;
                if (i.transformFlags & 128)
                  for (var o = 0, u = e.getElementsOfBindingOrAssignmentPattern(i); o < u.length; o++) {
                    var b = u[o], Y = e.getTargetOfBindingOrAssignmentElement(b);
                    if (Y && e.isAssignmentPattern(Y)) {
                      if (Y.transformFlags & 65536)
                        return 65536;
                      if (Y.transformFlags & 128) {
                        var Ke = ua(Y);
                        if (Ke)
                          return Ke;
                      }
                    }
                  }
                return 0;
              }
              __name(ua, "ua");
              function Qi(i, o, u, b) {
                return i.left !== o || i.operatorToken !== u || i.right !== b ? j(ji(o, u, b), i) : i;
              }
              __name(Qi, "Qi");
              function ta(i, o, u, b, Y) {
                var Ke = hr(224);
                return Ke.condition = be().parenthesizeConditionOfConditionalExpression(i), Ke.questionToken = o != null ? o : pr(57), Ke.whenTrue = be().parenthesizeBranchOfConditionalExpression(u), Ke.colonToken = b != null ? b : pr(58), Ke.whenFalse = be().parenthesizeBranchOfConditionalExpression(Y), Ke.transformFlags |= Q(Ke.condition) | Q(Ke.questionToken) | Q(Ke.whenTrue) | Q(Ke.colonToken) | Q(Ke.whenFalse), Ke;
              }
              __name(ta, "ta");
              function Ta(i, o, u, b, Y, Ke) {
                return i.condition !== o || i.questionToken !== u || i.whenTrue !== b || i.colonToken !== Y || i.whenFalse !== Ke ? j(ta(o, u, b, Y, Ke), i) : i;
              }
              __name(Ta, "Ta");
              function zi(i, o) {
                var u = hr(225);
                return u.head = i, u.templateSpans = we(o), u.transformFlags |= Q(u.head) | Be(u.templateSpans) | 1024, u;
              }
              __name(zi, "zi");
              function Ji(i, o, u) {
                return i.head !== o || i.templateSpans !== u ? j(zi(o, u), i) : i;
              }
              __name(Ji, "Ji");
              function ga(i, o, u, b) {
                b === void 0 && (b = 0), e.Debug.assert(!(b & -2049), "Unsupported template flags.");
                var Y = void 0;
                if (u !== void 0 && u !== o && (Y = J(i, u), typeof Y == "object"))
                  return e.Debug.fail("Invalid raw text");
                if (o === void 0) {
                  if (Y === void 0)
                    return e.Debug.fail("Arguments 'text' and 'rawText' may not both be undefined.");
                  o = Y;
                } else
                  Y !== void 0 && e.Debug.assert(o === Y, "Expected argument 'text' to be the normalized (i.e. 'cooked') version of argument 'rawText'.");
                return yo(i, o, u, b);
              }
              __name(ga, "ga");
              function yo(i, o, u, b) {
                var Y = nt(i);
                return Y.text = o, Y.rawText = u, Y.templateFlags = b & 2048, Y.transformFlags |= 1024, Y.templateFlags && (Y.transformFlags |= 128), Y;
              }
              __name(yo, "yo");
              function Ns(i, o, u) {
                return ga(15, i, o, u);
              }
              __name(Ns, "Ns");
              function wa(i, o, u) {
                return ga(16, i, o, u);
              }
              __name(wa, "wa");
              function Wo(i, o, u) {
                return ga(17, i, o, u);
              }
              __name(Wo, "Wo");
              function Sa(i, o, u) {
                return ga(14, i, o, u);
              }
              __name(Sa, "Sa");
              function Fa(i, o) {
                e.Debug.assert(!i || !!o, "A `YieldExpression` with an asteriskToken must have an expression.");
                var u = hr(226);
                return u.expression = o && be().parenthesizeExpressionForDisallowedComma(o), u.asteriskToken = i, u.transformFlags |= Q(u.expression) | Q(u.asteriskToken) | 1024 | 128 | 1048576, u;
              }
              __name(Fa, "Fa");
              function ho(i, o, u) {
                return i.expression !== u || i.asteriskToken !== o ? j(Fa(o, u), i) : i;
              }
              __name(ho, "ho");
              function vo(i) {
                var o = hr(227);
                return o.expression = be().parenthesizeExpressionForDisallowedComma(i), o.transformFlags |= Q(o.expression) | 1024 | 32768, o;
              }
              __name(vo, "vo");
              function eo(i, o) {
                return i.expression !== o ? j(vo(o), i) : i;
              }
              __name(eo, "eo");
              function Aa(i, o, u, b, Y) {
                var Ke = ir(228, i, o, u, b, Y);
                return Ke.transformFlags |= 1024, Ke;
              }
              __name(Aa, "Aa");
              function bo(i, o, u, b, Y, Ke) {
                return i.modifiers !== o || i.name !== u || i.typeParameters !== b || i.heritageClauses !== Y || i.members !== Ke ? j(Aa(o, u, b, Y, Ke), i) : i;
              }
              __name(bo, "bo");
              function Is() {
                return hr(229);
              }
              __name(Is, "Is");
              function Eo(i, o) {
                var u = he(230);
                return u.expression = be().parenthesizeLeftSideOfAccess(i, false), u.typeArguments = o && be().parenthesizeTypeArguments(o), u.transformFlags |= Q(u.expression) | Be(u.typeArguments) | 1024, u;
              }
              __name(Eo, "Eo");
              function To(i, o, u) {
                return i.expression !== o || i.typeArguments !== u ? j(Eo(o, u), i) : i;
              }
              __name(To, "To");
              function ka(i, o) {
                var u = hr(231);
                return u.expression = i, u.type = o, u.transformFlags |= Q(u.expression) | Q(u.type) | 1, u;
              }
              __name(ka, "ka");
              function ro(i, o, u) {
                return i.expression !== o || i.type !== u ? j(ka(o, u), i) : i;
              }
              __name(ro, "ro");
              function Ko(i) {
                var o = hr(232);
                return o.expression = be().parenthesizeLeftSideOfAccess(i, false), o.transformFlags |= Q(o.expression) | 1, o;
              }
              __name(Ko, "Ko");
              function Oi(i, o) {
                return e.isNonNullChain(i) ? Co(i, o) : i.expression !== o ? j(Ko(o), i) : i;
              }
              __name(Oi, "Oi");
              function Ba(i, o) {
                var u = hr(235);
                return u.expression = i, u.type = o, u.transformFlags |= Q(u.expression) | Q(u.type) | 1, u;
              }
              __name(Ba, "Ba");
              function to(i, o, u) {
                return i.expression !== o || i.type !== u ? j(Ba(o, u), i) : i;
              }
              __name(to, "to");
              function So(i) {
                var o = hr(232);
                return o.flags |= 32, o.expression = be().parenthesizeLeftSideOfAccess(i, true), o.transformFlags |= Q(o.expression) | 1, o;
              }
              __name(So, "So");
              function Co(i, o) {
                return e.Debug.assert(!!(i.flags & 32), "Cannot update a NonNullExpression using updateNonNullChain. Use updateNonNullExpression instead."), i.expression !== o ? j(So(o), i) : i;
              }
              __name(Co, "Co");
              function Ho(i, o) {
                var u = hr(233);
                switch (u.keywordToken = i, u.name = o, u.transformFlags |= Q(u.name), i) {
                  case 103:
                    u.transformFlags |= 1024;
                    break;
                  case 100:
                    u.transformFlags |= 4;
                    break;
                  default:
                    return e.Debug.assertNever(i);
                }
                return u;
              }
              __name(Ho, "Ho");
              function Go(i, o) {
                return i.name !== o ? j(Ho(i.keywordToken, o), i) : i;
              }
              __name(Go, "Go");
              function Vi(i, o) {
                var u = he(236);
                return u.expression = i, u.literal = o, u.transformFlags |= Q(u.expression) | Q(u.literal) | 1024, u;
              }
              __name(Vi, "Vi");
              function Os(i, o, u) {
                return i.expression !== o || i.literal !== u ? j(Vi(o, u), i) : i;
              }
              __name(Os, "Os");
              function Do() {
                var i = he(237);
                return i.transformFlags |= 1024, i;
              }
              __name(Do, "Do");
              function l(i, o) {
                var u = he(238);
                return u.statements = we(i), u.multiLine = o, u.transformFlags |= Be(u.statements), u;
              }
              __name(l, "l");
              function w(i, o) {
                return i.statements !== o ? j(l(o, i.multiLine), i) : i;
              }
              __name(w, "w");
              function M(i, o) {
                var u = yr(240);
                return u.modifiers = Xn(i), u.declarationList = e.isArray(o) ? Po(o) : o, u.transformFlags |= Be(u.modifiers) | Q(u.declarationList), e.modifiersToFlags(u.modifiers) & 2 && (u.transformFlags = 1), u;
              }
              __name(M, "M");
              function ke(i, o, u) {
                return i.modifiers !== o || i.declarationList !== u ? j(M(o, u), i) : i;
              }
              __name(ke, "ke");
              function cr() {
                return he(239);
              }
              __name(cr, "cr");
              function Zr(i) {
                var o = he(241);
                return o.expression = be().parenthesizeExpressionOfExpressionStatement(i), o.transformFlags |= Q(o.expression), o;
              }
              __name(Zr, "Zr");
              function _t(i, o) {
                return i.expression !== o ? j(Zr(o), i) : i;
              }
              __name(_t, "_t");
              function Rt(i, o, u) {
                var b = he(242);
                return b.expression = i, b.thenStatement = ii(o), b.elseStatement = ii(u), b.transformFlags |= Q(b.expression) | Q(b.thenStatement) | Q(b.elseStatement), b;
              }
              __name(Rt, "Rt");
              function un(i, o, u, b) {
                return i.expression !== o || i.thenStatement !== u || i.elseStatement !== b ? j(Rt(o, u, b), i) : i;
              }
              __name(un, "un");
              function bn(i, o) {
                var u = he(243);
                return u.statement = ii(i), u.expression = o, u.transformFlags |= Q(u.statement) | Q(u.expression), u;
              }
              __name(bn, "bn");
              function _n(i, o, u) {
                return i.statement !== o || i.expression !== u ? j(bn(o, u), i) : i;
              }
              __name(_n, "_n");
              function Nt(i, o) {
                var u = he(244);
                return u.expression = i, u.statement = ii(o), u.transformFlags |= Q(u.expression) | Q(u.statement), u;
              }
              __name(Nt, "Nt");
              function Ft(i, o, u) {
                return i.expression !== o || i.statement !== u ? j(Nt(o, u), i) : i;
              }
              __name(Ft, "Ft");
              function Sn(i, o, u, b) {
                var Y = he(245);
                return Y.initializer = i, Y.condition = o, Y.incrementor = u, Y.statement = ii(b), Y.transformFlags |= Q(Y.initializer) | Q(Y.condition) | Q(Y.incrementor) | Q(Y.statement), Y;
              }
              __name(Sn, "Sn");
              function wn(i, o, u, b, Y) {
                return i.initializer !== o || i.condition !== u || i.incrementor !== b || i.statement !== Y ? j(Sn(o, u, b, Y), i) : i;
              }
              __name(wn, "wn");
              function Wn(i, o, u) {
                var b = he(246);
                return b.initializer = i, b.expression = o, b.statement = ii(u), b.transformFlags |= Q(b.initializer) | Q(b.expression) | Q(b.statement), b;
              }
              __name(Wn, "Wn");
              function Fi(i, o, u, b) {
                return i.initializer !== o || i.expression !== u || i.statement !== b ? j(Wn(o, u, b), i) : i;
              }
              __name(Fi, "Fi");
              function qa(i, o, u, b) {
                var Y = he(247);
                return Y.awaitModifier = i, Y.initializer = o, Y.expression = be().parenthesizeExpressionForDisallowedComma(u), Y.statement = ii(b), Y.transformFlags |= Q(Y.awaitModifier) | Q(Y.initializer) | Q(Y.expression) | Q(Y.statement) | 1024, i && (Y.transformFlags |= 128), Y;
              }
              __name(qa, "qa");
              function xo(i, o, u, b, Y) {
                return i.awaitModifier !== o || i.initializer !== u || i.expression !== b || i.statement !== Y ? j(qa(o, u, b, Y), i) : i;
              }
              __name(xo, "xo");
              function wo(i) {
                var o = he(248);
                return o.label = Pi(i), o.transformFlags |= Q(o.label) | 4194304, o;
              }
              __name(wo, "wo");
              function Ao(i, o) {
                return i.label !== o ? j(wo(o), i) : i;
              }
              __name(Ao, "Ao");
              function no(i) {
                var o = he(249);
                return o.label = Pi(i), o.transformFlags |= Q(o.label) | 4194304, o;
              }
              __name(no, "no");
              function Vc(i, o) {
                return i.label !== o ? j(no(o), i) : i;
              }
              __name(Vc, "Vc");
              function Ms(i) {
                var o = he(250);
                return o.expression = i, o.transformFlags |= Q(o.expression) | 128 | 4194304, o;
              }
              __name(Ms, "Ms");
              function ko(i, o) {
                return i.expression !== o ? j(Ms(o), i) : i;
              }
              __name(ko, "ko");
              function Ls(i, o) {
                var u = he(251);
                return u.expression = i, u.statement = ii(o), u.transformFlags |= Q(u.expression) | Q(u.statement), u;
              }
              __name(Ls, "Ls");
              function Xo(i, o, u) {
                return i.expression !== o || i.statement !== u ? j(Ls(o, u), i) : i;
              }
              __name(Xo, "Xo");
              function $o(i, o) {
                var u = he(252);
                return u.expression = be().parenthesizeExpressionForDisallowedComma(i), u.caseBlock = o, u.transformFlags |= Q(u.expression) | Q(u.caseBlock), u;
              }
              __name($o, "$o");
              function w_(i, o, u) {
                return i.expression !== o || i.caseBlock !== u ? j($o(o, u), i) : i;
              }
              __name(w_, "w_");
              function Rs(i, o) {
                var u = he(253);
                return u.label = Pi(i), u.statement = ii(o), u.transformFlags |= Q(u.label) | Q(u.statement), u;
              }
              __name(Rs, "Rs");
              function js(i, o, u) {
                return i.label !== o || i.statement !== u ? j(Rs(o, u), i) : i;
              }
              __name(js, "js");
              function Js(i) {
                var o = he(254);
                return o.expression = i, o.transformFlags |= Q(o.expression), o;
              }
              __name(Js, "Js");
              function io(i, o) {
                return i.expression !== o ? j(Js(o), i) : i;
              }
              __name(io, "io");
              function A_(i, o, u) {
                var b = he(255);
                return b.tryBlock = i, b.catchClause = o, b.finallyBlock = u, b.transformFlags |= Q(b.tryBlock) | Q(b.catchClause) | Q(b.finallyBlock), b;
              }
              __name(A_, "A_");
              function Wc(i, o, u, b) {
                return i.tryBlock !== o || i.catchClause !== u || i.finallyBlock !== b ? j(A_(o, u, b), i) : i;
              }
              __name(Wc, "Wc");
              function Kc() {
                return he(256);
              }
              __name(Kc, "Kc");
              function Fs(i, o, u, b) {
                var Y = Pr(257, void 0, i, u, b && be().parenthesizeExpressionForDisallowedComma(b));
                return Y.exclamationToken = o, Y.transformFlags |= Q(Y.exclamationToken), o && (Y.transformFlags |= 1), Y;
              }
              __name(Fs, "Fs");
              function Pa(i, o, u, b, Y) {
                return i.name !== o || i.type !== b || i.exclamationToken !== u || i.initializer !== Y ? j(Fs(o, u, b, Y), i) : i;
              }
              __name(Pa, "Pa");
              function Po(i, o) {
                o === void 0 && (o = 0);
                var u = he(258);
                return u.flags |= o & 3, u.declarations = we(i), u.transformFlags |= Be(u.declarations) | 4194304, o & 3 && (u.transformFlags |= 263168), u;
              }
              __name(Po, "Po");
              function Bs(i, o) {
                return i.declarations !== o ? j(Po(o, i.flags), i) : i;
              }
              __name(Bs, "Bs");
              function No(i, o, u, b, Y, Ke, Or) {
                var kt = zr(259, i, u, b, Y, Ke, Or);
                return kt.asteriskToken = o, !kt.body || e.modifiersToFlags(kt.modifiers) & 2 ? kt.transformFlags = 1 : (kt.transformFlags |= Q(kt.asteriskToken) | 4194304, e.modifiersToFlags(kt.modifiers) & 512 ? kt.asteriskToken ? kt.transformFlags |= 128 : kt.transformFlags |= 256 : kt.asteriskToken && (kt.transformFlags |= 2048)), kt.illegalDecorators = void 0, kt;
              }
              __name(No, "No");
              function ao(i, o, u, b, Y, Ke, Or, kt) {
                return i.modifiers !== o || i.asteriskToken !== u || i.name !== b || i.typeParameters !== Y || i.parameters !== Ke || i.type !== Or || i.body !== kt ? qs(No(o, u, b, Y, Ke, Or, kt), i) : i;
              }
              __name(ao, "ao");
              function qs(i, o) {
                return i !== o && (i.illegalDecorators = o.illegalDecorators), Lr(i, o);
              }
              __name(qs, "qs");
              function Qo(i, o, u, b, Y) {
                var Ke = ir(260, i, o, u, b, Y);
                return e.modifiersToFlags(Ke.modifiers) & 2 ? Ke.transformFlags = 1 : (Ke.transformFlags |= 1024, Ke.transformFlags & 8192 && (Ke.transformFlags |= 1)), Ke;
              }
              __name(Qo, "Qo");
              function k_(i, o, u, b, Y, Ke) {
                return i.modifiers !== o || i.name !== u || i.typeParameters !== b || i.heritageClauses !== Y || i.members !== Ke ? j(Qo(o, u, b, Y, Ke), i) : i;
              }
              __name(k_, "k_");
              function Us(i, o, u, b, Y) {
                var Ke = ye(261, i, o, u, b);
                return Ke.members = we(Y), Ke.transformFlags = 1, Ke.illegalDecorators = void 0, Ke;
              }
              __name(Us, "Us");
              function P_(i, o, u, b, Y, Ke) {
                return i.modifiers !== o || i.name !== u || i.typeParameters !== b || i.heritageClauses !== Y || i.members !== Ke ? Hc(Us(o, u, b, Y, Ke), i) : i;
              }
              __name(P_, "P_");
              function Hc(i, o) {
                return i !== o && (i.illegalDecorators = o.illegalDecorators), j(i, o);
              }
              __name(Hc, "Hc");
              function zs(i, o, u, b) {
                var Y = nr(262, i, o, u);
                return Y.type = b, Y.transformFlags = 1, Y.illegalDecorators = void 0, Y;
              }
              __name(zs, "zs");
              function N_(i, o, u, b, Y) {
                return i.modifiers !== o || i.name !== u || i.typeParameters !== b || i.type !== Y ? Gc(zs(o, u, b, Y), i) : i;
              }
              __name(N_, "N_");
              function Gc(i, o) {
                return i !== o && (i.illegalDecorators = o.illegalDecorators), j(i, o);
              }
              __name(Gc, "Gc");
              function Un(i, o, u) {
                var b = kr(263, i, o);
                return b.members = we(u), b.transformFlags |= Be(b.members) | 1, b.transformFlags &= -67108865, b.illegalDecorators = void 0, b;
              }
              __name(Un, "Un");
              function la(i, o, u, b) {
                return i.modifiers !== o || i.name !== u || i.members !== b ? I_(Un(o, u, b), i) : i;
              }
              __name(la, "la");
              function I_(i, o) {
                return i !== o && (i.illegalDecorators = o.illegalDecorators), j(i, o);
              }
              __name(I_, "I_");
              function Ca(i, o, u, b) {
                b === void 0 && (b = 0);
                var Y = yr(264);
                return Y.modifiers = Xn(i), Y.flags |= b & 1044, Y.name = o, Y.body = u, e.modifiersToFlags(Y.modifiers) & 2 ? Y.transformFlags = 1 : Y.transformFlags |= Be(Y.modifiers) | Q(Y.name) | Q(Y.body) | 1, Y.transformFlags &= -67108865, Y.illegalDecorators = void 0, Y;
              }
              __name(Ca, "Ca");
              function O_(i, o, u, b) {
                return i.modifiers !== o || i.name !== u || i.body !== b ? pi(Ca(o, u, b, i.flags), i) : i;
              }
              __name(O_, "O_");
              function pi(i, o) {
                return i !== o && (i.illegalDecorators = o.illegalDecorators), j(i, o);
              }
              __name(pi, "pi");
              function Na(i) {
                var o = he(265);
                return o.statements = we(i), o.transformFlags |= Be(o.statements), o;
              }
              __name(Na, "Na");
              function Ai(i, o) {
                return i.statements !== o ? j(Na(o), i) : i;
              }
              __name(Ai, "Ai");
              function M_(i) {
                var o = he(266);
                return o.clauses = we(i), o.transformFlags |= Be(o.clauses), o;
              }
              __name(M_, "M_");
              function Vs(i, o) {
                return i.clauses !== o ? j(M_(o), i) : i;
              }
              __name(Vs, "Vs");
              function L_(i) {
                var o = kr(267, void 0, i);
                return o.transformFlags = 1, o.illegalDecorators = void 0, o.modifiers = void 0, o;
              }
              __name(L_, "L_");
              function Ws(i, o) {
                return i.name !== o ? R_(L_(o), i) : i;
              }
              __name(Ws, "Ws");
              function R_(i, o) {
                return i !== o && (i.illegalDecorators = o.illegalDecorators, i.modifiers = o.modifiers), j(i, o);
              }
              __name(R_, "R_");
              function j_(i, o, u, b) {
                var Y = kr(268, i, u);
                return Y.isTypeOnly = o, Y.moduleReference = b, Y.transformFlags |= Q(Y.moduleReference), e.isExternalModuleReference(Y.moduleReference) || (Y.transformFlags |= 1), Y.transformFlags &= -67108865, Y.illegalDecorators = void 0, Y;
              }
              __name(j_, "j_");
              function J_(i, o, u, b, Y) {
                return i.modifiers !== o || i.isTypeOnly !== u || i.name !== b || i.moduleReference !== Y ? Xc(j_(o, u, b, Y), i) : i;
              }
              __name(J_, "J_");
              function Xc(i, o) {
                return i !== o && (i.illegalDecorators = o.illegalDecorators), j(i, o);
              }
              __name(Xc, "Xc");
              function F_(i, o, u, b) {
                var Y = yr(269);
                return Y.modifiers = Xn(i), Y.importClause = o, Y.moduleSpecifier = u, Y.assertClause = b, Y.transformFlags |= Q(Y.importClause) | Q(Y.moduleSpecifier), Y.transformFlags &= -67108865, Y.illegalDecorators = void 0, Y;
              }
              __name(F_, "F_");
              function B_(i, o, u, b, Y) {
                return i.modifiers !== o || i.importClause !== u || i.moduleSpecifier !== b || i.assertClause !== Y ? q_(F_(o, u, b, Y), i) : i;
              }
              __name(B_, "B_");
              function q_(i, o) {
                return i !== o && (i.illegalDecorators = o.illegalDecorators), j(i, o);
              }
              __name(q_, "q_");
              function Ks(i, o, u) {
                var b = he(270);
                return b.isTypeOnly = i, b.name = o, b.namedBindings = u, b.transformFlags |= Q(b.name) | Q(b.namedBindings), i && (b.transformFlags |= 1), b.transformFlags &= -67108865, b;
              }
              __name(Ks, "Ks");
              function $c(i, o, u, b) {
                return i.isTypeOnly !== o || i.name !== u || i.namedBindings !== b ? j(Ks(o, u, b), i) : i;
              }
              __name($c, "$c");
              function Io(i, o) {
                var u = he(296);
                return u.elements = we(i), u.multiLine = o, u.transformFlags |= 4, u;
              }
              __name(Io, "Io");
              function Hs(i, o, u) {
                return i.elements !== o || i.multiLine !== u ? j(Io(o, u), i) : i;
              }
              __name(Hs, "Hs");
              function Gs(i, o) {
                var u = he(297);
                return u.name = i, u.value = o, u.transformFlags |= 4, u;
              }
              __name(Gs, "Gs");
              function Oo(i, o, u) {
                return i.name !== o || i.value !== u ? j(Gs(o, u), i) : i;
              }
              __name(Oo, "Oo");
              function Xs(i, o) {
                var u = he(298);
                return u.assertClause = i, u.multiLine = o, u;
              }
              __name(Xs, "Xs");
              function oo(i, o, u) {
                return i.assertClause !== o || i.multiLine !== u ? j(Xs(o, u), i) : i;
              }
              __name(oo, "oo");
              function U_(i) {
                var o = he(271);
                return o.name = i, o.transformFlags |= Q(o.name), o.transformFlags &= -67108865, o;
              }
              __name(U_, "U_");
              function z_(i, o) {
                return i.name !== o ? j(U_(o), i) : i;
              }
              __name(z_, "z_");
              function V_(i) {
                var o = he(277);
                return o.name = i, o.transformFlags |= Q(o.name) | 4, o.transformFlags &= -67108865, o;
              }
              __name(V_, "V_");
              function Qc(i, o) {
                return i.name !== o ? j(V_(o), i) : i;
              }
              __name(Qc, "Qc");
              function W_(i) {
                var o = he(272);
                return o.elements = we(i), o.transformFlags |= Be(o.elements), o.transformFlags &= -67108865, o;
              }
              __name(W_, "W_");
              function K_(i, o) {
                return i.elements !== o ? j(W_(o), i) : i;
              }
              __name(K_, "K_");
              function H_(i, o, u) {
                var b = he(273);
                return b.isTypeOnly = i, b.propertyName = o, b.name = u, b.transformFlags |= Q(b.propertyName) | Q(b.name), b.transformFlags &= -67108865, b;
              }
              __name(H_, "H_");
              function G_(i, o, u, b) {
                return i.isTypeOnly !== o || i.propertyName !== u || i.name !== b ? j(H_(o, u, b), i) : i;
              }
              __name(G_, "G_");
              function Da(i, o, u) {
                var b = yr(274);
                return b.modifiers = Xn(i), b.isExportEquals = o, b.expression = o ? be().parenthesizeRightSideOfBinary(63, void 0, u) : be().parenthesizeExpressionOfExportDefault(u), b.transformFlags |= Be(b.modifiers) | Q(b.expression), b.transformFlags &= -67108865, b.illegalDecorators = void 0, b;
              }
              __name(Da, "Da");
              function Ua(i, o, u) {
                return i.modifiers !== o || i.expression !== u ? Yo(Da(o, i.isExportEquals, u), i) : i;
              }
              __name(Ua, "Ua");
              function Yo(i, o) {
                return i !== o && (i.illegalDecorators = o.illegalDecorators), j(i, o);
              }
              __name(Yo, "Yo");
              function na(i, o, u, b, Y) {
                var Ke = yr(275);
                return Ke.modifiers = Xn(i), Ke.isTypeOnly = o, Ke.exportClause = u, Ke.moduleSpecifier = b, Ke.assertClause = Y, Ke.transformFlags |= Be(Ke.modifiers) | Q(Ke.exportClause) | Q(Ke.moduleSpecifier), Ke.transformFlags &= -67108865, Ke.illegalDecorators = void 0, Ke;
              }
              __name(na, "na");
              function $s(i, o, u, b, Y, Ke) {
                return i.modifiers !== o || i.isTypeOnly !== u || i.exportClause !== b || i.moduleSpecifier !== Y || i.assertClause !== Ke ? Yc(na(o, u, b, Y, Ke), i) : i;
              }
              __name($s, "$s");
              function Yc(i, o) {
                return i !== o && (i.illegalDecorators = o.illegalDecorators), j(i, o);
              }
              __name(Yc, "Yc");
              function so(i) {
                var o = he(276);
                return o.elements = we(i), o.transformFlags |= Be(o.elements), o.transformFlags &= -67108865, o;
              }
              __name(so, "so");
              function X_(i, o) {
                return i.elements !== o ? j(so(o), i) : i;
              }
              __name(X_, "X_");
              function Qs(i, o, u) {
                var b = he(278);
                return b.isTypeOnly = i, b.propertyName = Pi(o), b.name = Pi(u), b.transformFlags |= Q(b.propertyName) | Q(b.name), b.transformFlags &= -67108865, b;
              }
              __name(Qs, "Qs");
              function Ys(i, o, u, b) {
                return i.isTypeOnly !== o || i.propertyName !== u || i.name !== b ? j(Qs(o, u, b), i) : i;
              }
              __name(Ys, "Ys");
              function $_() {
                var i = yr(279);
                return i;
              }
              __name($_, "$_");
              function Q_(i) {
                var o = he(280);
                return o.expression = i, o.transformFlags |= Q(o.expression), o.transformFlags &= -67108865, o;
              }
              __name(Q_, "Q_");
              function Zo(i, o) {
                return i.expression !== o ? j(Q_(o), i) : i;
              }
              __name(Zo, "Zo");
              function Y_(i) {
                return he(i);
              }
              __name(Y_, "Y_");
              function Z_(i, o, u) {
                u === void 0 && (u = false);
                var b = es(i, u ? o && be().parenthesizeNonArrayTypeOfPostfixType(o) : o);
                return b.postfix = u, b;
              }
              __name(Z_, "Z_");
              function es(i, o) {
                var u = he(i);
                return u.type = o, u;
              }
              __name(es, "es");
              function ec(i, o, u) {
                return o.type !== u ? j(Z_(i, u, o.postfix), o) : o;
              }
              __name(ec, "ec");
              function Zc(i, o, u) {
                return o.type !== u ? j(es(i, u), o) : o;
              }
              __name(Zc, "Zc");
              function Zs(i, o) {
                var u = tr(320, void 0, void 0, void 0, i, o);
                return u;
              }
              __name(Zs, "Zs");
              function eu(i, o, u) {
                return i.parameters !== o || i.type !== u ? j(Zs(o, u), i) : i;
              }
              __name(eu, "eu");
              function rc(i, o) {
                o === void 0 && (o = false);
                var u = he(325);
                return u.jsDocPropertyTags = Xn(i), u.isArrayType = o, u;
              }
              __name(rc, "rc");
              function e_(i, o, u) {
                return i.jsDocPropertyTags !== o || i.isArrayType !== u ? j(rc(o, u), i) : i;
              }
              __name(e_, "e_");
              function Mo(i) {
                var o = he(312);
                return o.type = i, o;
              }
              __name(Mo, "Mo");
              function r_(i, o) {
                return i.type !== o ? j(Mo(o), i) : i;
              }
              __name(r_, "r_");
              function tc(i, o, u) {
                var b = he(326);
                return b.typeParameters = Xn(i), b.parameters = we(o), b.type = u, b;
              }
              __name(tc, "tc");
              function Lo(i, o, u, b) {
                return i.typeParameters !== o || i.parameters !== u || i.type !== b ? j(tc(o, u, b), i) : i;
              }
              __name(Lo, "Lo");
              function ia(i) {
                var o = fe(i.kind);
                return i.tagName.escapedText === e.escapeLeadingUnderscores(o) ? i.tagName : pt(o);
              }
              __name(ia, "ia");
              function Yi(i, o, u) {
                var b = he(i);
                return b.tagName = o, b.comment = u, b;
              }
              __name(Yi, "Yi");
              function pa(i, o, u, b) {
                var Y = Yi(347, i != null ? i : pt("template"), b);
                return Y.constraint = o, Y.typeParameters = we(u), Y;
              }
              __name(pa, "pa");
              function t_(i, o, u, b, Y) {
                return o === void 0 && (o = ia(i)), i.tagName !== o || i.constraint !== u || i.typeParameters !== b || i.comment !== Y ? j(pa(o, u, b, Y), i) : i;
              }
              __name(t_, "t_");
              function _o(i, o, u, b) {
                var Y = Yi(348, i != null ? i : pt("typedef"), b);
                return Y.typeExpression = o, Y.fullName = u, Y.name = e.getJSDocTypeAliasName(u), Y;
              }
              __name(_o, "_o");
              function ru(i, o, u, b, Y) {
                return o === void 0 && (o = ia(i)), i.tagName !== o || i.typeExpression !== u || i.fullName !== b || i.comment !== Y ? j(_o(o, u, b, Y), i) : i;
              }
              __name(ru, "ru");
              function n_(i, o, u, b, Y, Ke) {
                var Or = Yi(343, i != null ? i : pt("param"), Ke);
                return Or.typeExpression = b, Or.name = o, Or.isNameFirst = !!Y, Or.isBracketed = u, Or;
              }
              __name(n_, "n_");
              function rs(i, o, u, b, Y, Ke, Or) {
                return o === void 0 && (o = ia(i)), i.tagName !== o || i.name !== u || i.isBracketed !== b || i.typeExpression !== Y || i.isNameFirst !== Ke || i.comment !== Or ? j(n_(o, u, b, Y, Ke, Or), i) : i;
              }
              __name(rs, "rs");
              function ts(i, o, u, b, Y, Ke) {
                var Or = Yi(350, i != null ? i : pt("prop"), Ke);
                return Or.typeExpression = b, Or.name = o, Or.isNameFirst = !!Y, Or.isBracketed = u, Or;
              }
              __name(ts, "ts");
              function nc(i, o, u, b, Y, Ke, Or) {
                return o === void 0 && (o = ia(i)), i.tagName !== o || i.name !== u || i.isBracketed !== b || i.typeExpression !== Y || i.isNameFirst !== Ke || i.comment !== Or ? j(ts(o, u, b, Y, Ke, Or), i) : i;
              }
              __name(nc, "nc");
              function i_(i, o, u, b) {
                var Y = Yi(341, i != null ? i : pt("callback"), b);
                return Y.typeExpression = o, Y.fullName = u, Y.name = e.getJSDocTypeAliasName(u), Y;
              }
              __name(i_, "i_");
              function ic(i, o, u, b, Y) {
                return o === void 0 && (o = ia(i)), i.tagName !== o || i.typeExpression !== u || i.fullName !== b || i.comment !== Y ? j(i_(o, u, b, Y), i) : i;
              }
              __name(ic, "ic");
              function ns(i, o, u) {
                var b = Yi(331, i != null ? i : pt("augments"), u);
                return b.class = o, b;
              }
              __name(ns, "ns");
              function a_(i, o, u, b) {
                return o === void 0 && (o = ia(i)), i.tagName !== o || i.class !== u || i.comment !== b ? j(ns(o, u, b), i) : i;
              }
              __name(a_, "a_");
              function o_(i, o, u) {
                var b = Yi(332, i != null ? i : pt("implements"), u);
                return b.class = o, b;
              }
              __name(o_, "o_");
              function co(i, o, u) {
                var b = Yi(349, i != null ? i : pt("see"), u);
                return b.name = o, b;
              }
              __name(co, "co");
              function tu(i, o, u, b) {
                return i.tagName !== o || i.name !== u || i.comment !== b ? j(co(o, u, b), i) : i;
              }
              __name(tu, "tu");
              function za(i) {
                var o = he(313);
                return o.name = i, o;
              }
              __name(za, "za");
              function Ro(i, o) {
                return i.name !== o ? j(za(o), i) : i;
              }
              __name(Ro, "Ro");
              function s_(i, o) {
                var u = he(314);
                return u.left = i, u.right = o, u.transformFlags |= Q(u.left) | Q(u.right), u;
              }
              __name(s_, "s_");
              function nu(i, o, u) {
                return i.left !== o || i.right !== u ? j(s_(o, u), i) : i;
              }
              __name(nu, "nu");
              function __(i, o) {
                var u = he(327);
                return u.name = i, u.text = o, u;
              }
              __name(__, "__");
              function iu(i, o, u) {
                return i.name !== o ? j(__(o, u), i) : i;
              }
              __name(iu, "iu");
              function ac(i, o) {
                var u = he(328);
                return u.name = i, u.text = o, u;
              }
              __name(ac, "ac");
              function oc(i, o, u) {
                return i.name !== o ? j(ac(o, u), i) : i;
              }
              __name(oc, "oc");
              function c_(i, o) {
                var u = he(329);
                return u.name = i, u.text = o, u;
              }
              __name(c_, "c_");
              function au(i, o, u) {
                return i.name !== o ? j(c_(o, u), i) : i;
              }
              __name(au, "au");
              function ou(i, o, u, b) {
                return o === void 0 && (o = ia(i)), i.tagName !== o || i.class !== u || i.comment !== b ? j(o_(o, u, b), i) : i;
              }
              __name(ou, "ou");
              function is(i, o, u) {
                var b = Yi(i, o != null ? o : pt(fe(i)), u);
                return b;
              }
              __name(is, "is");
              function aa(i, o, u, b) {
                return u === void 0 && (u = ia(o)), o.tagName !== u || o.comment !== b ? j(is(i, u, b), o) : o;
              }
              __name(aa, "aa");
              function as(i, o, u, b) {
                var Y = Yi(i, o != null ? o : pt(fe(i)), b);
                return Y.typeExpression = u, Y;
              }
              __name(as, "as");
              function u_(i, o, u, b, Y) {
                return u === void 0 && (u = ia(o)), o.tagName !== u || o.typeExpression !== b || o.comment !== Y ? j(as(i, u, b, Y), o) : o;
              }
              __name(u_, "u_");
              function sc(i, o) {
                var u = Yi(330, i, o);
                return u;
              }
              __name(sc, "sc");
              function su(i, o, u) {
                return i.tagName !== o || i.comment !== u ? j(sc(o, u), i) : i;
              }
              __name(su, "su");
              function _c(i) {
                var o = he(324);
                return o.text = i, o;
              }
              __name(_c, "_c");
              function _u(i, o) {
                return i.text !== o ? j(_c(o), i) : i;
              }
              __name(_u, "_u");
              function os(i, o) {
                var u = he(323);
                return u.comment = i, u.tags = Xn(o), u;
              }
              __name(os, "os");
              function ss(i, o, u) {
                return i.comment !== o || i.tags !== u ? j(os(o, u), i) : i;
              }
              __name(ss, "ss");
              function l_(i, o, u) {
                var b = he(281);
                return b.openingElement = i, b.children = we(o), b.closingElement = u, b.transformFlags |= Q(b.openingElement) | Be(b.children) | Q(b.closingElement) | 2, b;
              }
              __name(l_, "l_");
              function p_(i, o, u, b) {
                return i.openingElement !== o || i.children !== u || i.closingElement !== b ? j(l_(o, u, b), i) : i;
              }
              __name(p_, "p_");
              function jo(i, o, u) {
                var b = he(282);
                return b.tagName = i, b.typeArguments = Xn(o), b.attributes = u, b.transformFlags |= Q(b.tagName) | Be(b.typeArguments) | Q(b.attributes) | 2, b.typeArguments && (b.transformFlags |= 1), b;
              }
              __name(jo, "jo");
              function f_(i, o, u, b) {
                return i.tagName !== o || i.typeArguments !== u || i.attributes !== b ? j(jo(o, u, b), i) : i;
              }
              __name(f_, "f_");
              function Jo(i, o, u) {
                var b = he(283);
                return b.tagName = i, b.typeArguments = Xn(o), b.attributes = u, b.transformFlags |= Q(b.tagName) | Be(b.typeArguments) | Q(b.attributes) | 2, o && (b.transformFlags |= 1), b;
              }
              __name(Jo, "Jo");
              function _s(i, o, u, b) {
                return i.tagName !== o || i.typeArguments !== u || i.attributes !== b ? j(Jo(o, u, b), i) : i;
              }
              __name(_s, "_s");
              function d_(i) {
                var o = he(284);
                return o.tagName = i, o.transformFlags |= Q(o.tagName) | 2, o;
              }
              __name(d_, "d_");
              function cu(i, o) {
                return i.tagName !== o ? j(d_(o), i) : i;
              }
              __name(cu, "cu");
              function ki(i, o, u) {
                var b = he(285);
                return b.openingFragment = i, b.children = we(o), b.closingFragment = u, b.transformFlags |= Q(b.openingFragment) | Be(b.children) | Q(b.closingFragment) | 2, b;
              }
              __name(ki, "ki");
              function m_(i, o, u, b) {
                return i.openingFragment !== o || i.children !== u || i.closingFragment !== b ? j(ki(o, u, b), i) : i;
              }
              __name(m_, "m_");
              function uo(i, o) {
                var u = he(11);
                return u.text = i, u.containsOnlyTriviaWhiteSpaces = !!o, u.transformFlags |= 2, u;
              }
              __name(uo, "uo");
              function uu(i, o, u) {
                return i.text !== o || i.containsOnlyTriviaWhiteSpaces !== u ? j(uo(o, u), i) : i;
              }
              __name(uu, "uu");
              function cs() {
                var i = he(286);
                return i.transformFlags |= 2, i;
              }
              __name(cs, "cs");
              function lu() {
                var i = he(287);
                return i.transformFlags |= 2, i;
              }
              __name(lu, "lu");
              function Ia(i, o) {
                var u = he(288);
                return u.name = i, u.initializer = o, u.transformFlags |= Q(u.name) | Q(u.initializer) | 2, u;
              }
              __name(Ia, "Ia");
              function cc(i, o, u) {
                return i.name !== o || i.initializer !== u ? j(Ia(o, u), i) : i;
              }
              __name(cc, "cc");
              function g_(i) {
                var o = he(289);
                return o.properties = we(i), o.transformFlags |= Be(o.properties) | 2, o;
              }
              __name(g_, "g_");
              function us(i, o) {
                return i.properties !== o ? j(g_(o), i) : i;
              }
              __name(us, "us");
              function uc(i) {
                var o = he(290);
                return o.expression = i, o.transformFlags |= Q(o.expression) | 2, o;
              }
              __name(uc, "uc");
              function y_(i, o) {
                return i.expression !== o ? j(uc(o), i) : i;
              }
              __name(y_, "y_");
              function Oa(i, o) {
                var u = he(291);
                return u.dotDotDotToken = i, u.expression = o, u.transformFlags |= Q(u.dotDotDotToken) | Q(u.expression) | 2, u;
              }
              __name(Oa, "Oa");
              function Ma(i, o) {
                return i.expression !== o ? j(Oa(i.dotDotDotToken, o), i) : i;
              }
              __name(Ma, "Ma");
              function ls(i, o) {
                var u = he(292);
                return u.expression = be().parenthesizeExpressionForDisallowedComma(i), u.statements = we(o), u.transformFlags |= Q(u.expression) | Be(u.statements), u;
              }
              __name(ls, "ls");
              function ps(i, o, u) {
                return i.expression !== o || i.statements !== u ? j(ls(o, u), i) : i;
              }
              __name(ps, "ps");
              function h_(i) {
                var o = he(293);
                return o.statements = we(i), o.transformFlags = Be(o.statements), o;
              }
              __name(h_, "h_");
              function Fo(i, o) {
                return i.statements !== o ? j(h_(o), i) : i;
              }
              __name(Fo, "Fo");
              function Va(i, o) {
                var u = he(294);
                switch (u.token = i, u.types = we(o), u.transformFlags |= Be(u.types), i) {
                  case 94:
                    u.transformFlags |= 1024;
                    break;
                  case 117:
                    u.transformFlags |= 1;
                    break;
                  default:
                    return e.Debug.assertNever(i);
                }
                return u;
              }
              __name(Va, "Va");
              function pu(i, o) {
                return i.types !== o ? j(Va(i.token, o), i) : i;
              }
              __name(pu, "pu");
              function v_(i, o) {
                var u = he(295);
                return (typeof i == "string" || i && !e.isVariableDeclaration(i)) && (i = Fs(i, void 0, void 0, void 0)), u.variableDeclaration = i, u.block = o, u.transformFlags |= Q(u.variableDeclaration) | Q(u.block), i || (u.transformFlags |= 64), u;
              }
              __name(v_, "v_");
              function lc(i, o, u) {
                return i.variableDeclaration !== o || i.block !== u ? j(v_(o, u), i) : i;
              }
              __name(lc, "lc");
              function fs(i, o) {
                var u = kr(299, void 0, i);
                return u.initializer = be().parenthesizeExpressionForDisallowedComma(o), u.transformFlags |= Q(u.name) | Q(u.initializer), u.illegalDecorators = void 0, u.modifiers = void 0, u.questionToken = void 0, u.exclamationToken = void 0, u;
              }
              __name(fs, "fs");
              function pc(i, o, u) {
                return i.name !== o || i.initializer !== u ? lo(fs(o, u), i) : i;
              }
              __name(pc, "pc");
              function lo(i, o) {
                return i !== o && (i.illegalDecorators = o.illegalDecorators, i.modifiers = o.modifiers, i.questionToken = o.questionToken, i.exclamationToken = o.exclamationToken), j(i, o);
              }
              __name(lo, "lo");
              function fc(i, o) {
                var u = kr(300, void 0, i);
                return u.objectAssignmentInitializer = o && be().parenthesizeExpressionForDisallowedComma(o), u.transformFlags |= Q(u.objectAssignmentInitializer) | 1024, u.equalsToken = void 0, u.illegalDecorators = void 0, u.modifiers = void 0, u.questionToken = void 0, u.exclamationToken = void 0, u;
              }
              __name(fc, "fc");
              function fu(i, o, u) {
                return i.name !== o || i.objectAssignmentInitializer !== u ? du(fc(o, u), i) : i;
              }
              __name(fu, "fu");
              function du(i, o) {
                return i !== o && (i.equalsToken = o.equalsToken, i.illegalDecorators = o.illegalDecorators, i.modifiers = o.modifiers, i.questionToken = o.questionToken, i.exclamationToken = o.exclamationToken), j(i, o);
              }
              __name(du, "du");
              function ya(i) {
                var o = he(301);
                return o.expression = be().parenthesizeExpressionForDisallowedComma(i), o.transformFlags |= Q(o.expression) | 128 | 65536, o;
              }
              __name(ya, "ya");
              function dc(i, o) {
                return i.expression !== o ? j(ya(o), i) : i;
              }
              __name(dc, "dc");
              function po(i, o) {
                var u = he(302);
                return u.name = Pi(i), u.initializer = o && be().parenthesizeExpressionForDisallowedComma(o), u.transformFlags |= Q(u.name) | Q(u.initializer) | 1, u;
              }
              __name(po, "po");
              function mu(i, o, u) {
                return i.name !== o || i.initializer !== u ? j(po(o, u), i) : i;
              }
              __name(mu, "mu");
              function Wa(i, o, u) {
                var b = pe.createBaseSourceFileNode(308);
                return b.statements = we(i), b.endOfFileToken = o, b.flags |= u, b.fileName = "", b.text = "", b.languageVersion = 0, b.languageVariant = 0, b.scriptKind = 0, b.isDeclarationFile = false, b.hasNoDefaultLib = false, b.transformFlags |= Be(b.statements) | Q(b.endOfFileToken), b;
              }
              __name(Wa, "Wa");
              function xa(i, o, u, b, Y, Ke, Or) {
                var kt = i.redirectInfo ? Object.create(i.redirectInfo.redirectTarget) : pe.createBaseSourceFileNode(308);
                for (var $n in i)
                  $n === "emitNode" || e.hasProperty(kt, $n) || !e.hasProperty(i, $n) || (kt[$n] = i[$n]);
                return kt.flags |= i.flags, kt.statements = we(o), kt.endOfFileToken = i.endOfFileToken, kt.isDeclarationFile = u, kt.referencedFiles = b, kt.typeReferenceDirectives = Y, kt.hasNoDefaultLib = Ke, kt.libReferenceDirectives = Or, kt.transformFlags = Be(kt.statements) | Q(kt.endOfFileToken), kt.impliedNodeFormat = i.impliedNodeFormat, kt;
              }
              __name(xa, "xa");
              function mc(i, o, u, b, Y, Ke, Or) {
                return u === void 0 && (u = i.isDeclarationFile), b === void 0 && (b = i.referencedFiles), Y === void 0 && (Y = i.typeReferenceDirectives), Ke === void 0 && (Ke = i.hasNoDefaultLib), Or === void 0 && (Or = i.libReferenceDirectives), i.statements !== o || i.isDeclarationFile !== u || i.referencedFiles !== b || i.typeReferenceDirectives !== Y || i.hasNoDefaultLib !== Ke || i.libReferenceDirectives !== Or ? j(xa(i, o, u, b, Y, Ke, Or), i) : i;
              }
              __name(mc, "mc");
              function gc(i, o) {
                o === void 0 && (o = e.emptyArray);
                var u = he(309);
                return u.prepends = o, u.sourceFiles = i, u;
              }
              __name(gc, "gc");
              function yc(i, o, u) {
                return u === void 0 && (u = e.emptyArray), i.sourceFiles !== o || i.prepends !== u ? j(gc(o, u), i) : i;
              }
              __name(yc, "yc");
              function hc(i, o, u) {
                var b = he(310);
                return b.prologues = i, b.syntheticReferences = o, b.texts = u, b.fileName = "", b.text = "", b.referencedFiles = e.emptyArray, b.libReferenceDirectives = e.emptyArray, b.getLineAndCharacterOfPosition = function(Y) {
                  return e.getLineAndCharacterOfPosition(b, Y);
                }, b;
              }
              __name(hc, "hc");
              function ds(i, o) {
                var u = he(i);
                return u.data = o, u;
              }
              __name(ds, "ds");
              function ms(i) {
                return ds(303, i);
              }
              __name(ms, "ms");
              function gu(i, o) {
                var u = ds(304, i);
                return u.texts = o, u;
              }
              __name(gu, "gu");
              function gs(i, o) {
                return ds(o ? 306 : 305, i);
              }
              __name(gs, "gs");
              function vc(i) {
                var o = he(307);
                return o.data = i.data, o.section = i, o;
              }
              __name(vc, "vc");
              function yu() {
                var i = he(311);
                return i.javascriptText = "", i.declarationText = "", i;
              }
              __name(yu, "yu");
              function ys(i, o, u) {
                o === void 0 && (o = false);
                var b = he(234);
                return b.type = i, b.isSpread = o, b.tupleNameSource = u, b;
              }
              __name(ys, "ys");
              function bc(i) {
                var o = he(351);
                return o._children = i, o;
              }
              __name(bc, "bc");
              function hu(i) {
                var o = he(352);
                return o.original = i, e.setTextRange(o, i), o;
              }
              __name(hu, "hu");
              function Ec(i, o) {
                var u = he(353);
                return u.expression = i, u.original = o, u.transformFlags |= Q(u.expression) | 1, e.setTextRange(u, o), u;
              }
              __name(Ec, "Ec");
              function Tc(i, o) {
                return i.expression !== o ? j(Ec(o, i.original), i) : i;
              }
              __name(Tc, "Tc");
              function Sc(i) {
                if (e.nodeIsSynthesized(i) && !e.isParseTreeNode(i) && !i.original && !i.emitNode && !i.id) {
                  if (e.isCommaListExpression(i))
                    return i.elements;
                  if (e.isBinaryExpression(i) && e.isCommaToken(i.operatorToken))
                    return [i.left, i.right];
                }
                return i;
              }
              __name(Sc, "Sc");
              function b_(i) {
                var o = he(354);
                return o.elements = we(e.sameFlatMap(i, Sc)), o.transformFlags |= Be(o.elements), o;
              }
              __name(b_, "b_");
              function Cc(i, o) {
                return i.elements !== o ? j(b_(o), i) : i;
              }
              __name(Cc, "Cc");
              function Dc(i) {
                var o = he(356);
                return o.emitNode = {}, o.original = i, o;
              }
              __name(Dc, "Dc");
              function xc(i) {
                var o = he(355);
                return o.emitNode = {}, o.original = i, o;
              }
              __name(xc, "xc");
              function Ka(i, o) {
                var u = he(357);
                return u.expression = i, u.thisArg = o, u.transformFlags |= Q(u.expression) | Q(u.thisArg), u;
              }
              __name(Ka, "Ka");
              function fo(i, o, u) {
                return i.expression !== o || i.thisArg !== u ? j(Ka(o, u), i) : i;
              }
              __name(fo, "fo");
              function hs(i) {
                if (i === void 0)
                  return i;
                var o = e.isSourceFile(i) ? pe.createBaseSourceFileNode(308) : e.isIdentifier(i) ? pe.createBaseIdentifierNode(79) : e.isPrivateIdentifier(i) ? pe.createBasePrivateIdentifierNode(80) : e.isNodeKind(i.kind) ? pe.createBaseNode(i.kind) : pe.createBaseTokenNode(i.kind);
                o.flags |= i.flags & -9, o.transformFlags = i.transformFlags, qe(o, i);
                for (var u in i)
                  e.hasProperty(o, u) || !e.hasProperty(i, u) || (o[u] = i[u]);
                return o;
              }
              __name(hs, "hs");
              function wc(i, o, u) {
                return Ui(or(void 0, void 0, void 0, void 0, o ? [o] : [], void 0, l(i, true)), void 0, u ? [u] : []);
              }
              __name(wc, "wc");
              function vu(i, o, u) {
                return Ui(vt(void 0, void 0, o ? [o] : [], void 0, void 0, l(i, true)), void 0, u ? [u] : []);
              }
              __name(vu, "vu");
              function vs() {
                return y(ut("0"));
              }
              __name(vs, "vs");
              function bu(i) {
                return Da(void 0, false, i);
              }
              __name(bu, "bu");
              function Eu(i) {
                return na(void 0, false, so([Qs(false, void 0, i)]));
              }
              __name(Eu, "Eu");
              function E_(i, o) {
                return o === "undefined" ? Ee.createStrictEquality(i, vs()) : Ee.createStrictEquality(Mt(i), f(o));
              }
              __name(E_, "E_");
              function Ha(i, o, u) {
                return e.isCallChain(i) ? Xi(Ni(i, void 0, o), void 0, void 0, u) : Ui(Ht(i, o), void 0, u);
              }
              __name(Ha, "Ha");
              function Ac(i, o, u) {
                return Ha(i, "bind", A([o], u, true));
              }
              __name(Ac, "Ac");
              function Tu(i, o, u) {
                return Ha(i, "call", A([o], u, true));
              }
              __name(Tu, "Tu");
              function Su(i, o, u) {
                return Ha(i, "apply", [o, u]);
              }
              __name(Su, "Su");
              function bs(i, o, u) {
                return Ha(pt(i), o, u);
              }
              __name(bs, "bs");
              function Cu(i, o) {
                return Ha(i, "slice", o === void 0 ? [] : [oa(o)]);
              }
              __name(Cu, "Cu");
              function Es(i, o) {
                return Ha(i, "concat", o);
              }
              __name(Es, "Es");
              function kc(i, o, u) {
                return bs("Object", "defineProperty", [i, oa(o), u]);
              }
              __name(kc, "kc");
              function La(i, o, u) {
                return bs("Reflect", "get", u ? [i, o, u] : [i, o]);
              }
              __name(La, "La");
              function Du(i, o, u, b) {
                return bs("Reflect", "set", b ? [i, o, u, b] : [i, o, u]);
              }
              __name(Du, "Du");
              function Ga(i, o, u) {
                return u ? (i.push(fs(o, u)), true) : false;
              }
              __name(Ga, "Ga");
              function Pc(i, o) {
                var u = [];
                Ga(u, "enumerable", oa(i.enumerable)), Ga(u, "configurable", oa(i.configurable));
                var b = Ga(u, "writable", oa(i.writable));
                b = Ga(u, "value", i.value) || b;
                var Y = Ga(u, "get", i.get);
                return Y = Ga(u, "set", i.set) || Y, e.Debug.assert(!(b && Y), "A PropertyDescriptor may not be both an accessor descriptor and a data descriptor."), Ut(u, !o);
              }
              __name(Pc, "Pc");
              function Nc(i, o) {
                switch (i.kind) {
                  case 214:
                    return Ne(i, o);
                  case 213:
                    return p(i, i.type, o);
                  case 231:
                    return ro(i, o, i.type);
                  case 235:
                    return to(i, o, i.type);
                  case 232:
                    return Oi(i, o);
                  case 353:
                    return Tc(i, o);
                }
              }
              __name(Nc, "Nc");
              function xu(i) {
                return e.isParenthesizedExpression(i) && e.nodeIsSynthesized(i) && e.nodeIsSynthesized(e.getSourceMapRange(i)) && e.nodeIsSynthesized(e.getCommentRange(i)) && !e.some(e.getSyntheticLeadingComments(i)) && !e.some(e.getSyntheticTrailingComments(i));
              }
              __name(xu, "xu");
              function Ic(i, o, u) {
                return u === void 0 && (u = 15), i && e.isOuterExpression(i, u) && !xu(i) ? Nc(i, Ic(i.expression, o)) : o;
              }
              __name(Ic, "Ic");
              function Ts(i, o, u) {
                if (!o)
                  return i;
                var b = js(o, o.label, e.isLabeledStatement(o.statement) ? Ts(i, o.statement) : i);
                return u && u(o), b;
              }
              __name(Ts, "Ts");
              function T_(i, o) {
                var u = e.skipParentheses(i);
                switch (u.kind) {
                  case 79:
                    return o;
                  case 108:
                  case 8:
                  case 9:
                  case 10:
                    return false;
                  case 206:
                    var b = u.elements;
                    return b.length !== 0;
                  case 207:
                    return u.properties.length > 0;
                  default:
                    return true;
                }
              }
              __name(T_, "T_");
              function Oc(i, o, u, b) {
                b === void 0 && (b = false);
                var Y = e.skipOuterExpressions(i, 15), Ke, Or;
                return e.isSuperProperty(Y) ? (Ke = ot(), Or = Y) : e.isSuperKeyword(Y) ? (Ke = ot(), Or = u !== void 0 && u < 2 ? e.setTextRange(pt("_super"), Y) : Y) : e.getEmitFlags(Y) & 4096 ? (Ke = vs(), Or = be().parenthesizeLeftSideOfAccess(Y, false)) : e.isPropertyAccessExpression(Y) ? T_(Y.expression, b) ? (Ke = K(o), Or = Ht(e.setTextRange(Ee.createAssignment(Ke, Y.expression), Y.expression), Y.name), e.setTextRange(Or, Y)) : (Ke = Y.expression, Or = Y) : e.isElementAccessExpression(Y) ? T_(Y.expression, b) ? (Ke = K(o), Or = qi(e.setTextRange(Ee.createAssignment(Ke, Y.expression), Y.expression), Y.argumentExpression), e.setTextRange(Or, Y)) : (Ke = Y.expression, Or = Y) : (Ke = vs(), Or = be().parenthesizeLeftSideOfAccess(i, false)), { target: Or, thisArg: Ke };
              }
              __name(Oc, "Oc");
              function d(i, o) {
                return Ht(ne(Ut([Yn(void 0, "value", [mt(void 0, void 0, i, void 0, void 0, void 0)], l([Zr(o)]))])), "value");
              }
              __name(d, "d");
              function P(i) {
                return i.length > 10 ? b_(i) : e.reduceLeft(i, Ee.createComma);
              }
              __name(P, "P");
              function $(i, o, u, b) {
                b === void 0 && (b = 0);
                var Y = e.getNameOfDeclaration(i);
                if (Y && e.isIdentifier(Y) && !e.isGeneratedIdentifier(Y)) {
                  var Ke = e.setParent(e.setTextRange(hs(Y), Y), Y.parent);
                  return b |= e.getEmitFlags(Y), u || (b |= 48), o || (b |= 1536), b && e.setEmitFlags(Ke, b), Ke;
                }
                return ft(i);
              }
              __name($, "$");
              function ce(i, o, u) {
                return $(i, o, u, 49152);
              }
              __name(ce, "ce");
              function Pe(i, o, u) {
                return $(i, o, u, 16384);
              }
              __name(Pe, "Pe");
              function We(i, o, u) {
                return $(i, o, u, 8192);
              }
              __name(We, "We");
              function Er(i, o, u) {
                return $(i, o, u);
              }
              __name(Er, "Er");
              function Rr(i, o, u, b) {
                var Y = Ht(i, e.nodeIsSynthesized(o) ? o : hs(o));
                e.setTextRange(Y, o);
                var Ke = 0;
                return b || (Ke |= 48), u || (Ke |= 1536), Ke && e.setEmitFlags(Y, Ke), Y;
              }
              __name(Rr, "Rr");
              function Fr(i, o, u, b) {
                return i && e.hasSyntacticModifier(o, 1) ? Rr(i, $(o), u, b) : We(o, u, b);
              }
              __name(Fr, "Fr");
              function et(i, o, u, b) {
                var Y = Wt(i, o, 0, u);
                return pn(i, o, Y, b);
              }
              __name(et, "et");
              function xt(i) {
                return e.isStringLiteral(i.expression) && i.expression.text === "use strict";
              }
              __name(xt, "xt");
              function Gt() {
                return e.startOnNewLine(Zr(f("use strict")));
              }
              __name(Gt, "Gt");
              function Wt(i, o, u, b) {
                u === void 0 && (u = 0), e.Debug.assert(o.length === 0, "Prologue directives should be at the first statement in the target statements array");
                for (var Y = false, Ke = i.length; u < Ke; ) {
                  var Or = i[u];
                  if (e.isPrologueDirective(Or))
                    xt(Or) && (Y = true), o.push(Or);
                  else
                    break;
                  u++;
                }
                return b && !Y && o.push(Gt()), u;
              }
              __name(Wt, "Wt");
              function pn(i, o, u, b, Y) {
                Y === void 0 && (Y = e.returnTrue);
                for (var Ke = i.length; u !== void 0 && u < Ke; ) {
                  var Or = i[u];
                  if (e.getEmitFlags(Or) & 1048576 && Y(Or))
                    e.append(o, b ? e.visitNode(Or, b, e.isStatement) : Or);
                  else
                    break;
                  u++;
                }
                return u;
              }
              __name(pn, "pn");
              function Pn(i) {
                var o = e.findUseStrictPrologue(i);
                return o ? i : e.setTextRange(we(A([Gt()], i, true)), i);
              }
              __name(Pn, "Pn");
              function _i(i) {
                return e.Debug.assert(e.every(i, e.isStatementOrBlock), "Cannot lift nodes to a Block."), e.singleOrUndefined(i) || l(i);
              }
              __name(_i, "_i");
              function Ln(i, o, u) {
                for (var b = u; b < i.length && o(i[b]); )
                  b++;
                return b;
              }
              __name(Ln, "Ln");
              function ha(i, o) {
                if (!e.some(o))
                  return i;
                var u = Ln(i, e.isPrologueDirective, 0), b = Ln(i, e.isHoistedFunction, u), Y = Ln(i, e.isHoistedVariableStatement, b), Ke = Ln(o, e.isPrologueDirective, 0), Or = Ln(o, e.isHoistedFunction, Ke), kt = Ln(o, e.isHoistedVariableStatement, Or), $n = Ln(o, e.isCustomPrologue, kt);
                e.Debug.assert($n === o.length, "Expected declarations to be valid standard or custom prologues");
                var fa = e.isNodeArray(i) ? i.slice() : i;
                if ($n > kt && fa.splice.apply(fa, A([Y, 0], o.slice(kt, $n), false)), kt > Or && fa.splice.apply(fa, A([b, 0], o.slice(Or, kt), false)), Or > Ke && fa.splice.apply(fa, A([u, 0], o.slice(Ke, Or), false)), Ke > 0)
                  if (u === 0)
                    fa.splice.apply(fa, A([0, 0], o.slice(0, Ke), false));
                  else {
                    for (var Bo = new e.Map(), $a = 0; $a < u; $a++) {
                      var Ss = i[$a];
                      Bo.set(Ss.expression.text, true);
                    }
                    for (var $a = Ke - 1; $a >= 0; $a--) {
                      var Cs = o[$a];
                      Bo.has(Cs.expression.text) || fa.unshift(Cs);
                    }
                  }
                return e.isNodeArray(i) ? e.setTextRange(we(fa, i.hasTrailingComma), i) : i;
              }
              __name(ha, "ha");
              function Di(i, o) {
                var u, b;
                return typeof o == "number" ? b = Nr(o) : b = o, e.isTypeParameterDeclaration(i) ? Zt(i, b, i.name, i.constraint, i.default) : e.isParameter(i) ? at(i, b, i.dotDotDotToken, i.name, i.questionToken, i.type, i.initializer) : e.isConstructorTypeNode(i) ? lr(i, b, i.typeParameters, i.parameters, i.type) : e.isPropertySignature(i) ? Sr(i, b, i.name, i.questionToken, i.type) : e.isPropertyDeclaration(i) ? Ct(i, b, i.name, (u = i.questionToken) !== null && u !== void 0 ? u : i.exclamationToken, i.type, i.initializer) : e.isMethodSignature(i) ? cn(i, b, i.name, i.questionToken, i.typeParameters, i.parameters, i.type) : e.isMethodDeclaration(i) ? yn(i, b, i.asteriskToken, i.name, i.questionToken, i.typeParameters, i.parameters, i.type, i.body) : e.isConstructorDeclaration(i) ? ei(i, b, i.parameters, i.body) : e.isGetAccessorDeclaration(i) ? bi(i, b, i.name, i.parameters, i.type, i.body) : e.isSetAccessorDeclaration(i) ? oi(i, b, i.name, i.parameters, i.body) : e.isIndexSignatureDeclaration(i) ? Fn(i, b, i.parameters, i.type) : e.isFunctionExpression(i) ? it(i, b, i.asteriskToken, i.name, i.typeParameters, i.parameters, i.type, i.body) : e.isArrowFunction(i) ? Et(i, b, i.typeParameters, i.parameters, i.type, i.equalsGreaterThanToken, i.body) : e.isClassExpression(i) ? bo(i, b, i.name, i.typeParameters, i.heritageClauses, i.members) : e.isVariableStatement(i) ? ke(i, b, i.declarationList) : e.isFunctionDeclaration(i) ? ao(i, b, i.asteriskToken, i.name, i.typeParameters, i.parameters, i.type, i.body) : e.isClassDeclaration(i) ? k_(i, b, i.name, i.typeParameters, i.heritageClauses, i.members) : e.isInterfaceDeclaration(i) ? P_(i, b, i.name, i.typeParameters, i.heritageClauses, i.members) : e.isTypeAliasDeclaration(i) ? N_(i, b, i.name, i.typeParameters, i.type) : e.isEnumDeclaration(i) ? la(i, b, i.name, i.members) : e.isModuleDeclaration(i) ? O_(i, b, i.name, i.body) : e.isImportEqualsDeclaration(i) ? J_(i, b, i.isTypeOnly, i.name, i.moduleReference) : e.isImportDeclaration(i) ? B_(i, b, i.importClause, i.moduleSpecifier, i.assertClause) : e.isExportAssignment(i) ? Ua(i, b, i.expression) : e.isExportDeclaration(i) ? $s(i, b, i.isTypeOnly, i.exportClause, i.moduleSpecifier, i.assertClause) : e.Debug.assertNever(i);
              }
              __name(Di, "Di");
              function Xn(i) {
                return i ? we(i) : void 0;
              }
              __name(Xn, "Xn");
              function Pi(i) {
                return typeof i == "string" ? pt(i) : i;
              }
              __name(Pi, "Pi");
              function oa(i) {
                return typeof i == "string" ? f(i) : typeof i == "number" ? ut(i) : typeof i == "boolean" ? i ? re() : de() : i;
              }
              __name(oa, "oa");
              function Xa(i) {
                return typeof i == "number" ? pr(i) : i;
              }
              __name(Xa, "Xa");
              function ii(i) {
                return i && e.isNotEmittedStatement(i) ? e.setTextRange(qe(cr(), i), i) : i;
              }
              __name(ii, "ii");
            }
            __name(s, "s");
            e.createNodeFactory = s;
            function q(G, pe) {
              return G !== pe && e.setTextRange(G, pe), G;
            }
            __name(q, "q");
            function F(G, pe) {
              return G !== pe && (qe(G, pe), e.setTextRange(G, pe)), G;
            }
            __name(F, "F");
            function fe(G) {
              switch (G) {
                case 346:
                  return "type";
                case 344:
                  return "returns";
                case 345:
                  return "this";
                case 342:
                  return "enum";
                case 333:
                  return "author";
                case 335:
                  return "class";
                case 336:
                  return "public";
                case 337:
                  return "private";
                case 338:
                  return "protected";
                case 339:
                  return "readonly";
                case 340:
                  return "override";
                case 347:
                  return "template";
                case 348:
                  return "typedef";
                case 343:
                  return "param";
                case 350:
                  return "prop";
                case 341:
                  return "callback";
                case 331:
                  return "augments";
                case 332:
                  return "implements";
                default:
                  return e.Debug.fail("Unsupported kind: ".concat(e.Debug.formatSyntaxKind(G)));
              }
            }
            __name(fe, "fe");
            var Te, Se = {};
            function J(G, pe) {
              switch (Te || (Te = e.createScanner(99, false, 0)), G) {
                case 14:
                  Te.setText("`" + pe + "`");
                  break;
                case 15:
                  Te.setText("`" + pe + "${");
                  break;
                case 16:
                  Te.setText("}" + pe + "${");
                  break;
                case 17:
                  Te.setText("}" + pe + "`");
                  break;
              }
              var j = Te.scan();
              if (j === 19 && (j = Te.reScanTemplateToken(false)), Te.isUnterminated())
                return Te.setText(void 0), Se;
              var be;
              switch (j) {
                case 14:
                case 15:
                case 16:
                case 17:
                  be = Te.getTokenValue();
                  break;
              }
              return be === void 0 || Te.scan() !== 1 ? (Te.setText(void 0), Se) : (Te.setText(void 0), be);
            }
            __name(J, "J");
            function se(G) {
              return Q(G) & -67108865;
            }
            __name(se, "se");
            function Le(G, pe) {
              return pe | G.transformFlags & 134234112;
            }
            __name(Le, "Le");
            function Q(G) {
              if (!G)
                return 0;
              var pe = G.transformFlags & ~W(G.kind);
              return e.isNamedDeclaration(G) && e.isPropertyName(G.name) ? Le(G.name, pe) : pe;
            }
            __name(Q, "Q");
            function Be(G) {
              return G ? G.transformFlags : 0;
            }
            __name(Be, "Be");
            function je(G) {
              for (var pe = 0, j = 0, be = G; j < be.length; j++) {
                var $e = be[j];
                pe |= Q($e);
              }
              G.transformFlags = pe;
            }
            __name(je, "je");
            function W(G) {
              if (G >= 179 && G <= 202)
                return -2;
              switch (G) {
                case 210:
                case 211:
                case 206:
                  return -2147450880;
                case 264:
                  return -1941676032;
                case 166:
                  return -2147483648;
                case 216:
                  return -2072174592;
                case 215:
                case 259:
                  return -1937940480;
                case 258:
                  return -2146893824;
                case 260:
                case 228:
                  return -2147344384;
                case 173:
                  return -1937948672;
                case 169:
                  return -2013249536;
                case 171:
                case 174:
                case 175:
                  return -2005057536;
                case 131:
                case 148:
                case 160:
                case 144:
                case 152:
                case 149:
                case 134:
                case 153:
                case 114:
                case 165:
                case 168:
                case 170:
                case 176:
                case 177:
                case 178:
                case 261:
                case 262:
                  return -2;
                case 207:
                  return -2147278848;
                case 295:
                  return -2147418112;
                case 203:
                case 204:
                  return -2147450880;
                case 213:
                case 235:
                case 231:
                case 353:
                case 214:
                case 106:
                  return -2147483648;
                case 208:
                case 209:
                  return -2147483648;
                default:
                  return -2147483648;
              }
            }
            __name(W, "W");
            e.getTransformFlagsSubtreeExclusions = W;
            var B = e.createBaseNodeFactory();
            function U(G) {
              return G.flags |= 8, G;
            }
            __name(U, "U");
            var m = { createBaseSourceFileNode: function(G) {
              return U(B.createBaseSourceFileNode(G));
            }, createBaseIdentifierNode: function(G) {
              return U(B.createBaseIdentifierNode(G));
            }, createBasePrivateIdentifierNode: function(G) {
              return U(B.createBasePrivateIdentifierNode(G));
            }, createBaseTokenNode: function(G) {
              return U(B.createBaseTokenNode(G));
            }, createBaseNode: function(G) {
              return U(B.createBaseNode(G));
            } };
            e.factory = s(4, m);
            function v(G, pe, j) {
              var be, $e, Re, Fe, dr, ze, ve, er, ar, Cr;
              e.isString(G) ? (Re = "", Fe = G, dr = G.length, ze = pe, ve = j) : (e.Debug.assert(pe === "js" || pe === "dts"), Re = (pe === "js" ? G.javascriptPath : G.declarationPath) || "", ze = pe === "js" ? G.javascriptMapPath : G.declarationMapPath, er = /* @__PURE__ */ __name(function() {
                return pe === "js" ? G.javascriptText : G.declarationText;
              }, "er"), ar = /* @__PURE__ */ __name(function() {
                return pe === "js" ? G.javascriptMapText : G.declarationMapText;
              }, "ar"), dr = /* @__PURE__ */ __name(function() {
                return er().length;
              }, "dr"), G.buildInfo && G.buildInfo.bundle && (e.Debug.assert(j === void 0 || typeof j == "boolean"), be = j, $e = pe === "js" ? G.buildInfo.bundle.js : G.buildInfo.bundle.dts, Cr = G.oldFileOfCurrentEmit));
              var Ce = Cr ? O(e.Debug.checkDefined($e)) : g($e, be, dr);
              return Ce.fileName = Re, Ce.sourceMapPath = ze, Ce.oldFileOfCurrentEmit = Cr, er && ar ? (Object.defineProperty(Ce, "text", { get: er }), Object.defineProperty(Ce, "sourceMapText", { get: ar })) : (e.Debug.assert(!Cr), Ce.text = Fe != null ? Fe : "", Ce.sourceMapText = ve), Ce;
            }
            __name(v, "v");
            e.createUnparsedSourceFile = v;
            function g(G, pe, j) {
              for (var be, $e, Re, Fe, dr, ze, ve, er, ar = 0, Cr = G ? G.sections : e.emptyArray; ar < Cr.length; ar++) {
                var Ce = Cr[ar];
                switch (Ce.kind) {
                  case "prologue":
                    be = e.append(be, e.setTextRange(e.factory.createUnparsedPrologue(Ce.data), Ce));
                    break;
                  case "emitHelpers":
                    $e = e.append($e, e.getAllUnscopedEmitHelpers().get(Ce.data));
                    break;
                  case "no-default-lib":
                    er = true;
                    break;
                  case "reference":
                    Re = e.append(Re, { pos: -1, end: -1, fileName: Ce.data });
                    break;
                  case "type":
                    Fe = e.append(Fe, { pos: -1, end: -1, fileName: Ce.data });
                    break;
                  case "type-import":
                    Fe = e.append(Fe, { pos: -1, end: -1, fileName: Ce.data, resolutionMode: e.ModuleKind.ESNext });
                    break;
                  case "type-require":
                    Fe = e.append(Fe, { pos: -1, end: -1, fileName: Ce.data, resolutionMode: e.ModuleKind.CommonJS });
                    break;
                  case "lib":
                    dr = e.append(dr, { pos: -1, end: -1, fileName: Ce.data });
                    break;
                  case "prepend":
                    for (var Xe = void 0, gr = 0, X = Ce.texts; gr < X.length; gr++) {
                      var Ee = X[gr];
                      (!pe || Ee.kind !== "internal") && (Xe = e.append(Xe, e.setTextRange(e.factory.createUnparsedTextLike(Ee.data, Ee.kind === "internal"), Ee)));
                    }
                    ze = e.addRange(ze, Xe), ve = e.append(ve, e.factory.createUnparsedPrepend(Ce.data, Xe != null ? Xe : e.emptyArray));
                    break;
                  case "internal":
                    if (pe) {
                      ve || (ve = []);
                      break;
                    }
                  case "text":
                    ve = e.append(ve, e.setTextRange(e.factory.createUnparsedTextLike(Ce.data, Ce.kind === "internal"), Ce));
                    break;
                  default:
                    e.Debug.assertNever(Ce);
                }
              }
              if (!ve) {
                var we = e.factory.createUnparsedTextLike(void 0, false);
                e.setTextRangePosWidth(we, 0, typeof j == "function" ? j() : j), ve = [we];
              }
              var he = e.parseNodeFactory.createUnparsedSource(be != null ? be : e.emptyArray, void 0, ve);
              return e.setEachParent(be, he), e.setEachParent(ve, he), e.setEachParent(ze, he), he.hasNoDefaultLib = er, he.helpers = $e, he.referencedFiles = Re || e.emptyArray, he.typeReferenceDirectives = Fe, he.libReferenceDirectives = dr || e.emptyArray, he;
            }
            __name(g, "g");
            function O(G) {
              for (var pe, j, be = 0, $e = G.sections; be < $e.length; be++) {
                var Re = $e[be];
                switch (Re.kind) {
                  case "internal":
                  case "text":
                    pe = e.append(pe, e.setTextRange(e.factory.createUnparsedTextLike(Re.data, Re.kind === "internal"), Re));
                    break;
                  case "no-default-lib":
                  case "reference":
                  case "type":
                  case "type-import":
                  case "type-require":
                  case "lib":
                    j = e.append(j, e.setTextRange(e.factory.createUnparsedSyntheticReference(Re), Re));
                    break;
                  case "prologue":
                  case "emitHelpers":
                  case "prepend":
                    break;
                  default:
                    e.Debug.assertNever(Re);
                }
              }
              var Fe = e.factory.createUnparsedSource(e.emptyArray, j, pe != null ? pe : e.emptyArray);
              return e.setEachParent(j, Fe), e.setEachParent(pe, Fe), Fe.helpers = e.map(G.sources && G.sources.helpers, function(dr) {
                return e.getAllUnscopedEmitHelpers().get(dr);
              }), Fe;
            }
            __name(O, "O");
            function S(G, pe, j, be, $e, Re, Fe, dr, ze, ve, er) {
              var ar = e.parseNodeFactory.createInputFiles();
              if (e.isString(G))
                ar.javascriptText = G, ar.javascriptMapPath = j, ar.javascriptMapText = be, ar.declarationText = pe, ar.declarationMapPath = $e, ar.declarationMapText = Re, ar.javascriptPath = Fe, ar.declarationPath = dr, ar.buildInfoPath = ze, ar.buildInfo = ve, ar.oldFileOfCurrentEmit = er;
              else {
                var Cr = new e.Map(), Ce = /* @__PURE__ */ __name(function(Ee) {
                  if (Ee !== void 0) {
                    var we = Cr.get(Ee);
                    return we === void 0 && (we = G(Ee), Cr.set(Ee, we !== void 0 ? we : false)), we !== false ? we : void 0;
                  }
                }, "Ce"), Xe = /* @__PURE__ */ __name(function(Ee) {
                  var we = Ce(Ee);
                  return we !== void 0 ? we : "/* Input file ".concat(Ee, ` was missing */\r
`);
                }, "Xe"), gr, X = /* @__PURE__ */ __name(function(Ee) {
                  var we;
                  if (gr === void 0) {
                    var he = Ee();
                    gr = he !== void 0 && (we = e.getBuildInfo(ar.buildInfoPath, he)) !== null && we !== void 0 ? we : false;
                  }
                  return gr || void 0;
                }, "X");
                ar.javascriptPath = pe, ar.javascriptMapPath = j, ar.declarationPath = e.Debug.checkDefined(be), ar.declarationMapPath = $e, ar.buildInfoPath = Re, Object.defineProperties(ar, { javascriptText: { get: function() {
                  return Xe(pe);
                } }, javascriptMapText: { get: function() {
                  return Ce(j);
                } }, declarationText: { get: function() {
                  return Xe(e.Debug.checkDefined(be));
                } }, declarationMapText: { get: function() {
                  return Ce($e);
                } }, buildInfo: { get: function() {
                  return X(function() {
                    return Ce(Re);
                  });
                } } });
              }
              return ar;
            }
            __name(S, "S");
            e.createInputFiles = S;
            var te;
            function Je(G, pe, j) {
              return new (te || (te = e.objectAllocator.getSourceMapSourceConstructor()))(G, pe, j);
            }
            __name(Je, "Je");
            e.createSourceMapSource = Je;
            function qe(G, pe) {
              if (G.original = pe, pe) {
                var j = pe.emitNode;
                j && (G.emitNode = ge(j, G.emitNode));
              }
              return G;
            }
            __name(qe, "qe");
            e.setOriginalNode = qe;
            function ge(G, pe) {
              var j = G.flags, be = G.leadingComments, $e = G.trailingComments, Re = G.commentRange, Fe = G.sourceMapRange, dr = G.tokenSourceMapRanges, ze = G.constantValue, ve = G.helpers, er = G.startsOnNewLine, ar = G.snippetElement;
              if (pe || (pe = {}), be && (pe.leadingComments = e.addRange(be.slice(), pe.leadingComments)), $e && (pe.trailingComments = e.addRange($e.slice(), pe.trailingComments)), j && (pe.flags = j & -268435457), Re && (pe.commentRange = Re), Fe && (pe.sourceMapRange = Fe), dr && (pe.tokenSourceMapRanges = ie(dr, pe.tokenSourceMapRanges)), ze !== void 0 && (pe.constantValue = ze), ve)
                for (var Cr = 0, Ce = ve; Cr < Ce.length; Cr++) {
                  var Xe = Ce[Cr];
                  pe.helpers = e.appendIfUnique(pe.helpers, Xe);
                }
              return er !== void 0 && (pe.startsOnNewLine = er), ar !== void 0 && (pe.snippetElement = ar), pe;
            }
            __name(ge, "ge");
            function ie(G, pe) {
              pe || (pe = []);
              for (var j in G)
                pe[j] = G[j];
              return pe;
            }
            __name(ie, "ie");
          })(N || (N = {}));
          var N;
          (function(e) {
            function t(Re) {
              var Fe;
              if (Re.emitNode)
                e.Debug.assert(!(Re.emitNode.flags & 268435456), "Invalid attempt to mutate an immutable node.");
              else {
                if (e.isParseTreeNode(Re)) {
                  if (Re.kind === 308)
                    return Re.emitNode = { annotatedNodes: [Re] };
                  var dr = (Fe = e.getSourceFileOfNode(e.getParseTreeNode(e.getSourceFileOfNode(Re)))) !== null && Fe !== void 0 ? Fe : e.Debug.fail("Could not determine parsed source file.");
                  t(dr).annotatedNodes.push(Re);
                }
                Re.emitNode = {};
              }
              return Re.emitNode;
            }
            __name(t, "t");
            e.getOrCreateEmitNode = t;
            function x(Re) {
              var Fe, dr, ze = (dr = (Fe = e.getSourceFileOfNode(e.getParseTreeNode(Re))) === null || Fe === void 0 ? void 0 : Fe.emitNode) === null || dr === void 0 ? void 0 : dr.annotatedNodes;
              if (ze)
                for (var ve = 0, er = ze; ve < er.length; ve++) {
                  var ar = er[ve];
                  ar.emitNode = void 0;
                }
            }
            __name(x, "x");
            e.disposeEmitNodes = x;
            function s(Re) {
              var Fe = t(Re);
              return Fe.flags |= 1536, Fe.leadingComments = void 0, Fe.trailingComments = void 0, Re;
            }
            __name(s, "s");
            e.removeAllComments = s;
            function q(Re, Fe) {
              return t(Re).flags = Fe, Re;
            }
            __name(q, "q");
            e.setEmitFlags = q;
            function F(Re, Fe) {
              var dr = t(Re);
              return dr.flags = dr.flags | Fe, Re;
            }
            __name(F, "F");
            e.addEmitFlags = F;
            function fe(Re) {
              var Fe, dr;
              return (dr = (Fe = Re.emitNode) === null || Fe === void 0 ? void 0 : Fe.sourceMapRange) !== null && dr !== void 0 ? dr : Re;
            }
            __name(fe, "fe");
            e.getSourceMapRange = fe;
            function Te(Re, Fe) {
              return t(Re).sourceMapRange = Fe, Re;
            }
            __name(Te, "Te");
            e.setSourceMapRange = Te;
            function Se(Re, Fe) {
              var dr, ze;
              return (ze = (dr = Re.emitNode) === null || dr === void 0 ? void 0 : dr.tokenSourceMapRanges) === null || ze === void 0 ? void 0 : ze[Fe];
            }
            __name(Se, "Se");
            e.getTokenSourceMapRange = Se;
            function J(Re, Fe, dr) {
              var ze, ve = t(Re), er = (ze = ve.tokenSourceMapRanges) !== null && ze !== void 0 ? ze : ve.tokenSourceMapRanges = [];
              return er[Fe] = dr, Re;
            }
            __name(J, "J");
            e.setTokenSourceMapRange = J;
            function se(Re) {
              var Fe;
              return (Fe = Re.emitNode) === null || Fe === void 0 ? void 0 : Fe.startsOnNewLine;
            }
            __name(se, "se");
            e.getStartsOnNewLine = se;
            function Le(Re, Fe) {
              return t(Re).startsOnNewLine = Fe, Re;
            }
            __name(Le, "Le");
            e.setStartsOnNewLine = Le;
            function Q(Re) {
              var Fe, dr;
              return (dr = (Fe = Re.emitNode) === null || Fe === void 0 ? void 0 : Fe.commentRange) !== null && dr !== void 0 ? dr : Re;
            }
            __name(Q, "Q");
            e.getCommentRange = Q;
            function Be(Re, Fe) {
              return t(Re).commentRange = Fe, Re;
            }
            __name(Be, "Be");
            e.setCommentRange = Be;
            function je(Re) {
              var Fe;
              return (Fe = Re.emitNode) === null || Fe === void 0 ? void 0 : Fe.leadingComments;
            }
            __name(je, "je");
            e.getSyntheticLeadingComments = je;
            function W(Re, Fe) {
              return t(Re).leadingComments = Fe, Re;
            }
            __name(W, "W");
            e.setSyntheticLeadingComments = W;
            function B(Re, Fe, dr, ze) {
              return W(Re, e.append(je(Re), { kind: Fe, pos: -1, end: -1, hasTrailingNewLine: ze, text: dr }));
            }
            __name(B, "B");
            e.addSyntheticLeadingComment = B;
            function U(Re) {
              var Fe;
              return (Fe = Re.emitNode) === null || Fe === void 0 ? void 0 : Fe.trailingComments;
            }
            __name(U, "U");
            e.getSyntheticTrailingComments = U;
            function m(Re, Fe) {
              return t(Re).trailingComments = Fe, Re;
            }
            __name(m, "m");
            e.setSyntheticTrailingComments = m;
            function v(Re, Fe, dr, ze) {
              return m(Re, e.append(U(Re), { kind: Fe, pos: -1, end: -1, hasTrailingNewLine: ze, text: dr }));
            }
            __name(v, "v");
            e.addSyntheticTrailingComment = v;
            function g(Re, Fe) {
              W(Re, je(Fe)), m(Re, U(Fe));
              var dr = t(Fe);
              return dr.leadingComments = void 0, dr.trailingComments = void 0, Re;
            }
            __name(g, "g");
            e.moveSyntheticComments = g;
            function O(Re) {
              var Fe;
              return (Fe = Re.emitNode) === null || Fe === void 0 ? void 0 : Fe.constantValue;
            }
            __name(O, "O");
            e.getConstantValue = O;
            function S(Re, Fe) {
              var dr = t(Re);
              return dr.constantValue = Fe, Re;
            }
            __name(S, "S");
            e.setConstantValue = S;
            function te(Re, Fe) {
              var dr = t(Re);
              return dr.helpers = e.append(dr.helpers, Fe), Re;
            }
            __name(te, "te");
            e.addEmitHelper = te;
            function Je(Re, Fe) {
              if (e.some(Fe))
                for (var dr = t(Re), ze = 0, ve = Fe; ze < ve.length; ze++) {
                  var er = ve[ze];
                  dr.helpers = e.appendIfUnique(dr.helpers, er);
                }
              return Re;
            }
            __name(Je, "Je");
            e.addEmitHelpers = Je;
            function qe(Re, Fe) {
              var dr, ze = (dr = Re.emitNode) === null || dr === void 0 ? void 0 : dr.helpers;
              return ze ? e.orderedRemoveItem(ze, Fe) : false;
            }
            __name(qe, "qe");
            e.removeEmitHelper = qe;
            function ge(Re) {
              var Fe;
              return (Fe = Re.emitNode) === null || Fe === void 0 ? void 0 : Fe.helpers;
            }
            __name(ge, "ge");
            e.getEmitHelpers = ge;
            function ie(Re, Fe, dr) {
              var ze = Re.emitNode, ve = ze && ze.helpers;
              if (!!e.some(ve)) {
                for (var er = t(Fe), ar = 0, Cr = 0; Cr < ve.length; Cr++) {
                  var Ce = ve[Cr];
                  dr(Ce) ? (ar++, er.helpers = e.appendIfUnique(er.helpers, Ce)) : ar > 0 && (ve[Cr - ar] = Ce);
                }
                ar > 0 && (ve.length -= ar);
              }
            }
            __name(ie, "ie");
            e.moveEmitHelpers = ie;
            function G(Re) {
              var Fe;
              return (Fe = Re.emitNode) === null || Fe === void 0 ? void 0 : Fe.snippetElement;
            }
            __name(G, "G");
            e.getSnippetElement = G;
            function pe(Re, Fe) {
              var dr = t(Re);
              return dr.snippetElement = Fe, Re;
            }
            __name(pe, "pe");
            e.setSnippetElement = pe;
            function j(Re) {
              return t(Re).flags |= 134217728, Re;
            }
            __name(j, "j");
            e.ignoreSourceNewlines = j;
            function be(Re, Fe) {
              var dr = t(Re);
              return dr.typeNode = Fe, Re;
            }
            __name(be, "be");
            e.setTypeNode = be;
            function $e(Re) {
              var Fe;
              return (Fe = Re.emitNode) === null || Fe === void 0 ? void 0 : Fe.typeNode;
            }
            __name($e, "$e");
            e.getTypeNode = $e;
          })(N || (N = {}));
          var N;
          (function(e) {
            function t(Te) {
              var Se = Te.factory, J = e.memoize(function() {
                return e.setEmitFlags(Se.createTrue(), 268435456);
              }), se = e.memoize(function() {
                return e.setEmitFlags(Se.createFalse(), 268435456);
              });
              return { getUnscopedHelperName: Le, createDecorateHelper: Q, createMetadataHelper: Be, createParamHelper: je, createAssignHelper: W, createAwaitHelper: B, createAsyncGeneratorHelper: U, createAsyncDelegatorHelper: m, createAsyncValuesHelper: v, createRestHelper: g, createAwaiterHelper: O, createExtendsHelper: S, createTemplateObjectHelper: te, createSpreadArrayHelper: Je, createValuesHelper: qe, createReadHelper: ge, createGeneratorHelper: ie, createCreateBindingHelper: G, createImportStarHelper: pe, createImportStarCallbackHelper: j, createImportDefaultHelper: be, createExportStarHelper: $e, createClassPrivateFieldGetHelper: Re, createClassPrivateFieldSetHelper: Fe, createClassPrivateFieldInHelper: dr };
              function Le(ze) {
                return e.setEmitFlags(Se.createIdentifier(ze), 4098);
              }
              __name(Le, "Le");
              function Q(ze, ve, er, ar) {
                Te.requestEmitHelper(e.decorateHelper);
                var Cr = [];
                return Cr.push(Se.createArrayLiteralExpression(ze, true)), Cr.push(ve), er && (Cr.push(er), ar && Cr.push(ar)), Se.createCallExpression(Le("__decorate"), void 0, Cr);
              }
              __name(Q, "Q");
              function Be(ze, ve) {
                return Te.requestEmitHelper(e.metadataHelper), Se.createCallExpression(Le("__metadata"), void 0, [Se.createStringLiteral(ze), ve]);
              }
              __name(Be, "Be");
              function je(ze, ve, er) {
                return Te.requestEmitHelper(e.paramHelper), e.setTextRange(Se.createCallExpression(Le("__param"), void 0, [Se.createNumericLiteral(ve + ""), ze]), er);
              }
              __name(je, "je");
              function W(ze) {
                return e.getEmitScriptTarget(Te.getCompilerOptions()) >= 2 ? Se.createCallExpression(Se.createPropertyAccessExpression(Se.createIdentifier("Object"), "assign"), void 0, ze) : (Te.requestEmitHelper(e.assignHelper), Se.createCallExpression(Le("__assign"), void 0, ze));
              }
              __name(W, "W");
              function B(ze) {
                return Te.requestEmitHelper(e.awaitHelper), Se.createCallExpression(Le("__await"), void 0, [ze]);
              }
              __name(B, "B");
              function U(ze, ve) {
                return Te.requestEmitHelper(e.awaitHelper), Te.requestEmitHelper(e.asyncGeneratorHelper), (ze.emitNode || (ze.emitNode = {})).flags |= 786432, Se.createCallExpression(Le("__asyncGenerator"), void 0, [ve ? Se.createThis() : Se.createVoidZero(), Se.createIdentifier("arguments"), ze]);
              }
              __name(U, "U");
              function m(ze) {
                return Te.requestEmitHelper(e.awaitHelper), Te.requestEmitHelper(e.asyncDelegator), Se.createCallExpression(Le("__asyncDelegator"), void 0, [ze]);
              }
              __name(m, "m");
              function v(ze) {
                return Te.requestEmitHelper(e.asyncValues), Se.createCallExpression(Le("__asyncValues"), void 0, [ze]);
              }
              __name(v, "v");
              function g(ze, ve, er, ar) {
                Te.requestEmitHelper(e.restHelper);
                for (var Cr = [], Ce = 0, Xe = 0; Xe < ve.length - 1; Xe++) {
                  var gr = e.getPropertyNameOfBindingOrAssignmentElement(ve[Xe]);
                  if (gr)
                    if (e.isComputedPropertyName(gr)) {
                      e.Debug.assertIsDefined(er, "Encountered computed property name but 'computedTempVariables' argument was not provided.");
                      var X = er[Ce];
                      Ce++, Cr.push(Se.createConditionalExpression(Se.createTypeCheck(X, "symbol"), void 0, X, void 0, Se.createAdd(X, Se.createStringLiteral(""))));
                    } else
                      Cr.push(Se.createStringLiteralFromNode(gr));
                }
                return Se.createCallExpression(Le("__rest"), void 0, [ze, e.setTextRange(Se.createArrayLiteralExpression(Cr), ar)]);
              }
              __name(g, "g");
              function O(ze, ve, er, ar) {
                Te.requestEmitHelper(e.awaiterHelper);
                var Cr = Se.createFunctionExpression(void 0, Se.createToken(41), void 0, void 0, [], void 0, ar);
                return (Cr.emitNode || (Cr.emitNode = {})).flags |= 786432, Se.createCallExpression(Le("__awaiter"), void 0, [ze ? Se.createThis() : Se.createVoidZero(), ve ? Se.createIdentifier("arguments") : Se.createVoidZero(), er ? e.createExpressionFromEntityName(Se, er) : Se.createVoidZero(), Cr]);
              }
              __name(O, "O");
              function S(ze) {
                return Te.requestEmitHelper(e.extendsHelper), Se.createCallExpression(Le("__extends"), void 0, [ze, Se.createUniqueName("_super", 48)]);
              }
              __name(S, "S");
              function te(ze, ve) {
                return Te.requestEmitHelper(e.templateObjectHelper), Se.createCallExpression(Le("__makeTemplateObject"), void 0, [ze, ve]);
              }
              __name(te, "te");
              function Je(ze, ve, er) {
                return Te.requestEmitHelper(e.spreadArrayHelper), Se.createCallExpression(Le("__spreadArray"), void 0, [ze, ve, er ? J() : se()]);
              }
              __name(Je, "Je");
              function qe(ze) {
                return Te.requestEmitHelper(e.valuesHelper), Se.createCallExpression(Le("__values"), void 0, [ze]);
              }
              __name(qe, "qe");
              function ge(ze, ve) {
                return Te.requestEmitHelper(e.readHelper), Se.createCallExpression(Le("__read"), void 0, ve !== void 0 ? [ze, Se.createNumericLiteral(ve + "")] : [ze]);
              }
              __name(ge, "ge");
              function ie(ze) {
                return Te.requestEmitHelper(e.generatorHelper), Se.createCallExpression(Le("__generator"), void 0, [Se.createThis(), ze]);
              }
              __name(ie, "ie");
              function G(ze, ve, er) {
                return Te.requestEmitHelper(e.createBindingHelper), Se.createCallExpression(Le("__createBinding"), void 0, A([Se.createIdentifier("exports"), ze, ve], er ? [er] : [], true));
              }
              __name(G, "G");
              function pe(ze) {
                return Te.requestEmitHelper(e.importStarHelper), Se.createCallExpression(Le("__importStar"), void 0, [ze]);
              }
              __name(pe, "pe");
              function j() {
                return Te.requestEmitHelper(e.importStarHelper), Le("__importStar");
              }
              __name(j, "j");
              function be(ze) {
                return Te.requestEmitHelper(e.importDefaultHelper), Se.createCallExpression(Le("__importDefault"), void 0, [ze]);
              }
              __name(be, "be");
              function $e(ze, ve) {
                return ve === void 0 && (ve = Se.createIdentifier("exports")), Te.requestEmitHelper(e.exportStarHelper), Te.requestEmitHelper(e.createBindingHelper), Se.createCallExpression(Le("__exportStar"), void 0, [ze, ve]);
              }
              __name($e, "$e");
              function Re(ze, ve, er, ar) {
                Te.requestEmitHelper(e.classPrivateFieldGetHelper);
                var Cr;
                return ar ? Cr = [ze, ve, Se.createStringLiteral(er), ar] : Cr = [ze, ve, Se.createStringLiteral(er)], Se.createCallExpression(Le("__classPrivateFieldGet"), void 0, Cr);
              }
              __name(Re, "Re");
              function Fe(ze, ve, er, ar, Cr) {
                Te.requestEmitHelper(e.classPrivateFieldSetHelper);
                var Ce;
                return Cr ? Ce = [ze, ve, er, Se.createStringLiteral(ar), Cr] : Ce = [ze, ve, er, Se.createStringLiteral(ar)], Se.createCallExpression(Le("__classPrivateFieldSet"), void 0, Ce);
              }
              __name(Fe, "Fe");
              function dr(ze, ve) {
                return Te.requestEmitHelper(e.classPrivateFieldInHelper), Se.createCallExpression(Le("__classPrivateFieldIn"), void 0, [ze, ve]);
              }
              __name(dr, "dr");
            }
            __name(t, "t");
            e.createEmitHelperFactory = t;
            function x(Te, Se) {
              return Te === Se || Te.priority === Se.priority ? 0 : Te.priority === void 0 ? 1 : Se.priority === void 0 ? -1 : e.compareValues(Te.priority, Se.priority);
            }
            __name(x, "x");
            e.compareEmitHelpers = x;
            function s(Te) {
              for (var Se = [], J = 1; J < arguments.length; J++)
                Se[J - 1] = arguments[J];
              return function(se) {
                for (var Le = "", Q = 0; Q < Se.length; Q++)
                  Le += Te[Q], Le += se(Se[Q]);
                return Le += Te[Te.length - 1], Le;
              };
            }
            __name(s, "s");
            e.helperString = s, e.decorateHelper = { name: "typescript:decorate", importName: "__decorate", scoped: false, priority: 2, text: `
            var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
                var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
                else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                return c > 3 && r && Object.defineProperty(target, key, r), r;
            };` }, e.metadataHelper = { name: "typescript:metadata", importName: "__metadata", scoped: false, priority: 3, text: `
            var __metadata = (this && this.__metadata) || function (k, v) {
                if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
            };` }, e.paramHelper = { name: "typescript:param", importName: "__param", scoped: false, priority: 4, text: `
            var __param = (this && this.__param) || function (paramIndex, decorator) {
                return function (target, key) { decorator(target, key, paramIndex); }
            };` }, e.assignHelper = { name: "typescript:assign", importName: "__assign", scoped: false, priority: 1, text: `
            var __assign = (this && this.__assign) || function () {
                __assign = Object.assign || function(t) {
                    for (var s, i = 1, n = arguments.length; i < n; i++) {
                        s = arguments[i];
                        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                            t[p] = s[p];
                    }
                    return t;
                };
                return __assign.apply(this, arguments);
            };` }, e.awaitHelper = { name: "typescript:await", importName: "__await", scoped: false, text: `
            var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }` }, e.asyncGeneratorHelper = { name: "typescript:asyncGenerator", importName: "__asyncGenerator", scoped: false, dependencies: [e.awaitHelper], text: `
            var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
                if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                var g = generator.apply(thisArg, _arguments || []), i, q = [];
                return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
                function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
                function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
                function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
                function fulfill(value) { resume("next", value); }
                function reject(value) { resume("throw", value); }
                function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
            };` }, e.asyncDelegator = { name: "typescript:asyncDelegator", importName: "__asyncDelegator", scoped: false, dependencies: [e.awaitHelper], text: `
            var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {
                var i, p;
                return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
                function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
            };` }, e.asyncValues = { name: "typescript:asyncValues", importName: "__asyncValues", scoped: false, text: `
            var __asyncValues = (this && this.__asyncValues) || function (o) {
                if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                var m = o[Symbol.asyncIterator], i;
                return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
                function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
                function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
            };` }, e.restHelper = { name: "typescript:rest", importName: "__rest", scoped: false, text: `
            var __rest = (this && this.__rest) || function (s, e) {
                var t = {};
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                    t[p] = s[p];
                if (s != null && typeof Object.getOwnPropertySymbols === "function")
                    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                            t[p[i]] = s[p[i]];
                    }
                return t;
            };` }, e.awaiterHelper = { name: "typescript:awaiter", importName: "__awaiter", scoped: false, priority: 5, text: `
            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
                return new (P || (P = Promise))(function (resolve, reject) {
                    function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
                    function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
            };` }, e.extendsHelper = { name: "typescript:extends", importName: "__extends", scoped: false, priority: 0, text: `
            var __extends = (this && this.__extends) || (function () {
                var extendStatics = function (d, b) {
                    extendStatics = Object.setPrototypeOf ||
                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
                    return extendStatics(d, b);
                };

                return function (d, b) {
                    if (typeof b !== "function" && b !== null)
                        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                    extendStatics(d, b);
                    function __() { this.constructor = d; }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();` }, e.templateObjectHelper = { name: "typescript:makeTemplateObject", importName: "__makeTemplateObject", scoped: false, priority: 0, text: `
            var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
                if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
                return cooked;
            };` }, e.readHelper = { name: "typescript:read", importName: "__read", scoped: false, text: `
            var __read = (this && this.__read) || function (o, n) {
                var m = typeof Symbol === "function" && o[Symbol.iterator];
                if (!m) return o;
                var i = m.call(o), r, ar = [], e;
                try {
                    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
                }
                catch (error) { e = { error: error }; }
                finally {
                    try {
                        if (r && !r.done && (m = i["return"])) m.call(i);
                    }
                    finally { if (e) throw e.error; }
                }
                return ar;
            };` }, e.spreadArrayHelper = { name: "typescript:spreadArray", importName: "__spreadArray", scoped: false, text: `
            var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
                if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
                    if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                    }
                }
                return to.concat(ar || Array.prototype.slice.call(from));
            };` }, e.valuesHelper = { name: "typescript:values", importName: "__values", scoped: false, text: `
            var __values = (this && this.__values) || function(o) {
                var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
                if (m) return m.call(o);
                if (o && typeof o.length === "number") return {
                    next: function () {
                        if (o && i >= o.length) o = void 0;
                        return { value: o && o[i++], done: !o };
                    }
                };
                throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
            };` }, e.generatorHelper = { name: "typescript:generator", importName: "__generator", scoped: false, priority: 6, text: `
            var __generator = (this && this.__generator) || function (thisArg, body) {
                var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
                return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
                function verb(n) { return function (v) { return step([n, v]); }; }
                function step(op) {
                    if (f) throw new TypeError("Generator is already executing.");
                    while (g && (g = 0, op[0] && (_ = 0)), _) try {
                        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                        if (y = 0, t) op = [op[0] & 2, t.value];
                        switch (op[0]) {
                            case 0: case 1: t = op; break;
                            case 4: _.label++; return { value: op[1], done: false };
                            case 5: _.label++; y = op[1]; op = [0]; continue;
                            case 7: op = _.ops.pop(); _.trys.pop(); continue;
                            default:
                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                                if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                                if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                                if (t[2]) _.ops.pop();
                                _.trys.pop(); continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
                    if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
                }
            };` }, e.createBindingHelper = { name: "typescript:commonjscreatebinding", importName: "__createBinding", scoped: false, priority: 1, text: `
            var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                var desc = Object.getOwnPropertyDescriptor(m, k);
                if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                  desc = { enumerable: true, get: function() { return m[k]; } };
                }
                Object.defineProperty(o, k2, desc);
            }) : (function(o, m, k, k2) {
                if (k2 === undefined) k2 = k;
                o[k2] = m[k];
            }));` }, e.setModuleDefaultHelper = { name: "typescript:commonjscreatevalue", importName: "__setModuleDefault", scoped: false, priority: 1, text: `
            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
                Object.defineProperty(o, "default", { enumerable: true, value: v });
            }) : function(o, v) {
                o["default"] = v;
            });` }, e.importStarHelper = { name: "typescript:commonjsimportstar", importName: "__importStar", scoped: false, dependencies: [e.createBindingHelper, e.setModuleDefaultHelper], priority: 2, text: `
            var __importStar = (this && this.__importStar) || function (mod) {
                if (mod && mod.__esModule) return mod;
                var result = {};
                if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
                __setModuleDefault(result, mod);
                return result;
            };` }, e.importDefaultHelper = { name: "typescript:commonjsimportdefault", importName: "__importDefault", scoped: false, text: `
            var __importDefault = (this && this.__importDefault) || function (mod) {
                return (mod && mod.__esModule) ? mod : { "default": mod };
            };` }, e.exportStarHelper = { name: "typescript:export-star", importName: "__exportStar", scoped: false, dependencies: [e.createBindingHelper], priority: 2, text: `
            var __exportStar = (this && this.__exportStar) || function(m, exports) {
                for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
            };` }, e.classPrivateFieldGetHelper = { name: "typescript:classPrivateFieldGet", importName: "__classPrivateFieldGet", scoped: false, text: `
            var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
                if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
                if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
            };` }, e.classPrivateFieldSetHelper = { name: "typescript:classPrivateFieldSet", importName: "__classPrivateFieldSet", scoped: false, text: `
            var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
                if (kind === "m") throw new TypeError("Private method is not writable");
                if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
                if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
            };` }, e.classPrivateFieldInHelper = { name: "typescript:classPrivateFieldIn", importName: "__classPrivateFieldIn", scoped: false, text: `
            var __classPrivateFieldIn = (this && this.__classPrivateFieldIn) || function(state, receiver) {
                if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
                return typeof state === "function" ? receiver === state : state.has(receiver);
            };` };
            var q;
            function F() {
              return q || (q = e.arrayToMap([e.decorateHelper, e.metadataHelper, e.paramHelper, e.assignHelper, e.awaitHelper, e.asyncGeneratorHelper, e.asyncDelegator, e.asyncValues, e.restHelper, e.awaiterHelper, e.extendsHelper, e.templateObjectHelper, e.spreadArrayHelper, e.valuesHelper, e.readHelper, e.generatorHelper, e.importStarHelper, e.importDefaultHelper, e.exportStarHelper, e.classPrivateFieldGetHelper, e.classPrivateFieldSetHelper, e.classPrivateFieldInHelper, e.createBindingHelper, e.setModuleDefaultHelper], function(Te) {
                return Te.name;
              }));
            }
            __name(F, "F");
            e.getAllUnscopedEmitHelpers = F, e.asyncSuperHelper = { name: "typescript:async-super", scoped: true, text: s(oe([`
            const `, " = name => super[name];"], [`
            const `, " = name => super[name];"]), "_superIndex") }, e.advancedAsyncSuperHelper = { name: "typescript:advanced-async-super", scoped: true, text: s(oe([`
            const `, ` = (function (geti, seti) {
                const cache = Object.create(null);
                return name => cache[name] || (cache[name] = { get value() { return geti(name); }, set value(v) { seti(name, v); } });
            })(name => super[name], (name, value) => super[name] = value);`], [`
            const `, ` = (function (geti, seti) {
                const cache = Object.create(null);
                return name => cache[name] || (cache[name] = { get value() { return geti(name); }, set value(v) { seti(name, v); } });
            })(name => super[name], (name, value) => super[name] = value);`]), "_superIndex") };
            function fe(Te, Se) {
              return e.isCallExpression(Te) && e.isIdentifier(Te.expression) && (e.getEmitFlags(Te.expression) & 4096) !== 0 && Te.expression.escapedText === Se;
            }
            __name(fe, "fe");
            e.isCallToHelper = fe;
          })(N || (N = {}));
          var N;
          (function(e) {
            function t(R) {
              return R.kind === 8;
            }
            __name(t, "t");
            e.isNumericLiteral = t;
            function x(R) {
              return R.kind === 9;
            }
            __name(x, "x");
            e.isBigIntLiteral = x;
            function s(R) {
              return R.kind === 10;
            }
            __name(s, "s");
            e.isStringLiteral = s;
            function q(R) {
              return R.kind === 11;
            }
            __name(q, "q");
            e.isJsxText = q;
            function F(R) {
              return R.kind === 13;
            }
            __name(F, "F");
            e.isRegularExpressionLiteral = F;
            function fe(R) {
              return R.kind === 14;
            }
            __name(fe, "fe");
            e.isNoSubstitutionTemplateLiteral = fe;
            function Te(R) {
              return R.kind === 15;
            }
            __name(Te, "Te");
            e.isTemplateHead = Te;
            function Se(R) {
              return R.kind === 16;
            }
            __name(Se, "Se");
            e.isTemplateMiddle = Se;
            function J(R) {
              return R.kind === 17;
            }
            __name(J, "J");
            e.isTemplateTail = J;
            function se(R) {
              return R.kind === 25;
            }
            __name(se, "se");
            e.isDotDotDotToken = se;
            function Le(R) {
              return R.kind === 27;
            }
            __name(Le, "Le");
            e.isCommaToken = Le;
            function Q(R) {
              return R.kind === 39;
            }
            __name(Q, "Q");
            e.isPlusToken = Q;
            function Be(R) {
              return R.kind === 40;
            }
            __name(Be, "Be");
            e.isMinusToken = Be;
            function je(R) {
              return R.kind === 41;
            }
            __name(je, "je");
            e.isAsteriskToken = je;
            function W(R) {
              return R.kind === 53;
            }
            __name(W, "W");
            e.isExclamationToken = W;
            function B(R) {
              return R.kind === 57;
            }
            __name(B, "B");
            e.isQuestionToken = B;
            function U(R) {
              return R.kind === 58;
            }
            __name(U, "U");
            e.isColonToken = U;
            function m(R) {
              return R.kind === 28;
            }
            __name(m, "m");
            e.isQuestionDotToken = m;
            function v(R) {
              return R.kind === 38;
            }
            __name(v, "v");
            e.isEqualsGreaterThanToken = v;
            function g(R) {
              return R.kind === 79;
            }
            __name(g, "g");
            e.isIdentifier = g;
            function O(R) {
              return R.kind === 80;
            }
            __name(O, "O");
            e.isPrivateIdentifier = O;
            function S(R) {
              return R.kind === 93;
            }
            __name(S, "S");
            e.isExportModifier = S;
            function te(R) {
              return R.kind === 132;
            }
            __name(te, "te");
            e.isAsyncModifier = te;
            function Je(R) {
              return R.kind === 129;
            }
            __name(Je, "Je");
            e.isAssertsKeyword = Je;
            function qe(R) {
              return R.kind === 133;
            }
            __name(qe, "qe");
            e.isAwaitKeyword = qe;
            function ge(R) {
              return R.kind === 146;
            }
            __name(ge, "ge");
            e.isReadonlyKeyword = ge;
            function ie(R) {
              return R.kind === 124;
            }
            __name(ie, "ie");
            e.isStaticModifier = ie;
            function G(R) {
              return R.kind === 126;
            }
            __name(G, "G");
            e.isAbstractModifier = G;
            function pe(R) {
              return R.kind === 161;
            }
            __name(pe, "pe");
            e.isOverrideModifier = pe;
            function j(R) {
              return R.kind === 127;
            }
            __name(j, "j");
            e.isAccessorModifier = j;
            function be(R) {
              return R.kind === 106;
            }
            __name(be, "be");
            e.isSuperKeyword = be;
            function $e(R) {
              return R.kind === 100;
            }
            __name($e, "$e");
            e.isImportKeyword = $e;
            function Re(R) {
              return R.kind === 163;
            }
            __name(Re, "Re");
            e.isQualifiedName = Re;
            function Fe(R) {
              return R.kind === 164;
            }
            __name(Fe, "Fe");
            e.isComputedPropertyName = Fe;
            function dr(R) {
              return R.kind === 165;
            }
            __name(dr, "dr");
            e.isTypeParameterDeclaration = dr;
            function ze(R) {
              return R.kind === 166;
            }
            __name(ze, "ze");
            e.isParameter = ze;
            function ve(R) {
              return R.kind === 167;
            }
            __name(ve, "ve");
            e.isDecorator = ve;
            function er(R) {
              return R.kind === 168;
            }
            __name(er, "er");
            e.isPropertySignature = er;
            function ar(R) {
              return R.kind === 169;
            }
            __name(ar, "ar");
            e.isPropertyDeclaration = ar;
            function Cr(R) {
              return R.kind === 170;
            }
            __name(Cr, "Cr");
            e.isMethodSignature = Cr;
            function Ce(R) {
              return R.kind === 171;
            }
            __name(Ce, "Ce");
            e.isMethodDeclaration = Ce;
            function Xe(R) {
              return R.kind === 172;
            }
            __name(Xe, "Xe");
            e.isClassStaticBlockDeclaration = Xe;
            function gr(R) {
              return R.kind === 173;
            }
            __name(gr, "gr");
            e.isConstructorDeclaration = gr;
            function X(R) {
              return R.kind === 174;
            }
            __name(X, "X");
            e.isGetAccessorDeclaration = X;
            function Ee(R) {
              return R.kind === 175;
            }
            __name(Ee, "Ee");
            e.isSetAccessorDeclaration = Ee;
            function we(R) {
              return R.kind === 176;
            }
            __name(we, "we");
            e.isCallSignatureDeclaration = we;
            function he(R) {
              return R.kind === 177;
            }
            __name(he, "he");
            e.isConstructSignatureDeclaration = he;
            function yr(R) {
              return R.kind === 178;
            }
            __name(yr, "yr");
            e.isIndexSignatureDeclaration = yr;
            function kr(R) {
              return R.kind === 179;
            }
            __name(kr, "kr");
            e.isTypePredicateNode = kr;
            function nr(R) {
              return R.kind === 180;
            }
            __name(nr, "nr");
            e.isTypeReferenceNode = nr;
            function tr(R) {
              return R.kind === 181;
            }
            __name(tr, "tr");
            e.isFunctionTypeNode = tr;
            function Lr(R) {
              return R.kind === 182;
            }
            __name(Lr, "Lr");
            e.isConstructorTypeNode = Lr;
            function zr(R) {
              return R.kind === 183;
            }
            __name(zr, "zr");
            e.isTypeQueryNode = zr;
            function ye(R) {
              return R.kind === 184;
            }
            __name(ye, "ye");
            e.isTypeLiteralNode = ye;
            function ir(R) {
              return R.kind === 185;
            }
            __name(ir, "ir");
            e.isArrayTypeNode = ir;
            function Dr(R) {
              return R.kind === 186;
            }
            __name(Dr, "Dr");
            e.isTupleTypeNode = Dr;
            function Pr(R) {
              return R.kind === 199;
            }
            __name(Pr, "Pr");
            e.isNamedTupleMember = Pr;
            function Br(R) {
              return R.kind === 187;
            }
            __name(Br, "Br");
            e.isOptionalTypeNode = Br;
            function ut(R) {
              return R.kind === 188;
            }
            __name(ut, "ut");
            e.isRestTypeNode = ut;
            function rt(R) {
              return R.kind === 189;
            }
            __name(rt, "rt");
            e.isUnionTypeNode = rt;
            function Z(R) {
              return R.kind === 190;
            }
            __name(Z, "Z");
            e.isIntersectionTypeNode = Z;
            function f(R) {
              return R.kind === 191;
            }
            __name(f, "f");
            e.isConditionalTypeNode = f;
            function h(R) {
              return R.kind === 192;
            }
            __name(h, "h");
            e.isInferTypeNode = h;
            function ae(R) {
              return R.kind === 193;
            }
            __name(ae, "ae");
            e.isParenthesizedTypeNode = ae;
            function xr(R) {
              return R.kind === 194;
            }
            __name(xr, "xr");
            e.isThisTypeNode = xr;
            function jr(R) {
              return R.kind === 195;
            }
            __name(jr, "jr");
            e.isTypeOperatorNode = jr;
            function qr(R) {
              return R.kind === 196;
            }
            __name(qr, "qr");
            e.isIndexedAccessTypeNode = qr;
            function pt(R) {
              return R.kind === 197;
            }
            __name(pt, "pt");
            e.isMappedTypeNode = pt;
            function Ge(R) {
              return R.kind === 198;
            }
            __name(Ge, "Ge");
            e.isLiteralTypeNode = Ge;
            function K(R) {
              return R.kind === 202;
            }
            __name(K, "K");
            e.isImportTypeNode = K;
            function r(R) {
              return R.kind === 201;
            }
            __name(r, "r");
            e.isTemplateLiteralTypeSpan = r;
            function ct(R) {
              return R.kind === 200;
            }
            __name(ct, "ct");
            e.isTemplateLiteralTypeNode = ct;
            function ft(R) {
              return R.kind === 203;
            }
            __name(ft, "ft");
            e.isObjectBindingPattern = ft;
            function Ie(R) {
              return R.kind === 204;
            }
            __name(Ie, "Ie");
            e.isArrayBindingPattern = Ie;
            function me(R) {
              return R.kind === 205;
            }
            __name(me, "me");
            e.isBindingElement = me;
            function xe(R) {
              return R.kind === 206;
            }
            __name(xe, "xe");
            e.isArrayLiteralExpression = xe;
            function Ye(R) {
              return R.kind === 207;
            }
            __name(Ye, "Ye");
            e.isObjectLiteralExpression = Ye;
            function vr(R) {
              return R.kind === 208;
            }
            __name(vr, "vr");
            e.isPropertyAccessExpression = vr;
            function nt(R) {
              return R.kind === 209;
            }
            __name(nt, "nt");
            e.isElementAccessExpression = nt;
            function pr(R) {
              return R.kind === 210;
            }
            __name(pr, "pr");
            e.isCallExpression = pr;
            function Mr(R) {
              return R.kind === 211;
            }
            __name(Mr, "Mr");
            e.isNewExpression = Mr;
            function ot(R) {
              return R.kind === 212;
            }
            __name(ot, "ot");
            e.isTaggedTemplateExpression = ot;
            function At(R) {
              return R.kind === 213;
            }
            __name(At, "At");
            e.isTypeAssertionExpression = At;
            function re(R) {
              return R.kind === 214;
            }
            __name(re, "re");
            e.isParenthesizedExpression = re;
            function de(R) {
              return R.kind === 215;
            }
            __name(de, "de");
            e.isFunctionExpression = de;
            function He(R) {
              return R.kind === 216;
            }
            __name(He, "He");
            e.isArrowFunction = He;
            function Nr(R) {
              return R.kind === 217;
            }
            __name(Nr, "Nr");
            e.isDeleteExpression = Nr;
            function Yr(R) {
              return R.kind === 218;
            }
            __name(Yr, "Yr");
            e.isTypeOfExpression = Yr;
            function St(R) {
              return R.kind === 219;
            }
            __name(St, "St");
            e.isVoidExpression = St;
            function Dt(R) {
              return R.kind === 220;
            }
            __name(Dt, "Dt");
            e.isAwaitExpression = Dt;
            function Lt(R) {
              return R.kind === 221;
            }
            __name(Lt, "Lt");
            e.isPrefixUnaryExpression = Lt;
            function zt(R) {
              return R.kind === 222;
            }
            __name(zt, "zt");
            e.isPostfixUnaryExpression = zt;
            function Zt(R) {
              return R.kind === 223;
            }
            __name(Zt, "Zt");
            e.isBinaryExpression = Zt;
            function mt(R) {
              return R.kind === 224;
            }
            __name(mt, "mt");
            e.isConditionalExpression = mt;
            function at(R) {
              return R.kind === 225;
            }
            __name(at, "at");
            e.isTemplateExpression = at;
            function k(R) {
              return R.kind === 226;
            }
            __name(k, "k");
            e.isYieldExpression = k;
            function ue(R) {
              return R.kind === 227;
            }
            __name(ue, "ue");
            e.isSpreadElement = ue;
            function Qe(R) {
              return R.kind === 228;
            }
            __name(Qe, "Qe");
            e.isClassExpression = Qe;
            function Sr(R) {
              return R.kind === 229;
            }
            __name(Sr, "Sr");
            e.isOmittedExpression = Sr;
            function Kr(R) {
              return R.kind === 230;
            }
            __name(Kr, "Kr");
            e.isExpressionWithTypeArguments = Kr;
            function Hr(R) {
              return R.kind === 231;
            }
            __name(Hr, "Hr");
            e.isAsExpression = Hr;
            function Ct(R) {
              return R.kind === 235;
            }
            __name(Ct, "Ct");
            e.isSatisfiesExpression = Ct;
            function Xt(R) {
              return R.kind === 232;
            }
            __name(Xt, "Xt");
            e.isNonNullExpression = Xt;
            function cn(R) {
              return R.kind === 233;
            }
            __name(cn, "cn");
            e.isMetaProperty = cn;
            function In(R) {
              return R.kind === 234;
            }
            __name(In, "In");
            e.isSyntheticExpression = In;
            function yn(R) {
              return R.kind === 353;
            }
            __name(yn, "yn");
            e.isPartiallyEmittedExpression = yn;
            function hn(R) {
              return R.kind === 354;
            }
            __name(hn, "hn");
            e.isCommaListExpression = hn;
            function ln(R) {
              return R.kind === 236;
            }
            __name(ln, "ln");
            e.isTemplateSpan = ln;
            function En(R) {
              return R.kind === 237;
            }
            __name(En, "En");
            e.isSemicolonClassElement = En;
            function Vt(R) {
              return R.kind === 238;
            }
            __name(Vt, "Vt");
            e.isBlock = Vt;
            function ui(R) {
              return R.kind === 240;
            }
            __name(ui, "ui");
            e.isVariableStatement = ui;
            function ei(R) {
              return R.kind === 239;
            }
            __name(ei, "ei");
            e.isEmptyStatement = ei;
            function vi(R) {
              return R.kind === 241;
            }
            __name(vi, "vi");
            e.isExpressionStatement = vi;
            function ri(R) {
              return R.kind === 242;
            }
            __name(ri, "ri");
            e.isIfStatement = ri;
            function bi(R) {
              return R.kind === 243;
            }
            __name(bi, "bi");
            e.isDoStatement = bi;
            function Qn(R) {
              return R.kind === 244;
            }
            __name(Qn, "Qn");
            e.isWhileStatement = Qn;
            function Yn(R) {
              return R.kind === 245;
            }
            __name(Yn, "Yn");
            e.isForStatement = Yn;
            function oi(R) {
              return R.kind === 246;
            }
            __name(oi, "oi");
            e.isForInStatement = oi;
            function Ei(R) {
              return R.kind === 247;
            }
            __name(Ei, "Ei");
            e.isForOfStatement = Ei;
            function Dn(R) {
              return R.kind === 248;
            }
            __name(Dn, "Dn");
            e.isContinueStatement = Dn;
            function Kn(R) {
              return R.kind === 249;
            }
            __name(Kn, "Kn");
            e.isBreakStatement = Kn;
            function si(R) {
              return R.kind === 250;
            }
            __name(si, "si");
            e.isReturnStatement = si;
            function mi(R) {
              return R.kind === 251;
            }
            __name(mi, "mi");
            e.isWithStatement = mi;
            function Zn(R) {
              return R.kind === 252;
            }
            __name(Zn, "Zn");
            e.isSwitchStatement = Zn;
            function Fn(R) {
              return R.kind === 253;
            }
            __name(Fn, "Fn");
            e.isLabeledStatement = Fn;
            function gt(R) {
              return R.kind === 254;
            }
            __name(gt, "gt");
            e.isThrowStatement = gt;
            function gi(R) {
              return R.kind === 255;
            }
            __name(gi, "gi");
            e.isTryStatement = gi;
            function dn(R) {
              return R.kind === 256;
            }
            __name(dn, "dn");
            e.isDebuggerStatement = dn;
            function On(R) {
              return R.kind === 257;
            }
            __name(On, "On");
            e.isVariableDeclaration = On;
            function br(R) {
              return R.kind === 258;
            }
            __name(br, "br");
            e.isVariableDeclarationList = br;
            function Ae(R) {
              return R.kind === 259;
            }
            __name(Ae, "Ae");
            e.isFunctionDeclaration = Ae;
            function ur(R) {
              return R.kind === 260;
            }
            __name(ur, "ur");
            e.isClassDeclaration = ur;
            function L(R) {
              return R.kind === 261;
            }
            __name(L, "L");
            e.isInterfaceDeclaration = L;
            function qt(R) {
              return R.kind === 262;
            }
            __name(qt, "qt");
            e.isTypeAliasDeclaration = qt;
            function nn(R) {
              return R.kind === 263;
            }
            __name(nn, "nn");
            e.isEnumDeclaration = nn;
            function fr(R) {
              return R.kind === 264;
            }
            __name(fr, "fr");
            e.isModuleDeclaration = fr;
            function Me(R) {
              return R.kind === 265;
            }
            __name(Me, "Me");
            e.isModuleBlock = Me;
            function Ve(R) {
              return R.kind === 266;
            }
            __name(Ve, "Ve");
            e.isCaseBlock = Ve;
            function _r(R) {
              return R.kind === 267;
            }
            __name(_r, "_r");
            e.isNamespaceExportDeclaration = _r;
            function lr(R) {
              return R.kind === 268;
            }
            __name(lr, "lr");
            e.isImportEqualsDeclaration = lr;
            function Vr(R) {
              return R.kind === 269;
            }
            __name(Vr, "Vr");
            e.isImportDeclaration = Vr;
            function tt(R) {
              return R.kind === 270;
            }
            __name(tt, "tt");
            e.isImportClause = tt;
            function dt(R) {
              return R.kind === 298;
            }
            __name(dt, "dt");
            e.isImportTypeAssertionContainer = dt;
            function It(R) {
              return R.kind === 296;
            }
            __name(It, "It");
            e.isAssertClause = It;
            function an(R) {
              return R.kind === 297;
            }
            __name(an, "an");
            e.isAssertEntry = an;
            function sn(R) {
              return R.kind === 271;
            }
            __name(sn, "sn");
            e.isNamespaceImport = sn;
            function _e(R) {
              return R.kind === 277;
            }
            __name(_e, "_e");
            e.isNamespaceExport = _e;
            function Gr(R) {
              return R.kind === 272;
            }
            __name(Gr, "Gr");
            e.isNamedImports = Gr;
            function Kt(R) {
              return R.kind === 273;
            }
            __name(Kt, "Kt");
            e.isImportSpecifier = Kt;
            function en(R) {
              return R.kind === 274;
            }
            __name(en, "en");
            e.isExportAssignment = en;
            function Ot(R) {
              return R.kind === 275;
            }
            __name(Ot, "Ot");
            e.isExportDeclaration = Ot;
            function rr(R) {
              return R.kind === 276;
            }
            __name(rr, "rr");
            e.isNamedExports = rr;
            function Hn(R) {
              return R.kind === 278;
            }
            __name(Hn, "Hn");
            e.isExportSpecifier = Hn;
            function rn(R) {
              return R.kind === 279;
            }
            __name(rn, "rn");
            e.isMissingDeclaration = rn;
            function xn(R) {
              return R.kind === 352;
            }
            __name(xn, "xn");
            e.isNotEmittedStatement = xn;
            function Mn(R) {
              return R.kind === 357;
            }
            __name(Mn, "Mn");
            e.isSyntheticReference = Mn;
            function Rn(R) {
              return R.kind === 355;
            }
            __name(Rn, "Rn");
            e.isMergeDeclarationMarker = Rn;
            function kn(R) {
              return R.kind === 356;
            }
            __name(kn, "kn");
            e.isEndOfDeclarationMarker = kn;
            function on(R) {
              return R.kind === 280;
            }
            __name(on, "on");
            e.isExternalModuleReference = on;
            function Xr(R) {
              return R.kind === 281;
            }
            __name(Xr, "Xr");
            e.isJsxElement = Xr;
            function wr(R) {
              return R.kind === 282;
            }
            __name(wr, "wr");
            e.isJsxSelfClosingElement = wr;
            function fn(R) {
              return R.kind === 283;
            }
            __name(fn, "fn");
            e.isJsxOpeningElement = fn;
            function mn(R) {
              return R.kind === 284;
            }
            __name(mn, "mn");
            e.isJsxClosingElement = mn;
            function Li(R) {
              return R.kind === 285;
            }
            __name(Li, "Li");
            e.isJsxFragment = Li;
            function An(R) {
              return R.kind === 286;
            }
            __name(An, "An");
            e.isJsxOpeningFragment = An;
            function wi(R) {
              return R.kind === 287;
            }
            __name(wi, "wi");
            e.isJsxClosingFragment = wi;
            function ti(R) {
              return R.kind === 288;
            }
            __name(ti, "ti");
            e.isJsxAttribute = ti;
            function li(R) {
              return R.kind === 289;
            }
            __name(li, "li");
            e.isJsxAttributes = li;
            function Bn(R) {
              return R.kind === 290;
            }
            __name(Bn, "Bn");
            e.isJsxSpreadAttribute = Bn;
            function vn(R) {
              return R.kind === 291;
            }
            __name(vn, "vn");
            e.isJsxExpression = vn;
            function Ue(R) {
              return R.kind === 292;
            }
            __name(Ue, "Ue");
            e.isCaseClause = Ue;
            function Vn(R) {
              return R.kind === 293;
            }
            __name(Vn, "Vn");
            e.isDefaultClause = Vn;
            function Ti(R) {
              return R.kind === 294;
            }
            __name(Ti, "Ti");
            e.isHeritageClause = Ti;
            function ni(R) {
              return R.kind === 295;
            }
            __name(ni, "ni");
            e.isCatchClause = ni;
            function Bi(R) {
              return R.kind === 299;
            }
            __name(Bi, "Bi");
            e.isPropertyAssignment = Bi;
            function Tn(R) {
              return R.kind === 300;
            }
            __name(Tn, "Tn");
            e.isShorthandPropertyAssignment = Tn;
            function jn(R) {
              return R.kind === 301;
            }
            __name(jn, "jn");
            e.isSpreadAssignment = jn;
            function Si(R) {
              return R.kind === 302;
            }
            __name(Si, "Si");
            e.isEnumMember = Si;
            function Ci(R) {
              return R.kind === 304;
            }
            __name(Ci, "Ci");
            e.isUnparsedPrepend = Ci;
            function C(R) {
              return R.kind === 308;
            }
            __name(C, "C");
            e.isSourceFile = C;
            function V(R) {
              return R.kind === 309;
            }
            __name(V, "V");
            e.isBundle = V;
            function ee(R) {
              return R.kind === 310;
            }
            __name(ee, "ee");
            e.isUnparsedSource = ee;
            function le(R) {
              return R.kind === 312;
            }
            __name(le, "le");
            e.isJSDocTypeExpression = le;
            function Ze(R) {
              return R.kind === 313;
            }
            __name(Ze, "Ze");
            e.isJSDocNameReference = Ze;
            function Ir(R) {
              return R.kind === 314;
            }
            __name(Ir, "Ir");
            e.isJSDocMemberName = Ir;
            function Ar(R) {
              return R.kind === 327;
            }
            __name(Ar, "Ar");
            e.isJSDocLink = Ar;
            function hr(R) {
              return R.kind === 328;
            }
            __name(hr, "hr");
            e.isJSDocLinkCode = hr;
            function yt(R) {
              return R.kind === 329;
            }
            __name(yt, "yt");
            e.isJSDocLinkPlain = yt;
            function Pt(R) {
              return R.kind === 315;
            }
            __name(Pt, "Pt");
            e.isJSDocAllType = Pt;
            function Ut(R) {
              return R.kind === 316;
            }
            __name(Ut, "Ut");
            e.isJSDocUnknownType = Ut;
            function jt(R) {
              return R.kind === 317;
            }
            __name(jt, "jt");
            e.isJSDocNullableType = jt;
            function Ht(R) {
              return R.kind === 318;
            }
            __name(Ht, "Ht");
            e.isJSDocNonNullableType = Ht;
            function yi(R) {
              return R.kind === 319;
            }
            __name(yi, "yi");
            e.isJSDocOptionalType = yi;
            function Ni(R) {
              return R.kind === 320;
            }
            __name(Ni, "Ni");
            e.isJSDocFunctionType = Ni;
            function Gn(R) {
              return R.kind === 321;
            }
            __name(Gn, "Gn");
            e.isJSDocVariadicType = Gn;
            function qi(R) {
              return R.kind === 322;
            }
            __name(qi, "qi");
            e.isJSDocNamepathType = qi;
            function sa(R) {
              return R.kind === 323;
            }
            __name(sa, "sa");
            e.isJSDoc = sa;
            function ea(R) {
              return R.kind === 325;
            }
            __name(ea, "ea");
            e.isJSDocTypeLiteral = ea;
            function Hi(R) {
              return R.kind === 326;
            }
            __name(Hi, "Hi");
            e.isJSDocSignature = Hi;
            function Ui(R) {
              return R.kind === 331;
            }
            __name(Ui, "Ui");
            e.isJSDocAugmentsTag = Ui;
            function Gi(R) {
              return R.kind === 333;
            }
            __name(Gi, "Gi");
            e.isJSDocAuthorTag = Gi;
            function Xi(R) {
              return R.kind === 335;
            }
            __name(Xi, "Xi");
            e.isJSDocClassTag = Xi;
            function ma(R) {
              return R.kind === 341;
            }
            __name(ma, "ma");
            e.isJSDocCallbackTag = ma;
            function Jn(R) {
              return R.kind === 336;
            }
            __name(Jn, "Jn");
            e.isJSDocPublicTag = Jn;
            function ra(R) {
              return R.kind === 337;
            }
            __name(ra, "ra");
            e.isJSDocPrivateTag = ra;
            function $i(R) {
              return R.kind === 338;
            }
            __name($i, "$i");
            e.isJSDocProtectedTag = $i;
            function _a(R) {
              return R.kind === 339;
            }
            __name(_a, "_a");
            e.isJSDocReadonlyTag = _a;
            function Ri(R) {
              return R.kind === 340;
            }
            __name(Ri, "Ri");
            e.isJSDocOverrideTag = Ri;
            function p(R) {
              return R.kind === 334;
            }
            __name(p, "p");
            e.isJSDocDeprecatedTag = p;
            function ne(R) {
              return R.kind === 349;
            }
            __name(ne, "ne");
            e.isJSDocSeeTag = ne;
            function Ne(R) {
              return R.kind === 342;
            }
            __name(Ne, "Ne");
            e.isJSDocEnumTag = Ne;
            function or(R) {
              return R.kind === 343;
            }
            __name(or, "or");
            e.isJSDocParameterTag = or;
            function it(R) {
              return R.kind === 344;
            }
            __name(it, "it");
            e.isJSDocReturnTag = it;
            function vt(R) {
              return R.kind === 345;
            }
            __name(vt, "vt");
            e.isJSDocThisTag = vt;
            function Et(R) {
              return R.kind === 346;
            }
            __name(Et, "Et");
            e.isJSDocTypeTag = Et;
            function Tt(R) {
              return R.kind === 347;
            }
            __name(Tt, "Tt");
            e.isJSDocTemplateTag = Tt;
            function tn(R) {
              return R.kind === 348;
            }
            __name(tn, "tn");
            e.isJSDocTypedefTag = tn;
            function Mt(R) {
              return R.kind === 330;
            }
            __name(Mt, "Mt");
            e.isJSDocUnknownTag = Mt;
            function $t(R) {
              return R.kind === 350;
            }
            __name($t, "$t");
            e.isJSDocPropertyTag = $t;
            function y(R) {
              return R.kind === 332;
            }
            __name(y, "y");
            e.isJSDocImplementsTag = y;
            function De(R) {
              return R.kind === 351;
            }
            __name(De, "De");
            e.isSyntaxList = De;
          })(N || (N = {}));
          var N;
          (function(e) {
            function t(re) {
              return re.createExportDeclaration(void 0, false, re.createNamedExports([]), void 0);
            }
            __name(t, "t");
            e.createEmptyExports = t;
            function x(re, de, He, Nr) {
              if (e.isComputedPropertyName(He))
                return e.setTextRange(re.createElementAccessExpression(de, He.expression), Nr);
              var Yr = e.setTextRange(e.isMemberName(He) ? re.createPropertyAccessExpression(de, He) : re.createElementAccessExpression(de, He), He);
              return e.getOrCreateEmitNode(Yr).flags |= 64, Yr;
            }
            __name(x, "x");
            e.createMemberAccessForPropertyName = x;
            function s(re, de) {
              var He = e.parseNodeFactory.createIdentifier(re || "React");
              return e.setParent(He, e.getParseTreeNode(de)), He;
            }
            __name(s, "s");
            function q(re, de, He) {
              if (e.isQualifiedName(de)) {
                var Nr = q(re, de.left, He), Yr = re.createIdentifier(e.idText(de.right));
                return Yr.escapedText = de.right.escapedText, re.createPropertyAccessExpression(Nr, Yr);
              } else
                return s(e.idText(de), He);
            }
            __name(q, "q");
            function F(re, de, He, Nr) {
              return de ? q(re, de, Nr) : re.createPropertyAccessExpression(s(He, Nr), "createElement");
            }
            __name(F, "F");
            e.createJsxFactoryExpression = F;
            function fe(re, de, He, Nr) {
              return de ? q(re, de, Nr) : re.createPropertyAccessExpression(s(He, Nr), "Fragment");
            }
            __name(fe, "fe");
            function Te(re, de, He, Nr, Yr, St) {
              var Dt = [He];
              if (Nr && Dt.push(Nr), Yr && Yr.length > 0)
                if (Nr || Dt.push(re.createNull()), Yr.length > 1)
                  for (var Lt = 0, zt = Yr; Lt < zt.length; Lt++) {
                    var Zt = zt[Lt];
                    be(Zt), Dt.push(Zt);
                  }
                else
                  Dt.push(Yr[0]);
              return e.setTextRange(re.createCallExpression(de, void 0, Dt), St);
            }
            __name(Te, "Te");
            e.createExpressionForJsxElement = Te;
            function Se(re, de, He, Nr, Yr, St, Dt) {
              var Lt = fe(re, He, Nr, St), zt = [Lt, re.createNull()];
              if (Yr && Yr.length > 0)
                if (Yr.length > 1)
                  for (var Zt = 0, mt = Yr; Zt < mt.length; Zt++) {
                    var at = mt[Zt];
                    be(at), zt.push(at);
                  }
                else
                  zt.push(Yr[0]);
              return e.setTextRange(re.createCallExpression(F(re, de, Nr, St), void 0, zt), Dt);
            }
            __name(Se, "Se");
            e.createExpressionForJsxFragment = Se;
            function J(re, de, He) {
              if (e.isVariableDeclarationList(de)) {
                var Nr = e.first(de.declarations), Yr = re.updateVariableDeclaration(Nr, Nr.name, void 0, void 0, He);
                return e.setTextRange(re.createVariableStatement(void 0, re.updateVariableDeclarationList(de, [Yr])), de);
              } else {
                var St = e.setTextRange(re.createAssignment(de, He), de);
                return e.setTextRange(re.createExpressionStatement(St), de);
              }
            }
            __name(J, "J");
            e.createForOfBindingStatement = J;
            function se(re, de, He) {
              return e.isBlock(de) ? re.updateBlock(de, e.setTextRange(re.createNodeArray(A([He], de.statements, true)), de.statements)) : re.createBlock(re.createNodeArray([de, He]), true);
            }
            __name(se, "se");
            e.insertLeadingStatement = se;
            function Le(re, de) {
              if (e.isQualifiedName(de)) {
                var He = Le(re, de.left), Nr = e.setParent(e.setTextRange(re.cloneNode(de.right), de.right), de.right.parent);
                return e.setTextRange(re.createPropertyAccessExpression(He, Nr), de);
              } else
                return e.setParent(e.setTextRange(re.cloneNode(de), de), de.parent);
            }
            __name(Le, "Le");
            e.createExpressionFromEntityName = Le;
            function Q(re, de) {
              return e.isIdentifier(de) ? re.createStringLiteralFromNode(de) : e.isComputedPropertyName(de) ? e.setParent(e.setTextRange(re.cloneNode(de.expression), de.expression), de.expression.parent) : e.setParent(e.setTextRange(re.cloneNode(de), de), de.parent);
            }
            __name(Q, "Q");
            e.createExpressionForPropertyName = Q;
            function Be(re, de, He, Nr, Yr) {
              var St = e.getAllAccessorDeclarations(de, He), Dt = St.firstAccessor, Lt = St.getAccessor, zt = St.setAccessor;
              if (He === Dt)
                return e.setTextRange(re.createObjectDefinePropertyCall(Nr, Q(re, He.name), re.createPropertyDescriptor({ enumerable: re.createFalse(), configurable: true, get: Lt && e.setTextRange(e.setOriginalNode(re.createFunctionExpression(e.getModifiers(Lt), void 0, void 0, void 0, Lt.parameters, void 0, Lt.body), Lt), Lt), set: zt && e.setTextRange(e.setOriginalNode(re.createFunctionExpression(e.getModifiers(zt), void 0, void 0, void 0, zt.parameters, void 0, zt.body), zt), zt) }, !Yr)), Dt);
            }
            __name(Be, "Be");
            function je(re, de, He) {
              return e.setOriginalNode(e.setTextRange(re.createAssignment(x(re, He, de.name, de.name), de.initializer), de), de);
            }
            __name(je, "je");
            function W(re, de, He) {
              return e.setOriginalNode(e.setTextRange(re.createAssignment(x(re, He, de.name, de.name), re.cloneNode(de.name)), de), de);
            }
            __name(W, "W");
            function B(re, de, He) {
              return e.setOriginalNode(e.setTextRange(re.createAssignment(x(re, He, de.name, de.name), e.setOriginalNode(e.setTextRange(re.createFunctionExpression(e.getModifiers(de), de.asteriskToken, void 0, void 0, de.parameters, void 0, de.body), de), de)), de), de);
            }
            __name(B, "B");
            function U(re, de, He, Nr) {
              switch (He.name && e.isPrivateIdentifier(He.name) && e.Debug.failBadSyntaxKind(He.name, "Private identifiers are not allowed in object literals."), He.kind) {
                case 174:
                case 175:
                  return Be(re, de.properties, He, Nr, !!de.multiLine);
                case 299:
                  return je(re, He, Nr);
                case 300:
                  return W(re, He, Nr);
                case 171:
                  return B(re, He, Nr);
              }
            }
            __name(U, "U");
            e.createExpressionForObjectLiteralElementLike = U;
            function m(re, de, He, Nr, Yr) {
              var St = de.operator;
              e.Debug.assert(St === 45 || St === 46, "Expected 'node' to be a pre- or post-increment or pre- or post-decrement expression");
              var Dt = re.createTempVariable(Nr);
              He = re.createAssignment(Dt, He), e.setTextRange(He, de.operand);
              var Lt = e.isPrefixUnaryExpression(de) ? re.createPrefixUnaryExpression(St, Dt) : re.createPostfixUnaryExpression(Dt, St);
              return e.setTextRange(Lt, de), Yr && (Lt = re.createAssignment(Yr, Lt), e.setTextRange(Lt, de)), He = re.createComma(He, Lt), e.setTextRange(He, de), e.isPostfixUnaryExpression(de) && (He = re.createComma(He, Dt), e.setTextRange(He, de)), He;
            }
            __name(m, "m");
            e.expandPreOrPostfixIncrementOrDecrementExpression = m;
            function v(re) {
              return (e.getEmitFlags(re) & 32768) !== 0;
            }
            __name(v, "v");
            e.isInternalName = v;
            function g(re) {
              return (e.getEmitFlags(re) & 16384) !== 0;
            }
            __name(g, "g");
            e.isLocalName = g;
            function O(re) {
              return (e.getEmitFlags(re) & 8192) !== 0;
            }
            __name(O, "O");
            e.isExportName = O;
            function S(re) {
              return e.isStringLiteral(re.expression) && re.expression.text === "use strict";
            }
            __name(S, "S");
            function te(re) {
              for (var de = 0, He = re; de < He.length; de++) {
                var Nr = He[de];
                if (e.isPrologueDirective(Nr)) {
                  if (S(Nr))
                    return Nr;
                } else
                  break;
              }
            }
            __name(te, "te");
            e.findUseStrictPrologue = te;
            function Je(re) {
              var de = e.firstOrUndefined(re);
              return de !== void 0 && e.isPrologueDirective(de) && S(de);
            }
            __name(Je, "Je");
            e.startsWithUseStrict = Je;
            function qe(re) {
              return re.kind === 223 && re.operatorToken.kind === 27 || re.kind === 354;
            }
            __name(qe, "qe");
            e.isCommaSequence = qe;
            function ge(re) {
              return e.isParenthesizedExpression(re) && e.isInJSFile(re) && !!e.getJSDocTypeTag(re);
            }
            __name(ge, "ge");
            e.isJSDocTypeAssertion = ge;
            function ie(re) {
              var de = e.getJSDocType(re);
              return e.Debug.assertIsDefined(de), de;
            }
            __name(ie, "ie");
            e.getJSDocTypeAssertionType = ie;
            function G(re, de) {
              switch (de === void 0 && (de = 15), re.kind) {
                case 214:
                  return de & 16 && ge(re) ? false : (de & 1) !== 0;
                case 213:
                case 231:
                case 235:
                  return (de & 2) !== 0;
                case 232:
                  return (de & 4) !== 0;
                case 353:
                  return (de & 8) !== 0;
              }
              return false;
            }
            __name(G, "G");
            e.isOuterExpression = G;
            function pe(re, de) {
              for (de === void 0 && (de = 15); G(re, de); )
                re = re.expression;
              return re;
            }
            __name(pe, "pe");
            e.skipOuterExpressions = pe;
            function j(re) {
              return pe(re, 6);
            }
            __name(j, "j");
            e.skipAssertions = j;
            function be(re) {
              return e.setStartsOnNewLine(re, true);
            }
            __name(be, "be");
            e.startOnNewLine = be;
            function $e(re) {
              var de = e.getOriginalNode(re, e.isSourceFile), He = de && de.emitNode;
              return He && He.externalHelpersModuleName;
            }
            __name($e, "$e");
            e.getExternalHelpersModuleName = $e;
            function Re(re) {
              var de = e.getOriginalNode(re, e.isSourceFile), He = de && de.emitNode;
              return !!He && (!!He.externalHelpersModuleName || !!He.externalHelpers);
            }
            __name(Re, "Re");
            e.hasRecordedExternalHelpers = Re;
            function Fe(re, de, He, Nr, Yr, St, Dt) {
              if (Nr.importHelpers && e.isEffectiveExternalModule(He, Nr)) {
                var Lt = void 0, zt = e.getEmitModuleKind(Nr);
                if (zt >= e.ModuleKind.ES2015 && zt <= e.ModuleKind.ESNext || He.impliedNodeFormat === e.ModuleKind.ESNext) {
                  var Zt = e.getEmitHelpers(He);
                  if (Zt) {
                    for (var mt = [], at = 0, k = Zt; at < k.length; at++) {
                      var ue = k[at];
                      if (!ue.scoped) {
                        var Qe = ue.importName;
                        Qe && e.pushIfUnique(mt, Qe);
                      }
                    }
                    if (e.some(mt)) {
                      mt.sort(e.compareStringsCaseSensitive), Lt = re.createNamedImports(e.map(mt, function(Xt) {
                        return e.isFileLevelUniqueName(He, Xt) ? re.createImportSpecifier(false, void 0, re.createIdentifier(Xt)) : re.createImportSpecifier(false, re.createIdentifier(Xt), de.getUnscopedHelperName(Xt));
                      }));
                      var Sr = e.getOriginalNode(He, e.isSourceFile), Kr = e.getOrCreateEmitNode(Sr);
                      Kr.externalHelpers = true;
                    }
                  }
                } else {
                  var Hr = dr(re, He, Nr, Yr, St || Dt);
                  Hr && (Lt = re.createNamespaceImport(Hr));
                }
                if (Lt) {
                  var Ct = re.createImportDeclaration(void 0, re.createImportClause(false, void 0, Lt), re.createStringLiteral(e.externalHelpersModuleNameText), void 0);
                  return e.addEmitFlags(Ct, 67108864), Ct;
                }
              }
            }
            __name(Fe, "Fe");
            e.createExternalHelpersImportDeclarationIfNeeded = Fe;
            function dr(re, de, He, Nr, Yr) {
              if (He.importHelpers && e.isEffectiveExternalModule(de, He)) {
                var St = $e(de);
                if (St)
                  return St;
                var Dt = e.getEmitModuleKind(He), Lt = (Nr || e.getESModuleInterop(He) && Yr) && Dt !== e.ModuleKind.System && (Dt < e.ModuleKind.ES2015 || de.impliedNodeFormat === e.ModuleKind.CommonJS);
                if (!Lt) {
                  var zt = e.getEmitHelpers(de);
                  if (zt)
                    for (var Zt = 0, mt = zt; Zt < mt.length; Zt++) {
                      var at = mt[Zt];
                      if (!at.scoped) {
                        Lt = true;
                        break;
                      }
                    }
                }
                if (Lt) {
                  var k = e.getOriginalNode(de, e.isSourceFile), ue = e.getOrCreateEmitNode(k);
                  return ue.externalHelpersModuleName || (ue.externalHelpersModuleName = re.createUniqueName(e.externalHelpersModuleNameText));
                }
              }
            }
            __name(dr, "dr");
            e.getOrCreateExternalHelpersModuleNameIfNeeded = dr;
            function ze(re, de, He) {
              var Nr = e.getNamespaceDeclarationNode(de);
              if (Nr && !e.isDefaultImport(de) && !e.isExportNamespaceAsDefaultDeclaration(de)) {
                var Yr = Nr.name;
                return e.isGeneratedIdentifier(Yr) ? Yr : re.createIdentifier(e.getSourceTextOfNodeFromSourceFile(He, Yr) || e.idText(Yr));
              }
              if (de.kind === 269 && de.importClause || de.kind === 275 && de.moduleSpecifier)
                return re.getGeneratedNameForNode(de);
            }
            __name(ze, "ze");
            e.getLocalNameForExternalImport = ze;
            function ve(re, de, He, Nr, Yr, St) {
              var Dt = e.getExternalModuleName(de);
              if (Dt && e.isStringLiteral(Dt))
                return Cr(de, Nr, re, Yr, St) || er(re, Dt, He) || re.cloneNode(Dt);
            }
            __name(ve, "ve");
            e.getExternalModuleNameLiteral = ve;
            function er(re, de, He) {
              var Nr = He.renamedDependencies && He.renamedDependencies.get(de.text);
              return Nr ? re.createStringLiteral(Nr) : void 0;
            }
            __name(er, "er");
            function ar(re, de, He, Nr) {
              if (!!de) {
                if (de.moduleName)
                  return re.createStringLiteral(de.moduleName);
                if (!de.isDeclarationFile && e.outFile(Nr))
                  return re.createStringLiteral(e.getExternalModuleNameFromPath(He, de.fileName));
              }
            }
            __name(ar, "ar");
            e.tryGetModuleNameFromFile = ar;
            function Cr(re, de, He, Nr, Yr) {
              return ar(He, Nr.getExternalModuleFileFromDeclaration(re), de, Yr);
            }
            __name(Cr, "Cr");
            function Ce(re) {
              if (e.isDeclarationBindingElement(re))
                return re.initializer;
              if (e.isPropertyAssignment(re)) {
                var de = re.initializer;
                return e.isAssignmentExpression(de, true) ? de.right : void 0;
              }
              if (e.isShorthandPropertyAssignment(re))
                return re.objectAssignmentInitializer;
              if (e.isAssignmentExpression(re, true))
                return re.right;
              if (e.isSpreadElement(re))
                return Ce(re.expression);
            }
            __name(Ce, "Ce");
            e.getInitializerOfBindingOrAssignmentElement = Ce;
            function Xe(re) {
              if (e.isDeclarationBindingElement(re))
                return re.name;
              if (e.isObjectLiteralElementLike(re)) {
                switch (re.kind) {
                  case 299:
                    return Xe(re.initializer);
                  case 300:
                    return re.name;
                  case 301:
                    return Xe(re.expression);
                }
                return;
              }
              return e.isAssignmentExpression(re, true) ? Xe(re.left) : e.isSpreadElement(re) ? Xe(re.expression) : re;
            }
            __name(Xe, "Xe");
            e.getTargetOfBindingOrAssignmentElement = Xe;
            function gr(re) {
              switch (re.kind) {
                case 166:
                case 205:
                  return re.dotDotDotToken;
                case 227:
                case 301:
                  return re;
              }
            }
            __name(gr, "gr");
            e.getRestIndicatorOfBindingOrAssignmentElement = gr;
            function X(re) {
              var de = Ee(re);
              return e.Debug.assert(!!de || e.isSpreadAssignment(re), "Invalid property name for binding element."), de;
            }
            __name(X, "X");
            e.getPropertyNameOfBindingOrAssignmentElement = X;
            function Ee(re) {
              switch (re.kind) {
                case 205:
                  if (re.propertyName) {
                    var de = re.propertyName;
                    return e.isPrivateIdentifier(de) ? e.Debug.failBadSyntaxKind(de) : e.isComputedPropertyName(de) && we(de.expression) ? de.expression : de;
                  }
                  break;
                case 299:
                  if (re.name) {
                    var de = re.name;
                    return e.isPrivateIdentifier(de) ? e.Debug.failBadSyntaxKind(de) : e.isComputedPropertyName(de) && we(de.expression) ? de.expression : de;
                  }
                  break;
                case 301:
                  return re.name && e.isPrivateIdentifier(re.name) ? e.Debug.failBadSyntaxKind(re.name) : re.name;
              }
              var He = Xe(re);
              if (He && e.isPropertyName(He))
                return He;
            }
            __name(Ee, "Ee");
            e.tryGetPropertyNameOfBindingOrAssignmentElement = Ee;
            function we(re) {
              var de = re.kind;
              return de === 10 || de === 8;
            }
            __name(we, "we");
            function he(re) {
              switch (re.kind) {
                case 203:
                case 204:
                case 206:
                  return re.elements;
                case 207:
                  return re.properties;
              }
            }
            __name(he, "he");
            e.getElementsOfBindingOrAssignmentPattern = he;
            function yr(re) {
              if (re)
                for (var de = re; ; ) {
                  if (e.isIdentifier(de) || !de.body)
                    return e.isIdentifier(de) ? de : de.name;
                  de = de.body;
                }
            }
            __name(yr, "yr");
            e.getJSDocTypeAliasName = yr;
            function kr(re) {
              var de = re.kind;
              return de === 173 || de === 175;
            }
            __name(kr, "kr");
            e.canHaveIllegalType = kr;
            function nr(re) {
              var de = re.kind;
              return de === 173 || de === 174 || de === 175;
            }
            __name(nr, "nr");
            e.canHaveIllegalTypeParameters = nr;
            function tr(re) {
              var de = re.kind;
              return de === 299 || de === 300 || de === 259 || de === 173 || de === 178 || de === 172 || de === 279 || de === 240 || de === 261 || de === 262 || de === 263 || de === 264 || de === 268 || de === 269 || de === 267 || de === 275 || de === 274;
            }
            __name(tr, "tr");
            e.canHaveIllegalDecorators = tr;
            function Lr(re) {
              var de = re.kind;
              return de === 172 || de === 299 || de === 300 || de === 181 || de === 279 || de === 267;
            }
            __name(Lr, "Lr");
            e.canHaveIllegalModifiers = Lr, e.isTypeNodeOrTypeParameterDeclaration = e.or(e.isTypeNode, e.isTypeParameterDeclaration), e.isQuestionOrExclamationToken = e.or(e.isQuestionToken, e.isExclamationToken), e.isIdentifierOrThisTypeNode = e.or(e.isIdentifier, e.isThisTypeNode), e.isReadonlyKeywordOrPlusOrMinusToken = e.or(e.isReadonlyKeyword, e.isPlusToken, e.isMinusToken), e.isQuestionOrPlusOrMinusToken = e.or(e.isQuestionToken, e.isPlusToken, e.isMinusToken), e.isModuleName = e.or(e.isIdentifier, e.isStringLiteral);
            function zr(re) {
              var de = re.kind;
              return de === 104 || de === 110 || de === 95 || e.isLiteralExpression(re) || e.isPrefixUnaryExpression(re);
            }
            __name(zr, "zr");
            e.isLiteralTypeLikeExpression = zr;
            function ye(re) {
              return re === 42;
            }
            __name(ye, "ye");
            function ir(re) {
              return re === 41 || re === 43 || re === 44;
            }
            __name(ir, "ir");
            function Dr(re) {
              return ye(re) || ir(re);
            }
            __name(Dr, "Dr");
            function Pr(re) {
              return re === 39 || re === 40;
            }
            __name(Pr, "Pr");
            function Br(re) {
              return Pr(re) || Dr(re);
            }
            __name(Br, "Br");
            function ut(re) {
              return re === 47 || re === 48 || re === 49;
            }
            __name(ut, "ut");
            function rt(re) {
              return ut(re) || Br(re);
            }
            __name(rt, "rt");
            function Z(re) {
              return re === 29 || re === 32 || re === 31 || re === 33 || re === 102 || re === 101;
            }
            __name(Z, "Z");
            function f(re) {
              return Z(re) || rt(re);
            }
            __name(f, "f");
            function h(re) {
              return re === 34 || re === 36 || re === 35 || re === 37;
            }
            __name(h, "h");
            function ae(re) {
              return h(re) || f(re);
            }
            __name(ae, "ae");
            function xr(re) {
              return re === 50 || re === 51 || re === 52;
            }
            __name(xr, "xr");
            function jr(re) {
              return xr(re) || ae(re);
            }
            __name(jr, "jr");
            function qr(re) {
              return re === 55 || re === 56;
            }
            __name(qr, "qr");
            function pt(re) {
              return qr(re) || jr(re);
            }
            __name(pt, "pt");
            function Ge(re) {
              return re === 60 || pt(re) || e.isAssignmentOperator(re);
            }
            __name(Ge, "Ge");
            function K(re) {
              return Ge(re) || re === 27;
            }
            __name(K, "K");
            function r(re) {
              return K(re.kind);
            }
            __name(r, "r");
            e.isBinaryOperatorToken = r;
            var ct;
            (function(re) {
              function de(mt, at, k, ue, Qe, Sr, Kr) {
                var Hr = at > 0 ? Qe[at - 1] : void 0;
                return e.Debug.assertEqual(k[at], de), Qe[at] = mt.onEnter(ue[at], Hr, Kr), k[at] = Lt(mt, de), at;
              }
              __name(de, "de");
              re.enter = de;
              function He(mt, at, k, ue, Qe, Sr, Kr) {
                e.Debug.assertEqual(k[at], He), e.Debug.assertIsDefined(mt.onLeft), k[at] = Lt(mt, He);
                var Hr = mt.onLeft(ue[at].left, Qe[at], ue[at]);
                return Hr ? (Zt(at, ue, Hr), zt(at, k, ue, Qe, Hr)) : at;
              }
              __name(He, "He");
              re.left = He;
              function Nr(mt, at, k, ue, Qe, Sr, Kr) {
                return e.Debug.assertEqual(k[at], Nr), e.Debug.assertIsDefined(mt.onOperator), k[at] = Lt(mt, Nr), mt.onOperator(ue[at].operatorToken, Qe[at], ue[at]), at;
              }
              __name(Nr, "Nr");
              re.operator = Nr;
              function Yr(mt, at, k, ue, Qe, Sr, Kr) {
                e.Debug.assertEqual(k[at], Yr), e.Debug.assertIsDefined(mt.onRight), k[at] = Lt(mt, Yr);
                var Hr = mt.onRight(ue[at].right, Qe[at], ue[at]);
                return Hr ? (Zt(at, ue, Hr), zt(at, k, ue, Qe, Hr)) : at;
              }
              __name(Yr, "Yr");
              re.right = Yr;
              function St(mt, at, k, ue, Qe, Sr, Kr) {
                e.Debug.assertEqual(k[at], St), k[at] = Lt(mt, St);
                var Hr = mt.onExit(ue[at], Qe[at]);
                if (at > 0) {
                  if (at--, mt.foldState) {
                    var Ct = k[at] === St ? "right" : "left";
                    Qe[at] = mt.foldState(Qe[at], Hr, Ct);
                  }
                } else
                  Sr.value = Hr;
                return at;
              }
              __name(St, "St");
              re.exit = St;
              function Dt(mt, at, k, ue, Qe, Sr, Kr) {
                return e.Debug.assertEqual(k[at], Dt), at;
              }
              __name(Dt, "Dt");
              re.done = Dt;
              function Lt(mt, at) {
                switch (at) {
                  case de:
                    if (mt.onLeft)
                      return He;
                  case He:
                    if (mt.onOperator)
                      return Nr;
                  case Nr:
                    if (mt.onRight)
                      return Yr;
                  case Yr:
                    return St;
                  case St:
                    return Dt;
                  case Dt:
                    return Dt;
                  default:
                    e.Debug.fail("Invalid state");
                }
              }
              __name(Lt, "Lt");
              re.nextState = Lt;
              function zt(mt, at, k, ue, Qe) {
                return mt++, at[mt] = de, k[mt] = Qe, ue[mt] = void 0, mt;
              }
              __name(zt, "zt");
              function Zt(mt, at, k) {
                if (e.Debug.shouldAssert(2))
                  for (; mt >= 0; )
                    e.Debug.assert(at[mt] !== k, "Circular traversal detected."), mt--;
              }
              __name(Zt, "Zt");
            })(ct || (ct = {}));
            var ft = function() {
              function re(de, He, Nr, Yr, St, Dt) {
                this.onEnter = de, this.onLeft = He, this.onOperator = Nr, this.onRight = Yr, this.onExit = St, this.foldState = Dt;
              }
              __name(re, "re");
              return re;
            }();
            function Ie(re, de, He, Nr, Yr, St) {
              var Dt = new ft(re, de, He, Nr, Yr, St);
              return Lt;
              function Lt(zt, Zt) {
                for (var mt = { value: void 0 }, at = [ct.enter], k = [zt], ue = [void 0], Qe = 0; at[Qe] !== ct.done; )
                  Qe = at[Qe](Dt, Qe, at, k, ue, mt, Zt);
                return e.Debug.assertEqual(Qe, 0), mt.value;
              }
              __name(Lt, "Lt");
            }
            __name(Ie, "Ie");
            e.createBinaryExpressionTrampoline = Ie;
            function me(re, de) {
              if (de !== void 0)
                return de.length === 0 ? de : e.setTextRange(re.createNodeArray([], de.hasTrailingComma), de);
            }
            __name(me, "me");
            e.elideNodes = me;
            function xe(re) {
              if (re.autoGenerateFlags & 4) {
                for (var de = re.autoGenerateId, He = re, Nr = He.original; Nr && (He = Nr, !(e.isMemberName(He) && !!(He.autoGenerateFlags & 4) && He.autoGenerateId !== de)); )
                  Nr = He.original;
                return He;
              }
              return re;
            }
            __name(xe, "xe");
            e.getNodeForGeneratedName = xe;
            function Ye(re, de) {
              return typeof re == "object" ? pr(false, re.prefix, re.node, re.suffix, de) : typeof re == "string" ? re.length > 0 && re.charCodeAt(0) === 35 ? re.slice(1) : re : "";
            }
            __name(Ye, "Ye");
            e.formatGeneratedNamePart = Ye;
            function vr(re, de) {
              return typeof re == "string" ? re : nt(re, e.Debug.checkDefined(de));
            }
            __name(vr, "vr");
            function nt(re, de) {
              return e.isGeneratedPrivateIdentifier(re) ? de(re).slice(1) : e.isGeneratedIdentifier(re) ? de(re) : e.isPrivateIdentifier(re) ? re.escapedText.slice(1) : e.idText(re);
            }
            __name(nt, "nt");
            function pr(re, de, He, Nr, Yr) {
              return de = Ye(de, Yr), Nr = Ye(Nr, Yr), He = vr(He, Yr), "".concat(re ? "#" : "").concat(de).concat(He).concat(Nr);
            }
            __name(pr, "pr");
            e.formatGeneratedName = pr;
            function Mr(re, de, He, Nr) {
              return re.updatePropertyDeclaration(de, He, re.getGeneratedPrivateNameForNode(de.name, void 0, "_accessor_storage"), void 0, void 0, Nr);
            }
            __name(Mr, "Mr");
            e.createAccessorPropertyBackingField = Mr;
            function ot(re, de, He, Nr) {
              return re.createGetAccessorDeclaration(He, Nr, [], void 0, re.createBlock([re.createReturnStatement(re.createPropertyAccessExpression(re.createThis(), re.getGeneratedPrivateNameForNode(de.name, void 0, "_accessor_storage")))]));
            }
            __name(ot, "ot");
            e.createAccessorPropertyGetRedirector = ot;
            function At(re, de, He, Nr) {
              return re.createSetAccessorDeclaration(He, Nr, [re.createParameterDeclaration(void 0, void 0, "value")], re.createBlock([re.createExpressionStatement(re.createAssignment(re.createPropertyAccessExpression(re.createThis(), re.getGeneratedPrivateNameForNode(de.name, void 0, "_accessor_storage")), re.createIdentifier("value")))]));
            }
            __name(At, "At");
            e.createAccessorPropertySetRedirector = At;
          })(N || (N = {}));
          var N;
          (function(e) {
            function t(q, F) {
              return F ? e.setTextRangePosEnd(q, F.pos, F.end) : q;
            }
            __name(t, "t");
            e.setTextRange = t;
            function x(q) {
              var F = q.kind;
              return F === 165 || F === 166 || F === 168 || F === 169 || F === 170 || F === 171 || F === 173 || F === 174 || F === 175 || F === 178 || F === 182 || F === 215 || F === 216 || F === 228 || F === 240 || F === 259 || F === 260 || F === 261 || F === 262 || F === 263 || F === 264 || F === 268 || F === 269 || F === 274 || F === 275;
            }
            __name(x, "x");
            e.canHaveModifiers = x;
            function s(q) {
              var F = q.kind;
              return F === 166 || F === 169 || F === 171 || F === 174 || F === 175 || F === 228 || F === 260;
            }
            __name(s, "s");
            e.canHaveDecorators = s;
          })(N || (N = {}));
          var N;
          (function(e) {
            var t, x;
            (function(Z) {
              Z[Z.None = 0] = "None", Z[Z.Yield = 1] = "Yield", Z[Z.Await = 2] = "Await", Z[Z.Type = 4] = "Type", Z[Z.IgnoreMissingOpenBrace = 16] = "IgnoreMissingOpenBrace", Z[Z.JSDoc = 32] = "JSDoc";
            })(x || (x = {}));
            var s;
            (function(Z) {
              Z[Z.TryParse = 0] = "TryParse", Z[Z.Lookahead = 1] = "Lookahead", Z[Z.Reparse = 2] = "Reparse";
            })(s || (s = {}));
            var q, F, fe, Te, Se;
            e.parseBaseNodeFactory = { createBaseSourceFileNode: function(Z) {
              return new (Se || (Se = e.objectAllocator.getSourceFileConstructor()))(Z, -1, -1);
            }, createBaseIdentifierNode: function(Z) {
              return new (fe || (fe = e.objectAllocator.getIdentifierConstructor()))(Z, -1, -1);
            }, createBasePrivateIdentifierNode: function(Z) {
              return new (Te || (Te = e.objectAllocator.getPrivateIdentifierConstructor()))(Z, -1, -1);
            }, createBaseTokenNode: function(Z) {
              return new (F || (F = e.objectAllocator.getTokenConstructor()))(Z, -1, -1);
            }, createBaseNode: function(Z) {
              return new (q || (q = e.objectAllocator.getNodeConstructor()))(Z, -1, -1);
            } }, e.parseNodeFactory = e.createNodeFactory(1, e.parseBaseNodeFactory);
            function J(Z, f) {
              return f && Z(f);
            }
            __name(J, "J");
            function se(Z, f, h) {
              if (h) {
                if (f)
                  return f(h);
                for (var ae = 0, xr = h; ae < xr.length; ae++) {
                  var jr = xr[ae], qr = Z(jr);
                  if (qr)
                    return qr;
                }
              }
            }
            __name(se, "se");
            function Le(Z, f) {
              return Z.charCodeAt(f + 1) === 42 && Z.charCodeAt(f + 2) === 42 && Z.charCodeAt(f + 3) !== 47;
            }
            __name(Le, "Le");
            e.isJSDocLikeText = Le;
            function Q(Z) {
              return e.forEach(Z.statements, Be) || je(Z);
            }
            __name(Q, "Q");
            e.isFileProbablyExternalModule = Q;
            function Be(Z) {
              return e.canHaveModifiers(Z) && B(Z, 93) || e.isImportEqualsDeclaration(Z) && e.isExternalModuleReference(Z.moduleReference) || e.isImportDeclaration(Z) || e.isExportAssignment(Z) || e.isExportDeclaration(Z) ? Z : void 0;
            }
            __name(Be, "Be");
            function je(Z) {
              return Z.flags & 4194304 ? W(Z) : void 0;
            }
            __name(je, "je");
            function W(Z) {
              return U(Z) ? Z : ze(Z, W);
            }
            __name(W, "W");
            function B(Z, f) {
              return e.some(Z.modifiers, function(h) {
                return h.kind === f;
              });
            }
            __name(B, "B");
            function U(Z) {
              return e.isMetaProperty(Z) && Z.keywordToken === 100 && Z.name.escapedText === "meta";
            }
            __name(U, "U");
            var m = (t = {}, t[163] = function(f, h, ae) {
              return J(h, f.left) || J(h, f.right);
            }, t[165] = function(f, h, ae) {
              return se(h, ae, f.modifiers) || J(h, f.name) || J(h, f.constraint) || J(h, f.default) || J(h, f.expression);
            }, t[300] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.name) || J(h, f.questionToken) || J(h, f.exclamationToken) || J(h, f.equalsToken) || J(h, f.objectAssignmentInitializer);
            }, t[301] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[166] = function(f, h, ae) {
              return se(h, ae, f.modifiers) || J(h, f.dotDotDotToken) || J(h, f.name) || J(h, f.questionToken) || J(h, f.type) || J(h, f.initializer);
            }, t[169] = function(f, h, ae) {
              return se(h, ae, f.modifiers) || J(h, f.name) || J(h, f.questionToken) || J(h, f.exclamationToken) || J(h, f.type) || J(h, f.initializer);
            }, t[168] = function(f, h, ae) {
              return se(h, ae, f.modifiers) || J(h, f.name) || J(h, f.questionToken) || J(h, f.type) || J(h, f.initializer);
            }, t[299] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.name) || J(h, f.questionToken) || J(h, f.exclamationToken) || J(h, f.initializer);
            }, t[257] = function(f, h, ae) {
              return J(h, f.name) || J(h, f.exclamationToken) || J(h, f.type) || J(h, f.initializer);
            }, t[205] = function(f, h, ae) {
              return J(h, f.dotDotDotToken) || J(h, f.propertyName) || J(h, f.name) || J(h, f.initializer);
            }, t[178] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || se(h, ae, f.typeParameters) || se(h, ae, f.parameters) || J(h, f.type);
            }, t[182] = function(f, h, ae) {
              return se(h, ae, f.modifiers) || se(h, ae, f.typeParameters) || se(h, ae, f.parameters) || J(h, f.type);
            }, t[181] = function(f, h, ae) {
              return se(h, ae, f.modifiers) || se(h, ae, f.typeParameters) || se(h, ae, f.parameters) || J(h, f.type);
            }, t[176] = v, t[177] = v, t[171] = function(f, h, ae) {
              return se(h, ae, f.modifiers) || J(h, f.asteriskToken) || J(h, f.name) || J(h, f.questionToken) || J(h, f.exclamationToken) || se(h, ae, f.typeParameters) || se(h, ae, f.parameters) || J(h, f.type) || J(h, f.body);
            }, t[170] = function(f, h, ae) {
              return se(h, ae, f.modifiers) || J(h, f.name) || J(h, f.questionToken) || se(h, ae, f.typeParameters) || se(h, ae, f.parameters) || J(h, f.type);
            }, t[173] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.name) || se(h, ae, f.typeParameters) || se(h, ae, f.parameters) || J(h, f.type) || J(h, f.body);
            }, t[174] = function(f, h, ae) {
              return se(h, ae, f.modifiers) || J(h, f.name) || se(h, ae, f.typeParameters) || se(h, ae, f.parameters) || J(h, f.type) || J(h, f.body);
            }, t[175] = function(f, h, ae) {
              return se(h, ae, f.modifiers) || J(h, f.name) || se(h, ae, f.typeParameters) || se(h, ae, f.parameters) || J(h, f.type) || J(h, f.body);
            }, t[259] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.asteriskToken) || J(h, f.name) || se(h, ae, f.typeParameters) || se(h, ae, f.parameters) || J(h, f.type) || J(h, f.body);
            }, t[215] = function(f, h, ae) {
              return se(h, ae, f.modifiers) || J(h, f.asteriskToken) || J(h, f.name) || se(h, ae, f.typeParameters) || se(h, ae, f.parameters) || J(h, f.type) || J(h, f.body);
            }, t[216] = function(f, h, ae) {
              return se(h, ae, f.modifiers) || se(h, ae, f.typeParameters) || se(h, ae, f.parameters) || J(h, f.type) || J(h, f.equalsGreaterThanToken) || J(h, f.body);
            }, t[172] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.body);
            }, t[180] = function(f, h, ae) {
              return J(h, f.typeName) || se(h, ae, f.typeArguments);
            }, t[179] = function(f, h, ae) {
              return J(h, f.assertsModifier) || J(h, f.parameterName) || J(h, f.type);
            }, t[183] = function(f, h, ae) {
              return J(h, f.exprName) || se(h, ae, f.typeArguments);
            }, t[184] = function(f, h, ae) {
              return se(h, ae, f.members);
            }, t[185] = function(f, h, ae) {
              return J(h, f.elementType);
            }, t[186] = function(f, h, ae) {
              return se(h, ae, f.elements);
            }, t[189] = g, t[190] = g, t[191] = function(f, h, ae) {
              return J(h, f.checkType) || J(h, f.extendsType) || J(h, f.trueType) || J(h, f.falseType);
            }, t[192] = function(f, h, ae) {
              return J(h, f.typeParameter);
            }, t[202] = function(f, h, ae) {
              return J(h, f.argument) || J(h, f.assertions) || J(h, f.qualifier) || se(h, ae, f.typeArguments);
            }, t[298] = function(f, h, ae) {
              return J(h, f.assertClause);
            }, t[193] = O, t[195] = O, t[196] = function(f, h, ae) {
              return J(h, f.objectType) || J(h, f.indexType);
            }, t[197] = function(f, h, ae) {
              return J(h, f.readonlyToken) || J(h, f.typeParameter) || J(h, f.nameType) || J(h, f.questionToken) || J(h, f.type) || se(h, ae, f.members);
            }, t[198] = function(f, h, ae) {
              return J(h, f.literal);
            }, t[199] = function(f, h, ae) {
              return J(h, f.dotDotDotToken) || J(h, f.name) || J(h, f.questionToken) || J(h, f.type);
            }, t[203] = S, t[204] = S, t[206] = function(f, h, ae) {
              return se(h, ae, f.elements);
            }, t[207] = function(f, h, ae) {
              return se(h, ae, f.properties);
            }, t[208] = function(f, h, ae) {
              return J(h, f.expression) || J(h, f.questionDotToken) || J(h, f.name);
            }, t[209] = function(f, h, ae) {
              return J(h, f.expression) || J(h, f.questionDotToken) || J(h, f.argumentExpression);
            }, t[210] = te, t[211] = te, t[212] = function(f, h, ae) {
              return J(h, f.tag) || J(h, f.questionDotToken) || se(h, ae, f.typeArguments) || J(h, f.template);
            }, t[213] = function(f, h, ae) {
              return J(h, f.type) || J(h, f.expression);
            }, t[214] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[217] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[218] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[219] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[221] = function(f, h, ae) {
              return J(h, f.operand);
            }, t[226] = function(f, h, ae) {
              return J(h, f.asteriskToken) || J(h, f.expression);
            }, t[220] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[222] = function(f, h, ae) {
              return J(h, f.operand);
            }, t[223] = function(f, h, ae) {
              return J(h, f.left) || J(h, f.operatorToken) || J(h, f.right);
            }, t[231] = function(f, h, ae) {
              return J(h, f.expression) || J(h, f.type);
            }, t[232] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[235] = function(f, h, ae) {
              return J(h, f.expression) || J(h, f.type);
            }, t[233] = function(f, h, ae) {
              return J(h, f.name);
            }, t[224] = function(f, h, ae) {
              return J(h, f.condition) || J(h, f.questionToken) || J(h, f.whenTrue) || J(h, f.colonToken) || J(h, f.whenFalse);
            }, t[227] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[238] = Je, t[265] = Je, t[308] = function(f, h, ae) {
              return se(h, ae, f.statements) || J(h, f.endOfFileToken);
            }, t[240] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.declarationList);
            }, t[258] = function(f, h, ae) {
              return se(h, ae, f.declarations);
            }, t[241] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[242] = function(f, h, ae) {
              return J(h, f.expression) || J(h, f.thenStatement) || J(h, f.elseStatement);
            }, t[243] = function(f, h, ae) {
              return J(h, f.statement) || J(h, f.expression);
            }, t[244] = function(f, h, ae) {
              return J(h, f.expression) || J(h, f.statement);
            }, t[245] = function(f, h, ae) {
              return J(h, f.initializer) || J(h, f.condition) || J(h, f.incrementor) || J(h, f.statement);
            }, t[246] = function(f, h, ae) {
              return J(h, f.initializer) || J(h, f.expression) || J(h, f.statement);
            }, t[247] = function(f, h, ae) {
              return J(h, f.awaitModifier) || J(h, f.initializer) || J(h, f.expression) || J(h, f.statement);
            }, t[248] = qe, t[249] = qe, t[250] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[251] = function(f, h, ae) {
              return J(h, f.expression) || J(h, f.statement);
            }, t[252] = function(f, h, ae) {
              return J(h, f.expression) || J(h, f.caseBlock);
            }, t[266] = function(f, h, ae) {
              return se(h, ae, f.clauses);
            }, t[292] = function(f, h, ae) {
              return J(h, f.expression) || se(h, ae, f.statements);
            }, t[293] = function(f, h, ae) {
              return se(h, ae, f.statements);
            }, t[253] = function(f, h, ae) {
              return J(h, f.label) || J(h, f.statement);
            }, t[254] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[255] = function(f, h, ae) {
              return J(h, f.tryBlock) || J(h, f.catchClause) || J(h, f.finallyBlock);
            }, t[295] = function(f, h, ae) {
              return J(h, f.variableDeclaration) || J(h, f.block);
            }, t[167] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[260] = ge, t[228] = ge, t[261] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.name) || se(h, ae, f.typeParameters) || se(h, ae, f.heritageClauses) || se(h, ae, f.members);
            }, t[262] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.name) || se(h, ae, f.typeParameters) || J(h, f.type);
            }, t[263] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.name) || se(h, ae, f.members);
            }, t[302] = function(f, h, ae) {
              return J(h, f.name) || J(h, f.initializer);
            }, t[264] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.name) || J(h, f.body);
            }, t[268] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.name) || J(h, f.moduleReference);
            }, t[269] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.importClause) || J(h, f.moduleSpecifier) || J(h, f.assertClause);
            }, t[270] = function(f, h, ae) {
              return J(h, f.name) || J(h, f.namedBindings);
            }, t[296] = function(f, h, ae) {
              return se(h, ae, f.elements);
            }, t[297] = function(f, h, ae) {
              return J(h, f.name) || J(h, f.value);
            }, t[267] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || J(h, f.name);
            }, t[271] = function(f, h, ae) {
              return J(h, f.name);
            }, t[277] = function(f, h, ae) {
              return J(h, f.name);
            }, t[272] = ie, t[276] = ie, t[275] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.exportClause) || J(h, f.moduleSpecifier) || J(h, f.assertClause);
            }, t[273] = G, t[278] = G, t[274] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers) || J(h, f.expression);
            }, t[225] = function(f, h, ae) {
              return J(h, f.head) || se(h, ae, f.templateSpans);
            }, t[236] = function(f, h, ae) {
              return J(h, f.expression) || J(h, f.literal);
            }, t[200] = function(f, h, ae) {
              return J(h, f.head) || se(h, ae, f.templateSpans);
            }, t[201] = function(f, h, ae) {
              return J(h, f.type) || J(h, f.literal);
            }, t[164] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[294] = function(f, h, ae) {
              return se(h, ae, f.types);
            }, t[230] = function(f, h, ae) {
              return J(h, f.expression) || se(h, ae, f.typeArguments);
            }, t[280] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[279] = function(f, h, ae) {
              return se(h, ae, f.illegalDecorators) || se(h, ae, f.modifiers);
            }, t[354] = function(f, h, ae) {
              return se(h, ae, f.elements);
            }, t[281] = function(f, h, ae) {
              return J(h, f.openingElement) || se(h, ae, f.children) || J(h, f.closingElement);
            }, t[285] = function(f, h, ae) {
              return J(h, f.openingFragment) || se(h, ae, f.children) || J(h, f.closingFragment);
            }, t[282] = pe, t[283] = pe, t[289] = function(f, h, ae) {
              return se(h, ae, f.properties);
            }, t[288] = function(f, h, ae) {
              return J(h, f.name) || J(h, f.initializer);
            }, t[290] = function(f, h, ae) {
              return J(h, f.expression);
            }, t[291] = function(f, h, ae) {
              return J(h, f.dotDotDotToken) || J(h, f.expression);
            }, t[284] = function(f, h, ae) {
              return J(h, f.tagName);
            }, t[187] = j, t[188] = j, t[312] = j, t[318] = j, t[317] = j, t[319] = j, t[321] = j, t[320] = function(f, h, ae) {
              return se(h, ae, f.parameters) || J(h, f.type);
            }, t[323] = function(f, h, ae) {
              return (typeof f.comment == "string" ? void 0 : se(h, ae, f.comment)) || se(h, ae, f.tags);
            }, t[349] = function(f, h, ae) {
              return J(h, f.tagName) || J(h, f.name) || (typeof f.comment == "string" ? void 0 : se(h, ae, f.comment));
            }, t[313] = function(f, h, ae) {
              return J(h, f.name);
            }, t[314] = function(f, h, ae) {
              return J(h, f.left) || J(h, f.right);
            }, t[343] = be, t[350] = be, t[333] = function(f, h, ae) {
              return J(h, f.tagName) || (typeof f.comment == "string" ? void 0 : se(h, ae, f.comment));
            }, t[332] = function(f, h, ae) {
              return J(h, f.tagName) || J(h, f.class) || (typeof f.comment == "string" ? void 0 : se(h, ae, f.comment));
            }, t[331] = function(f, h, ae) {
              return J(h, f.tagName) || J(h, f.class) || (typeof f.comment == "string" ? void 0 : se(h, ae, f.comment));
            }, t[347] = function(f, h, ae) {
              return J(h, f.tagName) || J(h, f.constraint) || se(h, ae, f.typeParameters) || (typeof f.comment == "string" ? void 0 : se(h, ae, f.comment));
            }, t[348] = function(f, h, ae) {
              return J(h, f.tagName) || (f.typeExpression && f.typeExpression.kind === 312 ? J(h, f.typeExpression) || J(h, f.fullName) || (typeof f.comment == "string" ? void 0 : se(h, ae, f.comment)) : J(h, f.fullName) || J(h, f.typeExpression) || (typeof f.comment == "string" ? void 0 : se(h, ae, f.comment)));
            }, t[341] = function(f, h, ae) {
              return J(h, f.tagName) || J(h, f.fullName) || J(h, f.typeExpression) || (typeof f.comment == "string" ? void 0 : se(h, ae, f.comment));
            }, t[344] = $e, t[346] = $e, t[345] = $e, t[342] = $e, t[326] = function(f, h, ae) {
              return e.forEach(f.typeParameters, h) || e.forEach(f.parameters, h) || J(h, f.type);
            }, t[327] = Re, t[328] = Re, t[329] = Re, t[325] = function(f, h, ae) {
              return e.forEach(f.jsDocPropertyTags, h);
            }, t[330] = Fe, t[335] = Fe, t[336] = Fe, t[337] = Fe, t[338] = Fe, t[339] = Fe, t[334] = Fe, t[340] = Fe, t[353] = dr, t);
            function v(Z, f, h) {
              return se(f, h, Z.typeParameters) || se(f, h, Z.parameters) || J(f, Z.type);
            }
            __name(v, "v");
            function g(Z, f, h) {
              return se(f, h, Z.types);
            }
            __name(g, "g");
            function O(Z, f, h) {
              return J(f, Z.type);
            }
            __name(O, "O");
            function S(Z, f, h) {
              return se(f, h, Z.elements);
            }
            __name(S, "S");
            function te(Z, f, h) {
              return J(f, Z.expression) || J(f, Z.questionDotToken) || se(f, h, Z.typeArguments) || se(f, h, Z.arguments);
            }
            __name(te, "te");
            function Je(Z, f, h) {
              return se(f, h, Z.statements);
            }
            __name(Je, "Je");
            function qe(Z, f, h) {
              return J(f, Z.label);
            }
            __name(qe, "qe");
            function ge(Z, f, h) {
              return se(f, h, Z.modifiers) || J(f, Z.name) || se(f, h, Z.typeParameters) || se(f, h, Z.heritageClauses) || se(f, h, Z.members);
            }
            __name(ge, "ge");
            function ie(Z, f, h) {
              return se(f, h, Z.elements);
            }
            __name(ie, "ie");
            function G(Z, f, h) {
              return J(f, Z.propertyName) || J(f, Z.name);
            }
            __name(G, "G");
            function pe(Z, f, h) {
              return J(f, Z.tagName) || se(f, h, Z.typeArguments) || J(f, Z.attributes);
            }
            __name(pe, "pe");
            function j(Z, f, h) {
              return J(f, Z.type);
            }
            __name(j, "j");
            function be(Z, f, h) {
              return J(f, Z.tagName) || (Z.isNameFirst ? J(f, Z.name) || J(f, Z.typeExpression) : J(f, Z.typeExpression) || J(f, Z.name)) || (typeof Z.comment == "string" ? void 0 : se(f, h, Z.comment));
            }
            __name(be, "be");
            function $e(Z, f, h) {
              return J(f, Z.tagName) || J(f, Z.typeExpression) || (typeof Z.comment == "string" ? void 0 : se(f, h, Z.comment));
            }
            __name($e, "$e");
            function Re(Z, f, h) {
              return J(f, Z.name);
            }
            __name(Re, "Re");
            function Fe(Z, f, h) {
              return J(f, Z.tagName) || (typeof Z.comment == "string" ? void 0 : se(f, h, Z.comment));
            }
            __name(Fe, "Fe");
            function dr(Z, f, h) {
              return J(f, Z.expression);
            }
            __name(dr, "dr");
            function ze(Z, f, h) {
              if (!(Z === void 0 || Z.kind <= 162)) {
                var ae = m[Z.kind];
                return ae === void 0 ? void 0 : ae(Z, f, h);
              }
            }
            __name(ze, "ze");
            e.forEachChild = ze;
            function ve(Z, f, h) {
              for (var ae = er(Z), xr = []; xr.length < ae.length; )
                xr.push(Z);
              for (; ae.length !== 0; ) {
                var jr = ae.pop(), qr = xr.pop();
                if (e.isArray(jr)) {
                  if (h) {
                    var pt = h(jr, qr);
                    if (pt) {
                      if (pt === "skip")
                        continue;
                      return pt;
                    }
                  }
                  for (var Ge = jr.length - 1; Ge >= 0; --Ge)
                    ae.push(jr[Ge]), xr.push(qr);
                } else {
                  var pt = f(jr, qr);
                  if (pt) {
                    if (pt === "skip")
                      continue;
                    return pt;
                  }
                  if (jr.kind >= 163)
                    for (var K = 0, r = er(jr); K < r.length; K++) {
                      var ct = r[K];
                      ae.push(ct), xr.push(jr);
                    }
                }
              }
            }
            __name(ve, "ve");
            e.forEachChildRecursively = ve;
            function er(Z) {
              var f = [];
              return ze(Z, h, h), f;
              function h(ae) {
                f.unshift(ae);
              }
              __name(h, "h");
            }
            __name(er, "er");
            function ar(Z) {
              Z.externalModuleIndicator = Q(Z);
            }
            __name(ar, "ar");
            function Cr(Z, f, h, ae, xr) {
              ae === void 0 && (ae = false), e.tracing === null || e.tracing === void 0 || e.tracing.push("parse", "createSourceFile", { path: Z }, true), e.performance.mark("beforeParse");
              var jr;
              e.perfLogger.logStartParseSourceFile(Z);
              var qr = typeof h == "object" ? h : { languageVersion: h }, pt = qr.languageVersion, Ge = qr.setExternalModuleIndicator, K = qr.impliedNodeFormat;
              if (pt === 100)
                jr = he.parseSourceFile(Z, f, pt, void 0, ae, 6, e.noop);
              else {
                var r = K === void 0 ? Ge : function(ct) {
                  return ct.impliedNodeFormat = K, (Ge || ar)(ct);
                };
                jr = he.parseSourceFile(Z, f, pt, void 0, ae, xr, r);
              }
              return e.perfLogger.logStopParseSourceFile(), e.performance.mark("afterParse"), e.performance.measure("Parse", "beforeParse", "afterParse"), e.tracing === null || e.tracing === void 0 || e.tracing.pop(), jr;
            }
            __name(Cr, "Cr");
            e.createSourceFile = Cr;
            function Ce(Z, f) {
              return he.parseIsolatedEntityName(Z, f);
            }
            __name(Ce, "Ce");
            e.parseIsolatedEntityName = Ce;
            function Xe(Z, f) {
              return he.parseJsonText(Z, f);
            }
            __name(Xe, "Xe");
            e.parseJsonText = Xe;
            function gr(Z) {
              return Z.externalModuleIndicator !== void 0;
            }
            __name(gr, "gr");
            e.isExternalModule = gr;
            function X(Z, f, h, ae) {
              ae === void 0 && (ae = false);
              var xr = yr.updateSourceFile(Z, f, h, ae);
              return xr.flags |= Z.flags & 6291456, xr;
            }
            __name(X, "X");
            e.updateSourceFile = X;
            function Ee(Z, f, h) {
              var ae = he.JSDocParser.parseIsolatedJSDocComment(Z, f, h);
              return ae && ae.jsDoc && he.fixupParentReferences(ae.jsDoc), ae;
            }
            __name(Ee, "Ee");
            e.parseIsolatedJSDocComment = Ee;
            function we(Z, f, h) {
              return he.JSDocParser.parseJSDocTypeExpressionForTests(Z, f, h);
            }
            __name(we, "we");
            e.parseJSDocTypeExpressionForTests = we;
            var he;
            (function(Z) {
              var f = e.createScanner(99, true), h = 20480, ae, xr, jr, qr, pt;
              function Ge(d) {
                return ot++, d;
              }
              __name(Ge, "Ge");
              var K = { createBaseSourceFileNode: function(d) {
                return Ge(new pt(d, 0, 0));
              }, createBaseIdentifierNode: function(d) {
                return Ge(new jr(d, 0, 0));
              }, createBasePrivateIdentifierNode: function(d) {
                return Ge(new qr(d, 0, 0));
              }, createBaseTokenNode: function(d) {
                return Ge(new xr(d, 0, 0));
              }, createBaseNode: function(d) {
                return Ge(new ae(d, 0, 0));
              } }, r = e.createNodeFactory(11, K), ct, ft, Ie, me, xe, Ye, vr, nt, pr, Mr, ot, At, re, de, He, Nr, Yr, St = true, Dt = false;
              function Lt(d, P, $, ce, Pe, We, Er) {
                var Rr;
                if (Pe === void 0 && (Pe = false), We = e.ensureScriptKind(d, We), We === 6) {
                  var Fr = Zt(d, P, $, ce, Pe);
                  return e.convertToObjectWorker(Fr, (Rr = Fr.statements[0]) === null || Rr === void 0 ? void 0 : Rr.expression, Fr.parseDiagnostics, false, void 0, void 0), Fr.referencedFiles = e.emptyArray, Fr.typeReferenceDirectives = e.emptyArray, Fr.libReferenceDirectives = e.emptyArray, Fr.amdDependencies = e.emptyArray, Fr.hasNoDefaultLib = false, Fr.pragmas = e.emptyMap, Fr;
                }
                mt(d, P, $, ce, We);
                var et = k($, Pe, We, Er || ar);
                return at(), et;
              }
              __name(Lt, "Lt");
              Z.parseSourceFile = Lt;
              function zt(d, P) {
                mt("", d, P, void 0, 1), fr();
                var $ = Qt(true), ce = L() === 1 && !vr.length;
                return at(), ce ? $ : void 0;
              }
              __name(zt, "zt");
              Z.parseIsolatedEntityName = zt;
              function Zt(d, P, $, ce, Pe) {
                $ === void 0 && ($ = 2), Pe === void 0 && (Pe = false), mt(d, P, $, ce, 6), ft = Yr, fr();
                var We = Ae(), Er, Rr;
                if (L() === 1)
                  Er = vn([], We, We), Rr = An();
                else {
                  for (var Fr = void 0; L() !== 1; ) {
                    var et = void 0;
                    switch (L()) {
                      case 22:
                        et = ic();
                        break;
                      case 110:
                      case 95:
                      case 104:
                        et = An();
                        break;
                      case 40:
                        Gr(function() {
                          return fr() === 8 && fr() !== 58;
                        }) ? et = z_() : et = a_();
                        break;
                      case 8:
                      case 10:
                        if (Gr(function() {
                          return fr() !== 58;
                        })) {
                          et = Ji();
                          break;
                        }
                      default:
                        et = a_();
                        break;
                    }
                    Fr && e.isArray(Fr) ? Fr.push(et) : Fr ? Fr = [Fr, et] : (Fr = et, L() !== 1 && gt(e.Diagnostics.Unexpected_token));
                  }
                  var xt = e.isArray(Fr) ? Ue(r.createArrayLiteralExpression(Fr), We) : e.Debug.checkDefined(Fr), Gt = r.createExpressionStatement(xt);
                  Ue(Gt, We), Er = vn([Gt], We), Rr = mn(1, e.Diagnostics.Unexpected_token);
                }
                var Wt = Ct(d, 2, 6, false, Er, Rr, ft, e.noop);
                Pe && Hr(Wt), Wt.nodeCount = ot, Wt.identifierCount = de, Wt.identifiers = At, Wt.parseDiagnostics = e.attachFileToDiagnostics(vr, Wt), nt && (Wt.jsDocDiagnostics = e.attachFileToDiagnostics(nt, Wt));
                var pn = Wt;
                return at(), pn;
              }
              __name(Zt, "Zt");
              Z.parseJsonText = Zt;
              function mt(d, P, $, ce, Pe) {
                switch (ae = e.objectAllocator.getNodeConstructor(), xr = e.objectAllocator.getTokenConstructor(), jr = e.objectAllocator.getIdentifierConstructor(), qr = e.objectAllocator.getPrivateIdentifierConstructor(), pt = e.objectAllocator.getSourceFileConstructor(), ct = e.normalizePath(d), Ie = P, me = $, pr = ce, xe = Pe, Ye = e.getLanguageVariant(Pe), vr = [], He = 0, At = new e.Map(), re = new e.Map(), de = 0, ot = 0, ft = 0, St = true, xe) {
                  case 1:
                  case 2:
                    Yr = 262144;
                    break;
                  case 6:
                    Yr = 67371008;
                    break;
                  default:
                    Yr = 0;
                    break;
                }
                Dt = false, f.setText(Ie), f.setOnError(br), f.setScriptTarget(me), f.setLanguageVariant(Ye);
              }
              __name(mt, "mt");
              function at() {
                f.clearCommentDirectives(), f.setText(""), f.setOnError(void 0), Ie = void 0, me = void 0, pr = void 0, xe = void 0, Ye = void 0, ft = 0, vr = void 0, nt = void 0, He = 0, At = void 0, Nr = void 0, St = true;
              }
              __name(at, "at");
              function k(d, P, $, ce) {
                var Pe = kr(ct);
                Pe && (Yr |= 16777216), ft = Yr, fr();
                var We = Jn(0, ki);
                e.Debug.assert(L() === 1);
                var Er = Sr(An()), Rr = Ct(ct, d, $, Pe, We, Er, ft, ce);
                return tr(Rr, Ie), Lr(Rr, Fr), Rr.commentDirectives = f.getCommentDirectives(), Rr.nodeCount = ot, Rr.identifierCount = de, Rr.identifiers = At, Rr.parseDiagnostics = e.attachFileToDiagnostics(vr, Rr), nt && (Rr.jsDocDiagnostics = e.attachFileToDiagnostics(nt, Rr)), P && Hr(Rr), Rr;
                function Fr(et, xt, Gt) {
                  vr.push(e.createDetachedDiagnostic(ct, et, xt, Gt));
                }
                __name(Fr, "Fr");
              }
              __name(k, "k");
              function ue(d, P) {
                return P ? Sr(d) : d;
              }
              __name(ue, "ue");
              var Qe = false;
              function Sr(d) {
                e.Debug.assert(!d.jsDoc);
                var P = e.mapDefined(e.getJSDocCommentRanges(d, Ie), function($) {
                  return Oc.parseJSDocComment(d, $.pos, $.end - $.pos);
                });
                return P.length && (d.jsDoc = P), Qe && (Qe = false, d.flags |= 268435456), d;
              }
              __name(Sr, "Sr");
              function Kr(d) {
                var P = pr, $ = yr.createSyntaxCursor(d);
                pr = { currentNode: pn };
                var ce = [], Pe = vr;
                vr = [];
                for (var We = 0, Er = Gt(d.statements, 0), Rr = function() {
                  var Pn = d.statements[We], _i = d.statements[Er];
                  e.addRange(ce, d.statements, We, Er), We = Wt(d.statements, Er);
                  var Ln = e.findIndex(Pe, function(Di) {
                    return Di.start >= Pn.pos;
                  }), ha = Ln >= 0 ? e.findIndex(Pe, function(Di) {
                    return Di.start >= _i.pos;
                  }, Ln) : -1;
                  Ln >= 0 && e.addRange(vr, Pe, Ln, ha >= 0 ? ha : void 0), _e(function() {
                    var Di = Yr;
                    for (Yr |= 32768, f.setTextPos(_i.pos), fr(); L() !== 1; ) {
                      var Xn = f.getStartPos(), Pi = ra(0, ki);
                      if (ce.push(Pi), Xn === f.getStartPos() && fr(), We >= 0) {
                        var oa = d.statements[We];
                        if (Pi.end === oa.pos)
                          break;
                        Pi.end > oa.pos && (We = Wt(d.statements, We + 1));
                      }
                    }
                    Yr = Di;
                  }, 2), Er = We >= 0 ? Gt(d.statements, We) : -1;
                }; Er !== -1; )
                  Rr();
                if (We >= 0) {
                  var Fr = d.statements[We];
                  e.addRange(ce, d.statements, We);
                  var et = e.findIndex(Pe, function(Pn) {
                    return Pn.start >= Fr.pos;
                  });
                  et >= 0 && e.addRange(vr, Pe, et);
                }
                return pr = P, r.updateSourceFile(d, e.setTextRange(r.createNodeArray(ce), d.statements));
                function xt(Pn) {
                  return !(Pn.flags & 32768) && !!(Pn.transformFlags & 67108864);
                }
                __name(xt, "xt");
                function Gt(Pn, _i) {
                  for (var Ln = _i; Ln < Pn.length; Ln++)
                    if (xt(Pn[Ln]))
                      return Ln;
                  return -1;
                }
                __name(Gt, "Gt");
                function Wt(Pn, _i) {
                  for (var Ln = _i; Ln < Pn.length; Ln++)
                    if (!xt(Pn[Ln]))
                      return Ln;
                  return -1;
                }
                __name(Wt, "Wt");
                function pn(Pn) {
                  var _i = $.currentNode(Pn);
                  return St && _i && xt(_i) && (_i.intersectsChange = true), _i;
                }
                __name(pn, "pn");
              }
              __name(Kr, "Kr");
              function Hr(d) {
                e.setParentRecursive(d, true);
              }
              __name(Hr, "Hr");
              Z.fixupParentReferences = Hr;
              function Ct(d, P, $, ce, Pe, We, Er, Rr) {
                var Fr = r.createSourceFile(Pe, We, Er);
                return e.setTextRangePosWidth(Fr, 0, Ie.length), et(Fr), !ce && gr(Fr) && Fr.transformFlags & 67108864 && (Fr = Kr(Fr), et(Fr)), Fr;
                function et(xt) {
                  xt.text = Ie, xt.bindDiagnostics = [], xt.bindSuggestionDiagnostics = void 0, xt.languageVersion = P, xt.fileName = d, xt.languageVariant = e.getLanguageVariant($), xt.isDeclarationFile = ce, xt.scriptKind = $, Rr(xt), xt.setExternalModuleIndicator = Rr;
                }
                __name(et, "et");
              }
              __name(Ct, "Ct");
              function Xt(d, P) {
                d ? Yr |= P : Yr &= ~P;
              }
              __name(Xt, "Xt");
              function cn(d) {
                Xt(d, 4096);
              }
              __name(cn, "cn");
              function In(d) {
                Xt(d, 8192);
              }
              __name(In, "In");
              function yn(d) {
                Xt(d, 16384);
              }
              __name(yn, "yn");
              function hn(d) {
                Xt(d, 32768);
              }
              __name(hn, "hn");
              function ln(d, P) {
                var $ = d & Yr;
                if ($) {
                  Xt(false, $);
                  var ce = P();
                  return Xt(true, $), ce;
                }
                return P();
              }
              __name(ln, "ln");
              function En(d, P) {
                var $ = d & ~Yr;
                if ($) {
                  Xt(true, $);
                  var ce = P();
                  return Xt(false, $), ce;
                }
                return P();
              }
              __name(En, "En");
              function Vt(d) {
                return ln(4096, d);
              }
              __name(Vt, "Vt");
              function ui(d) {
                return En(4096, d);
              }
              __name(ui, "ui");
              function ei(d) {
                return ln(65536, d);
              }
              __name(ei, "ei");
              function vi(d) {
                return En(65536, d);
              }
              __name(vi, "vi");
              function ri(d) {
                return En(8192, d);
              }
              __name(ri, "ri");
              function bi(d) {
                return En(16384, d);
              }
              __name(bi, "bi");
              function Qn(d) {
                return En(32768, d);
              }
              __name(Qn, "Qn");
              function Yn(d) {
                return ln(32768, d);
              }
              __name(Yn, "Yn");
              function oi(d) {
                return En(40960, d);
              }
              __name(oi, "oi");
              function Ei(d) {
                return ln(40960, d);
              }
              __name(Ei, "Ei");
              function Dn(d) {
                return (Yr & d) !== 0;
              }
              __name(Dn, "Dn");
              function Kn() {
                return Dn(8192);
              }
              __name(Kn, "Kn");
              function si() {
                return Dn(4096);
              }
              __name(si, "si");
              function mi() {
                return Dn(65536);
              }
              __name(mi, "mi");
              function Zn() {
                return Dn(16384);
              }
              __name(Zn, "Zn");
              function Fn() {
                return Dn(32768);
              }
              __name(Fn, "Fn");
              function gt(d, P) {
                return dn(f.getTokenPos(), f.getTextPos(), d, P);
              }
              __name(gt, "gt");
              function gi(d, P, $, ce) {
                var Pe = e.lastOrUndefined(vr), We;
                return (!Pe || d !== Pe.start) && (We = e.createDetachedDiagnostic(ct, d, P, $, ce), vr.push(We)), Dt = true, We;
              }
              __name(gi, "gi");
              function dn(d, P, $, ce) {
                return gi(d, P - d, $, ce);
              }
              __name(dn, "dn");
              function On(d, P, $) {
                dn(d.pos, d.end, P, $);
              }
              __name(On, "On");
              function br(d, P) {
                gi(f.getTextPos(), P, d);
              }
              __name(br, "br");
              function Ae() {
                return f.getStartPos();
              }
              __name(Ae, "Ae");
              function ur() {
                return f.hasPrecedingJSDocComment();
              }
              __name(ur, "ur");
              function L() {
                return Mr;
              }
              __name(L, "L");
              function qt() {
                return Mr = f.scan();
              }
              __name(qt, "qt");
              function nn(d) {
                return fr(), d();
              }
              __name(nn, "nn");
              function fr() {
                return e.isKeyword(Mr) && (f.hasUnicodeEscape() || f.hasExtendedUnicodeEscape()) && dn(f.getTokenPos(), f.getTextPos(), e.Diagnostics.Keywords_cannot_contain_escape_characters), qt();
              }
              __name(fr, "fr");
              function Me() {
                return Mr = f.scanJsDocToken();
              }
              __name(Me, "Me");
              function Ve() {
                return Mr = f.reScanGreaterToken();
              }
              __name(Ve, "Ve");
              function _r() {
                return Mr = f.reScanSlashToken();
              }
              __name(_r, "_r");
              function lr(d) {
                return Mr = f.reScanTemplateToken(d);
              }
              __name(lr, "lr");
              function Vr() {
                return Mr = f.reScanTemplateHeadOrNoSubstitutionTemplate();
              }
              __name(Vr, "Vr");
              function tt() {
                return Mr = f.reScanLessThanToken();
              }
              __name(tt, "tt");
              function dt() {
                return Mr = f.reScanHashToken();
              }
              __name(dt, "dt");
              function It() {
                return Mr = f.scanJsxIdentifier();
              }
              __name(It, "It");
              function an() {
                return Mr = f.scanJsxToken();
              }
              __name(an, "an");
              function sn() {
                return Mr = f.scanJsxAttributeValue();
              }
              __name(sn, "sn");
              function _e(d, P) {
                var $ = Mr, ce = vr.length, Pe = Dt, We = Yr, Er = P !== 0 ? f.lookAhead(d) : f.tryScan(d);
                return e.Debug.assert(We === Yr), (!Er || P !== 0) && (Mr = $, P !== 2 && (vr.length = ce), Dt = Pe), Er;
              }
              __name(_e, "_e");
              function Gr(d) {
                return _e(d, 1);
              }
              __name(Gr, "Gr");
              function Kt(d) {
                return _e(d, 0);
              }
              __name(Kt, "Kt");
              function en() {
                return L() === 79 ? true : L() > 116;
              }
              __name(en, "en");
              function Ot() {
                return L() === 79 ? true : L() === 125 && Kn() || L() === 133 && Fn() ? false : L() > 116;
              }
              __name(Ot, "Ot");
              function rr(d, P, $) {
                return $ === void 0 && ($ = true), L() === d ? ($ && fr(), true) : (P ? gt(P) : gt(e.Diagnostics._0_expected, e.tokenToString(d)), false);
              }
              __name(rr, "rr");
              var Hn = Object.keys(e.textToKeywordObj).filter(function(d) {
                return d.length > 2;
              });
              function rn(d) {
                var P;
                if (e.isTaggedTemplateExpression(d)) {
                  dn(e.skipTrivia(Ie, d.template.pos), d.template.end, e.Diagnostics.Module_declaration_names_may_only_use_or_quoted_strings);
                  return;
                }
                var $ = e.isIdentifier(d) ? e.idText(d) : void 0;
                if (!$ || !e.isIdentifierText($, me)) {
                  gt(e.Diagnostics._0_expected, e.tokenToString(26));
                  return;
                }
                var ce = e.skipTrivia(Ie, d.pos);
                switch ($) {
                  case "const":
                  case "let":
                  case "var":
                    dn(ce, d.end, e.Diagnostics.Variable_declaration_not_allowed_at_this_location);
                    return;
                  case "declare":
                    return;
                  case "interface":
                    xn(e.Diagnostics.Interface_name_cannot_be_0, e.Diagnostics.Interface_must_be_given_a_name, 18);
                    return;
                  case "is":
                    dn(ce, f.getTextPos(), e.Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
                    return;
                  case "module":
                  case "namespace":
                    xn(e.Diagnostics.Namespace_name_cannot_be_0, e.Diagnostics.Namespace_must_be_given_a_name, 18);
                    return;
                  case "type":
                    xn(e.Diagnostics.Type_alias_name_cannot_be_0, e.Diagnostics.Type_alias_must_be_given_a_name, 63);
                    return;
                }
                var Pe = (P = e.getSpellingSuggestion($, Hn, function(We) {
                  return We;
                })) !== null && P !== void 0 ? P : Mn($);
                if (Pe) {
                  dn(ce, d.end, e.Diagnostics.Unknown_keyword_or_identifier_Did_you_mean_0, Pe);
                  return;
                }
                L() !== 0 && dn(ce, d.end, e.Diagnostics.Unexpected_keyword_or_identifier);
              }
              __name(rn, "rn");
              function xn(d, P, $) {
                L() === $ ? gt(P) : gt(d, f.getTokenValue());
              }
              __name(xn, "xn");
              function Mn(d) {
                for (var P = 0, $ = Hn; P < $.length; P++) {
                  var ce = $[P];
                  if (d.length > ce.length + 2 && e.startsWith(d, ce))
                    return "".concat(ce, " ").concat(d.slice(ce.length));
                }
              }
              __name(Mn, "Mn");
              function Rn(d, P, $) {
                if (L() === 59 && !f.hasPrecedingLineBreak()) {
                  gt(e.Diagnostics.Decorators_must_precede_the_name_and_all_keywords_of_property_declarations);
                  return;
                }
                if (L() === 20) {
                  gt(e.Diagnostics.Cannot_start_a_function_call_in_a_type_annotation), fr();
                  return;
                }
                if (P && !ti()) {
                  $ ? gt(e.Diagnostics._0_expected, e.tokenToString(26)) : gt(e.Diagnostics.Expected_for_property_initializer);
                  return;
                }
                if (!li()) {
                  if ($) {
                    gt(e.Diagnostics._0_expected, e.tokenToString(26));
                    return;
                  }
                  rn(d);
                }
              }
              __name(Rn, "Rn");
              function kn(d) {
                return L() === d ? (Me(), true) : (gt(e.Diagnostics._0_expected, e.tokenToString(d)), false);
              }
              __name(kn, "kn");
              function on(d, P, $, ce) {
                if (L() === P) {
                  fr();
                  return;
                }
                var Pe = gt(e.Diagnostics._0_expected, e.tokenToString(P));
                !$ || Pe && e.addRelatedInfo(Pe, e.createDetachedDiagnostic(ct, ce, 1, e.Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, e.tokenToString(d), e.tokenToString(P)));
              }
              __name(on, "on");
              function Xr(d) {
                return L() === d ? (fr(), true) : false;
              }
              __name(Xr, "Xr");
              function wr(d) {
                if (L() === d)
                  return An();
              }
              __name(wr, "wr");
              function fn(d) {
                if (L() === d)
                  return wi();
              }
              __name(fn, "fn");
              function mn(d, P, $) {
                return wr(d) || Vn(d, false, P || e.Diagnostics._0_expected, $ || e.tokenToString(d));
              }
              __name(mn, "mn");
              function Li(d) {
                return fn(d) || Vn(d, false, e.Diagnostics._0_expected, e.tokenToString(d));
              }
              __name(Li, "Li");
              function An() {
                var d = Ae(), P = L();
                return fr(), Ue(r.createToken(P), d);
              }
              __name(An, "An");
              function wi() {
                var d = Ae(), P = L();
                return Me(), Ue(r.createToken(P), d);
              }
              __name(wi, "wi");
              function ti() {
                return L() === 26 ? true : L() === 19 || L() === 1 || f.hasPrecedingLineBreak();
              }
              __name(ti, "ti");
              function li() {
                return ti() ? (L() === 26 && fr(), true) : false;
              }
              __name(li, "li");
              function Bn() {
                return li() || rr(26);
              }
              __name(Bn, "Bn");
              function vn(d, P, $, ce) {
                var Pe = r.createNodeArray(d, ce);
                return e.setTextRangePosEnd(Pe, P, $ != null ? $ : f.getStartPos()), Pe;
              }
              __name(vn, "vn");
              function Ue(d, P, $) {
                return e.setTextRangePosEnd(d, P, $ != null ? $ : f.getStartPos()), Yr && (d.flags |= Yr), Dt && (Dt = false, d.flags |= 131072), d;
              }
              __name(Ue, "Ue");
              function Vn(d, P, $, ce) {
                P ? gi(f.getStartPos(), 0, $, ce) : $ && gt($, ce);
                var Pe = Ae(), We = d === 79 ? r.createIdentifier("", void 0, void 0) : e.isTemplateLiteralKind(d) ? r.createTemplateLiteralLikeNode(d, "", "", void 0) : d === 8 ? r.createNumericLiteral("", void 0) : d === 10 ? r.createStringLiteral("", void 0) : d === 279 ? r.createMissingDeclaration() : r.createToken(d);
                return Ue(We, Pe);
              }
              __name(Vn, "Vn");
              function Ti(d) {
                var P = At.get(d);
                return P === void 0 && At.set(d, P = d), P;
              }
              __name(Ti, "Ti");
              function ni(d, P, $) {
                if (d) {
                  de++;
                  var ce = Ae(), Pe = L(), We = Ti(f.getTokenValue()), Er = f.hasExtendedUnicodeEscape();
                  return qt(), Ue(r.createIdentifier(We, void 0, Pe, Er), ce);
                }
                if (L() === 80)
                  return gt($ || e.Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies), ni(true);
                if (L() === 0 && f.tryScan(function() {
                  return f.reScanInvalidIdentifier() === 79;
                }))
                  return ni(true);
                de++;
                var Rr = L() === 1, Fr = f.isReservedWord(), et = f.getTokenText(), xt = Fr ? e.Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here : e.Diagnostics.Identifier_expected;
                return Vn(79, Rr, P || xt, et);
              }
              __name(ni, "ni");
              function Bi(d) {
                return ni(en(), void 0, d);
              }
              __name(Bi, "Bi");
              function Tn(d, P) {
                return ni(Ot(), d, P);
              }
              __name(Tn, "Tn");
              function jn(d) {
                return ni(e.tokenIsIdentifierOrKeyword(L()), d);
              }
              __name(jn, "jn");
              function Si() {
                return e.tokenIsIdentifierOrKeyword(L()) || L() === 10 || L() === 8;
              }
              __name(Si, "Si");
              function Ci() {
                return e.tokenIsIdentifierOrKeyword(L()) || L() === 10;
              }
              __name(Ci, "Ci");
              function C(d) {
                if (L() === 10 || L() === 8) {
                  var P = Ji();
                  return P.text = Ti(P.text), P;
                }
                return d && L() === 22 ? ee() : L() === 80 ? Ze() : jn();
              }
              __name(C, "C");
              function V() {
                return C(true);
              }
              __name(V, "V");
              function ee() {
                var d = Ae();
                rr(22);
                var P = Vt(pi);
                return rr(23), Ue(r.createComputedPropertyName(P), d);
              }
              __name(ee, "ee");
              function le(d) {
                var P = re.get(d);
                return P === void 0 && re.set(d, P = d), P;
              }
              __name(le, "le");
              function Ze() {
                var d = Ae(), P = r.createPrivateIdentifier(le(f.getTokenValue()));
                return fr(), Ue(P, d);
              }
              __name(Ze, "Ze");
              function Ir(d) {
                return L() === d && Kt(hr);
              }
              __name(Ir, "Ir");
              function Ar() {
                return fr(), f.hasPrecedingLineBreak() ? false : jt();
              }
              __name(Ar, "Ar");
              function hr() {
                switch (L()) {
                  case 85:
                    return fr() === 92;
                  case 93:
                    return fr(), L() === 88 ? Gr(Ht) : L() === 154 ? Gr(Pt) : yt();
                  case 88:
                    return Ht();
                  case 127:
                  case 124:
                  case 137:
                  case 151:
                    return fr(), jt();
                  default:
                    return Ar();
                }
              }
              __name(hr, "hr");
              function yt() {
                return L() !== 41 && L() !== 128 && L() !== 18 && jt();
              }
              __name(yt, "yt");
              function Pt() {
                return fr(), yt();
              }
              __name(Pt, "Pt");
              function Ut() {
                return e.isModifierKind(L()) && Kt(hr);
              }
              __name(Ut, "Ut");
              function jt() {
                return L() === 22 || L() === 18 || L() === 41 || L() === 25 || Si();
              }
              __name(jt, "jt");
              function Ht() {
                return fr(), L() === 84 || L() === 98 || L() === 118 || L() === 126 && Gr(l_) || L() === 132 && Gr(p_);
              }
              __name(Ht, "Ht");
              function yi(d, P) {
                var $ = $i(d);
                if ($)
                  return true;
                switch (d) {
                  case 0:
                  case 1:
                  case 3:
                    return !(L() === 26 && P) && _s();
                  case 2:
                    return L() === 82 || L() === 88;
                  case 4:
                    return Gr(Rt);
                  case 5:
                    return Gr(fc) || L() === 26 && !P;
                  case 6:
                    return L() === 22 || Si();
                  case 12:
                    switch (L()) {
                      case 22:
                      case 41:
                      case 25:
                      case 24:
                        return true;
                      default:
                        return Si();
                    }
                  case 18:
                    return Si();
                  case 9:
                    return L() === 22 || L() === 25 || Si();
                  case 24:
                    return Ci();
                  case 7:
                    return L() === 18 ? Gr(Ni) : P ? Ot() && !ea() : I_() && !ea();
                  case 8:
                    return y_();
                  case 10:
                    return L() === 27 || L() === 25 || y_();
                  case 19:
                    return L() === 101 || Ot();
                  case 15:
                    switch (L()) {
                      case 27:
                      case 24:
                        return true;
                    }
                  case 11:
                    return L() === 25 || Ca();
                  case 16:
                    return Ba(false);
                  case 17:
                    return Ba(true);
                  case 20:
                  case 21:
                    return L() === 27 || io();
                  case 22:
                    return bc();
                  case 23:
                    return e.tokenIsIdentifierOrKeyword(L());
                  case 13:
                    return e.tokenIsIdentifierOrKeyword(L()) || L() === 18;
                  case 14:
                    return true;
                }
                return e.Debug.fail("Non-exhaustive case in 'isListElement'.");
              }
              __name(yi, "yi");
              function Ni() {
                if (e.Debug.assert(L() === 18), fr() === 19) {
                  var d = fr();
                  return d === 27 || d === 18 || d === 94 || d === 117;
                }
                return true;
              }
              __name(Ni, "Ni");
              function Gn() {
                return fr(), Ot();
              }
              __name(Gn, "Gn");
              function qi() {
                return fr(), e.tokenIsIdentifierOrKeyword(L());
              }
              __name(qi, "qi");
              function sa() {
                return fr(), e.tokenIsIdentifierOrKeywordOrGreaterThan(L());
              }
              __name(sa, "sa");
              function ea() {
                return L() === 117 || L() === 94 ? Gr(Hi) : false;
              }
              __name(ea, "ea");
              function Hi() {
                return fr(), Ca();
              }
              __name(Hi, "Hi");
              function Ui() {
                return fr(), io();
              }
              __name(Ui, "Ui");
              function Gi(d) {
                if (L() === 1)
                  return true;
                switch (d) {
                  case 1:
                  case 2:
                  case 4:
                  case 5:
                  case 6:
                  case 12:
                  case 9:
                  case 23:
                  case 24:
                    return L() === 19;
                  case 3:
                    return L() === 19 || L() === 82 || L() === 88;
                  case 7:
                    return L() === 18 || L() === 94 || L() === 117;
                  case 8:
                    return Xi();
                  case 19:
                    return L() === 31 || L() === 20 || L() === 18 || L() === 94 || L() === 117;
                  case 11:
                    return L() === 21 || L() === 26;
                  case 15:
                  case 21:
                  case 10:
                    return L() === 23;
                  case 17:
                  case 16:
                  case 18:
                    return L() === 21 || L() === 23;
                  case 20:
                    return L() !== 27;
                  case 22:
                    return L() === 18 || L() === 19;
                  case 13:
                    return L() === 31 || L() === 43;
                  case 14:
                    return L() === 29 && Gr(vu);
                  default:
                    return false;
                }
              }
              __name(Gi, "Gi");
              function Xi() {
                return !!(ti() || Hs(L()) || L() === 38);
              }
              __name(Xi, "Xi");
              function ma() {
                for (var d = 0; d < 25; d++)
                  if (He & 1 << d && (yi(d, true) || Gi(d)))
                    return true;
                return false;
              }
              __name(ma, "ma");
              function Jn(d, P) {
                var $ = He;
                He |= 1 << d;
                for (var ce = [], Pe = Ae(); !Gi(d); ) {
                  if (yi(d, false)) {
                    ce.push(ra(d, P));
                    continue;
                  }
                  if (tn(d))
                    break;
                }
                return He = $, vn(ce, Pe);
              }
              __name(Jn, "Jn");
              function ra(d, P) {
                var $ = $i(d);
                return $ ? _a($) : P();
              }
              __name(ra, "ra");
              function $i(d, P) {
                if (!(!pr || !Ri(d) || Dt)) {
                  var $ = pr.currentNode(P != null ? P : f.getStartPos());
                  if (!(e.nodeIsMissing($) || $.intersectsChange || e.containsParseError($))) {
                    var ce = $.flags & 50720768;
                    if (ce === Yr && !!p($, d))
                      return $.jsDocCache && ($.jsDocCache = void 0), $;
                  }
                }
              }
              __name($i, "$i");
              function _a(d) {
                return f.setTextPos(d.end), fr(), d;
              }
              __name(_a, "_a");
              function Ri(d) {
                switch (d) {
                  case 5:
                  case 2:
                  case 0:
                  case 1:
                  case 3:
                  case 6:
                  case 4:
                  case 8:
                  case 17:
                  case 16:
                    return true;
                }
                return false;
              }
              __name(Ri, "Ri");
              function p(d, P) {
                switch (P) {
                  case 5:
                    return ne(d);
                  case 2:
                    return Ne(d);
                  case 0:
                  case 1:
                  case 3:
                    return or(d);
                  case 6:
                    return it(d);
                  case 4:
                    return vt(d);
                  case 8:
                    return Et(d);
                  case 17:
                  case 16:
                    return Tt(d);
                }
                return false;
              }
              __name(p, "p");
              function ne(d) {
                if (d)
                  switch (d.kind) {
                    case 173:
                    case 178:
                    case 174:
                    case 175:
                    case 169:
                    case 237:
                      return true;
                    case 171:
                      var P = d, $ = P.name.kind === 79 && P.name.originalKeywordKind === 135;
                      return !$;
                  }
                return false;
              }
              __name(ne, "ne");
              function Ne(d) {
                if (d)
                  switch (d.kind) {
                    case 292:
                    case 293:
                      return true;
                  }
                return false;
              }
              __name(Ne, "Ne");
              function or(d) {
                if (d)
                  switch (d.kind) {
                    case 259:
                    case 240:
                    case 238:
                    case 242:
                    case 241:
                    case 254:
                    case 250:
                    case 252:
                    case 249:
                    case 248:
                    case 246:
                    case 247:
                    case 245:
                    case 244:
                    case 251:
                    case 239:
                    case 255:
                    case 253:
                    case 243:
                    case 256:
                    case 269:
                    case 268:
                    case 275:
                    case 274:
                    case 264:
                    case 260:
                    case 261:
                    case 263:
                    case 262:
                      return true;
                  }
                return false;
              }
              __name(or, "or");
              function it(d) {
                return d.kind === 302;
              }
              __name(it, "it");
              function vt(d) {
                if (d)
                  switch (d.kind) {
                    case 177:
                    case 170:
                    case 178:
                    case 168:
                    case 176:
                      return true;
                  }
                return false;
              }
              __name(vt, "vt");
              function Et(d) {
                if (d.kind !== 257)
                  return false;
                var P = d;
                return P.initializer === void 0;
              }
              __name(Et, "Et");
              function Tt(d) {
                if (d.kind !== 166)
                  return false;
                var P = d;
                return P.initializer === void 0;
              }
              __name(Tt, "Tt");
              function tn(d) {
                return Mt(d), ma() ? true : (fr(), false);
              }
              __name(tn, "tn");
              function Mt(d) {
                switch (d) {
                  case 0:
                    return L() === 88 ? gt(e.Diagnostics._0_expected, e.tokenToString(93)) : gt(e.Diagnostics.Declaration_or_statement_expected);
                  case 1:
                    return gt(e.Diagnostics.Declaration_or_statement_expected);
                  case 2:
                    return gt(e.Diagnostics.case_or_default_expected);
                  case 3:
                    return gt(e.Diagnostics.Statement_expected);
                  case 18:
                  case 4:
                    return gt(e.Diagnostics.Property_or_signature_expected);
                  case 5:
                    return gt(e.Diagnostics.Unexpected_token_A_constructor_method_accessor_or_property_was_expected);
                  case 6:
                    return gt(e.Diagnostics.Enum_member_expected);
                  case 7:
                    return gt(e.Diagnostics.Expression_expected);
                  case 8:
                    return e.isKeyword(L()) ? gt(e.Diagnostics._0_is_not_allowed_as_a_variable_declaration_name, e.tokenToString(L())) : gt(e.Diagnostics.Variable_declaration_expected);
                  case 9:
                    return gt(e.Diagnostics.Property_destructuring_pattern_expected);
                  case 10:
                    return gt(e.Diagnostics.Array_element_destructuring_pattern_expected);
                  case 11:
                    return gt(e.Diagnostics.Argument_expression_expected);
                  case 12:
                    return gt(e.Diagnostics.Property_assignment_expected);
                  case 15:
                    return gt(e.Diagnostics.Expression_or_comma_expected);
                  case 17:
                    return gt(e.Diagnostics.Parameter_declaration_expected);
                  case 16:
                    return e.isKeyword(L()) ? gt(e.Diagnostics._0_is_not_allowed_as_a_parameter_name, e.tokenToString(L())) : gt(e.Diagnostics.Parameter_declaration_expected);
                  case 19:
                    return gt(e.Diagnostics.Type_parameter_declaration_expected);
                  case 20:
                    return gt(e.Diagnostics.Type_argument_expected);
                  case 21:
                    return gt(e.Diagnostics.Type_expected);
                  case 22:
                    return gt(e.Diagnostics.Unexpected_token_expected);
                  case 23:
                    return gt(e.Diagnostics.Identifier_expected);
                  case 13:
                    return gt(e.Diagnostics.Identifier_expected);
                  case 14:
                    return gt(e.Diagnostics.Identifier_expected);
                  case 24:
                    return gt(e.Diagnostics.Identifier_or_string_literal_expected);
                  case 25:
                    return e.Debug.fail("ParsingContext.Count used as a context");
                  default:
                    e.Debug.assertNever(d);
                }
              }
              __name(Mt, "Mt");
              function $t(d, P, $) {
                var ce = He;
                He |= 1 << d;
                for (var Pe = [], We = Ae(), Er = -1; ; ) {
                  if (yi(d, false)) {
                    var Rr = f.getStartPos(), Fr = ra(d, P);
                    if (!Fr) {
                      He = ce;
                      return;
                    }
                    if (Pe.push(Fr), Er = f.getTokenPos(), Xr(27))
                      continue;
                    if (Er = -1, Gi(d))
                      break;
                    rr(27, y(d)), $ && L() === 26 && !f.hasPrecedingLineBreak() && fr(), Rr === f.getStartPos() && fr();
                    continue;
                  }
                  if (Gi(d) || tn(d))
                    break;
                }
                return He = ce, vn(Pe, We, void 0, Er >= 0);
              }
              __name($t, "$t");
              function y(d) {
                return d === 6 ? e.Diagnostics.An_enum_member_name_must_be_followed_by_a_or : void 0;
              }
              __name(y, "y");
              function De() {
                var d = vn([], Ae());
                return d.isMissingList = true, d;
              }
              __name(De, "De");
              function R(d) {
                return !!d.isMissingList;
              }
              __name(R, "R");
              function Jt(d, P, $, ce) {
                if (rr($)) {
                  var Pe = $t(d, P);
                  return rr(ce), Pe;
                }
                return De();
              }
              __name(Jt, "Jt");
              function Qt(d, P) {
                for (var $ = Ae(), ce = d ? jn(P) : Tn(P), Pe = Ae(); Xr(24); ) {
                  if (L() === 29) {
                    ce.jsdocDotPos = Pe;
                    break;
                  }
                  Pe = Ae(), ce = Ue(r.createQualifiedName(ce, Ii(d, false)), $);
                }
                return ce;
              }
              __name(Qt, "Qt");
              function qn(d, P) {
                return Ue(r.createQualifiedName(d, P), d.pos);
              }
              __name(qn, "qn");
              function Ii(d, P) {
                if (f.hasPrecedingLineBreak() && e.tokenIsIdentifierOrKeyword(L())) {
                  var $ = Gr(ss);
                  if ($)
                    return Vn(79, true, e.Diagnostics.Identifier_expected);
                }
                if (L() === 80) {
                  var ce = Ze();
                  return P ? ce : Vn(79, true, e.Diagnostics.Identifier_expected);
                }
                return d ? jn() : Tn();
              }
              __name(Ii, "Ii");
              function ca(d) {
                var P = Ae(), $ = [], ce;
                do
                  ce = zi(d), $.push(ce);
                while (ce.literal.kind === 16);
                return vn($, P);
              }
              __name(ca, "ca");
              function ji(d) {
                var P = Ae();
                return Ue(r.createTemplateExpression(ga(d), ca(d)), P);
              }
              __name(ji, "ji");
              function ua() {
                var d = Ae();
                return Ue(r.createTemplateLiteralType(ga(false), Qi()), d);
              }
              __name(ua, "ua");
              function Qi() {
                var d = Ae(), P = [], $;
                do
                  $ = ta(), P.push($);
                while ($.literal.kind === 16);
                return vn(P, d);
              }
              __name(Qi, "Qi");
              function ta() {
                var d = Ae();
                return Ue(r.createTemplateLiteralTypeSpan(Un(), Ta(false)), d);
              }
              __name(ta, "ta");
              function Ta(d) {
                return L() === 19 ? (lr(d), yo()) : mn(17, e.Diagnostics._0_expected, e.tokenToString(19));
              }
              __name(Ta, "Ta");
              function zi(d) {
                var P = Ae();
                return Ue(r.createTemplateSpan(Vt(pi), Ta(d)), P);
              }
              __name(zi, "zi");
              function Ji() {
                return wa(L());
              }
              __name(Ji, "Ji");
              function ga(d) {
                d && Vr();
                var P = wa(L());
                return e.Debug.assert(P.kind === 15, "Template head has wrong token kind"), P;
              }
              __name(ga, "ga");
              function yo() {
                var d = wa(L());
                return e.Debug.assert(d.kind === 16 || d.kind === 17, "Template fragment has wrong token kind"), d;
              }
              __name(yo, "yo");
              function Ns(d) {
                var P = d === 14 || d === 17, $ = f.getTokenText();
                return $.substring(1, $.length - (f.isUnterminated() ? 0 : P ? 1 : 2));
              }
              __name(Ns, "Ns");
              function wa(d) {
                var P = Ae(), $ = e.isTemplateLiteralKind(d) ? r.createTemplateLiteralLikeNode(d, f.getTokenValue(), Ns(d), f.getTokenFlags() & 2048) : d === 8 ? r.createNumericLiteral(f.getTokenValue(), f.getNumericLiteralFlags()) : d === 10 ? r.createStringLiteral(f.getTokenValue(), void 0, f.hasExtendedUnicodeEscape()) : e.isLiteralKind(d) ? r.createLiteralLikeNode(d, f.getTokenValue()) : e.Debug.fail();
                return f.hasExtendedUnicodeEscape() && ($.hasExtendedUnicodeEscape = true), f.isUnterminated() && ($.isUnterminated = true), fr(), Ue($, P);
              }
              __name(wa, "wa");
              function Wo() {
                return Qt(true, e.Diagnostics.Type_expected);
              }
              __name(Wo, "Wo");
              function Sa() {
                if (!f.hasPrecedingLineBreak() && tt() === 29)
                  return Jt(20, Un, 29, 31);
              }
              __name(Sa, "Sa");
              function Fa() {
                var d = Ae();
                return Ue(r.createTypeReferenceNode(Wo(), Sa()), d);
              }
              __name(Fa, "Fa");
              function ho(d) {
                switch (d.kind) {
                  case 180:
                    return e.nodeIsMissing(d.typeName);
                  case 181:
                  case 182: {
                    var P = d, $ = P.parameters, ce = P.type;
                    return R($) || ho(ce);
                  }
                  case 193:
                    return ho(d.type);
                  default:
                    return false;
                }
              }
              __name(ho, "ho");
              function vo(d) {
                return fr(), Ue(r.createTypePredicateNode(void 0, d, Un()), d.pos);
              }
              __name(vo, "vo");
              function eo() {
                var d = Ae();
                return fr(), Ue(r.createThisTypeNode(), d);
              }
              __name(eo, "eo");
              function Aa() {
                var d = Ae();
                return fr(), Ue(r.createJSDocAllType(), d);
              }
              __name(Aa, "Aa");
              function bo() {
                var d = Ae();
                return fr(), Ue(r.createJSDocNonNullableType(Js(), false), d);
              }
              __name(bo, "bo");
              function Is() {
                var d = Ae();
                return fr(), L() === 27 || L() === 19 || L() === 21 || L() === 31 || L() === 63 || L() === 51 ? Ue(r.createJSDocUnknownType(), d) : Ue(r.createJSDocNullableType(Un(), false), d);
              }
              __name(Is, "Is");
              function Eo() {
                var d = Ae(), P = ur();
                if (Gr(hs)) {
                  fr();
                  var $ = l(36), ce = Vi(58, false);
                  return ue(Ue(r.createJSDocFunctionType($, ce), d), P);
                }
                return Ue(r.createTypeReferenceNode(jn(), void 0), d);
              }
              __name(Eo, "Eo");
              function To() {
                var d = Ae(), P;
                return (L() === 108 || L() === 103) && (P = jn(), rr(58)), Ue(r.createParameterDeclaration(void 0, void 0, P, void 0, ka(), void 0), d);
              }
              __name(To, "To");
              function ka() {
                f.setInJSDocType(true);
                var d = Ae();
                if (Xr(142)) {
                  var P = r.createJSDocNamepathType(void 0);
                  e:
                    for (; ; )
                      switch (L()) {
                        case 19:
                        case 1:
                        case 27:
                        case 5:
                          break e;
                        default:
                          Me();
                      }
                  return f.setInJSDocType(false), Ue(P, d);
                }
                var $ = Xr(25), ce = zs();
                return f.setInJSDocType(false), $ && (ce = Ue(r.createJSDocVariadicType(ce), d)), L() === 63 ? (fr(), Ue(r.createJSDocOptionalType(ce), d)) : ce;
              }
              __name(ka, "ka");
              function ro() {
                var d = Ae();
                rr(112);
                var P = Qt(true), $ = f.hasPrecedingLineBreak() ? void 0 : ys();
                return Ue(r.createTypeQueryNode(P, $), d);
              }
              __name(ro, "ro");
              function Ko() {
                var d = Ae(), P = xa(), $ = Tn(), ce, Pe;
                Xr(94) && (io() || !Ca() ? ce = Un() : Pe = G_());
                var We = Xr(63) ? Un() : void 0, Er = r.createTypeParameterDeclaration(P, $, ce, We);
                return Er.expression = Pe, Ue(Er, d);
              }
              __name(Ko, "Ko");
              function Oi() {
                if (L() === 29)
                  return Jt(19, Ko, 29, 31);
              }
              __name(Oi, "Oi");
              function Ba(d) {
                return L() === 25 || y_() || e.isModifierKind(L()) || L() === 59 || io(!d);
              }
              __name(Ba, "Ba");
              function to(d) {
                var P = Oa(e.Diagnostics.Private_identifiers_cannot_be_used_as_parameters);
                return e.getFullWidth(P) === 0 && !e.some(d) && e.isModifierKind(L()) && fr(), P;
              }
              __name(to, "to");
              function So() {
                return en() || L() === 22 || L() === 18;
              }
              __name(So, "So");
              function Co(d) {
                return Go(d);
              }
              __name(Co, "Co");
              function Ho(d) {
                return Go(d, false);
              }
              __name(Ho, "Ho");
              function Go(d, P) {
                P === void 0 && (P = true);
                var $ = Ae(), ce = ur(), Pe = d ? Qn(po) : Yn(po);
                if (L() === 108) {
                  var We = r.createParameterDeclaration(Pe, void 0, ni(true), void 0, la(), void 0);
                  return Pe && On(Pe[0], e.Diagnostics.Decorators_may_not_be_applied_to_this_parameters), ue(Ue(We, $), ce);
                }
                var Er = St;
                St = false;
                var Rr = Wa(Pe, xa()), Fr = wr(25);
                if (!(!P && !So())) {
                  var et = ue(Ue(r.createParameterDeclaration(Rr, Fr, to(Rr), wr(57), la(), Na()), $), ce);
                  return St = Er, et;
                }
              }
              __name(Go, "Go");
              function Vi(d, P) {
                if (Os(d, P))
                  return ei(zs);
              }
              __name(Vi, "Vi");
              function Os(d, P) {
                return d === 38 ? (rr(d), true) : Xr(58) ? true : P && L() === 38 ? (gt(e.Diagnostics._0_expected, e.tokenToString(58)), fr(), true) : false;
              }
              __name(Os, "Os");
              function Do(d, P) {
                var $ = Kn(), ce = Fn();
                In(!!(d & 1)), hn(!!(d & 2));
                var Pe = d & 32 ? $t(17, To) : $t(16, function() {
                  return P ? Co(ce) : Ho(ce);
                });
                return In($), hn(ce), Pe;
              }
              __name(Do, "Do");
              function l(d) {
                if (!rr(20))
                  return De();
                var P = Do(d, true);
                return rr(21), P;
              }
              __name(l, "l");
              function w() {
                Xr(27) || Bn();
              }
              __name(w, "w");
              function M(d) {
                var P = Ae(), $ = ur();
                d === 177 && rr(103);
                var ce = Oi(), Pe = l(4), We = Vi(58, true);
                w();
                var Er = d === 176 ? r.createCallSignature(ce, Pe, We) : r.createConstructSignature(ce, Pe, We);
                return ue(Ue(Er, P), $);
              }
              __name(M, "M");
              function ke() {
                return L() === 22 && Gr(cr);
              }
              __name(ke, "ke");
              function cr() {
                if (fr(), L() === 25 || L() === 23)
                  return true;
                if (e.isModifierKind(L())) {
                  if (fr(), Ot())
                    return true;
                } else if (Ot())
                  fr();
                else
                  return false;
                return L() === 58 || L() === 27 ? true : L() !== 57 ? false : (fr(), L() === 58 || L() === 27 || L() === 23);
              }
              __name(cr, "cr");
              function Zr(d, P, $, ce) {
                var Pe = Jt(16, function() {
                  return Co(false);
                }, 22, 23), We = la();
                w();
                var Er = r.createIndexSignature(ce, Pe, We);
                return Er.illegalDecorators = $, ue(Ue(Er, d), P);
              }
              __name(Zr, "Zr");
              function _t(d, P, $) {
                var ce = V(), Pe = wr(57), We;
                if (L() === 20 || L() === 29) {
                  var Er = Oi(), Rr = l(4), Fr = Vi(58, true);
                  We = r.createMethodSignature($, ce, Pe, Er, Rr, Fr);
                } else {
                  var Fr = la();
                  We = r.createPropertySignature($, ce, Pe, Fr), L() === 63 && (We.initializer = Na());
                }
                return w(), ue(Ue(We, d), P);
              }
              __name(_t, "_t");
              function Rt() {
                if (L() === 20 || L() === 29 || L() === 137 || L() === 151)
                  return true;
                for (var d = false; e.isModifierKind(L()); )
                  d = true, fr();
                return L() === 22 ? true : (Si() && (d = true, fr()), d ? L() === 20 || L() === 29 || L() === 57 || L() === 58 || L() === 27 || ti() : false);
              }
              __name(Rt, "Rt");
              function un() {
                if (L() === 20 || L() === 29)
                  return M(176);
                if (L() === 103 && Gr(bn))
                  return M(177);
                var d = Ae(), P = ur(), $ = xa();
                return Ir(137) ? lo(d, P, void 0, $, 174, 4) : Ir(151) ? lo(d, P, void 0, $, 175, 4) : ke() ? Zr(d, P, void 0, $) : _t(d, P, $);
              }
              __name(un, "un");
              function bn() {
                return fr(), L() === 20 || L() === 29;
              }
              __name(bn, "bn");
              function _n() {
                return fr() === 24;
              }
              __name(_n, "_n");
              function Nt() {
                switch (fr()) {
                  case 20:
                  case 29:
                  case 24:
                    return true;
                }
                return false;
              }
              __name(Nt, "Nt");
              function Ft() {
                var d = Ae();
                return Ue(r.createTypeLiteralNode(Sn()), d);
              }
              __name(Ft, "Ft");
              function Sn() {
                var d;
                return rr(18) ? (d = Jn(4, un), rr(19)) : d = De(), d;
              }
              __name(Sn, "Sn");
              function wn() {
                return fr(), L() === 39 || L() === 40 ? fr() === 146 : (L() === 146 && fr(), L() === 22 && Gn() && fr() === 101);
              }
              __name(wn, "wn");
              function Wn() {
                var d = Ae(), P = jn();
                rr(101);
                var $ = Un();
                return Ue(r.createTypeParameterDeclaration(void 0, P, $, void 0), d);
              }
              __name(Wn, "Wn");
              function Fi() {
                var d = Ae();
                rr(18);
                var P;
                (L() === 146 || L() === 39 || L() === 40) && (P = An(), P.kind !== 146 && rr(146)), rr(22);
                var $ = Wn(), ce = Xr(128) ? Un() : void 0;
                rr(23);
                var Pe;
                (L() === 57 || L() === 39 || L() === 40) && (Pe = An(), Pe.kind !== 57 && rr(57));
                var We = la();
                Bn();
                var Er = Jn(4, un);
                return rr(19), Ue(r.createMappedTypeNode(P, $, ce, Pe, We, Er), d);
              }
              __name(Fi, "Fi");
              function qa() {
                var d = Ae();
                if (Xr(25))
                  return Ue(r.createRestTypeNode(Un()), d);
                var P = Un();
                if (e.isJSDocNullableType(P) && P.pos === P.type.pos) {
                  var $ = r.createOptionalTypeNode(P.type);
                  return e.setTextRange($, P), $.flags = P.flags, $;
                }
                return P;
              }
              __name(qa, "qa");
              function xo() {
                return fr() === 58 || L() === 57 && fr() === 58;
              }
              __name(xo, "xo");
              function wo() {
                return L() === 25 ? e.tokenIsIdentifierOrKeyword(fr()) && xo() : e.tokenIsIdentifierOrKeyword(L()) && xo();
              }
              __name(wo, "wo");
              function Ao() {
                if (Gr(wo)) {
                  var d = Ae(), P = ur(), $ = wr(25), ce = jn(), Pe = wr(57);
                  rr(58);
                  var We = qa(), Er = r.createNamedTupleMember($, ce, Pe, We);
                  return ue(Ue(Er, d), P);
                }
                return qa();
              }
              __name(Ao, "Ao");
              function no() {
                var d = Ae();
                return Ue(r.createTupleTypeNode(Jt(21, Ao, 22, 23)), d);
              }
              __name(no, "no");
              function Vc() {
                var d = Ae();
                rr(20);
                var P = Un();
                return rr(21), Ue(r.createParenthesizedType(P), d);
              }
              __name(Vc, "Vc");
              function Ms() {
                var d;
                if (L() === 126) {
                  var P = Ae();
                  fr();
                  var $ = Ue(r.createToken(126), P);
                  d = vn([$], P);
                }
                return d;
              }
              __name(Ms, "Ms");
              function ko() {
                var d = Ae(), P = ur(), $ = Ms(), ce = Xr(103), Pe = Oi(), We = l(4), Er = Vi(38, false), Rr = ce ? r.createConstructorTypeNode($, Pe, We, Er) : r.createFunctionTypeNode(Pe, We, Er);
                return ce || (Rr.modifiers = $), ue(Ue(Rr, d), P);
              }
              __name(ko, "ko");
              function Ls() {
                var d = An();
                return L() === 24 ? void 0 : d;
              }
              __name(Ls, "Ls");
              function Xo(d) {
                var P = Ae();
                d && fr();
                var $ = L() === 110 || L() === 95 || L() === 104 ? An() : wa(L());
                return d && ($ = Ue(r.createPrefixUnaryExpression(40, $), P)), Ue(r.createLiteralTypeNode($), P);
              }
              __name(Xo, "Xo");
              function $o() {
                return fr(), L() === 100;
              }
              __name($o, "$o");
              function w_() {
                var d = Ae(), P = f.getTokenPos();
                rr(18);
                var $ = f.hasPrecedingLineBreak();
                rr(130), rr(58);
                var ce = E_(true);
                if (!rr(19)) {
                  var Pe = e.lastOrUndefined(vr);
                  Pe && Pe.code === e.Diagnostics._0_expected.code && e.addRelatedInfo(Pe, e.createDetachedDiagnostic(ct, P, 1, e.Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}"));
                }
                return Ue(r.createImportTypeAssertionContainer(ce, $), d);
              }
              __name(w_, "w_");
              function Rs() {
                ft |= 2097152;
                var d = Ae(), P = Xr(112);
                rr(100), rr(20);
                var $ = Un(), ce;
                Xr(27) && (ce = w_()), rr(21);
                var Pe = Xr(24) ? Wo() : void 0, We = Sa();
                return Ue(r.createImportTypeNode($, ce, Pe, We, P), d);
              }
              __name(Rs, "Rs");
              function js() {
                return fr(), L() === 8 || L() === 9;
              }
              __name(js, "js");
              function Js() {
                switch (L()) {
                  case 131:
                  case 157:
                  case 152:
                  case 148:
                  case 160:
                  case 153:
                  case 134:
                  case 155:
                  case 144:
                  case 149:
                    return Kt(Ls) || Fa();
                  case 66:
                    f.reScanAsteriskEqualsToken();
                  case 41:
                    return Aa();
                  case 60:
                    f.reScanQuestionToken();
                  case 57:
                    return Is();
                  case 98:
                    return Eo();
                  case 53:
                    return bo();
                  case 14:
                  case 10:
                  case 8:
                  case 9:
                  case 110:
                  case 95:
                  case 104:
                    return Xo();
                  case 40:
                    return Gr(js) ? Xo(true) : Fa();
                  case 114:
                    return An();
                  case 108: {
                    var d = eo();
                    return L() === 140 && !f.hasPrecedingLineBreak() ? vo(d) : d;
                  }
                  case 112:
                    return Gr($o) ? Rs() : ro();
                  case 18:
                    return Gr(wn) ? Fi() : Ft();
                  case 22:
                    return no();
                  case 20:
                    return Vc();
                  case 100:
                    return Rs();
                  case 129:
                    return Gr(ss) ? Gc() : Fa();
                  case 15:
                    return ua();
                  default:
                    return Fa();
                }
              }
              __name(Js, "Js");
              function io(d) {
                switch (L()) {
                  case 131:
                  case 157:
                  case 152:
                  case 148:
                  case 160:
                  case 134:
                  case 146:
                  case 153:
                  case 156:
                  case 114:
                  case 155:
                  case 104:
                  case 108:
                  case 112:
                  case 144:
                  case 18:
                  case 22:
                  case 29:
                  case 51:
                  case 50:
                  case 103:
                  case 10:
                  case 8:
                  case 9:
                  case 110:
                  case 95:
                  case 149:
                  case 41:
                  case 57:
                  case 53:
                  case 25:
                  case 138:
                  case 100:
                  case 129:
                  case 14:
                  case 15:
                    return true;
                  case 98:
                    return !d;
                  case 40:
                    return !d && Gr(js);
                  case 20:
                    return !d && Gr(A_);
                  default:
                    return Ot();
                }
              }
              __name(io, "io");
              function A_() {
                return fr(), L() === 21 || Ba(false) || io();
              }
              __name(A_, "A_");
              function Wc() {
                for (var d = Ae(), P = Js(); !f.hasPrecedingLineBreak(); )
                  switch (L()) {
                    case 53:
                      fr(), P = Ue(r.createJSDocNonNullableType(P, true), d);
                      break;
                    case 57:
                      if (Gr(Ui))
                        return P;
                      fr(), P = Ue(r.createJSDocNullableType(P, true), d);
                      break;
                    case 22:
                      if (rr(22), io()) {
                        var $ = Un();
                        rr(23), P = Ue(r.createIndexedAccessTypeNode(P, $), d);
                      } else
                        rr(23), P = Ue(r.createArrayTypeNode(P), d);
                      break;
                    default:
                      return P;
                  }
                return P;
              }
              __name(Wc, "Wc");
              function Kc(d) {
                var P = Ae();
                return rr(d), Ue(r.createTypeOperatorNode(d, Bs()), P);
              }
              __name(Kc, "Kc");
              function Fs() {
                if (Xr(94)) {
                  var d = vi(Un);
                  if (mi() || L() !== 57)
                    return d;
                }
              }
              __name(Fs, "Fs");
              function Pa() {
                var d = Ae(), P = Tn(), $ = Kt(Fs), ce = r.createTypeParameterDeclaration(void 0, P, $);
                return Ue(ce, d);
              }
              __name(Pa, "Pa");
              function Po() {
                var d = Ae();
                return rr(138), Ue(r.createInferTypeNode(Pa()), d);
              }
              __name(Po, "Po");
              function Bs() {
                var d = L();
                switch (d) {
                  case 141:
                  case 156:
                  case 146:
                    return Kc(d);
                  case 138:
                    return Po();
                }
                return ei(Wc);
              }
              __name(Bs, "Bs");
              function No(d) {
                if (Us()) {
                  var P = ko(), $ = void 0;
                  return e.isFunctionTypeNode(P) ? $ = d ? e.Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_a_union_type : e.Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type : $ = d ? e.Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type : e.Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type, On(P, $), P;
                }
              }
              __name(No, "No");
              function ao(d, P, $) {
                var ce = Ae(), Pe = d === 51, We = Xr(d), Er = We && No(Pe) || P();
                if (L() === d || We) {
                  for (var Rr = [Er]; Xr(d); )
                    Rr.push(No(Pe) || P());
                  Er = Ue($(vn(Rr, ce)), ce);
                }
                return Er;
              }
              __name(ao, "ao");
              function qs() {
                return ao(50, Bs, r.createIntersectionTypeNode);
              }
              __name(qs, "qs");
              function Qo() {
                return ao(51, qs, r.createUnionTypeNode);
              }
              __name(Qo, "Qo");
              function k_() {
                return fr(), L() === 103;
              }
              __name(k_, "k_");
              function Us() {
                return L() === 29 || L() === 20 && Gr(Hc) ? true : L() === 103 || L() === 126 && Gr(k_);
              }
              __name(Us, "Us");
              function P_() {
                if (e.isModifierKind(L()) && xa(), Ot() || L() === 108)
                  return fr(), true;
                if (L() === 22 || L() === 18) {
                  var d = vr.length;
                  return Oa(), d === vr.length;
                }
                return false;
              }
              __name(P_, "P_");
              function Hc() {
                return fr(), !!(L() === 21 || L() === 25 || P_() && (L() === 58 || L() === 27 || L() === 57 || L() === 63 || L() === 21 && (fr(), L() === 38)));
              }
              __name(Hc, "Hc");
              function zs() {
                var d = Ae(), P = Ot() && Kt(N_), $ = Un();
                return P ? Ue(r.createTypePredicateNode(void 0, P, $), d) : $;
              }
              __name(zs, "zs");
              function N_() {
                var d = Tn();
                if (L() === 140 && !f.hasPrecedingLineBreak())
                  return fr(), d;
              }
              __name(N_, "N_");
              function Gc() {
                var d = Ae(), P = mn(129), $ = L() === 108 ? eo() : Tn(), ce = Xr(140) ? Un() : void 0;
                return Ue(r.createTypePredicateNode(P, $, ce), d);
              }
              __name(Gc, "Gc");
              function Un() {
                if (Yr & 40960)
                  return ln(40960, Un);
                if (Us())
                  return ko();
                var d = Ae(), P = Qo();
                if (!mi() && !f.hasPrecedingLineBreak() && Xr(94)) {
                  var $ = vi(Un);
                  rr(57);
                  var ce = ei(Un);
                  rr(58);
                  var Pe = ei(Un);
                  return Ue(r.createConditionalTypeNode(P, $, ce, Pe), d);
                }
                return P;
              }
              __name(Un, "Un");
              function la() {
                return Xr(58) ? Un() : void 0;
              }
              __name(la, "la");
              function I_() {
                switch (L()) {
                  case 108:
                  case 106:
                  case 104:
                  case 110:
                  case 95:
                  case 8:
                  case 9:
                  case 10:
                  case 14:
                  case 15:
                  case 20:
                  case 22:
                  case 18:
                  case 98:
                  case 84:
                  case 103:
                  case 43:
                  case 68:
                  case 79:
                    return true;
                  case 100:
                    return Gr(Nt);
                  default:
                    return Ot();
                }
              }
              __name(I_, "I_");
              function Ca() {
                if (I_())
                  return true;
                switch (L()) {
                  case 39:
                  case 40:
                  case 54:
                  case 53:
                  case 89:
                  case 112:
                  case 114:
                  case 45:
                  case 46:
                  case 29:
                  case 133:
                  case 125:
                  case 80:
                    return true;
                  default:
                    return Oo() ? true : Ot();
                }
              }
              __name(Ca, "Ca");
              function O_() {
                return L() !== 18 && L() !== 98 && L() !== 84 && L() !== 59 && Ca();
              }
              __name(O_, "O_");
              function pi() {
                var d = Zn();
                d && yn(false);
                for (var P = Ae(), $ = Ai(true), ce; ce = wr(27); )
                  $ = oo($, ce, Ai(true), P);
                return d && yn(true), $;
              }
              __name(pi, "pi");
              function Na() {
                return Xr(63) ? Ai(true) : void 0;
              }
              __name(Na, "Na");
              function Ai(d) {
                if (M_())
                  return L_();
                var P = R_(d) || F_(d);
                if (P)
                  return P;
                var $ = Ae(), ce = Io(0);
                return ce.kind === 79 && L() === 38 ? Ws($, ce, d, void 0) : e.isLeftHandSideExpression(ce) && e.isAssignmentOperator(Ve()) ? oo(ce, An(), Ai(d), $) : $c(ce, $, d);
              }
              __name(Ai, "Ai");
              function M_() {
                return L() === 125 ? Kn() ? true : Gr(jo) : false;
              }
              __name(M_, "M_");
              function Vs() {
                return fr(), !f.hasPrecedingLineBreak() && Ot();
              }
              __name(Vs, "Vs");
              function L_() {
                var d = Ae();
                return fr(), !f.hasPrecedingLineBreak() && (L() === 41 || Ca()) ? Ue(r.createYieldExpression(wr(41), Ai(true)), d) : Ue(r.createYieldExpression(void 0, void 0), d);
              }
              __name(L_, "L_");
              function Ws(d, P, $, ce) {
                e.Debug.assert(L() === 38, "parseSimpleArrowFunctionExpression should only have been called if we had a =>");
                var Pe = r.createParameterDeclaration(void 0, void 0, P, void 0, void 0, void 0);
                Ue(Pe, P.pos);
                var We = vn([Pe], Pe.pos, Pe.end), Er = mn(38), Rr = Ks(!!ce, $), Fr = r.createArrowFunction(ce, void 0, We, void 0, Er, Rr);
                return Sr(Ue(Fr, d));
              }
              __name(Ws, "Ws");
              function R_(d) {
                var P = j_();
                if (P !== 0)
                  return P === 1 ? q_(true, true) : Kt(function() {
                    return Xc(d);
                  });
              }
              __name(R_, "R_");
              function j_() {
                return L() === 20 || L() === 29 || L() === 132 ? Gr(J_) : L() === 38 ? 1 : 0;
              }
              __name(j_, "j_");
              function J_() {
                if (L() === 132 && (fr(), f.hasPrecedingLineBreak() || L() !== 20 && L() !== 29))
                  return 0;
                var d = L(), P = fr();
                if (d === 20) {
                  if (P === 21) {
                    var $ = fr();
                    switch ($) {
                      case 38:
                      case 58:
                      case 18:
                        return 1;
                      default:
                        return 0;
                    }
                  }
                  if (P === 22 || P === 18)
                    return 2;
                  if (P === 25)
                    return 1;
                  if (e.isModifierKind(P) && P !== 132 && Gr(Gn))
                    return fr() === 128 ? 0 : 1;
                  if (!Ot() && P !== 108)
                    return 0;
                  switch (fr()) {
                    case 58:
                      return 1;
                    case 57:
                      return fr(), L() === 58 || L() === 27 || L() === 63 || L() === 21 ? 1 : 0;
                    case 27:
                    case 63:
                    case 21:
                      return 2;
                  }
                  return 0;
                } else {
                  if (e.Debug.assert(d === 29), !Ot())
                    return 0;
                  if (Ye === 1) {
                    var ce = Gr(function() {
                      var Pe = fr();
                      if (Pe === 94) {
                        var We = fr();
                        switch (We) {
                          case 63:
                          case 31:
                            return false;
                          default:
                            return true;
                        }
                      } else if (Pe === 27 || Pe === 63)
                        return true;
                      return false;
                    });
                    return ce ? 1 : 0;
                  }
                  return 2;
                }
              }
              __name(J_, "J_");
              function Xc(d) {
                var P = f.getTokenPos();
                if (!(Nr != null && Nr.has(P))) {
                  var $ = q_(false, d);
                  return $ || (Nr || (Nr = new e.Set())).add(P), $;
                }
              }
              __name(Xc, "Xc");
              function F_(d) {
                if (L() === 132 && Gr(B_) === 1) {
                  var P = Ae(), $ = mc(), ce = Io(0);
                  return Ws(P, ce, d, $);
                }
              }
              __name(F_, "F_");
              function B_() {
                if (L() === 132) {
                  if (fr(), f.hasPrecedingLineBreak() || L() === 38)
                    return 0;
                  var d = Io(0);
                  if (!f.hasPrecedingLineBreak() && d.kind === 79 && L() === 38)
                    return 1;
                }
                return 0;
              }
              __name(B_, "B_");
              function q_(d, P) {
                var $ = Ae(), ce = ur(), Pe = mc(), We = e.some(Pe, e.isAsyncModifier) ? 2 : 0, Er = Oi(), Rr;
                if (rr(20)) {
                  if (d)
                    Rr = Do(We, d);
                  else {
                    var Fr = Do(We, d);
                    if (!Fr)
                      return;
                    Rr = Fr;
                  }
                  if (!rr(21) && !d)
                    return;
                } else {
                  if (!d)
                    return;
                  Rr = De();
                }
                var et = L() === 58, xt = Vi(58, false);
                if (!(xt && !d && ho(xt))) {
                  for (var Gt = xt; (Gt == null ? void 0 : Gt.kind) === 193; )
                    Gt = Gt.type;
                  var Wt = Gt && e.isJSDocFunctionType(Gt);
                  if (!(!d && L() !== 38 && (Wt || L() !== 18))) {
                    var pn = L(), Pn = mn(38), _i = pn === 38 || pn === 18 ? Ks(e.some(Pe, e.isAsyncModifier), P) : Tn();
                    if (!(!P && et && L() !== 58)) {
                      var Ln = r.createArrowFunction(Pe, Er, Rr, xt, Pn, _i);
                      return ue(Ue(Ln, $), ce);
                    }
                  }
                }
              }
              __name(q_, "q_");
              function Ks(d, P) {
                if (L() === 18)
                  return Ro(d ? 2 : 0);
                if (L() !== 26 && L() !== 98 && L() !== 84 && _s() && !O_())
                  return Ro(16 | (d ? 2 : 0));
                var $ = St;
                St = false;
                var ce = d ? Qn(function() {
                  return Ai(P);
                }) : Yn(function() {
                  return Ai(P);
                });
                return St = $, ce;
              }
              __name(Ks, "Ks");
              function $c(d, P, $) {
                var ce = wr(57);
                if (!ce)
                  return d;
                var Pe;
                return Ue(r.createConditionalExpression(d, ce, ln(h, function() {
                  return Ai(false);
                }), Pe = mn(58), e.nodeIsPresent(Pe) ? Ai($) : Vn(79, false, e.Diagnostics._0_expected, e.tokenToString(58))), P);
              }
              __name($c, "$c");
              function Io(d) {
                var P = Ae(), $ = G_();
                return Gs(d, $, P);
              }
              __name(Io, "Io");
              function Hs(d) {
                return d === 101 || d === 162;
              }
              __name(Hs, "Hs");
              function Gs(d, P, $) {
                for (; ; ) {
                  Ve();
                  var ce = e.getBinaryOperatorPrecedence(L()), Pe = L() === 42 ? ce >= d : ce > d;
                  if (!Pe || L() === 101 && si())
                    break;
                  if (L() === 128 || L() === 150) {
                    if (f.hasPrecedingLineBreak())
                      break;
                    var We = L();
                    fr(), P = We === 150 ? Xs(P, Un()) : U_(P, Un());
                  } else
                    P = oo(P, An(), Io(ce), $);
                }
                return P;
              }
              __name(Gs, "Gs");
              function Oo() {
                return si() && L() === 101 ? false : e.getBinaryOperatorPrecedence(L()) > 0;
              }
              __name(Oo, "Oo");
              function Xs(d, P) {
                return Ue(r.createSatisfiesExpression(d, P), d.pos);
              }
              __name(Xs, "Xs");
              function oo(d, P, $, ce) {
                return Ue(r.createBinaryExpression(d, P, $), ce);
              }
              __name(oo, "oo");
              function U_(d, P) {
                return Ue(r.createAsExpression(d, P), d.pos);
              }
              __name(U_, "U_");
              function z_() {
                var d = Ae();
                return Ue(r.createPrefixUnaryExpression(L(), nn(Da)), d);
              }
              __name(z_, "z_");
              function V_() {
                var d = Ae();
                return Ue(r.createDeleteExpression(nn(Da)), d);
              }
              __name(V_, "V_");
              function Qc() {
                var d = Ae();
                return Ue(r.createTypeOfExpression(nn(Da)), d);
              }
              __name(Qc, "Qc");
              function W_() {
                var d = Ae();
                return Ue(r.createVoidExpression(nn(Da)), d);
              }
              __name(W_, "W_");
              function K_() {
                return L() === 133 ? Fn() ? true : Gr(jo) : false;
              }
              __name(K_, "K_");
              function H_() {
                var d = Ae();
                return Ue(r.createAwaitExpression(nn(Da)), d);
              }
              __name(H_, "H_");
              function G_() {
                if (Ua()) {
                  var d = Ae(), P = Yo();
                  return L() === 42 ? Gs(e.getBinaryOperatorPrecedence(L()), P, d) : P;
                }
                var $ = L(), ce = Da();
                if (L() === 42) {
                  var d = e.skipTrivia(Ie, ce.pos), Pe = ce.end;
                  ce.kind === 213 ? dn(d, Pe, e.Diagnostics.A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses) : dn(d, Pe, e.Diagnostics.An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses, e.tokenToString($));
                }
                return ce;
              }
              __name(G_, "G_");
              function Da() {
                switch (L()) {
                  case 39:
                  case 40:
                  case 54:
                  case 53:
                    return z_();
                  case 89:
                    return V_();
                  case 112:
                    return Qc();
                  case 114:
                    return W_();
                  case 29:
                    return eu();
                  case 133:
                    if (K_())
                      return H_();
                  default:
                    return Yo();
                }
              }
              __name(Da, "Da");
              function Ua() {
                switch (L()) {
                  case 39:
                  case 40:
                  case 54:
                  case 53:
                  case 89:
                  case 112:
                  case 114:
                  case 133:
                    return false;
                  case 29:
                    if (Ye !== 1)
                      return false;
                  default:
                    return true;
                }
              }
              __name(Ua, "Ua");
              function Yo() {
                if (L() === 45 || L() === 46) {
                  var d = Ae();
                  return Ue(r.createPrefixUnaryExpression(L(), nn(na)), d);
                } else if (Ye === 1 && L() === 29 && Gr(sa))
                  return so(true);
                var P = na();
                if (e.Debug.assert(e.isLeftHandSideExpression(P)), (L() === 45 || L() === 46) && !f.hasPrecedingLineBreak()) {
                  var $ = L();
                  return fr(), Ue(r.createPostfixUnaryExpression(P, $), P.pos);
                }
                return P;
              }
              __name(Yo, "Yo");
              function na() {
                var d = Ae(), P;
                return L() === 100 ? Gr(bn) ? (ft |= 2097152, P = An()) : Gr(_n) ? (fr(), fr(), P = Ue(r.createMetaProperty(100, jn()), d), ft |= 4194304) : P = $s() : P = L() === 106 ? Yc() : $s(), pa(d, P);
              }
              __name(na, "na");
              function $s() {
                var d = Ae(), P = n_();
                return Lo(d, P, true);
              }
              __name($s, "$s");
              function Yc() {
                var d = Ae(), P = An();
                if (L() === 29) {
                  var $ = Ae(), ce = Kt(_o);
                  ce !== void 0 && (dn($, Ae(), e.Diagnostics.super_may_not_use_type_arguments), ia() || (P = r.createExpressionWithTypeArguments(P, ce)));
                }
                return L() === 20 || L() === 24 || L() === 22 ? P : (mn(24, e.Diagnostics.super_must_be_followed_by_an_argument_list_or_member_access), Ue(r.createPropertyAccessExpression(P, Ii(true, true)), d));
              }
              __name(Yc, "Yc");
              function so(d, P, $) {
                var ce = Ae(), Pe = Q_(d), We;
                if (Pe.kind === 283) {
                  var Er = Ys(Pe), Rr = void 0, Fr = Er[Er.length - 1];
                  if ((Fr == null ? void 0 : Fr.kind) === 281 && !rt(Fr.openingElement.tagName, Fr.closingElement.tagName) && rt(Pe.tagName, Fr.closingElement.tagName)) {
                    var et = Fr.children.end, xt = Ue(r.createJsxElement(Fr.openingElement, Fr.children, Ue(r.createJsxClosingElement(Ue(r.createIdentifier(""), et, et)), et, et)), Fr.openingElement.pos, et);
                    Er = vn(A(A([], Er.slice(0, Er.length - 1), true), [xt], false), Er.pos, et), Rr = Fr.closingElement;
                  } else
                    Rr = Zc(Pe, d), rt(Pe.tagName, Rr.tagName) || ($ && e.isJsxOpeningElement($) && rt(Rr.tagName, $.tagName) ? On(Pe.tagName, e.Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, e.getTextOfNodeFromSourceText(Ie, Pe.tagName)) : On(Rr.tagName, e.Diagnostics.Expected_corresponding_JSX_closing_tag_for_0, e.getTextOfNodeFromSourceText(Ie, Pe.tagName)));
                  We = Ue(r.createJsxElement(Pe, Er, Rr), ce);
                } else
                  Pe.kind === 286 ? We = Ue(r.createJsxFragment(Pe, Ys(Pe), Zs(d)), ce) : (e.Debug.assert(Pe.kind === 282), We = Pe);
                if (d && L() === 29) {
                  var Gt = typeof P > "u" ? We.pos : P, Wt = Kt(function() {
                    return so(true, Gt);
                  });
                  if (Wt) {
                    var pn = Vn(27, false);
                    return e.setTextRangePosWidth(pn, Wt.pos, 0), dn(e.skipTrivia(Ie, Gt), Wt.end, e.Diagnostics.JSX_expressions_must_have_one_parent_element), Ue(r.createBinaryExpression(We, pn, Wt), ce);
                  }
                }
                return We;
              }
              __name(so, "so");
              function X_() {
                var d = Ae(), P = r.createJsxText(f.getTokenValue(), Mr === 12);
                return Mr = f.scanJsxToken(), Ue(P, d);
              }
              __name(X_, "X_");
              function Qs(d, P) {
                switch (P) {
                  case 1:
                    if (e.isJsxOpeningFragment(d))
                      On(d, e.Diagnostics.JSX_fragment_has_no_corresponding_closing_tag);
                    else {
                      var $ = d.tagName, ce = e.skipTrivia(Ie, $.pos);
                      dn(ce, $.end, e.Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, e.getTextOfNodeFromSourceText(Ie, d.tagName));
                    }
                    return;
                  case 30:
                  case 7:
                    return;
                  case 11:
                  case 12:
                    return X_();
                  case 18:
                    return Y_(false);
                  case 29:
                    return so(false, void 0, d);
                  default:
                    return e.Debug.assertNever(P);
                }
              }
              __name(Qs, "Qs");
              function Ys(d) {
                var P = [], $ = Ae(), ce = He;
                for (He |= 1 << 14; ; ) {
                  var Pe = Qs(d, Mr = f.reScanJsxToken());
                  if (!Pe || (P.push(Pe), e.isJsxOpeningElement(d) && (Pe == null ? void 0 : Pe.kind) === 281 && !rt(Pe.openingElement.tagName, Pe.closingElement.tagName) && rt(d.tagName, Pe.closingElement.tagName)))
                    break;
                }
                return He = ce, vn(P, $);
              }
              __name(Ys, "Ys");
              function $_() {
                var d = Ae();
                return Ue(r.createJsxAttributes(Jn(13, Z_)), d);
              }
              __name($_, "$_");
              function Q_(d) {
                var P = Ae();
                if (rr(29), L() === 31)
                  return an(), Ue(r.createJsxOpeningFragment(), P);
                var $ = Zo(), ce = (Yr & 262144) === 0 ? ys() : void 0, Pe = $_(), We;
                return L() === 31 ? (an(), We = r.createJsxOpeningElement($, ce, Pe)) : (rr(43), rr(31, void 0, false) && (d ? fr() : an()), We = r.createJsxSelfClosingElement($, ce, Pe)), Ue(We, P);
              }
              __name(Q_, "Q_");
              function Zo() {
                var d = Ae();
                It();
                for (var P = L() === 108 ? An() : jn(); Xr(24); )
                  P = Ue(r.createPropertyAccessExpression(P, Ii(true, false)), d);
                return P;
              }
              __name(Zo, "Zo");
              function Y_(d) {
                var P = Ae();
                if (!!rr(18)) {
                  var $, ce;
                  return L() !== 19 && ($ = wr(25), ce = pi()), d ? rr(19) : rr(19, void 0, false) && an(), Ue(r.createJsxExpression($, ce), P);
                }
              }
              __name(Y_, "Y_");
              function Z_() {
                if (L() === 18)
                  return ec();
                It();
                var d = Ae();
                return Ue(r.createJsxAttribute(jn(), es()), d);
              }
              __name(Z_, "Z_");
              function es() {
                if (L() === 63) {
                  if (sn() === 10)
                    return Ji();
                  if (L() === 18)
                    return Y_(true);
                  if (L() === 29)
                    return so(true);
                  gt(e.Diagnostics.or_JSX_element_expected);
                }
              }
              __name(es, "es");
              function ec() {
                var d = Ae();
                rr(18), rr(25);
                var P = pi();
                return rr(19), Ue(r.createJsxSpreadAttribute(P), d);
              }
              __name(ec, "ec");
              function Zc(d, P) {
                var $ = Ae();
                rr(30);
                var ce = Zo();
                return rr(31, void 0, false) && (P || !rt(d.tagName, ce) ? fr() : an()), Ue(r.createJsxClosingElement(ce), $);
              }
              __name(Zc, "Zc");
              function Zs(d) {
                var P = Ae();
                return rr(30), e.tokenIsIdentifierOrKeyword(L()) && On(Zo(), e.Diagnostics.Expected_corresponding_closing_tag_for_JSX_fragment), rr(31, void 0, false) && (d ? fr() : an()), Ue(r.createJsxJsxClosingFragment(), P);
              }
              __name(Zs, "Zs");
              function eu() {
                var d = Ae();
                rr(29);
                var P = Un();
                rr(31);
                var $ = Da();
                return Ue(r.createTypeAssertion(P, $), d);
              }
              __name(eu, "eu");
              function rc() {
                return fr(), e.tokenIsIdentifierOrKeyword(L()) || L() === 22 || ia();
              }
              __name(rc, "rc");
              function e_() {
                return L() === 28 && Gr(rc);
              }
              __name(e_, "e_");
              function Mo(d) {
                if (d.flags & 32)
                  return true;
                if (e.isNonNullExpression(d)) {
                  for (var P = d.expression; e.isNonNullExpression(P) && !(P.flags & 32); )
                    P = P.expression;
                  if (P.flags & 32) {
                    for (; e.isNonNullExpression(d); )
                      d.flags |= 32, d = d.expression;
                    return true;
                  }
                }
                return false;
              }
              __name(Mo, "Mo");
              function r_(d, P, $) {
                var ce = Ii(true, true), Pe = $ || Mo(P), We = Pe ? r.createPropertyAccessChain(P, $, ce) : r.createPropertyAccessExpression(P, ce);
                if (Pe && e.isPrivateIdentifier(We.name) && On(We.name, e.Diagnostics.An_optional_chain_cannot_contain_private_identifiers), e.isExpressionWithTypeArguments(P) && P.typeArguments) {
                  var Er = P.typeArguments.pos - 1, Rr = e.skipTrivia(Ie, P.typeArguments.end) + 1;
                  dn(Er, Rr, e.Diagnostics.An_instantiation_expression_cannot_be_followed_by_a_property_access);
                }
                return Ue(We, d);
              }
              __name(r_, "r_");
              function tc(d, P, $) {
                var ce;
                if (L() === 23)
                  ce = Vn(79, true, e.Diagnostics.An_element_access_expression_should_take_an_argument);
                else {
                  var Pe = Vt(pi);
                  e.isStringOrNumericLiteralLike(Pe) && (Pe.text = Ti(Pe.text)), ce = Pe;
                }
                rr(23);
                var We = $ || Mo(P) ? r.createElementAccessChain(P, $, ce) : r.createElementAccessExpression(P, ce);
                return Ue(We, d);
              }
              __name(tc, "tc");
              function Lo(d, P, $) {
                for (; ; ) {
                  var ce = void 0, Pe = false;
                  if ($ && e_() ? (ce = mn(28), Pe = e.tokenIsIdentifierOrKeyword(L())) : Pe = Xr(24), Pe) {
                    P = r_(d, P, ce);
                    continue;
                  }
                  if ((ce || !Zn()) && Xr(22)) {
                    P = tc(d, P, ce);
                    continue;
                  }
                  if (ia()) {
                    P = !ce && P.kind === 230 ? Yi(d, P.expression, ce, P.typeArguments) : Yi(d, P, ce, void 0);
                    continue;
                  }
                  if (!ce) {
                    if (L() === 53 && !f.hasPrecedingLineBreak()) {
                      fr(), P = Ue(r.createNonNullExpression(P), d);
                      continue;
                    }
                    var We = Kt(_o);
                    if (We) {
                      P = Ue(r.createExpressionWithTypeArguments(P, We), d);
                      continue;
                    }
                  }
                  return P;
                }
              }
              __name(Lo, "Lo");
              function ia() {
                return L() === 14 || L() === 15;
              }
              __name(ia, "ia");
              function Yi(d, P, $, ce) {
                var Pe = r.createTaggedTemplateExpression(P, ce, L() === 14 ? (Vr(), Ji()) : ji(true));
                return ($ || P.flags & 32) && (Pe.flags |= 32), Pe.questionDotToken = $, Ue(Pe, d);
              }
              __name(Yi, "Yi");
              function pa(d, P) {
                for (; ; ) {
                  P = Lo(d, P, true);
                  var $ = void 0, ce = wr(28);
                  if (ce && ($ = Kt(_o), ia())) {
                    P = Yi(d, P, ce, $);
                    continue;
                  }
                  if ($ || L() === 20) {
                    !ce && P.kind === 230 && ($ = P.typeArguments, P = P.expression);
                    var Pe = t_(), We = ce || Mo(P) ? r.createCallChain(P, ce, $, Pe) : r.createCallExpression(P, $, Pe);
                    P = Ue(We, d);
                    continue;
                  }
                  if (ce) {
                    var Er = Vn(79, false, e.Diagnostics.Identifier_expected);
                    P = Ue(r.createPropertyAccessChain(P, ce, Er), d);
                  }
                  break;
                }
                return P;
              }
              __name(pa, "pa");
              function t_() {
                rr(20);
                var d = $t(11, i_);
                return rr(21), d;
              }
              __name(t_, "t_");
              function _o() {
                if ((Yr & 262144) === 0 && tt() === 29) {
                  fr();
                  var d = $t(20, Un);
                  if (Ve() === 31)
                    return fr(), d && ru() ? d : void 0;
                }
              }
              __name(_o, "_o");
              function ru() {
                switch (L()) {
                  case 20:
                  case 14:
                  case 15:
                    return true;
                  case 29:
                  case 31:
                  case 39:
                  case 40:
                    return false;
                }
                return f.hasPrecedingLineBreak() || Oo() || !Ca();
              }
              __name(ru, "ru");
              function n_() {
                switch (L()) {
                  case 8:
                  case 9:
                  case 10:
                  case 14:
                    return Ji();
                  case 108:
                  case 106:
                  case 104:
                  case 110:
                  case 95:
                    return An();
                  case 20:
                    return rs();
                  case 22:
                    return ic();
                  case 18:
                    return a_();
                  case 132:
                    if (!Gr(p_))
                      break;
                    return o_();
                  case 84:
                    return yc();
                  case 98:
                    return o_();
                  case 103:
                    return tu();
                  case 43:
                  case 68:
                    if (_r() === 13)
                      return Ji();
                    break;
                  case 15:
                    return ji(false);
                  case 80:
                    return Ze();
                }
                return Tn(e.Diagnostics.Expression_expected);
              }
              __name(n_, "n_");
              function rs() {
                var d = Ae(), P = ur();
                rr(20);
                var $ = Vt(pi);
                return rr(21), ue(Ue(r.createParenthesizedExpression($), d), P);
              }
              __name(rs, "rs");
              function ts() {
                var d = Ae();
                rr(25);
                var P = Ai(true);
                return Ue(r.createSpreadElement(P), d);
              }
              __name(ts, "ts");
              function nc() {
                return L() === 25 ? ts() : L() === 27 ? Ue(r.createOmittedExpression(), Ae()) : Ai(true);
              }
              __name(nc, "nc");
              function i_() {
                return ln(h, nc);
              }
              __name(i_, "i_");
              function ic() {
                var d = Ae(), P = f.getTokenPos(), $ = rr(22), ce = f.hasPrecedingLineBreak(), Pe = $t(15, nc);
                return on(22, 23, $, P), Ue(r.createArrayLiteralExpression(Pe, ce), d);
              }
              __name(ic, "ic");
              function ns() {
                var d = Ae(), P = ur();
                if (wr(25)) {
                  var $ = Ai(true);
                  return ue(Ue(r.createSpreadAssignment($), d), P);
                }
                var ce = po(), Pe = xa();
                if (Ir(137))
                  return lo(d, P, ce, Pe, 174, 0);
                if (Ir(151))
                  return lo(d, P, ce, Pe, 175, 0);
                var We = wr(41), Er = Ot(), Rr = V(), Fr = wr(57), et = wr(53);
                if (We || L() === 20 || L() === 29)
                  return lc(d, P, ce, Pe, We, Rr, Fr, et);
                var xt, Gt = Er && L() !== 58;
                if (Gt) {
                  var Wt = wr(63), pn = Wt ? Vt(function() {
                    return Ai(true);
                  }) : void 0;
                  xt = r.createShorthandPropertyAssignment(Rr, pn), xt.equalsToken = Wt;
                } else {
                  rr(58);
                  var Pn = Vt(function() {
                    return Ai(true);
                  });
                  xt = r.createPropertyAssignment(Rr, Pn);
                }
                return xt.illegalDecorators = ce, xt.modifiers = Pe, xt.questionToken = Fr, xt.exclamationToken = et, ue(Ue(xt, d), P);
              }
              __name(ns, "ns");
              function a_() {
                var d = Ae(), P = f.getTokenPos(), $ = rr(18), ce = f.hasPrecedingLineBreak(), Pe = $t(12, ns, true);
                return on(18, 19, $, P), Ue(r.createObjectLiteralExpression(Pe, ce), d);
              }
              __name(a_, "a_");
              function o_() {
                var d = Zn();
                yn(false);
                var P = Ae(), $ = ur(), ce = xa();
                rr(98);
                var Pe = wr(41), We = Pe ? 1 : 0, Er = e.some(ce, e.isAsyncModifier) ? 2 : 0, Rr = We && Er ? oi(co) : We ? ri(co) : Er ? Qn(co) : co(), Fr = Oi(), et = l(We | Er), xt = Vi(58, false), Gt = Ro(We | Er);
                yn(d);
                var Wt = r.createFunctionExpression(ce, Pe, Rr, Fr, et, xt, Gt);
                return ue(Ue(Wt, P), $);
              }
              __name(o_, "o_");
              function co() {
                return en() ? Bi() : void 0;
              }
              __name(co, "co");
              function tu() {
                var d = Ae();
                if (rr(103), Xr(24)) {
                  var P = jn();
                  return Ue(r.createMetaProperty(103, P), d);
                }
                var $ = Ae(), ce = Lo($, n_(), false), Pe;
                ce.kind === 230 && (Pe = ce.typeArguments, ce = ce.expression), L() === 28 && gt(e.Diagnostics.Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0, e.getTextOfNodeFromSourceText(Ie, ce));
                var We = L() === 20 ? t_() : void 0;
                return Ue(r.createNewExpression(ce, Pe, We), d);
              }
              __name(tu, "tu");
              function za(d, P) {
                var $ = Ae(), ce = ur(), Pe = f.getTokenPos(), We = rr(18, P);
                if (We || d) {
                  var Er = f.hasPrecedingLineBreak(), Rr = Jn(1, ki);
                  on(18, 19, We, Pe);
                  var Fr = ue(Ue(r.createBlock(Rr, Er), $), ce);
                  return L() === 63 && (gt(e.Diagnostics.Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_the_whole_assignment_in_parentheses), fr()), Fr;
                } else {
                  var Rr = De();
                  return ue(Ue(r.createBlock(Rr, void 0), $), ce);
                }
              }
              __name(za, "za");
              function Ro(d, P) {
                var $ = Kn();
                In(!!(d & 1));
                var ce = Fn();
                hn(!!(d & 2));
                var Pe = St;
                St = false;
                var We = Zn();
                We && yn(false);
                var Er = za(!!(d & 16), P);
                return We && yn(true), St = Pe, In($), hn(ce), Er;
              }
              __name(Ro, "Ro");
              function s_() {
                var d = Ae(), P = ur();
                return rr(26), ue(Ue(r.createEmptyStatement(), d), P);
              }
              __name(s_, "s_");
              function nu() {
                var d = Ae(), P = ur();
                rr(99);
                var $ = f.getTokenPos(), ce = rr(20), Pe = Vt(pi);
                on(20, 21, ce, $);
                var We = ki(), Er = Xr(91) ? ki() : void 0;
                return ue(Ue(r.createIfStatement(Pe, We, Er), d), P);
              }
              __name(nu, "nu");
              function __() {
                var d = Ae(), P = ur();
                rr(90);
                var $ = ki();
                rr(115);
                var ce = f.getTokenPos(), Pe = rr(20), We = Vt(pi);
                return on(20, 21, Pe, ce), Xr(26), ue(Ue(r.createDoStatement($, We), d), P);
              }
              __name(__, "__");
              function iu() {
                var d = Ae(), P = ur();
                rr(115);
                var $ = f.getTokenPos(), ce = rr(20), Pe = Vt(pi);
                on(20, 21, ce, $);
                var We = ki();
                return ue(Ue(r.createWhileStatement(Pe, We), d), P);
              }
              __name(iu, "iu");
              function ac() {
                var d = Ae(), P = ur();
                rr(97);
                var $ = wr(133);
                rr(20);
                var ce;
                L() !== 26 && (L() === 113 || L() === 119 || L() === 85 ? ce = ps(true) : ce = ui(pi));
                var Pe;
                if ($ ? rr(162) : Xr(162)) {
                  var We = Vt(function() {
                    return Ai(true);
                  });
                  rr(21), Pe = r.createForOfStatement($, ce, We, ki());
                } else if (Xr(101)) {
                  var We = Vt(pi);
                  rr(21), Pe = r.createForInStatement(ce, We, ki());
                } else {
                  rr(26);
                  var Er = L() !== 26 && L() !== 21 ? Vt(pi) : void 0;
                  rr(26);
                  var Rr = L() !== 21 ? Vt(pi) : void 0;
                  rr(21), Pe = r.createForStatement(ce, Er, Rr, ki());
                }
                return ue(Ue(Pe, d), P);
              }
              __name(ac, "ac");
              function oc(d) {
                var P = Ae(), $ = ur();
                rr(d === 249 ? 81 : 86);
                var ce = ti() ? void 0 : Tn();
                Bn();
                var Pe = d === 249 ? r.createBreakStatement(ce) : r.createContinueStatement(ce);
                return ue(Ue(Pe, P), $);
              }
              __name(oc, "oc");
              function c_() {
                var d = Ae(), P = ur();
                rr(105);
                var $ = ti() ? void 0 : Vt(pi);
                return Bn(), ue(Ue(r.createReturnStatement($), d), P);
              }
              __name(c_, "c_");
              function au() {
                var d = Ae(), P = ur();
                rr(116);
                var $ = f.getTokenPos(), ce = rr(20), Pe = Vt(pi);
                on(20, 21, ce, $);
                var We = En(33554432, ki);
                return ue(Ue(r.createWithStatement(Pe, We), d), P);
              }
              __name(au, "au");
              function ou() {
                var d = Ae(), P = ur();
                rr(82);
                var $ = Vt(pi);
                rr(58);
                var ce = Jn(3, ki);
                return ue(Ue(r.createCaseClause($, ce), d), P);
              }
              __name(ou, "ou");
              function is() {
                var d = Ae();
                rr(88), rr(58);
                var P = Jn(3, ki);
                return Ue(r.createDefaultClause(P), d);
              }
              __name(is, "is");
              function aa() {
                return L() === 82 ? ou() : is();
              }
              __name(aa, "aa");
              function as() {
                var d = Ae();
                rr(18);
                var P = Jn(2, aa);
                return rr(19), Ue(r.createCaseBlock(P), d);
              }
              __name(as, "as");
              function u_() {
                var d = Ae(), P = ur();
                rr(107), rr(20);
                var $ = Vt(pi);
                rr(21);
                var ce = as();
                return ue(Ue(r.createSwitchStatement($, ce), d), P);
              }
              __name(u_, "u_");
              function sc() {
                var d = Ae(), P = ur();
                rr(109);
                var $ = f.hasPrecedingLineBreak() ? void 0 : Vt(pi);
                return $ === void 0 && (de++, $ = Ue(r.createIdentifier(""), Ae())), li() || rn($), ue(Ue(r.createThrowStatement($), d), P);
              }
              __name(sc, "sc");
              function su() {
                var d = Ae(), P = ur();
                rr(111);
                var $ = za(false), ce = L() === 83 ? _c() : void 0, Pe;
                return (!ce || L() === 96) && (rr(96, e.Diagnostics.catch_or_finally_expected), Pe = za(false)), ue(Ue(r.createTryStatement($, ce, Pe), d), P);
              }
              __name(su, "su");
              function _c() {
                var d = Ae();
                rr(83);
                var P;
                Xr(20) ? (P = ls(), rr(21)) : P = void 0;
                var $ = za(false);
                return Ue(r.createCatchClause(P, $), d);
              }
              __name(_c, "_c");
              function _u() {
                var d = Ae(), P = ur();
                return rr(87), Bn(), ue(Ue(r.createDebuggerStatement(), d), P);
              }
              __name(_u, "_u");
              function os() {
                var d = Ae(), P = ur(), $, ce = L() === 20, Pe = Vt(pi);
                return e.isIdentifier(Pe) && Xr(58) ? $ = r.createLabeledStatement(Pe, ki()) : (li() || rn(Pe), $ = r.createExpressionStatement(Pe), ce && (P = false)), ue(Ue($, d), P);
              }
              __name(os, "os");
              function ss() {
                return fr(), e.tokenIsIdentifierOrKeyword(L()) && !f.hasPrecedingLineBreak();
              }
              __name(ss, "ss");
              function l_() {
                return fr(), L() === 84 && !f.hasPrecedingLineBreak();
              }
              __name(l_, "l_");
              function p_() {
                return fr(), L() === 98 && !f.hasPrecedingLineBreak();
              }
              __name(p_, "p_");
              function jo() {
                return fr(), (e.tokenIsIdentifierOrKeyword(L()) || L() === 8 || L() === 9 || L() === 10) && !f.hasPrecedingLineBreak();
              }
              __name(jo, "jo");
              function f_() {
                for (; ; )
                  switch (L()) {
                    case 113:
                    case 119:
                    case 85:
                    case 98:
                    case 84:
                    case 92:
                      return true;
                    case 118:
                    case 154:
                      return Vs();
                    case 142:
                    case 143:
                      return lu();
                    case 126:
                    case 127:
                    case 132:
                    case 136:
                    case 121:
                    case 122:
                    case 123:
                    case 146:
                      if (fr(), f.hasPrecedingLineBreak())
                        return false;
                      continue;
                    case 159:
                      return fr(), L() === 18 || L() === 79 || L() === 93;
                    case 100:
                      return fr(), L() === 10 || L() === 41 || L() === 18 || e.tokenIsIdentifierOrKeyword(L());
                    case 93:
                      var d = fr();
                      if (d === 154 && (d = Gr(fr)), d === 63 || d === 41 || d === 18 || d === 88 || d === 128)
                        return true;
                      continue;
                    case 124:
                      fr();
                      continue;
                    default:
                      return false;
                  }
              }
              __name(f_, "f_");
              function Jo() {
                return Gr(f_);
              }
              __name(Jo, "Jo");
              function _s() {
                switch (L()) {
                  case 59:
                  case 26:
                  case 18:
                  case 113:
                  case 119:
                  case 98:
                  case 84:
                  case 92:
                  case 99:
                  case 90:
                  case 115:
                  case 97:
                  case 86:
                  case 81:
                  case 105:
                  case 116:
                  case 107:
                  case 109:
                  case 111:
                  case 87:
                  case 83:
                  case 96:
                    return true;
                  case 100:
                    return Jo() || Gr(Nt);
                  case 85:
                  case 93:
                    return Jo();
                  case 132:
                  case 136:
                  case 118:
                  case 142:
                  case 143:
                  case 154:
                  case 159:
                    return true;
                  case 127:
                  case 123:
                  case 121:
                  case 122:
                  case 124:
                  case 146:
                    return Jo() || !Gr(ss);
                  default:
                    return Ca();
                }
              }
              __name(_s, "_s");
              function d_() {
                return fr(), en() || L() === 18 || L() === 22;
              }
              __name(d_, "d_");
              function cu() {
                return Gr(d_);
              }
              __name(cu, "cu");
              function ki() {
                switch (L()) {
                  case 26:
                    return s_();
                  case 18:
                    return za(false);
                  case 113:
                    return Fo(Ae(), ur(), void 0, void 0);
                  case 119:
                    if (cu())
                      return Fo(Ae(), ur(), void 0, void 0);
                    break;
                  case 98:
                    return Va(Ae(), ur(), void 0, void 0);
                  case 84:
                    return hc(Ae(), ur(), void 0, void 0);
                  case 99:
                    return nu();
                  case 90:
                    return __();
                  case 115:
                    return iu();
                  case 97:
                    return ac();
                  case 86:
                    return oc(248);
                  case 81:
                    return oc(249);
                  case 105:
                    return c_();
                  case 116:
                    return au();
                  case 107:
                    return u_();
                  case 109:
                    return sc();
                  case 111:
                  case 83:
                  case 96:
                    return su();
                  case 87:
                    return _u();
                  case 59:
                    return uo();
                  case 132:
                  case 118:
                  case 154:
                  case 142:
                  case 143:
                  case 136:
                  case 85:
                  case 92:
                  case 93:
                  case 100:
                  case 121:
                  case 122:
                  case 123:
                  case 126:
                  case 127:
                  case 124:
                  case 146:
                  case 159:
                    if (Jo())
                      return uo();
                    break;
                }
                return os();
              }
              __name(ki, "ki");
              function m_(d) {
                return d.kind === 136;
              }
              __name(m_, "m_");
              function uo() {
                var d = Ae(), P = ur(), $ = po(), ce = xa(), Pe = e.some(ce, m_);
                if (Pe) {
                  var We = uu(d);
                  if (We)
                    return We;
                  for (var Er = 0, Rr = ce; Er < Rr.length; Er++) {
                    var Fr = Rr[Er];
                    Fr.flags |= 16777216;
                  }
                  return En(16777216, function() {
                    return cs(d, P, $, ce);
                  });
                } else
                  return cs(d, P, $, ce);
              }
              __name(uo, "uo");
              function uu(d) {
                return En(16777216, function() {
                  var P = $i(He, d);
                  if (P)
                    return _a(P);
                });
              }
              __name(uu, "uu");
              function cs(d, P, $, ce) {
                switch (L()) {
                  case 113:
                  case 119:
                  case 85:
                    return Fo(d, P, $, ce);
                  case 98:
                    return Va(d, P, $, ce);
                  case 84:
                    return hc(d, P, $, ce);
                  case 118:
                    return Ec(d, P, $, ce);
                  case 154:
                    return Tc(d, P, $, ce);
                  case 92:
                    return b_(d, P, $, ce);
                  case 159:
                  case 142:
                  case 143:
                    return Ka(d, P, $, ce);
                  case 100:
                    return bu(d, P, $, ce);
                  case 93:
                    switch (fr(), L()) {
                      case 88:
                      case 63:
                        return Ic(d, P, $, ce);
                      case 128:
                        return vs(d, P, $, ce);
                      default:
                        return xu(d, P, $, ce);
                    }
                  default:
                    if ($ || ce) {
                      var Pe = Vn(279, true, e.Diagnostics.Declaration_expected);
                      return e.setTextRangePos(Pe, d), Pe.illegalDecorators = $, Pe.modifiers = ce, Pe;
                    }
                    return;
                }
              }
              __name(cs, "cs");
              function lu() {
                return fr(), !f.hasPrecedingLineBreak() && (Ot() || L() === 10);
              }
              __name(lu, "lu");
              function Ia(d, P) {
                if (L() !== 18) {
                  if (d & 4) {
                    w();
                    return;
                  }
                  if (ti()) {
                    Bn();
                    return;
                  }
                }
                return Ro(d, P);
              }
              __name(Ia, "Ia");
              function cc() {
                var d = Ae();
                if (L() === 27)
                  return Ue(r.createOmittedExpression(), d);
                var P = wr(25), $ = Oa(), ce = Na();
                return Ue(r.createBindingElement(P, void 0, $, ce), d);
              }
              __name(cc, "cc");
              function g_() {
                var d = Ae(), P = wr(25), $ = en(), ce = V(), Pe;
                $ && L() !== 58 ? (Pe = ce, ce = void 0) : (rr(58), Pe = Oa());
                var We = Na();
                return Ue(r.createBindingElement(P, ce, Pe, We), d);
              }
              __name(g_, "g_");
              function us() {
                var d = Ae();
                rr(18);
                var P = $t(9, g_);
                return rr(19), Ue(r.createObjectBindingPattern(P), d);
              }
              __name(us, "us");
              function uc() {
                var d = Ae();
                rr(22);
                var P = $t(10, cc);
                return rr(23), Ue(r.createArrayBindingPattern(P), d);
              }
              __name(uc, "uc");
              function y_() {
                return L() === 18 || L() === 22 || L() === 80 || en();
              }
              __name(y_, "y_");
              function Oa(d) {
                return L() === 22 ? uc() : L() === 18 ? us() : Bi(d);
              }
              __name(Oa, "Oa");
              function Ma() {
                return ls(true);
              }
              __name(Ma, "Ma");
              function ls(d) {
                var P = Ae(), $ = ur(), ce = Oa(e.Diagnostics.Private_identifiers_are_not_allowed_in_variable_declarations), Pe;
                d && ce.kind === 79 && L() === 53 && !f.hasPrecedingLineBreak() && (Pe = An());
                var We = la(), Er = Hs(L()) ? void 0 : Na(), Rr = r.createVariableDeclaration(ce, Pe, We, Er);
                return ue(Ue(Rr, P), $);
              }
              __name(ls, "ls");
              function ps(d) {
                var P = Ae(), $ = 0;
                switch (L()) {
                  case 113:
                    break;
                  case 119:
                    $ |= 1;
                    break;
                  case 85:
                    $ |= 2;
                    break;
                  default:
                    e.Debug.fail();
                }
                fr();
                var ce;
                if (L() === 162 && Gr(h_))
                  ce = De();
                else {
                  var Pe = si();
                  cn(d), ce = $t(8, d ? ls : Ma), cn(Pe);
                }
                return Ue(r.createVariableDeclarationList(ce, $), P);
              }
              __name(ps, "ps");
              function h_() {
                return Gn() && fr() === 21;
              }
              __name(h_, "h_");
              function Fo(d, P, $, ce) {
                var Pe = ps(false);
                Bn();
                var We = r.createVariableStatement(ce, Pe);
                return We.illegalDecorators = $, ue(Ue(We, d), P);
              }
              __name(Fo, "Fo");
              function Va(d, P, $, ce) {
                var Pe = Fn(), We = e.modifiersToFlags(ce);
                rr(98);
                var Er = wr(41), Rr = We & 1024 ? co() : Bi(), Fr = Er ? 1 : 0, et = We & 512 ? 2 : 0, xt = Oi();
                We & 1 && hn(true);
                var Gt = l(Fr | et), Wt = Vi(58, false), pn = Ia(Fr | et, e.Diagnostics.or_expected);
                hn(Pe);
                var Pn = r.createFunctionDeclaration(ce, Er, Rr, xt, Gt, Wt, pn);
                return Pn.illegalDecorators = $, ue(Ue(Pn, d), P);
              }
              __name(Va, "Va");
              function pu() {
                if (L() === 135)
                  return rr(135);
                if (L() === 10 && Gr(fr) === 20)
                  return Kt(function() {
                    var d = Ji();
                    return d.text === "constructor" ? d : void 0;
                  });
              }
              __name(pu, "pu");
              function v_(d, P, $, ce) {
                return Kt(function() {
                  if (pu()) {
                    var Pe = Oi(), We = l(0), Er = Vi(58, false), Rr = Ia(0, e.Diagnostics.or_expected), Fr = r.createConstructorDeclaration(ce, We, Rr);
                    return Fr.illegalDecorators = $, Fr.typeParameters = Pe, Fr.type = Er, ue(Ue(Fr, d), P);
                  }
                });
              }
              __name(v_, "v_");
              function lc(d, P, $, ce, Pe, We, Er, Rr, Fr) {
                var et = Pe ? 1 : 0, xt = e.some(ce, e.isAsyncModifier) ? 2 : 0, Gt = Oi(), Wt = l(et | xt), pn = Vi(58, false), Pn = Ia(et | xt, Fr), _i = r.createMethodDeclaration(Wa($, ce), Pe, We, Er, Gt, Wt, pn, Pn);
                return _i.exclamationToken = Rr, ue(Ue(_i, d), P);
              }
              __name(lc, "lc");
              function fs(d, P, $, ce, Pe, We) {
                var Er = !We && !f.hasPrecedingLineBreak() ? wr(53) : void 0, Rr = la(), Fr = ln(45056, Na);
                Rn(Pe, Rr, Fr);
                var et = r.createPropertyDeclaration(Wa($, ce), Pe, We || Er, Rr, Fr);
                return ue(Ue(et, d), P);
              }
              __name(fs, "fs");
              function pc(d, P, $, ce) {
                var Pe = wr(41), We = V(), Er = wr(57);
                return Pe || L() === 20 || L() === 29 ? lc(d, P, $, ce, Pe, We, Er, void 0, e.Diagnostics.or_expected) : fs(d, P, $, ce, We, Er);
              }
              __name(pc, "pc");
              function lo(d, P, $, ce, Pe, We) {
                var Er = V(), Rr = Oi(), Fr = l(0), et = Vi(58, false), xt = Ia(We), Gt = Pe === 174 ? r.createGetAccessorDeclaration(Wa($, ce), Er, Fr, et, xt) : r.createSetAccessorDeclaration(Wa($, ce), Er, Fr, xt);
                return Gt.typeParameters = Rr, e.isSetAccessorDeclaration(Gt) && (Gt.type = et), ue(Ue(Gt, d), P);
              }
              __name(lo, "lo");
              function fc() {
                var d;
                if (L() === 59)
                  return true;
                for (; e.isModifierKind(L()); ) {
                  if (d = L(), e.isClassMemberModifier(d))
                    return true;
                  fr();
                }
                if (L() === 41 || (Si() && (d = L(), fr()), L() === 22))
                  return true;
                if (d !== void 0) {
                  if (!e.isKeyword(d) || d === 151 || d === 137)
                    return true;
                  switch (L()) {
                    case 20:
                    case 29:
                    case 53:
                    case 58:
                    case 63:
                    case 57:
                      return true;
                    default:
                      return ti();
                  }
                }
                return false;
              }
              __name(fc, "fc");
              function fu(d, P, $, ce) {
                mn(124);
                var Pe = du(), We = ue(Ue(r.createClassStaticBlockDeclaration(Pe), d), P);
                return We.illegalDecorators = $, We.modifiers = ce, We;
              }
              __name(fu, "fu");
              function du() {
                var d = Kn(), P = Fn();
                In(false), hn(true);
                var $ = za(false);
                return In(d), hn(P), $;
              }
              __name(du, "du");
              function ya() {
                if (Fn() && L() === 133) {
                  var d = Ae(), P = Tn(e.Diagnostics.Expression_expected);
                  fr();
                  var $ = Lo(d, P, true);
                  return pa(d, $);
                }
                return na();
              }
              __name(ya, "ya");
              function dc() {
                var d = Ae();
                if (!!Xr(59)) {
                  var P = bi(ya);
                  return Ue(r.createDecorator(P), d);
                }
              }
              __name(dc, "dc");
              function po() {
                for (var d = Ae(), P, $; $ = dc(); )
                  P = e.append(P, $);
                return P && vn(P, d);
              }
              __name(po, "po");
              function mu(d, P, $) {
                var ce = Ae(), Pe = L();
                if (L() === 85 && d) {
                  if (!Kt(Ar))
                    return;
                } else {
                  if (P && L() === 124 && Gr(wc))
                    return;
                  if ($ && L() === 124)
                    return;
                  if (!Ut())
                    return;
                }
                return Ue(r.createToken(Pe), ce);
              }
              __name(mu, "mu");
              function Wa(d, P) {
                if (!d)
                  return P;
                if (!P)
                  return d;
                var $ = r.createNodeArray(e.concatenate(d, P));
                return e.setTextRangePosEnd($, d.pos, P.end), $;
              }
              __name(Wa, "Wa");
              function xa(d, P) {
                for (var $ = Ae(), ce, Pe, We = false; Pe = mu(d, P, We); )
                  Pe.kind === 124 && (We = true), ce = e.append(ce, Pe);
                return ce && vn(ce, $);
              }
              __name(xa, "xa");
              function mc() {
                var d;
                if (L() === 132) {
                  var P = Ae();
                  fr();
                  var $ = Ue(r.createToken(132), P);
                  d = vn([$], P);
                }
                return d;
              }
              __name(mc, "mc");
              function gc() {
                var d = Ae();
                if (L() === 26)
                  return fr(), Ue(r.createSemicolonClassElement(), d);
                var P = ur(), $ = po(), ce = xa(true, true);
                if (L() === 124 && Gr(wc))
                  return fu(d, P, $, ce);
                if (Ir(137))
                  return lo(d, P, $, ce, 174, 0);
                if (Ir(151))
                  return lo(d, P, $, ce, 175, 0);
                if (L() === 135 || L() === 10) {
                  var Pe = v_(d, P, $, ce);
                  if (Pe)
                    return Pe;
                }
                if (ke())
                  return Zr(d, P, $, ce);
                if (e.tokenIsIdentifierOrKeyword(L()) || L() === 10 || L() === 8 || L() === 41 || L() === 22) {
                  var We = e.some(ce, m_);
                  if (We) {
                    for (var Er = 0, Rr = ce; Er < Rr.length; Er++) {
                      var Fr = Rr[Er];
                      Fr.flags |= 16777216;
                    }
                    return En(16777216, function() {
                      return pc(d, P, $, ce);
                    });
                  } else
                    return pc(d, P, $, ce);
                }
                if ($ || ce) {
                  var et = Vn(79, true, e.Diagnostics.Declaration_expected);
                  return fs(d, P, $, ce, et, void 0);
                }
                return e.Debug.fail("Should not have attempted to parse class member declaration.");
              }
              __name(gc, "gc");
              function yc() {
                return ds(Ae(), ur(), void 0, void 0, 228);
              }
              __name(yc, "yc");
              function hc(d, P, $, ce) {
                return ds(d, P, $, ce, 260);
              }
              __name(hc, "hc");
              function ds(d, P, $, ce, Pe) {
                var We = Fn();
                rr(84);
                var Er = ms(), Rr = Oi();
                e.some(ce, e.isExportModifier) && hn(true);
                var Fr = gs(), et;
                rr(18) ? (et = hu(), rr(19)) : et = De(), hn(We);
                var xt = Pe === 260 ? r.createClassDeclaration(Wa($, ce), Er, Rr, Fr, et) : r.createClassExpression(Wa($, ce), Er, Rr, Fr, et);
                return ue(Ue(xt, d), P);
              }
              __name(ds, "ds");
              function ms() {
                return en() && !gu() ? ni(en()) : void 0;
              }
              __name(ms, "ms");
              function gu() {
                return L() === 117 && Gr(qi);
              }
              __name(gu, "gu");
              function gs() {
                if (bc())
                  return Jn(22, vc);
              }
              __name(gs, "gs");
              function vc() {
                var d = Ae(), P = L();
                e.Debug.assert(P === 94 || P === 117), fr();
                var $ = $t(7, yu);
                return Ue(r.createHeritageClause(P, $), d);
              }
              __name(vc, "vc");
              function yu() {
                var d = Ae(), P = na();
                if (P.kind === 230)
                  return P;
                var $ = ys();
                return Ue(r.createExpressionWithTypeArguments(P, $), d);
              }
              __name(yu, "yu");
              function ys() {
                return L() === 29 ? Jt(20, Un, 29, 31) : void 0;
              }
              __name(ys, "ys");
              function bc() {
                return L() === 94 || L() === 117;
              }
              __name(bc, "bc");
              function hu() {
                return Jn(5, gc);
              }
              __name(hu, "hu");
              function Ec(d, P, $, ce) {
                rr(118);
                var Pe = Tn(), We = Oi(), Er = gs(), Rr = Sn(), Fr = r.createInterfaceDeclaration(ce, Pe, We, Er, Rr);
                return Fr.illegalDecorators = $, ue(Ue(Fr, d), P);
              }
              __name(Ec, "Ec");
              function Tc(d, P, $, ce) {
                rr(154);
                var Pe = Tn(), We = Oi();
                rr(63);
                var Er = L() === 139 && Kt(Ls) || Un();
                Bn();
                var Rr = r.createTypeAliasDeclaration(ce, Pe, We, Er);
                return Rr.illegalDecorators = $, ue(Ue(Rr, d), P);
              }
              __name(Tc, "Tc");
              function Sc() {
                var d = Ae(), P = ur(), $ = V(), ce = Vt(Na);
                return ue(Ue(r.createEnumMember($, ce), d), P);
              }
              __name(Sc, "Sc");
              function b_(d, P, $, ce) {
                rr(92);
                var Pe = Tn(), We;
                rr(18) ? (We = Ei(function() {
                  return $t(6, Sc);
                }), rr(19)) : We = De();
                var Er = r.createEnumDeclaration(ce, Pe, We);
                return Er.illegalDecorators = $, ue(Ue(Er, d), P);
              }
              __name(b_, "b_");
              function Cc() {
                var d = Ae(), P;
                return rr(18) ? (P = Jn(1, ki), rr(19)) : P = De(), Ue(r.createModuleBlock(P), d);
              }
              __name(Cc, "Cc");
              function Dc(d, P, $, ce, Pe) {
                var We = Pe & 16, Er = Tn(), Rr = Xr(24) ? Dc(Ae(), false, void 0, void 0, 4 | We) : Cc(), Fr = r.createModuleDeclaration(ce, Er, Rr, Pe);
                return Fr.illegalDecorators = $, ue(Ue(Fr, d), P);
              }
              __name(Dc, "Dc");
              function xc(d, P, $, ce) {
                var Pe = 0, We;
                L() === 159 ? (We = Tn(), Pe |= 1024) : (We = Ji(), We.text = Ti(We.text));
                var Er;
                L() === 18 ? Er = Cc() : Bn();
                var Rr = r.createModuleDeclaration(ce, We, Er, Pe);
                return Rr.illegalDecorators = $, ue(Ue(Rr, d), P);
              }
              __name(xc, "xc");
              function Ka(d, P, $, ce) {
                var Pe = 0;
                if (L() === 159)
                  return xc(d, P, $, ce);
                if (Xr(143))
                  Pe |= 16;
                else if (rr(142), L() === 10)
                  return xc(d, P, $, ce);
                return Dc(d, P, $, ce, Pe);
              }
              __name(Ka, "Ka");
              function fo() {
                return L() === 147 && Gr(hs);
              }
              __name(fo, "fo");
              function hs() {
                return fr() === 20;
              }
              __name(hs, "hs");
              function wc() {
                return fr() === 18;
              }
              __name(wc, "wc");
              function vu() {
                return fr() === 43;
              }
              __name(vu, "vu");
              function vs(d, P, $, ce) {
                rr(128), rr(143);
                var Pe = Tn();
                Bn();
                var We = r.createNamespaceExportDeclaration(Pe);
                return We.illegalDecorators = $, We.modifiers = ce, ue(Ue(We, d), P);
              }
              __name(vs, "vs");
              function bu(d, P, $, ce) {
                rr(100);
                var Pe = f.getStartPos(), We;
                Ot() && (We = Tn());
                var Er = false;
                if (L() !== 158 && (We == null ? void 0 : We.escapedText) === "type" && (Ot() || Ha()) && (Er = true, We = Ot() ? Tn() : void 0), We && !Ac())
                  return Tu(d, P, $, ce, We, Er);
                var Rr;
                (We || L() === 41 || L() === 18) && (Rr = Su(We, Pe, Er), rr(158));
                var Fr = Es(), et;
                L() === 130 && !f.hasPrecedingLineBreak() && (et = E_()), Bn();
                var xt = r.createImportDeclaration(ce, Rr, Fr, et);
                return xt.illegalDecorators = $, ue(Ue(xt, d), P);
              }
              __name(bu, "bu");
              function Eu() {
                var d = Ae(), P = e.tokenIsIdentifierOrKeyword(L()) ? jn() : wa(10);
                rr(58);
                var $ = Ai(true);
                return Ue(r.createAssertEntry(P, $), d);
              }
              __name(Eu, "Eu");
              function E_(d) {
                var P = Ae();
                d || rr(130);
                var $ = f.getTokenPos();
                if (rr(18)) {
                  var ce = f.hasPrecedingLineBreak(), Pe = $t(24, Eu, true);
                  if (!rr(19)) {
                    var We = e.lastOrUndefined(vr);
                    We && We.code === e.Diagnostics._0_expected.code && e.addRelatedInfo(We, e.createDetachedDiagnostic(ct, $, 1, e.Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}"));
                  }
                  return Ue(r.createAssertClause(Pe, ce), P);
                } else {
                  var Pe = vn([], Ae(), void 0, false);
                  return Ue(r.createAssertClause(Pe, false), P);
                }
              }
              __name(E_, "E_");
              function Ha() {
                return L() === 41 || L() === 18;
              }
              __name(Ha, "Ha");
              function Ac() {
                return L() === 27 || L() === 158;
              }
              __name(Ac, "Ac");
              function Tu(d, P, $, ce, Pe, We) {
                rr(63);
                var Er = bs();
                Bn();
                var Rr = r.createImportEqualsDeclaration(ce, We, Pe, Er);
                Rr.illegalDecorators = $;
                var Fr = ue(Ue(Rr, d), P);
                return Fr;
              }
              __name(Tu, "Tu");
              function Su(d, P, $) {
                var ce;
                return (!d || Xr(27)) && (ce = L() === 41 ? kc() : La(272)), Ue(r.createImportClause($, d, ce), P);
              }
              __name(Su, "Su");
              function bs() {
                return fo() ? Cu() : Qt(false);
              }
              __name(bs, "bs");
              function Cu() {
                var d = Ae();
                rr(147), rr(20);
                var P = Es();
                return rr(21), Ue(r.createExternalModuleReference(P), d);
              }
              __name(Cu, "Cu");
              function Es() {
                if (L() === 10) {
                  var d = Ji();
                  return d.text = Ti(d.text), d;
                } else
                  return pi();
              }
              __name(Es, "Es");
              function kc() {
                var d = Ae();
                rr(41), rr(128);
                var P = Tn();
                return Ue(r.createNamespaceImport(P), d);
              }
              __name(kc, "kc");
              function La(d) {
                var P = Ae(), $ = d === 272 ? r.createNamedImports(Jt(23, Ga, 18, 19)) : r.createNamedExports(Jt(23, Du, 18, 19));
                return Ue($, P);
              }
              __name(La, "La");
              function Du() {
                var d = ur();
                return ue(Pc(278), d);
              }
              __name(Du, "Du");
              function Ga() {
                return Pc(273);
              }
              __name(Ga, "Ga");
              function Pc(d) {
                var P = Ae(), $ = e.isKeyword(L()) && !Ot(), ce = f.getTokenPos(), Pe = f.getTextPos(), We = false, Er, Rr = true, Fr = jn();
                if (Fr.escapedText === "type")
                  if (L() === 128) {
                    var et = jn();
                    if (L() === 128) {
                      var xt = jn();
                      e.tokenIsIdentifierOrKeyword(L()) ? (We = true, Er = et, Fr = Wt(), Rr = false) : (Er = Fr, Fr = xt, Rr = false);
                    } else
                      e.tokenIsIdentifierOrKeyword(L()) ? (Er = Fr, Rr = false, Fr = Wt()) : (We = true, Fr = et);
                  } else
                    e.tokenIsIdentifierOrKeyword(L()) && (We = true, Fr = Wt());
                Rr && L() === 128 && (Er = Fr, rr(128), Fr = Wt()), d === 273 && $ && dn(ce, Pe, e.Diagnostics.Identifier_expected);
                var Gt = d === 273 ? r.createImportSpecifier(We, Er, Fr) : r.createExportSpecifier(We, Er, Fr);
                return Ue(Gt, P);
                function Wt() {
                  return $ = e.isKeyword(L()) && !Ot(), ce = f.getTokenPos(), Pe = f.getTextPos(), jn();
                }
                __name(Wt, "Wt");
              }
              __name(Pc, "Pc");
              function Nc(d) {
                return Ue(r.createNamespaceExport(jn()), d);
              }
              __name(Nc, "Nc");
              function xu(d, P, $, ce) {
                var Pe = Fn();
                hn(true);
                var We, Er, Rr, Fr = Xr(154), et = Ae();
                Xr(41) ? (Xr(128) && (We = Nc(et)), rr(158), Er = Es()) : (We = La(276), (L() === 158 || L() === 10 && !f.hasPrecedingLineBreak()) && (rr(158), Er = Es())), Er && L() === 130 && !f.hasPrecedingLineBreak() && (Rr = E_()), Bn(), hn(Pe);
                var xt = r.createExportDeclaration(ce, Fr, We, Er, Rr);
                return xt.illegalDecorators = $, ue(Ue(xt, d), P);
              }
              __name(xu, "xu");
              function Ic(d, P, $, ce) {
                var Pe = Fn();
                hn(true);
                var We;
                Xr(63) ? We = true : rr(88);
                var Er = Ai(true);
                Bn(), hn(Pe);
                var Rr = r.createExportAssignment(ce, We, Er);
                return Rr.illegalDecorators = $, ue(Ue(Rr, d), P);
              }
              __name(Ic, "Ic");
              var Ts;
              (function(d) {
                d[d.SourceElements = 0] = "SourceElements", d[d.BlockStatements = 1] = "BlockStatements", d[d.SwitchClauses = 2] = "SwitchClauses", d[d.SwitchClauseStatements = 3] = "SwitchClauseStatements", d[d.TypeMembers = 4] = "TypeMembers", d[d.ClassMembers = 5] = "ClassMembers", d[d.EnumMembers = 6] = "EnumMembers", d[d.HeritageClauseElement = 7] = "HeritageClauseElement", d[d.VariableDeclarations = 8] = "VariableDeclarations", d[d.ObjectBindingElements = 9] = "ObjectBindingElements", d[d.ArrayBindingElements = 10] = "ArrayBindingElements", d[d.ArgumentExpressions = 11] = "ArgumentExpressions", d[d.ObjectLiteralMembers = 12] = "ObjectLiteralMembers", d[d.JsxAttributes = 13] = "JsxAttributes", d[d.JsxChildren = 14] = "JsxChildren", d[d.ArrayLiteralMembers = 15] = "ArrayLiteralMembers", d[d.Parameters = 16] = "Parameters", d[d.JSDocParameters = 17] = "JSDocParameters", d[d.RestProperties = 18] = "RestProperties", d[d.TypeParameters = 19] = "TypeParameters", d[d.TypeArguments = 20] = "TypeArguments", d[d.TupleElementTypes = 21] = "TupleElementTypes", d[d.HeritageClauses = 22] = "HeritageClauses", d[d.ImportOrExportSpecifiers = 23] = "ImportOrExportSpecifiers", d[d.AssertEntries = 24] = "AssertEntries", d[d.Count = 25] = "Count";
              })(Ts || (Ts = {}));
              var T_;
              (function(d) {
                d[d.False = 0] = "False", d[d.True = 1] = "True", d[d.Unknown = 2] = "Unknown";
              })(T_ || (T_ = {}));
              var Oc;
              (function(d) {
                function P(et, xt, Gt) {
                  mt("file.js", et, 99, void 0, 1), f.setText(et, xt, Gt), Mr = f.scan();
                  var Wt = $(), pn = Ct("file.js", 99, 1, false, [], r.createToken(1), 0, e.noop), Pn = e.attachFileToDiagnostics(vr, pn);
                  return nt && (pn.jsDocDiagnostics = e.attachFileToDiagnostics(nt, pn)), at(), Wt ? { jsDocTypeExpression: Wt, diagnostics: Pn } : void 0;
                }
                __name(P, "P");
                d.parseJSDocTypeExpressionForTests = P;
                function $(et) {
                  var xt = Ae(), Gt = (et ? Xr : rr)(18), Wt = En(8388608, ka);
                  (!et || Gt) && kn(19);
                  var pn = r.createJSDocTypeExpression(Wt);
                  return Hr(pn), Ue(pn, xt);
                }
                __name($, "$");
                d.parseJSDocTypeExpression = $;
                function ce() {
                  for (var et = Ae(), xt = Xr(18), Gt = Ae(), Wt = Qt(false); L() === 80; )
                    dt(), Me(), Wt = Ue(r.createJSDocMemberName(Wt, Tn()), Gt);
                  xt && kn(19);
                  var pn = r.createJSDocNameReference(Wt);
                  return Hr(pn), Ue(pn, et);
                }
                __name(ce, "ce");
                d.parseJSDocNameReference = ce;
                function Pe(et, xt, Gt) {
                  mt("", et, 99, void 0, 1);
                  var Wt = En(8388608, function() {
                    return Fr(xt, Gt);
                  }), pn = { languageVariant: 0, text: et }, Pn = e.attachFileToDiagnostics(vr, pn);
                  return at(), Wt ? { jsDoc: Wt, diagnostics: Pn } : void 0;
                }
                __name(Pe, "Pe");
                d.parseIsolatedJSDocComment = Pe;
                function We(et, xt, Gt) {
                  var Wt = Mr, pn = vr.length, Pn = Dt, _i = En(8388608, function() {
                    return Fr(xt, Gt);
                  });
                  return e.setParent(_i, et), Yr & 262144 && (nt || (nt = []), nt.push.apply(nt, vr)), Mr = Wt, vr.length = pn, Dt = Pn, _i;
                }
                __name(We, "We");
                d.parseJSDocComment = We;
                var Er;
                (function(et) {
                  et[et.BeginningOfLine = 0] = "BeginningOfLine", et[et.SawAsterisk = 1] = "SawAsterisk", et[et.SavingComments = 2] = "SavingComments", et[et.SavingBackticks = 3] = "SavingBackticks";
                })(Er || (Er = {}));
                var Rr;
                (function(et) {
                  et[et.Property = 1] = "Property", et[et.Parameter = 2] = "Parameter", et[et.CallbackParameter = 4] = "CallbackParameter";
                })(Rr || (Rr = {}));
                function Fr(et, xt) {
                  et === void 0 && (et = 0);
                  var Gt = Ie, Wt = xt === void 0 ? Gt.length : et + xt;
                  if (xt = Wt - et, e.Debug.assert(et >= 0), e.Debug.assert(et <= Wt), e.Debug.assert(Wt <= Gt.length), !Le(Gt, et))
                    return;
                  var pn, Pn, _i, Ln, ha, Di = [], Xn = [];
                  return f.scanRange(et + 3, xt - 5, function() {
                    var sr = 1, $r, Wr = et - (Gt.lastIndexOf(`
`, et) + 1) + 4;
                    function st(Mi) {
                      $r || ($r = Wr), Di.push(Mi), Wr += Mi.length;
                    }
                    __name(st, "st");
                    for (Me(); qo(5); )
                      ;
                    qo(4) && (sr = 0, Wr = 0);
                    e:
                      for (; ; ) {
                        switch (L()) {
                          case 59:
                            sr === 0 || sr === 1 ? (oa(Di), ha || (ha = Ae()), fa(o(Wr)), sr = 0, $r = void 0) : st(f.getTokenText());
                            break;
                          case 4:
                            Di.push(f.getTokenText()), sr = 0, Wr = 0;
                            break;
                          case 41:
                            var ht = f.getTokenText();
                            sr === 1 || sr === 2 ? (sr = 2, st(ht)) : (sr = 1, Wr += ht.length);
                            break;
                          case 5:
                            var Bt = f.getTokenText();
                            sr === 2 ? Di.push(Bt) : $r !== void 0 && Wr + Bt.length > $r && Di.push(Bt.slice($r - Wr)), Wr += Bt.length;
                            break;
                          case 1:
                            break e;
                          case 18:
                            sr = 2;
                            var Cn = f.getStartPos(), hi = f.getTextPos() - 1, fi = Ke(hi);
                            if (fi) {
                              Ln || Pi(Di), Xn.push(Ue(r.createJSDocText(Di.join("")), Ln != null ? Ln : et, Cn)), Xn.push(fi), Di = [], Ln = f.getTextPos();
                              break;
                            }
                          default:
                            sr = 2, st(f.getTokenText());
                            break;
                        }
                        Me();
                      }
                    oa(Di), Xn.length && Di.length && Xn.push(Ue(r.createJSDocText(Di.join("")), Ln != null ? Ln : et, ha)), Xn.length && pn && e.Debug.assertIsDefined(ha, "having parsed tags implies that the end of the comment span should be set");
                    var Ki = pn && vn(pn, Pn, _i);
                    return Ue(r.createJSDocComment(Xn.length ? vn(Xn, et, ha) : Di.length ? Di.join("") : void 0, Ki), et, Wt);
                  });
                  function Pi(sr) {
                    for (; sr.length && (sr[0] === `
` || sr[0] === "\r"); )
                      sr.shift();
                  }
                  __name(Pi, "Pi");
                  function oa(sr) {
                    for (; sr.length && sr[sr.length - 1].trim() === ""; )
                      sr.pop();
                  }
                  __name(oa, "oa");
                  function Xa() {
                    for (; ; ) {
                      if (Me(), L() === 1)
                        return true;
                      if (!(L() === 5 || L() === 4))
                        return false;
                    }
                  }
                  __name(Xa, "Xa");
                  function ii() {
                    if (!((L() === 5 || L() === 4) && Gr(Xa)))
                      for (; L() === 5 || L() === 4; )
                        Me();
                  }
                  __name(ii, "ii");
                  function i() {
                    if ((L() === 5 || L() === 4) && Gr(Xa))
                      return "";
                    for (var sr = f.hasPrecedingLineBreak(), $r = false, Wr = ""; sr && L() === 41 || L() === 5 || L() === 4; )
                      Wr += f.getTokenText(), L() === 4 ? (sr = true, $r = true, Wr = "") : L() === 41 && (sr = false), Me();
                    return $r ? Wr : "";
                  }
                  __name(i, "i");
                  function o(sr) {
                    e.Debug.assert(L() === 59);
                    var $r = f.getTokenPos();
                    Me();
                    var Wr = mo(void 0), st = i(), ht;
                    switch (Wr.escapedText) {
                      case "author":
                        ht = Pl($r, Wr, sr, st);
                        break;
                      case "implements":
                        ht = Nl($r, Wr, sr, st);
                        break;
                      case "augments":
                      case "extends":
                        ht = Il($r, Wr, sr, st);
                        break;
                      case "class":
                      case "constructor":
                        ht = Wi($r, r.createJSDocClassTag, Wr, sr, st);
                        break;
                      case "public":
                        ht = Wi($r, r.createJSDocPublicTag, Wr, sr, st);
                        break;
                      case "private":
                        ht = Wi($r, r.createJSDocPrivateTag, Wr, sr, st);
                        break;
                      case "protected":
                        ht = Wi($r, r.createJSDocProtectedTag, Wr, sr, st);
                        break;
                      case "readonly":
                        ht = Wi($r, r.createJSDocReadonlyTag, Wr, sr, st);
                        break;
                      case "override":
                        ht = Wi($r, r.createJSDocOverrideTag, Wr, sr, st);
                        break;
                      case "deprecated":
                        Qe = true, ht = Wi($r, r.createJSDocDeprecatedTag, Wr, sr, st);
                        break;
                      case "this":
                        ht = Ol($r, Wr, sr, st);
                        break;
                      case "enum":
                        ht = Vu($r, Wr, sr, st);
                        break;
                      case "arg":
                      case "argument":
                      case "param":
                        return Cs($r, Wr, 2, sr);
                      case "return":
                      case "returns":
                        ht = Mc($r, Wr, sr, st);
                        break;
                      case "template":
                        ht = Ku($r, Wr, sr, st);
                        break;
                      case "type":
                        ht = Bu($r, Wr, sr, st);
                        break;
                      case "typedef":
                        ht = Ml($r, Wr, sr, st);
                        break;
                      case "callback":
                        ht = Rl($r, Wr, sr, st);
                        break;
                      case "see":
                        ht = qu($r, Wr, sr, st);
                        break;
                      default:
                        ht = $n($r, Wr, sr, st);
                        break;
                    }
                    return ht;
                  }
                  __name(o, "o");
                  function u(sr, $r, Wr, st) {
                    return st || (Wr += $r - sr), b(Wr, st.slice(Wr));
                  }
                  __name(u, "u");
                  function b(sr, $r) {
                    var Wr = Ae(), st = [], ht = [], Bt, Cn = 0, hi = true, fi;
                    function Ki(xs) {
                      fi || (fi = sr), st.push(xs), sr += xs.length;
                    }
                    __name(Ki, "Ki");
                    $r !== void 0 && ($r !== "" && Ki($r), Cn = 1);
                    var Mi = L();
                    e:
                      for (; ; ) {
                        switch (Mi) {
                          case 4:
                            Cn = 0, st.push(f.getTokenText()), sr = 0;
                            break;
                          case 59:
                            if (Cn === 3 || Cn === 2 && (!hi || Gr(Y))) {
                              st.push(f.getTokenText());
                              break;
                            }
                            f.setTextPos(f.getTextPos() - 1);
                          case 1:
                            break e;
                          case 5:
                            if (Cn === 2 || Cn === 3)
                              Ki(f.getTokenText());
                            else {
                              var va = f.getTokenText();
                              fi !== void 0 && sr + va.length > fi && st.push(va.slice(fi - sr)), sr += va.length;
                            }
                            break;
                          case 18:
                            Cn = 2;
                            var Ds = f.getStartPos(), Rc = f.getTextPos() - 1, jc = Ke(Rc);
                            jc ? (ht.push(Ue(r.createJSDocText(st.join("")), Bt != null ? Bt : Wr, Ds)), ht.push(jc), st = [], Bt = f.getTextPos()) : Ki(f.getTokenText());
                            break;
                          case 61:
                            Cn === 3 ? Cn = 2 : Cn = 3, Ki(f.getTokenText());
                            break;
                          case 41:
                            if (Cn === 0) {
                              Cn = 1, sr += 1;
                              break;
                            }
                          default:
                            Cn !== 3 && (Cn = 2), Ki(f.getTokenText());
                            break;
                        }
                        hi = L() === 5, Mi = Me();
                      }
                    if (Pi(st), oa(st), ht.length)
                      return st.length && ht.push(Ue(r.createJSDocText(st.join("")), Bt != null ? Bt : Wr)), vn(ht, Wr, f.getTextPos());
                    if (st.length)
                      return st.join("");
                  }
                  __name(b, "b");
                  function Y() {
                    var sr = Me();
                    return sr === 5 || sr === 4;
                  }
                  __name(Y, "Y");
                  function Ke(sr) {
                    var $r = Kt(Or);
                    if (!!$r) {
                      Me(), ii();
                      var Wr = Ae(), st = e.tokenIsIdentifierOrKeyword(L()) ? Qt(true) : void 0;
                      if (st)
                        for (; L() === 80; )
                          dt(), Me(), st = Ue(r.createJSDocMemberName(st, Tn()), Wr);
                      for (var ht = []; L() !== 19 && L() !== 4 && L() !== 1; )
                        ht.push(f.getTokenText()), Me();
                      var Bt = $r === "link" ? r.createJSDocLink : $r === "linkcode" ? r.createJSDocLinkCode : r.createJSDocLinkPlain;
                      return Ue(Bt(st, ht.join("")), sr, f.getTextPos());
                    }
                  }
                  __name(Ke, "Ke");
                  function Or() {
                    if (i(), L() === 18 && Me() === 59 && e.tokenIsIdentifierOrKeyword(Me())) {
                      var sr = f.getTokenValue();
                      if (kt(sr))
                        return sr;
                    }
                  }
                  __name(Or, "Or");
                  function kt(sr) {
                    return sr === "link" || sr === "linkcode" || sr === "linkplain";
                  }
                  __name(kt, "kt");
                  function $n(sr, $r, Wr, st) {
                    return Ue(r.createJSDocUnknownTag($r, u(sr, Ae(), Wr, st)), sr);
                  }
                  __name($n, "$n");
                  function fa(sr) {
                    !sr || (pn ? pn.push(sr) : (pn = [sr], Pn = sr.pos), _i = sr.end);
                  }
                  __name(fa, "fa");
                  function Bo() {
                    return i(), L() === 18 ? $() : void 0;
                  }
                  __name(Bo, "Bo");
                  function $a() {
                    var sr = qo(22);
                    sr && ii();
                    var $r = qo(61), Wr = Bl();
                    return $r && Li(61), sr && (ii(), wr(63) && pi(), rr(23)), { name: Wr, isBracketed: sr };
                  }
                  __name($a, "$a");
                  function Ss(sr) {
                    switch (sr.kind) {
                      case 149:
                        return true;
                      case 185:
                        return Ss(sr.elementType);
                      default:
                        return e.isTypeReferenceNode(sr) && e.isIdentifier(sr.typeName) && sr.typeName.escapedText === "Object" && !sr.typeArguments;
                    }
                  }
                  __name(Ss, "Ss");
                  function Cs(sr, $r, Wr, st) {
                    var ht = Bo(), Bt = !ht;
                    i();
                    var Cn = $a(), hi = Cn.name, fi = Cn.isBracketed, Ki = i();
                    Bt && !Gr(Or) && (ht = Bo());
                    var Mi = u(sr, Ae(), st, Ki), va = Wr !== 4 && Fu(ht, hi, Wr, st);
                    va && (ht = va, Bt = true);
                    var Ds = Wr === 1 ? r.createJSDocPropertyTag($r, hi, fi, ht, Bt, Mi) : r.createJSDocParameterTag($r, hi, fi, ht, Bt, Mi);
                    return Ue(Ds, sr);
                  }
                  __name(Cs, "Cs");
                  function Fu(sr, $r, Wr, st) {
                    if (sr && Ss(sr.type)) {
                      for (var ht = Ae(), Bt = void 0, Cn = void 0; Bt = Kt(function() {
                        return Lc(Wr, st, $r);
                      }); )
                        (Bt.kind === 343 || Bt.kind === 350) && (Cn = e.append(Cn, Bt));
                      if (Cn) {
                        var hi = Ue(r.createJSDocTypeLiteral(Cn, sr.type.kind === 185), ht);
                        return Ue(r.createJSDocTypeExpression(hi), ht);
                      }
                    }
                  }
                  __name(Fu, "Fu");
                  function Mc(sr, $r, Wr, st) {
                    e.some(pn, e.isJSDocReturnTag) && dn($r.pos, f.getTokenPos(), e.Diagnostics._0_tag_already_specified, $r.escapedText);
                    var ht = Bo();
                    return Ue(r.createJSDocReturnTag($r, ht, u(sr, Ae(), Wr, st)), sr);
                  }
                  __name(Mc, "Mc");
                  function Bu(sr, $r, Wr, st) {
                    e.some(pn, e.isJSDocTypeTag) && dn($r.pos, f.getTokenPos(), e.Diagnostics._0_tag_already_specified, $r.escapedText);
                    var ht = $(true), Bt = Wr !== void 0 && st !== void 0 ? u(sr, Ae(), Wr, st) : void 0;
                    return Ue(r.createJSDocTypeTag($r, ht, Bt), sr);
                  }
                  __name(Bu, "Bu");
                  function qu(sr, $r, Wr, st) {
                    var ht = L() === 22 || Gr(function() {
                      return Me() === 59 && e.tokenIsIdentifierOrKeyword(Me()) && kt(f.getTokenValue());
                    }), Bt = ht ? void 0 : ce(), Cn = Wr !== void 0 && st !== void 0 ? u(sr, Ae(), Wr, st) : void 0;
                    return Ue(r.createJSDocSeeTag($r, Bt, Cn), sr);
                  }
                  __name(qu, "qu");
                  function Pl(sr, $r, Wr, st) {
                    var ht = Ae(), Bt = Uu(), Cn = f.getStartPos(), hi = u(sr, Cn, Wr, st);
                    hi || (Cn = f.getStartPos());
                    var fi = typeof hi != "string" ? vn(e.concatenate([Ue(Bt, ht, Cn)], hi), ht) : Bt.text + hi;
                    return Ue(r.createJSDocAuthorTag($r, fi), sr);
                  }
                  __name(Pl, "Pl");
                  function Uu() {
                    for (var sr = [], $r = false, Wr = f.getToken(); Wr !== 1 && Wr !== 4; ) {
                      if (Wr === 29)
                        $r = true;
                      else {
                        if (Wr === 59 && !$r)
                          break;
                        if (Wr === 31 && $r) {
                          sr.push(f.getTokenText()), f.setTextPos(f.getTokenPos() + 1);
                          break;
                        }
                      }
                      sr.push(f.getTokenText()), Wr = Me();
                    }
                    return r.createJSDocText(sr.join(""));
                  }
                  __name(Uu, "Uu");
                  function Nl(sr, $r, Wr, st) {
                    var ht = zu();
                    return Ue(r.createJSDocImplementsTag($r, ht, u(sr, Ae(), Wr, st)), sr);
                  }
                  __name(Nl, "Nl");
                  function Il(sr, $r, Wr, st) {
                    var ht = zu();
                    return Ue(r.createJSDocAugmentsTag($r, ht, u(sr, Ae(), Wr, st)), sr);
                  }
                  __name(Il, "Il");
                  function zu() {
                    var sr = Xr(18), $r = Ae(), Wr = wu(), st = ys(), ht = r.createExpressionWithTypeArguments(Wr, st), Bt = Ue(ht, $r);
                    return sr && rr(19), Bt;
                  }
                  __name(zu, "zu");
                  function wu() {
                    for (var sr = Ae(), $r = mo(); Xr(24); ) {
                      var Wr = mo();
                      $r = Ue(r.createPropertyAccessExpression($r, Wr), sr);
                    }
                    return $r;
                  }
                  __name(wu, "wu");
                  function Wi(sr, $r, Wr, st, ht) {
                    return Ue($r(Wr, u(sr, Ae(), st, ht)), sr);
                  }
                  __name(Wi, "Wi");
                  function Ol(sr, $r, Wr, st) {
                    var ht = $(true);
                    return ii(), Ue(r.createJSDocThisTag($r, ht, u(sr, Ae(), Wr, st)), sr);
                  }
                  __name(Ol, "Ol");
                  function Vu(sr, $r, Wr, st) {
                    var ht = $(true);
                    return ii(), Ue(r.createJSDocEnumTag($r, ht, u(sr, Ae(), Wr, st)), sr);
                  }
                  __name(Vu, "Vu");
                  function Ml(sr, $r, Wr, st) {
                    var ht, Bt = Bo();
                    i();
                    var Cn = Au();
                    ii();
                    var hi = b(Wr), fi;
                    if (!Bt || Ss(Bt.type)) {
                      for (var Ki = void 0, Mi = void 0, va = void 0, Ds = false; Ki = Kt(function() {
                        return jl(Wr);
                      }); )
                        if (Ds = true, Ki.kind === 346)
                          if (Mi) {
                            var Rc = gt(e.Diagnostics.A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags);
                            Rc && e.addRelatedInfo(Rc, e.createDetachedDiagnostic(ct, 0, 0, e.Diagnostics.The_tag_was_first_specified_here));
                            break;
                          } else
                            Mi = Ki;
                        else
                          va = e.append(va, Ki);
                      if (Ds) {
                        var jc = Bt && Bt.type.kind === 185, xs = r.createJSDocTypeLiteral(va, jc);
                        Bt = Mi && Mi.typeExpression && !Ss(Mi.typeExpression.type) ? Mi.typeExpression : Ue(xs, sr), fi = Bt.end;
                      }
                    }
                    fi = fi || hi !== void 0 ? Ae() : ((ht = Cn != null ? Cn : Bt) !== null && ht !== void 0 ? ht : $r).end, hi || (hi = u(sr, fi, Wr, st));
                    var Hu = r.createJSDocTypedefTag($r, Bt, Cn, hi);
                    return Ue(Hu, sr, fi);
                  }
                  __name(Ml, "Ml");
                  function Au(sr) {
                    var $r = f.getTokenPos();
                    if (!!e.tokenIsIdentifierOrKeyword(L())) {
                      var Wr = mo();
                      if (Xr(24)) {
                        var st = Au(true), ht = r.createModuleDeclaration(void 0, Wr, st, sr ? 4 : void 0);
                        return Ue(ht, $r);
                      }
                      return sr && (Wr.isInJSDocNamespace = true), Wr;
                    }
                  }
                  __name(Au, "Au");
                  function Ll(sr) {
                    for (var $r = Ae(), Wr, st; Wr = Kt(function() {
                      return Lc(4, sr);
                    }); )
                      st = e.append(st, Wr);
                    return vn(st || [], $r);
                  }
                  __name(Ll, "Ll");
                  function Rl(sr, $r, Wr, st) {
                    var ht = Au();
                    ii();
                    var Bt = b(Wr), Cn = Ll(Wr), hi = Kt(function() {
                      if (qo(59)) {
                        var Mi = o(Wr);
                        if (Mi && Mi.kind === 344)
                          return Mi;
                      }
                    }), fi = Ue(r.createJSDocSignature(void 0, Cn, hi), sr);
                    Bt || (Bt = u(sr, Ae(), Wr, st));
                    var Ki = Bt !== void 0 ? Ae() : fi.end;
                    return Ue(r.createJSDocCallbackTag($r, fi, ht, Bt), sr, Ki);
                  }
                  __name(Rl, "Rl");
                  function Wu(sr, $r) {
                    for (; !e.isIdentifier(sr) || !e.isIdentifier($r); )
                      if (!e.isIdentifier(sr) && !e.isIdentifier($r) && sr.right.escapedText === $r.right.escapedText)
                        sr = sr.left, $r = $r.left;
                      else
                        return false;
                    return sr.escapedText === $r.escapedText;
                  }
                  __name(Wu, "Wu");
                  function jl(sr) {
                    return Lc(1, sr);
                  }
                  __name(jl, "jl");
                  function Lc(sr, $r, Wr) {
                    for (var st = true, ht = false; ; )
                      switch (Me()) {
                        case 59:
                          if (st) {
                            var Bt = Jl(sr, $r);
                            return Bt && (Bt.kind === 343 || Bt.kind === 350) && sr !== 4 && Wr && (e.isIdentifier(Bt.name) || !Wu(Wr, Bt.name.left)) ? false : Bt;
                          }
                          ht = false;
                          break;
                        case 4:
                          st = true, ht = false;
                          break;
                        case 41:
                          ht && (st = false), ht = true;
                          break;
                        case 79:
                          st = false;
                          break;
                        case 1:
                          return false;
                      }
                  }
                  __name(Lc, "Lc");
                  function Jl(sr, $r) {
                    e.Debug.assert(L() === 59);
                    var Wr = f.getStartPos();
                    Me();
                    var st = mo();
                    ii();
                    var ht;
                    switch (st.escapedText) {
                      case "type":
                        return sr === 1 && Bu(Wr, st);
                      case "prop":
                      case "property":
                        ht = 1;
                        break;
                      case "arg":
                      case "argument":
                      case "param":
                        ht = 6;
                        break;
                      default:
                        return false;
                    }
                    return sr & ht ? Cs(Wr, st, sr, $r) : false;
                  }
                  __name(Jl, "Jl");
                  function Fl() {
                    var sr = Ae(), $r = qo(22);
                    $r && ii();
                    var Wr = mo(e.Diagnostics.Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces), st;
                    if ($r && (ii(), rr(63), st = En(8388608, ka), rr(23)), !e.nodeIsMissing(Wr))
                      return Ue(r.createTypeParameterDeclaration(void 0, Wr, void 0, st), sr);
                  }
                  __name(Fl, "Fl");
                  function ku() {
                    var sr = Ae(), $r = [];
                    do {
                      ii();
                      var Wr = Fl();
                      Wr !== void 0 && $r.push(Wr), i();
                    } while (qo(27));
                    return vn($r, sr);
                  }
                  __name(ku, "ku");
                  function Ku(sr, $r, Wr, st) {
                    var ht = L() === 18 ? $() : void 0, Bt = ku();
                    return Ue(r.createJSDocTemplateTag($r, ht, Bt, u(sr, Ae(), Wr, st)), sr);
                  }
                  __name(Ku, "Ku");
                  function qo(sr) {
                    return L() === sr ? (Me(), true) : false;
                  }
                  __name(qo, "qo");
                  function Bl() {
                    var sr = mo();
                    for (Xr(22) && rr(23); Xr(24); ) {
                      var $r = mo();
                      Xr(22) && rr(23), sr = qn(sr, $r);
                    }
                    return sr;
                  }
                  __name(Bl, "Bl");
                  function mo(sr) {
                    if (!e.tokenIsIdentifierOrKeyword(L()))
                      return Vn(79, !sr, sr || e.Diagnostics.Identifier_expected);
                    de++;
                    var $r = f.getTokenPos(), Wr = f.getTextPos(), st = L(), ht = Ti(f.getTokenValue()), Bt = Ue(r.createIdentifier(ht, void 0, st), $r, Wr);
                    return Me(), Bt;
                  }
                  __name(mo, "mo");
                }
                __name(Fr, "Fr");
              })(Oc = Z.JSDocParser || (Z.JSDocParser = {}));
            })(he || (he = {}));
            var yr;
            (function(Z) {
              function f(Ie, me, xe, Ye) {
                if (Ye = Ye || e.Debug.shouldAssert(2), r(Ie, me, xe, Ye), e.textChangeRangeIsUnchanged(xe))
                  return Ie;
                if (Ie.statements.length === 0)
                  return he.parseSourceFile(Ie.fileName, me, Ie.languageVersion, void 0, true, Ie.scriptKind, Ie.setExternalModuleIndicator);
                var vr = Ie;
                e.Debug.assert(!vr.hasBeenIncrementallyParsed), vr.hasBeenIncrementallyParsed = true, he.fixupParentReferences(vr);
                var nt = Ie.text, pr = ct(Ie), Mr = Ge(Ie, xe);
                r(Ie, me, Mr, Ye), e.Debug.assert(Mr.span.start <= xe.span.start), e.Debug.assert(e.textSpanEnd(Mr.span) === e.textSpanEnd(xe.span)), e.Debug.assert(e.textSpanEnd(e.textChangeRangeNewSpan(Mr)) === e.textSpanEnd(e.textChangeRangeNewSpan(xe)));
                var ot = e.textChangeRangeNewSpan(Mr).length - Mr.span.length;
                pt(vr, Mr.span.start, e.textSpanEnd(Mr.span), e.textSpanEnd(e.textChangeRangeNewSpan(Mr)), ot, nt, me, Ye);
                var At = he.parseSourceFile(Ie.fileName, me, Ie.languageVersion, pr, true, Ie.scriptKind, Ie.setExternalModuleIndicator);
                return At.commentDirectives = h(Ie.commentDirectives, At.commentDirectives, Mr.span.start, e.textSpanEnd(Mr.span), ot, nt, me, Ye), At.impliedNodeFormat = Ie.impliedNodeFormat, At;
              }
              __name(f, "f");
              Z.updateSourceFile = f;
              function h(Ie, me, xe, Ye, vr, nt, pr, Mr) {
                if (!Ie)
                  return me;
                for (var ot, At = false, re = 0, de = Ie; re < de.length; re++) {
                  var He = de[re], Nr = He.range, Yr = He.type;
                  if (Nr.end < xe)
                    ot = e.append(ot, He);
                  else if (Nr.pos > Ye) {
                    Dt();
                    var St = { range: { pos: Nr.pos + vr, end: Nr.end + vr }, type: Yr };
                    ot = e.append(ot, St), Mr && e.Debug.assert(nt.substring(Nr.pos, Nr.end) === pr.substring(St.range.pos, St.range.end));
                  }
                }
                return Dt(), ot;
                function Dt() {
                  At || (At = true, ot ? me && ot.push.apply(ot, me) : ot = me);
                }
                __name(Dt, "Dt");
              }
              __name(h, "h");
              function ae(Ie, me, xe, Ye, vr, nt) {
                me ? Mr(Ie) : pr(Ie);
                return;
                function pr(ot) {
                  var At = "";
                  if (nt && xr(ot) && (At = Ye.substring(ot.pos, ot.end)), ot._children && (ot._children = void 0), e.setTextRangePosEnd(ot, ot.pos + xe, ot.end + xe), nt && xr(ot) && e.Debug.assert(At === vr.substring(ot.pos, ot.end)), ze(ot, pr, Mr), e.hasJSDocNodes(ot))
                    for (var re = 0, de = ot.jsDoc; re < de.length; re++) {
                      var He = de[re];
                      pr(He);
                    }
                  qr(ot, nt);
                }
                __name(pr, "pr");
                function Mr(ot) {
                  ot._children = void 0, e.setTextRangePosEnd(ot, ot.pos + xe, ot.end + xe);
                  for (var At = 0, re = ot; At < re.length; At++) {
                    var de = re[At];
                    pr(de);
                  }
                }
                __name(Mr, "Mr");
              }
              __name(ae, "ae");
              function xr(Ie) {
                switch (Ie.kind) {
                  case 10:
                  case 8:
                  case 79:
                    return true;
                }
                return false;
              }
              __name(xr, "xr");
              function jr(Ie, me, xe, Ye, vr) {
                e.Debug.assert(Ie.end >= me, "Adjusting an element that was entirely before the change range"), e.Debug.assert(Ie.pos <= xe, "Adjusting an element that was entirely after the change range"), e.Debug.assert(Ie.pos <= Ie.end);
                var nt = Math.min(Ie.pos, Ye), pr = Ie.end >= xe ? Ie.end + vr : Math.min(Ie.end, Ye);
                e.Debug.assert(nt <= pr), Ie.parent && (e.Debug.assertGreaterThanOrEqual(nt, Ie.parent.pos), e.Debug.assertLessThanOrEqual(pr, Ie.parent.end)), e.setTextRangePosEnd(Ie, nt, pr);
              }
              __name(jr, "jr");
              function qr(Ie, me) {
                if (me) {
                  var xe = Ie.pos, Ye = /* @__PURE__ */ __name(function(Mr) {
                    e.Debug.assert(Mr.pos >= xe), xe = Mr.end;
                  }, "Ye");
                  if (e.hasJSDocNodes(Ie))
                    for (var vr = 0, nt = Ie.jsDoc; vr < nt.length; vr++) {
                      var pr = nt[vr];
                      Ye(pr);
                    }
                  ze(Ie, Ye), e.Debug.assert(xe <= Ie.end);
                }
              }
              __name(qr, "qr");
              function pt(Ie, me, xe, Ye, vr, nt, pr, Mr) {
                ot(Ie);
                return;
                function ot(re) {
                  if (e.Debug.assert(re.pos <= re.end), re.pos > xe) {
                    ae(re, false, vr, nt, pr, Mr);
                    return;
                  }
                  var de = re.end;
                  if (de >= me) {
                    if (re.intersectsChange = true, re._children = void 0, jr(re, me, xe, Ye, vr), ze(re, ot, At), e.hasJSDocNodes(re))
                      for (var He = 0, Nr = re.jsDoc; He < Nr.length; He++) {
                        var Yr = Nr[He];
                        ot(Yr);
                      }
                    qr(re, Mr);
                    return;
                  }
                  e.Debug.assert(de < me);
                }
                __name(ot, "ot");
                function At(re) {
                  if (e.Debug.assert(re.pos <= re.end), re.pos > xe) {
                    ae(re, true, vr, nt, pr, Mr);
                    return;
                  }
                  var de = re.end;
                  if (de >= me) {
                    re.intersectsChange = true, re._children = void 0, jr(re, me, xe, Ye, vr);
                    for (var He = 0, Nr = re; He < Nr.length; He++) {
                      var Yr = Nr[He];
                      ot(Yr);
                    }
                    return;
                  }
                  e.Debug.assert(de < me);
                }
                __name(At, "At");
              }
              __name(pt, "pt");
              function Ge(Ie, me) {
                for (var xe = 1, Ye = me.span.start, vr = 0; Ye > 0 && vr <= xe; vr++) {
                  var nt = K(Ie, Ye);
                  e.Debug.assert(nt.pos <= Ye);
                  var pr = nt.pos;
                  Ye = Math.max(0, pr - 1);
                }
                var Mr = e.createTextSpanFromBounds(Ye, e.textSpanEnd(me.span)), ot = me.newLength + (me.span.start - Ye);
                return e.createTextChangeRange(Mr, ot);
              }
              __name(Ge, "Ge");
              function K(Ie, me) {
                var xe = Ie, Ye;
                if (ze(Ie, pr), Ye) {
                  var vr = nt(Ye);
                  vr.pos > xe.pos && (xe = vr);
                }
                return xe;
                function nt(Mr) {
                  for (; ; ) {
                    var ot = e.getLastChild(Mr);
                    if (ot)
                      Mr = ot;
                    else
                      return Mr;
                  }
                }
                __name(nt, "nt");
                function pr(Mr) {
                  if (!e.nodeIsMissing(Mr))
                    if (Mr.pos <= me) {
                      if (Mr.pos >= xe.pos && (xe = Mr), me < Mr.end)
                        return ze(Mr, pr), true;
                      e.Debug.assert(Mr.end <= me), Ye = Mr;
                    } else
                      return e.Debug.assert(Mr.pos > me), true;
                }
                __name(pr, "pr");
              }
              __name(K, "K");
              function r(Ie, me, xe, Ye) {
                var vr = Ie.text;
                if (xe && (e.Debug.assert(vr.length - xe.span.length + xe.newLength === me.length), Ye || e.Debug.shouldAssert(3))) {
                  var nt = vr.substr(0, xe.span.start), pr = me.substr(0, xe.span.start);
                  e.Debug.assert(nt === pr);
                  var Mr = vr.substring(e.textSpanEnd(xe.span), vr.length), ot = me.substring(e.textSpanEnd(e.textChangeRangeNewSpan(xe)), me.length);
                  e.Debug.assert(Mr === ot);
                }
              }
              __name(r, "r");
              function ct(Ie) {
                var me = Ie.statements, xe = 0;
                e.Debug.assert(xe < me.length);
                var Ye = me[xe], vr = -1;
                return { currentNode: function(pr) {
                  return pr !== vr && (Ye && Ye.end === pr && xe < me.length - 1 && (xe++, Ye = me[xe]), (!Ye || Ye.pos !== pr) && nt(pr)), vr = pr, e.Debug.assert(!Ye || Ye.pos === pr), Ye;
                } };
                function nt(pr) {
                  me = void 0, xe = -1, Ye = void 0, ze(Ie, Mr, ot);
                  return;
                  function Mr(At) {
                    return pr >= At.pos && pr < At.end ? (ze(At, Mr, ot), true) : false;
                  }
                  __name(Mr, "Mr");
                  function ot(At) {
                    if (pr >= At.pos && pr < At.end)
                      for (var re = 0; re < At.length; re++) {
                        var de = At[re];
                        if (de) {
                          if (de.pos === pr)
                            return me = At, xe = re, Ye = de, true;
                          if (de.pos < pr && pr < de.end)
                            return ze(de, Mr, ot), true;
                        }
                      }
                    return false;
                  }
                  __name(ot, "ot");
                }
                __name(nt, "nt");
              }
              __name(ct, "ct");
              Z.createSyntaxCursor = ct;
              var ft;
              (function(Ie) {
                Ie[Ie.Value = -1] = "Value";
              })(ft || (ft = {}));
            })(yr || (yr = {}));
            function kr(Z) {
              return e.fileExtensionIsOneOf(Z, e.supportedDeclarationExtensions);
            }
            __name(kr, "kr");
            e.isDeclarationFileName = kr;
            function nr(Z, f, h, ae) {
              if (!!Z) {
                if (Z === "import")
                  return e.ModuleKind.ESNext;
                if (Z === "require")
                  return e.ModuleKind.CommonJS;
                ae(f, h - f, e.Diagnostics.resolution_mode_should_be_either_require_or_import);
              }
            }
            __name(nr, "nr");
            function tr(Z, f) {
              for (var h = [], ae = 0, xr = e.getLeadingCommentRanges(f, 0) || e.emptyArray; ae < xr.length; ae++) {
                var jr = xr[ae], qr = f.substring(jr.pos, jr.end);
                Pr(h, jr, qr);
              }
              Z.pragmas = new e.Map();
              for (var pt = 0, Ge = h; pt < Ge.length; pt++) {
                var K = Ge[pt];
                if (Z.pragmas.has(K.name)) {
                  var r = Z.pragmas.get(K.name);
                  r instanceof Array ? r.push(K.args) : Z.pragmas.set(K.name, [r, K.args]);
                  continue;
                }
                Z.pragmas.set(K.name, K.args);
              }
            }
            __name(tr, "tr");
            e.processCommentPragmas = tr;
            function Lr(Z, f) {
              Z.checkJsDirective = void 0, Z.referencedFiles = [], Z.typeReferenceDirectives = [], Z.libReferenceDirectives = [], Z.amdDependencies = [], Z.hasNoDefaultLib = false, Z.pragmas.forEach(function(h, ae) {
                switch (ae) {
                  case "reference": {
                    var xr = Z.referencedFiles, jr = Z.typeReferenceDirectives, qr = Z.libReferenceDirectives;
                    e.forEach(e.toArray(h), function(r) {
                      var ct = r.arguments, ft = ct.types, Ie = ct.lib, me = ct.path, xe = ct["resolution-mode"];
                      if (r.arguments["no-default-lib"])
                        Z.hasNoDefaultLib = true;
                      else if (ft) {
                        var Ye = nr(xe, ft.pos, ft.end, f);
                        jr.push(T({ pos: ft.pos, end: ft.end, fileName: ft.value }, Ye ? { resolutionMode: Ye } : {}));
                      } else
                        Ie ? qr.push({ pos: Ie.pos, end: Ie.end, fileName: Ie.value }) : me ? xr.push({ pos: me.pos, end: me.end, fileName: me.value }) : f(r.range.pos, r.range.end - r.range.pos, e.Diagnostics.Invalid_reference_directive_syntax);
                    });
                    break;
                  }
                  case "amd-dependency": {
                    Z.amdDependencies = e.map(e.toArray(h), function(r) {
                      return { name: r.arguments.name, path: r.arguments.path };
                    });
                    break;
                  }
                  case "amd-module": {
                    if (h instanceof Array)
                      for (var pt = 0, Ge = h; pt < Ge.length; pt++) {
                        var K = Ge[pt];
                        Z.moduleName && f(K.range.pos, K.range.end - K.range.pos, e.Diagnostics.An_AMD_module_cannot_have_multiple_name_assignments), Z.moduleName = K.arguments.name;
                      }
                    else
                      Z.moduleName = h.arguments.name;
                    break;
                  }
                  case "ts-nocheck":
                  case "ts-check": {
                    e.forEach(e.toArray(h), function(r) {
                      (!Z.checkJsDirective || r.range.pos > Z.checkJsDirective.pos) && (Z.checkJsDirective = { enabled: ae === "ts-check", end: r.range.end, pos: r.range.pos });
                    });
                    break;
                  }
                  case "jsx":
                  case "jsxfrag":
                  case "jsximportsource":
                  case "jsxruntime":
                    return;
                  default:
                    e.Debug.fail("Unhandled pragma kind");
                }
              });
            }
            __name(Lr, "Lr");
            e.processPragmasIntoFields = Lr;
            var zr = new e.Map();
            function ye(Z) {
              if (zr.has(Z))
                return zr.get(Z);
              var f = new RegExp("(\\s".concat(Z, `\\s*=\\s*)(?:(?:'([^']*)')|(?:"([^"]*)"))`), "im");
              return zr.set(Z, f), f;
            }
            __name(ye, "ye");
            var ir = /^\/\/\/\s*<(\S+)\s.*?\/>/im, Dr = /^\/\/\/?\s*@(\S+)\s*(.*)\s*$/im;
            function Pr(Z, f, h) {
              var ae = f.kind === 2 && ir.exec(h);
              if (ae) {
                var xr = ae[1].toLowerCase(), jr = e.commentPragmas[xr];
                if (!jr || !(jr.kind & 1))
                  return;
                if (jr.args) {
                  for (var qr = {}, pt = 0, Ge = jr.args; pt < Ge.length; pt++) {
                    var K = Ge[pt], r = ye(K.name), ct = r.exec(h);
                    if (!ct && !K.optional)
                      return;
                    if (ct) {
                      var ft = ct[2] || ct[3];
                      if (K.captureSpan) {
                        var Ie = f.pos + ct.index + ct[1].length + 1;
                        qr[K.name] = { value: ft, pos: Ie, end: Ie + ft.length };
                      } else
                        qr[K.name] = ft;
                    }
                  }
                  Z.push({ name: xr, args: { arguments: qr, range: f } });
                } else
                  Z.push({ name: xr, args: { arguments: {}, range: f } });
                return;
              }
              var me = f.kind === 2 && Dr.exec(h);
              if (me)
                return Br(Z, f, 2, me);
              if (f.kind === 3)
                for (var xe = /@(\S+)(\s+.*)?$/gim, Ye = void 0; Ye = xe.exec(h); )
                  Br(Z, f, 4, Ye);
            }
            __name(Pr, "Pr");
            function Br(Z, f, h, ae) {
              if (!!ae) {
                var xr = ae[1].toLowerCase(), jr = e.commentPragmas[xr];
                if (!(!jr || !(jr.kind & h))) {
                  var qr = ae[2], pt = ut(jr, qr);
                  pt !== "fail" && Z.push({ name: xr, args: { arguments: pt, range: f } });
                }
              }
            }
            __name(Br, "Br");
            function ut(Z, f) {
              if (!f)
                return {};
              if (!Z.args)
                return {};
              for (var h = e.trimString(f).split(/\s+/), ae = {}, xr = 0; xr < Z.args.length; xr++) {
                var jr = Z.args[xr];
                if (!h[xr] && !jr.optional)
                  return "fail";
                if (jr.captureSpan)
                  return e.Debug.fail("Capture spans not yet implemented for non-xml pragmas");
                ae[jr.name] = h[xr];
              }
              return ae;
            }
            __name(ut, "ut");
            function rt(Z, f) {
              return Z.kind !== f.kind ? false : Z.kind === 79 ? Z.escapedText === f.escapedText : Z.kind === 108 ? true : Z.name.escapedText === f.name.escapedText && rt(Z.expression, f.expression);
            }
            __name(rt, "rt");
            e.tagNamesAreEquivalent = rt;
          })(N || (N = {}));
          var N;
          (function(e) {
            var t;
            (function(B) {
              B[B.NonInstantiated = 0] = "NonInstantiated", B[B.Instantiated = 1] = "Instantiated", B[B.ConstEnumOnly = 2] = "ConstEnumOnly";
            })(t = e.ModuleInstanceState || (e.ModuleInstanceState = {}));
            function x(B, U) {
              return B.body && !B.body.parent && (e.setParent(B.body, B), e.setParentRecursive(B.body, false)), B.body ? s(B.body, U) : 1;
            }
            __name(x, "x");
            e.getModuleInstanceState = x;
            function s(B, U) {
              U === void 0 && (U = new e.Map());
              var m = e.getNodeId(B);
              if (U.has(m))
                return U.get(m) || 0;
              U.set(m, void 0);
              var v = q(B, U);
              return U.set(m, v), v;
            }
            __name(s, "s");
            function q(B, U) {
              switch (B.kind) {
                case 261:
                case 262:
                  return 0;
                case 263:
                  if (e.isEnumConst(B))
                    return 2;
                  break;
                case 269:
                case 268:
                  if (!e.hasSyntacticModifier(B, 1))
                    return 0;
                  break;
                case 275:
                  var m = B;
                  if (!m.moduleSpecifier && m.exportClause && m.exportClause.kind === 276) {
                    for (var v = 0, g = 0, O = m.exportClause.elements; g < O.length; g++) {
                      var S = O[g], te = F(S, U);
                      if (te > v && (v = te), v === 1)
                        return v;
                    }
                    return v;
                  }
                  break;
                case 265: {
                  var Je = 0;
                  return e.forEachChild(B, function(qe) {
                    var ge = s(qe, U);
                    switch (ge) {
                      case 0:
                        return;
                      case 2:
                        Je = 2;
                        return;
                      case 1:
                        return Je = 1, true;
                      default:
                        e.Debug.assertNever(ge);
                    }
                  }), Je;
                }
                case 264:
                  return x(B, U);
                case 79:
                  if (B.isInJSDocNamespace)
                    return 0;
              }
              return 1;
            }
            __name(q, "q");
            function F(B, U) {
              for (var m = B.propertyName || B.name, v = B.parent; v; ) {
                if (e.isBlock(v) || e.isModuleBlock(v) || e.isSourceFile(v)) {
                  for (var g = v.statements, O = void 0, S = 0, te = g; S < te.length; S++) {
                    var Je = te[S];
                    if (e.nodeHasName(Je, m)) {
                      Je.parent || (e.setParent(Je, v), e.setParentRecursive(Je, false));
                      var qe = s(Je, U);
                      if ((O === void 0 || qe > O) && (O = qe), O === 1)
                        return O;
                    }
                  }
                  if (O !== void 0)
                    return O;
                }
                v = v.parent;
              }
              return 1;
            }
            __name(F, "F");
            var fe;
            (function(B) {
              B[B.None = 0] = "None", B[B.IsContainer = 1] = "IsContainer", B[B.IsBlockScopedContainer = 2] = "IsBlockScopedContainer", B[B.IsControlFlowContainer = 4] = "IsControlFlowContainer", B[B.IsFunctionLike = 8] = "IsFunctionLike", B[B.IsFunctionExpression = 16] = "IsFunctionExpression", B[B.HasLocals = 32] = "HasLocals", B[B.IsInterface = 64] = "IsInterface", B[B.IsObjectLiteralOrClassExpressionMethodOrAccessor = 128] = "IsObjectLiteralOrClassExpressionMethodOrAccessor";
            })(fe || (fe = {}));
            function Te(B) {
              return e.Debug.attachFlowNodeDebugInfo(B), B;
            }
            __name(Te, "Te");
            var Se = se();
            function J(B, U) {
              e.performance.mark("beforeBind"), e.perfLogger.logStartBindFile("" + B.fileName), Se(B, U), e.perfLogger.logStopBindFile(), e.performance.mark("afterBind"), e.performance.measure("Bind", "beforeBind", "afterBind");
            }
            __name(J, "J");
            e.bindSourceFile = J;
            function se() {
              var B, U, m, v, g, O, S, te, Je, qe, ge, ie, G, pe, j, be, $e, Re, Fe, dr, ze, ve, er = false, ar = 0, Cr, Ce, Xe = { flags: 1 }, gr = { flags: 1 }, X = hn();
              function Ee(p, ne, Ne, or, it) {
                return e.createDiagnosticForNodeInSourceFile(e.getSourceFileOfNode(p) || B, p, ne, Ne, or, it);
              }
              __name(Ee, "Ee");
              function we(p, ne) {
                B = p, U = ne, m = e.getEmitScriptTarget(U), ve = he(B, ne), Ce = new e.Set(), ar = 0, Cr = e.objectAllocator.getSymbolConstructor(), e.Debug.attachFlowNodeDebugInfo(Xe), e.Debug.attachFlowNodeDebugInfo(gr), B.locals || (e.tracing === null || e.tracing === void 0 || e.tracing.push("bind", "bindSourceFile", { path: B.path }, true), wr(B), e.tracing === null || e.tracing === void 0 || e.tracing.pop(), B.symbolCount = ar, B.classifiableNames = Ce, _r()), B = void 0, U = void 0, m = void 0, v = void 0, g = void 0, O = void 0, S = void 0, te = void 0, Je = void 0, qe = false, ge = void 0, ie = void 0, G = void 0, pe = void 0, j = void 0, be = void 0, $e = void 0, Fe = void 0, dr = false, er = false, ze = 0;
              }
              __name(we, "we");
              return we;
              function he(p, ne) {
                return e.getStrictOptionValue(ne, "alwaysStrict") && !p.isDeclarationFile ? true : !!p.externalModuleIndicator;
              }
              __name(he, "he");
              function yr(p, ne) {
                return ar++, new Cr(p, ne);
              }
              __name(yr, "yr");
              function kr(p, ne, Ne) {
                p.flags |= Ne, ne.symbol = p, p.declarations = e.appendIfUnique(p.declarations, ne), Ne & 1955 && !p.exports && (p.exports = e.createSymbolTable()), Ne & 6240 && !p.members && (p.members = e.createSymbolTable()), p.constEnumOnlyModule && p.flags & 304 && (p.constEnumOnlyModule = false), Ne & 111551 && e.setValueDeclaration(p, ne);
              }
              __name(kr, "kr");
              function nr(p) {
                if (p.kind === 274)
                  return p.isExportEquals ? "export=" : "default";
                var ne = e.getNameOfDeclaration(p);
                if (ne) {
                  if (e.isAmbientModule(p)) {
                    var Ne = e.getTextOfIdentifierOrLiteral(ne);
                    return e.isGlobalScopeAugmentation(p) ? "__global" : '"'.concat(Ne, '"');
                  }
                  if (ne.kind === 164) {
                    var or = ne.expression;
                    if (e.isStringOrNumericLiteralLike(or))
                      return e.escapeLeadingUnderscores(or.text);
                    if (e.isSignedNumericLiteral(or))
                      return e.tokenToString(or.operator) + or.operand.text;
                    e.Debug.fail("Only computed properties with literal names have declaration names");
                  }
                  if (e.isPrivateIdentifier(ne)) {
                    var it = e.getContainingClass(p);
                    if (!it)
                      return;
                    var vt = it.symbol;
                    return e.getSymbolNameForPrivateIdentifier(vt, ne.escapedText);
                  }
                  return e.isPropertyNameLiteral(ne) ? e.getEscapedTextOfIdentifierOrLiteral(ne) : void 0;
                }
                switch (p.kind) {
                  case 173:
                    return "__constructor";
                  case 181:
                  case 176:
                  case 326:
                    return "__call";
                  case 182:
                  case 177:
                    return "__new";
                  case 178:
                    return "__index";
                  case 275:
                    return "__export";
                  case 308:
                    return "export=";
                  case 223:
                    if (e.getAssignmentDeclarationKind(p) === 2)
                      return "export=";
                    e.Debug.fail("Unknown binary declaration kind");
                    break;
                  case 320:
                    return e.isJSDocConstructSignature(p) ? "__new" : "__call";
                  case 166:
                    e.Debug.assert(p.parent.kind === 320, "Impossible parameter parent kind", function() {
                      return "parent is: ".concat(e.Debug.formatSyntaxKind(p.parent.kind), ", expected JSDocFunctionType");
                    });
                    var Et = p.parent, Tt = Et.parameters.indexOf(p);
                    return "arg" + Tt;
                }
              }
              __name(nr, "nr");
              function tr(p) {
                return e.isNamedDeclaration(p) ? e.declarationNameToString(p.name) : e.unescapeLeadingUnderscores(e.Debug.checkDefined(nr(p)));
              }
              __name(tr, "tr");
              function Lr(p, ne, Ne, or, it, vt, Et) {
                e.Debug.assert(Et || !e.hasDynamicName(Ne));
                var Tt = e.hasSyntacticModifier(Ne, 1024) || e.isExportSpecifier(Ne) && Ne.name.escapedText === "default", tn = Et ? "__computed" : Tt && ne ? "default" : nr(Ne), Mt;
                if (tn === void 0)
                  Mt = yr(0, "__missing");
                else if (Mt = p.get(tn), or & 2885600 && Ce.add(tn), !Mt)
                  p.set(tn, Mt = yr(0, tn)), vt && (Mt.isReplaceableByMethod = true);
                else {
                  if (vt && !Mt.isReplaceableByMethod)
                    return Mt;
                  if (Mt.flags & it) {
                    if (Mt.isReplaceableByMethod)
                      p.set(tn, Mt = yr(0, tn));
                    else if (!(or & 3 && Mt.flags & 67108864)) {
                      e.isNamedDeclaration(Ne) && e.setParent(Ne.name, Ne);
                      var $t = Mt.flags & 2 ? e.Diagnostics.Cannot_redeclare_block_scoped_variable_0 : e.Diagnostics.Duplicate_identifier_0, y = true;
                      (Mt.flags & 384 || or & 384) && ($t = e.Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations, y = false);
                      var De = false;
                      e.length(Mt.declarations) && (Tt || Mt.declarations && Mt.declarations.length && Ne.kind === 274 && !Ne.isExportEquals) && ($t = e.Diagnostics.A_module_cannot_have_multiple_default_exports, y = false, De = true);
                      var R = [];
                      e.isTypeAliasDeclaration(Ne) && e.nodeIsMissing(Ne.type) && e.hasSyntacticModifier(Ne, 1) && Mt.flags & 2887656 && R.push(Ee(Ne, e.Diagnostics.Did_you_mean_0, "export type { ".concat(e.unescapeLeadingUnderscores(Ne.name.escapedText), " }")));
                      var Jt = e.getNameOfDeclaration(Ne) || Ne;
                      e.forEach(Mt.declarations, function(qn, Ii) {
                        var ca = e.getNameOfDeclaration(qn) || qn, ji = Ee(ca, $t, y ? tr(qn) : void 0);
                        B.bindDiagnostics.push(De ? e.addRelatedInfo(ji, Ee(Jt, Ii === 0 ? e.Diagnostics.Another_export_default_is_here : e.Diagnostics.and_here)) : ji), De && R.push(Ee(ca, e.Diagnostics.The_first_export_default_is_here));
                      });
                      var Qt = Ee(Jt, $t, y ? tr(Ne) : void 0);
                      B.bindDiagnostics.push(e.addRelatedInfo.apply(void 0, A([Qt], R, false))), Mt = yr(0, tn);
                    }
                  }
                }
                return kr(Mt, Ne, or), Mt.parent ? e.Debug.assert(Mt.parent === ne, "Existing symbol parent should match new one") : Mt.parent = ne, Mt;
              }
              __name(Lr, "Lr");
              function zr(p, ne, Ne) {
                var or = !!(e.getCombinedModifierFlags(p) & 1) || ye(p);
                if (ne & 2097152)
                  return p.kind === 278 || p.kind === 268 && or ? Lr(g.symbol.exports, g.symbol, p, ne, Ne) : Lr(g.locals, void 0, p, ne, Ne);
                if (e.isJSDocTypeAlias(p) && e.Debug.assert(e.isInJSFile(p)), !e.isAmbientModule(p) && (or || g.flags & 64)) {
                  if (!g.locals || e.hasSyntacticModifier(p, 1024) && !nr(p))
                    return Lr(g.symbol.exports, g.symbol, p, ne, Ne);
                  var it = ne & 111551 ? 1048576 : 0, vt = Lr(g.locals, void 0, p, it, Ne);
                  return vt.exportSymbol = Lr(g.symbol.exports, g.symbol, p, ne, Ne), p.localSymbol = vt, vt;
                } else
                  return Lr(g.locals, void 0, p, ne, Ne);
              }
              __name(zr, "zr");
              function ye(p) {
                if (p.parent && e.isModuleDeclaration(p) && (p = p.parent), !e.isJSDocTypeAlias(p))
                  return false;
                if (!e.isJSDocEnumTag(p) && !!p.fullName)
                  return true;
                var ne = e.getNameOfDeclaration(p);
                return ne ? !!(e.isPropertyAccessEntityNameExpression(ne.parent) && jt(ne.parent) || e.isDeclaration(ne.parent) && e.getCombinedModifierFlags(ne.parent) & 1) : false;
              }
              __name(ye, "ye");
              function ir(p, ne) {
                var Ne = g, or = O, it = S;
                if (ne & 1 ? (p.kind !== 216 && (O = g), g = S = p, ne & 32 && (g.locals = e.createSymbolTable()), Fn(g)) : ne & 2 && (S = p, S.locals = void 0), ne & 4) {
                  var vt = ge, Et = ie, Tt = G, tn = pe, Mt = $e, $t = Fe, y = dr, De = ne & 16 && !e.hasSyntacticModifier(p, 512) && !p.asteriskToken && !!e.getImmediatelyInvokedFunctionExpression(p) || p.kind === 172;
                  De || (ge = Te({ flags: 2 }), ne & 144 && (ge.node = p)), pe = De || p.kind === 173 || e.isInJSFile(p) && (p.kind === 259 || p.kind === 215) ? qr() : void 0, $e = void 0, ie = void 0, G = void 0, Fe = void 0, dr = false, ut(p), p.flags &= -2817, !(ge.flags & 1) && ne & 8 && e.nodeIsPresent(p.body) && (p.flags |= 256, dr && (p.flags |= 512), p.endFlowNode = ge), p.kind === 308 && (p.flags |= ze, p.endFlowNode = ge), pe && (r(pe, ge), ge = xe(pe), (p.kind === 173 || p.kind === 172 || e.isInJSFile(p) && (p.kind === 259 || p.kind === 215)) && (p.returnFlowNode = ge)), De || (ge = vt), ie = Et, G = Tt, pe = tn, $e = Mt, Fe = $t, dr = y;
                } else
                  ne & 64 ? (qe = false, ut(p), p.flags = qe ? p.flags | 128 : p.flags & -129) : ut(p);
                g = Ne, O = or, S = it;
              }
              __name(ir, "ir");
              function Dr(p) {
                Pr(p, function(ne) {
                  return ne.kind === 259 ? wr(ne) : void 0;
                }), Pr(p, function(ne) {
                  return ne.kind !== 259 ? wr(ne) : void 0;
                });
              }
              __name(Dr, "Dr");
              function Pr(p, ne) {
                ne === void 0 && (ne = wr), p !== void 0 && e.forEach(p, ne);
              }
              __name(Pr, "Pr");
              function Br(p) {
                e.forEachChild(p, wr, Pr);
              }
              __name(Br, "Br");
              function ut(p) {
                var ne = er;
                if (er = false, Ri(p)) {
                  Br(p), fn(p), er = ne;
                  return;
                }
                switch (p.kind >= 240 && p.kind <= 256 && !U.allowUnreachableCode && (p.flowNode = ge), p.kind) {
                  case 244:
                    de(p);
                    break;
                  case 243:
                    He(p);
                    break;
                  case 245:
                    Nr(p);
                    break;
                  case 246:
                  case 247:
                    Yr(p);
                    break;
                  case 242:
                    St(p);
                    break;
                  case 250:
                  case 254:
                    Dt(p);
                    break;
                  case 249:
                  case 248:
                    Zt(p);
                    break;
                  case 255:
                    mt(p);
                    break;
                  case 252:
                    at(p);
                    break;
                  case 266:
                    k(p);
                    break;
                  case 292:
                    ue(p);
                    break;
                  case 241:
                    Qe(p);
                    break;
                  case 253:
                    Kr(p);
                    break;
                  case 221:
                    cn(p);
                    break;
                  case 222:
                    In(p);
                    break;
                  case 223:
                    if (e.isDestructuringAssignment(p)) {
                      er = ne, yn(p);
                      return;
                    }
                    X(p);
                    break;
                  case 217:
                    ln(p);
                    break;
                  case 224:
                    En(p);
                    break;
                  case 257:
                    ui(p);
                    break;
                  case 208:
                  case 209:
                    si(p);
                    break;
                  case 210:
                    mi(p);
                    break;
                  case 232:
                    Kn(p);
                    break;
                  case 348:
                  case 341:
                  case 342:
                    bi(p);
                    break;
                  case 308: {
                    Dr(p.statements), wr(p.endOfFileToken);
                    break;
                  }
                  case 238:
                  case 265:
                    Dr(p.statements);
                    break;
                  case 205:
                    ei(p);
                    break;
                  case 166:
                    vi(p);
                    break;
                  case 207:
                  case 206:
                  case 299:
                  case 227:
                    er = ne;
                  default:
                    Br(p);
                    break;
                }
                fn(p), er = ne;
              }
              __name(ut, "ut");
              function rt(p) {
                switch (p.kind) {
                  case 79:
                  case 80:
                  case 108:
                  case 208:
                  case 209:
                    return f(p);
                  case 210:
                    return h(p);
                  case 214:
                  case 232:
                    return rt(p.expression);
                  case 223:
                    return xr(p);
                  case 221:
                    return p.operator === 53 && rt(p.operand);
                  case 218:
                    return rt(p.expression);
                }
                return false;
              }
              __name(rt, "rt");
              function Z(p) {
                return e.isDottedName(p) || (e.isPropertyAccessExpression(p) || e.isNonNullExpression(p) || e.isParenthesizedExpression(p)) && Z(p.expression) || e.isBinaryExpression(p) && p.operatorToken.kind === 27 && Z(p.right) || e.isElementAccessExpression(p) && (e.isStringOrNumericLiteralLike(p.argumentExpression) || e.isEntityNameExpression(p.argumentExpression)) && Z(p.expression) || e.isAssignmentExpression(p) && Z(p.left);
              }
              __name(Z, "Z");
              function f(p) {
                return Z(p) || e.isOptionalChain(p) && f(p.expression);
              }
              __name(f, "f");
              function h(p) {
                if (p.arguments)
                  for (var ne = 0, Ne = p.arguments; ne < Ne.length; ne++) {
                    var or = Ne[ne];
                    if (f(or))
                      return true;
                  }
                return !!(p.expression.kind === 208 && f(p.expression.expression));
              }
              __name(h, "h");
              function ae(p, ne) {
                return e.isTypeOfExpression(p) && jr(p.expression) && e.isStringLiteralLike(ne);
              }
              __name(ae, "ae");
              function xr(p) {
                switch (p.operatorToken.kind) {
                  case 63:
                  case 75:
                  case 76:
                  case 77:
                    return f(p.left);
                  case 34:
                  case 35:
                  case 36:
                  case 37:
                    return jr(p.left) || jr(p.right) || ae(p.right, p.left) || ae(p.left, p.right);
                  case 102:
                    return jr(p.left);
                  case 101:
                    return rt(p.right);
                  case 27:
                    return rt(p.right);
                }
                return false;
              }
              __name(xr, "xr");
              function jr(p) {
                switch (p.kind) {
                  case 214:
                    return jr(p.expression);
                  case 223:
                    switch (p.operatorToken.kind) {
                      case 63:
                        return jr(p.left);
                      case 27:
                        return jr(p.right);
                    }
                }
                return f(p);
              }
              __name(jr, "jr");
              function qr() {
                return Te({ flags: 4, antecedents: void 0 });
              }
              __name(qr, "qr");
              function pt() {
                return Te({ flags: 8, antecedents: void 0 });
              }
              __name(pt, "pt");
              function Ge(p, ne, Ne) {
                return Te({ flags: 1024, target: p, antecedents: ne, antecedent: Ne });
              }
              __name(Ge, "Ge");
              function K(p) {
                p.flags |= p.flags & 2048 ? 4096 : 2048;
              }
              __name(K, "K");
              function r(p, ne) {
                !(ne.flags & 1) && !e.contains(p.antecedents, ne) && ((p.antecedents || (p.antecedents = [])).push(ne), K(ne));
              }
              __name(r, "r");
              function ct(p, ne, Ne) {
                return ne.flags & 1 ? ne : Ne ? (Ne.kind === 110 && p & 64 || Ne.kind === 95 && p & 32) && !e.isExpressionOfOptionalChainRoot(Ne) && !e.isNullishCoalesce(Ne.parent) ? Xe : rt(Ne) ? (K(ne), Te({ flags: p, antecedent: ne, node: Ne })) : ne : p & 32 ? ne : Xe;
              }
              __name(ct, "ct");
              function ft(p, ne, Ne, or) {
                return K(p), Te({ flags: 128, antecedent: p, switchStatement: ne, clauseStart: Ne, clauseEnd: or });
              }
              __name(ft, "ft");
              function Ie(p, ne, Ne) {
                K(ne);
                var or = Te({ flags: p, antecedent: ne, node: Ne });
                return $e && r($e, or), or;
              }
              __name(Ie, "Ie");
              function me(p, ne) {
                return K(p), Te({ flags: 512, antecedent: p, node: ne });
              }
              __name(me, "me");
              function xe(p) {
                var ne = p.antecedents;
                return ne ? ne.length === 1 ? ne[0] : p : Xe;
              }
              __name(xe, "xe");
              function Ye(p) {
                var ne = p.parent;
                switch (ne.kind) {
                  case 242:
                  case 244:
                  case 243:
                    return ne.expression === p;
                  case 245:
                  case 224:
                    return ne.condition === p;
                }
                return false;
              }
              __name(Ye, "Ye");
              function vr(p) {
                for (; ; )
                  if (p.kind === 214)
                    p = p.expression;
                  else if (p.kind === 221 && p.operator === 53)
                    p = p.operand;
                  else
                    return p.kind === 223 && (p.operatorToken.kind === 55 || p.operatorToken.kind === 56 || p.operatorToken.kind === 60);
              }
              __name(vr, "vr");
              function nt(p) {
                return p = e.skipParentheses(p), e.isBinaryExpression(p) && e.isLogicalOrCoalescingAssignmentOperator(p.operatorToken.kind);
              }
              __name(nt, "nt");
              function pr(p) {
                for (; e.isParenthesizedExpression(p.parent) || e.isPrefixUnaryExpression(p.parent) && p.parent.operator === 53; )
                  p = p.parent;
                return !Ye(p) && !vr(p.parent) && !(e.isOptionalChain(p.parent) && p.parent.expression === p);
              }
              __name(pr, "pr");
              function Mr(p, ne, Ne, or) {
                var it = j, vt = be;
                j = Ne, be = or, p(ne), j = it, be = vt;
              }
              __name(Mr, "Mr");
              function ot(p, ne, Ne) {
                Mr(wr, p, ne, Ne), (!p || !nt(p) && !vr(p) && !(e.isOptionalChain(p) && e.isOutermostOptionalChain(p))) && (r(ne, ct(32, ge, p)), r(Ne, ct(64, ge, p)));
              }
              __name(ot, "ot");
              function At(p, ne, Ne) {
                var or = ie, it = G;
                ie = ne, G = Ne, wr(p), ie = or, G = it;
              }
              __name(At, "At");
              function re(p, ne) {
                for (var Ne = Fe; Ne && p.parent.kind === 253; )
                  Ne.continueTarget = ne, Ne = Ne.next, p = p.parent;
                return ne;
              }
              __name(re, "re");
              function de(p) {
                var ne = re(p, pt()), Ne = qr(), or = qr();
                r(ne, ge), ge = ne, ot(p.expression, Ne, or), ge = xe(Ne), At(p.statement, or, ne), r(ne, ge), ge = xe(or);
              }
              __name(de, "de");
              function He(p) {
                var ne = pt(), Ne = re(p, qr()), or = qr();
                r(ne, ge), ge = ne, At(p.statement, or, Ne), r(Ne, ge), ge = xe(Ne), ot(p.expression, ne, or), ge = xe(or);
              }
              __name(He, "He");
              function Nr(p) {
                var ne = re(p, pt()), Ne = qr(), or = qr();
                wr(p.initializer), r(ne, ge), ge = ne, ot(p.condition, Ne, or), ge = xe(Ne), At(p.statement, or, ne), wr(p.incrementor), r(ne, ge), ge = xe(or);
              }
              __name(Nr, "Nr");
              function Yr(p) {
                var ne = re(p, pt()), Ne = qr();
                wr(p.expression), r(ne, ge), ge = ne, p.kind === 247 && wr(p.awaitModifier), r(Ne, ge), wr(p.initializer), p.initializer.kind !== 258 && Ct(p.initializer), At(p.statement, Ne, ne), r(ne, ge), ge = xe(Ne);
              }
              __name(Yr, "Yr");
              function St(p) {
                var ne = qr(), Ne = qr(), or = qr();
                ot(p.expression, ne, Ne), ge = xe(ne), wr(p.thenStatement), r(or, ge), ge = xe(Ne), wr(p.elseStatement), r(or, ge), ge = xe(or);
              }
              __name(St, "St");
              function Dt(p) {
                wr(p.expression), p.kind === 250 && (dr = true, pe && r(pe, ge)), ge = Xe;
              }
              __name(Dt, "Dt");
              function Lt(p) {
                for (var ne = Fe; ne; ne = ne.next)
                  if (ne.name === p)
                    return ne;
              }
              __name(Lt, "Lt");
              function zt(p, ne, Ne) {
                var or = p.kind === 249 ? ne : Ne;
                or && (r(or, ge), ge = Xe);
              }
              __name(zt, "zt");
              function Zt(p) {
                if (wr(p.label), p.label) {
                  var ne = Lt(p.label.escapedText);
                  ne && (ne.referenced = true, zt(p, ne.breakTarget, ne.continueTarget));
                } else
                  zt(p, ie, G);
              }
              __name(Zt, "Zt");
              function mt(p) {
                var ne = pe, Ne = $e, or = qr(), it = qr(), vt = qr();
                if (p.finallyBlock && (pe = it), r(vt, ge), $e = vt, wr(p.tryBlock), r(or, ge), p.catchClause && (ge = xe(vt), vt = qr(), r(vt, ge), $e = vt, wr(p.catchClause), r(or, ge)), pe = ne, $e = Ne, p.finallyBlock) {
                  var Et = qr();
                  Et.antecedents = e.concatenate(e.concatenate(or.antecedents, vt.antecedents), it.antecedents), ge = Et, wr(p.finallyBlock), ge.flags & 1 ? ge = Xe : (pe && it.antecedents && r(pe, Ge(Et, it.antecedents, ge)), $e && vt.antecedents && r($e, Ge(Et, vt.antecedents, ge)), ge = or.antecedents ? Ge(Et, or.antecedents, ge) : Xe);
                } else
                  ge = xe(or);
              }
              __name(mt, "mt");
              function at(p) {
                var ne = qr();
                wr(p.expression);
                var Ne = ie, or = Re;
                ie = ne, Re = ge, wr(p.caseBlock), r(ne, ge);
                var it = e.forEach(p.caseBlock.clauses, function(vt) {
                  return vt.kind === 293;
                });
                p.possiblyExhaustive = !it && !ne.antecedents, it || r(ne, ft(Re, p, 0, 0)), ie = Ne, Re = or, ge = xe(ne);
              }
              __name(at, "at");
              function k(p) {
                for (var ne = p.clauses, Ne = rt(p.parent.expression), or = Xe, it = 0; it < ne.length; it++) {
                  for (var vt = it; !ne[it].statements.length && it + 1 < ne.length; )
                    wr(ne[it]), it++;
                  var Et = qr();
                  r(Et, Ne ? ft(Re, p.parent, vt, it + 1) : Re), r(Et, or), ge = xe(Et);
                  var Tt = ne[it];
                  wr(Tt), or = ge, !(ge.flags & 1) && it !== ne.length - 1 && U.noFallthroughCasesInSwitch && (Tt.fallthroughFlowNode = ge);
                }
              }
              __name(k, "k");
              function ue(p) {
                var ne = ge;
                ge = Re, wr(p.expression), ge = ne, Pr(p.statements);
              }
              __name(ue, "ue");
              function Qe(p) {
                wr(p.expression), Sr(p.expression);
              }
              __name(Qe, "Qe");
              function Sr(p) {
                if (p.kind === 210) {
                  var ne = p;
                  ne.expression.kind !== 106 && e.isDottedName(ne.expression) && (ge = me(ge, ne));
                }
              }
              __name(Sr, "Sr");
              function Kr(p) {
                var ne = qr();
                Fe = { next: Fe, name: p.label.escapedText, breakTarget: ne, continueTarget: void 0, referenced: false }, wr(p.label), wr(p.statement), !Fe.referenced && !U.allowUnusedLabels && kn(e.unusedLabelIsError(U), p.label, e.Diagnostics.Unused_label), Fe = Fe.next, r(ne, ge), ge = xe(ne);
              }
              __name(Kr, "Kr");
              function Hr(p) {
                p.kind === 223 && p.operatorToken.kind === 63 ? Ct(p.left) : Ct(p);
              }
              __name(Hr, "Hr");
              function Ct(p) {
                if (Z(p))
                  ge = Ie(16, ge, p);
                else if (p.kind === 206)
                  for (var ne = 0, Ne = p.elements; ne < Ne.length; ne++) {
                    var or = Ne[ne];
                    or.kind === 227 ? Ct(or.expression) : Hr(or);
                  }
                else if (p.kind === 207)
                  for (var it = 0, vt = p.properties; it < vt.length; it++) {
                    var Et = vt[it];
                    Et.kind === 299 ? Hr(Et.initializer) : Et.kind === 300 ? Ct(Et.name) : Et.kind === 301 && Ct(Et.expression);
                  }
              }
              __name(Ct, "Ct");
              function Xt(p, ne, Ne) {
                var or = qr();
                p.operatorToken.kind === 55 || p.operatorToken.kind === 76 ? ot(p.left, or, Ne) : ot(p.left, ne, or), ge = xe(or), wr(p.operatorToken), e.isLogicalOrCoalescingAssignmentOperator(p.operatorToken.kind) ? (Mr(wr, p.right, ne, Ne), Ct(p.left), r(ne, ct(32, ge, p)), r(Ne, ct(64, ge, p))) : ot(p.right, ne, Ne);
              }
              __name(Xt, "Xt");
              function cn(p) {
                if (p.operator === 53) {
                  var ne = j;
                  j = be, be = ne, Br(p), be = j, j = ne;
                } else
                  Br(p), (p.operator === 45 || p.operator === 46) && Ct(p.operand);
              }
              __name(cn, "cn");
              function In(p) {
                Br(p), (p.operator === 45 || p.operator === 46) && Ct(p.operand);
              }
              __name(In, "In");
              function yn(p) {
                er ? (er = false, wr(p.operatorToken), wr(p.right), er = true, wr(p.left)) : (er = true, wr(p.left), er = false, wr(p.operatorToken), wr(p.right)), Ct(p.left);
              }
              __name(yn, "yn");
              function hn() {
                return e.createBinaryExpressionTrampoline(p, ne, Ne, or, it, void 0);
                function p(Et, Tt) {
                  if (Tt) {
                    Tt.stackIndex++, e.setParent(Et, v);
                    var tn = ve;
                    An(Et);
                    var Mt = v;
                    v = Et, Tt.skip = false, Tt.inStrictModeStack[Tt.stackIndex] = tn, Tt.parentStack[Tt.stackIndex] = Mt;
                  } else
                    Tt = { stackIndex: 0, skip: false, inStrictModeStack: [void 0], parentStack: [void 0] };
                  var $t = Et.operatorToken.kind;
                  if ($t === 55 || $t === 56 || $t === 60 || e.isLogicalOrCoalescingAssignmentOperator($t)) {
                    if (pr(Et)) {
                      var y = qr();
                      Xt(Et, y, y), ge = xe(y);
                    } else
                      Xt(Et, j, be);
                    Tt.skip = true;
                  }
                  return Tt;
                }
                __name(p, "p");
                function ne(Et, Tt, tn) {
                  if (!Tt.skip) {
                    var Mt = vt(Et);
                    return tn.operatorToken.kind === 27 && Sr(Et), Mt;
                  }
                }
                __name(ne, "ne");
                function Ne(Et, Tt, tn) {
                  Tt.skip || wr(Et);
                }
                __name(Ne, "Ne");
                function or(Et, Tt, tn) {
                  if (!Tt.skip) {
                    var Mt = vt(Et);
                    return tn.operatorToken.kind === 27 && Sr(Et), Mt;
                  }
                }
                __name(or, "or");
                function it(Et, Tt) {
                  if (!Tt.skip) {
                    var tn = Et.operatorToken.kind;
                    if (e.isAssignmentOperator(tn) && !e.isAssignmentTarget(Et) && (Ct(Et.left), tn === 63 && Et.left.kind === 209)) {
                      var Mt = Et.left;
                      jr(Mt.expression) && (ge = Ie(256, ge, Et));
                    }
                  }
                  var $t = Tt.inStrictModeStack[Tt.stackIndex], y = Tt.parentStack[Tt.stackIndex];
                  $t !== void 0 && (ve = $t), y !== void 0 && (v = y), Tt.skip = false, Tt.stackIndex--;
                }
                __name(it, "it");
                function vt(Et) {
                  if (Et && e.isBinaryExpression(Et) && !e.isDestructuringAssignment(Et))
                    return Et;
                  wr(Et);
                }
                __name(vt, "vt");
              }
              __name(hn, "hn");
              function ln(p) {
                Br(p), p.expression.kind === 208 && Ct(p.expression);
              }
              __name(ln, "ln");
              function En(p) {
                var ne = qr(), Ne = qr(), or = qr();
                ot(p.condition, ne, Ne), ge = xe(ne), wr(p.questionToken), wr(p.whenTrue), r(or, ge), ge = xe(Ne), wr(p.colonToken), wr(p.whenFalse), r(or, ge), ge = xe(or);
              }
              __name(En, "En");
              function Vt(p) {
                var ne = e.isOmittedExpression(p) ? void 0 : p.name;
                if (e.isBindingPattern(ne))
                  for (var Ne = 0, or = ne.elements; Ne < or.length; Ne++) {
                    var it = or[Ne];
                    Vt(it);
                  }
                else
                  ge = Ie(16, ge, p);
              }
              __name(Vt, "Vt");
              function ui(p) {
                Br(p), (p.initializer || e.isForInOrOfStatement(p.parent.parent)) && Vt(p);
              }
              __name(ui, "ui");
              function ei(p) {
                wr(p.dotDotDotToken), wr(p.propertyName), ri(p.initializer), wr(p.name);
              }
              __name(ei, "ei");
              function vi(p) {
                Pr(p.modifiers), wr(p.dotDotDotToken), wr(p.questionToken), wr(p.type), ri(p.initializer), wr(p.name);
              }
              __name(vi, "vi");
              function ri(p) {
                if (!!p) {
                  var ne = ge;
                  if (wr(p), !(ne === Xe || ne === ge)) {
                    var Ne = qr();
                    r(Ne, ne), r(Ne, ge), ge = xe(Ne);
                  }
                }
              }
              __name(ri, "ri");
              function bi(p) {
                wr(p.tagName), p.kind !== 342 && p.fullName && (e.setParent(p.fullName, p), e.setParentRecursive(p.fullName, false)), typeof p.comment != "string" && Pr(p.comment);
              }
              __name(bi, "bi");
              function Qn(p) {
                Br(p);
                var ne = e.getHostSignatureFromJSDoc(p);
                ne && ne.kind !== 171 && kr(ne.symbol, ne, 32);
              }
              __name(Qn, "Qn");
              function Yn(p, ne, Ne) {
                Mr(wr, p, ne, Ne), (!e.isOptionalChain(p) || e.isOutermostOptionalChain(p)) && (r(ne, ct(32, ge, p)), r(Ne, ct(64, ge, p)));
              }
              __name(Yn, "Yn");
              function oi(p) {
                switch (p.kind) {
                  case 208:
                    wr(p.questionDotToken), wr(p.name);
                    break;
                  case 209:
                    wr(p.questionDotToken), wr(p.argumentExpression);
                    break;
                  case 210:
                    wr(p.questionDotToken), Pr(p.typeArguments), Pr(p.arguments);
                    break;
                }
              }
              __name(oi, "oi");
              function Ei(p, ne, Ne) {
                var or = e.isOptionalChainRoot(p) ? qr() : void 0;
                Yn(p.expression, or || ne, Ne), or && (ge = xe(or)), Mr(oi, p, ne, Ne), e.isOutermostOptionalChain(p) && (r(ne, ct(32, ge, p)), r(Ne, ct(64, ge, p)));
              }
              __name(Ei, "Ei");
              function Dn(p) {
                if (pr(p)) {
                  var ne = qr();
                  Ei(p, ne, ne), ge = xe(ne);
                } else
                  Ei(p, j, be);
              }
              __name(Dn, "Dn");
              function Kn(p) {
                e.isOptionalChain(p) ? Dn(p) : Br(p);
              }
              __name(Kn, "Kn");
              function si(p) {
                e.isOptionalChain(p) ? Dn(p) : Br(p);
              }
              __name(si, "si");
              function mi(p) {
                if (e.isOptionalChain(p))
                  Dn(p);
                else {
                  var ne = e.skipParentheses(p.expression);
                  ne.kind === 215 || ne.kind === 216 ? (Pr(p.typeArguments), Pr(p.arguments), wr(p.expression)) : (Br(p), p.expression.kind === 106 && (ge = me(ge, p)));
                }
                if (p.expression.kind === 208) {
                  var Ne = p.expression;
                  e.isIdentifier(Ne.name) && jr(Ne.expression) && e.isPushOrUnshiftIdentifier(Ne.name) && (ge = Ie(256, ge, p));
                }
              }
              __name(mi, "mi");
              function Zn(p) {
                switch (p.kind) {
                  case 228:
                  case 260:
                  case 263:
                  case 207:
                  case 184:
                  case 325:
                  case 289:
                    return 1;
                  case 261:
                    return 65;
                  case 264:
                  case 262:
                  case 197:
                  case 178:
                    return 33;
                  case 308:
                    return 37;
                  case 174:
                  case 175:
                  case 171:
                    if (e.isObjectLiteralOrClassExpressionMethodOrAccessor(p))
                      return 173;
                  case 173:
                  case 259:
                  case 170:
                  case 176:
                  case 326:
                  case 320:
                  case 181:
                  case 177:
                  case 182:
                  case 172:
                    return 45;
                  case 215:
                  case 216:
                    return 61;
                  case 265:
                    return 4;
                  case 169:
                    return p.initializer ? 4 : 0;
                  case 295:
                  case 245:
                  case 246:
                  case 247:
                  case 266:
                    return 2;
                  case 238:
                    return e.isFunctionLike(p.parent) || e.isClassStaticBlockDeclaration(p.parent) ? 0 : 2;
                }
                return 0;
              }
              __name(Zn, "Zn");
              function Fn(p) {
                te && (te.nextContainer = p), te = p;
              }
              __name(Fn, "Fn");
              function gt(p, ne, Ne) {
                switch (g.kind) {
                  case 264:
                    return zr(p, ne, Ne);
                  case 308:
                    return dn(p, ne, Ne);
                  case 228:
                  case 260:
                    return gi(p, ne, Ne);
                  case 263:
                    return Lr(g.symbol.exports, g.symbol, p, ne, Ne);
                  case 184:
                  case 325:
                  case 207:
                  case 261:
                  case 289:
                    return Lr(g.symbol.members, g.symbol, p, ne, Ne);
                  case 181:
                  case 182:
                  case 176:
                  case 177:
                  case 326:
                  case 178:
                  case 171:
                  case 170:
                  case 173:
                  case 174:
                  case 175:
                  case 259:
                  case 215:
                  case 216:
                  case 320:
                  case 348:
                  case 341:
                  case 172:
                  case 262:
                  case 197:
                    return Lr(g.locals, void 0, p, ne, Ne);
                }
              }
              __name(gt, "gt");
              function gi(p, ne, Ne) {
                return e.isStatic(p) ? Lr(g.symbol.exports, g.symbol, p, ne, Ne) : Lr(g.symbol.members, g.symbol, p, ne, Ne);
              }
              __name(gi, "gi");
              function dn(p, ne, Ne) {
                return e.isExternalModule(B) ? zr(p, ne, Ne) : Lr(B.locals, void 0, p, ne, Ne);
              }
              __name(dn, "dn");
              function On(p) {
                var ne = e.isSourceFile(p) ? p : e.tryCast(p.body, e.isModuleBlock);
                return !!ne && ne.statements.some(function(Ne) {
                  return e.isExportDeclaration(Ne) || e.isExportAssignment(Ne);
                });
              }
              __name(On, "On");
              function br(p) {
                p.flags & 16777216 && !On(p) ? p.flags |= 64 : p.flags &= -65;
              }
              __name(br, "br");
              function Ae(p) {
                if (br(p), e.isAmbientModule(p))
                  if (e.hasSyntacticModifier(p, 1) && Rn(p, e.Diagnostics.export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible), e.isModuleAugmentationExternal(p))
                    ur(p);
                  else {
                    var ne = void 0;
                    if (p.name.kind === 10) {
                      var Ne = p.name.text;
                      ne = e.tryParsePattern(Ne), ne === void 0 && Rn(p.name, e.Diagnostics.Pattern_0_can_have_at_most_one_Asterisk_character, Ne);
                    }
                    var or = gt(p, 512, 110735);
                    B.patternAmbientModules = e.append(B.patternAmbientModules, ne && !e.isString(ne) ? { pattern: ne, symbol: or } : void 0);
                  }
                else {
                  var it = ur(p);
                  if (it !== 0) {
                    var or = p.symbol;
                    or.constEnumOnlyModule = !(or.flags & 304) && it === 2 && or.constEnumOnlyModule !== false;
                  }
                }
              }
              __name(Ae, "Ae");
              function ur(p) {
                var ne = x(p), Ne = ne !== 0;
                return gt(p, Ne ? 512 : 1024, Ne ? 110735 : 0), ne;
              }
              __name(ur, "ur");
              function L(p) {
                var ne = yr(131072, nr(p));
                kr(ne, p, 131072);
                var Ne = yr(2048, "__type");
                kr(Ne, p, 2048), Ne.members = e.createSymbolTable(), Ne.members.set(ne.escapedName, ne);
              }
              __name(L, "L");
              function qt(p) {
                return Me(p, 4096, "__object");
              }
              __name(qt, "qt");
              function nn(p) {
                return Me(p, 4096, "__jsxAttributes");
              }
              __name(nn, "nn");
              function fr(p, ne, Ne) {
                return gt(p, ne, Ne);
              }
              __name(fr, "fr");
              function Me(p, ne, Ne) {
                var or = yr(ne, Ne);
                return ne & 106508 && (or.parent = g.symbol), kr(or, p, ne), or;
              }
              __name(Me, "Me");
              function Ve(p, ne, Ne) {
                switch (S.kind) {
                  case 264:
                    zr(p, ne, Ne);
                    break;
                  case 308:
                    if (e.isExternalOrCommonJsModule(g)) {
                      zr(p, ne, Ne);
                      break;
                    }
                  default:
                    S.locals || (S.locals = e.createSymbolTable(), Fn(S)), Lr(S.locals, void 0, p, ne, Ne);
                }
              }
              __name(Ve, "Ve");
              function _r() {
                if (!!Je) {
                  for (var p = g, ne = te, Ne = S, or = v, it = ge, vt = 0, Et = Je; vt < Et.length; vt++) {
                    var Tt = Et[vt], tn = Tt.parent.parent;
                    g = e.findAncestor(tn.parent, function(De) {
                      return !!(Zn(De) & 1);
                    }) || B, S = e.getEnclosingBlockScopeContainer(tn) || B, ge = Te({ flags: 2 }), v = Tt, wr(Tt.typeExpression);
                    var Mt = e.getNameOfDeclaration(Tt);
                    if ((e.isJSDocEnumTag(Tt) || !Tt.fullName) && Mt && e.isPropertyAccessEntityNameExpression(Mt.parent)) {
                      var $t = jt(Mt.parent);
                      if ($t) {
                        Pt(B.symbol, Mt.parent, $t, !!e.findAncestor(Mt, function(De) {
                          return e.isPropertyAccessExpression(De) && De.name.escapedText === "prototype";
                        }), false);
                        var y = g;
                        switch (e.getAssignmentDeclarationPropertyAccessKind(Mt.parent)) {
                          case 1:
                          case 2:
                            e.isExternalOrCommonJsModule(B) ? g = B : g = void 0;
                            break;
                          case 4:
                            g = Mt.parent.expression;
                            break;
                          case 3:
                            g = Mt.parent.expression.name;
                            break;
                          case 5:
                            g = je(B, Mt.parent.expression) ? B : e.isPropertyAccessExpression(Mt.parent.expression) ? Mt.parent.expression.name : Mt.parent.expression;
                            break;
                          case 0:
                            return e.Debug.fail("Shouldn't have detected typedef or enum on non-assignment declaration");
                        }
                        g && zr(Tt, 524288, 788968), g = y;
                      }
                    } else
                      e.isJSDocEnumTag(Tt) || !Tt.fullName || Tt.fullName.kind === 79 ? (v = Tt.parent, Ve(Tt, 524288, 788968)) : wr(Tt.fullName);
                  }
                  g = p, te = ne, S = Ne, v = or, ge = it;
                }
              }
              __name(_r, "_r");
              function lr(p) {
                !B.parseDiagnostics.length && !(p.flags & 16777216) && !(p.flags & 8388608) && !e.isIdentifierName(p) && (ve && p.originalKeywordKind >= 117 && p.originalKeywordKind <= 125 ? B.bindDiagnostics.push(Ee(p, Vr(p), e.declarationNameToString(p))) : p.originalKeywordKind === 133 ? e.isExternalModule(B) && e.isInTopLevelContext(p) ? B.bindDiagnostics.push(Ee(p, e.Diagnostics.Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module, e.declarationNameToString(p))) : p.flags & 32768 && B.bindDiagnostics.push(Ee(p, e.Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here, e.declarationNameToString(p))) : p.originalKeywordKind === 125 && p.flags & 8192 && B.bindDiagnostics.push(Ee(p, e.Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here, e.declarationNameToString(p))));
              }
              __name(lr, "lr");
              function Vr(p) {
                return e.getContainingClass(p) ? e.Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode : B.externalModuleIndicator ? e.Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode : e.Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode;
              }
              __name(Vr, "Vr");
              function tt(p) {
                p.escapedText === "#constructor" && (B.parseDiagnostics.length || B.bindDiagnostics.push(Ee(p, e.Diagnostics.constructor_is_a_reserved_word, e.declarationNameToString(p))));
              }
              __name(tt, "tt");
              function dt(p) {
                ve && e.isLeftHandSideExpression(p.left) && e.isAssignmentOperator(p.operatorToken.kind) && _e(p, p.left);
              }
              __name(dt, "dt");
              function It(p) {
                ve && p.variableDeclaration && _e(p, p.variableDeclaration.name);
              }
              __name(It, "It");
              function an(p) {
                if (ve && p.expression.kind === 79) {
                  var ne = e.getErrorSpanForNode(B, p.expression);
                  B.bindDiagnostics.push(e.createFileDiagnostic(B, ne.start, ne.length, e.Diagnostics.delete_cannot_be_called_on_an_identifier_in_strict_mode));
                }
              }
              __name(an, "an");
              function sn(p) {
                return e.isIdentifier(p) && (p.escapedText === "eval" || p.escapedText === "arguments");
              }
              __name(sn, "sn");
              function _e(p, ne) {
                if (ne && ne.kind === 79) {
                  var Ne = ne;
                  if (sn(Ne)) {
                    var or = e.getErrorSpanForNode(B, ne);
                    B.bindDiagnostics.push(e.createFileDiagnostic(B, or.start, or.length, Gr(p), e.idText(Ne)));
                  }
                }
              }
              __name(_e, "_e");
              function Gr(p) {
                return e.getContainingClass(p) ? e.Diagnostics.Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of_0_For_more_information_see_https_Colon_Slash_Slashdeveloper_mozilla_org_Slashen_US_Slashdocs_SlashWeb_SlashJavaScript_SlashReference_SlashStrict_mode : B.externalModuleIndicator ? e.Diagnostics.Invalid_use_of_0_Modules_are_automatically_in_strict_mode : e.Diagnostics.Invalid_use_of_0_in_strict_mode;
              }
              __name(Gr, "Gr");
              function Kt(p) {
                ve && _e(p, p.name);
              }
              __name(Kt, "Kt");
              function en(p) {
                return e.getContainingClass(p) ? e.Diagnostics.Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_definitions_are_automatically_in_strict_mode : B.externalModuleIndicator ? e.Diagnostics.Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_are_automatically_in_strict_mode : e.Diagnostics.Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5;
              }
              __name(en, "en");
              function Ot(p) {
                if (m < 2 && S.kind !== 308 && S.kind !== 264 && !e.isFunctionLikeOrClassStaticBlockDeclaration(S)) {
                  var ne = e.getErrorSpanForNode(B, p);
                  B.bindDiagnostics.push(e.createFileDiagnostic(B, ne.start, ne.length, en(p)));
                }
              }
              __name(Ot, "Ot");
              function rr(p) {
                m < 1 && ve && p.numericLiteralFlags & 32 && B.bindDiagnostics.push(Ee(p, e.Diagnostics.Octal_literals_are_not_allowed_in_strict_mode));
              }
              __name(rr, "rr");
              function Hn(p) {
                ve && _e(p, p.operand);
              }
              __name(Hn, "Hn");
              function rn(p) {
                ve && (p.operator === 45 || p.operator === 46) && _e(p, p.operand);
              }
              __name(rn, "rn");
              function xn(p) {
                ve && Rn(p, e.Diagnostics.with_statements_are_not_allowed_in_strict_mode);
              }
              __name(xn, "xn");
              function Mn(p) {
                ve && e.getEmitScriptTarget(U) >= 2 && (e.isDeclarationStatement(p.statement) || e.isVariableStatement(p.statement)) && Rn(p.label, e.Diagnostics.A_label_is_not_allowed_here);
              }
              __name(Mn, "Mn");
              function Rn(p, ne, Ne, or, it) {
                var vt = e.getSpanOfTokenAtPosition(B, p.pos);
                B.bindDiagnostics.push(e.createFileDiagnostic(B, vt.start, vt.length, ne, Ne, or, it));
              }
              __name(Rn, "Rn");
              function kn(p, ne, Ne) {
                on(p, ne, ne, Ne);
              }
              __name(kn, "kn");
              function on(p, ne, Ne, or) {
                Xr(p, { pos: e.getTokenPosOfNode(ne, B), end: Ne.end }, or);
              }
              __name(on, "on");
              function Xr(p, ne, Ne) {
                var or = e.createFileDiagnostic(B, ne.pos, ne.end - ne.pos, Ne);
                p ? B.bindDiagnostics.push(or) : B.bindSuggestionDiagnostics = e.append(B.bindSuggestionDiagnostics, T(T({}, or), { category: e.DiagnosticCategory.Suggestion }));
              }
              __name(Xr, "Xr");
              function wr(p) {
                if (!!p) {
                  e.setParent(p, v), e.tracing && (p.tracingPath = B.path);
                  var ne = ve;
                  if (An(p), p.kind > 162) {
                    var Ne = v;
                    v = p;
                    var or = Zn(p);
                    or === 0 ? ut(p) : ir(p, or), v = Ne;
                  } else {
                    var Ne = v;
                    p.kind === 1 && (v = p), fn(p), v = Ne;
                  }
                  ve = ne;
                }
              }
              __name(wr, "wr");
              function fn(p) {
                if (e.hasJSDocNodes(p))
                  if (e.isInJSFile(p))
                    for (var ne = 0, Ne = p.jsDoc; ne < Ne.length; ne++) {
                      var or = Ne[ne];
                      wr(or);
                    }
                  else
                    for (var it = 0, vt = p.jsDoc; it < vt.length; it++) {
                      var or = vt[it];
                      e.setParent(or, p), e.setParentRecursive(or, false);
                    }
              }
              __name(fn, "fn");
              function mn(p) {
                if (!ve)
                  for (var ne = 0, Ne = p; ne < Ne.length; ne++) {
                    var or = Ne[ne];
                    if (!e.isPrologueDirective(or))
                      return;
                    if (Li(or)) {
                      ve = true;
                      return;
                    }
                  }
              }
              __name(mn, "mn");
              function Li(p) {
                var ne = e.getSourceTextOfNodeFromSourceFile(B, p.expression);
                return ne === '"use strict"' || ne === "'use strict'";
              }
              __name(Li, "Li");
              function An(p) {
                switch (p.kind) {
                  case 79:
                    if (p.isInJSDocNamespace) {
                      for (var ne = p.parent; ne && !e.isJSDocTypeAlias(ne); )
                        ne = ne.parent;
                      Ve(ne, 524288, 788968);
                      break;
                    }
                  case 108:
                    return ge && (e.isExpression(p) || v.kind === 300) && (p.flowNode = ge), lr(p);
                  case 163:
                    ge && e.isPartOfTypeQuery(p) && (p.flowNode = ge);
                    break;
                  case 233:
                  case 106:
                    p.flowNode = ge;
                    break;
                  case 80:
                    return tt(p);
                  case 208:
                  case 209:
                    var Ne = p;
                    ge && Z(Ne) && (Ne.flowNode = ge), e.isSpecialPropertyDeclaration(Ne) && ee(Ne), e.isInJSFile(Ne) && B.commonJsModuleIndicator && e.isModuleExportsAccessExpression(Ne) && !W(S, "module") && Lr(B.locals, void 0, Ne.expression, 134217729, 111550);
                    break;
                  case 223:
                    var or = e.getAssignmentDeclarationKind(p);
                    switch (or) {
                      case 1:
                        Tn(p);
                        break;
                      case 2:
                        jn(p);
                        break;
                      case 3:
                        Ir(p.left, p);
                        break;
                      case 6:
                        le(p);
                        break;
                      case 4:
                        Ci(p);
                        break;
                      case 5:
                        var it = p.left.expression;
                        if (e.isInJSFile(p) && e.isIdentifier(it)) {
                          var vt = W(S, it.escapedText);
                          if (e.isThisInitializedDeclaration(vt == null ? void 0 : vt.valueDeclaration)) {
                            Ci(p);
                            break;
                          }
                        }
                        hr(p);
                        break;
                      case 0:
                        break;
                      default:
                        e.Debug.fail("Unknown binary expression special property assignment kind");
                    }
                    return dt(p);
                  case 295:
                    return It(p);
                  case 217:
                    return an(p);
                  case 8:
                    return rr(p);
                  case 222:
                    return Hn(p);
                  case 221:
                    return rn(p);
                  case 251:
                    return xn(p);
                  case 253:
                    return Mn(p);
                  case 194:
                    qe = true;
                    return;
                  case 179:
                    break;
                  case 165:
                    return $i(p);
                  case 166:
                    return Gi(p);
                  case 257:
                    return Ui(p);
                  case 205:
                    return p.flowNode = ge, Ui(p);
                  case 169:
                  case 168:
                    return wi(p);
                  case 299:
                  case 300:
                    return Jn(p, 4, 0);
                  case 302:
                    return Jn(p, 8, 900095);
                  case 176:
                  case 177:
                  case 178:
                    return gt(p, 131072, 0);
                  case 171:
                  case 170:
                    return Jn(p, 8192 | (p.questionToken ? 16777216 : 0), e.isObjectLiteralMethod(p) ? 0 : 103359);
                  case 259:
                    return Xi(p);
                  case 173:
                    return gt(p, 16384, 0);
                  case 174:
                    return Jn(p, 32768, 46015);
                  case 175:
                    return Jn(p, 65536, 78783);
                  case 181:
                  case 320:
                  case 326:
                  case 182:
                    return L(p);
                  case 184:
                  case 325:
                  case 197:
                    return ti(p);
                  case 335:
                    return Qn(p);
                  case 207:
                    return qt(p);
                  case 215:
                  case 216:
                    return ma(p);
                  case 210:
                    var Et = e.getAssignmentDeclarationKind(p);
                    switch (Et) {
                      case 7:
                        return Ar(p);
                      case 8:
                        return Bi(p);
                      case 9:
                        return Ze(p);
                      case 0:
                        break;
                      default:
                        return e.Debug.fail("Unknown call expression assignment declaration kind");
                    }
                    e.isInJSFile(p) && sa(p);
                    break;
                  case 228:
                  case 260:
                    return ve = true, ea(p);
                  case 261:
                    return Ve(p, 64, 788872);
                  case 262:
                    return Ve(p, 524288, 788968);
                  case 263:
                    return Hi(p);
                  case 264:
                    return Ae(p);
                  case 289:
                    return nn(p);
                  case 288:
                    return fr(p, 4, 0);
                  case 268:
                  case 271:
                  case 273:
                  case 278:
                    return gt(p, 2097152, 2097152);
                  case 267:
                    return Ue(p);
                  case 270:
                    return Ti(p);
                  case 275:
                    return Vn(p);
                  case 274:
                    return vn(p);
                  case 308:
                    return mn(p.statements), li();
                  case 238:
                    if (!e.isFunctionLikeOrClassStaticBlockDeclaration(p.parent))
                      return;
                  case 265:
                    return mn(p.statements);
                  case 343:
                    if (p.parent.kind === 326)
                      return Gi(p);
                    if (p.parent.kind !== 325)
                      break;
                  case 350:
                    var Tt = p, tn = Tt.isBracketed || Tt.typeExpression && Tt.typeExpression.type.kind === 319 ? 16777220 : 4;
                    return gt(Tt, tn, 0);
                  case 348:
                  case 341:
                  case 342:
                    return (Je || (Je = [])).push(p);
                }
              }
              __name(An, "An");
              function wi(p) {
                var ne = e.isAutoAccessorPropertyDeclaration(p), Ne = ne ? 98304 : 4, or = ne ? 13247 : 0;
                return Jn(p, Ne | (p.questionToken ? 16777216 : 0), or);
              }
              __name(wi, "wi");
              function ti(p) {
                return Me(p, 2048, "__type");
              }
              __name(ti, "ti");
              function li() {
                if (br(B), e.isExternalModule(B))
                  Bn();
                else if (e.isJsonSourceFile(B)) {
                  Bn();
                  var p = B.symbol;
                  Lr(B.symbol.exports, B.symbol, B, 4, 67108863), B.symbol = p;
                }
              }
              __name(li, "li");
              function Bn() {
                Me(B, 512, '"'.concat(e.removeFileExtension(B.fileName), '"'));
              }
              __name(Bn, "Bn");
              function vn(p) {
                if (!g.symbol || !g.symbol.exports)
                  Me(p, 111551, nr(p));
                else {
                  var ne = e.exportAssignmentIsAlias(p) ? 2097152 : 4, Ne = Lr(g.symbol.exports, g.symbol, p, ne, 67108863);
                  p.isExportEquals && e.setValueDeclaration(Ne, p);
                }
              }
              __name(vn, "vn");
              function Ue(p) {
                e.some(p.modifiers) && B.bindDiagnostics.push(Ee(p, e.Diagnostics.Modifiers_cannot_appear_here));
                var ne = e.isSourceFile(p.parent) ? e.isExternalModule(p.parent) ? p.parent.isDeclarationFile ? void 0 : e.Diagnostics.Global_module_exports_may_only_appear_in_declaration_files : e.Diagnostics.Global_module_exports_may_only_appear_in_module_files : e.Diagnostics.Global_module_exports_may_only_appear_at_top_level;
                ne ? B.bindDiagnostics.push(Ee(p, ne)) : (B.symbol.globalExports = B.symbol.globalExports || e.createSymbolTable(), Lr(B.symbol.globalExports, B.symbol, p, 2097152, 2097152));
              }
              __name(Ue, "Ue");
              function Vn(p) {
                !g.symbol || !g.symbol.exports ? Me(p, 8388608, nr(p)) : p.exportClause ? e.isNamespaceExport(p.exportClause) && (e.setParent(p.exportClause, p), Lr(g.symbol.exports, g.symbol, p.exportClause, 2097152, 2097152)) : Lr(g.symbol.exports, g.symbol, p, 8388608, 0);
              }
              __name(Vn, "Vn");
              function Ti(p) {
                p.name && gt(p, 2097152, 2097152);
              }
              __name(Ti, "Ti");
              function ni(p) {
                return B.externalModuleIndicator && B.externalModuleIndicator !== true ? false : (B.commonJsModuleIndicator || (B.commonJsModuleIndicator = p, B.externalModuleIndicator || Bn()), true);
              }
              __name(ni, "ni");
              function Bi(p) {
                if (!!ni(p)) {
                  var ne = qi(p.arguments[0], void 0, function(or, it) {
                    return it && kr(it, or, 67110400), it;
                  });
                  if (ne) {
                    var Ne = 1048580;
                    Lr(ne.exports, ne, p, Ne, 0);
                  }
                }
              }
              __name(Bi, "Bi");
              function Tn(p) {
                if (!!ni(p)) {
                  var ne = qi(p.left.expression, void 0, function(it, vt) {
                    return vt && kr(vt, it, 67110400), vt;
                  });
                  if (ne) {
                    var Ne = e.isAliasableExpression(p.right) && (e.isExportsIdentifier(p.left.expression) || e.isModuleExportsAccessExpression(p.left.expression)), or = Ne ? 2097152 : 1048580;
                    e.setParent(p.left, p), Lr(ne.exports, ne, p.left, or, 0);
                  }
                }
              }
              __name(Tn, "Tn");
              function jn(p) {
                if (!!ni(p)) {
                  var ne = e.getRightMostAssignedExpression(p.right);
                  if (!(e.isEmptyObjectLiteral(ne) || g === B && je(B, ne))) {
                    if (e.isObjectLiteralExpression(ne) && e.every(ne.properties, e.isShorthandPropertyAssignment)) {
                      e.forEach(ne.properties, Si);
                      return;
                    }
                    var Ne = e.exportAssignmentIsAlias(p) ? 2097152 : 1049092, or = Lr(B.symbol.exports, B.symbol, p, Ne | 67108864, 0);
                    e.setValueDeclaration(or, p);
                  }
                }
              }
              __name(jn, "jn");
              function Si(p) {
                Lr(B.symbol.exports, B.symbol, p, 69206016, 0);
              }
              __name(Si, "Si");
              function Ci(p) {
                e.Debug.assert(e.isInJSFile(p));
                var ne = e.isBinaryExpression(p) && e.isPropertyAccessExpression(p.left) && e.isPrivateIdentifier(p.left.name) || e.isPropertyAccessExpression(p) && e.isPrivateIdentifier(p.name);
                if (!ne) {
                  var Ne = e.getThisContainer(p, false);
                  switch (Ne.kind) {
                    case 259:
                    case 215:
                      var or = Ne.symbol;
                      if (e.isBinaryExpression(Ne.parent) && Ne.parent.operatorToken.kind === 63) {
                        var it = Ne.parent.left;
                        e.isBindableStaticAccessExpression(it) && e.isPrototypeAccess(it.expression) && (or = Gn(it.expression.expression, O));
                      }
                      or && or.valueDeclaration && (or.members = or.members || e.createSymbolTable(), e.hasDynamicName(p) ? C(p, or, or.members) : Lr(or.members, or, p, 67108868, 0), kr(or, or.valueDeclaration, 32));
                      break;
                    case 173:
                    case 169:
                    case 171:
                    case 174:
                    case 175:
                    case 172:
                      var vt = Ne.parent, Et = e.isStatic(Ne) ? vt.symbol.exports : vt.symbol.members;
                      e.hasDynamicName(p) ? C(p, vt.symbol, Et) : Lr(Et, vt.symbol, p, 67108868, 0, true);
                      break;
                    case 308:
                      if (e.hasDynamicName(p))
                        break;
                      Ne.commonJsModuleIndicator ? Lr(Ne.symbol.exports, Ne.symbol, p, 1048580, 0) : gt(p, 1, 111550);
                      break;
                    default:
                      e.Debug.failBadSyntaxKind(Ne);
                  }
                }
              }
              __name(Ci, "Ci");
              function C(p, ne, Ne) {
                Lr(Ne, ne, p, 4, 0, true, true), V(p, ne);
              }
              __name(C, "C");
              function V(p, ne) {
                ne && (ne.assignmentDeclarationMembers || (ne.assignmentDeclarationMembers = new e.Map())).set(e.getNodeId(p), p);
              }
              __name(V, "V");
              function ee(p) {
                p.expression.kind === 108 ? Ci(p) : e.isBindableStaticAccessExpression(p) && p.parent.parent.kind === 308 && (e.isPrototypeAccess(p.expression) ? Ir(p, p.parent) : yt(p));
              }
              __name(ee, "ee");
              function le(p) {
                e.setParent(p.left, p), e.setParent(p.right, p), Ht(p.left.expression, p.left, false, true);
              }
              __name(le, "le");
              function Ze(p) {
                var ne = Gn(p.arguments[0].expression);
                ne && ne.valueDeclaration && kr(ne, ne.valueDeclaration, 32), Ut(p, ne, true);
              }
              __name(Ze, "Ze");
              function Ir(p, ne) {
                var Ne = p.expression, or = Ne.expression;
                e.setParent(or, Ne), e.setParent(Ne, p), e.setParent(p, ne), Ht(or, p, true, true);
              }
              __name(Ir, "Ir");
              function Ar(p) {
                var ne = Gn(p.arguments[0]), Ne = p.parent.parent.kind === 308;
                ne = Pt(ne, p.arguments[0], Ne, false, false), Ut(p, ne, false);
              }
              __name(Ar, "Ar");
              function hr(p) {
                var ne, Ne = Gn(p.left.expression, g) || Gn(p.left.expression, S);
                if (!(!e.isInJSFile(p) && !e.isFunctionSymbol(Ne))) {
                  var or = e.getLeftmostAccessExpression(p.left);
                  if (!(e.isIdentifier(or) && ((ne = W(g, or.escapedText)) === null || ne === void 0 ? void 0 : ne.flags) & 2097152))
                    if (e.setParent(p.left, p), e.setParent(p.right, p), e.isIdentifier(p.left.expression) && g === B && je(B, p.left.expression))
                      Tn(p);
                    else if (e.hasDynamicName(p)) {
                      Me(p, 67108868, "__computed");
                      var it = Pt(Ne, p.left.expression, jt(p.left), false, false);
                      V(p, it);
                    } else
                      yt(e.cast(p.left, e.isBindableStaticNameExpression));
                }
              }
              __name(hr, "hr");
              function yt(p) {
                e.Debug.assert(!e.isIdentifier(p)), e.setParent(p.expression, p), Ht(p.expression, p, false, false);
              }
              __name(yt, "yt");
              function Pt(p, ne, Ne, or, it) {
                if ((p == null ? void 0 : p.flags) & 2097152)
                  return p;
                if (Ne && !or) {
                  var vt = 67110400, Et = 110735;
                  p = qi(ne, p, function(Tt, tn, Mt) {
                    if (tn)
                      return kr(tn, Tt, vt), tn;
                    var $t = Mt ? Mt.exports : B.jsGlobalAugmentations || (B.jsGlobalAugmentations = e.createSymbolTable());
                    return Lr($t, Mt, Tt, vt, Et);
                  });
                }
                return it && p && p.valueDeclaration && kr(p, p.valueDeclaration, 32), p;
              }
              __name(Pt, "Pt");
              function Ut(p, ne, Ne) {
                if (!(!ne || !yi(ne))) {
                  var or = Ne ? ne.members || (ne.members = e.createSymbolTable()) : ne.exports || (ne.exports = e.createSymbolTable()), it = 0, vt = 0;
                  e.isFunctionLikeDeclaration(e.getAssignedExpandoInitializer(p)) ? (it = 8192, vt = 103359) : e.isCallExpression(p) && e.isBindableObjectDefinePropertyCall(p) && (e.some(p.arguments[2].properties, function(Et) {
                    var Tt = e.getNameOfDeclaration(Et);
                    return !!Tt && e.isIdentifier(Tt) && e.idText(Tt) === "set";
                  }) && (it |= 65540, vt |= 78783), e.some(p.arguments[2].properties, function(Et) {
                    var Tt = e.getNameOfDeclaration(Et);
                    return !!Tt && e.isIdentifier(Tt) && e.idText(Tt) === "get";
                  }) && (it |= 32772, vt |= 46015)), it === 0 && (it = 4, vt = 0), Lr(or, ne, p, it | 67108864, vt & -67108865);
                }
              }
              __name(Ut, "Ut");
              function jt(p) {
                return e.isBinaryExpression(p.parent) ? Ni(p.parent).parent.kind === 308 : p.parent.parent.kind === 308;
              }
              __name(jt, "jt");
              function Ht(p, ne, Ne, or) {
                var it = Gn(p, g) || Gn(p, S), vt = jt(ne);
                it = Pt(it, ne.expression, vt, Ne, or), Ut(ne, it, Ne);
              }
              __name(Ht, "Ht");
              function yi(p) {
                if (p.flags & 1072)
                  return true;
                var ne = p.valueDeclaration;
                if (ne && e.isCallExpression(ne))
                  return !!e.getAssignedExpandoInitializer(ne);
                var Ne = ne ? e.isVariableDeclaration(ne) ? ne.initializer : e.isBinaryExpression(ne) ? ne.right : e.isPropertyAccessExpression(ne) && e.isBinaryExpression(ne.parent) ? ne.parent.right : void 0 : void 0;
                if (Ne = Ne && e.getRightMostAssignedExpression(Ne), Ne) {
                  var or = e.isPrototypeAccess(e.isVariableDeclaration(ne) ? ne.name : e.isBinaryExpression(ne) ? ne.left : ne);
                  return !!e.getExpandoInitializer(e.isBinaryExpression(Ne) && (Ne.operatorToken.kind === 56 || Ne.operatorToken.kind === 60) ? Ne.right : Ne, or);
                }
                return false;
              }
              __name(yi, "yi");
              function Ni(p) {
                for (; e.isBinaryExpression(p.parent); )
                  p = p.parent;
                return p.parent;
              }
              __name(Ni, "Ni");
              function Gn(p, ne) {
                if (ne === void 0 && (ne = g), e.isIdentifier(p))
                  return W(ne, p.escapedText);
                var Ne = Gn(p.expression);
                return Ne && Ne.exports && Ne.exports.get(e.getElementOrPropertyAccessName(p));
              }
              __name(Gn, "Gn");
              function qi(p, ne, Ne) {
                if (je(B, p))
                  return B.symbol;
                if (e.isIdentifier(p))
                  return Ne(p, Gn(p), ne);
                var or = qi(p.expression, ne, Ne), it = e.getNameOrArgument(p);
                return e.isPrivateIdentifier(it) && e.Debug.fail("unexpected PrivateIdentifier"), Ne(it, or && or.exports && or.exports.get(e.getElementOrPropertyAccessName(p)), or);
              }
              __name(qi, "qi");
              function sa(p) {
                !B.commonJsModuleIndicator && e.isRequireCall(p, false) && ni(p);
              }
              __name(sa, "sa");
              function ea(p) {
                if (p.kind === 260)
                  Ve(p, 32, 899503);
                else {
                  var ne = p.name ? p.name.escapedText : "__class";
                  Me(p, 32, ne), p.name && Ce.add(p.name.escapedText);
                }
                var Ne = p.symbol, or = yr(4194308, "prototype"), it = Ne.exports.get(or.escapedName);
                it && (p.name && e.setParent(p.name, p), B.bindDiagnostics.push(Ee(it.declarations[0], e.Diagnostics.Duplicate_identifier_0, e.symbolName(or)))), Ne.exports.set(or.escapedName, or), or.parent = Ne;
              }
              __name(ea, "ea");
              function Hi(p) {
                return e.isEnumConst(p) ? Ve(p, 128, 899967) : Ve(p, 256, 899327);
              }
              __name(Hi, "Hi");
              function Ui(p) {
                if (ve && _e(p, p.name), !e.isBindingPattern(p.name)) {
                  var ne = p.kind === 257 ? p : p.parent.parent;
                  e.isInJSFile(p) && e.isVariableDeclarationInitializedToBareOrAccessedRequire(ne) && !e.getJSDocTypeTag(p) && !(e.getCombinedModifierFlags(p) & 1) ? gt(p, 2097152, 2097152) : e.isBlockOrCatchScoped(p) ? Ve(p, 2, 111551) : e.isParameterDeclaration(p) ? gt(p, 1, 111551) : gt(p, 1, 111550);
                }
              }
              __name(Ui, "Ui");
              function Gi(p) {
                if (!(p.kind === 343 && g.kind !== 326) && (ve && !(p.flags & 16777216) && _e(p, p.name), e.isBindingPattern(p.name) ? Me(p, 1, "__" + p.parent.parameters.indexOf(p)) : gt(p, 1, 111551), e.isParameterPropertyDeclaration(p, p.parent))) {
                  var ne = p.parent.parent;
                  Lr(ne.symbol.members, ne.symbol, p, 4 | (p.questionToken ? 16777216 : 0), 0);
                }
              }
              __name(Gi, "Gi");
              function Xi(p) {
                !B.isDeclarationFile && !(p.flags & 16777216) && e.isAsyncFunction(p) && (ze |= 2048), Kt(p), ve ? (Ot(p), Ve(p, 16, 110991)) : gt(p, 16, 110991);
              }
              __name(Xi, "Xi");
              function ma(p) {
                !B.isDeclarationFile && !(p.flags & 16777216) && e.isAsyncFunction(p) && (ze |= 2048), ge && (p.flowNode = ge), Kt(p);
                var ne = p.name ? p.name.escapedText : "__function";
                return Me(p, 16, ne);
              }
              __name(ma, "ma");
              function Jn(p, ne, Ne) {
                return !B.isDeclarationFile && !(p.flags & 16777216) && e.isAsyncFunction(p) && (ze |= 2048), ge && e.isObjectLiteralOrClassExpressionMethodOrAccessor(p) && (p.flowNode = ge), e.hasDynamicName(p) ? Me(p, ne, "__computed") : gt(p, ne, Ne);
              }
              __name(Jn, "Jn");
              function ra(p) {
                var ne = e.findAncestor(p, function(Ne) {
                  return Ne.parent && e.isConditionalTypeNode(Ne.parent) && Ne.parent.extendsType === Ne;
                });
                return ne && ne.parent;
              }
              __name(ra, "ra");
              function $i(p) {
                if (e.isJSDocTemplateTag(p.parent)) {
                  var ne = e.getEffectiveContainerForJSDocTemplateTag(p.parent);
                  ne ? (ne.locals || (ne.locals = e.createSymbolTable()), Lr(ne.locals, void 0, p, 262144, 526824)) : gt(p, 262144, 526824);
                } else if (p.parent.kind === 192) {
                  var Ne = ra(p.parent);
                  Ne ? (Ne.locals || (Ne.locals = e.createSymbolTable()), Lr(Ne.locals, void 0, p, 262144, 526824)) : Me(p, 262144, nr(p));
                } else
                  gt(p, 262144, 526824);
              }
              __name($i, "$i");
              function _a(p) {
                var ne = x(p);
                return ne === 1 || ne === 2 && e.shouldPreserveConstEnums(U);
              }
              __name(_a, "_a");
              function Ri(p) {
                if (!(ge.flags & 1))
                  return false;
                if (ge === Xe) {
                  var ne = e.isStatementButNotDeclaration(p) && p.kind !== 239 || p.kind === 260 || p.kind === 264 && _a(p);
                  if (ne && (ge = gr, !U.allowUnreachableCode)) {
                    var Ne = e.unreachableCodeIsError(U) && !(p.flags & 16777216) && (!e.isVariableStatement(p) || !!(e.getCombinedNodeFlags(p.declarationList) & 3) || p.declarationList.declarations.some(function(or) {
                      return !!or.initializer;
                    }));
                    Le(p, function(or, it) {
                      return on(Ne, or, it, e.Diagnostics.Unreachable_code_detected);
                    });
                  }
                }
                return true;
              }
              __name(Ri, "Ri");
            }
            __name(se, "se");
            function Le(B, U) {
              if (e.isStatement(B) && Q(B) && e.isBlock(B.parent)) {
                var m = B.parent.statements, v = e.sliceAfter(m, B);
                e.getRangesWhere(v, Q, function(g, O) {
                  return U(v[g], v[O - 1]);
                });
              } else
                U(B, B);
            }
            __name(Le, "Le");
            function Q(B) {
              return !e.isFunctionDeclaration(B) && !Be(B) && !e.isEnumDeclaration(B) && !(e.isVariableStatement(B) && !(e.getCombinedNodeFlags(B) & 3) && B.declarationList.declarations.some(function(U) {
                return !U.initializer;
              }));
            }
            __name(Q, "Q");
            function Be(B) {
              switch (B.kind) {
                case 261:
                case 262:
                  return true;
                case 264:
                  return x(B) !== 1;
                case 263:
                  return e.hasSyntacticModifier(B, 2048);
                default:
                  return false;
              }
            }
            __name(Be, "Be");
            function je(B, U) {
              var m = 0, v = e.createQueue();
              for (v.enqueue(U); !v.isEmpty() && m < 100; ) {
                if (m++, U = v.dequeue(), e.isExportsIdentifier(U) || e.isModuleExportsAccessExpression(U))
                  return true;
                if (e.isIdentifier(U)) {
                  var g = W(B, U.escapedText);
                  if (!!g && !!g.valueDeclaration && e.isVariableDeclaration(g.valueDeclaration) && !!g.valueDeclaration.initializer) {
                    var O = g.valueDeclaration.initializer;
                    v.enqueue(O), e.isAssignmentExpression(O, true) && (v.enqueue(O.left), v.enqueue(O.right));
                  }
                }
              }
              return false;
            }
            __name(je, "je");
            e.isExportsOrModuleExportsOrAlias = je;
            function W(B, U) {
              var m = B.locals && B.locals.get(U);
              return m ? m.exportSymbol || m : e.isSourceFile(B) && B.jsGlobalAugmentations && B.jsGlobalAugmentations.has(U) ? B.jsGlobalAugmentations.get(U) : B.symbol && B.symbol.exports && B.symbol.exports.get(U);
            }
            __name(W, "W");
          })(N || (N = {}));
          var N;
          (function(e) {
            function t(x, s, q, F, fe, Te, Se, J, se, Le) {
              return Q;
              function Q(Be) {
                Be === void 0 && (Be = /* @__PURE__ */ __name(function() {
                  return true;
                }, "Be"));
                var je = [], W = [];
                return { walkType: function(ie) {
                  try {
                    return B(ie), { visitedTypes: e.getOwnValues(je), visitedSymbols: e.getOwnValues(W) };
                  } finally {
                    e.clear(je), e.clear(W);
                  }
                }, walkSymbol: function(ie) {
                  try {
                    return ge(ie), { visitedTypes: e.getOwnValues(je), visitedSymbols: e.getOwnValues(W) };
                  } finally {
                    e.clear(je), e.clear(W);
                  }
                } };
                function B(ie) {
                  if (!!ie && !je[ie.id]) {
                    je[ie.id] = ie;
                    var G = ge(ie.symbol);
                    if (!G) {
                      if (ie.flags & 524288) {
                        var pe = ie, j = pe.objectFlags;
                        j & 4 && U(ie), j & 32 && S(ie), j & 3 && Je(ie), j & 24 && qe(pe);
                      }
                      ie.flags & 262144 && m(ie), ie.flags & 3145728 && v(ie), ie.flags & 4194304 && g(ie), ie.flags & 8388608 && O(ie);
                    }
                  }
                }
                __name(B, "B");
                function U(ie) {
                  B(ie.target), e.forEach(Le(ie), B);
                }
                __name(U, "U");
                function m(ie) {
                  B(J(ie));
                }
                __name(m, "m");
                function v(ie) {
                  e.forEach(ie.types, B);
                }
                __name(v, "v");
                function g(ie) {
                  B(ie.type);
                }
                __name(g, "g");
                function O(ie) {
                  B(ie.objectType), B(ie.indexType), B(ie.constraint);
                }
                __name(O, "O");
                function S(ie) {
                  B(ie.typeParameter), B(ie.constraintType), B(ie.templateType), B(ie.modifiersType);
                }
                __name(S, "S");
                function te(ie) {
                  var G = s(ie);
                  G && B(G.type), e.forEach(ie.typeParameters, B);
                  for (var pe = 0, j = ie.parameters; pe < j.length; pe++) {
                    var be = j[pe];
                    ge(be);
                  }
                  B(x(ie)), B(q(ie));
                }
                __name(te, "te");
                function Je(ie) {
                  qe(ie), e.forEach(ie.typeParameters, B), e.forEach(F(ie), B), B(ie.thisType);
                }
                __name(Je, "Je");
                function qe(ie) {
                  for (var G = fe(ie), pe = 0, j = G.indexInfos; pe < j.length; pe++) {
                    var be = j[pe];
                    B(be.keyType), B(be.type);
                  }
                  for (var $e = 0, Re = G.callSignatures; $e < Re.length; $e++) {
                    var Fe = Re[$e];
                    te(Fe);
                  }
                  for (var dr = 0, ze = G.constructSignatures; dr < ze.length; dr++) {
                    var Fe = ze[dr];
                    te(Fe);
                  }
                  for (var ve = 0, er = G.properties; ve < er.length; ve++) {
                    var ar = er[ve];
                    ge(ar);
                  }
                }
                __name(qe, "qe");
                function ge(ie) {
                  if (!ie)
                    return false;
                  var G = e.getSymbolId(ie);
                  if (W[G])
                    return false;
                  if (W[G] = ie, !Be(ie))
                    return true;
                  var pe = Te(ie);
                  return B(pe), ie.exports && ie.exports.forEach(ge), e.forEach(ie.declarations, function(j) {
                    if (j.type && j.type.kind === 183) {
                      var be = j.type, $e = Se(se(be.exprName));
                      ge($e);
                    }
                  }), false;
                }
                __name(ge, "ge");
              }
              __name(Q, "Q");
            }
            __name(t, "t");
            e.createGetSymbolWalker = t;
          })(N || (N = {}));
          var N;
          (function(e) {
            var t;
            function x(U, m, v, g) {
              if (U === void 0 || m === void 0)
                return U;
              var O = m(U);
              if (O === U)
                return U;
              var S;
              if (O !== void 0)
                return e.isArray(O) ? S = (g || B)(O) : S = O, e.Debug.assertNode(S, v), S;
            }
            __name(x, "x");
            e.visitNode = x;
            function s(U, m, v, g, O) {
              if (U === void 0 || m === void 0)
                return U;
              var S = U.length;
              (g === void 0 || g < 0) && (g = 0), (O === void 0 || O > S - g) && (O = S - g);
              var te, Je = -1, qe = -1;
              g > 0 || O < S ? te = U.hasTrailingComma && g + O === S : (Je = U.pos, qe = U.end, te = U.hasTrailingComma);
              var ge = F(U, m, v, g, O);
              if (ge !== U) {
                var ie = e.factory.createNodeArray(ge, te);
                return e.setTextRangePosEnd(ie, Je, qe), ie;
              }
              return U;
            }
            __name(s, "s");
            e.visitNodes = s;
            function q(U, m, v, g, O) {
              if (U === void 0)
                return U;
              var S = U.length;
              return (g === void 0 || g < 0) && (g = 0), (O === void 0 || O > S - g) && (O = S - g), F(U, m, v, g, O);
            }
            __name(q, "q");
            e.visitArray = q;
            function F(U, m, v, g, O) {
              var S, te = U.length;
              (g > 0 || O < te) && (S = []);
              for (var Je = 0; Je < O; Je++) {
                var qe = U[Je + g], ge = qe !== void 0 ? m(qe) : void 0;
                if ((S !== void 0 || ge === void 0 || ge !== qe) && (S === void 0 && (S = U.slice(0, Je)), ge))
                  if (e.isArray(ge))
                    for (var ie = 0, G = ge; ie < G.length; ie++) {
                      var pe = G[ie];
                      e.Debug.assertNode(pe, v), S.push(pe);
                    }
                  else
                    e.Debug.assertNode(ge, v), S.push(ge);
              }
              return S != null ? S : U;
            }
            __name(F, "F");
            function fe(U, m, v, g, O, S) {
              return S === void 0 && (S = s), v.startLexicalEnvironment(), U = S(U, m, e.isStatement, g), O && (U = v.factory.ensureUseStrict(U)), e.factory.mergeLexicalEnvironment(U, v.endLexicalEnvironment());
            }
            __name(fe, "fe");
            e.visitLexicalEnvironment = fe;
            function Te(U, m, v, g) {
              g === void 0 && (g = s);
              var O;
              return v.startLexicalEnvironment(), U && (v.setLexicalEnvironmentFlags(1, true), O = g(U, m, e.isParameterDeclaration), v.getLexicalEnvironmentFlags() & 2 && e.getEmitScriptTarget(v.getCompilerOptions()) >= 2 && (O = Se(O, v)), v.setLexicalEnvironmentFlags(1, false)), v.suspendLexicalEnvironment(), O;
            }
            __name(Te, "Te");
            e.visitParameterList = Te;
            function Se(U, m) {
              for (var v, g = 0; g < U.length; g++) {
                var O = U[g], S = J(O, m);
                (v || S !== O) && (v || (v = U.slice(0, g)), v[g] = S);
              }
              return v ? e.setTextRange(m.factory.createNodeArray(v, U.hasTrailingComma), U) : U;
            }
            __name(Se, "Se");
            function J(U, m) {
              return U.dotDotDotToken ? U : e.isBindingPattern(U.name) ? se(U, m) : U.initializer ? Le(U, U.name, U.initializer, m) : U;
            }
            __name(J, "J");
            function se(U, m) {
              var v = m.factory;
              return m.addInitializationStatement(v.createVariableStatement(void 0, v.createVariableDeclarationList([v.createVariableDeclaration(U.name, void 0, U.type, U.initializer ? v.createConditionalExpression(v.createStrictEquality(v.getGeneratedNameForNode(U), v.createVoidZero()), void 0, U.initializer, void 0, v.getGeneratedNameForNode(U)) : v.getGeneratedNameForNode(U))]))), v.updateParameterDeclaration(U, U.modifiers, U.dotDotDotToken, v.getGeneratedNameForNode(U), U.questionToken, U.type, void 0);
            }
            __name(se, "se");
            function Le(U, m, v, g) {
              var O = g.factory;
              return g.addInitializationStatement(O.createIfStatement(O.createTypeCheck(O.cloneNode(m), "undefined"), e.setEmitFlags(e.setTextRange(O.createBlock([O.createExpressionStatement(e.setEmitFlags(e.setTextRange(O.createAssignment(e.setEmitFlags(O.cloneNode(m), 48), e.setEmitFlags(v, 48 | e.getEmitFlags(v) | 1536)), U), 1536))]), U), 1953))), O.updateParameterDeclaration(U, U.modifiers, U.dotDotDotToken, U.name, U.questionToken, U.type, void 0);
            }
            __name(Le, "Le");
            function Q(U, m, v, g) {
              g === void 0 && (g = x), v.resumeLexicalEnvironment();
              var O = g(U, m, e.isConciseBody), S = v.endLexicalEnvironment();
              if (e.some(S)) {
                if (!O)
                  return v.factory.createBlock(S);
                var te = v.factory.converters.convertToFunctionBlock(O), Je = e.factory.mergeLexicalEnvironment(te.statements, S);
                return v.factory.updateBlock(te, Je);
              }
              return O;
            }
            __name(Q, "Q");
            e.visitFunctionBody = Q;
            function Be(U, m, v, g) {
              g === void 0 && (g = x), v.startBlockScope();
              var O = g(U, m, e.isStatement, v.factory.liftToBlock), S = v.endBlockScope();
              return e.some(S) ? e.isBlock(O) ? (S.push.apply(S, O.statements), v.factory.updateBlock(O, S)) : (S.push(O), v.factory.createBlock(S)) : O;
            }
            __name(Be, "Be");
            e.visitIterationBody = Be;
            function je(U, m, v, g, O, S) {
              if (g === void 0 && (g = s), S === void 0 && (S = x), U !== void 0) {
                var te = W[U.kind];
                return te === void 0 ? U : te(U, m, v, g, S, O);
              }
            }
            __name(je, "je");
            e.visitEachChild = je;
            var W = (t = {}, t[79] = function(m, v, g, O, S, te) {
              return g.factory.updateIdentifier(m, O(m.typeArguments, v, e.isTypeNodeOrTypeParameterDeclaration));
            }, t[163] = function(m, v, g, O, S, te) {
              return g.factory.updateQualifiedName(m, S(m.left, v, e.isEntityName), S(m.right, v, e.isIdentifier));
            }, t[164] = function(m, v, g, O, S, te) {
              return g.factory.updateComputedPropertyName(m, S(m.expression, v, e.isExpression));
            }, t[165] = function(m, v, g, O, S, te) {
              return g.factory.updateTypeParameterDeclaration(m, O(m.modifiers, v, e.isModifier), S(m.name, v, e.isIdentifier), S(m.constraint, v, e.isTypeNode), S(m.default, v, e.isTypeNode));
            }, t[166] = function(m, v, g, O, S, te) {
              return g.factory.updateParameterDeclaration(m, O(m.modifiers, v, e.isModifierLike), S(m.dotDotDotToken, te, e.isDotDotDotToken), S(m.name, v, e.isBindingName), S(m.questionToken, te, e.isQuestionToken), S(m.type, v, e.isTypeNode), S(m.initializer, v, e.isExpression));
            }, t[167] = function(m, v, g, O, S, te) {
              return g.factory.updateDecorator(m, S(m.expression, v, e.isExpression));
            }, t[168] = function(m, v, g, O, S, te) {
              return g.factory.updatePropertySignature(m, O(m.modifiers, v, e.isModifier), S(m.name, v, e.isPropertyName), S(m.questionToken, te, e.isToken), S(m.type, v, e.isTypeNode));
            }, t[169] = function(m, v, g, O, S, te) {
              var Je;
              return g.factory.updatePropertyDeclaration(m, O(m.modifiers, v, e.isModifierLike), S(m.name, v, e.isPropertyName), S((Je = m.questionToken) !== null && Je !== void 0 ? Je : m.exclamationToken, te, e.isQuestionOrExclamationToken), S(m.type, v, e.isTypeNode), S(m.initializer, v, e.isExpression));
            }, t[170] = function(m, v, g, O, S, te) {
              return g.factory.updateMethodSignature(m, O(m.modifiers, v, e.isModifier), S(m.name, v, e.isPropertyName), S(m.questionToken, te, e.isQuestionToken), O(m.typeParameters, v, e.isTypeParameterDeclaration), O(m.parameters, v, e.isParameterDeclaration), S(m.type, v, e.isTypeNode));
            }, t[171] = function(m, v, g, O, S, te) {
              return g.factory.updateMethodDeclaration(m, O(m.modifiers, v, e.isModifierLike), S(m.asteriskToken, te, e.isAsteriskToken), S(m.name, v, e.isPropertyName), S(m.questionToken, te, e.isQuestionToken), O(m.typeParameters, v, e.isTypeParameterDeclaration), Te(m.parameters, v, g, O), S(m.type, v, e.isTypeNode), Q(m.body, v, g, S));
            }, t[173] = function(m, v, g, O, S, te) {
              return g.factory.updateConstructorDeclaration(m, O(m.modifiers, v, e.isModifier), Te(m.parameters, v, g, O), Q(m.body, v, g, S));
            }, t[174] = function(m, v, g, O, S, te) {
              return g.factory.updateGetAccessorDeclaration(m, O(m.modifiers, v, e.isModifierLike), S(m.name, v, e.isPropertyName), Te(m.parameters, v, g, O), S(m.type, v, e.isTypeNode), Q(m.body, v, g, S));
            }, t[175] = function(m, v, g, O, S, te) {
              return g.factory.updateSetAccessorDeclaration(m, O(m.modifiers, v, e.isModifierLike), S(m.name, v, e.isPropertyName), Te(m.parameters, v, g, O), Q(m.body, v, g, S));
            }, t[172] = function(m, v, g, O, S, te) {
              return g.startLexicalEnvironment(), g.suspendLexicalEnvironment(), g.factory.updateClassStaticBlockDeclaration(m, Q(m.body, v, g, S));
            }, t[176] = function(m, v, g, O, S, te) {
              return g.factory.updateCallSignature(m, O(m.typeParameters, v, e.isTypeParameterDeclaration), O(m.parameters, v, e.isParameterDeclaration), S(m.type, v, e.isTypeNode));
            }, t[177] = function(m, v, g, O, S, te) {
              return g.factory.updateConstructSignature(m, O(m.typeParameters, v, e.isTypeParameterDeclaration), O(m.parameters, v, e.isParameterDeclaration), S(m.type, v, e.isTypeNode));
            }, t[178] = function(m, v, g, O, S, te) {
              return g.factory.updateIndexSignature(m, O(m.modifiers, v, e.isModifier), O(m.parameters, v, e.isParameterDeclaration), S(m.type, v, e.isTypeNode));
            }, t[179] = function(m, v, g, O, S, te) {
              return g.factory.updateTypePredicateNode(m, S(m.assertsModifier, v, e.isAssertsKeyword), S(m.parameterName, v, e.isIdentifierOrThisTypeNode), S(m.type, v, e.isTypeNode));
            }, t[180] = function(m, v, g, O, S, te) {
              return g.factory.updateTypeReferenceNode(m, S(m.typeName, v, e.isEntityName), O(m.typeArguments, v, e.isTypeNode));
            }, t[181] = function(m, v, g, O, S, te) {
              return g.factory.updateFunctionTypeNode(m, O(m.typeParameters, v, e.isTypeParameterDeclaration), O(m.parameters, v, e.isParameterDeclaration), S(m.type, v, e.isTypeNode));
            }, t[182] = function(m, v, g, O, S, te) {
              return g.factory.updateConstructorTypeNode(m, O(m.modifiers, v, e.isModifier), O(m.typeParameters, v, e.isTypeParameterDeclaration), O(m.parameters, v, e.isParameterDeclaration), S(m.type, v, e.isTypeNode));
            }, t[183] = function(m, v, g, O, S, te) {
              return g.factory.updateTypeQueryNode(m, S(m.exprName, v, e.isEntityName), O(m.typeArguments, v, e.isTypeNode));
            }, t[184] = function(m, v, g, O, S, te) {
              return g.factory.updateTypeLiteralNode(m, O(m.members, v, e.isTypeElement));
            }, t[185] = function(m, v, g, O, S, te) {
              return g.factory.updateArrayTypeNode(m, S(m.elementType, v, e.isTypeNode));
            }, t[186] = function(m, v, g, O, S, te) {
              return g.factory.updateTupleTypeNode(m, O(m.elements, v, e.isTypeNode));
            }, t[187] = function(m, v, g, O, S, te) {
              return g.factory.updateOptionalTypeNode(m, S(m.type, v, e.isTypeNode));
            }, t[188] = function(m, v, g, O, S, te) {
              return g.factory.updateRestTypeNode(m, S(m.type, v, e.isTypeNode));
            }, t[189] = function(m, v, g, O, S, te) {
              return g.factory.updateUnionTypeNode(m, O(m.types, v, e.isTypeNode));
            }, t[190] = function(m, v, g, O, S, te) {
              return g.factory.updateIntersectionTypeNode(m, O(m.types, v, e.isTypeNode));
            }, t[191] = function(m, v, g, O, S, te) {
              return g.factory.updateConditionalTypeNode(m, S(m.checkType, v, e.isTypeNode), S(m.extendsType, v, e.isTypeNode), S(m.trueType, v, e.isTypeNode), S(m.falseType, v, e.isTypeNode));
            }, t[192] = function(m, v, g, O, S, te) {
              return g.factory.updateInferTypeNode(m, S(m.typeParameter, v, e.isTypeParameterDeclaration));
            }, t[202] = function(m, v, g, O, S, te) {
              return g.factory.updateImportTypeNode(m, S(m.argument, v, e.isTypeNode), S(m.assertions, v, e.isImportTypeAssertionContainer), S(m.qualifier, v, e.isEntityName), O(m.typeArguments, v, e.isTypeNode), m.isTypeOf);
            }, t[298] = function(m, v, g, O, S, te) {
              return g.factory.updateImportTypeAssertionContainer(m, S(m.assertClause, v, e.isAssertClause), m.multiLine);
            }, t[199] = function(m, v, g, O, S, te) {
              return g.factory.updateNamedTupleMember(m, S(m.dotDotDotToken, te, e.isDotDotDotToken), S(m.name, v, e.isIdentifier), S(m.questionToken, te, e.isQuestionToken), S(m.type, v, e.isTypeNode));
            }, t[193] = function(m, v, g, O, S, te) {
              return g.factory.updateParenthesizedType(m, S(m.type, v, e.isTypeNode));
            }, t[195] = function(m, v, g, O, S, te) {
              return g.factory.updateTypeOperatorNode(m, S(m.type, v, e.isTypeNode));
            }, t[196] = function(m, v, g, O, S, te) {
              return g.factory.updateIndexedAccessTypeNode(m, S(m.objectType, v, e.isTypeNode), S(m.indexType, v, e.isTypeNode));
            }, t[197] = function(m, v, g, O, S, te) {
              return g.factory.updateMappedTypeNode(m, S(m.readonlyToken, te, e.isReadonlyKeywordOrPlusOrMinusToken), S(m.typeParameter, v, e.isTypeParameterDeclaration), S(m.nameType, v, e.isTypeNode), S(m.questionToken, te, e.isQuestionOrPlusOrMinusToken), S(m.type, v, e.isTypeNode), O(m.members, v, e.isTypeElement));
            }, t[198] = function(m, v, g, O, S, te) {
              return g.factory.updateLiteralTypeNode(m, S(m.literal, v, e.isExpression));
            }, t[200] = function(m, v, g, O, S, te) {
              return g.factory.updateTemplateLiteralType(m, S(m.head, v, e.isTemplateHead), O(m.templateSpans, v, e.isTemplateLiteralTypeSpan));
            }, t[201] = function(m, v, g, O, S, te) {
              return g.factory.updateTemplateLiteralTypeSpan(m, S(m.type, v, e.isTypeNode), S(m.literal, v, e.isTemplateMiddleOrTemplateTail));
            }, t[203] = function(m, v, g, O, S, te) {
              return g.factory.updateObjectBindingPattern(m, O(m.elements, v, e.isBindingElement));
            }, t[204] = function(m, v, g, O, S, te) {
              return g.factory.updateArrayBindingPattern(m, O(m.elements, v, e.isArrayBindingElement));
            }, t[205] = function(m, v, g, O, S, te) {
              return g.factory.updateBindingElement(m, S(m.dotDotDotToken, te, e.isDotDotDotToken), S(m.propertyName, v, e.isPropertyName), S(m.name, v, e.isBindingName), S(m.initializer, v, e.isExpression));
            }, t[206] = function(m, v, g, O, S, te) {
              return g.factory.updateArrayLiteralExpression(m, O(m.elements, v, e.isExpression));
            }, t[207] = function(m, v, g, O, S, te) {
              return g.factory.updateObjectLiteralExpression(m, O(m.properties, v, e.isObjectLiteralElementLike));
            }, t[208] = function(m, v, g, O, S, te) {
              return e.isPropertyAccessChain(m) ? g.factory.updatePropertyAccessChain(m, S(m.expression, v, e.isExpression), S(m.questionDotToken, te, e.isQuestionDotToken), S(m.name, v, e.isMemberName)) : g.factory.updatePropertyAccessExpression(m, S(m.expression, v, e.isExpression), S(m.name, v, e.isMemberName));
            }, t[209] = function(m, v, g, O, S, te) {
              return e.isElementAccessChain(m) ? g.factory.updateElementAccessChain(m, S(m.expression, v, e.isExpression), S(m.questionDotToken, te, e.isQuestionDotToken), S(m.argumentExpression, v, e.isExpression)) : g.factory.updateElementAccessExpression(m, S(m.expression, v, e.isExpression), S(m.argumentExpression, v, e.isExpression));
            }, t[210] = function(m, v, g, O, S, te) {
              return e.isCallChain(m) ? g.factory.updateCallChain(m, S(m.expression, v, e.isExpression), S(m.questionDotToken, te, e.isQuestionDotToken), O(m.typeArguments, v, e.isTypeNode), O(m.arguments, v, e.isExpression)) : g.factory.updateCallExpression(m, S(m.expression, v, e.isExpression), O(m.typeArguments, v, e.isTypeNode), O(m.arguments, v, e.isExpression));
            }, t[211] = function(m, v, g, O, S, te) {
              return g.factory.updateNewExpression(m, S(m.expression, v, e.isExpression), O(m.typeArguments, v, e.isTypeNode), O(m.arguments, v, e.isExpression));
            }, t[212] = function(m, v, g, O, S, te) {
              return g.factory.updateTaggedTemplateExpression(m, S(m.tag, v, e.isExpression), O(m.typeArguments, v, e.isTypeNode), S(m.template, v, e.isTemplateLiteral));
            }, t[213] = function(m, v, g, O, S, te) {
              return g.factory.updateTypeAssertion(m, S(m.type, v, e.isTypeNode), S(m.expression, v, e.isExpression));
            }, t[214] = function(m, v, g, O, S, te) {
              return g.factory.updateParenthesizedExpression(m, S(m.expression, v, e.isExpression));
            }, t[215] = function(m, v, g, O, S, te) {
              return g.factory.updateFunctionExpression(m, O(m.modifiers, v, e.isModifier), S(m.asteriskToken, te, e.isAsteriskToken), S(m.name, v, e.isIdentifier), O(m.typeParameters, v, e.isTypeParameterDeclaration), Te(m.parameters, v, g, O), S(m.type, v, e.isTypeNode), Q(m.body, v, g, S));
            }, t[216] = function(m, v, g, O, S, te) {
              return g.factory.updateArrowFunction(m, O(m.modifiers, v, e.isModifier), O(m.typeParameters, v, e.isTypeParameterDeclaration), Te(m.parameters, v, g, O), S(m.type, v, e.isTypeNode), S(m.equalsGreaterThanToken, te, e.isEqualsGreaterThanToken), Q(m.body, v, g, S));
            }, t[217] = function(m, v, g, O, S, te) {
              return g.factory.updateDeleteExpression(m, S(m.expression, v, e.isExpression));
            }, t[218] = function(m, v, g, O, S, te) {
              return g.factory.updateTypeOfExpression(m, S(m.expression, v, e.isExpression));
            }, t[219] = function(m, v, g, O, S, te) {
              return g.factory.updateVoidExpression(m, S(m.expression, v, e.isExpression));
            }, t[220] = function(m, v, g, O, S, te) {
              return g.factory.updateAwaitExpression(m, S(m.expression, v, e.isExpression));
            }, t[221] = function(m, v, g, O, S, te) {
              return g.factory.updatePrefixUnaryExpression(m, S(m.operand, v, e.isExpression));
            }, t[222] = function(m, v, g, O, S, te) {
              return g.factory.updatePostfixUnaryExpression(m, S(m.operand, v, e.isExpression));
            }, t[223] = function(m, v, g, O, S, te) {
              return g.factory.updateBinaryExpression(m, S(m.left, v, e.isExpression), S(m.operatorToken, te, e.isBinaryOperatorToken), S(m.right, v, e.isExpression));
            }, t[224] = function(m, v, g, O, S, te) {
              return g.factory.updateConditionalExpression(m, S(m.condition, v, e.isExpression), S(m.questionToken, te, e.isQuestionToken), S(m.whenTrue, v, e.isExpression), S(m.colonToken, te, e.isColonToken), S(m.whenFalse, v, e.isExpression));
            }, t[225] = function(m, v, g, O, S, te) {
              return g.factory.updateTemplateExpression(m, S(m.head, v, e.isTemplateHead), O(m.templateSpans, v, e.isTemplateSpan));
            }, t[226] = function(m, v, g, O, S, te) {
              return g.factory.updateYieldExpression(m, S(m.asteriskToken, te, e.isAsteriskToken), S(m.expression, v, e.isExpression));
            }, t[227] = function(m, v, g, O, S, te) {
              return g.factory.updateSpreadElement(m, S(m.expression, v, e.isExpression));
            }, t[228] = function(m, v, g, O, S, te) {
              return g.factory.updateClassExpression(m, O(m.modifiers, v, e.isModifierLike), S(m.name, v, e.isIdentifier), O(m.typeParameters, v, e.isTypeParameterDeclaration), O(m.heritageClauses, v, e.isHeritageClause), O(m.members, v, e.isClassElement));
            }, t[230] = function(m, v, g, O, S, te) {
              return g.factory.updateExpressionWithTypeArguments(m, S(m.expression, v, e.isExpression), O(m.typeArguments, v, e.isTypeNode));
            }, t[231] = function(m, v, g, O, S, te) {
              return g.factory.updateAsExpression(m, S(m.expression, v, e.isExpression), S(m.type, v, e.isTypeNode));
            }, t[235] = function(m, v, g, O, S, te) {
              return g.factory.updateSatisfiesExpression(m, S(m.expression, v, e.isExpression), S(m.type, v, e.isTypeNode));
            }, t[232] = function(m, v, g, O, S, te) {
              return e.isOptionalChain(m) ? g.factory.updateNonNullChain(m, S(m.expression, v, e.isExpression)) : g.factory.updateNonNullExpression(m, S(m.expression, v, e.isExpression));
            }, t[233] = function(m, v, g, O, S, te) {
              return g.factory.updateMetaProperty(m, S(m.name, v, e.isIdentifier));
            }, t[236] = function(m, v, g, O, S, te) {
              return g.factory.updateTemplateSpan(m, S(m.expression, v, e.isExpression), S(m.literal, v, e.isTemplateMiddleOrTemplateTail));
            }, t[238] = function(m, v, g, O, S, te) {
              return g.factory.updateBlock(m, O(m.statements, v, e.isStatement));
            }, t[240] = function(m, v, g, O, S, te) {
              return g.factory.updateVariableStatement(m, O(m.modifiers, v, e.isModifier), S(m.declarationList, v, e.isVariableDeclarationList));
            }, t[241] = function(m, v, g, O, S, te) {
              return g.factory.updateExpressionStatement(m, S(m.expression, v, e.isExpression));
            }, t[242] = function(m, v, g, O, S, te) {
              return g.factory.updateIfStatement(m, S(m.expression, v, e.isExpression), S(m.thenStatement, v, e.isStatement, g.factory.liftToBlock), S(m.elseStatement, v, e.isStatement, g.factory.liftToBlock));
            }, t[243] = function(m, v, g, O, S, te) {
              return g.factory.updateDoStatement(m, Be(m.statement, v, g, S), S(m.expression, v, e.isExpression));
            }, t[244] = function(m, v, g, O, S, te) {
              return g.factory.updateWhileStatement(m, S(m.expression, v, e.isExpression), Be(m.statement, v, g, S));
            }, t[245] = function(m, v, g, O, S, te) {
              return g.factory.updateForStatement(m, S(m.initializer, v, e.isForInitializer), S(m.condition, v, e.isExpression), S(m.incrementor, v, e.isExpression), Be(m.statement, v, g, S));
            }, t[246] = function(m, v, g, O, S, te) {
              return g.factory.updateForInStatement(m, S(m.initializer, v, e.isForInitializer), S(m.expression, v, e.isExpression), Be(m.statement, v, g, S));
            }, t[247] = function(m, v, g, O, S, te) {
              return g.factory.updateForOfStatement(m, S(m.awaitModifier, te, e.isAwaitKeyword), S(m.initializer, v, e.isForInitializer), S(m.expression, v, e.isExpression), Be(m.statement, v, g, S));
            }, t[248] = function(m, v, g, O, S, te) {
              return g.factory.updateContinueStatement(m, S(m.label, v, e.isIdentifier));
            }, t[249] = function(m, v, g, O, S, te) {
              return g.factory.updateBreakStatement(m, S(m.label, v, e.isIdentifier));
            }, t[250] = function(m, v, g, O, S, te) {
              return g.factory.updateReturnStatement(m, S(m.expression, v, e.isExpression));
            }, t[251] = function(m, v, g, O, S, te) {
              return g.factory.updateWithStatement(m, S(m.expression, v, e.isExpression), S(m.statement, v, e.isStatement, g.factory.liftToBlock));
            }, t[252] = function(m, v, g, O, S, te) {
              return g.factory.updateSwitchStatement(m, S(m.expression, v, e.isExpression), S(m.caseBlock, v, e.isCaseBlock));
            }, t[253] = function(m, v, g, O, S, te) {
              return g.factory.updateLabeledStatement(m, S(m.label, v, e.isIdentifier), S(m.statement, v, e.isStatement, g.factory.liftToBlock));
            }, t[254] = function(m, v, g, O, S, te) {
              return g.factory.updateThrowStatement(m, S(m.expression, v, e.isExpression));
            }, t[255] = function(m, v, g, O, S, te) {
              return g.factory.updateTryStatement(m, S(m.tryBlock, v, e.isBlock), S(m.catchClause, v, e.isCatchClause), S(m.finallyBlock, v, e.isBlock));
            }, t[257] = function(m, v, g, O, S, te) {
              return g.factory.updateVariableDeclaration(m, S(m.name, v, e.isBindingName), S(m.exclamationToken, te, e.isExclamationToken), S(m.type, v, e.isTypeNode), S(m.initializer, v, e.isExpression));
            }, t[258] = function(m, v, g, O, S, te) {
              return g.factory.updateVariableDeclarationList(m, O(m.declarations, v, e.isVariableDeclaration));
            }, t[259] = function(m, v, g, O, S, te) {
              return g.factory.updateFunctionDeclaration(m, O(m.modifiers, v, e.isModifier), S(m.asteriskToken, te, e.isAsteriskToken), S(m.name, v, e.isIdentifier), O(m.typeParameters, v, e.isTypeParameterDeclaration), Te(m.parameters, v, g, O), S(m.type, v, e.isTypeNode), Q(m.body, v, g, S));
            }, t[260] = function(m, v, g, O, S, te) {
              return g.factory.updateClassDeclaration(m, O(m.modifiers, v, e.isModifierLike), S(m.name, v, e.isIdentifier), O(m.typeParameters, v, e.isTypeParameterDeclaration), O(m.heritageClauses, v, e.isHeritageClause), O(m.members, v, e.isClassElement));
            }, t[261] = function(m, v, g, O, S, te) {
              return g.factory.updateInterfaceDeclaration(m, O(m.modifiers, v, e.isModifier), S(m.name, v, e.isIdentifier), O(m.typeParameters, v, e.isTypeParameterDeclaration), O(m.heritageClauses, v, e.isHeritageClause), O(m.members, v, e.isTypeElement));
            }, t[262] = function(m, v, g, O, S, te) {
              return g.factory.updateTypeAliasDeclaration(m, O(m.modifiers, v, e.isModifier), S(m.name, v, e.isIdentifier), O(m.typeParameters, v, e.isTypeParameterDeclaration), S(m.type, v, e.isTypeNode));
            }, t[263] = function(m, v, g, O, S, te) {
              return g.factory.updateEnumDeclaration(m, O(m.modifiers, v, e.isModifier), S(m.name, v, e.isIdentifier), O(m.members, v, e.isEnumMember));
            }, t[264] = function(m, v, g, O, S, te) {
              return g.factory.updateModuleDeclaration(m, O(m.modifiers, v, e.isModifier), S(m.name, v, e.isModuleName), S(m.body, v, e.isModuleBody));
            }, t[265] = function(m, v, g, O, S, te) {
              return g.factory.updateModuleBlock(m, O(m.statements, v, e.isStatement));
            }, t[266] = function(m, v, g, O, S, te) {
              return g.factory.updateCaseBlock(m, O(m.clauses, v, e.isCaseOrDefaultClause));
            }, t[267] = function(m, v, g, O, S, te) {
              return g.factory.updateNamespaceExportDeclaration(m, S(m.name, v, e.isIdentifier));
            }, t[268] = function(m, v, g, O, S, te) {
              return g.factory.updateImportEqualsDeclaration(m, O(m.modifiers, v, e.isModifier), m.isTypeOnly, S(m.name, v, e.isIdentifier), S(m.moduleReference, v, e.isModuleReference));
            }, t[269] = function(m, v, g, O, S, te) {
              return g.factory.updateImportDeclaration(m, O(m.modifiers, v, e.isModifier), S(m.importClause, v, e.isImportClause), S(m.moduleSpecifier, v, e.isExpression), S(m.assertClause, v, e.isAssertClause));
            }, t[296] = function(m, v, g, O, S, te) {
              return g.factory.updateAssertClause(m, O(m.elements, v, e.isAssertEntry), m.multiLine);
            }, t[297] = function(m, v, g, O, S, te) {
              return g.factory.updateAssertEntry(m, S(m.name, v, e.isAssertionKey), S(m.value, v, e.isExpression));
            }, t[270] = function(m, v, g, O, S, te) {
              return g.factory.updateImportClause(m, m.isTypeOnly, S(m.name, v, e.isIdentifier), S(m.namedBindings, v, e.isNamedImportBindings));
            }, t[271] = function(m, v, g, O, S, te) {
              return g.factory.updateNamespaceImport(m, S(m.name, v, e.isIdentifier));
            }, t[277] = function(m, v, g, O, S, te) {
              return g.factory.updateNamespaceExport(m, S(m.name, v, e.isIdentifier));
            }, t[272] = function(m, v, g, O, S, te) {
              return g.factory.updateNamedImports(m, O(m.elements, v, e.isImportSpecifier));
            }, t[273] = function(m, v, g, O, S, te) {
              return g.factory.updateImportSpecifier(m, m.isTypeOnly, S(m.propertyName, v, e.isIdentifier), S(m.name, v, e.isIdentifier));
            }, t[274] = function(m, v, g, O, S, te) {
              return g.factory.updateExportAssignment(m, O(m.modifiers, v, e.isModifier), S(m.expression, v, e.isExpression));
            }, t[275] = function(m, v, g, O, S, te) {
              return g.factory.updateExportDeclaration(m, O(m.modifiers, v, e.isModifier), m.isTypeOnly, S(m.exportClause, v, e.isNamedExportBindings), S(m.moduleSpecifier, v, e.isExpression), S(m.assertClause, v, e.isAssertClause));
            }, t[276] = function(m, v, g, O, S, te) {
              return g.factory.updateNamedExports(m, O(m.elements, v, e.isExportSpecifier));
            }, t[278] = function(m, v, g, O, S, te) {
              return g.factory.updateExportSpecifier(m, m.isTypeOnly, S(m.propertyName, v, e.isIdentifier), S(m.name, v, e.isIdentifier));
            }, t[280] = function(m, v, g, O, S, te) {
              return g.factory.updateExternalModuleReference(m, S(m.expression, v, e.isExpression));
            }, t[281] = function(m, v, g, O, S, te) {
              return g.factory.updateJsxElement(m, S(m.openingElement, v, e.isJsxOpeningElement), O(m.children, v, e.isJsxChild), S(m.closingElement, v, e.isJsxClosingElement));
            }, t[282] = function(m, v, g, O, S, te) {
              return g.factory.updateJsxSelfClosingElement(m, S(m.tagName, v, e.isJsxTagNameExpression), O(m.typeArguments, v, e.isTypeNode), S(m.attributes, v, e.isJsxAttributes));
            }, t[283] = function(m, v, g, O, S, te) {
              return g.factory.updateJsxOpeningElement(m, S(m.tagName, v, e.isJsxTagNameExpression), O(m.typeArguments, v, e.isTypeNode), S(m.attributes, v, e.isJsxAttributes));
            }, t[284] = function(m, v, g, O, S, te) {
              return g.factory.updateJsxClosingElement(m, S(m.tagName, v, e.isJsxTagNameExpression));
            }, t[285] = function(m, v, g, O, S, te) {
              return g.factory.updateJsxFragment(m, S(m.openingFragment, v, e.isJsxOpeningFragment), O(m.children, v, e.isJsxChild), S(m.closingFragment, v, e.isJsxClosingFragment));
            }, t[288] = function(m, v, g, O, S, te) {
              return g.factory.updateJsxAttribute(m, S(m.name, v, e.isIdentifier), S(m.initializer, v, e.isStringLiteralOrJsxExpression));
            }, t[289] = function(m, v, g, O, S, te) {
              return g.factory.updateJsxAttributes(m, O(m.properties, v, e.isJsxAttributeLike));
            }, t[290] = function(m, v, g, O, S, te) {
              return g.factory.updateJsxSpreadAttribute(m, S(m.expression, v, e.isExpression));
            }, t[291] = function(m, v, g, O, S, te) {
              return g.factory.updateJsxExpression(m, S(m.expression, v, e.isExpression));
            }, t[292] = function(m, v, g, O, S, te) {
              return g.factory.updateCaseClause(m, S(m.expression, v, e.isExpression), O(m.statements, v, e.isStatement));
            }, t[293] = function(m, v, g, O, S, te) {
              return g.factory.updateDefaultClause(m, O(m.statements, v, e.isStatement));
            }, t[294] = function(m, v, g, O, S, te) {
              return g.factory.updateHeritageClause(m, O(m.types, v, e.isExpressionWithTypeArguments));
            }, t[295] = function(m, v, g, O, S, te) {
              return g.factory.updateCatchClause(m, S(m.variableDeclaration, v, e.isVariableDeclaration), S(m.block, v, e.isBlock));
            }, t[299] = function(m, v, g, O, S, te) {
              return g.factory.updatePropertyAssignment(m, S(m.name, v, e.isPropertyName), S(m.initializer, v, e.isExpression));
            }, t[300] = function(m, v, g, O, S, te) {
              return g.factory.updateShorthandPropertyAssignment(m, S(m.name, v, e.isIdentifier), S(m.objectAssignmentInitializer, v, e.isExpression));
            }, t[301] = function(m, v, g, O, S, te) {
              return g.factory.updateSpreadAssignment(m, S(m.expression, v, e.isExpression));
            }, t[302] = function(m, v, g, O, S, te) {
              return g.factory.updateEnumMember(m, S(m.name, v, e.isPropertyName), S(m.initializer, v, e.isExpression));
            }, t[308] = function(m, v, g, O, S, te) {
              return g.factory.updateSourceFile(m, fe(m.statements, v, g, void 0, void 0, O));
            }, t[353] = function(m, v, g, O, S, te) {
              return g.factory.updatePartiallyEmittedExpression(m, S(m.expression, v, e.isExpression));
            }, t[354] = function(m, v, g, O, S, te) {
              return g.factory.updateCommaListExpression(m, O(m.elements, v, e.isExpression));
            }, t);
            function B(U) {
              return e.Debug.assert(U.length <= 1, "Too many nodes written to output."), e.singleOrUndefined(U);
            }
            __name(B, "B");
          })(N || (N = {}));
          var N;
          (function(e) {
            function t(j) {
              return j = e.getOriginalNode(j), j ? e.getNodeId(j) : 0;
            }
            __name(t, "t");
            e.getOriginalNodeId = t;
            function x(j) {
              return !j || !e.isNamedImports(j) ? false : e.some(j.elements, s);
            }
            __name(x, "x");
            function s(j) {
              return j.propertyName !== void 0 && j.propertyName.escapedText === "default";
            }
            __name(s, "s");
            function q(j, be) {
              return $e;
              function $e(Fe) {
                return Fe.kind === 308 ? be(Fe) : Re(Fe);
              }
              __name($e, "$e");
              function Re(Fe) {
                return j.factory.createBundle(e.map(Fe.sourceFiles, be), Fe.prepends);
              }
              __name(Re, "Re");
            }
            __name(q, "q");
            e.chainBundle = q;
            function F(j) {
              return !!e.getNamespaceDeclarationNode(j);
            }
            __name(F, "F");
            e.getExportNeedsImportStarHelper = F;
            function fe(j) {
              if (e.getNamespaceDeclarationNode(j))
                return true;
              var be = j.importClause && j.importClause.namedBindings;
              if (!be || !e.isNamedImports(be))
                return false;
              for (var $e = 0, Re = 0, Fe = be.elements; Re < Fe.length; Re++) {
                var dr = Fe[Re];
                s(dr) && $e++;
              }
              return $e > 0 && $e !== be.elements.length || !!(be.elements.length - $e) && e.isDefaultImport(j);
            }
            __name(fe, "fe");
            e.getImportNeedsImportStarHelper = fe;
            function Te(j) {
              return !fe(j) && (e.isDefaultImport(j) || !!j.importClause && e.isNamedImports(j.importClause.namedBindings) && x(j.importClause.namedBindings));
            }
            __name(Te, "Te");
            e.getImportNeedsImportDefaultHelper = Te;
            function Se(j, be, $e, Re) {
              for (var Fe = [], dr = e.createMultiMap(), ze = [], ve = new e.Map(), er, ar = false, Cr, Ce = false, Xe = false, gr = false, X = 0, Ee = be.statements; X < Ee.length; X++) {
                var we = Ee[X];
                switch (we.kind) {
                  case 269:
                    Fe.push(we), !Xe && fe(we) && (Xe = true), !gr && Te(we) && (gr = true);
                    break;
                  case 268:
                    we.moduleReference.kind === 280 && Fe.push(we);
                    break;
                  case 275:
                    if (we.moduleSpecifier)
                      if (!we.exportClause)
                        Fe.push(we), Ce = true;
                      else if (Fe.push(we), e.isNamedExports(we.exportClause))
                        Lr(we);
                      else {
                        var he = we.exportClause.name;
                        ve.get(e.idText(he)) || (se(ze, t(we), he), ve.set(e.idText(he), true), er = e.append(er, he)), Xe = true;
                      }
                    else
                      Lr(we);
                    break;
                  case 274:
                    we.isExportEquals && !Cr && (Cr = we);
                    break;
                  case 240:
                    if (e.hasSyntacticModifier(we, 1))
                      for (var yr = 0, kr = we.declarationList.declarations; yr < kr.length; yr++) {
                        var nr = kr[yr];
                        er = J(nr, ve, er);
                      }
                    break;
                  case 259:
                    if (e.hasSyntacticModifier(we, 1))
                      if (e.hasSyntacticModifier(we, 1024))
                        ar || (se(ze, t(we), j.factory.getDeclarationName(we)), ar = true);
                      else {
                        var he = we.name;
                        ve.get(e.idText(he)) || (se(ze, t(we), he), ve.set(e.idText(he), true), er = e.append(er, he));
                      }
                    break;
                  case 260:
                    if (e.hasSyntacticModifier(we, 1))
                      if (e.hasSyntacticModifier(we, 1024))
                        ar || (se(ze, t(we), j.factory.getDeclarationName(we)), ar = true);
                      else {
                        var he = we.name;
                        he && !ve.get(e.idText(he)) && (se(ze, t(we), he), ve.set(e.idText(he), true), er = e.append(er, he));
                      }
                    break;
                }
              }
              var tr = e.createExternalHelpersImportDeclarationIfNeeded(j.factory, j.getEmitHelperFactory(), be, Re, Ce, Xe, gr);
              return tr && Fe.unshift(tr), { externalImports: Fe, exportSpecifiers: dr, exportEquals: Cr, hasExportStarsToExportValues: Ce, exportedBindings: ze, exportedNames: er, externalHelpersImportDeclaration: tr };
              function Lr(zr) {
                for (var ye = 0, ir = e.cast(zr.exportClause, e.isNamedExports).elements; ye < ir.length; ye++) {
                  var Dr = ir[ye];
                  if (!ve.get(e.idText(Dr.name))) {
                    var Pr = Dr.propertyName || Dr.name;
                    zr.moduleSpecifier || dr.add(e.idText(Pr), Dr);
                    var Br = $e.getReferencedImportDeclaration(Pr) || $e.getReferencedValueDeclaration(Pr);
                    Br && se(ze, t(Br), Dr.name), ve.set(e.idText(Dr.name), true), er = e.append(er, Dr.name);
                  }
                }
              }
              __name(Lr, "Lr");
            }
            __name(Se, "Se");
            e.collectExternalModuleInfo = Se;
            function J(j, be, $e) {
              if (e.isBindingPattern(j.name))
                for (var Re = 0, Fe = j.name.elements; Re < Fe.length; Re++) {
                  var dr = Fe[Re];
                  e.isOmittedExpression(dr) || ($e = J(dr, be, $e));
                }
              else if (!e.isGeneratedIdentifier(j.name)) {
                var ze = e.idText(j.name);
                be.get(ze) || (be.set(ze, true), $e = e.append($e, j.name));
              }
              return $e;
            }
            __name(J, "J");
            function se(j, be, $e) {
              var Re = j[be];
              return Re ? Re.push($e) : j[be] = Re = [$e], Re;
            }
            __name(se, "se");
            function Le(j) {
              return e.isStringLiteralLike(j) || j.kind === 8 || e.isKeyword(j.kind) || e.isIdentifier(j);
            }
            __name(Le, "Le");
            e.isSimpleCopiableExpression = Le;
            function Q(j) {
              return !e.isIdentifier(j) && Le(j);
            }
            __name(Q, "Q");
            e.isSimpleInlineableExpression = Q;
            function Be(j) {
              return j >= 64 && j <= 78;
            }
            __name(Be, "Be");
            e.isCompoundAssignment = Be;
            function je(j) {
              switch (j) {
                case 64:
                  return 39;
                case 65:
                  return 40;
                case 66:
                  return 41;
                case 67:
                  return 42;
                case 68:
                  return 43;
                case 69:
                  return 44;
                case 70:
                  return 47;
                case 71:
                  return 48;
                case 72:
                  return 49;
                case 73:
                  return 50;
                case 74:
                  return 51;
                case 78:
                  return 52;
                case 75:
                  return 56;
                case 76:
                  return 55;
                case 77:
                  return 60;
              }
            }
            __name(je, "je");
            e.getNonAssignmentOperatorForCompoundAssignment = je;
            function W(j) {
              if (!!e.isExpressionStatement(j)) {
                var be = e.skipParentheses(j.expression);
                return e.isSuperCall(be) ? be : void 0;
              }
            }
            __name(W, "W");
            e.getSuperCallFromStatement = W;
            function B(j, be) {
              for (var $e = be; $e < j.length; $e += 1) {
                var Re = j[$e];
                if (W(Re))
                  return $e;
              }
              return -1;
            }
            __name(B, "B");
            e.findSuperStatementIndex = B;
            function U(j, be, $e) {
              return e.filter(j.members, function(Re) {
                return g(Re, be, $e);
              });
            }
            __name(U, "U");
            e.getProperties = U;
            function m(j) {
              return O(j) || e.isClassStaticBlockDeclaration(j);
            }
            __name(m, "m");
            function v(j) {
              return e.filter(j.members, m);
            }
            __name(v, "v");
            e.getStaticPropertiesAndClassStaticBlock = v;
            function g(j, be, $e) {
              return e.isPropertyDeclaration(j) && (!!j.initializer || !be) && e.hasStaticModifier(j) === $e;
            }
            __name(g, "g");
            function O(j) {
              return e.isPropertyDeclaration(j) && e.hasStaticModifier(j);
            }
            __name(O, "O");
            function S(j) {
              return j.kind === 169 && j.initializer !== void 0;
            }
            __name(S, "S");
            e.isInitializedProperty = S;
            function te(j) {
              return !e.isStatic(j) && (e.isMethodOrAccessor(j) || e.isAutoAccessorPropertyDeclaration(j)) && e.isPrivateIdentifier(j.name);
            }
            __name(te, "te");
            e.isNonStaticMethodOrAccessorWithPrivateName = te;
            function Je(j) {
              var be;
              if (j)
                for (var $e = j.parameters, Re = $e.length > 0 && e.parameterIsThisKeyword($e[0]), Fe = Re ? 1 : 0, dr = Re ? $e.length - 1 : $e.length, ze = 0; ze < dr; ze++) {
                  var ve = $e[ze + Fe];
                  (be || e.hasDecorators(ve)) && (be || (be = new Array(dr)), be[ze] = e.getDecorators(ve));
                }
              return be;
            }
            __name(Je, "Je");
            function qe(j) {
              var be = e.getDecorators(j), $e = Je(e.getFirstConstructorWithBody(j));
              if (!(!e.some(be) && !e.some($e)))
                return { decorators: be, parameters: $e };
            }
            __name(qe, "qe");
            e.getAllDecoratorsOfClass = qe;
            function ge(j, be) {
              switch (j.kind) {
                case 174:
                case 175:
                  return ie(j, be);
                case 171:
                  return G(j);
                case 169:
                  return pe(j);
                default:
                  return;
              }
            }
            __name(ge, "ge");
            e.getAllDecoratorsOfClassElement = ge;
            function ie(j, be) {
              if (!!j.body) {
                var $e = e.getAllAccessorDeclarations(be.members, j), Re = $e.firstAccessor, Fe = $e.secondAccessor, dr = $e.getAccessor, ze = $e.setAccessor, ve = e.hasDecorators(Re) ? Re : Fe && e.hasDecorators(Fe) ? Fe : void 0;
                if (!(!ve || j !== ve)) {
                  var er = e.getDecorators(ve), ar = Je(ze);
                  if (!(!e.some(er) && !e.some(ar)))
                    return { decorators: er, parameters: ar, getDecorators: dr && e.getDecorators(dr), setDecorators: ze && e.getDecorators(ze) };
                }
              }
            }
            __name(ie, "ie");
            function G(j) {
              if (!!j.body) {
                var be = e.getDecorators(j), $e = Je(j);
                if (!(!e.some(be) && !e.some($e)))
                  return { decorators: be, parameters: $e };
              }
            }
            __name(G, "G");
            function pe(j) {
              var be = e.getDecorators(j);
              if (!!e.some(be))
                return { decorators: be };
            }
            __name(pe, "pe");
          })(N || (N = {}));
          var N;
          (function(e) {
            e.scanner = e.createScanner(99, true);
            var t;
            (function(l) {
              l[l.None = 0] = "None", l[l.Value = 1] = "Value", l[l.Type = 2] = "Type", l[l.Namespace = 4] = "Namespace", l[l.All = 7] = "All";
            })(t = e.SemanticMeaning || (e.SemanticMeaning = {}));
            function x(l) {
              switch (l.kind) {
                case 257:
                  return e.isInJSFile(l) && e.getJSDocEnumTag(l) ? 7 : 1;
                case 166:
                case 205:
                case 169:
                case 168:
                case 299:
                case 300:
                case 171:
                case 170:
                case 173:
                case 174:
                case 175:
                case 259:
                case 215:
                case 216:
                case 295:
                case 288:
                  return 1;
                case 165:
                case 261:
                case 262:
                case 184:
                  return 2;
                case 348:
                  return l.name === void 0 ? 3 : 2;
                case 302:
                case 260:
                  return 3;
                case 264:
                  return e.isAmbientModule(l) || e.getModuleInstanceState(l) === 1 ? 5 : 4;
                case 263:
                case 272:
                case 273:
                case 268:
                case 269:
                case 274:
                case 275:
                  return 7;
                case 308:
                  return 5;
              }
              return 7;
            }
            __name(x, "x");
            e.getMeaningFromDeclaration = x;
            function s(l) {
              l = pt(l);
              var w = l.parent;
              return l.kind === 308 ? 1 : e.isExportAssignment(w) || e.isExportSpecifier(w) || e.isExternalModuleReference(w) || e.isImportSpecifier(w) || e.isImportClause(w) || e.isImportEqualsDeclaration(w) && l === w.name ? 7 : F(l) ? q(l) : e.isDeclarationName(l) ? x(w) : e.isEntityName(l) && e.findAncestor(l, e.or(e.isJSDocNameReference, e.isJSDocLinkLike, e.isJSDocMemberName)) ? 7 : J(l) ? 2 : fe(l) ? 4 : e.isTypeParameterDeclaration(w) ? (e.Debug.assert(e.isJSDocTemplateTag(w.parent)), 2) : e.isLiteralTypeNode(w) ? 3 : 1;
            }
            __name(s, "s");
            e.getMeaningFromLocation = s;
            function q(l) {
              var w = l.kind === 163 ? l : e.isQualifiedName(l.parent) && l.parent.right === l ? l.parent : void 0;
              return w && w.parent.kind === 268 ? 7 : 4;
            }
            __name(q, "q");
            function F(l) {
              for (; l.parent.kind === 163; )
                l = l.parent;
              return e.isInternalModuleImportEqualsDeclaration(l.parent) && l.parent.moduleReference === l;
            }
            __name(F, "F");
            e.isInRightSideOfInternalImportEqualsDeclaration = F;
            function fe(l) {
              return Te(l) || Se(l);
            }
            __name(fe, "fe");
            function Te(l) {
              var w = l, M = true;
              if (w.parent.kind === 163) {
                for (; w.parent && w.parent.kind === 163; )
                  w = w.parent;
                M = w.right === l;
              }
              return w.parent.kind === 180 && !M;
            }
            __name(Te, "Te");
            function Se(l) {
              var w = l, M = true;
              if (w.parent.kind === 208) {
                for (; w.parent && w.parent.kind === 208; )
                  w = w.parent;
                M = w.name === l;
              }
              if (!M && w.parent.kind === 230 && w.parent.parent.kind === 294) {
                var ke = w.parent.parent.parent;
                return ke.kind === 260 && w.parent.parent.token === 117 || ke.kind === 261 && w.parent.parent.token === 94;
              }
              return false;
            }
            __name(Se, "Se");
            function J(l) {
              switch (e.isRightSideOfQualifiedNameOrPropertyAccess(l) && (l = l.parent), l.kind) {
                case 108:
                  return !e.isExpressionNode(l);
                case 194:
                  return true;
              }
              switch (l.parent.kind) {
                case 180:
                  return true;
                case 202:
                  return !l.parent.isTypeOf;
                case 230:
                  return e.isPartOfTypeNode(l.parent);
              }
              return false;
            }
            __name(J, "J");
            function se(l, w, M) {
              return w === void 0 && (w = false), M === void 0 && (M = false), v(l, e.isCallExpression, B, w, M);
            }
            __name(se, "se");
            e.isCallExpressionTarget = se;
            function Le(l, w, M) {
              return w === void 0 && (w = false), M === void 0 && (M = false), v(l, e.isNewExpression, B, w, M);
            }
            __name(Le, "Le");
            e.isNewExpressionTarget = Le;
            function Q(l, w, M) {
              return w === void 0 && (w = false), M === void 0 && (M = false), v(l, e.isCallOrNewExpression, B, w, M);
            }
            __name(Q, "Q");
            e.isCallOrNewExpressionTarget = Q;
            function Be(l, w, M) {
              return w === void 0 && (w = false), M === void 0 && (M = false), v(l, e.isTaggedTemplateExpression, U, w, M);
            }
            __name(Be, "Be");
            e.isTaggedTemplateTag = Be;
            function je(l, w, M) {
              return w === void 0 && (w = false), M === void 0 && (M = false), v(l, e.isDecorator, B, w, M);
            }
            __name(je, "je");
            e.isDecoratorTarget = je;
            function W(l, w, M) {
              return w === void 0 && (w = false), M === void 0 && (M = false), v(l, e.isJsxOpeningLikeElement, m, w, M);
            }
            __name(W, "W");
            e.isJsxOpeningLikeElementTagName = W;
            function B(l) {
              return l.expression;
            }
            __name(B, "B");
            function U(l) {
              return l.tag;
            }
            __name(U, "U");
            function m(l) {
              return l.tagName;
            }
            __name(m, "m");
            function v(l, w, M, ke, cr) {
              var Zr = ke ? O(l) : g(l);
              return cr && (Zr = e.skipOuterExpressions(Zr)), !!Zr && !!Zr.parent && w(Zr.parent) && M(Zr.parent) === Zr;
            }
            __name(v, "v");
            function g(l) {
              return pe(l) ? l.parent : l;
            }
            __name(g, "g");
            e.climbPastPropertyAccess = g;
            function O(l) {
              return pe(l) || j(l) ? l.parent : l;
            }
            __name(O, "O");
            e.climbPastPropertyOrElementAccess = O;
            function S(l, w) {
              for (; l; ) {
                if (l.kind === 253 && l.label.escapedText === w)
                  return l.label;
                l = l.parent;
              }
            }
            __name(S, "S");
            e.getTargetLabel = S;
            function te(l, w) {
              return e.isPropertyAccessExpression(l.expression) ? l.expression.name.text === w : false;
            }
            __name(te, "te");
            e.hasPropertyAccessExpressionWithName = te;
            function Je(l) {
              var w;
              return e.isIdentifier(l) && ((w = e.tryCast(l.parent, e.isBreakOrContinueStatement)) === null || w === void 0 ? void 0 : w.label) === l;
            }
            __name(Je, "Je");
            e.isJumpStatementTarget = Je;
            function qe(l) {
              var w;
              return e.isIdentifier(l) && ((w = e.tryCast(l.parent, e.isLabeledStatement)) === null || w === void 0 ? void 0 : w.label) === l;
            }
            __name(qe, "qe");
            e.isLabelOfLabeledStatement = qe;
            function ge(l) {
              return qe(l) || Je(l);
            }
            __name(ge, "ge");
            e.isLabelName = ge;
            function ie(l) {
              var w;
              return ((w = e.tryCast(l.parent, e.isJSDocTag)) === null || w === void 0 ? void 0 : w.tagName) === l;
            }
            __name(ie, "ie");
            e.isTagName = ie;
            function G(l) {
              var w;
              return ((w = e.tryCast(l.parent, e.isQualifiedName)) === null || w === void 0 ? void 0 : w.right) === l;
            }
            __name(G, "G");
            e.isRightSideOfQualifiedName = G;
            function pe(l) {
              var w;
              return ((w = e.tryCast(l.parent, e.isPropertyAccessExpression)) === null || w === void 0 ? void 0 : w.name) === l;
            }
            __name(pe, "pe");
            e.isRightSideOfPropertyAccess = pe;
            function j(l) {
              var w;
              return ((w = e.tryCast(l.parent, e.isElementAccessExpression)) === null || w === void 0 ? void 0 : w.argumentExpression) === l;
            }
            __name(j, "j");
            e.isArgumentExpressionOfElementAccess = j;
            function be(l) {
              var w;
              return ((w = e.tryCast(l.parent, e.isModuleDeclaration)) === null || w === void 0 ? void 0 : w.name) === l;
            }
            __name(be, "be");
            e.isNameOfModuleDeclaration = be;
            function $e(l) {
              var w;
              return e.isIdentifier(l) && ((w = e.tryCast(l.parent, e.isFunctionLike)) === null || w === void 0 ? void 0 : w.name) === l;
            }
            __name($e, "$e");
            e.isNameOfFunctionDeclaration = $e;
            function Re(l) {
              switch (l.parent.kind) {
                case 169:
                case 168:
                case 299:
                case 302:
                case 171:
                case 170:
                case 174:
                case 175:
                case 264:
                  return e.getNameOfDeclaration(l.parent) === l;
                case 209:
                  return l.parent.argumentExpression === l;
                case 164:
                  return true;
                case 198:
                  return l.parent.parent.kind === 196;
                default:
                  return false;
              }
            }
            __name(Re, "Re");
            e.isLiteralNameOfPropertyDeclarationOrIndexAccess = Re;
            function Fe(l) {
              return e.isExternalModuleImportEqualsDeclaration(l.parent.parent) && e.getExternalModuleImportEqualsDeclarationExpression(l.parent.parent) === l;
            }
            __name(Fe, "Fe");
            e.isExpressionOfExternalModuleImportEqualsDeclaration = Fe;
            function dr(l) {
              for (e.isJSDocTypeAlias(l) && (l = l.parent.parent); ; ) {
                if (l = l.parent, !l)
                  return;
                switch (l.kind) {
                  case 308:
                  case 171:
                  case 170:
                  case 259:
                  case 215:
                  case 174:
                  case 175:
                  case 260:
                  case 261:
                  case 263:
                  case 264:
                    return l;
                }
              }
            }
            __name(dr, "dr");
            e.getContainerNode = dr;
            function ze(l) {
              switch (l.kind) {
                case 308:
                  return e.isExternalModule(l) ? "module" : "script";
                case 264:
                  return "module";
                case 260:
                case 228:
                  return "class";
                case 261:
                  return "interface";
                case 262:
                case 341:
                case 348:
                  return "type";
                case 263:
                  return "enum";
                case 257:
                  return _t(l);
                case 205:
                  return _t(e.getRootDeclaration(l));
                case 216:
                case 259:
                case 215:
                  return "function";
                case 174:
                  return "getter";
                case 175:
                  return "setter";
                case 171:
                case 170:
                  return "method";
                case 299:
                  var w = l.initializer;
                  return e.isFunctionLike(w) ? "method" : "property";
                case 169:
                case 168:
                case 300:
                case 301:
                  return "property";
                case 178:
                  return "index";
                case 177:
                  return "construct";
                case 176:
                  return "call";
                case 173:
                case 172:
                  return "constructor";
                case 165:
                  return "type parameter";
                case 302:
                  return "enum member";
                case 166:
                  return e.hasSyntacticModifier(l, 16476) ? "property" : "parameter";
                case 268:
                case 273:
                case 278:
                case 271:
                case 277:
                  return "alias";
                case 223:
                  var M = e.getAssignmentDeclarationKind(l), ke = l.right;
                  switch (M) {
                    case 7:
                    case 8:
                    case 9:
                    case 0:
                      return "";
                    case 1:
                    case 2:
                      var cr = ze(ke);
                      return cr === "" ? "const" : cr;
                    case 3:
                      return e.isFunctionExpression(ke) ? "method" : "property";
                    case 4:
                      return "property";
                    case 5:
                      return e.isFunctionExpression(ke) ? "method" : "property";
                    case 6:
                      return "local class";
                    default:
                      return e.assertType(M), "";
                  }
                case 79:
                  return e.isImportClause(l.parent) ? "alias" : "";
                case 274:
                  var Zr = ze(l.expression);
                  return Zr === "" ? "const" : Zr;
                default:
                  return "";
              }
              function _t(Rt) {
                return e.isVarConst(Rt) ? "const" : e.isLet(Rt) ? "let" : "var";
              }
              __name(_t, "_t");
            }
            __name(ze, "ze");
            e.getNodeKind = ze;
            function ve(l) {
              switch (l.kind) {
                case 108:
                  return true;
                case 79:
                  return e.identifierIsThisKeyword(l) && l.parent.kind === 166;
                default:
                  return false;
              }
            }
            __name(ve, "ve");
            e.isThis = ve;
            var er = /^\/\/\/\s*</;
            function ar(l, w) {
              var M = e.getLineStarts(w), ke = w.getLineAndCharacterOfPosition(l).line;
              return M[ke];
            }
            __name(ar, "ar");
            e.getLineStartPositionForPosition = ar;
            function Cr(l, w) {
              return X(l.pos, l.end, w);
            }
            __name(Cr, "Cr");
            e.rangeContainsRange = Cr;
            function Ce(l, w) {
              return gr(l, w.pos) && gr(l, w.end);
            }
            __name(Ce, "Ce");
            e.rangeContainsRangeExclusive = Ce;
            function Xe(l, w) {
              return l.pos <= w && w <= l.end;
            }
            __name(Xe, "Xe");
            e.rangeContainsPosition = Xe;
            function gr(l, w) {
              return l.pos < w && w < l.end;
            }
            __name(gr, "gr");
            e.rangeContainsPositionExclusive = gr;
            function X(l, w, M) {
              return l <= M.pos && w >= M.end;
            }
            __name(X, "X");
            e.startEndContainsRange = X;
            function Ee(l, w, M) {
              return l.pos <= w && l.end >= M;
            }
            __name(Ee, "Ee");
            e.rangeContainsStartEnd = Ee;
            function we(l, w, M) {
              return yr(l.pos, l.end, w, M);
            }
            __name(we, "we");
            e.rangeOverlapsWithStartEnd = we;
            function he(l, w, M, ke) {
              return yr(l.getStart(w), l.end, M, ke);
            }
            __name(he, "he");
            e.nodeOverlapsWithStartEnd = he;
            function yr(l, w, M, ke) {
              var cr = Math.max(l, M), Zr = Math.min(w, ke);
              return cr < Zr;
            }
            __name(yr, "yr");
            e.startEndOverlapsWithStartEnd = yr;
            function kr(l, w, M) {
              return e.Debug.assert(l.pos <= w), w < l.end || !nr(l, M);
            }
            __name(kr, "kr");
            e.positionBelongsToNode = kr;
            function nr(l, w) {
              if (l === void 0 || e.nodeIsMissing(l))
                return false;
              switch (l.kind) {
                case 260:
                case 261:
                case 263:
                case 207:
                case 203:
                case 184:
                case 238:
                case 265:
                case 266:
                case 272:
                case 276:
                  return tr(l, 19, w);
                case 295:
                  return nr(l.block, w);
                case 211:
                  if (!l.arguments)
                    return true;
                case 210:
                case 214:
                case 193:
                  return tr(l, 21, w);
                case 181:
                case 182:
                  return nr(l.type, w);
                case 173:
                case 174:
                case 175:
                case 259:
                case 215:
                case 171:
                case 170:
                case 177:
                case 176:
                case 216:
                  return l.body ? nr(l.body, w) : l.type ? nr(l.type, w) : zr(l, 21, w);
                case 264:
                  return !!l.body && nr(l.body, w);
                case 242:
                  return l.elseStatement ? nr(l.elseStatement, w) : nr(l.thenStatement, w);
                case 241:
                  return nr(l.expression, w) || zr(l, 26, w);
                case 206:
                case 204:
                case 209:
                case 164:
                case 186:
                  return tr(l, 23, w);
                case 178:
                  return l.type ? nr(l.type, w) : zr(l, 23, w);
                case 292:
                case 293:
                  return false;
                case 245:
                case 246:
                case 247:
                case 244:
                  return nr(l.statement, w);
                case 243:
                  return zr(l, 115, w) ? tr(l, 21, w) : nr(l.statement, w);
                case 183:
                  return nr(l.exprName, w);
                case 218:
                case 217:
                case 219:
                case 226:
                case 227:
                  var M = l;
                  return nr(M.expression, w);
                case 212:
                  return nr(l.template, w);
                case 225:
                  var ke = e.lastOrUndefined(l.templateSpans);
                  return nr(ke, w);
                case 236:
                  return e.nodeIsPresent(l.literal);
                case 275:
                case 269:
                  return e.nodeIsPresent(l.moduleSpecifier);
                case 221:
                  return nr(l.operand, w);
                case 223:
                  return nr(l.right, w);
                case 224:
                  return nr(l.whenFalse, w);
                default:
                  return true;
              }
            }
            __name(nr, "nr");
            function tr(l, w, M) {
              var ke = l.getChildren(M);
              if (ke.length) {
                var cr = e.last(ke);
                if (cr.kind === w)
                  return true;
                if (cr.kind === 26 && ke.length !== 1)
                  return ke[ke.length - 2].kind === w;
              }
              return false;
            }
            __name(tr, "tr");
            function Lr(l) {
              var w = ir(l);
              if (!!w) {
                var M = w.getChildren(), ke = e.indexOfNode(M, l);
                return { listItemIndex: ke, list: w };
              }
            }
            __name(Lr, "Lr");
            e.findListItemInfo = Lr;
            function zr(l, w, M) {
              return !!ye(l, w, M);
            }
            __name(zr, "zr");
            e.hasChildOfKind = zr;
            function ye(l, w, M) {
              return e.find(l.getChildren(M), function(ke) {
                return ke.kind === w;
              });
            }
            __name(ye, "ye");
            e.findChildOfKind = ye;
            function ir(l) {
              var w = e.find(l.parent.getChildren(), function(M) {
                return e.isSyntaxList(M) && Cr(M, l);
              });
              return e.Debug.assert(!w || e.contains(w.getChildren(), l)), w;
            }
            __name(ir, "ir");
            e.findContainingList = ir;
            function Dr(l) {
              return l.kind === 88;
            }
            __name(Dr, "Dr");
            function Pr(l) {
              return l.kind === 84;
            }
            __name(Pr, "Pr");
            function Br(l) {
              return l.kind === 98;
            }
            __name(Br, "Br");
            function ut(l) {
              if (e.isNamedDeclaration(l))
                return l.name;
              if (e.isClassDeclaration(l)) {
                var w = l.modifiers && e.find(l.modifiers, Dr);
                if (w)
                  return w;
              }
              if (e.isClassExpression(l)) {
                var M = e.find(l.getChildren(), Pr);
                if (M)
                  return M;
              }
            }
            __name(ut, "ut");
            function rt(l) {
              if (e.isNamedDeclaration(l))
                return l.name;
              if (e.isFunctionDeclaration(l)) {
                var w = e.find(l.modifiers, Dr);
                if (w)
                  return w;
              }
              if (e.isFunctionExpression(l)) {
                var M = e.find(l.getChildren(), Br);
                if (M)
                  return M;
              }
            }
            __name(rt, "rt");
            function Z(l) {
              var w;
              return e.findAncestor(l, function(M) {
                return e.isTypeNode(M) && (w = M), !e.isQualifiedName(M.parent) && !e.isTypeNode(M.parent) && !e.isTypeElement(M.parent);
              }), w;
            }
            __name(Z, "Z");
            function f(l, w) {
              if (!(l.flags & 8388608)) {
                var M = or(l, w);
                if (M)
                  return M;
                var ke = Z(l);
                return ke && w.getTypeAtLocation(ke);
              }
            }
            __name(f, "f");
            e.getContextualTypeFromParentOrAncestorTypeNode = f;
            function h(l, w) {
              if (!w)
                switch (l.kind) {
                  case 260:
                  case 228:
                    return ut(l);
                  case 259:
                  case 215:
                    return rt(l);
                  case 173:
                    return l;
                }
              if (e.isNamedDeclaration(l))
                return l.name;
            }
            __name(h, "h");
            function ae(l, w) {
              if (l.importClause) {
                if (l.importClause.name && l.importClause.namedBindings)
                  return;
                if (l.importClause.name)
                  return l.importClause.name;
                if (l.importClause.namedBindings) {
                  if (e.isNamedImports(l.importClause.namedBindings)) {
                    var M = e.singleOrUndefined(l.importClause.namedBindings.elements);
                    return M ? M.name : void 0;
                  } else if (e.isNamespaceImport(l.importClause.namedBindings))
                    return l.importClause.namedBindings.name;
                }
              }
              if (!w)
                return l.moduleSpecifier;
            }
            __name(ae, "ae");
            function xr(l, w) {
              if (l.exportClause) {
                if (e.isNamedExports(l.exportClause)) {
                  var M = e.singleOrUndefined(l.exportClause.elements);
                  return M ? l.exportClause.elements[0].name : void 0;
                } else if (e.isNamespaceExport(l.exportClause))
                  return l.exportClause.name;
              }
              if (!w)
                return l.moduleSpecifier;
            }
            __name(xr, "xr");
            function jr(l) {
              if (l.types.length === 1)
                return l.types[0].expression;
            }
            __name(jr, "jr");
            function qr(l, w) {
              var M = l.parent;
              if (e.isModifier(l) && (w || l.kind !== 88) ? e.canHaveModifiers(M) && e.contains(M.modifiers, l) : l.kind === 84 ? e.isClassDeclaration(M) || e.isClassExpression(l) : l.kind === 98 ? e.isFunctionDeclaration(M) || e.isFunctionExpression(l) : l.kind === 118 ? e.isInterfaceDeclaration(M) : l.kind === 92 ? e.isEnumDeclaration(M) : l.kind === 154 ? e.isTypeAliasDeclaration(M) : l.kind === 143 || l.kind === 142 ? e.isModuleDeclaration(M) : l.kind === 100 ? e.isImportEqualsDeclaration(M) : l.kind === 137 ? e.isGetAccessorDeclaration(M) : l.kind === 151 && e.isSetAccessorDeclaration(M)) {
                var ke = h(M, w);
                if (ke)
                  return ke;
              }
              if ((l.kind === 113 || l.kind === 85 || l.kind === 119) && e.isVariableDeclarationList(M) && M.declarations.length === 1) {
                var cr = M.declarations[0];
                if (e.isIdentifier(cr.name))
                  return cr.name;
              }
              if (l.kind === 154) {
                if (e.isImportClause(M) && M.isTypeOnly) {
                  var ke = ae(M.parent, w);
                  if (ke)
                    return ke;
                }
                if (e.isExportDeclaration(M) && M.isTypeOnly) {
                  var ke = xr(M, w);
                  if (ke)
                    return ke;
                }
              }
              if (l.kind === 128) {
                if (e.isImportSpecifier(M) && M.propertyName || e.isExportSpecifier(M) && M.propertyName || e.isNamespaceImport(M) || e.isNamespaceExport(M))
                  return M.name;
                if (e.isExportDeclaration(M) && M.exportClause && e.isNamespaceExport(M.exportClause))
                  return M.exportClause.name;
              }
              if (l.kind === 100 && e.isImportDeclaration(M)) {
                var ke = ae(M, w);
                if (ke)
                  return ke;
              }
              if (l.kind === 93) {
                if (e.isExportDeclaration(M)) {
                  var ke = xr(M, w);
                  if (ke)
                    return ke;
                }
                if (e.isExportAssignment(M))
                  return e.skipOuterExpressions(M.expression);
              }
              if (l.kind === 147 && e.isExternalModuleReference(M))
                return M.expression;
              if (l.kind === 158 && (e.isImportDeclaration(M) || e.isExportDeclaration(M)) && M.moduleSpecifier)
                return M.moduleSpecifier;
              if ((l.kind === 94 || l.kind === 117) && e.isHeritageClause(M) && M.token === l.kind) {
                var ke = jr(M);
                if (ke)
                  return ke;
              }
              if (l.kind === 94) {
                if (e.isTypeParameterDeclaration(M) && M.constraint && e.isTypeReferenceNode(M.constraint))
                  return M.constraint.typeName;
                if (e.isConditionalTypeNode(M) && e.isTypeReferenceNode(M.extendsType))
                  return M.extendsType.typeName;
              }
              if (l.kind === 138 && e.isInferTypeNode(M))
                return M.typeParameter.name;
              if (l.kind === 101 && e.isTypeParameterDeclaration(M) && e.isMappedTypeNode(M.parent))
                return M.name;
              if (l.kind === 141 && e.isTypeOperatorNode(M) && M.operator === 141 && e.isTypeReferenceNode(M.type))
                return M.type.typeName;
              if (l.kind === 146 && e.isTypeOperatorNode(M) && M.operator === 146 && e.isArrayTypeNode(M.type) && e.isTypeReferenceNode(M.type.elementType))
                return M.type.elementType.typeName;
              if (!w) {
                if ((l.kind === 103 && e.isNewExpression(M) || l.kind === 114 && e.isVoidExpression(M) || l.kind === 112 && e.isTypeOfExpression(M) || l.kind === 133 && e.isAwaitExpression(M) || l.kind === 125 && e.isYieldExpression(M) || l.kind === 89 && e.isDeleteExpression(M)) && M.expression)
                  return e.skipOuterExpressions(M.expression);
                if ((l.kind === 101 || l.kind === 102) && e.isBinaryExpression(M) && M.operatorToken === l)
                  return e.skipOuterExpressions(M.right);
                if (l.kind === 128 && e.isAsExpression(M) && e.isTypeReferenceNode(M.type))
                  return M.type.typeName;
                if (l.kind === 101 && e.isForInStatement(M) || l.kind === 162 && e.isForOfStatement(M))
                  return e.skipOuterExpressions(M.expression);
              }
              return l;
            }
            __name(qr, "qr");
            function pt(l) {
              return qr(l, false);
            }
            __name(pt, "pt");
            e.getAdjustedReferenceLocation = pt;
            function Ge(l) {
              return qr(l, true);
            }
            __name(Ge, "Ge");
            e.getAdjustedRenameLocation = Ge;
            function K(l, w) {
              return r(l, w, function(M) {
                return e.isPropertyNameLiteral(M) || e.isKeyword(M.kind) || e.isPrivateIdentifier(M);
              });
            }
            __name(K, "K");
            e.getTouchingPropertyName = K;
            function r(l, w, M) {
              return ft(l, w, false, M, false);
            }
            __name(r, "r");
            e.getTouchingToken = r;
            function ct(l, w) {
              return ft(l, w, true, void 0, false);
            }
            __name(ct, "ct");
            e.getTokenAtPosition = ct;
            function ft(l, w, M, ke, cr) {
              var Zr = l, _t, Rt = /* @__PURE__ */ __name(function() {
                var _n = Zr.getChildren(l), Nt = e.binarySearchKey(_n, w, function(Ft, Sn) {
                  return Sn;
                }, function(Ft, Sn) {
                  var wn = _n[Ft].getEnd();
                  if (wn < w)
                    return -1;
                  var Wn = M ? _n[Ft].getFullStart() : _n[Ft].getStart(l, true);
                  return Wn > w ? 1 : bn(_n[Ft], Wn, wn) ? _n[Ft - 1] && bn(_n[Ft - 1]) ? 1 : 0 : ke && Wn === w && _n[Ft - 1] && _n[Ft - 1].getEnd() === w && bn(_n[Ft - 1]) ? 1 : -1;
                });
                return _t ? { value: _t } : Nt >= 0 && _n[Nt] ? (Zr = _n[Nt], "continue-outer") : { value: Zr };
              }, "Rt");
              e:
                for (; ; ) {
                  var un = Rt();
                  if (typeof un == "object")
                    return un.value;
                  switch (un) {
                    case "continue-outer":
                      continue e;
                  }
                }
              function bn(_n, Nt, Ft) {
                if (Ft != null || (Ft = _n.getEnd()), Ft < w || (Nt != null || (Nt = M ? _n.getFullStart() : _n.getStart(l, true)), Nt > w))
                  return false;
                if (w < Ft || w === Ft && (_n.kind === 1 || cr))
                  return true;
                if (ke && Ft === w) {
                  var Sn = Ye(w, l, _n);
                  if (Sn && ke(Sn))
                    return _t = Sn, true;
                }
                return false;
              }
              __name(bn, "bn");
            }
            __name(ft, "ft");
            function Ie(l, w) {
              for (var M = ct(l, w); At(M); ) {
                var ke = xe(M, M.parent, l);
                if (!ke)
                  return;
                M = ke;
              }
              return M;
            }
            __name(Ie, "Ie");
            e.findFirstNonJsxWhitespaceToken = Ie;
            function me(l, w) {
              var M = ct(l, w);
              return e.isToken(M) && w > M.getStart(l) && w < M.getEnd() ? M : Ye(w, l);
            }
            __name(me, "me");
            e.findTokenOnLeftOfPosition = me;
            function xe(l, w, M) {
              return ke(w);
              function ke(cr) {
                return e.isToken(cr) && cr.pos === l.end ? cr : e.firstDefined(cr.getChildren(M), function(Zr) {
                  var _t = Zr.pos <= l.pos && Zr.end > l.end || Zr.pos === l.end;
                  return _t && mt(Zr, M) ? ke(Zr) : void 0;
                });
              }
              __name(ke, "ke");
            }
            __name(xe, "xe");
            e.findNextToken = xe;
            function Ye(l, w, M, ke) {
              var cr = Zr(M || w);
              return e.Debug.assert(!(cr && At(cr))), cr;
              function Zr(_t) {
                if (vr(_t) && _t.kind !== 1)
                  return _t;
                var Rt = _t.getChildren(w), un = e.binarySearchKey(Rt, l, function(wn, Wn) {
                  return Wn;
                }, function(wn, Wn) {
                  return l < Rt[wn].end ? !Rt[wn - 1] || l >= Rt[wn - 1].end ? 0 : 1 : -1;
                });
                if (un >= 0 && Rt[un]) {
                  var bn = Rt[un];
                  if (l < bn.end) {
                    var _n = bn.getStart(w, !ke), Nt = _n >= l || !mt(bn, w) || At(bn);
                    if (Nt) {
                      var Ft = pr(Rt, un, w, _t.kind);
                      return Ft && nt(Ft, w);
                    } else
                      return Zr(bn);
                  }
                }
                e.Debug.assert(M !== void 0 || _t.kind === 308 || _t.kind === 1 || e.isJSDocCommentContainingNode(_t));
                var Sn = pr(Rt, Rt.length, w, _t.kind);
                return Sn && nt(Sn, w);
              }
              __name(Zr, "Zr");
            }
            __name(Ye, "Ye");
            e.findPrecedingToken = Ye;
            function vr(l) {
              return e.isToken(l) && !At(l);
            }
            __name(vr, "vr");
            function nt(l, w) {
              if (vr(l))
                return l;
              var M = l.getChildren(w);
              if (M.length === 0)
                return l;
              var ke = pr(M, M.length, w, l.kind);
              return ke && nt(ke, w);
            }
            __name(nt, "nt");
            function pr(l, w, M, ke) {
              for (var cr = w - 1; cr >= 0; cr--) {
                var Zr = l[cr];
                if (At(Zr))
                  cr === 0 && (ke === 11 || ke === 282) && e.Debug.fail("`JsxText` tokens should not be the first child of `JsxElement | JsxSelfClosingElement`");
                else if (mt(l[cr], M))
                  return l[cr];
              }
            }
            __name(pr, "pr");
            function Mr(l, w, M) {
              if (M === void 0 && (M = Ye(w, l)), M && e.isStringTextContainingNode(M)) {
                var ke = M.getStart(l), cr = M.getEnd();
                if (ke < w && w < cr)
                  return true;
                if (w === cr)
                  return !!M.isUnterminated;
              }
              return false;
            }
            __name(Mr, "Mr");
            e.isInString = Mr;
            function ot(l, w) {
              var M = ct(l, w);
              return M ? !!(M.kind === 11 || M.kind === 29 && M.parent.kind === 11 || M.kind === 29 && M.parent.kind === 291 || M && M.kind === 19 && M.parent.kind === 291 || M.kind === 29 && M.parent.kind === 284) : false;
            }
            __name(ot, "ot");
            e.isInsideJsxElementOrAttribute = ot;
            function At(l) {
              return e.isJsxText(l) && l.containsOnlyTriviaWhiteSpaces;
            }
            __name(At, "At");
            function re(l, w) {
              var M = ct(l, w);
              return e.isTemplateLiteralKind(M.kind) && w > M.getStart(l);
            }
            __name(re, "re");
            e.isInTemplateString = re;
            function de(l, w) {
              var M = ct(l, w);
              return !!(e.isJsxText(M) || M.kind === 18 && e.isJsxExpression(M.parent) && e.isJsxElement(M.parent.parent) || M.kind === 29 && e.isJsxOpeningLikeElement(M.parent) && e.isJsxElement(M.parent.parent));
            }
            __name(de, "de");
            e.isInJSXText = de;
            function He(l, w) {
              function M(ke) {
                for (; ke; )
                  if (ke.kind >= 282 && ke.kind <= 291 || ke.kind === 11 || ke.kind === 29 || ke.kind === 31 || ke.kind === 79 || ke.kind === 19 || ke.kind === 18 || ke.kind === 43)
                    ke = ke.parent;
                  else if (ke.kind === 281) {
                    if (w > ke.getStart(l))
                      return true;
                    ke = ke.parent;
                  } else
                    return false;
                return false;
              }
              __name(M, "M");
              return M(ct(l, w));
            }
            __name(He, "He");
            e.isInsideJsxElement = He;
            function Nr(l, w, M) {
              var ke = e.tokenToString(l.kind), cr = e.tokenToString(w), Zr = l.getFullStart(), _t = M.text.lastIndexOf(cr, Zr);
              if (_t !== -1) {
                if (M.text.lastIndexOf(ke, Zr - 1) < _t) {
                  var Rt = Ye(_t + 1, M);
                  if (Rt && Rt.kind === w)
                    return Rt;
                }
                for (var un = l.kind, bn = 0; ; ) {
                  var _n = Ye(l.getFullStart(), M);
                  if (!_n)
                    return;
                  if (l = _n, l.kind === w) {
                    if (bn === 0)
                      return l;
                    bn--;
                  } else
                    l.kind === un && bn++;
                }
              }
            }
            __name(Nr, "Nr");
            e.findPrecedingMatchingToken = Nr;
            function Yr(l, w, M) {
              return w ? l.getNonNullableType() : M ? l.getNonOptionalType() : l;
            }
            __name(Yr, "Yr");
            e.removeOptionality = Yr;
            function St(l, w, M) {
              var ke = Lt(l, w);
              return ke !== void 0 && (e.isPartOfTypeNode(ke.called) || Dt(ke.called, ke.nTypeArguments, M).length !== 0 || St(ke.called, w, M));
            }
            __name(St, "St");
            e.isPossiblyTypeArgumentPosition = St;
            function Dt(l, w, M) {
              var ke = M.getTypeAtLocation(l);
              e.isOptionalChain(l.parent) && (ke = Yr(ke, e.isOptionalChainRoot(l.parent), true));
              var cr = e.isNewExpression(l.parent) ? ke.getConstructSignatures() : ke.getCallSignatures();
              return cr.filter(function(Zr) {
                return !!Zr.typeParameters && Zr.typeParameters.length >= w;
              });
            }
            __name(Dt, "Dt");
            e.getPossibleGenericSignatures = Dt;
            function Lt(l, w) {
              if (w.text.lastIndexOf("<", l ? l.pos : w.text.length) !== -1)
                for (var M = l, ke = 0, cr = 0; M; ) {
                  switch (M.kind) {
                    case 29:
                      if (M = Ye(M.getFullStart(), w), M && M.kind === 28 && (M = Ye(M.getFullStart(), w)), !M || !e.isIdentifier(M))
                        return;
                      if (!ke)
                        return e.isDeclarationName(M) ? void 0 : { called: M, nTypeArguments: cr };
                      ke--;
                      break;
                    case 49:
                      ke = 3;
                      break;
                    case 48:
                      ke = 2;
                      break;
                    case 31:
                      ke++;
                      break;
                    case 19:
                      if (M = Nr(M, 18, w), !M)
                        return;
                      break;
                    case 21:
                      if (M = Nr(M, 20, w), !M)
                        return;
                      break;
                    case 23:
                      if (M = Nr(M, 22, w), !M)
                        return;
                      break;
                    case 27:
                      cr++;
                      break;
                    case 38:
                    case 79:
                    case 10:
                    case 8:
                    case 9:
                    case 110:
                    case 95:
                    case 112:
                    case 94:
                    case 141:
                    case 24:
                    case 51:
                    case 57:
                    case 58:
                      break;
                    default:
                      if (e.isTypeNode(M))
                        break;
                      return;
                  }
                  M = Ye(M.getFullStart(), w);
                }
            }
            __name(Lt, "Lt");
            e.getPossibleTypeArgumentsInfo = Lt;
            function zt(l, w, M) {
              return e.formatting.getRangeOfEnclosingComment(l, w, void 0, M);
            }
            __name(zt, "zt");
            e.isInComment = zt;
            function Zt(l, w) {
              var M = ct(l, w);
              return !!e.findAncestor(M, e.isJSDoc);
            }
            __name(Zt, "Zt");
            e.hasDocComment = Zt;
            function mt(l, w) {
              return l.kind === 1 ? !!l.jsDoc : l.getWidth(w) !== 0;
            }
            __name(mt, "mt");
            function at(l, w) {
              w === void 0 && (w = 0);
              var M = [], ke = e.isDeclaration(l) ? e.getCombinedNodeFlagsAlwaysIncludeJSDoc(l) & ~w : 0;
              return ke & 8 && M.push("private"), ke & 16 && M.push("protected"), ke & 4 && M.push("public"), (ke & 32 || e.isClassStaticBlockDeclaration(l)) && M.push("static"), ke & 256 && M.push("abstract"), ke & 1 && M.push("export"), ke & 8192 && M.push("deprecated"), l.flags & 16777216 && M.push("declare"), l.kind === 274 && M.push("export"), M.length > 0 ? M.join(",") : "";
            }
            __name(at, "at");
            e.getNodeModifiers = at;
            function k(l) {
              if (l.kind === 180 || l.kind === 210)
                return l.typeArguments;
              if (e.isFunctionLike(l) || l.kind === 260 || l.kind === 261)
                return l.typeParameters;
            }
            __name(k, "k");
            e.getTypeArgumentOrTypeParameterList = k;
            function ue(l) {
              return l === 2 || l === 3;
            }
            __name(ue, "ue");
            e.isComment = ue;
            function Qe(l) {
              return !!(l === 10 || l === 13 || e.isTemplateLiteralKind(l));
            }
            __name(Qe, "Qe");
            e.isStringOrRegularExpressionOrTemplateLiteral = Qe;
            function Sr(l) {
              return 18 <= l && l <= 78;
            }
            __name(Sr, "Sr");
            e.isPunctuation = Sr;
            function Kr(l, w, M) {
              return e.isTemplateLiteralKind(l.kind) && l.getStart(M) < w && w < l.end || !!l.isUnterminated && w === l.end;
            }
            __name(Kr, "Kr");
            e.isInsideTemplateLiteral = Kr;
            function Hr(l) {
              switch (l) {
                case 123:
                case 121:
                case 122:
                  return true;
              }
              return false;
            }
            __name(Hr, "Hr");
            e.isAccessibilityModifier = Hr;
            function Ct(l) {
              var w = e.clone(l);
              return e.setConfigFileInOptions(w, l && l.configFile), w;
            }
            __name(Ct, "Ct");
            e.cloneCompilerOptions = Ct;
            function Xt(l) {
              return !!((l.kind === 206 || l.kind === 207) && (l.parent.kind === 223 && l.parent.left === l && l.parent.operatorToken.kind === 63 || l.parent.kind === 247 && l.parent.initializer === l || Xt(l.parent.kind === 299 ? l.parent.parent : l.parent)));
            }
            __name(Xt, "Xt");
            e.isArrayLiteralOrObjectLiteralDestructuringPattern = Xt;
            function cn(l, w) {
              return yn(l, w, true);
            }
            __name(cn, "cn");
            e.isInReferenceComment = cn;
            function In(l, w) {
              return yn(l, w, false);
            }
            __name(In, "In");
            e.isInNonReferenceComment = In;
            function yn(l, w, M) {
              var ke = zt(l, w, void 0);
              return !!ke && M === er.test(l.text.substring(ke.pos, ke.end));
            }
            __name(yn, "yn");
            function hn(l) {
              if (!!l)
                switch (l.kind) {
                  case 10:
                  case 14:
                    return En(l);
                  default:
                    return ln(l);
                }
            }
            __name(hn, "hn");
            e.getReplacementSpanForContextToken = hn;
            function ln(l, w, M) {
              return e.createTextSpanFromBounds(l.getStart(w), (M || l).getEnd());
            }
            __name(ln, "ln");
            e.createTextSpanFromNode = ln;
            function En(l) {
              if (!l.isUnterminated)
                return e.createTextSpanFromBounds(l.getStart() + 1, l.getEnd() - 1);
            }
            __name(En, "En");
            e.createTextSpanFromStringLiteralLikeContent = En;
            function Vt(l, w) {
              return e.createRange(l.getStart(w), l.end);
            }
            __name(Vt, "Vt");
            e.createTextRangeFromNode = Vt;
            function ui(l) {
              return e.createTextSpanFromBounds(l.pos, l.end);
            }
            __name(ui, "ui");
            e.createTextSpanFromRange = ui;
            function ei(l) {
              return e.createRange(l.start, l.start + l.length);
            }
            __name(ei, "ei");
            e.createTextRangeFromSpan = ei;
            function vi(l, w, M) {
              return ri(e.createTextSpan(l, w), M);
            }
            __name(vi, "vi");
            e.createTextChangeFromStartLength = vi;
            function ri(l, w) {
              return { span: l, newText: w };
            }
            __name(ri, "ri");
            e.createTextChange = ri, e.typeKeywords = [131, 129, 160, 134, 95, 138, 141, 144, 104, 148, 149, 146, 152, 153, 110, 114, 155, 156, 157];
            function bi(l) {
              return e.contains(e.typeKeywords, l);
            }
            __name(bi, "bi");
            e.isTypeKeyword = bi;
            function Qn(l) {
              return l.kind === 154;
            }
            __name(Qn, "Qn");
            e.isTypeKeywordToken = Qn;
            function Yn(l) {
              return Qn(l) || e.isIdentifier(l) && l.text === "type";
            }
            __name(Yn, "Yn");
            e.isTypeKeywordTokenOrIdentifier = Yn;
            function oi(l) {
              return !!(l.flags & 1536) && l.name.charCodeAt(0) === 34;
            }
            __name(oi, "oi");
            e.isExternalModuleSymbol = oi;
            function Ei() {
              var l = [];
              return function(w) {
                var M = e.getNodeId(w);
                return !l[M] && (l[M] = true);
              };
            }
            __name(Ei, "Ei");
            e.nodeSeenTracker = Ei;
            function Dn(l) {
              return l.getText(0, l.getLength());
            }
            __name(Dn, "Dn");
            e.getSnapshotText = Dn;
            function Kn(l, w) {
              for (var M = "", ke = 0; ke < w; ke++)
                M += l;
              return M;
            }
            __name(Kn, "Kn");
            e.repeatString = Kn;
            function si(l) {
              return l.isTypeParameter() && l.getConstraint() || l;
            }
            __name(si, "si");
            e.skipConstraint = si;
            function mi(l) {
              return l.kind === 164 ? e.isStringOrNumericLiteralLike(l.expression) ? l.expression.text : void 0 : e.isPrivateIdentifier(l) ? e.idText(l) : e.getTextOfIdentifierOrLiteral(l);
            }
            __name(mi, "mi");
            e.getNameFromPropertyName = mi;
            function Zn(l) {
              return l.getSourceFiles().some(function(w) {
                return !w.isDeclarationFile && !l.isSourceFileFromExternalLibrary(w) && !!(w.externalModuleIndicator || w.commonJsModuleIndicator);
              });
            }
            __name(Zn, "Zn");
            e.programContainsModules = Zn;
            function Fn(l) {
              return l.getSourceFiles().some(function(w) {
                return !w.isDeclarationFile && !l.isSourceFileFromExternalLibrary(w) && !!w.externalModuleIndicator;
              });
            }
            __name(Fn, "Fn");
            e.programContainsEsModules = Fn;
            function gt(l) {
              return !!l.module || e.getEmitScriptTarget(l) >= 2 || !!l.noEmit;
            }
            __name(gt, "gt");
            e.compilerOptionsIndicateEsModules = gt;
            function gi(l, w) {
              return { fileExists: function(M) {
                return l.fileExists(M);
              }, getCurrentDirectory: function() {
                return w.getCurrentDirectory();
              }, readFile: e.maybeBind(w, w.readFile), useCaseSensitiveFileNames: e.maybeBind(w, w.useCaseSensitiveFileNames), getSymlinkCache: e.maybeBind(w, w.getSymlinkCache) || l.getSymlinkCache, getModuleSpecifierCache: e.maybeBind(w, w.getModuleSpecifierCache), getPackageJsonInfoCache: function() {
                var M;
                return (M = l.getModuleResolutionCache()) === null || M === void 0 ? void 0 : M.getPackageJsonInfoCache();
              }, getGlobalTypingsCacheLocation: e.maybeBind(w, w.getGlobalTypingsCacheLocation), redirectTargetsMap: l.redirectTargetsMap, getProjectReferenceRedirect: function(M) {
                return l.getProjectReferenceRedirect(M);
              }, isSourceOfProjectReferenceRedirect: function(M) {
                return l.isSourceOfProjectReferenceRedirect(M);
              }, getNearestAncestorDirectoryWithPackageJson: e.maybeBind(w, w.getNearestAncestorDirectoryWithPackageJson), getFileIncludeReasons: function() {
                return l.getFileIncludeReasons();
              } };
            }
            __name(gi, "gi");
            e.createModuleSpecifierResolutionHost = gi;
            function dn(l, w) {
              return T(T({}, gi(l, w)), { getCommonSourceDirectory: function() {
                return l.getCommonSourceDirectory();
              } });
            }
            __name(dn, "dn");
            e.getModuleSpecifierResolverHost = dn;
            function On(l) {
              return l >= e.ModuleResolutionKind.Node16 && l <= e.ModuleResolutionKind.NodeNext;
            }
            __name(On, "On");
            e.moduleResolutionRespectsExports = On;
            function br(l) {
              return l === e.ModuleResolutionKind.NodeJs || l >= e.ModuleResolutionKind.Node16 && l <= e.ModuleResolutionKind.NodeNext;
            }
            __name(br, "br");
            e.moduleResolutionUsesNodeModules = br;
            function Ae(l, w, M, ke) {
              return l || w && w.length ? ur(l, w, M, ke) : void 0;
            }
            __name(Ae, "Ae");
            e.makeImportIfNecessary = Ae;
            function ur(l, w, M, ke, cr) {
              return e.factory.createImportDeclaration(void 0, l || w ? e.factory.createImportClause(!!cr, l, w && w.length ? e.factory.createNamedImports(w) : void 0) : void 0, typeof M == "string" ? L(M, ke) : M, void 0);
            }
            __name(ur, "ur");
            e.makeImport = ur;
            function L(l, w) {
              return e.factory.createStringLiteral(l, w === 0);
            }
            __name(L, "L");
            e.makeStringLiteral = L;
            var qt;
            (function(l) {
              l[l.Single = 0] = "Single", l[l.Double = 1] = "Double";
            })(qt = e.QuotePreference || (e.QuotePreference = {}));
            function nn(l, w) {
              return e.isStringDoubleQuoted(l, w) ? 1 : 0;
            }
            __name(nn, "nn");
            e.quotePreferenceFromString = nn;
            function fr(l, w) {
              if (w.quotePreference && w.quotePreference !== "auto")
                return w.quotePreference === "single" ? 0 : 1;
              var M = l.imports && e.find(l.imports, function(ke) {
                return e.isStringLiteral(ke) && !e.nodeIsSynthesized(ke.parent);
              });
              return M ? nn(M, l) : 1;
            }
            __name(fr, "fr");
            e.getQuotePreference = fr;
            function Me(l) {
              switch (l) {
                case 0:
                  return "'";
                case 1:
                  return '"';
                default:
                  return e.Debug.assertNever(l);
              }
            }
            __name(Me, "Me");
            e.getQuoteFromPreference = Me;
            function Ve(l) {
              var w = _r(l);
              return w === void 0 ? void 0 : e.unescapeLeadingUnderscores(w);
            }
            __name(Ve, "Ve");
            e.symbolNameNoDefault = Ve;
            function _r(l) {
              return l.escapedName !== "default" ? l.escapedName : e.firstDefined(l.declarations, function(w) {
                var M = e.getNameOfDeclaration(w);
                return M && M.kind === 79 ? M.escapedText : void 0;
              });
            }
            __name(_r, "_r");
            e.symbolEscapedNameNoDefault = _r;
            function lr(l) {
              return e.isStringLiteralLike(l) && (e.isExternalModuleReference(l.parent) || e.isImportDeclaration(l.parent) || e.isRequireCall(l.parent, false) && l.parent.arguments[0] === l || e.isImportCall(l.parent) && l.parent.arguments[0] === l);
            }
            __name(lr, "lr");
            e.isModuleSpecifierLike = lr;
            function Vr(l) {
              return e.isBindingElement(l) && e.isObjectBindingPattern(l.parent) && e.isIdentifier(l.name) && !l.propertyName;
            }
            __name(Vr, "Vr");
            e.isObjectBindingElementWithoutPropertyName = Vr;
            function tt(l, w) {
              var M = l.getTypeAtLocation(w.parent);
              return M && l.getPropertyOfType(M, w.name.text);
            }
            __name(tt, "tt");
            e.getPropertySymbolFromBindingElement = tt;
            function dt(l, w, M) {
              if (!!l)
                for (; l.parent; ) {
                  if (e.isSourceFile(l.parent) || !It(M, l.parent, w))
                    return l;
                  l = l.parent;
                }
            }
            __name(dt, "dt");
            e.getParentNodeInSpan = dt;
            function It(l, w, M) {
              return e.textSpanContainsPosition(l, w.getStart(M)) && w.getEnd() <= e.textSpanEnd(l);
            }
            __name(It, "It");
            function an(l, w) {
              return e.canHaveModifiers(l) ? e.find(l.modifiers, function(M) {
                return M.kind === w;
              }) : void 0;
            }
            __name(an, "an");
            e.findModifier = an;
            function sn(l, w, M, ke) {
              var cr = e.isArray(M) ? M[0] : M, Zr = cr.kind === 240 ? e.isRequireVariableStatement : e.isAnyImportSyntax, _t = e.filter(w.statements, Zr), Rt = e.isArray(M) ? e.stableSort(M, e.OrganizeImports.compareImportsOrRequireStatements) : [M];
              if (!_t.length)
                l.insertNodesAtTopOfFile(w, Rt, ke);
              else if (_t && e.OrganizeImports.importsAreSorted(_t))
                for (var un = 0, bn = Rt; un < bn.length; un++) {
                  var _n = bn[un], Nt = e.OrganizeImports.getImportDeclarationInsertionIndex(_t, _n);
                  if (Nt === 0) {
                    var Ft = _t[0] === w.statements[0] ? { leadingTriviaOption: e.textChanges.LeadingTriviaOption.Exclude } : {};
                    l.insertNodeBefore(w, _t[0], _n, false, Ft);
                  } else {
                    var Sn = _t[Nt - 1];
                    l.insertNodeAfter(w, Sn, _n);
                  }
                }
              else {
                var wn = e.lastOrUndefined(_t);
                wn ? l.insertNodesAfter(w, wn, Rt) : l.insertNodesAtTopOfFile(w, Rt, ke);
              }
            }
            __name(sn, "sn");
            e.insertImports = sn;
            function _e(l, w) {
              return e.Debug.assert(l.isTypeOnly), e.cast(l.getChildAt(0, w), Qn);
            }
            __name(_e, "_e");
            e.getTypeKeywordOfTypeOnlyImport = _e;
            function Gr(l, w) {
              return !!l && !!w && l.start === w.start && l.length === w.length;
            }
            __name(Gr, "Gr");
            e.textSpansEqual = Gr;
            function Kt(l, w) {
              return l.fileName === w.fileName && Gr(l.textSpan, w.textSpan);
            }
            __name(Kt, "Kt");
            e.documentSpansEqual = Kt;
            function en(l, w) {
              if (l) {
                for (var M = 0; M < l.length; M++)
                  if (l.indexOf(l[M]) === M) {
                    var ke = w(l[M], M);
                    if (ke)
                      return ke;
                  }
              }
            }
            __name(en, "en");
            e.forEachUnique = en;
            function Ot(l, w, M) {
              for (var ke = w; ke < M; ke++)
                if (!e.isWhiteSpaceLike(l.charCodeAt(ke)))
                  return false;
              return true;
            }
            __name(Ot, "Ot");
            e.isTextWhiteSpaceLike = Ot;
            function rr(l, w, M) {
              var ke = w.tryGetSourcePosition(l);
              return ke && (!M || M(e.normalizePath(ke.fileName)) ? ke : void 0);
            }
            __name(rr, "rr");
            e.getMappedLocation = rr;
            function Hn(l, w, M) {
              var ke = l.fileName, cr = l.textSpan, Zr = rr({ fileName: ke, pos: cr.start }, w, M);
              if (!!Zr) {
                var _t = rr({ fileName: ke, pos: cr.start + cr.length }, w, M), Rt = _t ? _t.pos - Zr.pos : cr.length;
                return { fileName: Zr.fileName, textSpan: { start: Zr.pos, length: Rt }, originalFileName: l.fileName, originalTextSpan: l.textSpan, contextSpan: rn(l, w, M), originalContextSpan: l.contextSpan };
              }
            }
            __name(Hn, "Hn");
            e.getMappedDocumentSpan = Hn;
            function rn(l, w, M) {
              var ke = l.contextSpan && rr({ fileName: l.fileName, pos: l.contextSpan.start }, w, M), cr = l.contextSpan && rr({ fileName: l.fileName, pos: l.contextSpan.start + l.contextSpan.length }, w, M);
              return ke && cr ? { start: ke.pos, length: cr.pos - ke.pos } : void 0;
            }
            __name(rn, "rn");
            e.getMappedContextSpan = rn;
            function xn(l) {
              var w = l.declarations ? e.firstOrUndefined(l.declarations) : void 0;
              return !!e.findAncestor(w, function(M) {
                return e.isParameter(M) ? true : e.isBindingElement(M) || e.isObjectBindingPattern(M) || e.isArrayBindingPattern(M) ? false : "quit";
              });
            }
            __name(xn, "xn");
            e.isFirstDeclarationOfSymbolParameter = xn;
            var Mn = Rn();
            function Rn() {
              var l = e.defaultMaximumTruncationLength * 10, w, M, ke, cr;
              _n();
              var Zr = /* @__PURE__ */ __name(function(Nt) {
                return Rt(Nt, e.SymbolDisplayPartKind.text);
              }, "Zr");
              return { displayParts: function() {
                var Nt = w.length && w[w.length - 1].text;
                return cr > l && Nt && Nt !== "..." && (e.isWhiteSpaceLike(Nt.charCodeAt(Nt.length - 1)) || w.push(on(" ", e.SymbolDisplayPartKind.space)), w.push(on("...", e.SymbolDisplayPartKind.punctuation))), w;
              }, writeKeyword: function(Nt) {
                return Rt(Nt, e.SymbolDisplayPartKind.keyword);
              }, writeOperator: function(Nt) {
                return Rt(Nt, e.SymbolDisplayPartKind.operator);
              }, writePunctuation: function(Nt) {
                return Rt(Nt, e.SymbolDisplayPartKind.punctuation);
              }, writeTrailingSemicolon: function(Nt) {
                return Rt(Nt, e.SymbolDisplayPartKind.punctuation);
              }, writeSpace: function(Nt) {
                return Rt(Nt, e.SymbolDisplayPartKind.space);
              }, writeStringLiteral: function(Nt) {
                return Rt(Nt, e.SymbolDisplayPartKind.stringLiteral);
              }, writeParameter: function(Nt) {
                return Rt(Nt, e.SymbolDisplayPartKind.parameterName);
              }, writeProperty: function(Nt) {
                return Rt(Nt, e.SymbolDisplayPartKind.propertyName);
              }, writeLiteral: function(Nt) {
                return Rt(Nt, e.SymbolDisplayPartKind.stringLiteral);
              }, writeSymbol: un, writeLine: bn, write: Zr, writeComment: Zr, getText: function() {
                return "";
              }, getTextPos: function() {
                return 0;
              }, getColumn: function() {
                return 0;
              }, getLine: function() {
                return 0;
              }, isAtStartOfLine: function() {
                return false;
              }, hasTrailingWhitespace: function() {
                return false;
              }, hasTrailingComment: function() {
                return false;
              }, rawWrite: e.notImplemented, getIndent: function() {
                return ke;
              }, increaseIndent: function() {
                ke++;
              }, decreaseIndent: function() {
                ke--;
              }, clear: _n, trackSymbol: function() {
                return false;
              }, reportInaccessibleThisError: e.noop, reportInaccessibleUniqueSymbolError: e.noop, reportPrivateInBaseOfClassExpression: e.noop };
              function _t() {
                if (!(cr > l) && M) {
                  var Nt = e.getIndentString(ke);
                  Nt && (cr += Nt.length, w.push(on(Nt, e.SymbolDisplayPartKind.space))), M = false;
                }
              }
              __name(_t, "_t");
              function Rt(Nt, Ft) {
                cr > l || (_t(), cr += Nt.length, w.push(on(Nt, Ft)));
              }
              __name(Rt, "Rt");
              function un(Nt, Ft) {
                cr > l || (_t(), cr += Nt.length, w.push(kn(Nt, Ft)));
              }
              __name(un, "un");
              function bn() {
                cr > l || (cr += 1, w.push(Si()), M = true);
              }
              __name(bn, "bn");
              function _n() {
                w = [], M = true, ke = 0, cr = 0;
              }
              __name(_n, "_n");
            }
            __name(Rn, "Rn");
            function kn(l, w) {
              return on(l, M(w));
              function M(ke) {
                var cr = ke.flags;
                return cr & 3 ? xn(ke) ? e.SymbolDisplayPartKind.parameterName : e.SymbolDisplayPartKind.localName : cr & 4 || cr & 32768 || cr & 65536 ? e.SymbolDisplayPartKind.propertyName : cr & 8 ? e.SymbolDisplayPartKind.enumMemberName : cr & 16 ? e.SymbolDisplayPartKind.functionName : cr & 32 ? e.SymbolDisplayPartKind.className : cr & 64 ? e.SymbolDisplayPartKind.interfaceName : cr & 384 ? e.SymbolDisplayPartKind.enumName : cr & 1536 ? e.SymbolDisplayPartKind.moduleName : cr & 8192 ? e.SymbolDisplayPartKind.methodName : cr & 262144 ? e.SymbolDisplayPartKind.typeParameterName : cr & 524288 || cr & 2097152 ? e.SymbolDisplayPartKind.aliasName : e.SymbolDisplayPartKind.text;
              }
              __name(M, "M");
            }
            __name(kn, "kn");
            e.symbolPart = kn;
            function on(l, w) {
              return { text: l, kind: e.SymbolDisplayPartKind[w] };
            }
            __name(on, "on");
            e.displayPart = on;
            function Xr() {
              return on(" ", e.SymbolDisplayPartKind.space);
            }
            __name(Xr, "Xr");
            e.spacePart = Xr;
            function wr(l) {
              return on(e.tokenToString(l), e.SymbolDisplayPartKind.keyword);
            }
            __name(wr, "wr");
            e.keywordPart = wr;
            function fn(l) {
              return on(e.tokenToString(l), e.SymbolDisplayPartKind.punctuation);
            }
            __name(fn, "fn");
            e.punctuationPart = fn;
            function mn(l) {
              return on(e.tokenToString(l), e.SymbolDisplayPartKind.operator);
            }
            __name(mn, "mn");
            e.operatorPart = mn;
            function Li(l) {
              return on(l, e.SymbolDisplayPartKind.parameterName);
            }
            __name(Li, "Li");
            e.parameterNamePart = Li;
            function An(l) {
              return on(l, e.SymbolDisplayPartKind.propertyName);
            }
            __name(An, "An");
            e.propertyNamePart = An;
            function wi(l) {
              var w = e.stringToToken(l);
              return w === void 0 ? ti(l) : wr(w);
            }
            __name(wi, "wi");
            e.textOrKeywordPart = wi;
            function ti(l) {
              return on(l, e.SymbolDisplayPartKind.text);
            }
            __name(ti, "ti");
            e.textPart = ti;
            function li(l) {
              return on(l, e.SymbolDisplayPartKind.aliasName);
            }
            __name(li, "li");
            e.typeAliasNamePart = li;
            function Bn(l) {
              return on(l, e.SymbolDisplayPartKind.typeParameterName);
            }
            __name(Bn, "Bn");
            e.typeParameterNamePart = Bn;
            function vn(l) {
              return on(l, e.SymbolDisplayPartKind.linkText);
            }
            __name(vn, "vn");
            e.linkTextPart = vn;
            function Ue(l, w) {
              return { text: l, kind: e.SymbolDisplayPartKind[e.SymbolDisplayPartKind.linkName], target: { fileName: e.getSourceFileOfNode(w).fileName, textSpan: ln(w) } };
            }
            __name(Ue, "Ue");
            e.linkNamePart = Ue;
            function Vn(l) {
              return on(l, e.SymbolDisplayPartKind.link);
            }
            __name(Vn, "Vn");
            e.linkPart = Vn;
            function Ti(l, w) {
              var M, ke = e.isJSDocLink(l) ? "link" : e.isJSDocLinkCode(l) ? "linkcode" : "linkplain", cr = [Vn("{@".concat(ke, " "))];
              if (!l.name)
                l.text && cr.push(vn(l.text));
              else {
                var Zr = w == null ? void 0 : w.getSymbolAtLocation(l.name), _t = Bi(l.text), Rt = e.getTextOfNode(l.name) + l.text.slice(0, _t), un = ni(l.text.slice(_t)), bn = (Zr == null ? void 0 : Zr.valueDeclaration) || ((M = Zr == null ? void 0 : Zr.declarations) === null || M === void 0 ? void 0 : M[0]);
                bn ? (cr.push(Ue(Rt, bn)), un && cr.push(vn(un))) : cr.push(vn(Rt + (_t || un.indexOf("://") === 0 ? "" : " ") + un));
              }
              return cr.push(Vn("}")), cr;
            }
            __name(Ti, "Ti");
            e.buildLinkParts = Ti;
            function ni(l) {
              var w = 0;
              if (l.charCodeAt(w++) === 124) {
                for (; w < l.length && l.charCodeAt(w) === 32; )
                  w++;
                return l.slice(w);
              }
              return l;
            }
            __name(ni, "ni");
            function Bi(l) {
              if (l.indexOf("()") === 0)
                return 2;
              if (l[0] !== "<")
                return 0;
              for (var w = 0, M = 0; M < l.length; )
                if (l[M] === "<" && w++, l[M] === ">" && w--, M++, !w)
                  return M;
              return 0;
            }
            __name(Bi, "Bi");
            var Tn = `\r
`;
            function jn(l, w) {
              var M;
              return (w == null ? void 0 : w.newLineCharacter) || ((M = l.getNewLine) === null || M === void 0 ? void 0 : M.call(l)) || Tn;
            }
            __name(jn, "jn");
            e.getNewLineOrDefaultFromHost = jn;
            function Si() {
              return on(`
`, e.SymbolDisplayPartKind.lineBreak);
            }
            __name(Si, "Si");
            e.lineBreakPart = Si;
            function Ci(l) {
              try {
                return l(Mn), Mn.displayParts();
              } finally {
                Mn.clear();
              }
            }
            __name(Ci, "Ci");
            e.mapToDisplayParts = Ci;
            function C(l, w, M, ke) {
              return ke === void 0 && (ke = 0), Ci(function(cr) {
                l.writeType(w, M, ke | 1024 | 16384, cr);
              });
            }
            __name(C, "C");
            e.typeToDisplayParts = C;
            function V(l, w, M, ke, cr) {
              return cr === void 0 && (cr = 0), Ci(function(Zr) {
                l.writeSymbol(w, M, ke, cr | 8, Zr);
              });
            }
            __name(V, "V");
            e.symbolToDisplayParts = V;
            function ee(l, w, M, ke) {
              return ke === void 0 && (ke = 0), ke |= 25632, Ci(function(cr) {
                l.writeSignature(w, M, ke, void 0, cr);
              });
            }
            __name(ee, "ee");
            e.signatureToDisplayParts = ee;
            function le(l, w) {
              var M = w.getSourceFile();
              return Ci(function(ke) {
                var cr = e.createPrinter({ removeComments: true, omitTrailingSemicolon: true });
                cr.writeNode(4, l, M, ke);
              });
            }
            __name(le, "le");
            e.nodeToDisplayParts = le;
            function Ze(l) {
              return !!l.parent && e.isImportOrExportSpecifier(l.parent) && l.parent.propertyName === l;
            }
            __name(Ze, "Ze");
            e.isImportOrExportSpecifierName = Ze;
            function Ir(l, w) {
              return e.ensureScriptKind(l, w.getScriptKind && w.getScriptKind(l));
            }
            __name(Ir, "Ir");
            e.getScriptKind = Ir;
            function Ar(l, w) {
              for (var M = l; yt(M) || hr(M) && M.target; )
                hr(M) && M.target ? M = M.target : M = e.skipAlias(M, w);
              return M;
            }
            __name(Ar, "Ar");
            e.getSymbolTarget = Ar;
            function hr(l) {
              return (l.flags & 33554432) !== 0;
            }
            __name(hr, "hr");
            function yt(l) {
              return (l.flags & 2097152) !== 0;
            }
            __name(yt, "yt");
            function Pt(l, w) {
              return e.getSymbolId(e.skipAlias(l, w));
            }
            __name(Pt, "Pt");
            e.getUniqueSymbolId = Pt;
            function Ut(l, w) {
              for (; e.isWhiteSpaceLike(l.charCodeAt(w)); )
                w += 1;
              return w;
            }
            __name(Ut, "Ut");
            e.getFirstNonSpaceCharacterPosition = Ut;
            function jt(l, w) {
              for (; w > -1 && e.isWhiteSpaceSingleLine(l.charCodeAt(w)); )
                w -= 1;
              return w + 1;
            }
            __name(jt, "jt");
            e.getPrecedingNonSpaceCharacterPosition = jt;
            function Ht(l, w) {
              w === void 0 && (w = true);
              var M = l && Ni(l);
              return M && !w && sa(M), M;
            }
            __name(Ht, "Ht");
            e.getSynthesizedDeepClone = Ht;
            function yi(l, w, M) {
              var ke = M(l);
              return ke ? e.setOriginalNode(ke, l) : ke = Ni(l, M), ke && !w && sa(ke), ke;
            }
            __name(yi, "yi");
            e.getSynthesizedDeepCloneWithReplacements = yi;
            function Ni(l, w) {
              var M = w ? function(_t) {
                return yi(_t, true, w);
              } : Ht, ke = w ? function(_t) {
                return _t && qi(_t, true, w);
              } : function(_t) {
                return _t && Gn(_t);
              }, cr = e.visitEachChild(l, M, e.nullTransformationContext, ke, M);
              if (cr === l) {
                var Zr = e.isStringLiteral(l) ? e.setOriginalNode(e.factory.createStringLiteralFromNode(l), l) : e.isNumericLiteral(l) ? e.setOriginalNode(e.factory.createNumericLiteral(l.text, l.numericLiteralFlags), l) : e.factory.cloneNode(l);
                return e.setTextRange(Zr, l);
              }
              return cr.parent = void 0, cr;
            }
            __name(Ni, "Ni");
            function Gn(l, w) {
              return w === void 0 && (w = true), l && e.factory.createNodeArray(l.map(function(M) {
                return Ht(M, w);
              }), l.hasTrailingComma);
            }
            __name(Gn, "Gn");
            e.getSynthesizedDeepClones = Gn;
            function qi(l, w, M) {
              return e.factory.createNodeArray(l.map(function(ke) {
                return yi(ke, w, M);
              }), l.hasTrailingComma);
            }
            __name(qi, "qi");
            e.getSynthesizedDeepClonesWithReplacements = qi;
            function sa(l) {
              ea(l), Hi(l);
            }
            __name(sa, "sa");
            e.suppressLeadingAndTrailingTrivia = sa;
            function ea(l) {
              Xi(l, 512, ma);
            }
            __name(ea, "ea");
            e.suppressLeadingTrivia = ea;
            function Hi(l) {
              Xi(l, 1024, e.getLastChild);
            }
            __name(Hi, "Hi");
            e.suppressTrailingTrivia = Hi;
            function Ui(l, w) {
              var M = l.getSourceFile(), ke = M.text;
              Gi(l, ke) ? $i(l, w, M) : Ri(l, w, M), _a(l, w, M);
            }
            __name(Ui, "Ui");
            e.copyComments = Ui;
            function Gi(l, w) {
              for (var M = l.getFullStart(), ke = l.getStart(), cr = M; cr < ke; cr++)
                if (w.charCodeAt(cr) === 10)
                  return true;
              return false;
            }
            __name(Gi, "Gi");
            function Xi(l, w, M) {
              e.addEmitFlags(l, w);
              var ke = M(l);
              ke && Xi(ke, w, M);
            }
            __name(Xi, "Xi");
            function ma(l) {
              return l.forEachChild(function(w) {
                return w;
              });
            }
            __name(ma, "ma");
            function Jn(l, w) {
              for (var M = l, ke = 1; !e.isFileLevelUniqueName(w, M); ke++)
                M = "".concat(l, "_").concat(ke);
              return M;
            }
            __name(Jn, "Jn");
            e.getUniqueName = Jn;
            function ra(l, w, M, ke) {
              for (var cr = 0, Zr = -1, _t = 0, Rt = l; _t < Rt.length; _t++) {
                var un = Rt[_t], bn = un.fileName, _n = un.textChanges;
                e.Debug.assert(bn === w);
                for (var Nt = 0, Ft = _n; Nt < Ft.length; Nt++) {
                  var Sn = Ft[Nt], wn = Sn.span, Wn = Sn.newText, Fi = ne(Wn, e.escapeString(M));
                  if (Fi !== -1 && (Zr = wn.start + cr + Fi, !ke))
                    return Zr;
                  cr += Wn.length - wn.length;
                }
              }
              return e.Debug.assert(ke), e.Debug.assert(Zr >= 0), Zr;
            }
            __name(ra, "ra");
            e.getRenameLocation = ra;
            function $i(l, w, M, ke, cr) {
              e.forEachLeadingCommentRange(M.text, l.pos, p(w, M, ke, cr, e.addSyntheticLeadingComment));
            }
            __name($i, "$i");
            e.copyLeadingComments = $i;
            function _a(l, w, M, ke, cr) {
              e.forEachTrailingCommentRange(M.text, l.end, p(w, M, ke, cr, e.addSyntheticTrailingComment));
            }
            __name(_a, "_a");
            e.copyTrailingComments = _a;
            function Ri(l, w, M, ke, cr) {
              e.forEachTrailingCommentRange(M.text, l.pos, p(w, M, ke, cr, e.addSyntheticLeadingComment));
            }
            __name(Ri, "Ri");
            e.copyTrailingAsLeadingComments = Ri;
            function p(l, w, M, ke, cr) {
              return function(Zr, _t, Rt, un) {
                Rt === 3 ? (Zr += 2, _t -= 2) : Zr += 2, cr(l, M || Rt, w.text.slice(Zr, _t), ke !== void 0 ? ke : un);
              };
            }
            __name(p, "p");
            function ne(l, w) {
              if (e.startsWith(l, w))
                return 0;
              var M = l.indexOf(" " + w);
              return M === -1 && (M = l.indexOf("." + w)), M === -1 && (M = l.indexOf('"' + w)), M === -1 ? -1 : M + 1;
            }
            __name(ne, "ne");
            function Ne(l) {
              return e.isBinaryExpression(l) && l.operatorToken.kind === 27 || e.isObjectLiteralExpression(l) || e.isAsExpression(l) && e.isObjectLiteralExpression(l.expression);
            }
            __name(Ne, "Ne");
            e.needsParentheses = Ne;
            function or(l, w) {
              var M = l.parent;
              switch (M.kind) {
                case 211:
                  return w.getContextualType(M);
                case 223: {
                  var ke = M, cr = ke.left, Zr = ke.operatorToken, _t = ke.right;
                  return vt(Zr.kind) ? w.getTypeAtLocation(l === _t ? cr : _t) : w.getContextualType(l);
                }
                case 292:
                  return M.expression === l ? tn(M, w) : void 0;
                default:
                  return w.getContextualType(l);
              }
            }
            __name(or, "or");
            e.getContextualTypeFromParent = or;
            function it(l, w, M) {
              var ke = fr(l, w), cr = JSON.stringify(M);
              return ke === 0 ? "'".concat(e.stripQuotes(cr).replace(/'/g, "\\'").replace(/\\"/g, '"'), "'") : cr;
            }
            __name(it, "it");
            e.quote = it;
            function vt(l) {
              switch (l) {
                case 36:
                case 34:
                case 37:
                case 35:
                  return true;
                default:
                  return false;
              }
            }
            __name(vt, "vt");
            e.isEqualityOperatorKind = vt;
            function Et(l) {
              switch (l.kind) {
                case 10:
                case 14:
                case 225:
                case 212:
                  return true;
                default:
                  return false;
              }
            }
            __name(Et, "Et");
            e.isStringLiteralOrTemplate = Et;
            function Tt(l) {
              return !!l.getStringIndexType() || !!l.getNumberIndexType();
            }
            __name(Tt, "Tt");
            e.hasIndexSignature = Tt;
            function tn(l, w) {
              return w.getTypeAtLocation(l.parent.parent.expression);
            }
            __name(tn, "tn");
            e.getSwitchedType = tn, e.ANONYMOUS = "anonymous function";
            function Mt(l, w, M, ke) {
              var cr = M.getTypeChecker(), Zr = true, _t = /* @__PURE__ */ __name(function() {
                return Zr = false;
              }, "_t"), Rt = cr.typeToTypeNode(l, w, 1, { trackSymbol: function(un, bn, _n) {
                return Zr = Zr && cr.isSymbolAccessible(un, bn, _n, false).accessibility === 0, !Zr;
              }, reportInaccessibleThisError: _t, reportPrivateInBaseOfClassExpression: _t, reportInaccessibleUniqueSymbolError: _t, moduleResolverHost: dn(M, ke) });
              return Zr ? Rt : void 0;
            }
            __name(Mt, "Mt");
            e.getTypeNodeIfAccessible = Mt;
            function $t(l) {
              return l === 176 || l === 177 || l === 178 || l === 168 || l === 170;
            }
            __name($t, "$t");
            function y(l) {
              return l === 259 || l === 173 || l === 171 || l === 174 || l === 175;
            }
            __name(y, "y");
            function De(l) {
              return l === 264;
            }
            __name(De, "De");
            function R(l) {
              return l === 240 || l === 241 || l === 243 || l === 248 || l === 249 || l === 250 || l === 254 || l === 256 || l === 169 || l === 262 || l === 269 || l === 268 || l === 275 || l === 267 || l === 274;
            }
            __name(R, "R");
            e.syntaxRequiresTrailingSemicolonOrASI = R, e.syntaxMayBeASICandidate = e.or($t, y, De, R);
            function Jt(l, w) {
              var M = l.getLastToken(w);
              if (M && M.kind === 26)
                return false;
              if ($t(l.kind)) {
                if (M && M.kind === 27)
                  return false;
              } else if (De(l.kind)) {
                var ke = e.last(l.getChildren(w));
                if (ke && e.isModuleBlock(ke))
                  return false;
              } else if (y(l.kind)) {
                var ke = e.last(l.getChildren(w));
                if (ke && e.isFunctionBlock(ke))
                  return false;
              } else if (!R(l.kind))
                return false;
              if (l.kind === 243)
                return true;
              var cr = e.findAncestor(l, function(un) {
                return !un.parent;
              }), Zr = xe(l, cr, w);
              if (!Zr || Zr.kind === 19)
                return true;
              var _t = w.getLineAndCharacterOfPosition(l.getEnd()).line, Rt = w.getLineAndCharacterOfPosition(Zr.getStart(w)).line;
              return _t !== Rt;
            }
            __name(Jt, "Jt");
            function Qt(l, w, M) {
              var ke = e.findAncestor(w, function(cr) {
                return cr.end !== l ? "quit" : e.syntaxMayBeASICandidate(cr.kind);
              });
              return !!ke && Jt(ke, M);
            }
            __name(Qt, "Qt");
            e.positionIsASICandidate = Qt;
            function qn(l) {
              var w = 0, M = 0, ke = 5;
              return e.forEachChild(l, /* @__PURE__ */ __name(function cr(Zr) {
                if (R(Zr.kind)) {
                  var _t = Zr.getLastToken(l);
                  (_t == null ? void 0 : _t.kind) === 26 ? w++ : M++;
                } else if ($t(Zr.kind)) {
                  var _t = Zr.getLastToken(l);
                  if ((_t == null ? void 0 : _t.kind) === 26)
                    w++;
                  else if (_t && _t.kind !== 27) {
                    var Rt = e.getLineAndCharacterOfPosition(l, _t.getStart(l)).line, un = e.getLineAndCharacterOfPosition(l, e.getSpanOfTokenAtPosition(l, _t.end).start).line;
                    Rt !== un && M++;
                  }
                }
                return w + M >= ke ? true : e.forEachChild(Zr, cr);
              }, "cr")), w === 0 && M <= 1 ? true : w / M > 1 / ke;
            }
            __name(qn, "qn");
            e.probablyUsesSemicolons = qn;
            function Ii(l, w) {
              return ta(l, l.getDirectories, w) || [];
            }
            __name(Ii, "Ii");
            e.tryGetDirectories = Ii;
            function ca(l, w, M, ke, cr) {
              return ta(l, l.readDirectory, w, M, ke, cr) || e.emptyArray;
            }
            __name(ca, "ca");
            e.tryReadDirectory = ca;
            function ji(l, w) {
              return ta(l, l.fileExists, w);
            }
            __name(ji, "ji");
            e.tryFileExists = ji;
            function ua(l, w) {
              return Qi(function() {
                return e.directoryProbablyExists(w, l);
              }) || false;
            }
            __name(ua, "ua");
            e.tryDirectoryExists = ua;
            function Qi(l) {
              try {
                return l();
              } catch {
                return;
              }
            }
            __name(Qi, "Qi");
            e.tryAndIgnoreErrors = Qi;
            function ta(l, w) {
              for (var M = [], ke = 2; ke < arguments.length; ke++)
                M[ke - 2] = arguments[ke];
              return Qi(function() {
                return w && w.apply(l, M);
              });
            }
            __name(ta, "ta");
            e.tryIOAndConsumeErrors = ta;
            function Ta(l, w, M) {
              var ke = [];
              return e.forEachAncestorDirectory(l, function(cr) {
                if (cr === M)
                  return true;
                var Zr = e.combinePaths(cr, "package.json");
                ji(w, Zr) && ke.push(Zr);
              }), ke;
            }
            __name(Ta, "Ta");
            e.findPackageJsons = Ta;
            function zi(l, w) {
              var M;
              return e.forEachAncestorDirectory(l, function(ke) {
                if (ke === "node_modules" || (M = e.findConfigFile(ke, function(cr) {
                  return ji(w, cr);
                }, "package.json"), M))
                  return true;
              }), M;
            }
            __name(zi, "zi");
            e.findPackageJson = zi;
            function Ji(l, w) {
              if (!w.fileExists)
                return [];
              var M = [];
              return e.forEachAncestorDirectory(e.getDirectoryPath(l), function(ke) {
                var cr = e.combinePaths(ke, "package.json");
                if (w.fileExists(cr)) {
                  var Zr = ga(cr, w);
                  Zr && M.push(Zr);
                }
              }), M;
            }
            __name(Ji, "Ji");
            e.getPackageJsonsVisibleToFile = Ji;
            function ga(l, w) {
              if (!w.readFile)
                return;
              var M = ["dependencies", "devDependencies", "optionalDependencies", "peerDependencies"], ke = w.readFile(l) || "", cr = Ns(ke), Zr = {};
              if (cr)
                for (var _t = 0, Rt = M; _t < Rt.length; _t++) {
                  var un = Rt[_t], bn = cr[un];
                  if (!!bn) {
                    var _n = new e.Map();
                    for (var Nt in bn)
                      _n.set(Nt, bn[Nt]);
                    Zr[un] = _n;
                  }
                }
              var Ft = [[1, Zr.dependencies], [2, Zr.devDependencies], [8, Zr.optionalDependencies], [4, Zr.peerDependencies]];
              return T(T({}, Zr), { parseable: !!cr, fileName: l, get: Sn, has: function(wn, Wn) {
                return !!Sn(wn, Wn);
              } });
              function Sn(wn, Wn) {
                Wn === void 0 && (Wn = 15);
                for (var Fi = 0, qa = Ft; Fi < qa.length; Fi++) {
                  var xo = qa[Fi], wo = xo[0], Ao = xo[1];
                  if (Ao && Wn & wo) {
                    var no = Ao.get(wn);
                    if (no !== void 0)
                      return no;
                  }
                }
              }
              __name(Sn, "Sn");
            }
            __name(ga, "ga");
            e.createPackageJsonInfo = ga;
            function yo(l, w, M) {
              var ke = (M.getPackageJsonsVisibleToFile && M.getPackageJsonsVisibleToFile(l.fileName) || Ji(l.fileName, M)).filter(function(Ft) {
                return Ft.parseable;
              }), cr;
              return { allowsImportingAmbientModule: _t, allowsImportingSourceFile: Rt, allowsImportingSpecifier: un };
              function Zr(Ft) {
                for (var Sn = Nt(Ft), wn = 0, Wn = ke; wn < Wn.length; wn++) {
                  var Fi = Wn[wn];
                  if (Fi.has(Sn) || Fi.has(e.getTypesPackageName(Sn)))
                    return true;
                }
                return false;
              }
              __name(Zr, "Zr");
              function _t(Ft, Sn) {
                if (!ke.length || !Ft.valueDeclaration)
                  return true;
                var wn = Ft.valueDeclaration.getSourceFile(), Wn = _n(wn.fileName, Sn);
                if (typeof Wn > "u")
                  return true;
                var Fi = e.stripQuotes(Ft.getName());
                return bn(Fi) ? true : Zr(Wn) || Zr(Fi);
              }
              __name(_t, "_t");
              function Rt(Ft, Sn) {
                if (!ke.length)
                  return true;
                var wn = _n(Ft.fileName, Sn);
                return wn ? Zr(wn) : true;
              }
              __name(Rt, "Rt");
              function un(Ft) {
                return !ke.length || bn(Ft) || e.pathIsRelative(Ft) || e.isRootedDiskPath(Ft) ? true : Zr(Ft);
              }
              __name(un, "un");
              function bn(Ft) {
                return !!(e.isSourceFileJS(l) && e.JsTyping.nodeCoreModules.has(Ft) && (cr === void 0 && (cr = wa(l)), cr));
              }
              __name(bn, "bn");
              function _n(Ft, Sn) {
                if (!!e.stringContains(Ft, "node_modules")) {
                  var wn = e.moduleSpecifiers.getNodeModulesPackageName(M.getCompilationSettings(), l, Ft, Sn, w);
                  if (!!wn && !e.pathIsRelative(wn) && !e.isRootedDiskPath(wn))
                    return Nt(wn);
                }
              }
              __name(_n, "_n");
              function Nt(Ft) {
                var Sn = e.getPathComponents(e.getPackageNameFromTypesPackageName(Ft)).slice(1);
                return e.startsWith(Sn[0], "@") ? "".concat(Sn[0], "/").concat(Sn[1]) : Sn[0];
              }
              __name(Nt, "Nt");
            }
            __name(yo, "yo");
            e.createPackageJsonImportFilter = yo;
            function Ns(l) {
              try {
                return JSON.parse(l);
              } catch {
                return;
              }
            }
            __name(Ns, "Ns");
            function wa(l) {
              return e.some(l.imports, function(w) {
                var M = w.text;
                return e.JsTyping.nodeCoreModules.has(M);
              });
            }
            __name(wa, "wa");
            e.consumesNodeCoreModules = wa;
            function Wo(l) {
              return e.contains(e.getPathComponents(l), "node_modules");
            }
            __name(Wo, "Wo");
            e.isInsideNodeModules = Wo;
            function Sa(l) {
              return l.file !== void 0 && l.start !== void 0 && l.length !== void 0;
            }
            __name(Sa, "Sa");
            e.isDiagnosticWithLocation = Sa;
            function Fa(l, w) {
              var M = ln(l), ke = e.binarySearchKey(w, M, e.identity, e.compareTextSpans);
              if (ke >= 0) {
                var cr = w[ke];
                return e.Debug.assertEqual(cr.file, l.getSourceFile(), "Diagnostics proided to 'findDiagnosticForNode' must be from a single SourceFile"), e.cast(cr, Sa);
              }
            }
            __name(Fa, "Fa");
            e.findDiagnosticForNode = Fa;
            function ho(l, w) {
              var M, ke = e.binarySearchKey(w, l.start, function(Rt) {
                return Rt.start;
              }, e.compareValues);
              for (ke < 0 && (ke = ~ke); ((M = w[ke - 1]) === null || M === void 0 ? void 0 : M.start) === l.start; )
                ke--;
              for (var cr = [], Zr = e.textSpanEnd(l); ; ) {
                var _t = e.tryCast(w[ke], Sa);
                if (!_t || _t.start > Zr)
                  break;
                e.textSpanContainsTextSpan(l, _t) && cr.push(_t), ke++;
              }
              return cr;
            }
            __name(ho, "ho");
            e.getDiagnosticsWithinSpan = ho;
            function vo(l) {
              var w = l.startPosition, M = l.endPosition;
              return e.createTextSpanFromBounds(w, M === void 0 ? w : M);
            }
            __name(vo, "vo");
            e.getRefactorContextSpan = vo;
            function eo(l, w) {
              var M = ct(l, w.start), ke = e.findAncestor(M, function(cr) {
                return cr.getStart(l) < w.start || cr.getEnd() > e.textSpanEnd(w) ? "quit" : e.isExpression(cr) && Gr(w, ln(cr, l));
              });
              return ke;
            }
            __name(eo, "eo");
            e.getFixableErrorSpanExpression = eo;
            function Aa(l, w, M) {
              return M === void 0 && (M = e.identity), l ? e.isArray(l) ? M(e.map(l, w)) : w(l, 0) : void 0;
            }
            __name(Aa, "Aa");
            e.mapOneOrMany = Aa;
            function bo(l) {
              return e.isArray(l) ? e.first(l) : l;
            }
            __name(bo, "bo");
            e.firstOrOnly = bo;
            function Is(l, w) {
              if (To(l)) {
                var M = ka(l);
                if (M)
                  return M;
                var ke = e.codefix.moduleSymbolToValidIdentifier(ro(l), w, false), cr = e.codefix.moduleSymbolToValidIdentifier(ro(l), w, true);
                return ke === cr ? ke : [ke, cr];
              }
              return l.name;
            }
            __name(Is, "Is");
            e.getNamesForExportedSymbol = Is;
            function Eo(l, w, M) {
              return To(l) ? ka(l) || e.codefix.moduleSymbolToValidIdentifier(ro(l), w, !!M) : l.name;
            }
            __name(Eo, "Eo");
            e.getNameForExportedSymbol = Eo;
            function To(l) {
              return !(l.flags & 33554432) && (l.escapedName === "export=" || l.escapedName === "default");
            }
            __name(To, "To");
            function ka(l) {
              return e.firstDefined(l.declarations, function(w) {
                var M;
                return e.isExportAssignment(w) ? (M = e.tryCast(e.skipOuterExpressions(w.expression), e.isIdentifier)) === null || M === void 0 ? void 0 : M.text : void 0;
              });
            }
            __name(ka, "ka");
            function ro(l) {
              var w;
              return e.Debug.checkDefined(l.parent, "Symbol parent was undefined. Flags: ".concat(e.Debug.formatSymbolFlags(l.flags), ". ") + "Declarations: ".concat((w = l.declarations) === null || w === void 0 ? void 0 : w.map(function(M) {
                var ke = e.Debug.formatSyntaxKind(M.kind), cr = e.isInJSFile(M), Zr = M.expression;
                return (cr ? "[JS]" : "") + ke + (Zr ? " (expression: ".concat(e.Debug.formatSyntaxKind(Zr.kind), ")") : "");
              }).join(", "), "."));
            }
            __name(ro, "ro");
            function Ko(l, w, M) {
              var ke = w.length;
              if (ke + M > l.length)
                return false;
              for (var cr = 0; cr < ke; cr++)
                if (w.charCodeAt(cr) !== l.charCodeAt(cr + M))
                  return false;
              return true;
            }
            __name(Ko, "Ko");
            e.stringContainsAt = Ko;
            function Oi(l) {
              return l.charCodeAt(0) === 95;
            }
            __name(Oi, "Oi");
            e.startsWithUnderscore = Oi;
            function Ba(l) {
              return !to(l);
            }
            __name(Ba, "Ba");
            e.isGlobalDeclaration = Ba;
            function to(l) {
              var w = l.getSourceFile();
              return !w.externalModuleIndicator && !w.commonJsModuleIndicator ? false : e.isInJSFile(l) || !e.findAncestor(l, e.isGlobalScopeAugmentation);
            }
            __name(to, "to");
            e.isNonGlobalDeclaration = to;
            function So(l) {
              return !!(e.getCombinedNodeFlagsAlwaysIncludeJSDoc(l) & 8192);
            }
            __name(So, "So");
            e.isDeprecatedDeclaration = So;
            function Co(l, w) {
              var M = e.firstDefined(l.imports, function(ke) {
                if (e.JsTyping.nodeCoreModules.has(ke.text))
                  return e.startsWith(ke.text, "node:");
              });
              return M != null ? M : w.usesUriStyleNodeCoreModules;
            }
            __name(Co, "Co");
            e.shouldUseUriStyleNodeCoreModules = Co;
            function Ho(l) {
              return l === `
` ? 1 : 0;
            }
            __name(Ho, "Ho");
            e.getNewLineKind = Ho;
            function Go(l) {
              return e.isArray(l) ? e.formatStringFromArgs(e.getLocaleSpecificMessage(l[0]), l.slice(1)) : e.getLocaleSpecificMessage(l);
            }
            __name(Go, "Go");
            e.diagnosticToString = Go;
            function Vi(l, w) {
              var M = l.options, ke = !M.semicolons || M.semicolons === e.SemicolonPreference.Ignore, cr = M.semicolons === e.SemicolonPreference.Remove || ke && !qn(w);
              return T(T({}, M), { semicolons: cr ? e.SemicolonPreference.Remove : e.SemicolonPreference.Ignore });
            }
            __name(Vi, "Vi");
            e.getFormatCodeSettingsForWriting = Vi;
            function Os(l) {
              return l === 2 || l === 3;
            }
            __name(Os, "Os");
            e.jsxModeNeedsExplicitImport = Os;
            function Do(l, w) {
              return l.isSourceFileFromExternalLibrary(w) || l.isSourceFileDefaultLibrary(w);
            }
            __name(Do, "Do");
            e.isSourceFileFromLibrary = Do;
          })(N || (N = {}));
          var N;
          (function(e) {
            var t;
            (function(je) {
              je[je.Named = 0] = "Named", je[je.Default = 1] = "Default", je[je.Namespace = 2] = "Namespace", je[je.CommonJS = 3] = "CommonJS";
            })(t = e.ImportKind || (e.ImportKind = {}));
            var x;
            (function(je) {
              je[je.Named = 0] = "Named", je[je.Default = 1] = "Default", je[je.ExportEquals = 2] = "ExportEquals", je[je.UMD = 3] = "UMD";
            })(x = e.ExportKind || (e.ExportKind = {}));
            function s(je) {
              var W = 1, B = e.createMultiMap(), U = new e.Map(), m = new e.Map(), v, g = { isUsableByFile: function(ie) {
                return ie === v;
              }, isEmpty: function() {
                return !B.size;
              }, clear: function() {
                B.clear(), U.clear(), v = void 0;
              }, add: function(ie, G, pe, j, be, $e, Re, Fe) {
                ie !== v && (g.clear(), v = ie);
                var dr;
                if (be) {
                  var ze = e.getNodeModulePathParts(be.fileName);
                  if (ze) {
                    var ve = ze.topLevelNodeModulesIndex, er = ze.topLevelPackageNameIndex, ar = ze.packageRootIndex;
                    if (dr = e.unmangleScopedPackageName(e.getPackageNameFromTypesPackageName(be.fileName.substring(er + 1, ar))), e.startsWith(ie, be.path.substring(0, ve))) {
                      var Cr = m.get(dr), Ce = be.fileName.substring(0, er + 1);
                      if (Cr) {
                        var Xe = Cr.indexOf(e.nodeModulesPathPart);
                        ve > Xe && m.set(dr, Ce);
                      } else
                        m.set(dr, Ce);
                    }
                  }
                }
                var gr = $e === 1, X = gr && e.getLocalSymbolForExportDefault(G) || G, Ee = $e === 0 || e.isExternalModuleSymbol(X) ? e.unescapeLeadingUnderscores(pe) : e.getNamesForExportedSymbol(X, void 0), we = typeof Ee == "string" ? Ee : Ee[0], he = typeof Ee == "string" ? void 0 : Ee[1], yr = e.stripQuotes(j.name), kr = W++, nr = e.skipAlias(G, Fe), tr = G.flags & 33554432 ? void 0 : G, Lr = j.flags & 33554432 ? void 0 : j;
                (!tr || !Lr) && U.set(kr, [G, j]), B.add(S(we, G, e.isExternalModuleNameRelative(yr) ? void 0 : yr, Fe), { id: kr, symbolTableKey: pe, symbolName: we, capitalizedSymbolName: he, moduleName: yr, moduleFile: be, moduleFileName: be == null ? void 0 : be.fileName, packageName: dr, exportKind: $e, targetFlags: nr.flags, isFromPackageJson: Re, symbol: tr, moduleSymbol: Lr });
              }, get: function(ie, G) {
                if (ie === v) {
                  var pe = B.get(G);
                  return pe == null ? void 0 : pe.map(O);
                }
              }, search: function(ie, G, pe, j) {
                if (ie === v)
                  return e.forEachEntry(B, function(be, $e) {
                    var Re = te($e), Fe = Re.symbolName, dr = Re.ambientModuleName, ze = G && be[0].capitalizedSymbolName || Fe;
                    if (pe(ze, be[0].targetFlags)) {
                      var ve = be.map(O), er = ve.filter(function(Cr, Ce) {
                        return ge(Cr, be[Ce].packageName);
                      });
                      if (er.length) {
                        var ar = j(er, ze, !!dr, $e);
                        if (ar !== void 0)
                          return ar;
                      }
                    }
                  });
              }, releaseSymbols: function() {
                U.clear();
              }, onFileChanged: function(ie, G, pe) {
                return Je(ie) && Je(G) ? false : v && v !== G.path || pe && e.consumesNodeCoreModules(ie) !== e.consumesNodeCoreModules(G) || !e.arrayIsEqualTo(ie.moduleAugmentations, G.moduleAugmentations) || !qe(ie, G) ? (g.clear(), true) : (v = G.path, false);
              } };
              return e.Debug.isDebugging && Object.defineProperty(g, "__cache", { get: function() {
                return B;
              } }), g;
              function O(ie) {
                if (ie.symbol && ie.moduleSymbol)
                  return ie;
                var G = ie.id, pe = ie.exportKind, j = ie.targetFlags, be = ie.isFromPackageJson, $e = ie.moduleFileName, Re = U.get(G) || e.emptyArray, Fe = Re[0], dr = Re[1];
                if (Fe && dr)
                  return { symbol: Fe, moduleSymbol: dr, moduleFileName: $e, exportKind: pe, targetFlags: j, isFromPackageJson: be };
                var ze = (be ? je.getPackageJsonAutoImportProvider() : je.getCurrentProgram()).getTypeChecker(), ve = ie.moduleSymbol || dr || e.Debug.checkDefined(ie.moduleFile ? ze.getMergedSymbol(ie.moduleFile.symbol) : ze.tryFindAmbientModule(ie.moduleName)), er = ie.symbol || Fe || e.Debug.checkDefined(pe === 2 ? ze.resolveExternalModuleSymbol(ve) : ze.tryGetMemberInModuleExportsAndProperties(e.unescapeLeadingUnderscores(ie.symbolTableKey), ve), "Could not find symbol '".concat(ie.symbolName, "' by key '").concat(ie.symbolTableKey, "' in module ").concat(ve.name));
                return U.set(G, [er, ve]), { symbol: er, moduleSymbol: ve, moduleFileName: $e, exportKind: pe, targetFlags: j, isFromPackageJson: be };
              }
              __name(O, "O");
              function S(ie, G, pe, j) {
                var be = pe || "";
                return "".concat(ie, "|").concat(e.getSymbolId(e.skipAlias(G, j)), "|").concat(be);
              }
              __name(S, "S");
              function te(ie) {
                var G = ie.substring(0, ie.indexOf("|")), pe = ie.substring(ie.lastIndexOf("|") + 1), j = pe === "" ? void 0 : pe;
                return { symbolName: G, ambientModuleName: j };
              }
              __name(te, "te");
              function Je(ie) {
                return !ie.commonJsModuleIndicator && !ie.externalModuleIndicator && !ie.moduleAugmentations && !ie.ambientModuleNames;
              }
              __name(Je, "Je");
              function qe(ie, G) {
                if (!e.arrayIsEqualTo(ie.ambientModuleNames, G.ambientModuleNames))
                  return false;
                for (var pe = -1, j = -1, be = function(ze) {
                  var ve = /* @__PURE__ */ __name(function(er) {
                    return e.isNonGlobalAmbientModule(er) && er.name.text === ze;
                  }, "ve");
                  if (pe = e.findIndex(ie.statements, ve, pe + 1), j = e.findIndex(G.statements, ve, j + 1), ie.statements[pe] !== G.statements[j])
                    return { value: false };
                }, $e = 0, Re = G.ambientModuleNames; $e < Re.length; $e++) {
                  var Fe = Re[$e], dr = be(Fe);
                  if (typeof dr == "object")
                    return dr.value;
                }
                return true;
              }
              __name(qe, "qe");
              function ge(ie, G) {
                if (!G || !ie.moduleFileName)
                  return true;
                var pe = je.getGlobalTypingsCacheLocation();
                if (pe && e.startsWith(ie.moduleFileName, pe))
                  return true;
                var j = m.get(G);
                return !j || e.startsWith(ie.moduleFileName, j);
              }
              __name(ge, "ge");
            }
            __name(s, "s");
            e.createCacheableExportInfoMap = s;
            function q(je, W, B, U, m, v, g) {
              var O;
              if (W === B)
                return false;
              var S = g == null ? void 0 : g.get(W.path, B.path, U, {});
              if ((S == null ? void 0 : S.isBlockedByPackageJsonDependencies) !== void 0)
                return !S.isBlockedByPackageJsonDependencies;
              var te = e.hostGetCanonicalFileName(v), Je = (O = v.getGlobalTypingsCacheLocation) === null || O === void 0 ? void 0 : O.call(v), qe = !!e.moduleSpecifiers.forEachFileNameOfModule(W.fileName, B.fileName, v, false, function(ie) {
                var G = je.getSourceFile(ie);
                return (G === B || !G) && F(W.fileName, ie, te, Je);
              });
              if (m) {
                var ge = qe && m.allowsImportingSourceFile(B, v);
                return g == null || g.setBlockedByPackageJsonDependencies(W.path, B.path, U, {}, !ge), ge;
              }
              return qe;
            }
            __name(q, "q");
            e.isImportableFile = q;
            function F(je, W, B, U) {
              var m = e.forEachAncestorDirectory(W, function(g) {
                return e.getBaseFileName(g) === "node_modules" ? g : void 0;
              }), v = m && e.getDirectoryPath(B(m));
              return v === void 0 || e.startsWith(B(je), v) || !!U && e.startsWith(B(U), v);
            }
            __name(F, "F");
            function fe(je, W, B, U, m) {
              var v, g, O = e.hostUsesCaseSensitiveFileNames(W), S = B.autoImportFileExcludePatterns && e.mapDefined(B.autoImportFileExcludePatterns, function(qe) {
                var ge = e.getPatternFromSpec(qe, "", "exclude");
                return ge ? e.getRegexFromPattern(ge, O) : void 0;
              });
              Te(je.getTypeChecker(), je.getSourceFiles(), S, function(qe, ge) {
                return m(qe, ge, je, false);
              });
              var te = U && ((v = W.getPackageJsonAutoImportProvider) === null || v === void 0 ? void 0 : v.call(W));
              if (te) {
                var Je = e.timestamp();
                Te(te.getTypeChecker(), te.getSourceFiles(), S, function(qe, ge) {
                  return m(qe, ge, te, true);
                }), (g = W.log) === null || g === void 0 || g.call(W, "forEachExternalModuleToImportFrom autoImportProvider: ".concat(e.timestamp() - Je));
              }
            }
            __name(fe, "fe");
            e.forEachExternalModuleToImportFrom = fe;
            function Te(je, W, B, U) {
              for (var m, v = function(ge) {
                return B == null ? void 0 : B.some(function(ie) {
                  return ie.test(ge);
                });
              }, g = 0, O = je.getAmbientModules(); g < O.length; g++) {
                var S = O[g];
                !e.stringContains(S.name, "*") && !(B && ((m = S.declarations) === null || m === void 0 ? void 0 : m.every(function(ge) {
                  return v(ge.getSourceFile().fileName);
                }))) && U(S, void 0);
              }
              for (var te = 0, Je = W; te < Je.length; te++) {
                var qe = Je[te];
                e.isExternalOrCommonJsModule(qe) && !v(qe.fileName) && U(je.getMergedSymbol(qe.symbol), qe);
              }
            }
            __name(Te, "Te");
            function Se(je, W, B, U, m) {
              var v, g, O, S, te, Je = e.timestamp();
              (v = W.getPackageJsonAutoImportProvider) === null || v === void 0 || v.call(W);
              var qe = ((g = W.getCachedExportInfoMap) === null || g === void 0 ? void 0 : g.call(W)) || s({ getCurrentProgram: function() {
                return B;
              }, getPackageJsonAutoImportProvider: function() {
                var G;
                return (G = W.getPackageJsonAutoImportProvider) === null || G === void 0 ? void 0 : G.call(W);
              }, getGlobalTypingsCacheLocation: function() {
                var G;
                return (G = W.getGlobalTypingsCacheLocation) === null || G === void 0 ? void 0 : G.call(W);
              } });
              if (qe.isUsableByFile(je.path))
                return (O = W.log) === null || O === void 0 || O.call(W, "getExportInfoMap: cache hit"), qe;
              (S = W.log) === null || S === void 0 || S.call(W, "getExportInfoMap: cache miss or empty; calculating new results");
              var ge = B.getCompilerOptions(), ie = 0;
              try {
                fe(B, W, U, true, function(G, pe, j, be) {
                  ++ie % 100 === 0 && (m == null || m.throwIfCancellationRequested());
                  var $e = new e.Map(), Re = j.getTypeChecker(), Fe = J(G, Re, ge);
                  Fe && se(Fe.symbol, Re) && qe.add(je.path, Fe.symbol, Fe.exportKind === 1 ? "default" : "export=", G, pe, Fe.exportKind, be, Re), Re.forEachExportAndPropertyOfModule(G, function(dr, ze) {
                    dr !== (Fe == null ? void 0 : Fe.symbol) && se(dr, Re) && e.addToSeen($e, ze) && qe.add(je.path, dr, ze, G, pe, 0, be, Re);
                  });
                });
              } catch (G) {
                throw qe.clear(), G;
              }
              return (te = W.log) === null || te === void 0 || te.call(W, "getExportInfoMap: done in ".concat(e.timestamp() - Je, " ms")), qe;
            }
            __name(Se, "Se");
            e.getExportInfoMap = Se;
            function J(je, W, B) {
              var U = Le(je, W);
              if (!!U) {
                var m = U.symbol, v = U.exportKind, g = Q(m, W, B);
                return g && T({ symbol: m, exportKind: v }, g);
              }
            }
            __name(J, "J");
            e.getDefaultLikeExportInfo = J;
            function se(je, W) {
              return !W.isUndefinedSymbol(je) && !W.isUnknownSymbol(je) && !e.isKnownSymbol(je) && !e.isPrivateIdentifierSymbol(je);
            }
            __name(se, "se");
            function Le(je, W) {
              var B = W.resolveExternalModuleSymbol(je);
              if (B !== je)
                return { symbol: B, exportKind: 2 };
              var U = W.tryGetMemberInModuleExports("default", je);
              if (U)
                return { symbol: U, exportKind: 1 };
            }
            __name(Le, "Le");
            function Q(je, W, B) {
              var U = e.getLocalSymbolForExportDefault(je);
              if (U)
                return { symbolForMeaning: U, name: U.name };
              var m = Be(je);
              if (m !== void 0)
                return { symbolForMeaning: je, name: m };
              if (je.flags & 2097152) {
                var v = W.getImmediateAliasedSymbol(je);
                if (v && v.parent)
                  return Q(v, W, B);
              }
              return je.escapedName !== "default" && je.escapedName !== "export=" ? { symbolForMeaning: je, name: je.getName() } : { symbolForMeaning: je, name: e.getNameForExportedSymbol(je, B.target) };
            }
            __name(Q, "Q");
            function Be(je) {
              return je.declarations && e.firstDefined(je.declarations, function(W) {
                var B;
                if (e.isExportAssignment(W))
                  return (B = e.tryCast(e.skipOuterExpressions(W.expression), e.isIdentifier)) === null || B === void 0 ? void 0 : B.text;
                if (e.isExportSpecifier(W))
                  return e.Debug.assert(W.name.text === "default", "Expected the specifier to be a default export"), W.propertyName && W.propertyName.text;
              });
            }
            __name(Be, "Be");
          })(N || (N = {}));
          var N;
          (function(e) {
            function t() {
              var O = e.createScanner(99, false);
              function S(Je, qe, ge) {
                return F(te(Je, qe, ge), Je);
              }
              __name(S, "S");
              function te(Je, qe, ge) {
                var ie = 0, G = 0, pe = [], j = Se(qe), be = j.prefix, $e = j.pushTemplate;
                Je = be + Je;
                var Re = be.length;
                $e && pe.push(15), O.setText(Je);
                var Fe = 0, dr = [], ze = 0;
                do {
                  ie = O.scan(), e.isTrivia(ie) || (ar(), G = ie);
                  var ve = O.getTextPos();
                  if (q(O.getTokenPos(), ve, Re, Le(ie), dr), ve >= Je.length) {
                    var er = s(O, ie, e.lastOrUndefined(pe));
                    er !== void 0 && (Fe = er);
                  }
                } while (ie !== 1);
                function ar() {
                  switch (ie) {
                    case 43:
                    case 68:
                      !x[G] && O.reScanSlashToken() === 13 && (ie = 13);
                      break;
                    case 29:
                      G === 79 && ze++;
                      break;
                    case 31:
                      ze > 0 && ze--;
                      break;
                    case 131:
                    case 152:
                    case 148:
                    case 134:
                    case 153:
                      ze > 0 && !ge && (ie = 79);
                      break;
                    case 15:
                      pe.push(ie);
                      break;
                    case 18:
                      pe.length > 0 && pe.push(ie);
                      break;
                    case 19:
                      if (pe.length > 0) {
                        var Cr = e.lastOrUndefined(pe);
                        Cr === 15 ? (ie = O.reScanTemplateToken(false), ie === 17 ? pe.pop() : e.Debug.assertEqual(ie, 16, "Should have been a template middle.")) : (e.Debug.assertEqual(Cr, 18, "Should have been an open brace"), pe.pop());
                      }
                      break;
                    default:
                      if (!e.isKeyword(ie))
                        break;
                      (G === 24 || e.isKeyword(G) && e.isKeyword(ie) && !Te(G, ie)) && (ie = 79);
                  }
                }
                __name(ar, "ar");
                return { endOfLineState: Fe, spans: dr };
              }
              __name(te, "te");
              return { getClassificationsForLine: S, getEncodedLexicalClassifications: te };
            }
            __name(t, "t");
            e.createClassifier = t;
            var x = e.arrayToNumericMap([79, 10, 8, 9, 13, 108, 45, 46, 21, 23, 19, 110, 95], function(O) {
              return O;
            }, function() {
              return true;
            });
            function s(O, S, te) {
              switch (S) {
                case 10: {
                  if (!O.isUnterminated())
                    return;
                  for (var Je = O.getTokenText(), qe = Je.length - 1, ge = 0; Je.charCodeAt(qe - ge) === 92; )
                    ge++;
                  return (ge & 1) === 0 ? void 0 : Je.charCodeAt(0) === 34 ? 3 : 2;
                }
                case 3:
                  return O.isUnterminated() ? 1 : void 0;
                default:
                  if (e.isTemplateLiteralKind(S)) {
                    if (!O.isUnterminated())
                      return;
                    switch (S) {
                      case 17:
                        return 5;
                      case 14:
                        return 4;
                      default:
                        return e.Debug.fail("Only 'NoSubstitutionTemplateLiteral's and 'TemplateTail's can be unterminated; got SyntaxKind #" + S);
                    }
                  }
                  return te === 15 ? 6 : void 0;
              }
            }
            __name(s, "s");
            function q(O, S, te, Je, qe) {
              if (Je !== 8) {
                O === 0 && te > 0 && (O += te);
                var ge = S - O;
                ge > 0 && qe.push(O - te, ge, Je);
              }
            }
            __name(q, "q");
            function F(O, S) {
              for (var te = [], Je = O.spans, qe = 0, ge = 0; ge < Je.length; ge += 3) {
                var ie = Je[ge], G = Je[ge + 1], pe = Je[ge + 2];
                if (qe >= 0) {
                  var j = ie - qe;
                  j > 0 && te.push({ length: j, classification: e.TokenClass.Whitespace });
                }
                te.push({ length: G, classification: fe(pe) }), qe = ie + G;
              }
              var be = S.length - qe;
              return be > 0 && te.push({ length: be, classification: e.TokenClass.Whitespace }), { entries: te, finalLexState: O.endOfLineState };
            }
            __name(F, "F");
            function fe(O) {
              switch (O) {
                case 1:
                  return e.TokenClass.Comment;
                case 3:
                  return e.TokenClass.Keyword;
                case 4:
                  return e.TokenClass.NumberLiteral;
                case 25:
                  return e.TokenClass.BigIntLiteral;
                case 5:
                  return e.TokenClass.Operator;
                case 6:
                  return e.TokenClass.StringLiteral;
                case 8:
                  return e.TokenClass.Whitespace;
                case 10:
                  return e.TokenClass.Punctuation;
                case 2:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 9:
                case 17:
                  return e.TokenClass.Identifier;
                default:
                  return;
              }
            }
            __name(fe, "fe");
            function Te(O, S) {
              if (!e.isAccessibilityModifier(O))
                return true;
              switch (S) {
                case 137:
                case 151:
                case 135:
                case 124:
                case 127:
                  return true;
                default:
                  return false;
              }
            }
            __name(Te, "Te");
            function Se(O) {
              switch (O) {
                case 3:
                  return { prefix: `"\\
` };
                case 2:
                  return { prefix: `'\\
` };
                case 1:
                  return { prefix: `/*
` };
                case 4:
                  return { prefix: "`\n" };
                case 5:
                  return { prefix: `}
`, pushTemplate: true };
                case 6:
                  return { prefix: "", pushTemplate: true };
                case 0:
                  return { prefix: "" };
                default:
                  return e.Debug.assertNever(O);
              }
            }
            __name(Se, "Se");
            function J(O) {
              switch (O) {
                case 41:
                case 43:
                case 44:
                case 39:
                case 40:
                case 47:
                case 48:
                case 49:
                case 29:
                case 31:
                case 32:
                case 33:
                case 102:
                case 101:
                case 128:
                case 150:
                case 34:
                case 35:
                case 36:
                case 37:
                case 50:
                case 52:
                case 51:
                case 55:
                case 56:
                case 74:
                case 73:
                case 78:
                case 70:
                case 71:
                case 72:
                case 64:
                case 65:
                case 66:
                case 68:
                case 69:
                case 63:
                case 27:
                case 60:
                case 75:
                case 76:
                case 77:
                  return true;
                default:
                  return false;
              }
            }
            __name(J, "J");
            function se(O) {
              switch (O) {
                case 39:
                case 40:
                case 54:
                case 53:
                case 45:
                case 46:
                  return true;
                default:
                  return false;
              }
            }
            __name(se, "se");
            function Le(O) {
              if (e.isKeyword(O))
                return 3;
              if (J(O) || se(O))
                return 5;
              if (O >= 18 && O <= 78)
                return 10;
              switch (O) {
                case 8:
                  return 4;
                case 9:
                  return 25;
                case 10:
                  return 6;
                case 13:
                  return 7;
                case 7:
                case 3:
                case 2:
                  return 1;
                case 5:
                case 4:
                  return 8;
                case 79:
                default:
                  return e.isTemplateLiteralKind(O) ? 6 : 2;
              }
            }
            __name(Le, "Le");
            function Q(O, S, te, Je, qe) {
              return m(je(O, S, te, Je, qe));
            }
            __name(Q, "Q");
            e.getSemanticClassifications = Q;
            function Be(O, S) {
              switch (S) {
                case 264:
                case 260:
                case 261:
                case 259:
                case 228:
                case 215:
                case 216:
                  O.throwIfCancellationRequested();
              }
            }
            __name(Be, "Be");
            function je(O, S, te, Je, qe) {
              var ge = [];
              return te.forEachChild(/* @__PURE__ */ __name(function G(pe) {
                if (!(!pe || !e.textSpanIntersectsWith(qe, pe.pos, pe.getFullWidth()))) {
                  if (Be(S, pe.kind), e.isIdentifier(pe) && !e.nodeIsMissing(pe) && Je.has(pe.escapedText)) {
                    var j = O.getSymbolAtLocation(pe), be = j && W(j, e.getMeaningFromLocation(pe), O);
                    be && ie(pe.getStart(te), pe.getEnd(), be);
                  }
                  pe.forEachChild(G);
                }
              }, "G")), { spans: ge, endOfLineState: 0 };
              function ie(G, pe, j) {
                var be = pe - G;
                e.Debug.assert(be > 0, "Classification had non-positive length of ".concat(be)), ge.push(G), ge.push(be), ge.push(j);
              }
              __name(ie, "ie");
            }
            __name(je, "je");
            e.getEncodedSemanticClassifications = je;
            function W(O, S, te) {
              var Je = O.getFlags();
              if ((Je & 2885600) !== 0)
                return Je & 32 ? 11 : Je & 384 ? 12 : Je & 524288 ? 16 : Je & 1536 ? S & 4 || S & 1 && B(O) ? 14 : void 0 : Je & 2097152 ? W(te.getAliasedSymbol(O), S, te) : S & 2 ? Je & 64 ? 13 : Je & 262144 ? 15 : void 0 : void 0;
            }
            __name(W, "W");
            function B(O) {
              return e.some(O.declarations, function(S) {
                return e.isModuleDeclaration(S) && e.getModuleInstanceState(S) === 1;
              });
            }
            __name(B, "B");
            function U(O) {
              switch (O) {
                case 1:
                  return "comment";
                case 2:
                  return "identifier";
                case 3:
                  return "keyword";
                case 4:
                  return "number";
                case 25:
                  return "bigint";
                case 5:
                  return "operator";
                case 6:
                  return "string";
                case 8:
                  return "whitespace";
                case 9:
                  return "text";
                case 10:
                  return "punctuation";
                case 11:
                  return "class name";
                case 12:
                  return "enum name";
                case 13:
                  return "interface name";
                case 14:
                  return "module name";
                case 15:
                  return "type parameter name";
                case 16:
                  return "type alias name";
                case 17:
                  return "parameter name";
                case 18:
                  return "doc comment tag name";
                case 19:
                  return "jsx open tag name";
                case 20:
                  return "jsx close tag name";
                case 21:
                  return "jsx self closing tag name";
                case 22:
                  return "jsx attribute";
                case 23:
                  return "jsx text";
                case 24:
                  return "jsx attribute string literal value";
                default:
                  return;
              }
            }
            __name(U, "U");
            function m(O) {
              e.Debug.assert(O.spans.length % 3 === 0);
              for (var S = O.spans, te = [], Je = 0; Je < S.length; Je += 3)
                te.push({ textSpan: e.createTextSpan(S[Je], S[Je + 1]), classificationType: U(S[Je + 2]) });
              return te;
            }
            __name(m, "m");
            function v(O, S, te) {
              return m(g(O, S, te));
            }
            __name(v, "v");
            e.getSyntacticClassifications = v;
            function g(O, S, te) {
              var Je = te.start, qe = te.length, ge = e.createScanner(99, false, S.languageVariant, S.text), ie = e.createScanner(99, false, S.languageVariant, S.text), G = [];
              return Ce(S), { spans: G, endOfLineState: 0 };
              function pe(Xe, gr, X) {
                G.push(Xe), G.push(gr), G.push(X);
              }
              __name(pe, "pe");
              function j(Xe) {
                for (ge.setTextPos(Xe.pos); ; ) {
                  var gr = ge.getTextPos();
                  if (!e.couldStartTrivia(S.text, gr))
                    return gr;
                  var X = ge.scan(), Ee = ge.getTextPos(), we = Ee - gr;
                  if (!e.isTrivia(X))
                    return gr;
                  switch (X) {
                    case 4:
                    case 5:
                      continue;
                    case 2:
                    case 3:
                      be(Xe, X, gr, we), ge.setTextPos(Ee);
                      continue;
                    case 7:
                      var he = S.text, yr = he.charCodeAt(gr);
                      if (yr === 60 || yr === 62) {
                        pe(gr, we, 1);
                        continue;
                      }
                      e.Debug.assert(yr === 124 || yr === 61), ze(he, gr, Ee);
                      break;
                    case 6:
                      break;
                    default:
                      e.Debug.assertNever(X);
                  }
                }
              }
              __name(j, "j");
              function be(Xe, gr, X, Ee) {
                if (gr === 3) {
                  var we = e.parseIsolatedJSDocComment(S.text, X, Ee);
                  if (we && we.jsDoc) {
                    e.setParent(we.jsDoc, Xe), Re(we.jsDoc);
                    return;
                  }
                } else if (gr === 2 && Fe(X, Ee))
                  return;
                $e(X, Ee);
              }
              __name(be, "be");
              function $e(Xe, gr) {
                pe(Xe, gr, 1);
              }
              __name($e, "$e");
              function Re(Xe) {
                var gr, X, Ee, we, he, yr, kr, nr = Xe.pos;
                if (Xe.tags)
                  for (var tr = 0, Lr = Xe.tags; tr < Lr.length; tr++) {
                    var zr = Lr[tr];
                    zr.pos !== nr && $e(nr, zr.pos - nr), pe(zr.pos, 1, 10), pe(zr.tagName.pos, zr.tagName.end - zr.tagName.pos, 18), nr = zr.tagName.end;
                    var ye = zr.tagName.end;
                    switch (zr.kind) {
                      case 343:
                        var ir = zr;
                        Br(ir), ye = ir.isNameFirst && ((gr = ir.typeExpression) === null || gr === void 0 ? void 0 : gr.end) || ir.name.end;
                        break;
                      case 350:
                        var Dr = zr;
                        ye = Dr.isNameFirst && ((X = Dr.typeExpression) === null || X === void 0 ? void 0 : X.end) || Dr.name.end;
                        break;
                      case 347:
                        dr(zr), nr = zr.end, ye = zr.typeParameters.end;
                        break;
                      case 348:
                        var Pr = zr;
                        ye = ((Ee = Pr.typeExpression) === null || Ee === void 0 ? void 0 : Ee.kind) === 312 && ((we = Pr.fullName) === null || we === void 0 ? void 0 : we.end) || ((he = Pr.typeExpression) === null || he === void 0 ? void 0 : he.end) || ye;
                        break;
                      case 341:
                        ye = zr.typeExpression.end;
                        break;
                      case 346:
                        Ce(zr.typeExpression), nr = zr.end, ye = zr.typeExpression.end;
                        break;
                      case 345:
                      case 342:
                        ye = zr.typeExpression.end;
                        break;
                      case 344:
                        Ce(zr.typeExpression), nr = zr.end, ye = ((yr = zr.typeExpression) === null || yr === void 0 ? void 0 : yr.end) || ye;
                        break;
                      case 349:
                        ye = ((kr = zr.name) === null || kr === void 0 ? void 0 : kr.end) || ye;
                        break;
                      case 331:
                      case 332:
                        ye = zr.class.end;
                        break;
                    }
                    typeof zr.comment == "object" ? $e(zr.comment.pos, zr.comment.end - zr.comment.pos) : typeof zr.comment == "string" && $e(ye, zr.end - ye);
                  }
                nr !== Xe.end && $e(nr, Xe.end - nr);
                return;
                function Br(ut) {
                  ut.isNameFirst && ($e(nr, ut.name.pos - nr), pe(ut.name.pos, ut.name.end - ut.name.pos, 17), nr = ut.name.end), ut.typeExpression && ($e(nr, ut.typeExpression.pos - nr), Ce(ut.typeExpression), nr = ut.typeExpression.end), ut.isNameFirst || ($e(nr, ut.name.pos - nr), pe(ut.name.pos, ut.name.end - ut.name.pos, 17), nr = ut.name.end);
                }
                __name(Br, "Br");
              }
              __name(Re, "Re");
              function Fe(Xe, gr) {
                var X = /^(\/\/\/\s*)(<)(?:(\S+)((?:[^/]|\/[^>])*)(\/>)?)?/im, Ee = /(\s)(\S+)(\s*)(=)(\s*)('[^']+'|"[^"]+")/img, we = S.text.substr(Xe, gr), he = X.exec(we);
                if (!he || !he[3] || !(he[3] in e.commentPragmas))
                  return false;
                var yr = Xe;
                $e(yr, he[1].length), yr += he[1].length, pe(yr, he[2].length, 10), yr += he[2].length, pe(yr, he[3].length, 21), yr += he[3].length;
                for (var kr = he[4], nr = yr; ; ) {
                  var tr = Ee.exec(kr);
                  if (!tr)
                    break;
                  var Lr = yr + tr.index + tr[1].length;
                  Lr > nr && ($e(nr, Lr - nr), nr = Lr), pe(nr, tr[2].length, 22), nr += tr[2].length, tr[3].length && ($e(nr, tr[3].length), nr += tr[3].length), pe(nr, tr[4].length, 5), nr += tr[4].length, tr[5].length && ($e(nr, tr[5].length), nr += tr[5].length), pe(nr, tr[6].length, 24), nr += tr[6].length;
                }
                yr += he[4].length, yr > nr && $e(nr, yr - nr), he[5] && (pe(yr, he[5].length, 10), yr += he[5].length);
                var zr = Xe + gr;
                return yr < zr && $e(yr, zr - yr), true;
              }
              __name(Fe, "Fe");
              function dr(Xe) {
                for (var gr = 0, X = Xe.getChildren(); gr < X.length; gr++) {
                  var Ee = X[gr];
                  Ce(Ee);
                }
              }
              __name(dr, "dr");
              function ze(Xe, gr, X) {
                var Ee;
                for (Ee = gr; Ee < X && !e.isLineBreak(Xe.charCodeAt(Ee)); Ee++)
                  ;
                for (pe(gr, Ee - gr, 1), ie.setTextPos(Ee); ie.getTextPos() < X; )
                  ve();
              }
              __name(ze, "ze");
              function ve() {
                var Xe = ie.getTextPos(), gr = ie.scan(), X = ie.getTextPos(), Ee = Cr(gr);
                Ee && pe(Xe, X - Xe, Ee);
              }
              __name(ve, "ve");
              function er(Xe) {
                if (e.isJSDoc(Xe) || e.nodeIsMissing(Xe))
                  return true;
                var gr = ar(Xe);
                if (!e.isToken(Xe) && Xe.kind !== 11 && gr === void 0)
                  return false;
                var X = Xe.kind === 11 ? Xe.pos : j(Xe), Ee = Xe.end - X;
                if (e.Debug.assert(Ee >= 0), Ee > 0) {
                  var we = gr || Cr(Xe.kind, Xe);
                  we && pe(X, Ee, we);
                }
                return true;
              }
              __name(er, "er");
              function ar(Xe) {
                switch (Xe.parent && Xe.parent.kind) {
                  case 283:
                    if (Xe.parent.tagName === Xe)
                      return 19;
                    break;
                  case 284:
                    if (Xe.parent.tagName === Xe)
                      return 20;
                    break;
                  case 282:
                    if (Xe.parent.tagName === Xe)
                      return 21;
                    break;
                  case 288:
                    if (Xe.parent.name === Xe)
                      return 22;
                    break;
                }
              }
              __name(ar, "ar");
              function Cr(Xe, gr) {
                if (e.isKeyword(Xe))
                  return 3;
                if ((Xe === 29 || Xe === 31) && gr && e.getTypeArgumentOrTypeParameterList(gr.parent))
                  return 10;
                if (e.isPunctuation(Xe)) {
                  if (gr) {
                    var X = gr.parent;
                    if (Xe === 63 && (X.kind === 257 || X.kind === 169 || X.kind === 166 || X.kind === 288) || X.kind === 223 || X.kind === 221 || X.kind === 222 || X.kind === 224)
                      return 5;
                  }
                  return 10;
                } else {
                  if (Xe === 8)
                    return 4;
                  if (Xe === 9)
                    return 25;
                  if (Xe === 10)
                    return gr && gr.parent.kind === 288 ? 24 : 6;
                  if (Xe === 13)
                    return 6;
                  if (e.isTemplateLiteralKind(Xe))
                    return 6;
                  if (Xe === 11)
                    return 23;
                  if (Xe === 79) {
                    if (gr) {
                      switch (gr.parent.kind) {
                        case 260:
                          return gr.parent.name === gr ? 11 : void 0;
                        case 165:
                          return gr.parent.name === gr ? 15 : void 0;
                        case 261:
                          return gr.parent.name === gr ? 13 : void 0;
                        case 263:
                          return gr.parent.name === gr ? 12 : void 0;
                        case 264:
                          return gr.parent.name === gr ? 14 : void 0;
                        case 166:
                          return gr.parent.name === gr ? e.isThisIdentifier(gr) ? 3 : 17 : void 0;
                      }
                      if (e.isConstTypeReference(gr.parent))
                        return 3;
                    }
                    return 2;
                  }
                }
              }
              __name(Cr, "Cr");
              function Ce(Xe) {
                if (!!Xe && e.decodedTextSpanIntersectsWith(Je, qe, Xe.pos, Xe.getFullWidth())) {
                  Be(O, Xe.kind);
                  for (var gr = 0, X = Xe.getChildren(S); gr < X.length; gr++) {
                    var Ee = X[gr];
                    er(Ee) || Ce(Ee);
                  }
                }
              }
              __name(Ce, "Ce");
            }
            __name(g, "g");
            e.getEncodedSyntacticClassifications = g;
          })(N || (N = {}));
          var N;
          (function(e) {
            var t;
            (function(x) {
              var s;
              (function(q) {
                var F;
                (function(g) {
                  g[g.typeOffset = 8] = "typeOffset", g[g.modifierMask = 255] = "modifierMask";
                })(F = q.TokenEncodingConsts || (q.TokenEncodingConsts = {}));
                var fe;
                (function(g) {
                  g[g.class = 0] = "class", g[g.enum = 1] = "enum", g[g.interface = 2] = "interface", g[g.namespace = 3] = "namespace", g[g.typeParameter = 4] = "typeParameter", g[g.type = 5] = "type", g[g.parameter = 6] = "parameter", g[g.variable = 7] = "variable", g[g.enumMember = 8] = "enumMember", g[g.property = 9] = "property", g[g.function = 10] = "function", g[g.member = 11] = "member";
                })(fe = q.TokenType || (q.TokenType = {}));
                var Te;
                (function(g) {
                  g[g.declaration = 0] = "declaration", g[g.static = 1] = "static", g[g.async = 2] = "async", g[g.readonly = 3] = "readonly", g[g.defaultLibrary = 4] = "defaultLibrary", g[g.local = 5] = "local";
                })(Te = q.TokenModifier || (q.TokenModifier = {}));
                function Se(g, O, S, te) {
                  var Je = J(g, O, S, te);
                  e.Debug.assert(Je.spans.length % 3 === 0);
                  for (var qe = Je.spans, ge = [], ie = 0; ie < qe.length; ie += 3)
                    ge.push({ textSpan: e.createTextSpan(qe[ie], qe[ie + 1]), classificationType: qe[ie + 2] });
                  return ge;
                }
                __name(Se, "Se");
                q.getSemanticClassifications = Se;
                function J(g, O, S, te) {
                  return { spans: se(g, S, te, O), endOfLineState: 0 };
                }
                __name(J, "J");
                q.getEncodedSemanticClassifications = J;
                function se(g, O, S, te) {
                  var Je = [], qe = /* @__PURE__ */ __name(function(ge, ie, G) {
                    Je.push(ge.getStart(O), ge.getWidth(O), (ie + 1 << 8) + G);
                  }, "qe");
                  return g && O && Le(g, O, S, qe, te), Je;
                }
                __name(se, "se");
                function Le(g, O, S, te, Je) {
                  var qe = g.getTypeChecker(), ge = false;
                  function ie(G) {
                    switch (G.kind) {
                      case 264:
                      case 260:
                      case 261:
                      case 259:
                      case 228:
                      case 215:
                      case 216:
                        Je.throwIfCancellationRequested();
                    }
                    if (!(!G || !e.textSpanIntersectsWith(S, G.pos, G.getFullWidth()) || G.getFullWidth() === 0)) {
                      var pe = ge;
                      if ((e.isJsxElement(G) || e.isJsxSelfClosingElement(G)) && (ge = true), e.isJsxExpression(G) && (ge = false), e.isIdentifier(G) && !ge && !B(G) && !e.isInfinityOrNaNString(G.escapedText)) {
                        var j = qe.getSymbolAtLocation(G);
                        if (j) {
                          j.flags & 2097152 && (j = qe.getAliasedSymbol(j));
                          var be = Q(j, e.getMeaningFromLocation(G));
                          if (be !== void 0) {
                            var $e = 0;
                            if (G.parent) {
                              var Re = e.isBindingElement(G.parent) || v.get(G.parent.kind) === be;
                              Re && G.parent.name === G && ($e = 1 << 0);
                            }
                            be === 6 && m(G) && (be = 9), be = Be(qe, G, be);
                            var Fe = j.valueDeclaration;
                            if (Fe) {
                              var dr = e.getCombinedModifierFlags(Fe), ze = e.getCombinedNodeFlags(Fe);
                              dr & 32 && ($e |= 1 << 1), dr & 512 && ($e |= 1 << 2), be !== 0 && be !== 2 && (dr & 64 || ze & 2 || j.getFlags() & 8) && ($e |= 1 << 3), (be === 7 || be === 10) && je(Fe, O) && ($e |= 1 << 5), g.isSourceFileDefaultLibrary(Fe.getSourceFile()) && ($e |= 1 << 4);
                            } else
                              j.declarations && j.declarations.some(function(ve) {
                                return g.isSourceFileDefaultLibrary(ve.getSourceFile());
                              }) && ($e |= 1 << 4);
                            te(G, be, $e);
                          }
                        }
                      }
                      e.forEachChild(G, ie), ge = pe;
                    }
                  }
                  __name(ie, "ie");
                  ie(O);
                }
                __name(Le, "Le");
                function Q(g, O) {
                  var S = g.getFlags();
                  if (S & 32)
                    return 0;
                  if (S & 384)
                    return 1;
                  if (S & 524288)
                    return 5;
                  if (S & 64) {
                    if (O & 2)
                      return 2;
                  } else if (S & 262144)
                    return 4;
                  var te = g.valueDeclaration || g.declarations && g.declarations[0];
                  return te && e.isBindingElement(te) && (te = W(te)), te && v.get(te.kind);
                }
                __name(Q, "Q");
                function Be(g, O, S) {
                  if (S === 7 || S === 9 || S === 6) {
                    var te = g.getTypeAtLocation(O);
                    if (te) {
                      var Je = /* @__PURE__ */ __name(function(qe) {
                        return qe(te) || te.isUnion() && te.types.some(qe);
                      }, "Je");
                      if (S !== 6 && Je(function(qe) {
                        return qe.getConstructSignatures().length > 0;
                      }))
                        return 0;
                      if (Je(function(qe) {
                        return qe.getCallSignatures().length > 0;
                      }) && !Je(function(qe) {
                        return qe.getProperties().length > 0;
                      }) || U(O))
                        return S === 9 ? 11 : 10;
                    }
                  }
                  return S;
                }
                __name(Be, "Be");
                function je(g, O) {
                  return e.isBindingElement(g) && (g = W(g)), e.isVariableDeclaration(g) ? (!e.isSourceFile(g.parent.parent.parent) || e.isCatchClause(g.parent)) && g.getSourceFile() === O : e.isFunctionDeclaration(g) ? !e.isSourceFile(g.parent) && g.getSourceFile() === O : false;
                }
                __name(je, "je");
                function W(g) {
                  for (; ; )
                    if (e.isBindingElement(g.parent.parent))
                      g = g.parent.parent;
                    else
                      return g.parent.parent;
                }
                __name(W, "W");
                function B(g) {
                  var O = g.parent;
                  return O && (e.isImportClause(O) || e.isImportSpecifier(O) || e.isNamespaceImport(O));
                }
                __name(B, "B");
                function U(g) {
                  for (; m(g); )
                    g = g.parent;
                  return e.isCallExpression(g.parent) && g.parent.expression === g;
                }
                __name(U, "U");
                function m(g) {
                  return e.isQualifiedName(g.parent) && g.parent.right === g || e.isPropertyAccessExpression(g.parent) && g.parent.name === g;
                }
                __name(m, "m");
                var v = new e.Map([[257, 7], [166, 6], [169, 9], [264, 3], [263, 1], [302, 8], [260, 0], [171, 11], [259, 10], [215, 10], [170, 11], [174, 9], [175, 9], [168, 9], [261, 2], [262, 5], [165, 4], [299, 9], [300, 9]]);
              })(s = x.v2020 || (x.v2020 = {}));
            })(t = e.classifier || (e.classifier = {}));
          })(N || (N = {}));
          var N;
          (function(e) {
            e.servicesVersion = "0.8";
            function t(X, Ee, we, he) {
              var yr = e.isNodeKind(X) ? new x(X, Ee, we) : X === 79 ? new J(79, Ee, we) : X === 80 ? new se(80, Ee, we) : new Se(X, Ee, we);
              return yr.parent = he, yr.flags = he.flags & 50720768, yr;
            }
            __name(t, "t");
            var x = function() {
              function X(Ee, we, he) {
                this.pos = we, this.end = he, this.flags = 0, this.modifierFlagsCache = 0, this.transformFlags = 0, this.parent = void 0, this.kind = Ee;
              }
              __name(X, "X");
              return X.prototype.assertHasRealPosition = function(Ee) {
                e.Debug.assert(!e.positionIsSynthesized(this.pos) && !e.positionIsSynthesized(this.end), Ee || "Node must have a real position for this operation");
              }, X.prototype.getSourceFile = function() {
                return e.getSourceFileOfNode(this);
              }, X.prototype.getStart = function(Ee, we) {
                return this.assertHasRealPosition(), e.getTokenPosOfNode(this, Ee, we);
              }, X.prototype.getFullStart = function() {
                return this.assertHasRealPosition(), this.pos;
              }, X.prototype.getEnd = function() {
                return this.assertHasRealPosition(), this.end;
              }, X.prototype.getWidth = function(Ee) {
                return this.assertHasRealPosition(), this.getEnd() - this.getStart(Ee);
              }, X.prototype.getFullWidth = function() {
                return this.assertHasRealPosition(), this.end - this.pos;
              }, X.prototype.getLeadingTriviaWidth = function(Ee) {
                return this.assertHasRealPosition(), this.getStart(Ee) - this.pos;
              }, X.prototype.getFullText = function(Ee) {
                return this.assertHasRealPosition(), (Ee || this.getSourceFile()).text.substring(this.pos, this.end);
              }, X.prototype.getText = function(Ee) {
                return this.assertHasRealPosition(), Ee || (Ee = this.getSourceFile()), Ee.text.substring(this.getStart(Ee), this.getEnd());
              }, X.prototype.getChildCount = function(Ee) {
                return this.getChildren(Ee).length;
              }, X.prototype.getChildAt = function(Ee, we) {
                return this.getChildren(we)[Ee];
              }, X.prototype.getChildren = function(Ee) {
                return this.assertHasRealPosition("Node without a real position cannot be scanned and thus has no token nodes - use forEachChild and collect the result if that's fine"), this._children || (this._children = s(this, Ee));
              }, X.prototype.getFirstToken = function(Ee) {
                this.assertHasRealPosition();
                var we = this.getChildren(Ee);
                if (!!we.length) {
                  var he = e.find(we, function(yr) {
                    return yr.kind < 312 || yr.kind > 350;
                  });
                  return he.kind < 163 ? he : he.getFirstToken(Ee);
                }
              }, X.prototype.getLastToken = function(Ee) {
                this.assertHasRealPosition();
                var we = this.getChildren(Ee), he = e.lastOrUndefined(we);
                if (!!he)
                  return he.kind < 163 ? he : he.getLastToken(Ee);
              }, X.prototype.forEachChild = function(Ee, we) {
                return e.forEachChild(this, Ee, we);
              }, X;
            }();
            function s(X, Ee) {
              if (!e.isNodeKind(X.kind))
                return e.emptyArray;
              var we = [];
              if (e.isJSDocCommentContainingNode(X))
                return X.forEachChild(function(nr) {
                  we.push(nr);
                }), we;
              e.scanner.setText((Ee || X.getSourceFile()).text);
              var he = X.pos, yr = /* @__PURE__ */ __name(function(nr) {
                q(we, he, nr.pos, X), we.push(nr), he = nr.end;
              }, "yr"), kr = /* @__PURE__ */ __name(function(nr) {
                q(we, he, nr.pos, X), we.push(F(nr, X)), he = nr.end;
              }, "kr");
              return e.forEach(X.jsDoc, yr), he = X.pos, X.forEachChild(yr, kr), q(we, he, X.end, X), e.scanner.setText(void 0), we;
            }
            __name(s, "s");
            function q(X, Ee, we, he) {
              for (e.scanner.setTextPos(Ee); Ee < we; ) {
                var yr = e.scanner.scan(), kr = e.scanner.getTextPos();
                if (kr <= we && (yr === 79 && e.Debug.fail("Did not expect ".concat(e.Debug.formatSyntaxKind(he.kind), " to have an Identifier in its trivia")), X.push(t(yr, Ee, kr, he))), Ee = kr, yr === 1)
                  break;
              }
            }
            __name(q, "q");
            function F(X, Ee) {
              var we = t(351, X.pos, X.end, Ee);
              we._children = [];
              for (var he = X.pos, yr = 0, kr = X; yr < kr.length; yr++) {
                var nr = kr[yr];
                q(we._children, he, nr.pos, Ee), we._children.push(nr), he = nr.end;
              }
              return q(we._children, he, X.end, Ee), we;
            }
            __name(F, "F");
            var fe = function() {
              function X(Ee, we) {
                this.pos = Ee, this.end = we, this.flags = 0, this.modifierFlagsCache = 0, this.transformFlags = 0, this.parent = void 0;
              }
              __name(X, "X");
              return X.prototype.getSourceFile = function() {
                return e.getSourceFileOfNode(this);
              }, X.prototype.getStart = function(Ee, we) {
                return e.getTokenPosOfNode(this, Ee, we);
              }, X.prototype.getFullStart = function() {
                return this.pos;
              }, X.prototype.getEnd = function() {
                return this.end;
              }, X.prototype.getWidth = function(Ee) {
                return this.getEnd() - this.getStart(Ee);
              }, X.prototype.getFullWidth = function() {
                return this.end - this.pos;
              }, X.prototype.getLeadingTriviaWidth = function(Ee) {
                return this.getStart(Ee) - this.pos;
              }, X.prototype.getFullText = function(Ee) {
                return (Ee || this.getSourceFile()).text.substring(this.pos, this.end);
              }, X.prototype.getText = function(Ee) {
                return Ee || (Ee = this.getSourceFile()), Ee.text.substring(this.getStart(Ee), this.getEnd());
              }, X.prototype.getChildCount = function() {
                return this.getChildren().length;
              }, X.prototype.getChildAt = function(Ee) {
                return this.getChildren()[Ee];
              }, X.prototype.getChildren = function() {
                return this.kind === 1 && this.jsDoc || e.emptyArray;
              }, X.prototype.getFirstToken = function() {
              }, X.prototype.getLastToken = function() {
              }, X.prototype.forEachChild = function() {
              }, X;
            }(), Te = function() {
              function X(Ee, we) {
                this.flags = Ee, this.escapedName = we;
              }
              __name(X, "X");
              return X.prototype.getFlags = function() {
                return this.flags;
              }, Object.defineProperty(X.prototype, "name", { get: function() {
                return e.symbolName(this);
              }, enumerable: false, configurable: true }), X.prototype.getEscapedName = function() {
                return this.escapedName;
              }, X.prototype.getName = function() {
                return this.name;
              }, X.prototype.getDeclarations = function() {
                return this.declarations;
              }, X.prototype.getDocumentationComment = function(Ee) {
                if (!this.documentationComment)
                  if (this.documentationComment = e.emptyArray, !this.declarations && this.target && this.target.tupleLabelDeclaration) {
                    var we = this.target.tupleLabelDeclaration;
                    this.documentationComment = W([we], Ee);
                  } else
                    this.documentationComment = W(this.declarations, Ee);
                return this.documentationComment;
              }, X.prototype.getContextualDocumentationComment = function(Ee, we) {
                if (Ee) {
                  if (e.isGetAccessor(Ee) && (this.contextualGetAccessorDocumentationComment || (this.contextualGetAccessorDocumentationComment = W(e.filter(this.declarations, e.isGetAccessor), we)), e.length(this.contextualGetAccessorDocumentationComment)))
                    return this.contextualGetAccessorDocumentationComment;
                  if (e.isSetAccessor(Ee) && (this.contextualSetAccessorDocumentationComment || (this.contextualSetAccessorDocumentationComment = W(e.filter(this.declarations, e.isSetAccessor), we)), e.length(this.contextualSetAccessorDocumentationComment)))
                    return this.contextualSetAccessorDocumentationComment;
                }
                return this.getDocumentationComment(we);
              }, X.prototype.getJsDocTags = function(Ee) {
                return this.tags === void 0 && (this.tags = je(this.declarations, Ee)), this.tags;
              }, X.prototype.getContextualJsDocTags = function(Ee, we) {
                if (Ee) {
                  if (e.isGetAccessor(Ee) && (this.contextualGetAccessorTags || (this.contextualGetAccessorTags = je(e.filter(this.declarations, e.isGetAccessor), we)), e.length(this.contextualGetAccessorTags)))
                    return this.contextualGetAccessorTags;
                  if (e.isSetAccessor(Ee) && (this.contextualSetAccessorTags || (this.contextualSetAccessorTags = je(e.filter(this.declarations, e.isSetAccessor), we)), e.length(this.contextualSetAccessorTags)))
                    return this.contextualSetAccessorTags;
                }
                return this.getJsDocTags(we);
              }, X;
            }(), Se = function(X) {
              E(Ee, X);
              function Ee(we, he, yr) {
                var kr = X.call(this, he, yr) || this;
                return kr.kind = we, kr;
              }
              __name(Ee, "Ee");
              return Ee;
            }(fe), J = function(X) {
              E(Ee, X);
              function Ee(we, he, yr) {
                var kr = X.call(this, he, yr) || this;
                return kr.kind = 79, kr;
              }
              __name(Ee, "Ee");
              return Object.defineProperty(Ee.prototype, "text", { get: function() {
                return e.idText(this);
              }, enumerable: false, configurable: true }), Ee;
            }(fe);
            J.prototype.kind = 79;
            var se = function(X) {
              E(Ee, X);
              function Ee(we, he, yr) {
                return X.call(this, he, yr) || this;
              }
              __name(Ee, "Ee");
              return Object.defineProperty(Ee.prototype, "text", { get: function() {
                return e.idText(this);
              }, enumerable: false, configurable: true }), Ee;
            }(fe);
            se.prototype.kind = 80;
            var Le = function() {
              function X(Ee, we) {
                this.checker = Ee, this.flags = we;
              }
              __name(X, "X");
              return X.prototype.getFlags = function() {
                return this.flags;
              }, X.prototype.getSymbol = function() {
                return this.symbol;
              }, X.prototype.getProperties = function() {
                return this.checker.getPropertiesOfType(this);
              }, X.prototype.getProperty = function(Ee) {
                return this.checker.getPropertyOfType(this, Ee);
              }, X.prototype.getApparentProperties = function() {
                return this.checker.getAugmentedPropertiesOfType(this);
              }, X.prototype.getCallSignatures = function() {
                return this.checker.getSignaturesOfType(this, 0);
              }, X.prototype.getConstructSignatures = function() {
                return this.checker.getSignaturesOfType(this, 1);
              }, X.prototype.getStringIndexType = function() {
                return this.checker.getIndexTypeOfType(this, 0);
              }, X.prototype.getNumberIndexType = function() {
                return this.checker.getIndexTypeOfType(this, 1);
              }, X.prototype.getBaseTypes = function() {
                return this.isClassOrInterface() ? this.checker.getBaseTypes(this) : void 0;
              }, X.prototype.isNullableType = function() {
                return this.checker.isNullableType(this);
              }, X.prototype.getNonNullableType = function() {
                return this.checker.getNonNullableType(this);
              }, X.prototype.getNonOptionalType = function() {
                return this.checker.getNonOptionalType(this);
              }, X.prototype.getConstraint = function() {
                return this.checker.getBaseConstraintOfType(this);
              }, X.prototype.getDefault = function() {
                return this.checker.getDefaultFromTypeParameter(this);
              }, X.prototype.isUnion = function() {
                return !!(this.flags & 1048576);
              }, X.prototype.isIntersection = function() {
                return !!(this.flags & 2097152);
              }, X.prototype.isUnionOrIntersection = function() {
                return !!(this.flags & 3145728);
              }, X.prototype.isLiteral = function() {
                return !!(this.flags & 384);
              }, X.prototype.isStringLiteral = function() {
                return !!(this.flags & 128);
              }, X.prototype.isNumberLiteral = function() {
                return !!(this.flags & 256);
              }, X.prototype.isTypeParameter = function() {
                return !!(this.flags & 262144);
              }, X.prototype.isClassOrInterface = function() {
                return !!(e.getObjectFlags(this) & 3);
              }, X.prototype.isClass = function() {
                return !!(e.getObjectFlags(this) & 1);
              }, X.prototype.isIndexType = function() {
                return !!(this.flags & 4194304);
              }, Object.defineProperty(X.prototype, "typeArguments", { get: function() {
                if (e.getObjectFlags(this) & 4)
                  return this.checker.getTypeArguments(this);
              }, enumerable: false, configurable: true }), X;
            }(), Q = function() {
              function X(Ee, we) {
                this.checker = Ee, this.flags = we;
              }
              __name(X, "X");
              return X.prototype.getDeclaration = function() {
                return this.declaration;
              }, X.prototype.getTypeParameters = function() {
                return this.typeParameters;
              }, X.prototype.getParameters = function() {
                return this.parameters;
              }, X.prototype.getReturnType = function() {
                return this.checker.getReturnTypeOfSignature(this);
              }, X.prototype.getTypeParameterAtPosition = function(Ee) {
                var we = this.checker.getParameterType(this, Ee);
                if (we.isIndexType() && e.isThisTypeParameter(we.type)) {
                  var he = we.type.getConstraint();
                  if (he)
                    return this.checker.getIndexType(he);
                }
                return we;
              }, X.prototype.getDocumentationComment = function() {
                return this.documentationComment || (this.documentationComment = W(e.singleElementArray(this.declaration), this.checker));
              }, X.prototype.getJsDocTags = function() {
                return this.jsDocTags || (this.jsDocTags = je(e.singleElementArray(this.declaration), this.checker));
              }, X;
            }();
            function Be(X) {
              return e.getJSDocTags(X).some(function(Ee) {
                return Ee.tagName.text === "inheritDoc" || Ee.tagName.text === "inheritdoc";
              });
            }
            __name(Be, "Be");
            function je(X, Ee) {
              if (!X)
                return e.emptyArray;
              var we = e.JsDoc.getJsDocTagsFromDeclarations(X, Ee);
              if (Ee && (we.length === 0 || X.some(Be)))
                for (var he = new e.Set(), yr = function(Lr) {
                  var zr = B(Ee, Lr, function(ye) {
                    var ir;
                    if (!he.has(ye))
                      return he.add(ye), Lr.kind === 174 || Lr.kind === 175 ? ye.getContextualJsDocTags(Lr, Ee) : ((ir = ye.declarations) === null || ir === void 0 ? void 0 : ir.length) === 1 ? ye.getJsDocTags() : void 0;
                  });
                  zr && (we = A(A([], zr, true), we, true));
                }, kr = 0, nr = X; kr < nr.length; kr++) {
                  var tr = nr[kr];
                  yr(tr);
                }
              return we;
            }
            __name(je, "je");
            function W(X, Ee) {
              if (!X)
                return e.emptyArray;
              var we = e.JsDoc.getJsDocCommentsFromDeclarations(X, Ee);
              if (Ee && (we.length === 0 || X.some(Be)))
                for (var he = new e.Set(), yr = function(Lr) {
                  var zr = B(Ee, Lr, function(ye) {
                    if (!he.has(ye))
                      return he.add(ye), Lr.kind === 174 || Lr.kind === 175 ? ye.getContextualDocumentationComment(Lr, Ee) : ye.getDocumentationComment(Ee);
                  });
                  zr && (we = we.length === 0 ? zr.slice() : zr.concat(e.lineBreakPart(), we));
                }, kr = 0, nr = X; kr < nr.length; kr++) {
                  var tr = nr[kr];
                  yr(tr);
                }
              return we;
            }
            __name(W, "W");
            function B(X, Ee, we) {
              var he, yr = ((he = Ee.parent) === null || he === void 0 ? void 0 : he.kind) === 173 ? Ee.parent.parent : Ee.parent;
              if (!!yr) {
                var kr = e.hasStaticModifier(Ee);
                return e.firstDefined(e.getAllSuperTypeNodes(yr), function(nr) {
                  var tr = X.getTypeAtLocation(nr), Lr = kr && tr.symbol ? X.getTypeOfSymbol(tr.symbol) : tr, zr = X.getPropertyOfType(Lr, Ee.symbol.name);
                  return zr ? we(zr) : void 0;
                });
              }
            }
            __name(B, "B");
            var U = function(X) {
              E(Ee, X);
              function Ee(we, he, yr) {
                var kr = X.call(this, we, he, yr) || this;
                return kr.kind = 308, kr;
              }
              __name(Ee, "Ee");
              return Ee.prototype.update = function(we, he) {
                return e.updateSourceFile(this, we, he);
              }, Ee.prototype.getLineAndCharacterOfPosition = function(we) {
                return e.getLineAndCharacterOfPosition(this, we);
              }, Ee.prototype.getLineStarts = function() {
                return e.getLineStarts(this);
              }, Ee.prototype.getPositionOfLineAndCharacter = function(we, he, yr) {
                return e.computePositionOfLineAndCharacter(e.getLineStarts(this), we, he, this.text, yr);
              }, Ee.prototype.getLineEndOfPosition = function(we) {
                var he = this.getLineAndCharacterOfPosition(we).line, yr = this.getLineStarts(), kr;
                he + 1 >= yr.length && (kr = this.getEnd()), kr || (kr = yr[he + 1] - 1);
                var nr = this.getFullText();
                return nr[kr] === `
` && nr[kr - 1] === "\r" ? kr - 1 : kr;
              }, Ee.prototype.getNamedDeclarations = function() {
                return this.namedDeclarations || (this.namedDeclarations = this.computeNamedDeclarations()), this.namedDeclarations;
              }, Ee.prototype.computeNamedDeclarations = function() {
                var we = e.createMultiMap();
                return this.forEachChild(nr), we;
                function he(tr) {
                  var Lr = kr(tr);
                  Lr && we.add(Lr, tr);
                }
                __name(he, "he");
                function yr(tr) {
                  var Lr = we.get(tr);
                  return Lr || we.set(tr, Lr = []), Lr;
                }
                __name(yr, "yr");
                function kr(tr) {
                  var Lr = e.getNonAssignedNameOfDeclaration(tr);
                  return Lr && (e.isComputedPropertyName(Lr) && e.isPropertyAccessExpression(Lr.expression) ? Lr.expression.name.text : e.isPropertyName(Lr) ? e.getNameFromPropertyName(Lr) : void 0);
                }
                __name(kr, "kr");
                function nr(tr) {
                  switch (tr.kind) {
                    case 259:
                    case 215:
                    case 171:
                    case 170:
                      var Lr = tr, zr = kr(Lr);
                      if (zr) {
                        var ye = yr(zr), ir = e.lastOrUndefined(ye);
                        ir && Lr.parent === ir.parent && Lr.symbol === ir.symbol ? Lr.body && !ir.body && (ye[ye.length - 1] = Lr) : ye.push(Lr);
                      }
                      e.forEachChild(tr, nr);
                      break;
                    case 260:
                    case 228:
                    case 261:
                    case 262:
                    case 263:
                    case 264:
                    case 268:
                    case 278:
                    case 273:
                    case 270:
                    case 271:
                    case 174:
                    case 175:
                    case 184:
                      he(tr), e.forEachChild(tr, nr);
                      break;
                    case 166:
                      if (!e.hasSyntacticModifier(tr, 16476))
                        break;
                    case 257:
                    case 205: {
                      var Dr = tr;
                      if (e.isBindingPattern(Dr.name)) {
                        e.forEachChild(Dr.name, nr);
                        break;
                      }
                      Dr.initializer && nr(Dr.initializer);
                    }
                    case 302:
                    case 169:
                    case 168:
                      he(tr);
                      break;
                    case 275:
                      var Pr = tr;
                      Pr.exportClause && (e.isNamedExports(Pr.exportClause) ? e.forEach(Pr.exportClause.elements, nr) : nr(Pr.exportClause.name));
                      break;
                    case 269:
                      var Br = tr.importClause;
                      Br && (Br.name && he(Br.name), Br.namedBindings && (Br.namedBindings.kind === 271 ? he(Br.namedBindings) : e.forEach(Br.namedBindings.elements, nr)));
                      break;
                    case 223:
                      e.getAssignmentDeclarationKind(tr) !== 0 && he(tr);
                    default:
                      e.forEachChild(tr, nr);
                  }
                }
                __name(nr, "nr");
              }, Ee;
            }(x), m = function() {
              function X(Ee, we, he) {
                this.fileName = Ee, this.text = we, this.skipTrivia = he;
              }
              __name(X, "X");
              return X.prototype.getLineAndCharacterOfPosition = function(Ee) {
                return e.getLineAndCharacterOfPosition(this, Ee);
              }, X;
            }();
            function v() {
              return { getNodeConstructor: function() {
                return x;
              }, getTokenConstructor: function() {
                return Se;
              }, getIdentifierConstructor: function() {
                return J;
              }, getPrivateIdentifierConstructor: function() {
                return se;
              }, getSourceFileConstructor: function() {
                return U;
              }, getSymbolConstructor: function() {
                return Te;
              }, getTypeConstructor: function() {
                return Le;
              }, getSignatureConstructor: function() {
                return Q;
              }, getSourceMapSourceConstructor: function() {
                return m;
              } };
            }
            __name(v, "v");
            function g(X) {
              var Ee = true;
              for (var we in X)
                if (e.hasProperty(X, we) && !O(we)) {
                  Ee = false;
                  break;
                }
              if (Ee)
                return X;
              var he = {};
              for (var we in X)
                if (e.hasProperty(X, we)) {
                  var yr = O(we) ? we : we.charAt(0).toLowerCase() + we.substr(1);
                  he[yr] = X[we];
                }
              return he;
            }
            __name(g, "g");
            e.toEditorSettings = g;
            function O(X) {
              return !X.length || X.charAt(0) === X.charAt(0).toLowerCase();
            }
            __name(O, "O");
            function S(X) {
              return X ? e.map(X, function(Ee) {
                return Ee.text;
              }).join("") : "";
            }
            __name(S, "S");
            e.displayPartsToString = S;
            function te() {
              return { target: 1, jsx: 1 };
            }
            __name(te, "te");
            e.getDefaultCompilerOptions = te;
            function Je() {
              return e.codefix.getSupportedErrorCodes();
            }
            __name(Je, "Je");
            e.getSupportedCodeFixes = Je;
            var qe = function() {
              function X(Ee) {
                this.host = Ee;
              }
              __name(X, "X");
              return X.prototype.getCurrentSourceFile = function(Ee) {
                var we, he, yr, kr, nr, tr, Lr, zr, ye = this.host.getScriptSnapshot(Ee);
                if (!ye)
                  throw new Error("Could not find file: '" + Ee + "'.");
                var ir = e.getScriptKind(Ee, this.host), Dr = this.host.getScriptVersion(Ee), Pr;
                if (this.currentFileName !== Ee) {
                  var Br = { languageVersion: 99, impliedNodeFormat: e.getImpliedNodeFormatForFile(e.toPath(Ee, this.host.getCurrentDirectory(), ((yr = (he = (we = this.host).getCompilerHost) === null || he === void 0 ? void 0 : he.call(we)) === null || yr === void 0 ? void 0 : yr.getCanonicalFileName) || e.hostGetCanonicalFileName(this.host)), (zr = (Lr = (tr = (nr = (kr = this.host).getCompilerHost) === null || nr === void 0 ? void 0 : nr.call(kr)) === null || tr === void 0 ? void 0 : tr.getModuleResolutionCache) === null || Lr === void 0 ? void 0 : Lr.call(tr)) === null || zr === void 0 ? void 0 : zr.getPackageJsonInfoCache(), this.host, this.host.getCompilationSettings()), setExternalModuleIndicator: e.getSetExternalModuleIndicator(this.host.getCompilationSettings()) };
                  Pr = ie(Ee, ye, Br, Dr, true, ir);
                } else if (this.currentFileVersion !== Dr) {
                  var ut = ye.getChangeRange(this.currentFileScriptSnapshot);
                  Pr = G(this.currentSourceFile, ye, Dr, ut);
                }
                return Pr && (this.currentFileVersion = Dr, this.currentFileName = Ee, this.currentFileScriptSnapshot = ye, this.currentSourceFile = Pr), this.currentSourceFile;
              }, X;
            }();
            function ge(X, Ee, we) {
              X.version = we, X.scriptSnapshot = Ee;
            }
            __name(ge, "ge");
            function ie(X, Ee, we, he, yr, kr) {
              var nr = e.createSourceFile(X, e.getSnapshotText(Ee), we, yr, kr);
              return ge(nr, Ee, he), nr;
            }
            __name(ie, "ie");
            e.createLanguageServiceSourceFile = ie;
            function G(X, Ee, we, he, yr) {
              if (he && we !== X.version) {
                var kr = void 0, nr = he.span.start !== 0 ? X.text.substr(0, he.span.start) : "", tr = e.textSpanEnd(he.span) !== X.text.length ? X.text.substr(e.textSpanEnd(he.span)) : "";
                if (he.newLength === 0)
                  kr = nr && tr ? nr + tr : nr || tr;
                else {
                  var Lr = Ee.getText(he.span.start, he.span.start + he.newLength);
                  kr = nr && tr ? nr + Lr + tr : nr ? nr + Lr : Lr + tr;
                }
                var zr = e.updateSourceFile(X, kr, he, yr);
                return ge(zr, Ee, we), zr.nameTable = void 0, X !== zr && X.scriptSnapshot && (X.scriptSnapshot.dispose && X.scriptSnapshot.dispose(), X.scriptSnapshot = void 0), zr;
              }
              var ye = { languageVersion: X.languageVersion, impliedNodeFormat: X.impliedNodeFormat, setExternalModuleIndicator: X.setExternalModuleIndicator };
              return ie(X.fileName, Ee, ye, we, true, X.scriptKind);
            }
            __name(G, "G");
            e.updateLanguageServiceSourceFile = G;
            var pe = { isCancellationRequested: e.returnFalse, throwIfCancellationRequested: e.noop }, j = function() {
              function X(Ee) {
                this.cancellationToken = Ee;
              }
              __name(X, "X");
              return X.prototype.isCancellationRequested = function() {
                return this.cancellationToken.isCancellationRequested();
              }, X.prototype.throwIfCancellationRequested = function() {
                if (this.isCancellationRequested())
                  throw e.tracing === null || e.tracing === void 0 || e.tracing.instant("session", "cancellationThrown", { kind: "CancellationTokenObject" }), new e.OperationCanceledException();
              }, X;
            }(), be = function() {
              function X(Ee, we) {
                we === void 0 && (we = 20), this.hostCancellationToken = Ee, this.throttleWaitMilliseconds = we, this.lastCancellationCheckTime = 0;
              }
              __name(X, "X");
              return X.prototype.isCancellationRequested = function() {
                var Ee = e.timestamp(), we = Math.abs(Ee - this.lastCancellationCheckTime);
                return we >= this.throttleWaitMilliseconds ? (this.lastCancellationCheckTime = Ee, this.hostCancellationToken.isCancellationRequested()) : false;
              }, X.prototype.throwIfCancellationRequested = function() {
                if (this.isCancellationRequested())
                  throw e.tracing === null || e.tracing === void 0 || e.tracing.instant("session", "cancellationThrown", { kind: "ThrottledCancellationToken" }), new e.OperationCanceledException();
              }, X;
            }();
            e.ThrottledCancellationToken = be;
            var $e = ["getSemanticDiagnostics", "getSuggestionDiagnostics", "getCompilerOptionsDiagnostics", "getSemanticClassifications", "getEncodedSemanticClassifications", "getCodeFixesAtPosition", "getCombinedCodeFix", "applyCodeActionCommand", "organizeImports", "getEditsForFileRename", "getEmitOutput", "getApplicableRefactors", "getEditsForRefactor", "prepareCallHierarchy", "provideCallHierarchyIncomingCalls", "provideCallHierarchyOutgoingCalls", "provideInlayHints"], Re = A(A([], $e, true), ["getCompletionsAtPosition", "getCompletionEntryDetails", "getCompletionEntrySymbol", "getSignatureHelpItems", "getQuickInfoAtPosition", "getDefinitionAtPosition", "getDefinitionAndBoundSpan", "getImplementationAtPosition", "getTypeDefinitionAtPosition", "getReferencesAtPosition", "findReferences", "getOccurrencesAtPosition", "getDocumentHighlights", "getNavigateToItems", "getRenameInfo", "findRenameLocations", "getApplicableRefactors"], false);
            function Fe(X, Ee, we) {
              var he, yr;
              Ee === void 0 && (Ee = e.createDocumentRegistry(X.useCaseSensitiveFileNames && X.useCaseSensitiveFileNames(), X.getCurrentDirectory()));
              var kr;
              we === void 0 ? kr = e.LanguageServiceMode.Semantic : typeof we == "boolean" ? kr = we ? e.LanguageServiceMode.Syntactic : e.LanguageServiceMode.Semantic : kr = we;
              var nr = new qe(X), tr, Lr, zr = 0, ye = X.getCancellationToken ? new j(X.getCancellationToken()) : pe, ir = X.getCurrentDirectory();
              e.maybeSetLocalizedDiagnosticMessages((yr = X.getLocalizedDiagnosticMessages) === null || yr === void 0 ? void 0 : yr.bind(X));
              function Dr(Me) {
                X.log && X.log(Me);
              }
              __name(Dr, "Dr");
              var Pr = e.hostUsesCaseSensitiveFileNames(X), Br = e.createGetCanonicalFileName(Pr), ut = e.getSourceMapper({ useCaseSensitiveFileNames: function() {
                return Pr;
              }, getCurrentDirectory: function() {
                return ir;
              }, getProgram: f, fileExists: e.maybeBind(X, X.fileExists), readFile: e.maybeBind(X, X.readFile), getDocumentPositionMapper: e.maybeBind(X, X.getDocumentPositionMapper), getSourceFileLike: e.maybeBind(X, X.getSourceFileLike), log: Dr });
              function rt(Me) {
                var Ve = tr.getSourceFile(Me);
                if (!Ve) {
                  var _r = new Error("Could not find source file: '".concat(Me, "'."));
                  throw _r.ProgramFiles = tr.getSourceFiles().map(function(lr) {
                    return lr.fileName;
                  }), _r;
                }
                return Ve;
              }
              __name(rt, "rt");
              function Z() {
                var Me, Ve, _r;
                if (e.Debug.assert(kr !== e.LanguageServiceMode.Syntactic), X.getProjectVersion) {
                  var lr = X.getProjectVersion();
                  if (lr) {
                    if (Lr === lr && !(!((Me = X.hasChangedAutomaticTypeDirectiveNames) === null || Me === void 0) && Me.call(X)))
                      return;
                    Lr = lr;
                  }
                }
                var Vr = X.getTypeRootsVersion ? X.getTypeRootsVersion() : 0;
                zr !== Vr && (Dr("TypeRoots version has changed; provide new program"), tr = void 0, zr = Vr);
                var tt = X.getScriptFileNames().slice(), dt = X.getCompilationSettings() || te(), It = X.hasInvalidatedResolutions || e.returnFalse, an = e.maybeBind(X, X.hasChangedAutomaticTypeDirectiveNames), sn = (Ve = X.getProjectReferences) === null || Ve === void 0 ? void 0 : Ve.call(X), _e, Gr = { getSourceFile: kn, getSourceFileByPath: on, getCancellationToken: function() {
                  return ye;
                }, getCanonicalFileName: Br, useCaseSensitiveFileNames: function() {
                  return Pr;
                }, getNewLine: function() {
                  return e.getNewLineCharacter(dt, function() {
                    return e.getNewLineOrDefaultFromHost(X);
                  });
                }, getDefaultLibFileName: function(Xr) {
                  return X.getDefaultLibFileName(Xr);
                }, writeFile: e.noop, getCurrentDirectory: function() {
                  return ir;
                }, fileExists: function(Xr) {
                  return X.fileExists(Xr);
                }, readFile: function(Xr) {
                  return X.readFile && X.readFile(Xr);
                }, getSymlinkCache: e.maybeBind(X, X.getSymlinkCache), realpath: e.maybeBind(X, X.realpath), directoryExists: function(Xr) {
                  return e.directoryProbablyExists(Xr, X);
                }, getDirectories: function(Xr) {
                  return X.getDirectories ? X.getDirectories(Xr) : [];
                }, readDirectory: function(Xr, wr, fn, mn, Li) {
                  return e.Debug.checkDefined(X.readDirectory, "'LanguageServiceHost.readDirectory' must be implemented to correctly process 'projectReferences'"), X.readDirectory(Xr, wr, fn, mn, Li);
                }, onReleaseOldSourceFile: Rn, onReleaseParsedCommandLine: Mn, hasInvalidatedResolutions: It, hasChangedAutomaticTypeDirectiveNames: an, trace: e.maybeBind(X, X.trace), resolveModuleNames: e.maybeBind(X, X.resolveModuleNames), getModuleResolutionCache: e.maybeBind(X, X.getModuleResolutionCache), resolveTypeReferenceDirectives: e.maybeBind(X, X.resolveTypeReferenceDirectives), useSourceOfProjectReferenceRedirect: e.maybeBind(X, X.useSourceOfProjectReferenceRedirect), getParsedCommandLine: rn }, Kt = Gr.getSourceFile, en = e.changeCompilerHostLikeToUseCache(Gr, function(Xr) {
                  return e.toPath(Xr, ir, Br);
                }, function() {
                  for (var Xr = [], wr = 0; wr < arguments.length; wr++)
                    Xr[wr] = arguments[wr];
                  return Kt.call.apply(Kt, A([Gr], Xr, false));
                }).getSourceFileWithCache;
                Gr.getSourceFile = en, (_r = X.setCompilerHost) === null || _r === void 0 || _r.call(X, Gr);
                var Ot = { useCaseSensitiveFileNames: Pr, fileExists: function(Xr) {
                  return Gr.fileExists(Xr);
                }, readFile: function(Xr) {
                  return Gr.readFile(Xr);
                }, readDirectory: function() {
                  for (var Xr, wr = [], fn = 0; fn < arguments.length; fn++)
                    wr[fn] = arguments[fn];
                  return (Xr = Gr).readDirectory.apply(Xr, wr);
                }, trace: Gr.trace, getCurrentDirectory: Gr.getCurrentDirectory, onUnRecoverableConfigFileDiagnostic: e.noop }, rr = Ee.getKeyForCompilationSettings(dt);
                if (e.isProgramUptoDate(tr, tt, dt, function(Xr, wr) {
                  return X.getScriptVersion(wr);
                }, function(Xr) {
                  return Gr.fileExists(Xr);
                }, It, an, rn, sn))
                  return;
                var Hn = { rootNames: tt, options: dt, host: Gr, oldProgram: tr, projectReferences: sn };
                tr = e.createProgram(Hn), Gr = void 0, _e = void 0, ut.clearCache(), tr.getTypeChecker();
                return;
                function rn(Xr) {
                  var wr = e.toPath(Xr, ir, Br), fn = _e == null ? void 0 : _e.get(wr);
                  if (fn !== void 0)
                    return fn || void 0;
                  var mn = X.getParsedCommandLine ? X.getParsedCommandLine(Xr) : xn(Xr);
                  return (_e || (_e = new e.Map())).set(wr, mn || false), mn;
                }
                __name(rn, "rn");
                function xn(Xr) {
                  var wr = kn(Xr, 100);
                  if (!!wr)
                    return wr.path = e.toPath(Xr, ir, Br), wr.resolvedPath = wr.path, wr.originalFileName = wr.fileName, e.parseJsonSourceFileConfigFileContent(wr, Ot, e.getNormalizedAbsolutePath(e.getDirectoryPath(Xr), ir), void 0, e.getNormalizedAbsolutePath(Xr, ir));
                }
                __name(xn, "xn");
                function Mn(Xr, wr, fn) {
                  var mn;
                  X.getParsedCommandLine ? (mn = X.onReleaseParsedCommandLine) === null || mn === void 0 || mn.call(X, Xr, wr, fn) : wr && Rn(wr.sourceFile, fn);
                }
                __name(Mn, "Mn");
                function Rn(Xr, wr) {
                  var fn = Ee.getKeyForCompilationSettings(wr);
                  Ee.releaseDocumentWithKey(Xr.resolvedPath, fn, Xr.scriptKind, Xr.impliedNodeFormat);
                }
                __name(Rn, "Rn");
                function kn(Xr, wr, fn, mn) {
                  return on(Xr, e.toPath(Xr, ir, Br), wr, fn, mn);
                }
                __name(kn, "kn");
                function on(Xr, wr, fn, mn, Li) {
                  e.Debug.assert(Gr, "getOrCreateSourceFileByPath called after typical CompilerHost lifetime, check the callstack something with a reference to an old host.");
                  var An = X.getScriptSnapshot(Xr);
                  if (!!An) {
                    var wi = e.getScriptKind(Xr, X), ti = X.getScriptVersion(Xr);
                    if (!Li) {
                      var li = tr && tr.getSourceFileByPath(wr);
                      if (li) {
                        if (wi === li.scriptKind)
                          return Ee.updateDocumentWithKey(Xr, wr, X, rr, An, ti, wi, fn);
                        Ee.releaseDocumentWithKey(li.resolvedPath, Ee.getKeyForCompilationSettings(tr.getCompilerOptions()), li.scriptKind, li.impliedNodeFormat);
                      }
                    }
                    return Ee.acquireDocumentWithKey(Xr, wr, X, rr, An, ti, wi, fn);
                  }
                }
                __name(on, "on");
              }
              __name(Z, "Z");
              function f() {
                if (kr === e.LanguageServiceMode.Syntactic) {
                  e.Debug.assert(tr === void 0);
                  return;
                }
                return Z(), tr;
              }
              __name(f, "f");
              function h() {
                var Me;
                return (Me = X.getPackageJsonAutoImportProvider) === null || Me === void 0 ? void 0 : Me.call(X);
              }
              __name(h, "h");
              function ae(Me, Ve) {
                var _r = tr.getTypeChecker(), lr = Kt();
                if (!lr)
                  return false;
                for (var Vr = 0, tt = Me; Vr < tt.length; Vr++)
                  for (var dt = tt[Vr], It = 0, an = dt.references; It < an.length; It++) {
                    var sn = an[It], _e = en(sn);
                    if (e.Debug.assertIsDefined(_e), Ve.has(sn) || e.FindAllReferences.isDeclarationOfSymbol(_e, lr)) {
                      Ve.add(sn), sn.isDefinition = true;
                      var Gr = e.getMappedDocumentSpan(sn, ut, e.maybeBind(X, X.fileExists));
                      Gr && Ve.add(Gr);
                    } else
                      sn.isDefinition = false;
                  }
                return true;
                function Kt() {
                  for (var Ot = 0, rr = Me; Ot < rr.length; Ot++)
                    for (var Hn = rr[Ot], rn = 0, xn = Hn.references; rn < xn.length; rn++) {
                      var Mn = xn[rn];
                      if (Ve.has(Mn)) {
                        var Rn = en(Mn);
                        return e.Debug.assertIsDefined(Rn), _r.getSymbolAtLocation(Rn);
                      }
                      var kn = e.getMappedDocumentSpan(Mn, ut, e.maybeBind(X, X.fileExists));
                      if (kn && Ve.has(kn)) {
                        var Rn = en(kn);
                        if (Rn)
                          return _r.getSymbolAtLocation(Rn);
                      }
                    }
                }
                __name(Kt, "Kt");
                function en(Ot) {
                  var rr = tr.getSourceFile(Ot.fileName);
                  if (!!rr) {
                    var Hn = e.getTouchingPropertyName(rr, Ot.textSpan.start), rn = e.FindAllReferences.Core.getAdjustedNode(Hn, { use: 1 });
                    return rn;
                  }
                }
                __name(en, "en");
              }
              __name(ae, "ae");
              function xr() {
                tr = void 0;
              }
              __name(xr, "xr");
              function jr() {
                if (tr) {
                  var Me = Ee.getKeyForCompilationSettings(tr.getCompilerOptions());
                  e.forEach(tr.getSourceFiles(), function(Ve) {
                    return Ee.releaseDocumentWithKey(Ve.resolvedPath, Me, Ve.scriptKind, Ve.impliedNodeFormat);
                  }), tr = void 0;
                }
                X = void 0;
              }
              __name(jr, "jr");
              function qr(Me) {
                return Z(), tr.getSyntacticDiagnostics(rt(Me), ye).slice();
              }
              __name(qr, "qr");
              function pt(Me) {
                Z();
                var Ve = rt(Me), _r = tr.getSemanticDiagnostics(Ve, ye);
                if (!e.getEmitDeclarations(tr.getCompilerOptions()))
                  return _r.slice();
                var lr = tr.getDeclarationDiagnostics(Ve, ye);
                return A(A([], _r, true), lr, true);
              }
              __name(pt, "pt");
              function Ge(Me) {
                return Z(), e.computeSuggestionDiagnostics(rt(Me), tr, ye);
              }
              __name(Ge, "Ge");
              function K() {
                return Z(), A(A([], tr.getOptionsDiagnostics(ye), true), tr.getGlobalDiagnostics(ye), true);
              }
              __name(K, "K");
              function r(Me, Ve, _r, lr) {
                _r === void 0 && (_r = e.emptyOptions);
                var Vr = T(T({}, e.identity(_r)), { includeCompletionsForModuleExports: _r.includeCompletionsForModuleExports || _r.includeExternalModuleExports, includeCompletionsWithInsertText: _r.includeCompletionsWithInsertText || _r.includeInsertTextCompletions });
                return Z(), e.Completions.getCompletionsAtPosition(X, tr, Dr, rt(Me), Ve, Vr, _r.triggerCharacter, _r.triggerKind, ye, lr && e.formatting.getFormatContext(lr, X));
              }
              __name(r, "r");
              function ct(Me, Ve, _r, lr, Vr, tt, dt) {
                return tt === void 0 && (tt = e.emptyOptions), Z(), e.Completions.getCompletionEntryDetails(tr, Dr, rt(Me), Ve, { name: _r, source: Vr, data: dt }, X, lr && e.formatting.getFormatContext(lr, X), tt, ye);
              }
              __name(ct, "ct");
              function ft(Me, Ve, _r, lr, Vr) {
                return Vr === void 0 && (Vr = e.emptyOptions), Z(), e.Completions.getCompletionEntrySymbol(tr, Dr, rt(Me), Ve, { name: _r, source: lr }, X, Vr);
              }
              __name(ft, "ft");
              function Ie(Me, Ve) {
                Z();
                var _r = rt(Me), lr = e.getTouchingPropertyName(_r, Ve);
                if (lr !== _r) {
                  var Vr = tr.getTypeChecker(), tt = me(lr), dt = Cr(tt, Vr);
                  if (!dt || Vr.isUnknownSymbol(dt)) {
                    var It = xe(_r, tt, Ve) ? Vr.getTypeAtLocation(tt) : void 0;
                    return It && { kind: "", kindModifiers: "", textSpan: e.createTextSpanFromNode(tt, _r), displayParts: Vr.runWithCancellationToken(ye, function(en) {
                      return e.typeToDisplayParts(en, It, e.getContainerNode(tt));
                    }), documentation: It.symbol ? It.symbol.getDocumentationComment(Vr) : void 0, tags: It.symbol ? It.symbol.getJsDocTags(Vr) : void 0 };
                  }
                  var an = Vr.runWithCancellationToken(ye, function(en) {
                    return e.SymbolDisplay.getSymbolDisplayPartsDocumentationAndSymbolKind(en, dt, _r, e.getContainerNode(tt), tt);
                  }), sn = an.symbolKind, _e = an.displayParts, Gr = an.documentation, Kt = an.tags;
                  return { kind: sn, kindModifiers: e.SymbolDisplay.getSymbolModifiers(Vr, dt), textSpan: e.createTextSpanFromNode(tt, _r), displayParts: _e, documentation: Gr, tags: Kt };
                }
              }
              __name(Ie, "Ie");
              function me(Me) {
                return e.isNewExpression(Me.parent) && Me.pos === Me.parent.pos ? Me.parent.expression : e.isNamedTupleMember(Me.parent) && Me.pos === Me.parent.pos || e.isImportMeta(Me.parent) && Me.parent.name === Me ? Me.parent : Me;
              }
              __name(me, "me");
              function xe(Me, Ve, _r) {
                switch (Ve.kind) {
                  case 79:
                    return !e.isLabelName(Ve) && !e.isTagName(Ve) && !e.isConstTypeReference(Ve.parent);
                  case 208:
                  case 163:
                    return !e.isInComment(Me, _r);
                  case 108:
                  case 194:
                  case 106:
                  case 199:
                    return true;
                  case 233:
                    return e.isImportMeta(Ve);
                  default:
                    return false;
                }
              }
              __name(xe, "xe");
              function Ye(Me, Ve, _r, lr) {
                return Z(), e.GoToDefinition.getDefinitionAtPosition(tr, rt(Me), Ve, _r, lr);
              }
              __name(Ye, "Ye");
              function vr(Me, Ve) {
                return Z(), e.GoToDefinition.getDefinitionAndBoundSpan(tr, rt(Me), Ve);
              }
              __name(vr, "vr");
              function nt(Me, Ve) {
                return Z(), e.GoToDefinition.getTypeDefinitionAtPosition(tr.getTypeChecker(), rt(Me), Ve);
              }
              __name(nt, "nt");
              function pr(Me, Ve) {
                return Z(), e.FindAllReferences.getImplementationsAtPosition(tr, ye, tr.getSourceFiles(), rt(Me), Ve);
              }
              __name(pr, "pr");
              function Mr(Me, Ve) {
                return e.flatMap(ot(Me, Ve, [Me]), function(_r) {
                  return _r.highlightSpans.map(function(lr) {
                    return T(T({ fileName: _r.fileName, textSpan: lr.textSpan, isWriteAccess: lr.kind === "writtenReference" }, lr.isInString && { isInString: true }), lr.contextSpan && { contextSpan: lr.contextSpan });
                  });
                });
              }
              __name(Mr, "Mr");
              function ot(Me, Ve, _r) {
                var lr = e.normalizePath(Me);
                e.Debug.assert(_r.some(function(dt) {
                  return e.normalizePath(dt) === lr;
                })), Z();
                var Vr = e.mapDefined(_r, function(dt) {
                  return tr.getSourceFile(dt);
                }), tt = rt(Me);
                return e.DocumentHighlights.getDocumentHighlights(tr, ye, tt, Ve, Vr);
              }
              __name(ot, "ot");
              function At(Me, Ve, _r, lr, Vr) {
                Z();
                var tt = rt(Me), dt = e.getAdjustedRenameLocation(e.getTouchingPropertyName(tt, Ve));
                if (!!e.Rename.nodeIsEligibleForRename(dt))
                  if (e.isIdentifier(dt) && (e.isJsxOpeningElement(dt.parent) || e.isJsxClosingElement(dt.parent)) && e.isIntrinsicJsxName(dt.escapedText)) {
                    var It = dt.parent.parent, an = It.openingElement, sn = It.closingElement;
                    return [an, sn].map(function(_e) {
                      var Gr = e.createTextSpanFromNode(_e.tagName, tt);
                      return T({ fileName: tt.fileName, textSpan: Gr }, e.FindAllReferences.toContextSpan(Gr, tt, _e.parent));
                    });
                  } else
                    return de(dt, Ve, { findInStrings: _r, findInComments: lr, providePrefixAndSuffixTextForRename: Vr, use: 2 }, function(_e, Gr, Kt) {
                      return e.FindAllReferences.toRenameLocation(_e, Gr, Kt, Vr || false);
                    });
              }
              __name(At, "At");
              function re(Me, Ve) {
                return Z(), de(e.getTouchingPropertyName(rt(Me), Ve), Ve, { use: 1 }, e.FindAllReferences.toReferenceEntry);
              }
              __name(re, "re");
              function de(Me, Ve, _r, lr) {
                Z();
                var Vr = _r && _r.use === 2 ? tr.getSourceFiles().filter(function(tt) {
                  return !tr.isSourceFileDefaultLibrary(tt);
                }) : tr.getSourceFiles();
                return e.FindAllReferences.findReferenceOrRenameEntries(tr, ye, Vr, Me, Ve, _r, lr);
              }
              __name(de, "de");
              function He(Me, Ve) {
                return Z(), e.FindAllReferences.findReferencedSymbols(tr, ye, tr.getSourceFiles(), rt(Me), Ve);
              }
              __name(He, "He");
              function Nr(Me) {
                return Z(), e.FindAllReferences.Core.getReferencesForFileName(Me, tr, tr.getSourceFiles()).map(e.FindAllReferences.toReferenceEntry);
              }
              __name(Nr, "Nr");
              function Yr(Me, Ve, _r, lr) {
                lr === void 0 && (lr = false), Z();
                var Vr = _r ? [rt(_r)] : tr.getSourceFiles();
                return e.NavigateTo.getNavigateToItems(Vr, tr.getTypeChecker(), ye, Me, Ve, lr);
              }
              __name(Yr, "Yr");
              function St(Me, Ve, _r) {
                Z();
                var lr = rt(Me), Vr = X.getCustomTransformers && X.getCustomTransformers();
                return e.getFileEmitOutput(tr, lr, !!Ve, ye, Vr, _r);
              }
              __name(St, "St");
              function Dt(Me, Ve, _r) {
                var lr = _r === void 0 ? e.emptyOptions : _r, Vr = lr.triggerReason;
                Z();
                var tt = rt(Me);
                return e.SignatureHelp.getSignatureHelpItems(tr, tt, Ve, Vr, ye);
              }
              __name(Dt, "Dt");
              function Lt(Me) {
                return nr.getCurrentSourceFile(Me);
              }
              __name(Lt, "Lt");
              function zt(Me, Ve, _r) {
                var lr = nr.getCurrentSourceFile(Me), Vr = e.getTouchingPropertyName(lr, Ve);
                if (Vr !== lr) {
                  switch (Vr.kind) {
                    case 208:
                    case 163:
                    case 10:
                    case 95:
                    case 110:
                    case 104:
                    case 106:
                    case 108:
                    case 194:
                    case 79:
                      break;
                    default:
                      return;
                  }
                  for (var tt = Vr; ; )
                    if (e.isRightSideOfPropertyAccess(tt) || e.isRightSideOfQualifiedName(tt))
                      tt = tt.parent;
                    else if (e.isNameOfModuleDeclaration(tt))
                      if (tt.parent.parent.kind === 264 && tt.parent.parent.body === tt.parent)
                        tt = tt.parent.parent.name;
                      else
                        break;
                    else
                      break;
                  return e.createTextSpanFromBounds(tt.getStart(), Vr.getEnd());
                }
              }
              __name(zt, "zt");
              function Zt(Me, Ve) {
                var _r = nr.getCurrentSourceFile(Me);
                return e.BreakpointResolver.spanInSourceFileAtLocation(_r, Ve);
              }
              __name(Zt, "Zt");
              function mt(Me) {
                return e.NavigationBar.getNavigationBarItems(nr.getCurrentSourceFile(Me), ye);
              }
              __name(mt, "mt");
              function at(Me) {
                return e.NavigationBar.getNavigationTree(nr.getCurrentSourceFile(Me), ye);
              }
              __name(at, "at");
              function k(Me, Ve, _r) {
                Z();
                var lr = _r || "original";
                return lr === "2020" ? e.classifier.v2020.getSemanticClassifications(tr, ye, rt(Me), Ve) : e.getSemanticClassifications(tr.getTypeChecker(), ye, rt(Me), tr.getClassifiableNames(), Ve);
              }
              __name(k, "k");
              function ue(Me, Ve, _r) {
                Z();
                var lr = _r || "original";
                return lr === "original" ? e.getEncodedSemanticClassifications(tr.getTypeChecker(), ye, rt(Me), tr.getClassifiableNames(), Ve) : e.classifier.v2020.getEncodedSemanticClassifications(tr, ye, rt(Me), Ve);
              }
              __name(ue, "ue");
              function Qe(Me, Ve) {
                return e.getSyntacticClassifications(ye, nr.getCurrentSourceFile(Me), Ve);
              }
              __name(Qe, "Qe");
              function Sr(Me, Ve) {
                return e.getEncodedSyntacticClassifications(ye, nr.getCurrentSourceFile(Me), Ve);
              }
              __name(Sr, "Sr");
              function Kr(Me) {
                var Ve = nr.getCurrentSourceFile(Me);
                return e.OutliningElementsCollector.collectElements(Ve, ye);
              }
              __name(Kr, "Kr");
              var Hr = new e.Map(e.getEntries((he = {}, he[18] = 19, he[20] = 21, he[22] = 23, he[31] = 29, he)));
              Hr.forEach(function(Me, Ve) {
                return Hr.set(Me.toString(), Number(Ve));
              });
              function Ct(Me, Ve) {
                var _r = nr.getCurrentSourceFile(Me), lr = e.getTouchingToken(_r, Ve), Vr = lr.getStart(_r) === Ve ? Hr.get(lr.kind.toString()) : void 0, tt = Vr && e.findChildOfKind(lr.parent, Vr, _r);
                return tt ? [e.createTextSpanFromNode(lr, _r), e.createTextSpanFromNode(tt, _r)].sort(function(dt, It) {
                  return dt.start - It.start;
                }) : e.emptyArray;
              }
              __name(Ct, "Ct");
              function Xt(Me, Ve, _r) {
                var lr = e.timestamp(), Vr = g(_r), tt = nr.getCurrentSourceFile(Me);
                Dr("getIndentationAtPosition: getCurrentSourceFile: " + (e.timestamp() - lr)), lr = e.timestamp();
                var dt = e.formatting.SmartIndenter.getIndentation(Ve, tt, Vr);
                return Dr("getIndentationAtPosition: computeIndentation  : " + (e.timestamp() - lr)), dt;
              }
              __name(Xt, "Xt");
              function cn(Me, Ve, _r, lr) {
                var Vr = nr.getCurrentSourceFile(Me);
                return e.formatting.formatSelection(Ve, _r, Vr, e.formatting.getFormatContext(g(lr), X));
              }
              __name(cn, "cn");
              function In(Me, Ve) {
                return e.formatting.formatDocument(nr.getCurrentSourceFile(Me), e.formatting.getFormatContext(g(Ve), X));
              }
              __name(In, "In");
              function yn(Me, Ve, _r, lr) {
                var Vr = nr.getCurrentSourceFile(Me), tt = e.formatting.getFormatContext(g(lr), X);
                if (!e.isInComment(Vr, Ve))
                  switch (_r) {
                    case "{":
                      return e.formatting.formatOnOpeningCurly(Ve, Vr, tt);
                    case "}":
                      return e.formatting.formatOnClosingCurly(Ve, Vr, tt);
                    case ";":
                      return e.formatting.formatOnSemicolon(Ve, Vr, tt);
                    case `
`:
                      return e.formatting.formatOnEnter(Ve, Vr, tt);
                  }
                return [];
              }
              __name(yn, "yn");
              function hn(Me, Ve, _r, lr, Vr, tt) {
                tt === void 0 && (tt = e.emptyOptions), Z();
                var dt = rt(Me), It = e.createTextSpanFromBounds(Ve, _r), an = e.formatting.getFormatContext(Vr, X);
                return e.flatMap(e.deduplicate(lr, e.equateValues, e.compareValues), function(sn) {
                  return ye.throwIfCancellationRequested(), e.codefix.getFixes({ errorCode: sn, sourceFile: dt, span: It, program: tr, host: X, cancellationToken: ye, formatContext: an, preferences: tt });
                });
              }
              __name(hn, "hn");
              function ln(Me, Ve, _r, lr) {
                lr === void 0 && (lr = e.emptyOptions), Z(), e.Debug.assert(Me.type === "file");
                var Vr = rt(Me.fileName), tt = e.formatting.getFormatContext(_r, X);
                return e.codefix.getAllFixes({ fixId: Ve, sourceFile: Vr, program: tr, host: X, cancellationToken: ye, formatContext: tt, preferences: lr });
              }
              __name(ln, "ln");
              function En(Me, Ve, _r) {
                var lr;
                _r === void 0 && (_r = e.emptyOptions), Z(), e.Debug.assert(Me.type === "file");
                var Vr = rt(Me.fileName), tt = e.formatting.getFormatContext(Ve, X), dt = (lr = Me.mode) !== null && lr !== void 0 ? lr : Me.skipDestructiveCodeActions ? "SortAndCombine" : "All";
                return e.OrganizeImports.organizeImports(Vr, tt, X, tr, _r, dt);
              }
              __name(En, "En");
              function Vt(Me, Ve, _r, lr) {
                return lr === void 0 && (lr = e.emptyOptions), e.getEditsForFileRename(f(), Me, Ve, X, e.formatting.getFormatContext(_r, X), lr, ut);
              }
              __name(Vt, "Vt");
              function ui(Me, Ve) {
                var _r = typeof Me == "string" ? Ve : Me;
                return e.isArray(_r) ? Promise.all(_r.map(function(lr) {
                  return ei(lr);
                })) : ei(_r);
              }
              __name(ui, "ui");
              function ei(Me) {
                var Ve = /* @__PURE__ */ __name(function(_r) {
                  return e.toPath(_r, ir, Br);
                }, "Ve");
                return e.Debug.assertEqual(Me.type, "install package"), X.installPackage ? X.installPackage({ fileName: Ve(Me.file), packageName: Me.packageName }) : Promise.reject("Host does not implement `installPackage`");
              }
              __name(ei, "ei");
              function vi(Me, Ve, _r) {
                return e.JsDoc.getDocCommentTemplateAtPosition(e.getNewLineOrDefaultFromHost(X), nr.getCurrentSourceFile(Me), Ve, _r);
              }
              __name(vi, "vi");
              function ri(Me, Ve, _r) {
                if (_r === 60)
                  return false;
                var lr = nr.getCurrentSourceFile(Me);
                if (e.isInString(lr, Ve))
                  return false;
                if (e.isInsideJsxElementOrAttribute(lr, Ve))
                  return _r === 123;
                if (e.isInTemplateString(lr, Ve))
                  return false;
                switch (_r) {
                  case 39:
                  case 34:
                  case 96:
                    return !e.isInComment(lr, Ve);
                }
                return true;
              }
              __name(ri, "ri");
              function bi(Me, Ve) {
                var _r = nr.getCurrentSourceFile(Me), lr = e.findPrecedingToken(Ve, _r);
                if (!!lr) {
                  var Vr = lr.kind === 31 && e.isJsxOpeningElement(lr.parent) ? lr.parent.parent : e.isJsxText(lr) && e.isJsxElement(lr.parent) ? lr.parent : void 0;
                  if (Vr && Kn(Vr))
                    return { newText: "</".concat(Vr.openingElement.tagName.getText(_r), ">") };
                  var tt = lr.kind === 31 && e.isJsxOpeningFragment(lr.parent) ? lr.parent.parent : e.isJsxText(lr) && e.isJsxFragment(lr.parent) ? lr.parent : void 0;
                  if (tt && si(tt))
                    return { newText: "</>" };
                }
              }
              __name(bi, "bi");
              function Qn(Me, Ve) {
                return { lineStarts: Me.getLineStarts(), firstLine: Me.getLineAndCharacterOfPosition(Ve.pos).line, lastLine: Me.getLineAndCharacterOfPosition(Ve.end).line };
              }
              __name(Qn, "Qn");
              function Yn(Me, Ve, _r) {
                for (var lr = nr.getCurrentSourceFile(Me), Vr = [], tt = Qn(lr, Ve), dt = tt.lineStarts, It = tt.firstLine, an = tt.lastLine, sn = _r || false, _e = Number.MAX_VALUE, Gr = new e.Map(), Kt = new RegExp(/\S/), en = e.isInsideJsxElement(lr, dt[It]), Ot = en ? "{/*" : "//", rr = It; rr <= an; rr++) {
                  var Hn = lr.text.substring(dt[rr], lr.getLineEndOfPosition(dt[rr])), rn = Kt.exec(Hn);
                  rn && (_e = Math.min(_e, rn.index), Gr.set(rr.toString(), rn.index), Hn.substr(rn.index, Ot.length) !== Ot && (sn = _r === void 0 || _r));
                }
                for (var rr = It; rr <= an; rr++)
                  if (!(It !== an && dt[rr] === Ve.end)) {
                    var xn = Gr.get(rr.toString());
                    xn !== void 0 && (en ? Vr.push.apply(Vr, oi(Me, { pos: dt[rr] + _e, end: lr.getLineEndOfPosition(dt[rr]) }, sn, en)) : sn ? Vr.push({ newText: Ot, span: { length: 0, start: dt[rr] + _e } }) : lr.text.substr(dt[rr] + xn, Ot.length) === Ot && Vr.push({ newText: "", span: { length: Ot.length, start: dt[rr] + xn } }));
                  }
                return Vr;
              }
              __name(Yn, "Yn");
              function oi(Me, Ve, _r, lr) {
                for (var Vr, tt = nr.getCurrentSourceFile(Me), dt = [], It = tt.text, an = false, sn = _r || false, _e = [], Gr = Ve.pos, Kt = lr !== void 0 ? lr : e.isInsideJsxElement(tt, Gr), en = Kt ? "{/*" : "/*", Ot = Kt ? "*/}" : "*/", rr = Kt ? "\\{\\/\\*" : "\\/\\*", Hn = Kt ? "\\*\\/\\}" : "\\*\\/"; Gr <= Ve.end; ) {
                  var rn = It.substr(Gr, en.length) === en ? en.length : 0, xn = e.isInComment(tt, Gr + rn);
                  if (xn)
                    Kt && (xn.pos--, xn.end++), _e.push(xn.pos), xn.kind === 3 && _e.push(xn.end), an = true, Gr = xn.end + 1;
                  else {
                    var Mn = It.substring(Gr, Ve.end).search("(".concat(rr, ")|(").concat(Hn, ")"));
                    sn = _r !== void 0 ? _r : sn || !e.isTextWhiteSpaceLike(It, Gr, Mn === -1 ? Ve.end : Gr + Mn), Gr = Mn === -1 ? Ve.end + 1 : Gr + Mn + Ot.length;
                  }
                }
                if (sn || !an) {
                  ((Vr = e.isInComment(tt, Ve.pos)) === null || Vr === void 0 ? void 0 : Vr.kind) !== 2 && e.insertSorted(_e, Ve.pos, e.compareValues), e.insertSorted(_e, Ve.end, e.compareValues);
                  var Rn = _e[0];
                  It.substr(Rn, en.length) !== en && dt.push({ newText: en, span: { length: 0, start: Rn } });
                  for (var kn = 1; kn < _e.length - 1; kn++)
                    It.substr(_e[kn] - Ot.length, Ot.length) !== Ot && dt.push({ newText: Ot, span: { length: 0, start: _e[kn] } }), It.substr(_e[kn], en.length) !== en && dt.push({ newText: en, span: { length: 0, start: _e[kn] } });
                  dt.length % 2 !== 0 && dt.push({ newText: Ot, span: { length: 0, start: _e[_e.length - 1] } });
                } else
                  for (var on = 0, Xr = _e; on < Xr.length; on++) {
                    var wr = Xr[on], fn = wr - Ot.length > 0 ? wr - Ot.length : 0, rn = It.substr(fn, Ot.length) === Ot ? Ot.length : 0;
                    dt.push({ newText: "", span: { length: en.length, start: wr - rn } });
                  }
                return dt;
              }
              __name(oi, "oi");
              function Ei(Me, Ve) {
                var _r = nr.getCurrentSourceFile(Me), lr = Qn(_r, Ve), Vr = lr.firstLine, tt = lr.lastLine;
                return Vr === tt && Ve.pos !== Ve.end ? oi(Me, Ve, true) : Yn(Me, Ve, true);
              }
              __name(Ei, "Ei");
              function Dn(Me, Ve) {
                var _r = nr.getCurrentSourceFile(Me), lr = [], Vr = Ve.pos, tt = Ve.end;
                Vr === tt && (tt += e.isInsideJsxElement(_r, Vr) ? 2 : 1);
                for (var dt = Vr; dt <= tt; dt++) {
                  var It = e.isInComment(_r, dt);
                  if (It) {
                    switch (It.kind) {
                      case 2:
                        lr.push.apply(lr, Yn(Me, { end: It.end, pos: It.pos + 1 }, false));
                        break;
                      case 3:
                        lr.push.apply(lr, oi(Me, { end: It.end, pos: It.pos + 1 }, false));
                    }
                    dt = It.end + 1;
                  }
                }
                return lr;
              }
              __name(Dn, "Dn");
              function Kn(Me) {
                var Ve = Me.openingElement, _r = Me.closingElement, lr = Me.parent;
                return !e.tagNamesAreEquivalent(Ve.tagName, _r.tagName) || e.isJsxElement(lr) && e.tagNamesAreEquivalent(Ve.tagName, lr.openingElement.tagName) && Kn(lr);
              }
              __name(Kn, "Kn");
              function si(Me) {
                var Ve = Me.closingFragment, _r = Me.parent;
                return !!(Ve.flags & 131072) || e.isJsxFragment(_r) && si(_r);
              }
              __name(si, "si");
              function mi(Me, Ve, _r) {
                var lr = nr.getCurrentSourceFile(Me), Vr = e.formatting.getRangeOfEnclosingComment(lr, Ve);
                return Vr && (!_r || Vr.kind === 3) ? e.createTextSpanFromRange(Vr) : void 0;
              }
              __name(mi, "mi");
              function Zn(Me, Ve) {
                Z();
                var _r = rt(Me);
                ye.throwIfCancellationRequested();
                var lr = _r.text, Vr = [];
                if (Ve.length > 0 && !Hn(_r.fileName))
                  for (var tt = Ot(), dt = void 0; dt = tt.exec(lr); ) {
                    ye.throwIfCancellationRequested();
                    var It = 3;
                    e.Debug.assert(dt.length === Ve.length + It);
                    var an = dt[1], sn = dt.index + an.length;
                    if (!!e.isInComment(_r, sn)) {
                      for (var _e = void 0, Gr = 0; Gr < Ve.length; Gr++)
                        dt[Gr + It] && (_e = Ve[Gr]);
                      if (_e === void 0)
                        return e.Debug.fail();
                      if (!rr(lr.charCodeAt(sn + _e.text.length))) {
                        var Kt = dt[2];
                        Vr.push({ descriptor: _e, message: Kt, position: sn });
                      }
                    }
                  }
                return Vr;
                function en(rn) {
                  return rn.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
                }
                __name(en, "en");
                function Ot() {
                  var rn = /(?:\/\/+\s*)/.source, xn = /(?:\/\*+\s*)/.source, Mn = /(?:^(?:\s|\*)*)/.source, Rn = "(" + Mn + "|" + rn + "|" + xn + ")", kn = "(?:" + e.map(Ve, function(mn) {
                    return "(" + en(mn.text) + ")";
                  }).join("|") + ")", on = /(?:$|\*\/)/.source, Xr = /(?:.*?)/.source, wr = "(" + kn + Xr + ")", fn = Rn + wr + on;
                  return new RegExp(fn, "gim");
                }
                __name(Ot, "Ot");
                function rr(rn) {
                  return rn >= 97 && rn <= 122 || rn >= 65 && rn <= 90 || rn >= 48 && rn <= 57;
                }
                __name(rr, "rr");
                function Hn(rn) {
                  return e.stringContains(rn, "/node_modules/");
                }
                __name(Hn, "Hn");
              }
              __name(Zn, "Zn");
              function Fn(Me, Ve, _r) {
                return Z(), e.Rename.getRenameInfo(tr, rt(Me), Ve, _r || {});
              }
              __name(Fn, "Fn");
              function gt(Me, Ve, _r, lr, Vr, tt) {
                var dt = typeof Ve == "number" ? [Ve, void 0] : [Ve.pos, Ve.end], It = dt[0], an = dt[1];
                return { file: Me, startPosition: It, endPosition: an, program: f(), host: X, formatContext: e.formatting.getFormatContext(lr, X), cancellationToken: ye, preferences: _r, triggerReason: Vr, kind: tt };
              }
              __name(gt, "gt");
              function gi(Me, Ve, _r) {
                return { file: Me, program: f(), host: X, span: Ve, preferences: _r, cancellationToken: ye };
              }
              __name(gi, "gi");
              function dn(Me, Ve) {
                return e.SmartSelectionRange.getSmartSelectionRange(Ve, nr.getCurrentSourceFile(Me));
              }
              __name(dn, "dn");
              function On(Me, Ve, _r, lr, Vr) {
                _r === void 0 && (_r = e.emptyOptions), Z();
                var tt = rt(Me);
                return e.refactor.getApplicableRefactors(gt(tt, Ve, _r, e.emptyOptions, lr, Vr));
              }
              __name(On, "On");
              function br(Me, Ve, _r, lr, Vr, tt) {
                tt === void 0 && (tt = e.emptyOptions), Z();
                var dt = rt(Me);
                return e.refactor.getEditsForRefactor(gt(dt, _r, tt, Ve), lr, Vr);
              }
              __name(br, "br");
              function Ae(Me, Ve) {
                return Ve === 0 ? { line: 0, character: 0 } : ut.toLineColumnOffset(Me, Ve);
              }
              __name(Ae, "Ae");
              function ur(Me, Ve) {
                Z();
                var _r = e.CallHierarchy.resolveCallHierarchyDeclaration(tr, e.getTouchingPropertyName(rt(Me), Ve));
                return _r && e.mapOneOrMany(_r, function(lr) {
                  return e.CallHierarchy.createCallHierarchyItem(tr, lr);
                });
              }
              __name(ur, "ur");
              function L(Me, Ve) {
                Z();
                var _r = rt(Me), lr = e.firstOrOnly(e.CallHierarchy.resolveCallHierarchyDeclaration(tr, Ve === 0 ? _r : e.getTouchingPropertyName(_r, Ve)));
                return lr ? e.CallHierarchy.getIncomingCalls(tr, lr, ye) : [];
              }
              __name(L, "L");
              function qt(Me, Ve) {
                Z();
                var _r = rt(Me), lr = e.firstOrOnly(e.CallHierarchy.resolveCallHierarchyDeclaration(tr, Ve === 0 ? _r : e.getTouchingPropertyName(_r, Ve)));
                return lr ? e.CallHierarchy.getOutgoingCalls(tr, lr) : [];
              }
              __name(qt, "qt");
              function nn(Me, Ve, _r) {
                _r === void 0 && (_r = e.emptyOptions), Z();
                var lr = rt(Me);
                return e.InlayHints.provideInlayHints(gi(lr, Ve, _r));
              }
              __name(nn, "nn");
              var fr = { dispose: jr, cleanupSemanticCache: xr, getSyntacticDiagnostics: qr, getSemanticDiagnostics: pt, getSuggestionDiagnostics: Ge, getCompilerOptionsDiagnostics: K, getSyntacticClassifications: Qe, getSemanticClassifications: k, getEncodedSyntacticClassifications: Sr, getEncodedSemanticClassifications: ue, getCompletionsAtPosition: r, getCompletionEntryDetails: ct, getCompletionEntrySymbol: ft, getSignatureHelpItems: Dt, getQuickInfoAtPosition: Ie, getDefinitionAtPosition: Ye, getDefinitionAndBoundSpan: vr, getImplementationAtPosition: pr, getTypeDefinitionAtPosition: nt, getReferencesAtPosition: re, findReferences: He, getFileReferences: Nr, getOccurrencesAtPosition: Mr, getDocumentHighlights: ot, getNameOrDottedNameSpan: zt, getBreakpointStatementAtPosition: Zt, getNavigateToItems: Yr, getRenameInfo: Fn, getSmartSelectionRange: dn, findRenameLocations: At, getNavigationBarItems: mt, getNavigationTree: at, getOutliningSpans: Kr, getTodoComments: Zn, getBraceMatchingAtPosition: Ct, getIndentationAtPosition: Xt, getFormattingEditsForRange: cn, getFormattingEditsForDocument: In, getFormattingEditsAfterKeystroke: yn, getDocCommentTemplateAtPosition: vi, isValidBraceCompletionAtPosition: ri, getJsxClosingTagAtPosition: bi, getSpanOfEnclosingComment: mi, getCodeFixesAtPosition: hn, getCombinedCodeFix: ln, applyCodeActionCommand: ui, organizeImports: En, getEditsForFileRename: Vt, getEmitOutput: St, getNonBoundSourceFile: Lt, getProgram: f, getCurrentProgram: function() {
                return tr;
              }, getAutoImportProvider: h, updateIsDefinitionOfReferencedSymbols: ae, getApplicableRefactors: On, getEditsForRefactor: br, toLineColumnOffset: Ae, getSourceMapper: function() {
                return ut;
              }, clearSourceMapperCache: function() {
                return ut.clearCache();
              }, prepareCallHierarchy: ur, provideCallHierarchyIncomingCalls: L, provideCallHierarchyOutgoingCalls: qt, toggleLineComment: Yn, toggleMultilineComment: oi, commentSelection: Ei, uncommentSelection: Dn, provideInlayHints: nn };
              switch (kr) {
                case e.LanguageServiceMode.Semantic:
                  break;
                case e.LanguageServiceMode.PartialSemantic:
                  $e.forEach(function(Me) {
                    return fr[Me] = function() {
                      throw new Error("LanguageService Operation: ".concat(Me, " not allowed in LanguageServiceMode.PartialSemantic"));
                    };
                  });
                  break;
                case e.LanguageServiceMode.Syntactic:
                  Re.forEach(function(Me) {
                    return fr[Me] = function() {
                      throw new Error("LanguageService Operation: ".concat(Me, " not allowed in LanguageServiceMode.Syntactic"));
                    };
                  });
                  break;
                default:
                  e.Debug.assertNever(kr);
              }
              return fr;
            }
            __name(Fe, "Fe");
            e.createLanguageService = Fe;
            function dr(X) {
              return X.nameTable || ze(X), X.nameTable;
            }
            __name(dr, "dr");
            e.getNameTable = dr;
            function ze(X) {
              var Ee = X.nameTable = new e.Map();
              X.forEachChild(/* @__PURE__ */ __name(function we(he) {
                if (e.isIdentifier(he) && !e.isTagName(he) && he.escapedText || e.isStringOrNumericLiteralLike(he) && ve(he)) {
                  var yr = e.getEscapedTextOfIdentifierOrLiteral(he);
                  Ee.set(yr, Ee.get(yr) === void 0 ? he.pos : -1);
                } else if (e.isPrivateIdentifier(he)) {
                  var yr = he.escapedText;
                  Ee.set(yr, Ee.get(yr) === void 0 ? he.pos : -1);
                }
                if (e.forEachChild(he, we), e.hasJSDocNodes(he))
                  for (var kr = 0, nr = he.jsDoc; kr < nr.length; kr++) {
                    var tr = nr[kr];
                    e.forEachChild(tr, we);
                  }
              }, "we"));
            }
            __name(ze, "ze");
            function ve(X) {
              return e.isDeclarationName(X) || X.parent.kind === 280 || Xe(X) || e.isLiteralComputedPropertyDeclarationName(X);
            }
            __name(ve, "ve");
            function er(X) {
              var Ee = ar(X);
              return Ee && (e.isObjectLiteralExpression(Ee.parent) || e.isJsxAttributes(Ee.parent)) ? Ee : void 0;
            }
            __name(er, "er");
            e.getContainingObjectLiteralElement = er;
            function ar(X) {
              switch (X.kind) {
                case 10:
                case 14:
                case 8:
                  if (X.parent.kind === 164)
                    return e.isObjectLiteralElement(X.parent.parent) ? X.parent.parent : void 0;
                case 79:
                  return e.isObjectLiteralElement(X.parent) && (X.parent.parent.kind === 207 || X.parent.parent.kind === 289) && X.parent.name === X ? X.parent : void 0;
              }
            }
            __name(ar, "ar");
            function Cr(X, Ee) {
              var we = er(X);
              if (we) {
                var he = Ee.getContextualType(we.parent), yr = he && Ce(we, Ee, he, false);
                if (yr && yr.length === 1)
                  return e.first(yr);
              }
              return Ee.getSymbolAtLocation(X);
            }
            __name(Cr, "Cr");
            function Ce(X, Ee, we, he) {
              var yr = e.getNameFromPropertyName(X.name);
              if (!yr)
                return e.emptyArray;
              if (!we.isUnion()) {
                var kr = we.getProperty(yr);
                return kr ? [kr] : e.emptyArray;
              }
              var nr = e.mapDefined(we.types, function(tr) {
                return (e.isObjectLiteralExpression(X.parent) || e.isJsxAttributes(X.parent)) && Ee.isTypeInvalidDueToUnionDiscriminant(tr, X.parent) ? void 0 : tr.getProperty(yr);
              });
              if (he && (nr.length === 0 || nr.length === we.types.length)) {
                var kr = we.getProperty(yr);
                if (kr)
                  return [kr];
              }
              return nr.length === 0 ? e.mapDefined(we.types, function(tr) {
                return tr.getProperty(yr);
              }) : nr;
            }
            __name(Ce, "Ce");
            e.getPropertySymbolsFromContextualType = Ce;
            function Xe(X) {
              return X && X.parent && X.parent.kind === 209 && X.parent.argumentExpression === X;
            }
            __name(Xe, "Xe");
            function gr(X) {
              return e.combinePaths("/prettier-security-dirname-placeholder", e.getDefaultLibFileName(X));
            }
            __name(gr, "gr");
            e.getDefaultLibFilePath = gr, e.setObjectAllocator(v());
          })(N || (N = {})), c.exports = N;
        } }), El = Ur({ "node_modules/semver/internal/constants.js"(a, c) {
          Jr();
          var A = "2.0.0", T = 256, oe = Number.MAX_SAFE_INTEGER || 9007199254740991, z = 16;
          c.exports = { SEMVER_SPEC_VERSION: A, MAX_LENGTH: T, MAX_SAFE_INTEGER: oe, MAX_SAFE_COMPONENT_LENGTH: z };
        } }), Tl = Ur({ "node_modules/semver/internal/debug.js"(a, c) {
          Jr();
          var A = typeof Ea == "object" && Ea.env && Ea.env.NODE_DEBUG && /\bsemver\b/i.test(Ea.env.NODE_DEBUG) ? function() {
            for (var T = arguments.length, oe = new Array(T), z = 0; z < T; z++)
              oe[z] = arguments[z];
            return console.error("SEMVER", ...oe);
          } : () => {
          };
          c.exports = A;
        } }), Bc = Ur({ "node_modules/semver/internal/re.js"(a, c) {
          Jr();
          var { MAX_SAFE_COMPONENT_LENGTH: A } = El(), T = Tl();
          a = c.exports = {};
          var oe = a.re = [], z = a.src = [], I = a.t = {}, E = 0, N = /* @__PURE__ */ __name((e, t, x) => {
            let s = E++;
            T(e, s, t), I[e] = s, z[s] = t, oe[s] = new RegExp(t, x ? "g" : void 0);
          }, "N");
          N("NUMERICIDENTIFIER", "0|[1-9]\\d*"), N("NUMERICIDENTIFIERLOOSE", "[0-9]+"), N("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), N("MAINVERSION", `(${z[I.NUMERICIDENTIFIER]})\\.(${z[I.NUMERICIDENTIFIER]})\\.(${z[I.NUMERICIDENTIFIER]})`), N("MAINVERSIONLOOSE", `(${z[I.NUMERICIDENTIFIERLOOSE]})\\.(${z[I.NUMERICIDENTIFIERLOOSE]})\\.(${z[I.NUMERICIDENTIFIERLOOSE]})`), N("PRERELEASEIDENTIFIER", `(?:${z[I.NUMERICIDENTIFIER]}|${z[I.NONNUMERICIDENTIFIER]})`), N("PRERELEASEIDENTIFIERLOOSE", `(?:${z[I.NUMERICIDENTIFIERLOOSE]}|${z[I.NONNUMERICIDENTIFIER]})`), N("PRERELEASE", `(?:-(${z[I.PRERELEASEIDENTIFIER]}(?:\\.${z[I.PRERELEASEIDENTIFIER]})*))`), N("PRERELEASELOOSE", `(?:-?(${z[I.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${z[I.PRERELEASEIDENTIFIERLOOSE]})*))`), N("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), N("BUILD", `(?:\\+(${z[I.BUILDIDENTIFIER]}(?:\\.${z[I.BUILDIDENTIFIER]})*))`), N("FULLPLAIN", `v?${z[I.MAINVERSION]}${z[I.PRERELEASE]}?${z[I.BUILD]}?`), N("FULL", `^${z[I.FULLPLAIN]}$`), N("LOOSEPLAIN", `[v=\\s]*${z[I.MAINVERSIONLOOSE]}${z[I.PRERELEASELOOSE]}?${z[I.BUILD]}?`), N("LOOSE", `^${z[I.LOOSEPLAIN]}$`), N("GTLT", "((?:<|>)?=?)"), N("XRANGEIDENTIFIERLOOSE", `${z[I.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), N("XRANGEIDENTIFIER", `${z[I.NUMERICIDENTIFIER]}|x|X|\\*`), N("XRANGEPLAIN", `[v=\\s]*(${z[I.XRANGEIDENTIFIER]})(?:\\.(${z[I.XRANGEIDENTIFIER]})(?:\\.(${z[I.XRANGEIDENTIFIER]})(?:${z[I.PRERELEASE]})?${z[I.BUILD]}?)?)?`), N("XRANGEPLAINLOOSE", `[v=\\s]*(${z[I.XRANGEIDENTIFIERLOOSE]})(?:\\.(${z[I.XRANGEIDENTIFIERLOOSE]})(?:\\.(${z[I.XRANGEIDENTIFIERLOOSE]})(?:${z[I.PRERELEASELOOSE]})?${z[I.BUILD]}?)?)?`), N("XRANGE", `^${z[I.GTLT]}\\s*${z[I.XRANGEPLAIN]}$`), N("XRANGELOOSE", `^${z[I.GTLT]}\\s*${z[I.XRANGEPLAINLOOSE]}$`), N("COERCE", `(^|[^\\d])(\\d{1,${A}})(?:\\.(\\d{1,${A}}))?(?:\\.(\\d{1,${A}}))?(?:$|[^\\d])`), N("COERCERTL", z[I.COERCE], true), N("LONETILDE", "(?:~>?)"), N("TILDETRIM", `(\\s*)${z[I.LONETILDE]}\\s+`, true), a.tildeTrimReplace = "$1~", N("TILDE", `^${z[I.LONETILDE]}${z[I.XRANGEPLAIN]}$`), N("TILDELOOSE", `^${z[I.LONETILDE]}${z[I.XRANGEPLAINLOOSE]}$`), N("LONECARET", "(?:\\^)"), N("CARETTRIM", `(\\s*)${z[I.LONECARET]}\\s+`, true), a.caretTrimReplace = "$1^", N("CARET", `^${z[I.LONECARET]}${z[I.XRANGEPLAIN]}$`), N("CARETLOOSE", `^${z[I.LONECARET]}${z[I.XRANGEPLAINLOOSE]}$`), N("COMPARATORLOOSE", `^${z[I.GTLT]}\\s*(${z[I.LOOSEPLAIN]})$|^$`), N("COMPARATOR", `^${z[I.GTLT]}\\s*(${z[I.FULLPLAIN]})$|^$`), N("COMPARATORTRIM", `(\\s*)${z[I.GTLT]}\\s*(${z[I.LOOSEPLAIN]}|${z[I.XRANGEPLAIN]})`, true), a.comparatorTrimReplace = "$1$2$3", N("HYPHENRANGE", `^\\s*(${z[I.XRANGEPLAIN]})\\s+-\\s+(${z[I.XRANGEPLAIN]})\\s*$`), N("HYPHENRANGELOOSE", `^\\s*(${z[I.XRANGEPLAINLOOSE]})\\s+-\\s+(${z[I.XRANGEPLAINLOOSE]})\\s*$`), N("STAR", "(<|>)?=?\\s*\\*"), N("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), N("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        } }), Sl = Ur({ "node_modules/semver/internal/parse-options.js"(a, c) {
          Jr();
          var A = ["includePrerelease", "loose", "rtl"], T = /* @__PURE__ */ __name((oe) => oe ? typeof oe != "object" ? { loose: true } : A.filter((z) => oe[z]).reduce((z, I) => (z[I] = true, z), {}) : {}, "T");
          c.exports = T;
        } }), qp = Ur({ "node_modules/semver/internal/identifiers.js"(a, c) {
          Jr();
          var A = /^[0-9]+$/, T = /* @__PURE__ */ __name((z, I) => {
            let E = A.test(z), N = A.test(I);
            return E && N && (z = +z, I = +I), z === I ? 0 : E && !N ? -1 : N && !E ? 1 : z < I ? -1 : 1;
          }, "T"), oe = /* @__PURE__ */ __name((z, I) => T(I, z), "oe");
          c.exports = { compareIdentifiers: T, rcompareIdentifiers: oe };
        } }), da = Ur({ "node_modules/semver/classes/semver.js"(a, c) {
          Jr();
          var A = Tl(), { MAX_LENGTH: T, MAX_SAFE_INTEGER: oe } = El(), { re: z, t: I } = Bc(), E = Sl(), { compareIdentifiers: N } = qp(), e = /* @__PURE__ */ __name(class {
            constructor(t, x) {
              if (x = E(x), t instanceof e) {
                if (t.loose === !!x.loose && t.includePrerelease === !!x.includePrerelease)
                  return t;
                t = t.version;
              } else if (typeof t != "string")
                throw new TypeError(`Invalid Version: ${t}`);
              if (t.length > T)
                throw new TypeError(`version is longer than ${T} characters`);
              A("SemVer", t, x), this.options = x, this.loose = !!x.loose, this.includePrerelease = !!x.includePrerelease;
              let s = t.trim().match(x.loose ? z[I.LOOSE] : z[I.FULL]);
              if (!s)
                throw new TypeError(`Invalid Version: ${t}`);
              if (this.raw = t, this.major = +s[1], this.minor = +s[2], this.patch = +s[3], this.major > oe || this.major < 0)
                throw new TypeError("Invalid major version");
              if (this.minor > oe || this.minor < 0)
                throw new TypeError("Invalid minor version");
              if (this.patch > oe || this.patch < 0)
                throw new TypeError("Invalid patch version");
              s[4] ? this.prerelease = s[4].split(".").map((q) => {
                if (/^[0-9]+$/.test(q)) {
                  let F = +q;
                  if (F >= 0 && F < oe)
                    return F;
                }
                return q;
              }) : this.prerelease = [], this.build = s[5] ? s[5].split(".") : [], this.format();
            }
            format() {
              return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
            }
            toString() {
              return this.version;
            }
            compare(t) {
              if (A("SemVer.compare", this.version, this.options, t), !(t instanceof e)) {
                if (typeof t == "string" && t === this.version)
                  return 0;
                t = new e(t, this.options);
              }
              return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
            }
            compareMain(t) {
              return t instanceof e || (t = new e(t, this.options)), N(this.major, t.major) || N(this.minor, t.minor) || N(this.patch, t.patch);
            }
            comparePre(t) {
              if (t instanceof e || (t = new e(t, this.options)), this.prerelease.length && !t.prerelease.length)
                return -1;
              if (!this.prerelease.length && t.prerelease.length)
                return 1;
              if (!this.prerelease.length && !t.prerelease.length)
                return 0;
              let x = 0;
              do {
                let s = this.prerelease[x], q = t.prerelease[x];
                if (A("prerelease compare", x, s, q), s === void 0 && q === void 0)
                  return 0;
                if (q === void 0)
                  return 1;
                if (s === void 0)
                  return -1;
                if (s === q)
                  continue;
                return N(s, q);
              } while (++x);
            }
            compareBuild(t) {
              t instanceof e || (t = new e(t, this.options));
              let x = 0;
              do {
                let s = this.build[x], q = t.build[x];
                if (A("prerelease compare", x, s, q), s === void 0 && q === void 0)
                  return 0;
                if (q === void 0)
                  return 1;
                if (s === void 0)
                  return -1;
                if (s === q)
                  continue;
                return N(s, q);
              } while (++x);
            }
            inc(t, x) {
              switch (t) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", x);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", x);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", x), this.inc("pre", x);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", x), this.inc("pre", x);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0)
                    this.prerelease = [0];
                  else {
                    let s = this.prerelease.length;
                    for (; --s >= 0; )
                      typeof this.prerelease[s] == "number" && (this.prerelease[s]++, s = -2);
                    s === -1 && this.prerelease.push(0);
                  }
                  x && (N(this.prerelease[0], x) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [x, 0]) : this.prerelease = [x, 0]);
                  break;
                default:
                  throw new Error(`invalid increment argument: ${t}`);
              }
              return this.format(), this.raw = this.version, this;
            }
          }, "e");
          c.exports = e;
        } }), qc = Ur({ "node_modules/semver/functions/parse.js"(a, c) {
          Jr();
          var { MAX_LENGTH: A } = El(), { re: T, t: oe } = Bc(), z = da(), I = Sl(), E = /* @__PURE__ */ __name((N, e) => {
            if (e = I(e), N instanceof z)
              return N;
            if (typeof N != "string" || N.length > A || !(e.loose ? T[oe.LOOSE] : T[oe.FULL]).test(N))
              return null;
            try {
              return new z(N, e);
            } catch {
              return null;
            }
          }, "E");
          c.exports = E;
        } }), Ob = Ur({ "node_modules/semver/functions/valid.js"(a, c) {
          Jr();
          var A = qc(), T = /* @__PURE__ */ __name((oe, z) => {
            let I = A(oe, z);
            return I ? I.version : null;
          }, "T");
          c.exports = T;
        } }), Mb = Ur({ "node_modules/semver/functions/clean.js"(a, c) {
          Jr();
          var A = qc(), T = /* @__PURE__ */ __name((oe, z) => {
            let I = A(oe.trim().replace(/^[=v]+/, ""), z);
            return I ? I.version : null;
          }, "T");
          c.exports = T;
        } }), Lb = Ur({ "node_modules/semver/functions/inc.js"(a, c) {
          Jr();
          var A = da(), T = /* @__PURE__ */ __name((oe, z, I, E) => {
            typeof I == "string" && (E = I, I = void 0);
            try {
              return new A(oe instanceof A ? oe.version : oe, I).inc(z, E).version;
            } catch {
              return null;
            }
          }, "T");
          c.exports = T;
        } }), Ya = Ur({ "node_modules/semver/functions/compare.js"(a, c) {
          Jr();
          var A = da(), T = /* @__PURE__ */ __name((oe, z, I) => new A(oe, I).compare(new A(z, I)), "T");
          c.exports = T;
        } }), Hp = Ur({ "node_modules/semver/functions/eq.js"(a, c) {
          Jr();
          var A = Ya(), T = /* @__PURE__ */ __name((oe, z, I) => A(oe, z, I) === 0, "T");
          c.exports = T;
        } }), Rb = Ur({ "node_modules/semver/functions/diff.js"(a, c) {
          Jr();
          var A = qc(), T = Hp(), oe = /* @__PURE__ */ __name((z, I) => {
            if (T(z, I))
              return null;
            {
              let E = A(z), N = A(I), e = E.prerelease.length || N.prerelease.length, t = e ? "pre" : "", x = e ? "prerelease" : "";
              for (let s in E)
                if ((s === "major" || s === "minor" || s === "patch") && E[s] !== N[s])
                  return t + s;
              return x;
            }
          }, "oe");
          c.exports = oe;
        } }), jb = Ur({ "node_modules/semver/functions/major.js"(a, c) {
          Jr();
          var A = da(), T = /* @__PURE__ */ __name((oe, z) => new A(oe, z).major, "T");
          c.exports = T;
        } }), Jb = Ur({ "node_modules/semver/functions/minor.js"(a, c) {
          Jr();
          var A = da(), T = /* @__PURE__ */ __name((oe, z) => new A(oe, z).minor, "T");
          c.exports = T;
        } }), Fb = Ur({ "node_modules/semver/functions/patch.js"(a, c) {
          Jr();
          var A = da(), T = /* @__PURE__ */ __name((oe, z) => new A(oe, z).patch, "T");
          c.exports = T;
        } }), Bb = Ur({ "node_modules/semver/functions/prerelease.js"(a, c) {
          Jr();
          var A = qc(), T = /* @__PURE__ */ __name((oe, z) => {
            let I = A(oe, z);
            return I && I.prerelease.length ? I.prerelease : null;
          }, "T");
          c.exports = T;
        } }), qb = Ur({ "node_modules/semver/functions/rcompare.js"(a, c) {
          Jr();
          var A = Ya(), T = /* @__PURE__ */ __name((oe, z, I) => A(z, oe, I), "T");
          c.exports = T;
        } }), Ub = Ur({ "node_modules/semver/functions/compare-loose.js"(a, c) {
          Jr();
          var A = Ya(), T = /* @__PURE__ */ __name((oe, z) => A(oe, z, true), "T");
          c.exports = T;
        } }), Gp = Ur({ "node_modules/semver/functions/compare-build.js"(a, c) {
          Jr();
          var A = da(), T = /* @__PURE__ */ __name((oe, z, I) => {
            let E = new A(oe, I), N = new A(z, I);
            return E.compare(N) || E.compareBuild(N);
          }, "T");
          c.exports = T;
        } }), zb = Ur({ "node_modules/semver/functions/sort.js"(a, c) {
          Jr();
          var A = Gp(), T = /* @__PURE__ */ __name((oe, z) => oe.sort((I, E) => A(I, E, z)), "T");
          c.exports = T;
        } }), Vb = Ur({ "node_modules/semver/functions/rsort.js"(a, c) {
          Jr();
          var A = Gp(), T = /* @__PURE__ */ __name((oe, z) => oe.sort((I, E) => A(E, I, z)), "T");
          c.exports = T;
        } }), Cl = Ur({ "node_modules/semver/functions/gt.js"(a, c) {
          Jr();
          var A = Ya(), T = /* @__PURE__ */ __name((oe, z, I) => A(oe, z, I) > 0, "T");
          c.exports = T;
        } }), Xp = Ur({ "node_modules/semver/functions/lt.js"(a, c) {
          Jr();
          var A = Ya(), T = /* @__PURE__ */ __name((oe, z, I) => A(oe, z, I) < 0, "T");
          c.exports = T;
        } }), Xg = Ur({ "node_modules/semver/functions/neq.js"(a, c) {
          Jr();
          var A = Ya(), T = /* @__PURE__ */ __name((oe, z, I) => A(oe, z, I) !== 0, "T");
          c.exports = T;
        } }), $p = Ur({ "node_modules/semver/functions/gte.js"(a, c) {
          Jr();
          var A = Ya(), T = /* @__PURE__ */ __name((oe, z, I) => A(oe, z, I) >= 0, "T");
          c.exports = T;
        } }), Qp = Ur({ "node_modules/semver/functions/lte.js"(a, c) {
          Jr();
          var A = Ya(), T = /* @__PURE__ */ __name((oe, z, I) => A(oe, z, I) <= 0, "T");
          c.exports = T;
        } }), $g = Ur({ "node_modules/semver/functions/cmp.js"(a, c) {
          Jr();
          var A = Hp(), T = Xg(), oe = Cl(), z = $p(), I = Xp(), E = Qp(), N = /* @__PURE__ */ __name((e, t, x, s) => {
            switch (t) {
              case "===":
                return typeof e == "object" && (e = e.version), typeof x == "object" && (x = x.version), e === x;
              case "!==":
                return typeof e == "object" && (e = e.version), typeof x == "object" && (x = x.version), e !== x;
              case "":
              case "=":
              case "==":
                return A(e, x, s);
              case "!=":
                return T(e, x, s);
              case ">":
                return oe(e, x, s);
              case ">=":
                return z(e, x, s);
              case "<":
                return I(e, x, s);
              case "<=":
                return E(e, x, s);
              default:
                throw new TypeError(`Invalid operator: ${t}`);
            }
          }, "N");
          c.exports = N;
        } }), Wb = Ur({ "node_modules/semver/functions/coerce.js"(a, c) {
          Jr();
          var A = da(), T = qc(), { re: oe, t: z } = Bc(), I = /* @__PURE__ */ __name((E, N) => {
            if (E instanceof A)
              return E;
            if (typeof E == "number" && (E = String(E)), typeof E != "string")
              return null;
            N = N || {};
            let e = null;
            if (!N.rtl)
              e = E.match(oe[z.COERCE]);
            else {
              let t;
              for (; (t = oe[z.COERCERTL].exec(E)) && (!e || e.index + e[0].length !== E.length); )
                (!e || t.index + t[0].length !== e.index + e[0].length) && (e = t), oe[z.COERCERTL].lastIndex = t.index + t[1].length + t[2].length;
              oe[z.COERCERTL].lastIndex = -1;
            }
            return e === null ? null : T(`${e[2]}.${e[3] || "0"}.${e[4] || "0"}`, N);
          }, "I");
          c.exports = I;
        } }), Kb = Ur({ "node_modules/yallist/iterator.js"(a, c) {
          "use strict";
          Jr(), c.exports = function(A) {
            A.prototype[Symbol.iterator] = function* () {
              for (let T = this.head; T; T = T.next)
                yield T.value;
            };
          };
        } }), Hb = Ur({ "node_modules/yallist/yallist.js"(a, c) {
          "use strict";
          Jr(), c.exports = A, A.Node = I, A.create = A;
          function A(E) {
            var N = this;
            if (N instanceof A || (N = new A()), N.tail = null, N.head = null, N.length = 0, E && typeof E.forEach == "function")
              E.forEach(function(x) {
                N.push(x);
              });
            else if (arguments.length > 0)
              for (var e = 0, t = arguments.length; e < t; e++)
                N.push(arguments[e]);
            return N;
          }
          __name(A, "A");
          A.prototype.removeNode = function(E) {
            if (E.list !== this)
              throw new Error("removing node which does not belong to this list");
            var N = E.next, e = E.prev;
            return N && (N.prev = e), e && (e.next = N), E === this.head && (this.head = N), E === this.tail && (this.tail = e), E.list.length--, E.next = null, E.prev = null, E.list = null, N;
          }, A.prototype.unshiftNode = function(E) {
            if (E !== this.head) {
              E.list && E.list.removeNode(E);
              var N = this.head;
              E.list = this, E.next = N, N && (N.prev = E), this.head = E, this.tail || (this.tail = E), this.length++;
            }
          }, A.prototype.pushNode = function(E) {
            if (E !== this.tail) {
              E.list && E.list.removeNode(E);
              var N = this.tail;
              E.list = this, E.prev = N, N && (N.next = E), this.tail = E, this.head || (this.head = E), this.length++;
            }
          }, A.prototype.push = function() {
            for (var E = 0, N = arguments.length; E < N; E++)
              oe(this, arguments[E]);
            return this.length;
          }, A.prototype.unshift = function() {
            for (var E = 0, N = arguments.length; E < N; E++)
              z(this, arguments[E]);
            return this.length;
          }, A.prototype.pop = function() {
            if (!!this.tail) {
              var E = this.tail.value;
              return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, E;
            }
          }, A.prototype.shift = function() {
            if (!!this.head) {
              var E = this.head.value;
              return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, E;
            }
          }, A.prototype.forEach = function(E, N) {
            N = N || this;
            for (var e = this.head, t = 0; e !== null; t++)
              E.call(N, e.value, t, this), e = e.next;
          }, A.prototype.forEachReverse = function(E, N) {
            N = N || this;
            for (var e = this.tail, t = this.length - 1; e !== null; t--)
              E.call(N, e.value, t, this), e = e.prev;
          }, A.prototype.get = function(E) {
            for (var N = 0, e = this.head; e !== null && N < E; N++)
              e = e.next;
            if (N === E && e !== null)
              return e.value;
          }, A.prototype.getReverse = function(E) {
            for (var N = 0, e = this.tail; e !== null && N < E; N++)
              e = e.prev;
            if (N === E && e !== null)
              return e.value;
          }, A.prototype.map = function(E, N) {
            N = N || this;
            for (var e = new A(), t = this.head; t !== null; )
              e.push(E.call(N, t.value, this)), t = t.next;
            return e;
          }, A.prototype.mapReverse = function(E, N) {
            N = N || this;
            for (var e = new A(), t = this.tail; t !== null; )
              e.push(E.call(N, t.value, this)), t = t.prev;
            return e;
          }, A.prototype.reduce = function(E, N) {
            var e, t = this.head;
            if (arguments.length > 1)
              e = N;
            else if (this.head)
              t = this.head.next, e = this.head.value;
            else
              throw new TypeError("Reduce of empty list with no initial value");
            for (var x = 0; t !== null; x++)
              e = E(e, t.value, x), t = t.next;
            return e;
          }, A.prototype.reduceReverse = function(E, N) {
            var e, t = this.tail;
            if (arguments.length > 1)
              e = N;
            else if (this.tail)
              t = this.tail.prev, e = this.tail.value;
            else
              throw new TypeError("Reduce of empty list with no initial value");
            for (var x = this.length - 1; t !== null; x--)
              e = E(e, t.value, x), t = t.prev;
            return e;
          }, A.prototype.toArray = function() {
            for (var E = new Array(this.length), N = 0, e = this.head; e !== null; N++)
              E[N] = e.value, e = e.next;
            return E;
          }, A.prototype.toArrayReverse = function() {
            for (var E = new Array(this.length), N = 0, e = this.tail; e !== null; N++)
              E[N] = e.value, e = e.prev;
            return E;
          }, A.prototype.slice = function(E, N) {
            N = N || this.length, N < 0 && (N += this.length), E = E || 0, E < 0 && (E += this.length);
            var e = new A();
            if (N < E || N < 0)
              return e;
            E < 0 && (E = 0), N > this.length && (N = this.length);
            for (var t = 0, x = this.head; x !== null && t < E; t++)
              x = x.next;
            for (; x !== null && t < N; t++, x = x.next)
              e.push(x.value);
            return e;
          }, A.prototype.sliceReverse = function(E, N) {
            N = N || this.length, N < 0 && (N += this.length), E = E || 0, E < 0 && (E += this.length);
            var e = new A();
            if (N < E || N < 0)
              return e;
            E < 0 && (E = 0), N > this.length && (N = this.length);
            for (var t = this.length, x = this.tail; x !== null && t > N; t--)
              x = x.prev;
            for (; x !== null && t > E; t--, x = x.prev)
              e.push(x.value);
            return e;
          }, A.prototype.splice = function(E, N) {
            E > this.length && (E = this.length - 1), E < 0 && (E = this.length + E);
            for (var e = 0, t = this.head; t !== null && e < E; e++)
              t = t.next;
            for (var x = [], e = 0; t && e < N; e++)
              x.push(t.value), t = this.removeNode(t);
            t === null && (t = this.tail), t !== this.head && t !== this.tail && (t = t.prev);
            for (var e = 0; e < (arguments.length <= 2 ? 0 : arguments.length - 2); e++)
              t = T(this, t, e + 2 < 2 || arguments.length <= e + 2 ? void 0 : arguments[e + 2]);
            return x;
          }, A.prototype.reverse = function() {
            for (var E = this.head, N = this.tail, e = E; e !== null; e = e.prev) {
              var t = e.prev;
              e.prev = e.next, e.next = t;
            }
            return this.head = N, this.tail = E, this;
          };
          function T(E, N, e) {
            var t = N === E.head ? new I(e, null, N, E) : new I(e, N, N.next, E);
            return t.next === null && (E.tail = t), t.prev === null && (E.head = t), E.length++, t;
          }
          __name(T, "T");
          function oe(E, N) {
            E.tail = new I(N, E.tail, null, E), E.head || (E.head = E.tail), E.length++;
          }
          __name(oe, "oe");
          function z(E, N) {
            E.head = new I(N, null, E.head, E), E.tail || (E.tail = E.head), E.length++;
          }
          __name(z, "z");
          function I(E, N, e, t) {
            if (!(this instanceof I))
              return new I(E, N, e, t);
            this.list = t, this.value = E, N ? (N.next = this, this.prev = N) : this.prev = null, e ? (e.prev = this, this.next = e) : this.next = null;
          }
          __name(I, "I");
          try {
            Kb()(A);
          } catch {
          }
        } }), Gb = Ur({ "node_modules/lru-cache/index.js"(a, c) {
          "use strict";
          Jr();
          var A = Hb(), T = Symbol("max"), oe = Symbol("length"), z = Symbol("lengthCalculator"), I = Symbol("allowStale"), E = Symbol("maxAge"), N = Symbol("dispose"), e = Symbol("noDisposeOnSet"), t = Symbol("lruList"), x = Symbol("cache"), s = Symbol("updateAgeOnGet"), q = /* @__PURE__ */ __name(() => 1, "q"), F = /* @__PURE__ */ __name(class {
            constructor(Q) {
              if (typeof Q == "number" && (Q = { max: Q }), Q || (Q = {}), Q.max && (typeof Q.max != "number" || Q.max < 0))
                throw new TypeError("max must be a non-negative number");
              let Be = this[T] = Q.max || 1 / 0, je = Q.length || q;
              if (this[z] = typeof je != "function" ? q : je, this[I] = Q.stale || false, Q.maxAge && typeof Q.maxAge != "number")
                throw new TypeError("maxAge must be a number");
              this[E] = Q.maxAge || 0, this[N] = Q.dispose, this[e] = Q.noDisposeOnSet || false, this[s] = Q.updateAgeOnGet || false, this.reset();
            }
            set max(Q) {
              if (typeof Q != "number" || Q < 0)
                throw new TypeError("max must be a non-negative number");
              this[T] = Q || 1 / 0, Se(this);
            }
            get max() {
              return this[T];
            }
            set allowStale(Q) {
              this[I] = !!Q;
            }
            get allowStale() {
              return this[I];
            }
            set maxAge(Q) {
              if (typeof Q != "number")
                throw new TypeError("maxAge must be a non-negative number");
              this[E] = Q, Se(this);
            }
            get maxAge() {
              return this[E];
            }
            set lengthCalculator(Q) {
              typeof Q != "function" && (Q = q), Q !== this[z] && (this[z] = Q, this[oe] = 0, this[t].forEach((Be) => {
                Be.length = this[z](Be.value, Be.key), this[oe] += Be.length;
              })), Se(this);
            }
            get lengthCalculator() {
              return this[z];
            }
            get length() {
              return this[oe];
            }
            get itemCount() {
              return this[t].length;
            }
            rforEach(Q, Be) {
              Be = Be || this;
              for (let je = this[t].tail; je !== null; ) {
                let W = je.prev;
                Le(this, Q, je, Be), je = W;
              }
            }
            forEach(Q, Be) {
              Be = Be || this;
              for (let je = this[t].head; je !== null; ) {
                let W = je.next;
                Le(this, Q, je, Be), je = W;
              }
            }
            keys() {
              return this[t].toArray().map((Q) => Q.key);
            }
            values() {
              return this[t].toArray().map((Q) => Q.value);
            }
            reset() {
              this[N] && this[t] && this[t].length && this[t].forEach((Q) => this[N](Q.key, Q.value)), this[x] = /* @__PURE__ */ new Map(), this[t] = new A(), this[oe] = 0;
            }
            dump() {
              return this[t].map((Q) => Te(this, Q) ? false : { k: Q.key, v: Q.value, e: Q.now + (Q.maxAge || 0) }).toArray().filter((Q) => Q);
            }
            dumpLru() {
              return this[t];
            }
            set(Q, Be, je) {
              if (je = je || this[E], je && typeof je != "number")
                throw new TypeError("maxAge must be a number");
              let W = je ? Date.now() : 0, B = this[z](Be, Q);
              if (this[x].has(Q)) {
                if (B > this[T])
                  return J(this, this[x].get(Q)), false;
                let v = this[x].get(Q).value;
                return this[N] && (this[e] || this[N](Q, v.value)), v.now = W, v.maxAge = je, v.value = Be, this[oe] += B - v.length, v.length = B, this.get(Q), Se(this), true;
              }
              let U = new se(Q, Be, B, W, je);
              return U.length > this[T] ? (this[N] && this[N](Q, Be), false) : (this[oe] += U.length, this[t].unshift(U), this[x].set(Q, this[t].head), Se(this), true);
            }
            has(Q) {
              if (!this[x].has(Q))
                return false;
              let Be = this[x].get(Q).value;
              return !Te(this, Be);
            }
            get(Q) {
              return fe(this, Q, true);
            }
            peek(Q) {
              return fe(this, Q, false);
            }
            pop() {
              let Q = this[t].tail;
              return Q ? (J(this, Q), Q.value) : null;
            }
            del(Q) {
              J(this, this[x].get(Q));
            }
            load(Q) {
              this.reset();
              let Be = Date.now();
              for (let je = Q.length - 1; je >= 0; je--) {
                let W = Q[je], B = W.e || 0;
                if (B === 0)
                  this.set(W.k, W.v);
                else {
                  let U = B - Be;
                  U > 0 && this.set(W.k, W.v, U);
                }
              }
            }
            prune() {
              this[x].forEach((Q, Be) => fe(this, Be, false));
            }
          }, "F"), fe = /* @__PURE__ */ __name((Q, Be, je) => {
            let W = Q[x].get(Be);
            if (W) {
              let B = W.value;
              if (Te(Q, B)) {
                if (J(Q, W), !Q[I])
                  return;
              } else
                je && (Q[s] && (W.value.now = Date.now()), Q[t].unshiftNode(W));
              return B.value;
            }
          }, "fe"), Te = /* @__PURE__ */ __name((Q, Be) => {
            if (!Be || !Be.maxAge && !Q[E])
              return false;
            let je = Date.now() - Be.now;
            return Be.maxAge ? je > Be.maxAge : Q[E] && je > Q[E];
          }, "Te"), Se = /* @__PURE__ */ __name((Q) => {
            if (Q[oe] > Q[T])
              for (let Be = Q[t].tail; Q[oe] > Q[T] && Be !== null; ) {
                let je = Be.prev;
                J(Q, Be), Be = je;
              }
          }, "Se"), J = /* @__PURE__ */ __name((Q, Be) => {
            if (Be) {
              let je = Be.value;
              Q[N] && Q[N](je.key, je.value), Q[oe] -= je.length, Q[x].delete(je.key), Q[t].removeNode(Be);
            }
          }, "J"), se = /* @__PURE__ */ __name(class {
            constructor(Q, Be, je, W, B) {
              this.key = Q, this.value = Be, this.length = je, this.now = W, this.maxAge = B || 0;
            }
          }, "se"), Le = /* @__PURE__ */ __name((Q, Be, je, W) => {
            let B = je.value;
            Te(Q, B) && (J(Q, je), Q[I] || (B = void 0)), B && Be.call(W, B.value, B.key, Q);
          }, "Le");
          c.exports = F;
        } }), Za = Ur({ "node_modules/semver/classes/range.js"(a, c) {
          Jr();
          var A = /* @__PURE__ */ __name(class {
            constructor(g, O) {
              if (O = z(O), g instanceof A)
                return g.loose === !!O.loose && g.includePrerelease === !!O.includePrerelease ? g : new A(g.raw, O);
              if (g instanceof I)
                return this.raw = g.value, this.set = [[g]], this.format(), this;
              if (this.options = O, this.loose = !!O.loose, this.includePrerelease = !!O.includePrerelease, this.raw = g, this.set = g.split("||").map((S) => this.parseRange(S.trim())).filter((S) => S.length), !this.set.length)
                throw new TypeError(`Invalid SemVer Range: ${g}`);
              if (this.set.length > 1) {
                let S = this.set[0];
                if (this.set = this.set.filter((te) => !F(te[0])), this.set.length === 0)
                  this.set = [S];
                else if (this.set.length > 1) {
                  for (let te of this.set)
                    if (te.length === 1 && fe(te[0])) {
                      this.set = [te];
                      break;
                    }
                }
              }
              this.format();
            }
            format() {
              return this.range = this.set.map((g) => g.join(" ").trim()).join("||").trim(), this.range;
            }
            toString() {
              return this.range;
            }
            parseRange(g) {
              g = g.trim();
              let S = `parseRange:${Object.keys(this.options).join(",")}:${g}`, te = oe.get(S);
              if (te)
                return te;
              let Je = this.options.loose, qe = Je ? e[t.HYPHENRANGELOOSE] : e[t.HYPHENRANGE];
              g = g.replace(qe, m(this.options.includePrerelease)), E("hyphen replace", g), g = g.replace(e[t.COMPARATORTRIM], x), E("comparator trim", g), g = g.replace(e[t.TILDETRIM], s), g = g.replace(e[t.CARETTRIM], q), g = g.split(/\s+/).join(" ");
              let ge = g.split(" ").map((j) => Se(j, this.options)).join(" ").split(/\s+/).map((j) => U(j, this.options));
              Je && (ge = ge.filter((j) => (E("loose invalid filter", j, this.options), !!j.match(e[t.COMPARATORLOOSE])))), E("range list", ge);
              let ie = /* @__PURE__ */ new Map(), G = ge.map((j) => new I(j, this.options));
              for (let j of G) {
                if (F(j))
                  return [j];
                ie.set(j.value, j);
              }
              ie.size > 1 && ie.has("") && ie.delete("");
              let pe = [...ie.values()];
              return oe.set(S, pe), pe;
            }
            intersects(g, O) {
              if (!(g instanceof A))
                throw new TypeError("a Range is required");
              return this.set.some((S) => Te(S, O) && g.set.some((te) => Te(te, O) && S.every((Je) => te.every((qe) => Je.intersects(qe, O)))));
            }
            test(g) {
              if (!g)
                return false;
              if (typeof g == "string")
                try {
                  g = new N(g, this.options);
                } catch {
                  return false;
                }
              for (let O = 0; O < this.set.length; O++)
                if (v(this.set[O], g, this.options))
                  return true;
              return false;
            }
          }, "A");
          c.exports = A;
          var T = Gb(), oe = new T({ max: 1e3 }), z = Sl(), I = Dl(), E = Tl(), N = da(), { re: e, t, comparatorTrimReplace: x, tildeTrimReplace: s, caretTrimReplace: q } = Bc(), F = /* @__PURE__ */ __name((g) => g.value === "<0.0.0-0", "F"), fe = /* @__PURE__ */ __name((g) => g.value === "", "fe"), Te = /* @__PURE__ */ __name((g, O) => {
            let S = true, te = g.slice(), Je = te.pop();
            for (; S && te.length; )
              S = te.every((qe) => Je.intersects(qe, O)), Je = te.pop();
            return S;
          }, "Te"), Se = /* @__PURE__ */ __name((g, O) => (E("comp", g, O), g = Q(g, O), E("caret", g), g = se(g, O), E("tildes", g), g = je(g, O), E("xrange", g), g = B(g, O), E("stars", g), g), "Se"), J = /* @__PURE__ */ __name((g) => !g || g.toLowerCase() === "x" || g === "*", "J"), se = /* @__PURE__ */ __name((g, O) => g.trim().split(/\s+/).map((S) => Le(S, O)).join(" "), "se"), Le = /* @__PURE__ */ __name((g, O) => {
            let S = O.loose ? e[t.TILDELOOSE] : e[t.TILDE];
            return g.replace(S, (te, Je, qe, ge, ie) => {
              E("tilde", g, te, Je, qe, ge, ie);
              let G;
              return J(Je) ? G = "" : J(qe) ? G = `>=${Je}.0.0 <${+Je + 1}.0.0-0` : J(ge) ? G = `>=${Je}.${qe}.0 <${Je}.${+qe + 1}.0-0` : ie ? (E("replaceTilde pr", ie), G = `>=${Je}.${qe}.${ge}-${ie} <${Je}.${+qe + 1}.0-0`) : G = `>=${Je}.${qe}.${ge} <${Je}.${+qe + 1}.0-0`, E("tilde return", G), G;
            });
          }, "Le"), Q = /* @__PURE__ */ __name((g, O) => g.trim().split(/\s+/).map((S) => Be(S, O)).join(" "), "Q"), Be = /* @__PURE__ */ __name((g, O) => {
            E("caret", g, O);
            let S = O.loose ? e[t.CARETLOOSE] : e[t.CARET], te = O.includePrerelease ? "-0" : "";
            return g.replace(S, (Je, qe, ge, ie, G) => {
              E("caret", g, Je, qe, ge, ie, G);
              let pe;
              return J(qe) ? pe = "" : J(ge) ? pe = `>=${qe}.0.0${te} <${+qe + 1}.0.0-0` : J(ie) ? qe === "0" ? pe = `>=${qe}.${ge}.0${te} <${qe}.${+ge + 1}.0-0` : pe = `>=${qe}.${ge}.0${te} <${+qe + 1}.0.0-0` : G ? (E("replaceCaret pr", G), qe === "0" ? ge === "0" ? pe = `>=${qe}.${ge}.${ie}-${G} <${qe}.${ge}.${+ie + 1}-0` : pe = `>=${qe}.${ge}.${ie}-${G} <${qe}.${+ge + 1}.0-0` : pe = `>=${qe}.${ge}.${ie}-${G} <${+qe + 1}.0.0-0`) : (E("no pr"), qe === "0" ? ge === "0" ? pe = `>=${qe}.${ge}.${ie}${te} <${qe}.${ge}.${+ie + 1}-0` : pe = `>=${qe}.${ge}.${ie}${te} <${qe}.${+ge + 1}.0-0` : pe = `>=${qe}.${ge}.${ie} <${+qe + 1}.0.0-0`), E("caret return", pe), pe;
            });
          }, "Be"), je = /* @__PURE__ */ __name((g, O) => (E("replaceXRanges", g, O), g.split(/\s+/).map((S) => W(S, O)).join(" ")), "je"), W = /* @__PURE__ */ __name((g, O) => {
            g = g.trim();
            let S = O.loose ? e[t.XRANGELOOSE] : e[t.XRANGE];
            return g.replace(S, (te, Je, qe, ge, ie, G) => {
              E("xRange", g, te, Je, qe, ge, ie, G);
              let pe = J(qe), j = pe || J(ge), be = j || J(ie), $e = be;
              return Je === "=" && $e && (Je = ""), G = O.includePrerelease ? "-0" : "", pe ? Je === ">" || Je === "<" ? te = "<0.0.0-0" : te = "*" : Je && $e ? (j && (ge = 0), ie = 0, Je === ">" ? (Je = ">=", j ? (qe = +qe + 1, ge = 0, ie = 0) : (ge = +ge + 1, ie = 0)) : Je === "<=" && (Je = "<", j ? qe = +qe + 1 : ge = +ge + 1), Je === "<" && (G = "-0"), te = `${Je + qe}.${ge}.${ie}${G}`) : j ? te = `>=${qe}.0.0${G} <${+qe + 1}.0.0-0` : be && (te = `>=${qe}.${ge}.0${G} <${qe}.${+ge + 1}.0-0`), E("xRange return", te), te;
            });
          }, "W"), B = /* @__PURE__ */ __name((g, O) => (E("replaceStars", g, O), g.trim().replace(e[t.STAR], "")), "B"), U = /* @__PURE__ */ __name((g, O) => (E("replaceGTE0", g, O), g.trim().replace(e[O.includePrerelease ? t.GTE0PRE : t.GTE0], "")), "U"), m = /* @__PURE__ */ __name((g) => (O, S, te, Je, qe, ge, ie, G, pe, j, be, $e, Re) => (J(te) ? S = "" : J(Je) ? S = `>=${te}.0.0${g ? "-0" : ""}` : J(qe) ? S = `>=${te}.${Je}.0${g ? "-0" : ""}` : ge ? S = `>=${S}` : S = `>=${S}${g ? "-0" : ""}`, J(pe) ? G = "" : J(j) ? G = `<${+pe + 1}.0.0-0` : J(be) ? G = `<${pe}.${+j + 1}.0-0` : $e ? G = `<=${pe}.${j}.${be}-${$e}` : g ? G = `<${pe}.${j}.${+be + 1}-0` : G = `<=${G}`, `${S} ${G}`.trim()), "m"), v = /* @__PURE__ */ __name((g, O, S) => {
            for (let te = 0; te < g.length; te++)
              if (!g[te].test(O))
                return false;
            if (O.prerelease.length && !S.includePrerelease) {
              for (let te = 0; te < g.length; te++)
                if (E(g[te].semver), g[te].semver !== I.ANY && g[te].semver.prerelease.length > 0) {
                  let Je = g[te].semver;
                  if (Je.major === O.major && Je.minor === O.minor && Je.patch === O.patch)
                    return true;
                }
              return false;
            }
            return true;
          }, "v");
        } }), Dl = Ur({ "node_modules/semver/classes/comparator.js"(a, c) {
          Jr();
          var A = Symbol("SemVer ANY"), T = /* @__PURE__ */ __name(class {
            static get ANY() {
              return A;
            }
            constructor(x, s) {
              if (s = oe(s), x instanceof T) {
                if (x.loose === !!s.loose)
                  return x;
                x = x.value;
              }
              N("comparator", x, s), this.options = s, this.loose = !!s.loose, this.parse(x), this.semver === A ? this.value = "" : this.value = this.operator + this.semver.version, N("comp", this);
            }
            parse(x) {
              let s = this.options.loose ? z[I.COMPARATORLOOSE] : z[I.COMPARATOR], q = x.match(s);
              if (!q)
                throw new TypeError(`Invalid comparator: ${x}`);
              this.operator = q[1] !== void 0 ? q[1] : "", this.operator === "=" && (this.operator = ""), q[2] ? this.semver = new e(q[2], this.options.loose) : this.semver = A;
            }
            toString() {
              return this.value;
            }
            test(x) {
              if (N("Comparator.test", x, this.options.loose), this.semver === A || x === A)
                return true;
              if (typeof x == "string")
                try {
                  x = new e(x, this.options);
                } catch {
                  return false;
                }
              return E(x, this.operator, this.semver, this.options);
            }
            intersects(x, s) {
              if (!(x instanceof T))
                throw new TypeError("a Comparator is required");
              if ((!s || typeof s != "object") && (s = { loose: !!s, includePrerelease: false }), this.operator === "")
                return this.value === "" ? true : new t(x.value, s).test(this.value);
              if (x.operator === "")
                return x.value === "" ? true : new t(this.value, s).test(x.semver);
              let q = (this.operator === ">=" || this.operator === ">") && (x.operator === ">=" || x.operator === ">"), F = (this.operator === "<=" || this.operator === "<") && (x.operator === "<=" || x.operator === "<"), fe = this.semver.version === x.semver.version, Te = (this.operator === ">=" || this.operator === "<=") && (x.operator === ">=" || x.operator === "<="), Se = E(this.semver, "<", x.semver, s) && (this.operator === ">=" || this.operator === ">") && (x.operator === "<=" || x.operator === "<"), J = E(this.semver, ">", x.semver, s) && (this.operator === "<=" || this.operator === "<") && (x.operator === ">=" || x.operator === ">");
              return q || F || fe && Te || Se || J;
            }
          }, "T");
          c.exports = T;
          var oe = Sl(), { re: z, t: I } = Bc(), E = $g(), N = Tl(), e = da(), t = Za();
        } }), xl = Ur({ "node_modules/semver/functions/satisfies.js"(a, c) {
          Jr();
          var A = Za(), T = /* @__PURE__ */ __name((oe, z, I) => {
            try {
              z = new A(z, I);
            } catch {
              return false;
            }
            return z.test(oe);
          }, "T");
          c.exports = T;
        } }), Xb = Ur({ "node_modules/semver/ranges/to-comparators.js"(a, c) {
          Jr();
          var A = Za(), T = /* @__PURE__ */ __name((oe, z) => new A(oe, z).set.map((I) => I.map((E) => E.value).join(" ").trim().split(" ")), "T");
          c.exports = T;
        } }), $b = Ur({ "node_modules/semver/ranges/max-satisfying.js"(a, c) {
          Jr();
          var A = da(), T = Za(), oe = /* @__PURE__ */ __name((z, I, E) => {
            let N = null, e = null, t = null;
            try {
              t = new T(I, E);
            } catch {
              return null;
            }
            return z.forEach((x) => {
              t.test(x) && (!N || e.compare(x) === -1) && (N = x, e = new A(N, E));
            }), N;
          }, "oe");
          c.exports = oe;
        } }), Qb = Ur({ "node_modules/semver/ranges/min-satisfying.js"(a, c) {
          Jr();
          var A = da(), T = Za(), oe = /* @__PURE__ */ __name((z, I, E) => {
            let N = null, e = null, t = null;
            try {
              t = new T(I, E);
            } catch {
              return null;
            }
            return z.forEach((x) => {
              t.test(x) && (!N || e.compare(x) === 1) && (N = x, e = new A(N, E));
            }), N;
          }, "oe");
          c.exports = oe;
        } }), Yb = Ur({ "node_modules/semver/ranges/min-version.js"(a, c) {
          Jr();
          var A = da(), T = Za(), oe = Cl(), z = /* @__PURE__ */ __name((I, E) => {
            I = new T(I, E);
            let N = new A("0.0.0");
            if (I.test(N) || (N = new A("0.0.0-0"), I.test(N)))
              return N;
            N = null;
            for (let e = 0; e < I.set.length; ++e) {
              let t = I.set[e], x = null;
              t.forEach((s) => {
                let q = new A(s.semver.version);
                switch (s.operator) {
                  case ">":
                    q.prerelease.length === 0 ? q.patch++ : q.prerelease.push(0), q.raw = q.format();
                  case "":
                  case ">=":
                    (!x || oe(q, x)) && (x = q);
                    break;
                  case "<":
                  case "<=":
                    break;
                  default:
                    throw new Error(`Unexpected operation: ${s.operator}`);
                }
              }), x && (!N || oe(N, x)) && (N = x);
            }
            return N && I.test(N) ? N : null;
          }, "z");
          c.exports = z;
        } }), Zb = Ur({ "node_modules/semver/ranges/valid.js"(a, c) {
          Jr();
          var A = Za(), T = /* @__PURE__ */ __name((oe, z) => {
            try {
              return new A(oe, z).range || "*";
            } catch {
              return null;
            }
          }, "T");
          c.exports = T;
        } }), Yp = Ur({ "node_modules/semver/ranges/outside.js"(a, c) {
          Jr();
          var A = da(), T = Dl(), { ANY: oe } = T, z = Za(), I = xl(), E = Cl(), N = Xp(), e = Qp(), t = $p(), x = /* @__PURE__ */ __name((s, q, F, fe) => {
            s = new A(s, fe), q = new z(q, fe);
            let Te, Se, J, se, Le;
            switch (F) {
              case ">":
                Te = E, Se = e, J = N, se = ">", Le = ">=";
                break;
              case "<":
                Te = N, Se = t, J = E, se = "<", Le = "<=";
                break;
              default:
                throw new TypeError('Must provide a hilo val of "<" or ">"');
            }
            if (I(s, q, fe))
              return false;
            for (let Q = 0; Q < q.set.length; ++Q) {
              let Be = q.set[Q], je = null, W = null;
              if (Be.forEach((B) => {
                B.semver === oe && (B = new T(">=0.0.0")), je = je || B, W = W || B, Te(B.semver, je.semver, fe) ? je = B : J(B.semver, W.semver, fe) && (W = B);
              }), je.operator === se || je.operator === Le || (!W.operator || W.operator === se) && Se(s, W.semver))
                return false;
              if (W.operator === Le && J(s, W.semver))
                return false;
            }
            return true;
          }, "x");
          c.exports = x;
        } }), eE = Ur({ "node_modules/semver/ranges/gtr.js"(a, c) {
          Jr();
          var A = Yp(), T = /* @__PURE__ */ __name((oe, z, I) => A(oe, z, ">", I), "T");
          c.exports = T;
        } }), rE = Ur({ "node_modules/semver/ranges/ltr.js"(a, c) {
          Jr();
          var A = Yp(), T = /* @__PURE__ */ __name((oe, z, I) => A(oe, z, "<", I), "T");
          c.exports = T;
        } }), tE = Ur({ "node_modules/semver/ranges/intersects.js"(a, c) {
          Jr();
          var A = Za(), T = /* @__PURE__ */ __name((oe, z, I) => (oe = new A(oe, I), z = new A(z, I), oe.intersects(z)), "T");
          c.exports = T;
        } }), nE = Ur({ "node_modules/semver/ranges/simplify.js"(a, c) {
          Jr();
          var A = xl(), T = Ya();
          c.exports = (oe, z, I) => {
            let E = [], N = null, e = null, t = oe.sort((F, fe) => T(F, fe, I));
            for (let F of t)
              A(F, z, I) ? (e = F, N || (N = F)) : (e && E.push([N, e]), e = null, N = null);
            N && E.push([N, null]);
            let x = [];
            for (let [F, fe] of E)
              F === fe ? x.push(F) : !fe && F === t[0] ? x.push("*") : fe ? F === t[0] ? x.push(`<=${fe}`) : x.push(`${F} - ${fe}`) : x.push(`>=${F}`);
            let s = x.join(" || "), q = typeof z.raw == "string" ? z.raw : String(z);
            return s.length < q.length ? s : z;
          };
        } }), iE = Ur({ "node_modules/semver/ranges/subset.js"(a, c) {
          Jr();
          var A = Za(), T = Dl(), { ANY: oe } = T, z = xl(), I = Ya(), E = /* @__PURE__ */ __name(function(x, s) {
            let q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (x === s)
              return true;
            x = new A(x, q), s = new A(s, q);
            let F = false;
            e:
              for (let fe of x.set) {
                for (let Te of s.set) {
                  let Se = N(fe, Te, q);
                  if (F = F || Se !== null, Se)
                    continue e;
                }
                if (F)
                  return false;
              }
            return true;
          }, "E"), N = /* @__PURE__ */ __name((x, s, q) => {
            if (x === s)
              return true;
            if (x.length === 1 && x[0].semver === oe) {
              if (s.length === 1 && s[0].semver === oe)
                return true;
              q.includePrerelease ? x = [new T(">=0.0.0-0")] : x = [new T(">=0.0.0")];
            }
            if (s.length === 1 && s[0].semver === oe) {
              if (q.includePrerelease)
                return true;
              s = [new T(">=0.0.0")];
            }
            let F = /* @__PURE__ */ new Set(), fe, Te;
            for (let W of x)
              W.operator === ">" || W.operator === ">=" ? fe = e(fe, W, q) : W.operator === "<" || W.operator === "<=" ? Te = t(Te, W, q) : F.add(W.semver);
            if (F.size > 1)
              return null;
            let Se;
            if (fe && Te) {
              if (Se = I(fe.semver, Te.semver, q), Se > 0)
                return null;
              if (Se === 0 && (fe.operator !== ">=" || Te.operator !== "<="))
                return null;
            }
            for (let W of F) {
              if (fe && !z(W, String(fe), q) || Te && !z(W, String(Te), q))
                return null;
              for (let B of s)
                if (!z(W, String(B), q))
                  return false;
              return true;
            }
            let J, se, Le, Q, Be = Te && !q.includePrerelease && Te.semver.prerelease.length ? Te.semver : false, je = fe && !q.includePrerelease && fe.semver.prerelease.length ? fe.semver : false;
            Be && Be.prerelease.length === 1 && Te.operator === "<" && Be.prerelease[0] === 0 && (Be = false);
            for (let W of s) {
              if (Q = Q || W.operator === ">" || W.operator === ">=", Le = Le || W.operator === "<" || W.operator === "<=", fe) {
                if (je && W.semver.prerelease && W.semver.prerelease.length && W.semver.major === je.major && W.semver.minor === je.minor && W.semver.patch === je.patch && (je = false), W.operator === ">" || W.operator === ">=") {
                  if (J = e(fe, W, q), J === W && J !== fe)
                    return false;
                } else if (fe.operator === ">=" && !z(fe.semver, String(W), q))
                  return false;
              }
              if (Te) {
                if (Be && W.semver.prerelease && W.semver.prerelease.length && W.semver.major === Be.major && W.semver.minor === Be.minor && W.semver.patch === Be.patch && (Be = false), W.operator === "<" || W.operator === "<=") {
                  if (se = t(Te, W, q), se === W && se !== Te)
                    return false;
                } else if (Te.operator === "<=" && !z(Te.semver, String(W), q))
                  return false;
              }
              if (!W.operator && (Te || fe) && Se !== 0)
                return false;
            }
            return !(fe && Le && !Te && Se !== 0 || Te && Q && !fe && Se !== 0 || je || Be);
          }, "N"), e = /* @__PURE__ */ __name((x, s, q) => {
            if (!x)
              return s;
            let F = I(x.semver, s.semver, q);
            return F > 0 ? x : F < 0 || s.operator === ">" && x.operator === ">=" ? s : x;
          }, "e"), t = /* @__PURE__ */ __name((x, s, q) => {
            if (!x)
              return s;
            let F = I(x.semver, s.semver, q);
            return F < 0 ? x : F > 0 || s.operator === "<" && x.operator === "<=" ? s : x;
          }, "t");
          c.exports = E;
        } }), Zp = Ur({ "node_modules/semver/index.js"(a, c) {
          Jr();
          var A = Bc();
          c.exports = { re: A.re, src: A.src, tokens: A.t, SEMVER_SPEC_VERSION: El().SEMVER_SPEC_VERSION, SemVer: da(), compareIdentifiers: qp().compareIdentifiers, rcompareIdentifiers: qp().rcompareIdentifiers, parse: qc(), valid: Ob(), clean: Mb(), inc: Lb(), diff: Rb(), major: jb(), minor: Jb(), patch: Fb(), prerelease: Bb(), compare: Ya(), rcompare: qb(), compareLoose: Ub(), compareBuild: Gp(), sort: zb(), rsort: Vb(), gt: Cl(), lt: Xp(), eq: Hp(), neq: Xg(), gte: $p(), lte: Qp(), cmp: $g(), coerce: Wb(), Comparator: Dl(), Range: Za(), satisfies: xl(), toComparators: Xb(), maxSatisfying: $b(), minSatisfying: Qb(), minVersion: Yb(), validRange: Zb(), outside: Yp(), gtr: eE(), ltr: rE(), intersects: tE(), simplifyRange: nE(), subset: iE() };
        } }), ef = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/version-check.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(N, e, t, x) {
            x === void 0 && (x = t);
            var s = Object.getOwnPropertyDescriptor(e, t);
            (!s || ("get" in s ? !e.__esModule : s.writable || s.configurable)) && (s = { enumerable: true, get: function() {
              return e[t];
            } }), Object.defineProperty(N, x, s);
          } : function(N, e, t, x) {
            x === void 0 && (x = t), N[x] = e[t];
          }), A = a && a.__setModuleDefault || (Object.create ? function(N, e) {
            Object.defineProperty(N, "default", { enumerable: true, value: e });
          } : function(N, e) {
            N.default = e;
          }), T = a && a.__importStar || function(N) {
            if (N && N.__esModule)
              return N;
            var e = {};
            if (N != null)
              for (var t in N)
                t !== "default" && Object.prototype.hasOwnProperty.call(N, t) && c(e, N, t);
            return A(e, N), e;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.typescriptVersionIsAtLeast = void 0;
          var oe = T(Zp()), z = T(xi()), I = ["3.7", "3.8", "3.9", "4.0", "4.1", "4.2", "4.3", "4.4", "4.5", "4.6", "4.7", "4.8"], E = {};
          a.typescriptVersionIsAtLeast = E;
          for (let N of I)
            E[N] = true;
        } }), rf = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/getModifiers.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(e, t, x, s) {
            s === void 0 && (s = x);
            var q = Object.getOwnPropertyDescriptor(t, x);
            (!q || ("get" in q ? !t.__esModule : q.writable || q.configurable)) && (q = { enumerable: true, get: function() {
              return t[x];
            } }), Object.defineProperty(e, s, q);
          } : function(e, t, x, s) {
            s === void 0 && (s = x), e[s] = t[x];
          }), A = a && a.__setModuleDefault || (Object.create ? function(e, t) {
            Object.defineProperty(e, "default", { enumerable: true, value: t });
          } : function(e, t) {
            e.default = t;
          }), T = a && a.__importStar || function(e) {
            if (e && e.__esModule)
              return e;
            var t = {};
            if (e != null)
              for (var x in e)
                x !== "default" && Object.prototype.hasOwnProperty.call(e, x) && c(t, e, x);
            return A(t, e), t;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.getDecorators = a.getModifiers = void 0;
          var oe = T(xi()), z = ef(), I = z.typescriptVersionIsAtLeast["4.8"];
          function E(e) {
            var t;
            if (e != null) {
              if (I) {
                if (oe.canHaveModifiers(e)) {
                  let x = oe.getModifiers(e);
                  return x ? Array.from(x) : void 0;
                }
                return;
              }
              return (t = e.modifiers) === null || t === void 0 ? void 0 : t.filter((x) => !oe.isDecorator(x));
            }
          }
          __name(E, "E");
          a.getModifiers = E;
          function N(e) {
            var t;
            if (e != null) {
              if (I) {
                if (oe.canHaveDecorators(e)) {
                  let x = oe.getDecorators(e);
                  return x ? Array.from(x) : void 0;
                }
                return;
              }
              return (t = e.decorators) === null || t === void 0 ? void 0 : t.filter(oe.isDecorator);
            }
          }
          __name(N, "N");
          a.getDecorators = N;
        } }), aE = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/jsx/xhtml-entities.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.xhtmlEntities = void 0, a.xhtmlEntities = { quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" };
        } }), Qg = Ur({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/types/dist/generated/ast-spec.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.AST_TOKEN_TYPES = a.AST_NODE_TYPES = void 0;
          var c;
          (function(T) {
            T.AccessorProperty = "AccessorProperty", T.ArrayExpression = "ArrayExpression", T.ArrayPattern = "ArrayPattern", T.ArrowFunctionExpression = "ArrowFunctionExpression", T.AssignmentExpression = "AssignmentExpression", T.AssignmentPattern = "AssignmentPattern", T.AwaitExpression = "AwaitExpression", T.BinaryExpression = "BinaryExpression", T.BlockStatement = "BlockStatement", T.BreakStatement = "BreakStatement", T.CallExpression = "CallExpression", T.CatchClause = "CatchClause", T.ChainExpression = "ChainExpression", T.ClassBody = "ClassBody", T.ClassDeclaration = "ClassDeclaration", T.ClassExpression = "ClassExpression", T.ConditionalExpression = "ConditionalExpression", T.ContinueStatement = "ContinueStatement", T.DebuggerStatement = "DebuggerStatement", T.Decorator = "Decorator", T.DoWhileStatement = "DoWhileStatement", T.EmptyStatement = "EmptyStatement", T.ExportAllDeclaration = "ExportAllDeclaration", T.ExportDefaultDeclaration = "ExportDefaultDeclaration", T.ExportNamedDeclaration = "ExportNamedDeclaration", T.ExportSpecifier = "ExportSpecifier", T.ExpressionStatement = "ExpressionStatement", T.ForInStatement = "ForInStatement", T.ForOfStatement = "ForOfStatement", T.ForStatement = "ForStatement", T.FunctionDeclaration = "FunctionDeclaration", T.FunctionExpression = "FunctionExpression", T.Identifier = "Identifier", T.IfStatement = "IfStatement", T.ImportAttribute = "ImportAttribute", T.ImportDeclaration = "ImportDeclaration", T.ImportDefaultSpecifier = "ImportDefaultSpecifier", T.ImportExpression = "ImportExpression", T.ImportNamespaceSpecifier = "ImportNamespaceSpecifier", T.ImportSpecifier = "ImportSpecifier", T.JSXAttribute = "JSXAttribute", T.JSXClosingElement = "JSXClosingElement", T.JSXClosingFragment = "JSXClosingFragment", T.JSXElement = "JSXElement", T.JSXEmptyExpression = "JSXEmptyExpression", T.JSXExpressionContainer = "JSXExpressionContainer", T.JSXFragment = "JSXFragment", T.JSXIdentifier = "JSXIdentifier", T.JSXMemberExpression = "JSXMemberExpression", T.JSXNamespacedName = "JSXNamespacedName", T.JSXOpeningElement = "JSXOpeningElement", T.JSXOpeningFragment = "JSXOpeningFragment", T.JSXSpreadAttribute = "JSXSpreadAttribute", T.JSXSpreadChild = "JSXSpreadChild", T.JSXText = "JSXText", T.LabeledStatement = "LabeledStatement", T.Literal = "Literal", T.LogicalExpression = "LogicalExpression", T.MemberExpression = "MemberExpression", T.MetaProperty = "MetaProperty", T.MethodDefinition = "MethodDefinition", T.NewExpression = "NewExpression", T.ObjectExpression = "ObjectExpression", T.ObjectPattern = "ObjectPattern", T.PrivateIdentifier = "PrivateIdentifier", T.Program = "Program", T.Property = "Property", T.PropertyDefinition = "PropertyDefinition", T.RestElement = "RestElement", T.ReturnStatement = "ReturnStatement", T.SequenceExpression = "SequenceExpression", T.SpreadElement = "SpreadElement", T.StaticBlock = "StaticBlock", T.Super = "Super", T.SwitchCase = "SwitchCase", T.SwitchStatement = "SwitchStatement", T.TaggedTemplateExpression = "TaggedTemplateExpression", T.TemplateElement = "TemplateElement", T.TemplateLiteral = "TemplateLiteral", T.ThisExpression = "ThisExpression", T.ThrowStatement = "ThrowStatement", T.TryStatement = "TryStatement", T.UnaryExpression = "UnaryExpression", T.UpdateExpression = "UpdateExpression", T.VariableDeclaration = "VariableDeclaration", T.VariableDeclarator = "VariableDeclarator", T.WhileStatement = "WhileStatement", T.WithStatement = "WithStatement", T.YieldExpression = "YieldExpression", T.TSAbstractAccessorProperty = "TSAbstractAccessorProperty", T.TSAbstractKeyword = "TSAbstractKeyword", T.TSAbstractMethodDefinition = "TSAbstractMethodDefinition", T.TSAbstractPropertyDefinition = "TSAbstractPropertyDefinition", T.TSAnyKeyword = "TSAnyKeyword", T.TSArrayType = "TSArrayType", T.TSAsExpression = "TSAsExpression", T.TSAsyncKeyword = "TSAsyncKeyword", T.TSBigIntKeyword = "TSBigIntKeyword", T.TSBooleanKeyword = "TSBooleanKeyword", T.TSCallSignatureDeclaration = "TSCallSignatureDeclaration", T.TSClassImplements = "TSClassImplements", T.TSConditionalType = "TSConditionalType", T.TSConstructorType = "TSConstructorType", T.TSConstructSignatureDeclaration = "TSConstructSignatureDeclaration", T.TSDeclareFunction = "TSDeclareFunction", T.TSDeclareKeyword = "TSDeclareKeyword", T.TSEmptyBodyFunctionExpression = "TSEmptyBodyFunctionExpression", T.TSEnumDeclaration = "TSEnumDeclaration", T.TSEnumMember = "TSEnumMember", T.TSExportAssignment = "TSExportAssignment", T.TSExportKeyword = "TSExportKeyword", T.TSExternalModuleReference = "TSExternalModuleReference", T.TSFunctionType = "TSFunctionType", T.TSInstantiationExpression = "TSInstantiationExpression", T.TSImportEqualsDeclaration = "TSImportEqualsDeclaration", T.TSImportType = "TSImportType", T.TSIndexedAccessType = "TSIndexedAccessType", T.TSIndexSignature = "TSIndexSignature", T.TSInferType = "TSInferType", T.TSInterfaceBody = "TSInterfaceBody", T.TSInterfaceDeclaration = "TSInterfaceDeclaration", T.TSInterfaceHeritage = "TSInterfaceHeritage", T.TSIntersectionType = "TSIntersectionType", T.TSIntrinsicKeyword = "TSIntrinsicKeyword", T.TSLiteralType = "TSLiteralType", T.TSMappedType = "TSMappedType", T.TSMethodSignature = "TSMethodSignature", T.TSModuleBlock = "TSModuleBlock", T.TSModuleDeclaration = "TSModuleDeclaration", T.TSNamedTupleMember = "TSNamedTupleMember", T.TSNamespaceExportDeclaration = "TSNamespaceExportDeclaration", T.TSNeverKeyword = "TSNeverKeyword", T.TSNonNullExpression = "TSNonNullExpression", T.TSNullKeyword = "TSNullKeyword", T.TSNumberKeyword = "TSNumberKeyword", T.TSObjectKeyword = "TSObjectKeyword", T.TSOptionalType = "TSOptionalType", T.TSParameterProperty = "TSParameterProperty", T.TSPrivateKeyword = "TSPrivateKeyword", T.TSPropertySignature = "TSPropertySignature", T.TSProtectedKeyword = "TSProtectedKeyword", T.TSPublicKeyword = "TSPublicKeyword", T.TSQualifiedName = "TSQualifiedName", T.TSReadonlyKeyword = "TSReadonlyKeyword", T.TSRestType = "TSRestType", T.TSSatisfiesExpression = "TSSatisfiesExpression", T.TSStaticKeyword = "TSStaticKeyword", T.TSStringKeyword = "TSStringKeyword", T.TSSymbolKeyword = "TSSymbolKeyword", T.TSTemplateLiteralType = "TSTemplateLiteralType", T.TSThisType = "TSThisType", T.TSTupleType = "TSTupleType", T.TSTypeAliasDeclaration = "TSTypeAliasDeclaration", T.TSTypeAnnotation = "TSTypeAnnotation", T.TSTypeAssertion = "TSTypeAssertion", T.TSTypeLiteral = "TSTypeLiteral", T.TSTypeOperator = "TSTypeOperator", T.TSTypeParameter = "TSTypeParameter", T.TSTypeParameterDeclaration = "TSTypeParameterDeclaration", T.TSTypeParameterInstantiation = "TSTypeParameterInstantiation", T.TSTypePredicate = "TSTypePredicate", T.TSTypeQuery = "TSTypeQuery", T.TSTypeReference = "TSTypeReference", T.TSUndefinedKeyword = "TSUndefinedKeyword", T.TSUnionType = "TSUnionType", T.TSUnknownKeyword = "TSUnknownKeyword", T.TSVoidKeyword = "TSVoidKeyword";
          })(c = a.AST_NODE_TYPES || (a.AST_NODE_TYPES = {}));
          var A;
          (function(T) {
            T.Boolean = "Boolean", T.Identifier = "Identifier", T.JSXIdentifier = "JSXIdentifier", T.JSXText = "JSXText", T.Keyword = "Keyword", T.Null = "Null", T.Numeric = "Numeric", T.Punctuator = "Punctuator", T.RegularExpression = "RegularExpression", T.String = "String", T.Template = "Template", T.Block = "Block", T.Line = "Line";
          })(A = a.AST_TOKEN_TYPES || (a.AST_TOKEN_TYPES = {}));
        } }), oE = Ur({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/types/dist/lib.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true });
        } }), sE = Ur({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/types/dist/parser-options.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true });
        } }), _E = Ur({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/types/dist/ts-estree.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(oe, z, I, E) {
            E === void 0 && (E = I);
            var N = Object.getOwnPropertyDescriptor(z, I);
            (!N || ("get" in N ? !z.__esModule : N.writable || N.configurable)) && (N = { enumerable: true, get: function() {
              return z[I];
            } }), Object.defineProperty(oe, E, N);
          } : function(oe, z, I, E) {
            E === void 0 && (E = I), oe[E] = z[I];
          }), A = a && a.__setModuleDefault || (Object.create ? function(oe, z) {
            Object.defineProperty(oe, "default", { enumerable: true, value: z });
          } : function(oe, z) {
            oe.default = z;
          }), T = a && a.__importStar || function(oe) {
            if (oe && oe.__esModule)
              return oe;
            var z = {};
            if (oe != null)
              for (var I in oe)
                I !== "default" && Object.prototype.hasOwnProperty.call(oe, I) && c(z, oe, I);
            return A(z, oe), z;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.TSESTree = void 0, a.TSESTree = T(Qg());
        } }), cE = Ur({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/types/dist/index.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(oe, z, I, E) {
            E === void 0 && (E = I);
            var N = Object.getOwnPropertyDescriptor(z, I);
            (!N || ("get" in N ? !z.__esModule : N.writable || N.configurable)) && (N = { enumerable: true, get: function() {
              return z[I];
            } }), Object.defineProperty(oe, E, N);
          } : function(oe, z, I, E) {
            E === void 0 && (E = I), oe[E] = z[I];
          }), A = a && a.__exportStar || function(oe, z) {
            for (var I in oe)
              I !== "default" && !Object.prototype.hasOwnProperty.call(z, I) && c(z, oe, I);
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.AST_TOKEN_TYPES = a.AST_NODE_TYPES = void 0;
          var T = Qg();
          Object.defineProperty(a, "AST_NODE_TYPES", { enumerable: true, get: function() {
            return T.AST_NODE_TYPES;
          } }), Object.defineProperty(a, "AST_TOKEN_TYPES", { enumerable: true, get: function() {
            return T.AST_TOKEN_TYPES;
          } }), A(oE(), a), A(sE(), a), A(_E(), a);
        } }), uE = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/ts-estree/ts-nodes.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true });
        } }), lE = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/ts-estree/estree-to-ts-node-types.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true });
        } }), wl = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/ts-estree/index.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(oe, z, I, E) {
            E === void 0 && (E = I);
            var N = Object.getOwnPropertyDescriptor(z, I);
            (!N || ("get" in N ? !z.__esModule : N.writable || N.configurable)) && (N = { enumerable: true, get: function() {
              return z[I];
            } }), Object.defineProperty(oe, E, N);
          } : function(oe, z, I, E) {
            E === void 0 && (E = I), oe[E] = z[I];
          }), A = a && a.__exportStar || function(oe, z) {
            for (var I in oe)
              I !== "default" && !Object.prototype.hasOwnProperty.call(z, I) && c(z, oe, I);
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.TSESTree = a.AST_TOKEN_TYPES = a.AST_NODE_TYPES = void 0;
          var T = cE();
          Object.defineProperty(a, "AST_NODE_TYPES", { enumerable: true, get: function() {
            return T.AST_NODE_TYPES;
          } }), Object.defineProperty(a, "AST_TOKEN_TYPES", { enumerable: true, get: function() {
            return T.AST_TOKEN_TYPES;
          } }), Object.defineProperty(a, "TSESTree", { enumerable: true, get: function() {
            return T.TSESTree;
          } }), A(uE(), a), A(lE(), a);
        } }), Al = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/node-utils.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(ve, er, ar, Cr) {
            Cr === void 0 && (Cr = ar);
            var Ce = Object.getOwnPropertyDescriptor(er, ar);
            (!Ce || ("get" in Ce ? !er.__esModule : Ce.writable || Ce.configurable)) && (Ce = { enumerable: true, get: function() {
              return er[ar];
            } }), Object.defineProperty(ve, Cr, Ce);
          } : function(ve, er, ar, Cr) {
            Cr === void 0 && (Cr = ar), ve[Cr] = er[ar];
          }), A = a && a.__setModuleDefault || (Object.create ? function(ve, er) {
            Object.defineProperty(ve, "default", { enumerable: true, value: er });
          } : function(ve, er) {
            ve.default = er;
          }), T = a && a.__importStar || function(ve) {
            if (ve && ve.__esModule)
              return ve;
            var er = {};
            if (ve != null)
              for (var ar in ve)
                ar !== "default" && Object.prototype.hasOwnProperty.call(ve, ar) && c(er, ve, ar);
            return A(er, ve), er;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.isThisInTypeQuery = a.isThisIdentifier = a.identifierIsThisKeyword = a.firstDefined = a.nodeHasTokens = a.createError = a.TSError = a.convertTokens = a.convertToken = a.getTokenType = a.isChildUnwrappableOptionalChain = a.isChainExpression = a.isOptional = a.isComputedProperty = a.unescapeStringLiteralText = a.hasJSXAncestor = a.findFirstMatchingAncestor = a.findNextToken = a.getTSNodeAccessibility = a.getDeclarationKind = a.isJSXToken = a.isToken = a.getRange = a.canContainDirective = a.getLocFor = a.getLineAndCharacterFor = a.getBinaryExpressionType = a.isJSDocComment = a.isComment = a.isComma = a.getLastModifier = a.hasModifier = a.isESTreeClassMember = a.getTextForTokenKind = a.isLogicalOperator = a.isAssignmentOperator = void 0;
          var oe = T(xi()), z = rf(), I = aE(), E = wl(), N = oe.SyntaxKind, e = [N.BarBarToken, N.AmpersandAmpersandToken, N.QuestionQuestionToken];
          function t(ve) {
            return ve.kind >= N.FirstAssignment && ve.kind <= N.LastAssignment;
          }
          __name(t, "t");
          a.isAssignmentOperator = t;
          function x(ve) {
            return e.includes(ve.kind);
          }
          __name(x, "x");
          a.isLogicalOperator = x;
          function s(ve) {
            return oe.tokenToString(ve);
          }
          __name(s, "s");
          a.getTextForTokenKind = s;
          function q(ve) {
            return ve.kind !== N.SemicolonClassElement;
          }
          __name(q, "q");
          a.isESTreeClassMember = q;
          function F(ve, er) {
            let ar = (0, z.getModifiers)(er);
            return (ar == null ? void 0 : ar.some((Cr) => Cr.kind === ve)) === true;
          }
          __name(F, "F");
          a.hasModifier = F;
          function fe(ve) {
            var er;
            let ar = (0, z.getModifiers)(ve);
            return ar == null ? null : (er = ar[ar.length - 1]) !== null && er !== void 0 ? er : null;
          }
          __name(fe, "fe");
          a.getLastModifier = fe;
          function Te(ve) {
            return ve.kind === N.CommaToken;
          }
          __name(Te, "Te");
          a.isComma = Te;
          function Se(ve) {
            return ve.kind === N.SingleLineCommentTrivia || ve.kind === N.MultiLineCommentTrivia;
          }
          __name(Se, "Se");
          a.isComment = Se;
          function J(ve) {
            return ve.kind === N.JSDocComment;
          }
          __name(J, "J");
          a.isJSDocComment = J;
          function se(ve) {
            return t(ve) ? E.AST_NODE_TYPES.AssignmentExpression : x(ve) ? E.AST_NODE_TYPES.LogicalExpression : E.AST_NODE_TYPES.BinaryExpression;
          }
          __name(se, "se");
          a.getBinaryExpressionType = se;
          function Le(ve, er) {
            let ar = er.getLineAndCharacterOfPosition(ve);
            return { line: ar.line + 1, column: ar.character };
          }
          __name(Le, "Le");
          a.getLineAndCharacterFor = Le;
          function Q(ve, er, ar) {
            return { start: Le(ve, ar), end: Le(er, ar) };
          }
          __name(Q, "Q");
          a.getLocFor = Q;
          function Be(ve) {
            if (ve.kind === oe.SyntaxKind.Block)
              switch (ve.parent.kind) {
                case oe.SyntaxKind.Constructor:
                case oe.SyntaxKind.GetAccessor:
                case oe.SyntaxKind.SetAccessor:
                case oe.SyntaxKind.ArrowFunction:
                case oe.SyntaxKind.FunctionExpression:
                case oe.SyntaxKind.FunctionDeclaration:
                case oe.SyntaxKind.MethodDeclaration:
                  return true;
                default:
                  return false;
              }
            return true;
          }
          __name(Be, "Be");
          a.canContainDirective = Be;
          function je(ve, er) {
            return [ve.getStart(er), ve.getEnd()];
          }
          __name(je, "je");
          a.getRange = je;
          function W(ve) {
            return ve.kind >= N.FirstToken && ve.kind <= N.LastToken;
          }
          __name(W, "W");
          a.isToken = W;
          function B(ve) {
            return ve.kind >= N.JsxElement && ve.kind <= N.JsxAttribute;
          }
          __name(B, "B");
          a.isJSXToken = B;
          function U(ve) {
            return ve.flags & oe.NodeFlags.Let ? "let" : ve.flags & oe.NodeFlags.Const ? "const" : "var";
          }
          __name(U, "U");
          a.getDeclarationKind = U;
          function m(ve) {
            let er = (0, z.getModifiers)(ve);
            if (er == null)
              return null;
            for (let ar of er)
              switch (ar.kind) {
                case N.PublicKeyword:
                  return "public";
                case N.ProtectedKeyword:
                  return "protected";
                case N.PrivateKeyword:
                  return "private";
                default:
                  break;
              }
            return null;
          }
          __name(m, "m");
          a.getTSNodeAccessibility = m;
          function v(ve, er, ar) {
            return Cr(er);
            function Cr(Ce) {
              return oe.isToken(Ce) && Ce.pos === ve.end ? Ce : Re(Ce.getChildren(ar), (Xe) => (Xe.pos <= ve.pos && Xe.end > ve.end || Xe.pos === ve.end) && $e(Xe, ar) ? Cr(Xe) : void 0);
            }
            __name(Cr, "Cr");
          }
          __name(v, "v");
          a.findNextToken = v;
          function g(ve, er) {
            for (; ve; ) {
              if (er(ve))
                return ve;
              ve = ve.parent;
            }
          }
          __name(g, "g");
          a.findFirstMatchingAncestor = g;
          function O(ve) {
            return !!g(ve, B);
          }
          __name(O, "O");
          a.hasJSXAncestor = O;
          function S(ve) {
            return ve.replace(/&(?:#\d+|#x[\da-fA-F]+|[0-9a-zA-Z]+);/g, (er) => {
              let ar = er.slice(1, -1);
              if (ar[0] === "#") {
                let Cr = ar[1] === "x" ? parseInt(ar.slice(2), 16) : parseInt(ar.slice(1), 10);
                return Cr > 1114111 ? er : String.fromCodePoint(Cr);
              }
              return I.xhtmlEntities[ar] || er;
            });
          }
          __name(S, "S");
          a.unescapeStringLiteralText = S;
          function te(ve) {
            return ve.kind === N.ComputedPropertyName;
          }
          __name(te, "te");
          a.isComputedProperty = te;
          function Je(ve) {
            return ve.questionToken ? ve.questionToken.kind === N.QuestionToken : false;
          }
          __name(Je, "Je");
          a.isOptional = Je;
          function qe(ve) {
            return ve.type === E.AST_NODE_TYPES.ChainExpression;
          }
          __name(qe, "qe");
          a.isChainExpression = qe;
          function ge(ve, er) {
            return qe(er) && ve.expression.kind !== oe.SyntaxKind.ParenthesizedExpression;
          }
          __name(ge, "ge");
          a.isChildUnwrappableOptionalChain = ge;
          function ie(ve) {
            if ("originalKeywordKind" in ve && ve.originalKeywordKind)
              return ve.originalKeywordKind === N.NullKeyword ? E.AST_TOKEN_TYPES.Null : ve.originalKeywordKind >= N.FirstFutureReservedWord && ve.originalKeywordKind <= N.LastKeyword ? E.AST_TOKEN_TYPES.Identifier : E.AST_TOKEN_TYPES.Keyword;
            if (ve.kind >= N.FirstKeyword && ve.kind <= N.LastFutureReservedWord)
              return ve.kind === N.FalseKeyword || ve.kind === N.TrueKeyword ? E.AST_TOKEN_TYPES.Boolean : E.AST_TOKEN_TYPES.Keyword;
            if (ve.kind >= N.FirstPunctuation && ve.kind <= N.LastPunctuation)
              return E.AST_TOKEN_TYPES.Punctuator;
            if (ve.kind >= N.NoSubstitutionTemplateLiteral && ve.kind <= N.TemplateTail)
              return E.AST_TOKEN_TYPES.Template;
            switch (ve.kind) {
              case N.NumericLiteral:
                return E.AST_TOKEN_TYPES.Numeric;
              case N.JsxText:
                return E.AST_TOKEN_TYPES.JSXText;
              case N.StringLiteral:
                return ve.parent && (ve.parent.kind === N.JsxAttribute || ve.parent.kind === N.JsxElement) ? E.AST_TOKEN_TYPES.JSXText : E.AST_TOKEN_TYPES.String;
              case N.RegularExpressionLiteral:
                return E.AST_TOKEN_TYPES.RegularExpression;
              case N.Identifier:
              case N.ConstructorKeyword:
              case N.GetKeyword:
              case N.SetKeyword:
              default:
            }
            return ve.parent && ve.kind === N.Identifier && (B(ve.parent) || ve.parent.kind === N.PropertyAccessExpression && O(ve)) ? E.AST_TOKEN_TYPES.JSXIdentifier : E.AST_TOKEN_TYPES.Identifier;
          }
          __name(ie, "ie");
          a.getTokenType = ie;
          function G(ve, er) {
            let ar = ve.kind === N.JsxText ? ve.getFullStart() : ve.getStart(er), Cr = ve.getEnd(), Ce = er.text.slice(ar, Cr), Xe = ie(ve);
            return Xe === E.AST_TOKEN_TYPES.RegularExpression ? { type: Xe, value: Ce, range: [ar, Cr], loc: Q(ar, Cr, er), regex: { pattern: Ce.slice(1, Ce.lastIndexOf("/")), flags: Ce.slice(Ce.lastIndexOf("/") + 1) } } : { type: Xe, value: Ce, range: [ar, Cr], loc: Q(ar, Cr, er) };
          }
          __name(G, "G");
          a.convertToken = G;
          function pe(ve) {
            let er = [];
            function ar(Cr) {
              if (!(Se(Cr) || J(Cr)))
                if (W(Cr) && Cr.kind !== N.EndOfFileToken) {
                  let Ce = G(Cr, ve);
                  Ce && er.push(Ce);
                } else
                  Cr.getChildren(ve).forEach(ar);
            }
            __name(ar, "ar");
            return ar(ve), er;
          }
          __name(pe, "pe");
          a.convertTokens = pe;
          var j = /* @__PURE__ */ __name(class extends Error {
            constructor(ve, er, ar, Cr, Ce) {
              super(ve), this.fileName = er, this.index = ar, this.lineNumber = Cr, this.column = Ce, Object.defineProperty(this, "name", { value: new.target.name, enumerable: false, configurable: true });
            }
          }, "j");
          a.TSError = j;
          function be(ve, er, ar) {
            let Cr = ve.getLineAndCharacterOfPosition(er);
            return new j(ar, ve.fileName, er, Cr.line + 1, Cr.character);
          }
          __name(be, "be");
          a.createError = be;
          function $e(ve, er) {
            return ve.kind === N.EndOfFileToken ? !!ve.jsDoc : ve.getWidth(er) !== 0;
          }
          __name($e, "$e");
          a.nodeHasTokens = $e;
          function Re(ve, er) {
            if (ve !== void 0)
              for (let ar = 0; ar < ve.length; ar++) {
                let Cr = er(ve[ar], ar);
                if (Cr !== void 0)
                  return Cr;
              }
          }
          __name(Re, "Re");
          a.firstDefined = Re;
          function Fe(ve) {
            return ve.originalKeywordKind === N.ThisKeyword;
          }
          __name(Fe, "Fe");
          a.identifierIsThisKeyword = Fe;
          function dr(ve) {
            return !!ve && ve.kind === N.Identifier && Fe(ve);
          }
          __name(dr, "dr");
          a.isThisIdentifier = dr;
          function ze(ve) {
            if (!dr(ve))
              return false;
            for (; oe.isQualifiedName(ve.parent) && ve.parent.left === ve; )
              ve = ve.parent;
            return ve.parent.kind === N.TypeQuery;
          }
          __name(ze, "ze");
          a.isThisInTypeQuery = ze;
        } }), Yg = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/convert.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(s, q, F, fe) {
            fe === void 0 && (fe = F);
            var Te = Object.getOwnPropertyDescriptor(q, F);
            (!Te || ("get" in Te ? !q.__esModule : Te.writable || Te.configurable)) && (Te = { enumerable: true, get: function() {
              return q[F];
            } }), Object.defineProperty(s, fe, Te);
          } : function(s, q, F, fe) {
            fe === void 0 && (fe = F), s[fe] = q[F];
          }), A = a && a.__setModuleDefault || (Object.create ? function(s, q) {
            Object.defineProperty(s, "default", { enumerable: true, value: q });
          } : function(s, q) {
            s.default = q;
          }), T = a && a.__importStar || function(s) {
            if (s && s.__esModule)
              return s;
            var q = {};
            if (s != null)
              for (var F in s)
                F !== "default" && Object.prototype.hasOwnProperty.call(s, F) && c(q, s, F);
            return A(q, s), q;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.Converter = a.convertError = void 0;
          var oe = T(xi()), z = rf(), I = Al(), E = wl(), N = ef(), e = oe.SyntaxKind;
          function t(s) {
            return (0, I.createError)(s.file, s.start, "message" in s && s.message || s.messageText);
          }
          __name(t, "t");
          a.convertError = t;
          var x = /* @__PURE__ */ __name(class {
            constructor(s, q) {
              this.esTreeNodeToTSNodeMap = /* @__PURE__ */ new WeakMap(), this.tsNodeToESTreeNodeMap = /* @__PURE__ */ new WeakMap(), this.allowPattern = false, this.inTypeMode = false, this.ast = s, this.options = Object.assign({}, q);
            }
            getASTMaps() {
              return { esTreeNodeToTSNodeMap: this.esTreeNodeToTSNodeMap, tsNodeToESTreeNodeMap: this.tsNodeToESTreeNodeMap };
            }
            convertProgram() {
              return this.converter(this.ast);
            }
            converter(s, q, F, fe) {
              if (!s)
                return null;
              let Te = this.inTypeMode, Se = this.allowPattern;
              F !== void 0 && (this.inTypeMode = F), fe !== void 0 && (this.allowPattern = fe);
              let J = this.convertNode(s, q != null ? q : s.parent);
              return this.registerTSNodeInNodeMap(s, J), this.inTypeMode = Te, this.allowPattern = Se, J;
            }
            fixExports(s, q) {
              let F = (0, z.getModifiers)(s);
              if ((F == null ? void 0 : F[0].kind) === e.ExportKeyword) {
                this.registerTSNodeInNodeMap(s, q);
                let fe = F[0], Te = F[1], Se = Te && Te.kind === e.DefaultKeyword, J = Se ? (0, I.findNextToken)(Te, this.ast, this.ast) : (0, I.findNextToken)(fe, this.ast, this.ast);
                if (q.range[0] = J.getStart(this.ast), q.loc = (0, I.getLocFor)(q.range[0], q.range[1], this.ast), Se)
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ExportDefaultDeclaration, declaration: q, range: [fe.getStart(this.ast), q.range[1]], exportKind: "value" });
                {
                  let se = q.type === E.AST_NODE_TYPES.TSInterfaceDeclaration || q.type === E.AST_NODE_TYPES.TSTypeAliasDeclaration, Le = "declare" in q && q.declare === true;
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ExportNamedDeclaration, declaration: q, specifiers: [], source: null, exportKind: se || Le ? "type" : "value", range: [fe.getStart(this.ast), q.range[1]], assertions: [] });
                }
              }
              return q;
            }
            registerTSNodeInNodeMap(s, q) {
              q && this.options.shouldPreserveNodeMaps && (this.tsNodeToESTreeNodeMap.has(s) || this.tsNodeToESTreeNodeMap.set(s, q));
            }
            convertPattern(s, q) {
              return this.converter(s, q, this.inTypeMode, true);
            }
            convertChild(s, q) {
              return this.converter(s, q, this.inTypeMode, false);
            }
            convertType(s, q) {
              return this.converter(s, q, true, false);
            }
            createNode(s, q) {
              let F = q;
              return F.range || (F.range = (0, I.getRange)(s, this.ast)), F.loc || (F.loc = (0, I.getLocFor)(F.range[0], F.range[1], this.ast)), F && this.options.shouldPreserveNodeMaps && this.esTreeNodeToTSNodeMap.set(F, s), F;
            }
            convertBindingNameWithTypeAnnotation(s, q, F) {
              let fe = this.convertPattern(s);
              return q && (fe.typeAnnotation = this.convertTypeAnnotation(q, F), this.fixParentLocation(fe, fe.typeAnnotation.range)), fe;
            }
            convertTypeAnnotation(s, q) {
              let F = (q == null ? void 0 : q.kind) === e.FunctionType || (q == null ? void 0 : q.kind) === e.ConstructorType ? 2 : 1, fe = s.getFullStart() - F, Te = (0, I.getLocFor)(fe, s.end, this.ast);
              return { type: E.AST_NODE_TYPES.TSTypeAnnotation, loc: Te, range: [fe, s.end], typeAnnotation: this.convertType(s) };
            }
            convertBodyExpressions(s, q) {
              let F = (0, I.canContainDirective)(q);
              return s.map((fe) => {
                let Te = this.convertChild(fe);
                if (F)
                  if ((Te == null ? void 0 : Te.expression) && oe.isExpressionStatement(fe) && oe.isStringLiteral(fe.expression)) {
                    let Se = Te.expression.raw;
                    return Te.directive = Se.slice(1, -1), Te;
                  } else
                    F = false;
                return Te;
              }).filter((fe) => fe);
            }
            convertTypeArgumentsToTypeParameters(s, q) {
              let F = (0, I.findNextToken)(s, this.ast, this.ast);
              return this.createNode(q, { type: E.AST_NODE_TYPES.TSTypeParameterInstantiation, range: [s.pos - 1, F.end], params: s.map((fe) => this.convertType(fe)) });
            }
            convertTSTypeParametersToTypeParametersDeclaration(s) {
              let q = (0, I.findNextToken)(s, this.ast, this.ast);
              return { type: E.AST_NODE_TYPES.TSTypeParameterDeclaration, range: [s.pos - 1, q.end], loc: (0, I.getLocFor)(s.pos - 1, q.end, this.ast), params: s.map((F) => this.convertType(F)) };
            }
            convertParameters(s) {
              return s != null && s.length ? s.map((q) => {
                let F = this.convertChild(q), fe = (0, z.getDecorators)(q);
                return fe != null && fe.length && (F.decorators = fe.map((Te) => this.convertChild(Te))), F;
              }) : [];
            }
            convertChainExpression(s, q) {
              let { child: F, isOptional: fe } = (() => s.type === E.AST_NODE_TYPES.MemberExpression ? { child: s.object, isOptional: s.optional } : s.type === E.AST_NODE_TYPES.CallExpression ? { child: s.callee, isOptional: s.optional } : { child: s.expression, isOptional: false })(), Te = (0, I.isChildUnwrappableOptionalChain)(q, F);
              if (!Te && !fe)
                return s;
              if (Te && (0, I.isChainExpression)(F)) {
                let Se = F.expression;
                s.type === E.AST_NODE_TYPES.MemberExpression ? s.object = Se : s.type === E.AST_NODE_TYPES.CallExpression ? s.callee = Se : s.expression = Se;
              }
              return this.createNode(q, { type: E.AST_NODE_TYPES.ChainExpression, expression: s });
            }
            deeplyCopy(s) {
              if (s.kind === oe.SyntaxKind.JSDocFunctionType)
                throw (0, I.createError)(this.ast, s.pos, "JSDoc types can only be used inside documentation comments.");
              let q = `TS${e[s.kind]}`;
              if (this.options.errorOnUnknownASTType && !E.AST_NODE_TYPES[q])
                throw new Error(`Unknown AST_NODE_TYPE: "${q}"`);
              let F = this.createNode(s, { type: q });
              "type" in s && (F.typeAnnotation = s.type && "kind" in s.type && oe.isTypeNode(s.type) ? this.convertTypeAnnotation(s.type, s) : null), "typeArguments" in s && (F.typeParameters = s.typeArguments && "pos" in s.typeArguments ? this.convertTypeArgumentsToTypeParameters(s.typeArguments, s) : null), "typeParameters" in s && (F.typeParameters = s.typeParameters && "pos" in s.typeParameters ? this.convertTSTypeParametersToTypeParametersDeclaration(s.typeParameters) : null);
              let fe = (0, z.getDecorators)(s);
              fe != null && fe.length && (F.decorators = fe.map((Se) => this.convertChild(Se)));
              let Te = /* @__PURE__ */ new Set(["_children", "decorators", "end", "flags", "illegalDecorators", "heritageClauses", "locals", "localSymbol", "jsDoc", "kind", "modifierFlagsCache", "modifiers", "nextContainer", "parent", "pos", "symbol", "transformFlags", "type", "typeArguments", "typeParameters"]);
              return Object.entries(s).filter((Se) => {
                let [J] = Se;
                return !Te.has(J);
              }).forEach((Se) => {
                let [J, se] = Se;
                Array.isArray(se) ? F[J] = se.map((Le) => this.convertChild(Le)) : se && typeof se == "object" && se.kind ? F[J] = this.convertChild(se) : F[J] = se;
              }), F;
            }
            convertJSXIdentifier(s) {
              let q = this.createNode(s, { type: E.AST_NODE_TYPES.JSXIdentifier, name: s.getText() });
              return this.registerTSNodeInNodeMap(s, q), q;
            }
            convertJSXNamespaceOrIdentifier(s) {
              let q = s.getText(), F = q.indexOf(":");
              if (F > 0) {
                let fe = (0, I.getRange)(s, this.ast), Te = this.createNode(s, { type: E.AST_NODE_TYPES.JSXNamespacedName, namespace: this.createNode(s, { type: E.AST_NODE_TYPES.JSXIdentifier, name: q.slice(0, F), range: [fe[0], fe[0] + F] }), name: this.createNode(s, { type: E.AST_NODE_TYPES.JSXIdentifier, name: q.slice(F + 1), range: [fe[0] + F + 1, fe[1]] }), range: fe });
                return this.registerTSNodeInNodeMap(s, Te), Te;
              }
              return this.convertJSXIdentifier(s);
            }
            convertJSXTagName(s, q) {
              let F;
              switch (s.kind) {
                case e.PropertyAccessExpression:
                  if (s.name.kind === e.PrivateIdentifier)
                    throw new Error("Non-private identifier expected.");
                  F = this.createNode(s, { type: E.AST_NODE_TYPES.JSXMemberExpression, object: this.convertJSXTagName(s.expression, q), property: this.convertJSXIdentifier(s.name) });
                  break;
                case e.ThisKeyword:
                case e.Identifier:
                default:
                  return this.convertJSXNamespaceOrIdentifier(s);
              }
              return this.registerTSNodeInNodeMap(s, F), F;
            }
            convertMethodSignature(s) {
              let q = this.createNode(s, { type: E.AST_NODE_TYPES.TSMethodSignature, computed: (0, I.isComputedProperty)(s.name), key: this.convertChild(s.name), params: this.convertParameters(s.parameters), kind: (() => {
                switch (s.kind) {
                  case e.GetAccessor:
                    return "get";
                  case e.SetAccessor:
                    return "set";
                  case e.MethodSignature:
                    return "method";
                }
              })() });
              (0, I.isOptional)(s) && (q.optional = true), s.type && (q.returnType = this.convertTypeAnnotation(s.type, s)), (0, I.hasModifier)(e.ReadonlyKeyword, s) && (q.readonly = true), s.typeParameters && (q.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(s.typeParameters));
              let F = (0, I.getTSNodeAccessibility)(s);
              return F && (q.accessibility = F), (0, I.hasModifier)(e.ExportKeyword, s) && (q.export = true), (0, I.hasModifier)(e.StaticKeyword, s) && (q.static = true), q;
            }
            convertAssertClasue(s) {
              return s === void 0 ? [] : s.elements.map((q) => this.convertChild(q));
            }
            applyModifiersToResult(s, q) {
              if (!q)
                return;
              let F = [];
              for (let fe of q)
                switch (fe.kind) {
                  case e.ExportKeyword:
                  case e.DefaultKeyword:
                    break;
                  case e.ConstKeyword:
                    s.const = true;
                    break;
                  case e.DeclareKeyword:
                    s.declare = true;
                    break;
                  default:
                    F.push(this.convertChild(fe));
                    break;
                }
              F.length > 0 && (s.modifiers = F);
            }
            fixParentLocation(s, q) {
              q[0] < s.range[0] && (s.range[0] = q[0], s.loc.start = (0, I.getLineAndCharacterFor)(s.range[0], this.ast)), q[1] > s.range[1] && (s.range[1] = q[1], s.loc.end = (0, I.getLineAndCharacterFor)(s.range[1], this.ast));
            }
            assertModuleSpecifier(s, q) {
              var F;
              if (!q && s.moduleSpecifier == null)
                throw (0, I.createError)(this.ast, s.pos, "Module specifier must be a string literal.");
              if (s.moduleSpecifier && ((F = s.moduleSpecifier) === null || F === void 0 ? void 0 : F.kind) !== e.StringLiteral)
                throw (0, I.createError)(this.ast, s.moduleSpecifier.pos, "Module specifier must be a string literal.");
            }
            convertNode(s, q) {
              var F, fe, Te, Se, J, se, Le, Q, Be, je;
              switch (s.kind) {
                case e.SourceFile:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.Program, body: this.convertBodyExpressions(s.statements, s), sourceType: s.externalModuleIndicator ? "module" : "script", range: [s.getStart(this.ast), s.endOfFileToken.end] });
                case e.Block:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.BlockStatement, body: this.convertBodyExpressions(s.statements, s) });
                case e.Identifier:
                  return (0, I.isThisInTypeQuery)(s) ? this.createNode(s, { type: E.AST_NODE_TYPES.ThisExpression }) : this.createNode(s, { type: E.AST_NODE_TYPES.Identifier, name: s.text });
                case e.PrivateIdentifier:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.PrivateIdentifier, name: s.text.slice(1) });
                case e.WithStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.WithStatement, object: this.convertChild(s.expression), body: this.convertChild(s.statement) });
                case e.ReturnStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ReturnStatement, argument: this.convertChild(s.expression) });
                case e.LabeledStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.LabeledStatement, label: this.convertChild(s.label), body: this.convertChild(s.statement) });
                case e.ContinueStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ContinueStatement, label: this.convertChild(s.label) });
                case e.BreakStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.BreakStatement, label: this.convertChild(s.label) });
                case e.IfStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.IfStatement, test: this.convertChild(s.expression), consequent: this.convertChild(s.thenStatement), alternate: this.convertChild(s.elseStatement) });
                case e.SwitchStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.SwitchStatement, discriminant: this.convertChild(s.expression), cases: s.caseBlock.clauses.map((W) => this.convertChild(W)) });
                case e.CaseClause:
                case e.DefaultClause:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.SwitchCase, test: s.kind === e.CaseClause ? this.convertChild(s.expression) : null, consequent: s.statements.map((W) => this.convertChild(W)) });
                case e.ThrowStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ThrowStatement, argument: this.convertChild(s.expression) });
                case e.TryStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TryStatement, block: this.convertChild(s.tryBlock), handler: this.convertChild(s.catchClause), finalizer: this.convertChild(s.finallyBlock) });
                case e.CatchClause:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.CatchClause, param: s.variableDeclaration ? this.convertBindingNameWithTypeAnnotation(s.variableDeclaration.name, s.variableDeclaration.type) : null, body: this.convertChild(s.block) });
                case e.WhileStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.WhileStatement, test: this.convertChild(s.expression), body: this.convertChild(s.statement) });
                case e.DoStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.DoWhileStatement, test: this.convertChild(s.expression), body: this.convertChild(s.statement) });
                case e.ForStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ForStatement, init: this.convertChild(s.initializer), test: this.convertChild(s.condition), update: this.convertChild(s.incrementor), body: this.convertChild(s.statement) });
                case e.ForInStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ForInStatement, left: this.convertPattern(s.initializer), right: this.convertChild(s.expression), body: this.convertChild(s.statement) });
                case e.ForOfStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ForOfStatement, left: this.convertPattern(s.initializer), right: this.convertChild(s.expression), body: this.convertChild(s.statement), await: Boolean(s.awaitModifier && s.awaitModifier.kind === e.AwaitKeyword) });
                case e.FunctionDeclaration: {
                  let W = (0, I.hasModifier)(e.DeclareKeyword, s), B = this.createNode(s, { type: W || !s.body ? E.AST_NODE_TYPES.TSDeclareFunction : E.AST_NODE_TYPES.FunctionDeclaration, id: this.convertChild(s.name), generator: !!s.asteriskToken, expression: false, async: (0, I.hasModifier)(e.AsyncKeyword, s), params: this.convertParameters(s.parameters), body: this.convertChild(s.body) || void 0 });
                  return s.type && (B.returnType = this.convertTypeAnnotation(s.type, s)), s.typeParameters && (B.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(s.typeParameters)), W && (B.declare = true), this.fixExports(s, B);
                }
                case e.VariableDeclaration: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.VariableDeclarator, id: this.convertBindingNameWithTypeAnnotation(s.name, s.type, s), init: this.convertChild(s.initializer) });
                  return s.exclamationToken && (W.definite = true), W;
                }
                case e.VariableStatement: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.VariableDeclaration, declarations: s.declarationList.declarations.map((B) => this.convertChild(B)), kind: (0, I.getDeclarationKind)(s.declarationList) });
                  return (0, I.hasModifier)(e.DeclareKeyword, s) && (W.declare = true), this.fixExports(s, W);
                }
                case e.VariableDeclarationList:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.VariableDeclaration, declarations: s.declarations.map((W) => this.convertChild(W)), kind: (0, I.getDeclarationKind)(s) });
                case e.ExpressionStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ExpressionStatement, expression: this.convertChild(s.expression) });
                case e.ThisKeyword:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ThisExpression });
                case e.ArrayLiteralExpression:
                  return this.allowPattern ? this.createNode(s, { type: E.AST_NODE_TYPES.ArrayPattern, elements: s.elements.map((W) => this.convertPattern(W)) }) : this.createNode(s, { type: E.AST_NODE_TYPES.ArrayExpression, elements: s.elements.map((W) => this.convertChild(W)) });
                case e.ObjectLiteralExpression:
                  return this.allowPattern ? this.createNode(s, { type: E.AST_NODE_TYPES.ObjectPattern, properties: s.properties.map((W) => this.convertPattern(W)) }) : this.createNode(s, { type: E.AST_NODE_TYPES.ObjectExpression, properties: s.properties.map((W) => this.convertChild(W)) });
                case e.PropertyAssignment:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.Property, key: this.convertChild(s.name), value: this.converter(s.initializer, s, this.inTypeMode, this.allowPattern), computed: (0, I.isComputedProperty)(s.name), method: false, shorthand: false, kind: "init" });
                case e.ShorthandPropertyAssignment:
                  return s.objectAssignmentInitializer ? this.createNode(s, { type: E.AST_NODE_TYPES.Property, key: this.convertChild(s.name), value: this.createNode(s, { type: E.AST_NODE_TYPES.AssignmentPattern, left: this.convertPattern(s.name), right: this.convertChild(s.objectAssignmentInitializer) }), computed: false, method: false, shorthand: true, kind: "init" }) : this.createNode(s, { type: E.AST_NODE_TYPES.Property, key: this.convertChild(s.name), value: this.convertChild(s.name), computed: false, method: false, shorthand: true, kind: "init" });
                case e.ComputedPropertyName:
                  return this.convertChild(s.expression);
                case e.PropertyDeclaration: {
                  let W = (0, I.hasModifier)(e.AbstractKeyword, s), B = (0, I.hasModifier)(e.AccessorKeyword, s), U = (() => B ? W ? E.AST_NODE_TYPES.TSAbstractAccessorProperty : E.AST_NODE_TYPES.AccessorProperty : W ? E.AST_NODE_TYPES.TSAbstractPropertyDefinition : E.AST_NODE_TYPES.PropertyDefinition)(), m = this.createNode(s, { type: U, key: this.convertChild(s.name), value: W ? null : this.convertChild(s.initializer), computed: (0, I.isComputedProperty)(s.name), static: (0, I.hasModifier)(e.StaticKeyword, s), readonly: (0, I.hasModifier)(e.ReadonlyKeyword, s) || void 0, declare: (0, I.hasModifier)(e.DeclareKeyword, s), override: (0, I.hasModifier)(e.OverrideKeyword, s) });
                  s.type && (m.typeAnnotation = this.convertTypeAnnotation(s.type, s));
                  let v = (0, z.getDecorators)(s);
                  v && (m.decorators = v.map((O) => this.convertChild(O)));
                  let g = (0, I.getTSNodeAccessibility)(s);
                  return g && (m.accessibility = g), (s.name.kind === e.Identifier || s.name.kind === e.ComputedPropertyName || s.name.kind === e.PrivateIdentifier) && s.questionToken && (m.optional = true), s.exclamationToken && (m.definite = true), m.key.type === E.AST_NODE_TYPES.Literal && s.questionToken && (m.optional = true), m;
                }
                case e.GetAccessor:
                case e.SetAccessor:
                  if (s.parent.kind === e.InterfaceDeclaration || s.parent.kind === e.TypeLiteral)
                    return this.convertMethodSignature(s);
                case e.MethodDeclaration: {
                  let W = this.createNode(s, { type: s.body ? E.AST_NODE_TYPES.FunctionExpression : E.AST_NODE_TYPES.TSEmptyBodyFunctionExpression, id: null, generator: !!s.asteriskToken, expression: false, async: (0, I.hasModifier)(e.AsyncKeyword, s), body: this.convertChild(s.body), range: [s.parameters.pos - 1, s.end], params: [] });
                  s.type && (W.returnType = this.convertTypeAnnotation(s.type, s)), s.typeParameters && (W.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(s.typeParameters), this.fixParentLocation(W, W.typeParameters.range));
                  let B;
                  if (q.kind === e.ObjectLiteralExpression)
                    W.params = s.parameters.map((U) => this.convertChild(U)), B = this.createNode(s, { type: E.AST_NODE_TYPES.Property, key: this.convertChild(s.name), value: W, computed: (0, I.isComputedProperty)(s.name), method: s.kind === e.MethodDeclaration, shorthand: false, kind: "init" });
                  else {
                    W.params = this.convertParameters(s.parameters);
                    let U = (0, I.hasModifier)(e.AbstractKeyword, s) ? E.AST_NODE_TYPES.TSAbstractMethodDefinition : E.AST_NODE_TYPES.MethodDefinition;
                    B = this.createNode(s, { type: U, key: this.convertChild(s.name), value: W, computed: (0, I.isComputedProperty)(s.name), static: (0, I.hasModifier)(e.StaticKeyword, s), kind: "method", override: (0, I.hasModifier)(e.OverrideKeyword, s) });
                    let m = (0, z.getDecorators)(s);
                    m && (B.decorators = m.map((g) => this.convertChild(g)));
                    let v = (0, I.getTSNodeAccessibility)(s);
                    v && (B.accessibility = v);
                  }
                  return s.questionToken && (B.optional = true), s.kind === e.GetAccessor ? B.kind = "get" : s.kind === e.SetAccessor ? B.kind = "set" : !B.static && s.name.kind === e.StringLiteral && s.name.text === "constructor" && B.type !== E.AST_NODE_TYPES.Property && (B.kind = "constructor"), B;
                }
                case e.Constructor: {
                  let W = (0, I.getLastModifier)(s), B = W && (0, I.findNextToken)(W, s, this.ast) || s.getFirstToken(), U = this.createNode(s, { type: s.body ? E.AST_NODE_TYPES.FunctionExpression : E.AST_NODE_TYPES.TSEmptyBodyFunctionExpression, id: null, params: this.convertParameters(s.parameters), generator: false, expression: false, async: false, body: this.convertChild(s.body), range: [s.parameters.pos - 1, s.end] });
                  s.typeParameters && (U.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(s.typeParameters), this.fixParentLocation(U, U.typeParameters.range)), s.type && (U.returnType = this.convertTypeAnnotation(s.type, s));
                  let m = this.createNode(s, { type: E.AST_NODE_TYPES.Identifier, name: "constructor", range: [B.getStart(this.ast), B.end] }), v = (0, I.hasModifier)(e.StaticKeyword, s), g = this.createNode(s, { type: (0, I.hasModifier)(e.AbstractKeyword, s) ? E.AST_NODE_TYPES.TSAbstractMethodDefinition : E.AST_NODE_TYPES.MethodDefinition, key: m, value: U, computed: false, static: v, kind: v ? "method" : "constructor", override: false }), O = (0, I.getTSNodeAccessibility)(s);
                  return O && (g.accessibility = O), g;
                }
                case e.FunctionExpression: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.FunctionExpression, id: this.convertChild(s.name), generator: !!s.asteriskToken, params: this.convertParameters(s.parameters), body: this.convertChild(s.body), async: (0, I.hasModifier)(e.AsyncKeyword, s), expression: false });
                  return s.type && (W.returnType = this.convertTypeAnnotation(s.type, s)), s.typeParameters && (W.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(s.typeParameters)), W;
                }
                case e.SuperKeyword:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.Super });
                case e.ArrayBindingPattern:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ArrayPattern, elements: s.elements.map((W) => this.convertPattern(W)) });
                case e.OmittedExpression:
                  return null;
                case e.ObjectBindingPattern:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ObjectPattern, properties: s.elements.map((W) => this.convertPattern(W)) });
                case e.BindingElement:
                  if (q.kind === e.ArrayBindingPattern) {
                    let W = this.convertChild(s.name, q);
                    return s.initializer ? this.createNode(s, { type: E.AST_NODE_TYPES.AssignmentPattern, left: W, right: this.convertChild(s.initializer) }) : s.dotDotDotToken ? this.createNode(s, { type: E.AST_NODE_TYPES.RestElement, argument: W }) : W;
                  } else {
                    let W;
                    return s.dotDotDotToken ? W = this.createNode(s, { type: E.AST_NODE_TYPES.RestElement, argument: this.convertChild((F = s.propertyName) !== null && F !== void 0 ? F : s.name) }) : W = this.createNode(s, { type: E.AST_NODE_TYPES.Property, key: this.convertChild((fe = s.propertyName) !== null && fe !== void 0 ? fe : s.name), value: this.convertChild(s.name), computed: Boolean(s.propertyName && s.propertyName.kind === e.ComputedPropertyName), method: false, shorthand: !s.propertyName, kind: "init" }), s.initializer && (W.value = this.createNode(s, { type: E.AST_NODE_TYPES.AssignmentPattern, left: this.convertChild(s.name), right: this.convertChild(s.initializer), range: [s.name.getStart(this.ast), s.initializer.end] })), W;
                  }
                case e.ArrowFunction: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.ArrowFunctionExpression, generator: false, id: null, params: this.convertParameters(s.parameters), body: this.convertChild(s.body), async: (0, I.hasModifier)(e.AsyncKeyword, s), expression: s.body.kind !== e.Block });
                  return s.type && (W.returnType = this.convertTypeAnnotation(s.type, s)), s.typeParameters && (W.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(s.typeParameters)), W;
                }
                case e.YieldExpression:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.YieldExpression, delegate: !!s.asteriskToken, argument: this.convertChild(s.expression) });
                case e.AwaitExpression:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.AwaitExpression, argument: this.convertChild(s.expression) });
                case e.NoSubstitutionTemplateLiteral:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TemplateLiteral, quasis: [this.createNode(s, { type: E.AST_NODE_TYPES.TemplateElement, value: { raw: this.ast.text.slice(s.getStart(this.ast) + 1, s.end - 1), cooked: s.text }, tail: true })], expressions: [] });
                case e.TemplateExpression: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.TemplateLiteral, quasis: [this.convertChild(s.head)], expressions: [] });
                  return s.templateSpans.forEach((B) => {
                    W.expressions.push(this.convertChild(B.expression)), W.quasis.push(this.convertChild(B.literal));
                  }), W;
                }
                case e.TaggedTemplateExpression:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TaggedTemplateExpression, typeParameters: s.typeArguments ? this.convertTypeArgumentsToTypeParameters(s.typeArguments, s) : void 0, tag: this.convertChild(s.tag), quasi: this.convertChild(s.template) });
                case e.TemplateHead:
                case e.TemplateMiddle:
                case e.TemplateTail: {
                  let W = s.kind === e.TemplateTail;
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TemplateElement, value: { raw: this.ast.text.slice(s.getStart(this.ast) + 1, s.end - (W ? 1 : 2)), cooked: s.text }, tail: W });
                }
                case e.SpreadAssignment:
                case e.SpreadElement:
                  return this.allowPattern ? this.createNode(s, { type: E.AST_NODE_TYPES.RestElement, argument: this.convertPattern(s.expression) }) : this.createNode(s, { type: E.AST_NODE_TYPES.SpreadElement, argument: this.convertChild(s.expression) });
                case e.Parameter: {
                  let W, B;
                  return s.dotDotDotToken ? W = B = this.createNode(s, { type: E.AST_NODE_TYPES.RestElement, argument: this.convertChild(s.name) }) : s.initializer ? (W = this.convertChild(s.name), B = this.createNode(s, { type: E.AST_NODE_TYPES.AssignmentPattern, left: W, right: this.convertChild(s.initializer) }), (0, z.getModifiers)(s) && (B.range[0] = W.range[0], B.loc = (0, I.getLocFor)(B.range[0], B.range[1], this.ast))) : W = B = this.convertChild(s.name, q), s.type && (W.typeAnnotation = this.convertTypeAnnotation(s.type, s), this.fixParentLocation(W, W.typeAnnotation.range)), s.questionToken && (s.questionToken.end > W.range[1] && (W.range[1] = s.questionToken.end, W.loc.end = (0, I.getLineAndCharacterFor)(W.range[1], this.ast)), W.optional = true), (0, z.getModifiers)(s) ? this.createNode(s, { type: E.AST_NODE_TYPES.TSParameterProperty, accessibility: (Te = (0, I.getTSNodeAccessibility)(s)) !== null && Te !== void 0 ? Te : void 0, readonly: (0, I.hasModifier)(e.ReadonlyKeyword, s) || void 0, static: (0, I.hasModifier)(e.StaticKeyword, s) || void 0, export: (0, I.hasModifier)(e.ExportKeyword, s) || void 0, override: (0, I.hasModifier)(e.OverrideKeyword, s) || void 0, parameter: B }) : B;
                }
                case e.ClassDeclaration:
                case e.ClassExpression: {
                  let W = (Se = s.heritageClauses) !== null && Se !== void 0 ? Se : [], B = s.kind === e.ClassDeclaration ? E.AST_NODE_TYPES.ClassDeclaration : E.AST_NODE_TYPES.ClassExpression, U = W.find((S) => S.token === e.ExtendsKeyword), m = W.find((S) => S.token === e.ImplementsKeyword), v = this.createNode(s, { type: B, id: this.convertChild(s.name), body: this.createNode(s, { type: E.AST_NODE_TYPES.ClassBody, body: [], range: [s.members.pos - 1, s.end] }), superClass: U != null && U.types[0] ? this.convertChild(U.types[0].expression) : null });
                  if (U) {
                    if (U.types.length > 1)
                      throw (0, I.createError)(this.ast, U.types[1].pos, "Classes can only extend a single class.");
                    !((J = U.types[0]) === null || J === void 0) && J.typeArguments && (v.superTypeParameters = this.convertTypeArgumentsToTypeParameters(U.types[0].typeArguments, U.types[0]));
                  }
                  s.typeParameters && (v.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(s.typeParameters)), m && (v.implements = m.types.map((S) => this.convertChild(S))), (0, I.hasModifier)(e.AbstractKeyword, s) && (v.abstract = true), (0, I.hasModifier)(e.DeclareKeyword, s) && (v.declare = true);
                  let g = (0, z.getDecorators)(s);
                  g && (v.decorators = g.map((S) => this.convertChild(S)));
                  let O = s.members.filter(I.isESTreeClassMember);
                  return O.length && (v.body.body = O.map((S) => this.convertChild(S))), this.fixExports(s, v);
                }
                case e.ModuleBlock:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSModuleBlock, body: this.convertBodyExpressions(s.statements, s) });
                case e.ImportDeclaration: {
                  this.assertModuleSpecifier(s, false);
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.ImportDeclaration, source: this.convertChild(s.moduleSpecifier), specifiers: [], importKind: "value", assertions: this.convertAssertClasue(s.assertClause) });
                  if (s.importClause && (s.importClause.isTypeOnly && (W.importKind = "type"), s.importClause.name && W.specifiers.push(this.convertChild(s.importClause)), s.importClause.namedBindings))
                    switch (s.importClause.namedBindings.kind) {
                      case e.NamespaceImport:
                        W.specifiers.push(this.convertChild(s.importClause.namedBindings));
                        break;
                      case e.NamedImports:
                        W.specifiers = W.specifiers.concat(s.importClause.namedBindings.elements.map((B) => this.convertChild(B)));
                        break;
                    }
                  return W;
                }
                case e.NamespaceImport:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ImportNamespaceSpecifier, local: this.convertChild(s.name) });
                case e.ImportSpecifier:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ImportSpecifier, local: this.convertChild(s.name), imported: this.convertChild((se = s.propertyName) !== null && se !== void 0 ? se : s.name), importKind: s.isTypeOnly ? "type" : "value" });
                case e.ImportClause: {
                  let W = this.convertChild(s.name);
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ImportDefaultSpecifier, local: W, range: W.range });
                }
                case e.ExportDeclaration:
                  return ((Le = s.exportClause) === null || Le === void 0 ? void 0 : Le.kind) === e.NamedExports ? (this.assertModuleSpecifier(s, true), this.createNode(s, { type: E.AST_NODE_TYPES.ExportNamedDeclaration, source: this.convertChild(s.moduleSpecifier), specifiers: s.exportClause.elements.map((W) => this.convertChild(W)), exportKind: s.isTypeOnly ? "type" : "value", declaration: null, assertions: this.convertAssertClasue(s.assertClause) })) : (this.assertModuleSpecifier(s, false), this.createNode(s, { type: E.AST_NODE_TYPES.ExportAllDeclaration, source: this.convertChild(s.moduleSpecifier), exportKind: s.isTypeOnly ? "type" : "value", exported: s.exportClause && s.exportClause.kind === e.NamespaceExport ? this.convertChild(s.exportClause.name) : null, assertions: this.convertAssertClasue(s.assertClause) }));
                case e.ExportSpecifier:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ExportSpecifier, local: this.convertChild((Q = s.propertyName) !== null && Q !== void 0 ? Q : s.name), exported: this.convertChild(s.name), exportKind: s.isTypeOnly ? "type" : "value" });
                case e.ExportAssignment:
                  return s.isExportEquals ? this.createNode(s, { type: E.AST_NODE_TYPES.TSExportAssignment, expression: this.convertChild(s.expression) }) : this.createNode(s, { type: E.AST_NODE_TYPES.ExportDefaultDeclaration, declaration: this.convertChild(s.expression), exportKind: "value" });
                case e.PrefixUnaryExpression:
                case e.PostfixUnaryExpression: {
                  let W = (0, I.getTextForTokenKind)(s.operator);
                  return W === "++" || W === "--" ? this.createNode(s, { type: E.AST_NODE_TYPES.UpdateExpression, operator: W, prefix: s.kind === e.PrefixUnaryExpression, argument: this.convertChild(s.operand) }) : this.createNode(s, { type: E.AST_NODE_TYPES.UnaryExpression, operator: W, prefix: s.kind === e.PrefixUnaryExpression, argument: this.convertChild(s.operand) });
                }
                case e.DeleteExpression:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.UnaryExpression, operator: "delete", prefix: true, argument: this.convertChild(s.expression) });
                case e.VoidExpression:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.UnaryExpression, operator: "void", prefix: true, argument: this.convertChild(s.expression) });
                case e.TypeOfExpression:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.UnaryExpression, operator: "typeof", prefix: true, argument: this.convertChild(s.expression) });
                case e.TypeOperator:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSTypeOperator, operator: (0, I.getTextForTokenKind)(s.operator), typeAnnotation: this.convertChild(s.type) });
                case e.BinaryExpression:
                  if ((0, I.isComma)(s.operatorToken)) {
                    let W = this.createNode(s, { type: E.AST_NODE_TYPES.SequenceExpression, expressions: [] }), B = this.convertChild(s.left);
                    return B.type === E.AST_NODE_TYPES.SequenceExpression && s.left.kind !== e.ParenthesizedExpression ? W.expressions = W.expressions.concat(B.expressions) : W.expressions.push(B), W.expressions.push(this.convertChild(s.right)), W;
                  } else {
                    let W = (0, I.getBinaryExpressionType)(s.operatorToken);
                    return this.allowPattern && W === E.AST_NODE_TYPES.AssignmentExpression ? this.createNode(s, { type: E.AST_NODE_TYPES.AssignmentPattern, left: this.convertPattern(s.left, s), right: this.convertChild(s.right) }) : this.createNode(s, { type: W, operator: (0, I.getTextForTokenKind)(s.operatorToken.kind), left: this.converter(s.left, s, this.inTypeMode, W === E.AST_NODE_TYPES.AssignmentExpression), right: this.convertChild(s.right) });
                  }
                case e.PropertyAccessExpression: {
                  let W = this.convertChild(s.expression), B = this.convertChild(s.name), U = false, m = this.createNode(s, { type: E.AST_NODE_TYPES.MemberExpression, object: W, property: B, computed: U, optional: s.questionDotToken !== void 0 });
                  return this.convertChainExpression(m, s);
                }
                case e.ElementAccessExpression: {
                  let W = this.convertChild(s.expression), B = this.convertChild(s.argumentExpression), U = true, m = this.createNode(s, { type: E.AST_NODE_TYPES.MemberExpression, object: W, property: B, computed: U, optional: s.questionDotToken !== void 0 });
                  return this.convertChainExpression(m, s);
                }
                case e.CallExpression: {
                  if (s.expression.kind === e.ImportKeyword) {
                    if (s.arguments.length !== 1 && s.arguments.length !== 2)
                      throw (0, I.createError)(this.ast, s.arguments.pos, "Dynamic import requires exactly one or two arguments.");
                    return this.createNode(s, { type: E.AST_NODE_TYPES.ImportExpression, source: this.convertChild(s.arguments[0]), attributes: s.arguments[1] ? this.convertChild(s.arguments[1]) : null });
                  }
                  let W = this.convertChild(s.expression), B = s.arguments.map((m) => this.convertChild(m)), U = this.createNode(s, { type: E.AST_NODE_TYPES.CallExpression, callee: W, arguments: B, optional: s.questionDotToken !== void 0 });
                  return s.typeArguments && (U.typeParameters = this.convertTypeArgumentsToTypeParameters(s.typeArguments, s)), this.convertChainExpression(U, s);
                }
                case e.NewExpression: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.NewExpression, callee: this.convertChild(s.expression), arguments: s.arguments ? s.arguments.map((B) => this.convertChild(B)) : [] });
                  return s.typeArguments && (W.typeParameters = this.convertTypeArgumentsToTypeParameters(s.typeArguments, s)), W;
                }
                case e.ConditionalExpression:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ConditionalExpression, test: this.convertChild(s.condition), consequent: this.convertChild(s.whenTrue), alternate: this.convertChild(s.whenFalse) });
                case e.MetaProperty:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.MetaProperty, meta: this.createNode(s.getFirstToken(), { type: E.AST_NODE_TYPES.Identifier, name: (0, I.getTextForTokenKind)(s.keywordToken) }), property: this.convertChild(s.name) });
                case e.Decorator:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.Decorator, expression: this.convertChild(s.expression) });
                case e.StringLiteral:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.Literal, value: q.kind === e.JsxAttribute ? (0, I.unescapeStringLiteralText)(s.text) : s.text, raw: s.getText() });
                case e.NumericLiteral:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.Literal, value: Number(s.text), raw: s.getText() });
                case e.BigIntLiteral: {
                  let W = (0, I.getRange)(s, this.ast), B = this.ast.text.slice(W[0], W[1]), U = B.slice(0, -1).replace(/_/g, ""), m = typeof BigInt < "u" ? BigInt(U) : null;
                  return this.createNode(s, { type: E.AST_NODE_TYPES.Literal, raw: B, value: m, bigint: m === null ? U : String(m), range: W });
                }
                case e.RegularExpressionLiteral: {
                  let W = s.text.slice(1, s.text.lastIndexOf("/")), B = s.text.slice(s.text.lastIndexOf("/") + 1), U = null;
                  try {
                    U = new RegExp(W, B);
                  } catch {
                    U = null;
                  }
                  return this.createNode(s, { type: E.AST_NODE_TYPES.Literal, value: U, raw: s.text, regex: { pattern: W, flags: B } });
                }
                case e.TrueKeyword:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.Literal, value: true, raw: "true" });
                case e.FalseKeyword:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.Literal, value: false, raw: "false" });
                case e.NullKeyword:
                  return !N.typescriptVersionIsAtLeast["4.0"] && this.inTypeMode ? this.createNode(s, { type: E.AST_NODE_TYPES.TSNullKeyword }) : this.createNode(s, { type: E.AST_NODE_TYPES.Literal, value: null, raw: "null" });
                case e.EmptyStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.EmptyStatement });
                case e.DebuggerStatement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.DebuggerStatement });
                case e.JsxElement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.JSXElement, openingElement: this.convertChild(s.openingElement), closingElement: this.convertChild(s.closingElement), children: s.children.map((W) => this.convertChild(W)) });
                case e.JsxFragment:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.JSXFragment, openingFragment: this.convertChild(s.openingFragment), closingFragment: this.convertChild(s.closingFragment), children: s.children.map((W) => this.convertChild(W)) });
                case e.JsxSelfClosingElement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.JSXElement, openingElement: this.createNode(s, { type: E.AST_NODE_TYPES.JSXOpeningElement, typeParameters: s.typeArguments ? this.convertTypeArgumentsToTypeParameters(s.typeArguments, s) : void 0, selfClosing: true, name: this.convertJSXTagName(s.tagName, s), attributes: s.attributes.properties.map((W) => this.convertChild(W)), range: (0, I.getRange)(s, this.ast) }), closingElement: null, children: [] });
                case e.JsxOpeningElement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.JSXOpeningElement, typeParameters: s.typeArguments ? this.convertTypeArgumentsToTypeParameters(s.typeArguments, s) : void 0, selfClosing: false, name: this.convertJSXTagName(s.tagName, s), attributes: s.attributes.properties.map((W) => this.convertChild(W)) });
                case e.JsxClosingElement:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.JSXClosingElement, name: this.convertJSXTagName(s.tagName, s) });
                case e.JsxOpeningFragment:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.JSXOpeningFragment });
                case e.JsxClosingFragment:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.JSXClosingFragment });
                case e.JsxExpression: {
                  let W = s.expression ? this.convertChild(s.expression) : this.createNode(s, { type: E.AST_NODE_TYPES.JSXEmptyExpression, range: [s.getStart(this.ast) + 1, s.getEnd() - 1] });
                  return s.dotDotDotToken ? this.createNode(s, { type: E.AST_NODE_TYPES.JSXSpreadChild, expression: W }) : this.createNode(s, { type: E.AST_NODE_TYPES.JSXExpressionContainer, expression: W });
                }
                case e.JsxAttribute:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.JSXAttribute, name: this.convertJSXNamespaceOrIdentifier(s.name), value: this.convertChild(s.initializer) });
                case e.JsxText: {
                  let W = s.getFullStart(), B = s.getEnd(), U = this.ast.text.slice(W, B);
                  return this.createNode(s, { type: E.AST_NODE_TYPES.JSXText, value: (0, I.unescapeStringLiteralText)(U), raw: U, range: [W, B] });
                }
                case e.JsxSpreadAttribute:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.JSXSpreadAttribute, argument: this.convertChild(s.expression) });
                case e.QualifiedName:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSQualifiedName, left: this.convertChild(s.left), right: this.convertChild(s.right) });
                case e.TypeReference:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSTypeReference, typeName: this.convertType(s.typeName), typeParameters: s.typeArguments ? this.convertTypeArgumentsToTypeParameters(s.typeArguments, s) : void 0 });
                case e.TypeParameter:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSTypeParameter, name: this.convertType(s.name), constraint: s.constraint ? this.convertType(s.constraint) : void 0, default: s.default ? this.convertType(s.default) : void 0, in: (0, I.hasModifier)(e.InKeyword, s), out: (0, I.hasModifier)(e.OutKeyword, s) });
                case e.ThisType:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSThisType });
                case e.AnyKeyword:
                case e.BigIntKeyword:
                case e.BooleanKeyword:
                case e.NeverKeyword:
                case e.NumberKeyword:
                case e.ObjectKeyword:
                case e.StringKeyword:
                case e.SymbolKeyword:
                case e.UnknownKeyword:
                case e.VoidKeyword:
                case e.UndefinedKeyword:
                case e.IntrinsicKeyword:
                  return this.createNode(s, { type: E.AST_NODE_TYPES[`TS${e[s.kind]}`] });
                case e.NonNullExpression: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.TSNonNullExpression, expression: this.convertChild(s.expression) });
                  return this.convertChainExpression(W, s);
                }
                case e.TypeLiteral:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSTypeLiteral, members: s.members.map((W) => this.convertChild(W)) });
                case e.ArrayType:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSArrayType, elementType: this.convertType(s.elementType) });
                case e.IndexedAccessType:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSIndexedAccessType, objectType: this.convertType(s.objectType), indexType: this.convertType(s.indexType) });
                case e.ConditionalType:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSConditionalType, checkType: this.convertType(s.checkType), extendsType: this.convertType(s.extendsType), trueType: this.convertType(s.trueType), falseType: this.convertType(s.falseType) });
                case e.TypeQuery:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSTypeQuery, exprName: this.convertType(s.exprName), typeParameters: s.typeArguments && this.convertTypeArgumentsToTypeParameters(s.typeArguments, s) });
                case e.MappedType: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.TSMappedType, typeParameter: this.convertType(s.typeParameter), nameType: (Be = this.convertType(s.nameType)) !== null && Be !== void 0 ? Be : null });
                  return s.readonlyToken && (s.readonlyToken.kind === e.ReadonlyKeyword ? W.readonly = true : W.readonly = (0, I.getTextForTokenKind)(s.readonlyToken.kind)), s.questionToken && (s.questionToken.kind === e.QuestionToken ? W.optional = true : W.optional = (0, I.getTextForTokenKind)(s.questionToken.kind)), s.type && (W.typeAnnotation = this.convertType(s.type)), W;
                }
                case e.ParenthesizedExpression:
                  return this.convertChild(s.expression, q);
                case e.TypeAliasDeclaration: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.TSTypeAliasDeclaration, id: this.convertChild(s.name), typeAnnotation: this.convertType(s.type) });
                  return (0, I.hasModifier)(e.DeclareKeyword, s) && (W.declare = true), s.typeParameters && (W.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(s.typeParameters)), this.fixExports(s, W);
                }
                case e.MethodSignature:
                  return this.convertMethodSignature(s);
                case e.PropertySignature: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.TSPropertySignature, optional: (0, I.isOptional)(s) || void 0, computed: (0, I.isComputedProperty)(s.name), key: this.convertChild(s.name), typeAnnotation: s.type ? this.convertTypeAnnotation(s.type, s) : void 0, initializer: this.convertChild(s.initializer) || void 0, readonly: (0, I.hasModifier)(e.ReadonlyKeyword, s) || void 0, static: (0, I.hasModifier)(e.StaticKeyword, s) || void 0, export: (0, I.hasModifier)(e.ExportKeyword, s) || void 0 }), B = (0, I.getTSNodeAccessibility)(s);
                  return B && (W.accessibility = B), W;
                }
                case e.IndexSignature: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.TSIndexSignature, parameters: s.parameters.map((U) => this.convertChild(U)) });
                  s.type && (W.typeAnnotation = this.convertTypeAnnotation(s.type, s)), (0, I.hasModifier)(e.ReadonlyKeyword, s) && (W.readonly = true);
                  let B = (0, I.getTSNodeAccessibility)(s);
                  return B && (W.accessibility = B), (0, I.hasModifier)(e.ExportKeyword, s) && (W.export = true), (0, I.hasModifier)(e.StaticKeyword, s) && (W.static = true), W;
                }
                case e.ConstructorType: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.TSConstructorType, params: this.convertParameters(s.parameters), abstract: (0, I.hasModifier)(e.AbstractKeyword, s) });
                  return s.type && (W.returnType = this.convertTypeAnnotation(s.type, s)), s.typeParameters && (W.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(s.typeParameters)), W;
                }
                case e.FunctionType:
                case e.ConstructSignature:
                case e.CallSignature: {
                  let W = s.kind === e.ConstructSignature ? E.AST_NODE_TYPES.TSConstructSignatureDeclaration : s.kind === e.CallSignature ? E.AST_NODE_TYPES.TSCallSignatureDeclaration : E.AST_NODE_TYPES.TSFunctionType, B = this.createNode(s, { type: W, params: this.convertParameters(s.parameters) });
                  return s.type && (B.returnType = this.convertTypeAnnotation(s.type, s)), s.typeParameters && (B.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(s.typeParameters)), B;
                }
                case e.ExpressionWithTypeArguments: {
                  let W = q.kind, B = W === e.InterfaceDeclaration ? E.AST_NODE_TYPES.TSInterfaceHeritage : W === e.HeritageClause ? E.AST_NODE_TYPES.TSClassImplements : E.AST_NODE_TYPES.TSInstantiationExpression, U = this.createNode(s, { type: B, expression: this.convertChild(s.expression) });
                  return s.typeArguments && (U.typeParameters = this.convertTypeArgumentsToTypeParameters(s.typeArguments, s)), U;
                }
                case e.InterfaceDeclaration: {
                  let W = (je = s.heritageClauses) !== null && je !== void 0 ? je : [], B = this.createNode(s, { type: E.AST_NODE_TYPES.TSInterfaceDeclaration, body: this.createNode(s, { type: E.AST_NODE_TYPES.TSInterfaceBody, body: s.members.map((U) => this.convertChild(U)), range: [s.members.pos - 1, s.end] }), id: this.convertChild(s.name) });
                  if (s.typeParameters && (B.typeParameters = this.convertTSTypeParametersToTypeParametersDeclaration(s.typeParameters)), W.length > 0) {
                    let U = [], m = [];
                    for (let v of W)
                      if (v.token === e.ExtendsKeyword)
                        for (let g of v.types)
                          U.push(this.convertChild(g, s));
                      else
                        for (let g of v.types)
                          m.push(this.convertChild(g, s));
                    U.length && (B.extends = U), m.length && (B.implements = m);
                  }
                  return (0, I.hasModifier)(e.AbstractKeyword, s) && (B.abstract = true), (0, I.hasModifier)(e.DeclareKeyword, s) && (B.declare = true), this.fixExports(s, B);
                }
                case e.TypePredicate: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.TSTypePredicate, asserts: s.assertsModifier !== void 0, parameterName: this.convertChild(s.parameterName), typeAnnotation: null });
                  return s.type && (W.typeAnnotation = this.convertTypeAnnotation(s.type, s), W.typeAnnotation.loc = W.typeAnnotation.typeAnnotation.loc, W.typeAnnotation.range = W.typeAnnotation.typeAnnotation.range), W;
                }
                case e.ImportType:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSImportType, isTypeOf: !!s.isTypeOf, parameter: this.convertChild(s.argument), qualifier: this.convertChild(s.qualifier), typeParameters: s.typeArguments ? this.convertTypeArgumentsToTypeParameters(s.typeArguments, s) : null });
                case e.EnumDeclaration: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.TSEnumDeclaration, id: this.convertChild(s.name), members: s.members.map((B) => this.convertChild(B)) });
                  return this.applyModifiersToResult(W, (0, z.getModifiers)(s)), this.fixExports(s, W);
                }
                case e.EnumMember: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.TSEnumMember, id: this.convertChild(s.name) });
                  return s.initializer && (W.initializer = this.convertChild(s.initializer)), s.name.kind === oe.SyntaxKind.ComputedPropertyName && (W.computed = true), W;
                }
                case e.ModuleDeclaration: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.TSModuleDeclaration, id: this.convertChild(s.name) });
                  return s.body && (W.body = this.convertChild(s.body)), this.applyModifiersToResult(W, (0, z.getModifiers)(s)), s.flags & oe.NodeFlags.GlobalAugmentation && (W.global = true), this.fixExports(s, W);
                }
                case e.ParenthesizedType:
                  return this.convertType(s.type);
                case e.UnionType:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSUnionType, types: s.types.map((W) => this.convertType(W)) });
                case e.IntersectionType:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSIntersectionType, types: s.types.map((W) => this.convertType(W)) });
                case e.AsExpression:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSAsExpression, expression: this.convertChild(s.expression), typeAnnotation: this.convertType(s.type) });
                case e.InferType:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSInferType, typeParameter: this.convertType(s.typeParameter) });
                case e.LiteralType:
                  return N.typescriptVersionIsAtLeast["4.0"] && s.literal.kind === e.NullKeyword ? this.createNode(s.literal, { type: E.AST_NODE_TYPES.TSNullKeyword }) : this.createNode(s, { type: E.AST_NODE_TYPES.TSLiteralType, literal: this.convertType(s.literal) });
                case e.TypeAssertionExpression:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSTypeAssertion, typeAnnotation: this.convertType(s.type), expression: this.convertChild(s.expression) });
                case e.ImportEqualsDeclaration:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSImportEqualsDeclaration, id: this.convertChild(s.name), moduleReference: this.convertChild(s.moduleReference), importKind: s.isTypeOnly ? "type" : "value", isExport: (0, I.hasModifier)(e.ExportKeyword, s) });
                case e.ExternalModuleReference:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSExternalModuleReference, expression: this.convertChild(s.expression) });
                case e.NamespaceExportDeclaration:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSNamespaceExportDeclaration, id: this.convertChild(s.name) });
                case e.AbstractKeyword:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSAbstractKeyword });
                case e.TupleType: {
                  let W = "elementTypes" in s ? s.elementTypes.map((B) => this.convertType(B)) : s.elements.map((B) => this.convertType(B));
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSTupleType, elementTypes: W });
                }
                case e.NamedTupleMember: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.TSNamedTupleMember, elementType: this.convertType(s.type, s), label: this.convertChild(s.name, s), optional: s.questionToken != null });
                  return s.dotDotDotToken ? (W.range[0] = W.label.range[0], W.loc.start = W.label.loc.start, this.createNode(s, { type: E.AST_NODE_TYPES.TSRestType, typeAnnotation: W })) : W;
                }
                case e.OptionalType:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSOptionalType, typeAnnotation: this.convertType(s.type) });
                case e.RestType:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSRestType, typeAnnotation: this.convertType(s.type) });
                case e.TemplateLiteralType: {
                  let W = this.createNode(s, { type: E.AST_NODE_TYPES.TSTemplateLiteralType, quasis: [this.convertChild(s.head)], types: [] });
                  return s.templateSpans.forEach((B) => {
                    W.types.push(this.convertChild(B.type)), W.quasis.push(this.convertChild(B.literal));
                  }), W;
                }
                case e.ClassStaticBlockDeclaration:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.StaticBlock, body: this.convertBodyExpressions(s.body.statements, s) });
                case e.AssertEntry:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.ImportAttribute, key: this.convertChild(s.name), value: this.convertChild(s.value) });
                case e.SatisfiesExpression:
                  return this.createNode(s, { type: E.AST_NODE_TYPES.TSSatisfiesExpression, expression: this.convertChild(s.expression), typeAnnotation: this.convertChild(s.type) });
                default:
                  return this.deeplyCopy(s);
              }
            }
          }, "x");
          a.Converter = x;
        } }), go = {};
        bl(go, { __assign: () => hl, __asyncDelegator: () => CE, __asyncGenerator: () => SE, __asyncValues: () => DE, __await: () => ju, __awaiter: () => yE, __classPrivateFieldGet: () => kE, __classPrivateFieldSet: () => PE, __createBinding: () => vE, __decorate: () => dE, __exportStar: () => bE, __extends: () => pE, __generator: () => hE, __importDefault: () => AE, __importStar: () => wE, __makeTemplateObject: () => xE, __metadata: () => gE, __param: () => mE, __read: () => Zg, __rest: () => fE, __spread: () => EE, __spreadArrays: () => TE, __values: () => Up });
        function pE(a, c) {
          yl(a, c);
          function A() {
            this.constructor = a;
          }
          __name(A, "A");
          a.prototype = c === null ? Object.create(c) : (A.prototype = c.prototype, new A());
        }
        __name(pE, "pE");
        function fE(a, c) {
          var A = {};
          for (var T in a)
            Object.prototype.hasOwnProperty.call(a, T) && c.indexOf(T) < 0 && (A[T] = a[T]);
          if (a != null && typeof Object.getOwnPropertySymbols == "function")
            for (var oe = 0, T = Object.getOwnPropertySymbols(a); oe < T.length; oe++)
              c.indexOf(T[oe]) < 0 && Object.prototype.propertyIsEnumerable.call(a, T[oe]) && (A[T[oe]] = a[T[oe]]);
          return A;
        }
        __name(fE, "fE");
        function dE(a, c, A, T) {
          var oe = arguments.length, z = oe < 3 ? c : T === null ? T = Object.getOwnPropertyDescriptor(c, A) : T, I;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            z = Reflect.decorate(a, c, A, T);
          else
            for (var E = a.length - 1; E >= 0; E--)
              (I = a[E]) && (z = (oe < 3 ? I(z) : oe > 3 ? I(c, A, z) : I(c, A)) || z);
          return oe > 3 && z && Object.defineProperty(c, A, z), z;
        }
        __name(dE, "dE");
        function mE(a, c) {
          return function(A, T) {
            c(A, T, a);
          };
        }
        __name(mE, "mE");
        function gE(a, c) {
          if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
            return Reflect.metadata(a, c);
        }
        __name(gE, "gE");
        function yE(a, c, A, T) {
          function oe(z) {
            return z instanceof A ? z : new A(function(I) {
              I(z);
            });
          }
          __name(oe, "oe");
          return new (A || (A = Promise))(function(z, I) {
            function E(t) {
              try {
                e(T.next(t));
              } catch (x) {
                I(x);
              }
            }
            __name(E, "E");
            function N(t) {
              try {
                e(T.throw(t));
              } catch (x) {
                I(x);
              }
            }
            __name(N, "N");
            function e(t) {
              t.done ? z(t.value) : oe(t.value).then(E, N);
            }
            __name(e, "e");
            e((T = T.apply(a, c || [])).next());
          });
        }
        __name(yE, "yE");
        function hE(a, c) {
          var A = { label: 0, sent: function() {
            if (z[0] & 1)
              throw z[1];
            return z[1];
          }, trys: [], ops: [] }, T, oe, z, I;
          return I = { next: E(0), throw: E(1), return: E(2) }, typeof Symbol == "function" && (I[Symbol.iterator] = function() {
            return this;
          }), I;
          function E(e) {
            return function(t) {
              return N([e, t]);
            };
          }
          __name(E, "E");
          function N(e) {
            if (T)
              throw new TypeError("Generator is already executing.");
            for (; A; )
              try {
                if (T = 1, oe && (z = e[0] & 2 ? oe.return : e[0] ? oe.throw || ((z = oe.return) && z.call(oe), 0) : oe.next) && !(z = z.call(oe, e[1])).done)
                  return z;
                switch (oe = 0, z && (e = [e[0] & 2, z.value]), e[0]) {
                  case 0:
                  case 1:
                    z = e;
                    break;
                  case 4:
                    return A.label++, { value: e[1], done: false };
                  case 5:
                    A.label++, oe = e[1], e = [0];
                    continue;
                  case 7:
                    e = A.ops.pop(), A.trys.pop();
                    continue;
                  default:
                    if (z = A.trys, !(z = z.length > 0 && z[z.length - 1]) && (e[0] === 6 || e[0] === 2)) {
                      A = 0;
                      continue;
                    }
                    if (e[0] === 3 && (!z || e[1] > z[0] && e[1] < z[3])) {
                      A.label = e[1];
                      break;
                    }
                    if (e[0] === 6 && A.label < z[1]) {
                      A.label = z[1], z = e;
                      break;
                    }
                    if (z && A.label < z[2]) {
                      A.label = z[2], A.ops.push(e);
                      break;
                    }
                    z[2] && A.ops.pop(), A.trys.pop();
                    continue;
                }
                e = c.call(a, A);
              } catch (t) {
                e = [6, t], oe = 0;
              } finally {
                T = z = 0;
              }
            if (e[0] & 5)
              throw e[1];
            return { value: e[0] ? e[1] : void 0, done: true };
          }
          __name(N, "N");
        }
        __name(hE, "hE");
        function vE(a, c, A, T) {
          T === void 0 && (T = A), a[T] = c[A];
        }
        __name(vE, "vE");
        function bE(a, c) {
          for (var A in a)
            A !== "default" && !c.hasOwnProperty(A) && (c[A] = a[A]);
        }
        __name(bE, "bE");
        function Up(a) {
          var c = typeof Symbol == "function" && Symbol.iterator, A = c && a[c], T = 0;
          if (A)
            return A.call(a);
          if (a && typeof a.length == "number")
            return { next: function() {
              return a && T >= a.length && (a = void 0), { value: a && a[T++], done: !a };
            } };
          throw new TypeError(c ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        __name(Up, "Up");
        function Zg(a, c) {
          var A = typeof Symbol == "function" && a[Symbol.iterator];
          if (!A)
            return a;
          var T = A.call(a), oe, z = [], I;
          try {
            for (; (c === void 0 || c-- > 0) && !(oe = T.next()).done; )
              z.push(oe.value);
          } catch (E) {
            I = { error: E };
          } finally {
            try {
              oe && !oe.done && (A = T.return) && A.call(T);
            } finally {
              if (I)
                throw I.error;
            }
          }
          return z;
        }
        __name(Zg, "Zg");
        function EE() {
          for (var a = [], c = 0; c < arguments.length; c++)
            a = a.concat(Zg(arguments[c]));
          return a;
        }
        __name(EE, "EE");
        function TE() {
          for (var a = 0, c = 0, A = arguments.length; c < A; c++)
            a += arguments[c].length;
          for (var T = Array(a), oe = 0, c = 0; c < A; c++)
            for (var z = arguments[c], I = 0, E = z.length; I < E; I++, oe++)
              T[oe] = z[I];
          return T;
        }
        __name(TE, "TE");
        function ju(a) {
          return this instanceof ju ? (this.v = a, this) : new ju(a);
        }
        __name(ju, "ju");
        function SE(a, c, A) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var T = A.apply(a, c || []), oe, z = [];
          return oe = {}, I("next"), I("throw"), I("return"), oe[Symbol.asyncIterator] = function() {
            return this;
          }, oe;
          function I(s) {
            T[s] && (oe[s] = function(q) {
              return new Promise(function(F, fe) {
                z.push([s, q, F, fe]) > 1 || E(s, q);
              });
            });
          }
          __name(I, "I");
          function E(s, q) {
            try {
              N(T[s](q));
            } catch (F) {
              x(z[0][3], F);
            }
          }
          __name(E, "E");
          function N(s) {
            s.value instanceof ju ? Promise.resolve(s.value.v).then(e, t) : x(z[0][2], s);
          }
          __name(N, "N");
          function e(s) {
            E("next", s);
          }
          __name(e, "e");
          function t(s) {
            E("throw", s);
          }
          __name(t, "t");
          function x(s, q) {
            s(q), z.shift(), z.length && E(z[0][0], z[0][1]);
          }
          __name(x, "x");
        }
        __name(SE, "SE");
        function CE(a) {
          var c, A;
          return c = {}, T("next"), T("throw", function(oe) {
            throw oe;
          }), T("return"), c[Symbol.iterator] = function() {
            return this;
          }, c;
          function T(oe, z) {
            c[oe] = a[oe] ? function(I) {
              return (A = !A) ? { value: ju(a[oe](I)), done: oe === "return" } : z ? z(I) : I;
            } : z;
          }
          __name(T, "T");
        }
        __name(CE, "CE");
        function DE(a) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var c = a[Symbol.asyncIterator], A;
          return c ? c.call(a) : (a = typeof Up == "function" ? Up(a) : a[Symbol.iterator](), A = {}, T("next"), T("throw"), T("return"), A[Symbol.asyncIterator] = function() {
            return this;
          }, A);
          function T(z) {
            A[z] = a[z] && function(I) {
              return new Promise(function(E, N) {
                I = a[z](I), oe(E, N, I.done, I.value);
              });
            };
          }
          __name(T, "T");
          function oe(z, I, E, N) {
            Promise.resolve(N).then(function(e) {
              z({ value: e, done: E });
            }, I);
          }
          __name(oe, "oe");
        }
        __name(DE, "DE");
        function xE(a, c) {
          return Object.defineProperty ? Object.defineProperty(a, "raw", { value: c }) : a.raw = c, a;
        }
        __name(xE, "xE");
        function wE(a) {
          if (a && a.__esModule)
            return a;
          var c = {};
          if (a != null)
            for (var A in a)
              Object.hasOwnProperty.call(a, A) && (c[A] = a[A]);
          return c.default = a, c;
        }
        __name(wE, "wE");
        function AE(a) {
          return a && a.__esModule ? a : { default: a };
        }
        __name(AE, "AE");
        function kE(a, c) {
          if (!c.has(a))
            throw new TypeError("attempted to get private field on non-instance");
          return c.get(a);
        }
        __name(kE, "kE");
        function PE(a, c, A) {
          if (!c.has(a))
            throw new TypeError("attempted to set private field on non-instance");
          return c.set(a, A), A;
        }
        __name(PE, "PE");
        var yl, hl, Vo = Ju({ "node_modules/tslib/tslib.es6.js"() {
          Jr(), yl = /* @__PURE__ */ __name(function(a, c) {
            return yl = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(A, T) {
              A.__proto__ = T;
            } || function(A, T) {
              for (var oe in T)
                T.hasOwnProperty(oe) && (A[oe] = T[oe]);
            }, yl(a, c);
          }, "yl"), hl = /* @__PURE__ */ __name(function() {
            return hl = Object.assign || function(c) {
              for (var A, T = 1, oe = arguments.length; T < oe; T++) {
                A = arguments[T];
                for (var z in A)
                  Object.prototype.hasOwnProperty.call(A, z) && (c[z] = A[z]);
              }
              return c;
            }, hl.apply(this, arguments);
          }, "hl");
        } }), NE = Ur({ "node_modules/tsutils/typeguard/2.8/node.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.isExpressionStatement = a.isExpression = a.isExportSpecifier = a.isExportDeclaration = a.isExportAssignment = a.isEnumMember = a.isEnumDeclaration = a.isEntityNameExpression = a.isEntityName = a.isEmptyStatement = a.isElementAccessExpression = a.isDoStatement = a.isDeleteExpression = a.isDefaultClause = a.isDecorator = a.isDebuggerStatement = a.isComputedPropertyName = a.isContinueStatement = a.isConstructSignatureDeclaration = a.isConstructorTypeNode = a.isConstructorDeclaration = a.isConditionalTypeNode = a.isConditionalExpression = a.isCommaListExpression = a.isClassLikeDeclaration = a.isClassExpression = a.isClassDeclaration = a.isCatchClause = a.isCaseOrDefaultClause = a.isCaseClause = a.isCaseBlock = a.isCallSignatureDeclaration = a.isCallLikeExpression = a.isCallExpression = a.isBreakStatement = a.isBreakOrContinueStatement = a.isBooleanLiteral = a.isBlockLike = a.isBlock = a.isBindingPattern = a.isBindingElement = a.isBinaryExpression = a.isAwaitExpression = a.isAssertionExpression = a.isAsExpression = a.isArrowFunction = a.isArrayTypeNode = a.isArrayLiteralExpression = a.isArrayBindingPattern = a.isAccessorDeclaration = void 0, a.isNamespaceImport = a.isNamespaceDeclaration = a.isNamedImports = a.isNamedExports = a.isModuleDeclaration = a.isModuleBlock = a.isMethodSignature = a.isMethodDeclaration = a.isMetaProperty = a.isMappedTypeNode = a.isLiteralTypeNode = a.isLiteralExpression = a.isLabeledStatement = a.isJsxText = a.isJsxSpreadAttribute = a.isJsxSelfClosingElement = a.isJsxOpeningLikeElement = a.isJsxOpeningFragment = a.isJsxOpeningElement = a.isJsxFragment = a.isJsxExpression = a.isJsxElement = a.isJsxClosingFragment = a.isJsxClosingElement = a.isJsxAttributes = a.isJsxAttributeLike = a.isJsxAttribute = a.isJsDoc = a.isIterationStatement = a.isIntersectionTypeNode = a.isInterfaceDeclaration = a.isInferTypeNode = a.isIndexSignatureDeclaration = a.isIndexedAccessTypeNode = a.isImportSpecifier = a.isImportEqualsDeclaration = a.isImportDeclaration = a.isImportClause = a.isIfStatement = a.isIdentifier = a.isGetAccessorDeclaration = a.isFunctionTypeNode = a.isFunctionExpression = a.isFunctionDeclaration = a.isForStatement = a.isForOfStatement = a.isForInOrOfStatement = a.isForInStatement = a.isExternalModuleReference = a.isExpressionWithTypeArguments = void 0, a.isVariableStatement = a.isVariableDeclaration = a.isUnionTypeNode = a.isTypeQueryNode = a.isTypeReferenceNode = a.isTypePredicateNode = a.isTypeParameterDeclaration = a.isTypeOperatorNode = a.isTypeOfExpression = a.isTypeLiteralNode = a.isTypeAssertion = a.isTypeAliasDeclaration = a.isTupleTypeNode = a.isTryStatement = a.isThrowStatement = a.isTextualLiteral = a.isTemplateLiteral = a.isTemplateExpression = a.isTaggedTemplateExpression = a.isSyntaxList = a.isSwitchStatement = a.isStringLiteral = a.isSpreadElement = a.isSpreadAssignment = a.isSourceFile = a.isSignatureDeclaration = a.isShorthandPropertyAssignment = a.isSetAccessorDeclaration = a.isReturnStatement = a.isRegularExpressionLiteral = a.isQualifiedName = a.isPropertySignature = a.isPropertyDeclaration = a.isPropertyAssignment = a.isPropertyAccessExpression = a.isPrefixUnaryExpression = a.isPostfixUnaryExpression = a.isParenthesizedTypeNode = a.isParenthesizedExpression = a.isParameterDeclaration = a.isOmittedExpression = a.isObjectLiteralExpression = a.isObjectBindingPattern = a.isNumericOrStringLikeLiteral = a.isNumericLiteral = a.isNullLiteral = a.isNoSubstitutionTemplateLiteral = a.isNonNullExpression = a.isNewExpression = a.isNamespaceExportDeclaration = void 0, a.isWithStatement = a.isWhileStatement = a.isVoidExpression = a.isVariableDeclarationList = void 0;
          var c = xi();
          function A(_e) {
            return _e.kind === c.SyntaxKind.GetAccessor || _e.kind === c.SyntaxKind.SetAccessor;
          }
          __name(A, "A");
          a.isAccessorDeclaration = A;
          function T(_e) {
            return _e.kind === c.SyntaxKind.ArrayBindingPattern;
          }
          __name(T, "T");
          a.isArrayBindingPattern = T;
          function oe(_e) {
            return _e.kind === c.SyntaxKind.ArrayLiteralExpression;
          }
          __name(oe, "oe");
          a.isArrayLiteralExpression = oe;
          function z(_e) {
            return _e.kind === c.SyntaxKind.ArrayType;
          }
          __name(z, "z");
          a.isArrayTypeNode = z;
          function I(_e) {
            return _e.kind === c.SyntaxKind.ArrowFunction;
          }
          __name(I, "I");
          a.isArrowFunction = I;
          function E(_e) {
            return _e.kind === c.SyntaxKind.AsExpression;
          }
          __name(E, "E");
          a.isAsExpression = E;
          function N(_e) {
            return _e.kind === c.SyntaxKind.AsExpression || _e.kind === c.SyntaxKind.TypeAssertionExpression;
          }
          __name(N, "N");
          a.isAssertionExpression = N;
          function e(_e) {
            return _e.kind === c.SyntaxKind.AwaitExpression;
          }
          __name(e, "e");
          a.isAwaitExpression = e;
          function t(_e) {
            return _e.kind === c.SyntaxKind.BinaryExpression;
          }
          __name(t, "t");
          a.isBinaryExpression = t;
          function x(_e) {
            return _e.kind === c.SyntaxKind.BindingElement;
          }
          __name(x, "x");
          a.isBindingElement = x;
          function s(_e) {
            return _e.kind === c.SyntaxKind.ArrayBindingPattern || _e.kind === c.SyntaxKind.ObjectBindingPattern;
          }
          __name(s, "s");
          a.isBindingPattern = s;
          function q(_e) {
            return _e.kind === c.SyntaxKind.Block;
          }
          __name(q, "q");
          a.isBlock = q;
          function F(_e) {
            return _e.statements !== void 0;
          }
          __name(F, "F");
          a.isBlockLike = F;
          function fe(_e) {
            return _e.kind === c.SyntaxKind.TrueKeyword || _e.kind === c.SyntaxKind.FalseKeyword;
          }
          __name(fe, "fe");
          a.isBooleanLiteral = fe;
          function Te(_e) {
            return _e.kind === c.SyntaxKind.BreakStatement || _e.kind === c.SyntaxKind.ContinueStatement;
          }
          __name(Te, "Te");
          a.isBreakOrContinueStatement = Te;
          function Se(_e) {
            return _e.kind === c.SyntaxKind.BreakStatement;
          }
          __name(Se, "Se");
          a.isBreakStatement = Se;
          function J(_e) {
            return _e.kind === c.SyntaxKind.CallExpression;
          }
          __name(J, "J");
          a.isCallExpression = J;
          function se(_e) {
            switch (_e.kind) {
              case c.SyntaxKind.CallExpression:
              case c.SyntaxKind.Decorator:
              case c.SyntaxKind.JsxOpeningElement:
              case c.SyntaxKind.JsxSelfClosingElement:
              case c.SyntaxKind.NewExpression:
              case c.SyntaxKind.TaggedTemplateExpression:
                return true;
              default:
                return false;
            }
          }
          __name(se, "se");
          a.isCallLikeExpression = se;
          function Le(_e) {
            return _e.kind === c.SyntaxKind.CallSignature;
          }
          __name(Le, "Le");
          a.isCallSignatureDeclaration = Le;
          function Q(_e) {
            return _e.kind === c.SyntaxKind.CaseBlock;
          }
          __name(Q, "Q");
          a.isCaseBlock = Q;
          function Be(_e) {
            return _e.kind === c.SyntaxKind.CaseClause;
          }
          __name(Be, "Be");
          a.isCaseClause = Be;
          function je(_e) {
            return _e.kind === c.SyntaxKind.CaseClause || _e.kind === c.SyntaxKind.DefaultClause;
          }
          __name(je, "je");
          a.isCaseOrDefaultClause = je;
          function W(_e) {
            return _e.kind === c.SyntaxKind.CatchClause;
          }
          __name(W, "W");
          a.isCatchClause = W;
          function B(_e) {
            return _e.kind === c.SyntaxKind.ClassDeclaration;
          }
          __name(B, "B");
          a.isClassDeclaration = B;
          function U(_e) {
            return _e.kind === c.SyntaxKind.ClassExpression;
          }
          __name(U, "U");
          a.isClassExpression = U;
          function m(_e) {
            return _e.kind === c.SyntaxKind.ClassDeclaration || _e.kind === c.SyntaxKind.ClassExpression;
          }
          __name(m, "m");
          a.isClassLikeDeclaration = m;
          function v(_e) {
            return _e.kind === c.SyntaxKind.CommaListExpression;
          }
          __name(v, "v");
          a.isCommaListExpression = v;
          function g(_e) {
            return _e.kind === c.SyntaxKind.ConditionalExpression;
          }
          __name(g, "g");
          a.isConditionalExpression = g;
          function O(_e) {
            return _e.kind === c.SyntaxKind.ConditionalType;
          }
          __name(O, "O");
          a.isConditionalTypeNode = O;
          function S(_e) {
            return _e.kind === c.SyntaxKind.Constructor;
          }
          __name(S, "S");
          a.isConstructorDeclaration = S;
          function te(_e) {
            return _e.kind === c.SyntaxKind.ConstructorType;
          }
          __name(te, "te");
          a.isConstructorTypeNode = te;
          function Je(_e) {
            return _e.kind === c.SyntaxKind.ConstructSignature;
          }
          __name(Je, "Je");
          a.isConstructSignatureDeclaration = Je;
          function qe(_e) {
            return _e.kind === c.SyntaxKind.ContinueStatement;
          }
          __name(qe, "qe");
          a.isContinueStatement = qe;
          function ge(_e) {
            return _e.kind === c.SyntaxKind.ComputedPropertyName;
          }
          __name(ge, "ge");
          a.isComputedPropertyName = ge;
          function ie(_e) {
            return _e.kind === c.SyntaxKind.DebuggerStatement;
          }
          __name(ie, "ie");
          a.isDebuggerStatement = ie;
          function G(_e) {
            return _e.kind === c.SyntaxKind.Decorator;
          }
          __name(G, "G");
          a.isDecorator = G;
          function pe(_e) {
            return _e.kind === c.SyntaxKind.DefaultClause;
          }
          __name(pe, "pe");
          a.isDefaultClause = pe;
          function j(_e) {
            return _e.kind === c.SyntaxKind.DeleteExpression;
          }
          __name(j, "j");
          a.isDeleteExpression = j;
          function be(_e) {
            return _e.kind === c.SyntaxKind.DoStatement;
          }
          __name(be, "be");
          a.isDoStatement = be;
          function $e(_e) {
            return _e.kind === c.SyntaxKind.ElementAccessExpression;
          }
          __name($e, "$e");
          a.isElementAccessExpression = $e;
          function Re(_e) {
            return _e.kind === c.SyntaxKind.EmptyStatement;
          }
          __name(Re, "Re");
          a.isEmptyStatement = Re;
          function Fe(_e) {
            return _e.kind === c.SyntaxKind.Identifier || ei(_e);
          }
          __name(Fe, "Fe");
          a.isEntityName = Fe;
          function dr(_e) {
            return _e.kind === c.SyntaxKind.Identifier || ln(_e) && dr(_e.expression);
          }
          __name(dr, "dr");
          a.isEntityNameExpression = dr;
          function ze(_e) {
            return _e.kind === c.SyntaxKind.EnumDeclaration;
          }
          __name(ze, "ze");
          a.isEnumDeclaration = ze;
          function ve(_e) {
            return _e.kind === c.SyntaxKind.EnumMember;
          }
          __name(ve, "ve");
          a.isEnumMember = ve;
          function er(_e) {
            return _e.kind === c.SyntaxKind.ExportAssignment;
          }
          __name(er, "er");
          a.isExportAssignment = er;
          function ar(_e) {
            return _e.kind === c.SyntaxKind.ExportDeclaration;
          }
          __name(ar, "ar");
          a.isExportDeclaration = ar;
          function Cr(_e) {
            return _e.kind === c.SyntaxKind.ExportSpecifier;
          }
          __name(Cr, "Cr");
          a.isExportSpecifier = Cr;
          function Ce(_e) {
            switch (_e.kind) {
              case c.SyntaxKind.ArrayLiteralExpression:
              case c.SyntaxKind.ArrowFunction:
              case c.SyntaxKind.AsExpression:
              case c.SyntaxKind.AwaitExpression:
              case c.SyntaxKind.BinaryExpression:
              case c.SyntaxKind.CallExpression:
              case c.SyntaxKind.ClassExpression:
              case c.SyntaxKind.CommaListExpression:
              case c.SyntaxKind.ConditionalExpression:
              case c.SyntaxKind.DeleteExpression:
              case c.SyntaxKind.ElementAccessExpression:
              case c.SyntaxKind.FalseKeyword:
              case c.SyntaxKind.FunctionExpression:
              case c.SyntaxKind.Identifier:
              case c.SyntaxKind.JsxElement:
              case c.SyntaxKind.JsxFragment:
              case c.SyntaxKind.JsxExpression:
              case c.SyntaxKind.JsxOpeningElement:
              case c.SyntaxKind.JsxOpeningFragment:
              case c.SyntaxKind.JsxSelfClosingElement:
              case c.SyntaxKind.MetaProperty:
              case c.SyntaxKind.NewExpression:
              case c.SyntaxKind.NonNullExpression:
              case c.SyntaxKind.NoSubstitutionTemplateLiteral:
              case c.SyntaxKind.NullKeyword:
              case c.SyntaxKind.NumericLiteral:
              case c.SyntaxKind.ObjectLiteralExpression:
              case c.SyntaxKind.OmittedExpression:
              case c.SyntaxKind.ParenthesizedExpression:
              case c.SyntaxKind.PostfixUnaryExpression:
              case c.SyntaxKind.PrefixUnaryExpression:
              case c.SyntaxKind.PropertyAccessExpression:
              case c.SyntaxKind.RegularExpressionLiteral:
              case c.SyntaxKind.SpreadElement:
              case c.SyntaxKind.StringLiteral:
              case c.SyntaxKind.SuperKeyword:
              case c.SyntaxKind.TaggedTemplateExpression:
              case c.SyntaxKind.TemplateExpression:
              case c.SyntaxKind.ThisKeyword:
              case c.SyntaxKind.TrueKeyword:
              case c.SyntaxKind.TypeAssertionExpression:
              case c.SyntaxKind.TypeOfExpression:
              case c.SyntaxKind.VoidExpression:
              case c.SyntaxKind.YieldExpression:
                return true;
              default:
                return false;
            }
          }
          __name(Ce, "Ce");
          a.isExpression = Ce;
          function Xe(_e) {
            return _e.kind === c.SyntaxKind.ExpressionStatement;
          }
          __name(Xe, "Xe");
          a.isExpressionStatement = Xe;
          function gr(_e) {
            return _e.kind === c.SyntaxKind.ExpressionWithTypeArguments;
          }
          __name(gr, "gr");
          a.isExpressionWithTypeArguments = gr;
          function X(_e) {
            return _e.kind === c.SyntaxKind.ExternalModuleReference;
          }
          __name(X, "X");
          a.isExternalModuleReference = X;
          function Ee(_e) {
            return _e.kind === c.SyntaxKind.ForInStatement;
          }
          __name(Ee, "Ee");
          a.isForInStatement = Ee;
          function we(_e) {
            return _e.kind === c.SyntaxKind.ForOfStatement || _e.kind === c.SyntaxKind.ForInStatement;
          }
          __name(we, "we");
          a.isForInOrOfStatement = we;
          function he(_e) {
            return _e.kind === c.SyntaxKind.ForOfStatement;
          }
          __name(he, "he");
          a.isForOfStatement = he;
          function yr(_e) {
            return _e.kind === c.SyntaxKind.ForStatement;
          }
          __name(yr, "yr");
          a.isForStatement = yr;
          function kr(_e) {
            return _e.kind === c.SyntaxKind.FunctionDeclaration;
          }
          __name(kr, "kr");
          a.isFunctionDeclaration = kr;
          function nr(_e) {
            return _e.kind === c.SyntaxKind.FunctionExpression;
          }
          __name(nr, "nr");
          a.isFunctionExpression = nr;
          function tr(_e) {
            return _e.kind === c.SyntaxKind.FunctionType;
          }
          __name(tr, "tr");
          a.isFunctionTypeNode = tr;
          function Lr(_e) {
            return _e.kind === c.SyntaxKind.GetAccessor;
          }
          __name(Lr, "Lr");
          a.isGetAccessorDeclaration = Lr;
          function zr(_e) {
            return _e.kind === c.SyntaxKind.Identifier;
          }
          __name(zr, "zr");
          a.isIdentifier = zr;
          function ye(_e) {
            return _e.kind === c.SyntaxKind.IfStatement;
          }
          __name(ye, "ye");
          a.isIfStatement = ye;
          function ir(_e) {
            return _e.kind === c.SyntaxKind.ImportClause;
          }
          __name(ir, "ir");
          a.isImportClause = ir;
          function Dr(_e) {
            return _e.kind === c.SyntaxKind.ImportDeclaration;
          }
          __name(Dr, "Dr");
          a.isImportDeclaration = Dr;
          function Pr(_e) {
            return _e.kind === c.SyntaxKind.ImportEqualsDeclaration;
          }
          __name(Pr, "Pr");
          a.isImportEqualsDeclaration = Pr;
          function Br(_e) {
            return _e.kind === c.SyntaxKind.ImportSpecifier;
          }
          __name(Br, "Br");
          a.isImportSpecifier = Br;
          function ut(_e) {
            return _e.kind === c.SyntaxKind.IndexedAccessType;
          }
          __name(ut, "ut");
          a.isIndexedAccessTypeNode = ut;
          function rt(_e) {
            return _e.kind === c.SyntaxKind.IndexSignature;
          }
          __name(rt, "rt");
          a.isIndexSignatureDeclaration = rt;
          function Z(_e) {
            return _e.kind === c.SyntaxKind.InferType;
          }
          __name(Z, "Z");
          a.isInferTypeNode = Z;
          function f(_e) {
            return _e.kind === c.SyntaxKind.InterfaceDeclaration;
          }
          __name(f, "f");
          a.isInterfaceDeclaration = f;
          function h(_e) {
            return _e.kind === c.SyntaxKind.IntersectionType;
          }
          __name(h, "h");
          a.isIntersectionTypeNode = h;
          function ae(_e) {
            switch (_e.kind) {
              case c.SyntaxKind.ForStatement:
              case c.SyntaxKind.ForOfStatement:
              case c.SyntaxKind.ForInStatement:
              case c.SyntaxKind.WhileStatement:
              case c.SyntaxKind.DoStatement:
                return true;
              default:
                return false;
            }
          }
          __name(ae, "ae");
          a.isIterationStatement = ae;
          function xr(_e) {
            return _e.kind === c.SyntaxKind.JSDocComment;
          }
          __name(xr, "xr");
          a.isJsDoc = xr;
          function jr(_e) {
            return _e.kind === c.SyntaxKind.JsxAttribute;
          }
          __name(jr, "jr");
          a.isJsxAttribute = jr;
          function qr(_e) {
            return _e.kind === c.SyntaxKind.JsxAttribute || _e.kind === c.SyntaxKind.JsxSpreadAttribute;
          }
          __name(qr, "qr");
          a.isJsxAttributeLike = qr;
          function pt(_e) {
            return _e.kind === c.SyntaxKind.JsxAttributes;
          }
          __name(pt, "pt");
          a.isJsxAttributes = pt;
          function Ge(_e) {
            return _e.kind === c.SyntaxKind.JsxClosingElement;
          }
          __name(Ge, "Ge");
          a.isJsxClosingElement = Ge;
          function K(_e) {
            return _e.kind === c.SyntaxKind.JsxClosingFragment;
          }
          __name(K, "K");
          a.isJsxClosingFragment = K;
          function r(_e) {
            return _e.kind === c.SyntaxKind.JsxElement;
          }
          __name(r, "r");
          a.isJsxElement = r;
          function ct(_e) {
            return _e.kind === c.SyntaxKind.JsxExpression;
          }
          __name(ct, "ct");
          a.isJsxExpression = ct;
          function ft(_e) {
            return _e.kind === c.SyntaxKind.JsxFragment;
          }
          __name(ft, "ft");
          a.isJsxFragment = ft;
          function Ie(_e) {
            return _e.kind === c.SyntaxKind.JsxOpeningElement;
          }
          __name(Ie, "Ie");
          a.isJsxOpeningElement = Ie;
          function me(_e) {
            return _e.kind === c.SyntaxKind.JsxOpeningFragment;
          }
          __name(me, "me");
          a.isJsxOpeningFragment = me;
          function xe(_e) {
            return _e.kind === c.SyntaxKind.JsxOpeningElement || _e.kind === c.SyntaxKind.JsxSelfClosingElement;
          }
          __name(xe, "xe");
          a.isJsxOpeningLikeElement = xe;
          function Ye(_e) {
            return _e.kind === c.SyntaxKind.JsxSelfClosingElement;
          }
          __name(Ye, "Ye");
          a.isJsxSelfClosingElement = Ye;
          function vr(_e) {
            return _e.kind === c.SyntaxKind.JsxSpreadAttribute;
          }
          __name(vr, "vr");
          a.isJsxSpreadAttribute = vr;
          function nt(_e) {
            return _e.kind === c.SyntaxKind.JsxText;
          }
          __name(nt, "nt");
          a.isJsxText = nt;
          function pr(_e) {
            return _e.kind === c.SyntaxKind.LabeledStatement;
          }
          __name(pr, "pr");
          a.isLabeledStatement = pr;
          function Mr(_e) {
            return _e.kind >= c.SyntaxKind.FirstLiteralToken && _e.kind <= c.SyntaxKind.LastLiteralToken;
          }
          __name(Mr, "Mr");
          a.isLiteralExpression = Mr;
          function ot(_e) {
            return _e.kind === c.SyntaxKind.LiteralType;
          }
          __name(ot, "ot");
          a.isLiteralTypeNode = ot;
          function At(_e) {
            return _e.kind === c.SyntaxKind.MappedType;
          }
          __name(At, "At");
          a.isMappedTypeNode = At;
          function re(_e) {
            return _e.kind === c.SyntaxKind.MetaProperty;
          }
          __name(re, "re");
          a.isMetaProperty = re;
          function de(_e) {
            return _e.kind === c.SyntaxKind.MethodDeclaration;
          }
          __name(de, "de");
          a.isMethodDeclaration = de;
          function He(_e) {
            return _e.kind === c.SyntaxKind.MethodSignature;
          }
          __name(He, "He");
          a.isMethodSignature = He;
          function Nr(_e) {
            return _e.kind === c.SyntaxKind.ModuleBlock;
          }
          __name(Nr, "Nr");
          a.isModuleBlock = Nr;
          function Yr(_e) {
            return _e.kind === c.SyntaxKind.ModuleDeclaration;
          }
          __name(Yr, "Yr");
          a.isModuleDeclaration = Yr;
          function St(_e) {
            return _e.kind === c.SyntaxKind.NamedExports;
          }
          __name(St, "St");
          a.isNamedExports = St;
          function Dt(_e) {
            return _e.kind === c.SyntaxKind.NamedImports;
          }
          __name(Dt, "Dt");
          a.isNamedImports = Dt;
          function Lt(_e) {
            return Yr(_e) && _e.name.kind === c.SyntaxKind.Identifier && _e.body !== void 0 && (_e.body.kind === c.SyntaxKind.ModuleBlock || Lt(_e.body));
          }
          __name(Lt, "Lt");
          a.isNamespaceDeclaration = Lt;
          function zt(_e) {
            return _e.kind === c.SyntaxKind.NamespaceImport;
          }
          __name(zt, "zt");
          a.isNamespaceImport = zt;
          function Zt(_e) {
            return _e.kind === c.SyntaxKind.NamespaceExportDeclaration;
          }
          __name(Zt, "Zt");
          a.isNamespaceExportDeclaration = Zt;
          function mt(_e) {
            return _e.kind === c.SyntaxKind.NewExpression;
          }
          __name(mt, "mt");
          a.isNewExpression = mt;
          function at(_e) {
            return _e.kind === c.SyntaxKind.NonNullExpression;
          }
          __name(at, "at");
          a.isNonNullExpression = at;
          function k(_e) {
            return _e.kind === c.SyntaxKind.NoSubstitutionTemplateLiteral;
          }
          __name(k, "k");
          a.isNoSubstitutionTemplateLiteral = k;
          function ue(_e) {
            return _e.kind === c.SyntaxKind.NullKeyword;
          }
          __name(ue, "ue");
          a.isNullLiteral = ue;
          function Qe(_e) {
            return _e.kind === c.SyntaxKind.NumericLiteral;
          }
          __name(Qe, "Qe");
          a.isNumericLiteral = Qe;
          function Sr(_e) {
            switch (_e.kind) {
              case c.SyntaxKind.StringLiteral:
              case c.SyntaxKind.NumericLiteral:
              case c.SyntaxKind.NoSubstitutionTemplateLiteral:
                return true;
              default:
                return false;
            }
          }
          __name(Sr, "Sr");
          a.isNumericOrStringLikeLiteral = Sr;
          function Kr(_e) {
            return _e.kind === c.SyntaxKind.ObjectBindingPattern;
          }
          __name(Kr, "Kr");
          a.isObjectBindingPattern = Kr;
          function Hr(_e) {
            return _e.kind === c.SyntaxKind.ObjectLiteralExpression;
          }
          __name(Hr, "Hr");
          a.isObjectLiteralExpression = Hr;
          function Ct(_e) {
            return _e.kind === c.SyntaxKind.OmittedExpression;
          }
          __name(Ct, "Ct");
          a.isOmittedExpression = Ct;
          function Xt(_e) {
            return _e.kind === c.SyntaxKind.Parameter;
          }
          __name(Xt, "Xt");
          a.isParameterDeclaration = Xt;
          function cn(_e) {
            return _e.kind === c.SyntaxKind.ParenthesizedExpression;
          }
          __name(cn, "cn");
          a.isParenthesizedExpression = cn;
          function In(_e) {
            return _e.kind === c.SyntaxKind.ParenthesizedType;
          }
          __name(In, "In");
          a.isParenthesizedTypeNode = In;
          function yn(_e) {
            return _e.kind === c.SyntaxKind.PostfixUnaryExpression;
          }
          __name(yn, "yn");
          a.isPostfixUnaryExpression = yn;
          function hn(_e) {
            return _e.kind === c.SyntaxKind.PrefixUnaryExpression;
          }
          __name(hn, "hn");
          a.isPrefixUnaryExpression = hn;
          function ln(_e) {
            return _e.kind === c.SyntaxKind.PropertyAccessExpression;
          }
          __name(ln, "ln");
          a.isPropertyAccessExpression = ln;
          function En(_e) {
            return _e.kind === c.SyntaxKind.PropertyAssignment;
          }
          __name(En, "En");
          a.isPropertyAssignment = En;
          function Vt(_e) {
            return _e.kind === c.SyntaxKind.PropertyDeclaration;
          }
          __name(Vt, "Vt");
          a.isPropertyDeclaration = Vt;
          function ui(_e) {
            return _e.kind === c.SyntaxKind.PropertySignature;
          }
          __name(ui, "ui");
          a.isPropertySignature = ui;
          function ei(_e) {
            return _e.kind === c.SyntaxKind.QualifiedName;
          }
          __name(ei, "ei");
          a.isQualifiedName = ei;
          function vi(_e) {
            return _e.kind === c.SyntaxKind.RegularExpressionLiteral;
          }
          __name(vi, "vi");
          a.isRegularExpressionLiteral = vi;
          function ri(_e) {
            return _e.kind === c.SyntaxKind.ReturnStatement;
          }
          __name(ri, "ri");
          a.isReturnStatement = ri;
          function bi(_e) {
            return _e.kind === c.SyntaxKind.SetAccessor;
          }
          __name(bi, "bi");
          a.isSetAccessorDeclaration = bi;
          function Qn(_e) {
            return _e.kind === c.SyntaxKind.ShorthandPropertyAssignment;
          }
          __name(Qn, "Qn");
          a.isShorthandPropertyAssignment = Qn;
          function Yn(_e) {
            return _e.parameters !== void 0;
          }
          __name(Yn, "Yn");
          a.isSignatureDeclaration = Yn;
          function oi(_e) {
            return _e.kind === c.SyntaxKind.SourceFile;
          }
          __name(oi, "oi");
          a.isSourceFile = oi;
          function Ei(_e) {
            return _e.kind === c.SyntaxKind.SpreadAssignment;
          }
          __name(Ei, "Ei");
          a.isSpreadAssignment = Ei;
          function Dn(_e) {
            return _e.kind === c.SyntaxKind.SpreadElement;
          }
          __name(Dn, "Dn");
          a.isSpreadElement = Dn;
          function Kn(_e) {
            return _e.kind === c.SyntaxKind.StringLiteral;
          }
          __name(Kn, "Kn");
          a.isStringLiteral = Kn;
          function si(_e) {
            return _e.kind === c.SyntaxKind.SwitchStatement;
          }
          __name(si, "si");
          a.isSwitchStatement = si;
          function mi(_e) {
            return _e.kind === c.SyntaxKind.SyntaxList;
          }
          __name(mi, "mi");
          a.isSyntaxList = mi;
          function Zn(_e) {
            return _e.kind === c.SyntaxKind.TaggedTemplateExpression;
          }
          __name(Zn, "Zn");
          a.isTaggedTemplateExpression = Zn;
          function Fn(_e) {
            return _e.kind === c.SyntaxKind.TemplateExpression;
          }
          __name(Fn, "Fn");
          a.isTemplateExpression = Fn;
          function gt(_e) {
            return _e.kind === c.SyntaxKind.TemplateExpression || _e.kind === c.SyntaxKind.NoSubstitutionTemplateLiteral;
          }
          __name(gt, "gt");
          a.isTemplateLiteral = gt;
          function gi(_e) {
            return _e.kind === c.SyntaxKind.StringLiteral || _e.kind === c.SyntaxKind.NoSubstitutionTemplateLiteral;
          }
          __name(gi, "gi");
          a.isTextualLiteral = gi;
          function dn(_e) {
            return _e.kind === c.SyntaxKind.ThrowStatement;
          }
          __name(dn, "dn");
          a.isThrowStatement = dn;
          function On(_e) {
            return _e.kind === c.SyntaxKind.TryStatement;
          }
          __name(On, "On");
          a.isTryStatement = On;
          function br(_e) {
            return _e.kind === c.SyntaxKind.TupleType;
          }
          __name(br, "br");
          a.isTupleTypeNode = br;
          function Ae(_e) {
            return _e.kind === c.SyntaxKind.TypeAliasDeclaration;
          }
          __name(Ae, "Ae");
          a.isTypeAliasDeclaration = Ae;
          function ur(_e) {
            return _e.kind === c.SyntaxKind.TypeAssertionExpression;
          }
          __name(ur, "ur");
          a.isTypeAssertion = ur;
          function L(_e) {
            return _e.kind === c.SyntaxKind.TypeLiteral;
          }
          __name(L, "L");
          a.isTypeLiteralNode = L;
          function qt(_e) {
            return _e.kind === c.SyntaxKind.TypeOfExpression;
          }
          __name(qt, "qt");
          a.isTypeOfExpression = qt;
          function nn(_e) {
            return _e.kind === c.SyntaxKind.TypeOperator;
          }
          __name(nn, "nn");
          a.isTypeOperatorNode = nn;
          function fr(_e) {
            return _e.kind === c.SyntaxKind.TypeParameter;
          }
          __name(fr, "fr");
          a.isTypeParameterDeclaration = fr;
          function Me(_e) {
            return _e.kind === c.SyntaxKind.TypePredicate;
          }
          __name(Me, "Me");
          a.isTypePredicateNode = Me;
          function Ve(_e) {
            return _e.kind === c.SyntaxKind.TypeReference;
          }
          __name(Ve, "Ve");
          a.isTypeReferenceNode = Ve;
          function _r(_e) {
            return _e.kind === c.SyntaxKind.TypeQuery;
          }
          __name(_r, "_r");
          a.isTypeQueryNode = _r;
          function lr(_e) {
            return _e.kind === c.SyntaxKind.UnionType;
          }
          __name(lr, "lr");
          a.isUnionTypeNode = lr;
          function Vr(_e) {
            return _e.kind === c.SyntaxKind.VariableDeclaration;
          }
          __name(Vr, "Vr");
          a.isVariableDeclaration = Vr;
          function tt(_e) {
            return _e.kind === c.SyntaxKind.VariableStatement;
          }
          __name(tt, "tt");
          a.isVariableStatement = tt;
          function dt(_e) {
            return _e.kind === c.SyntaxKind.VariableDeclarationList;
          }
          __name(dt, "dt");
          a.isVariableDeclarationList = dt;
          function It(_e) {
            return _e.kind === c.SyntaxKind.VoidExpression;
          }
          __name(It, "It");
          a.isVoidExpression = It;
          function an(_e) {
            return _e.kind === c.SyntaxKind.WhileStatement;
          }
          __name(an, "an");
          a.isWhileStatement = an;
          function sn(_e) {
            return _e.kind === c.SyntaxKind.WithStatement;
          }
          __name(sn, "sn");
          a.isWithStatement = sn;
        } }), IE = Ur({ "node_modules/tsutils/typeguard/2.9/node.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.isImportTypeNode = void 0;
          var c = (Vo(), Ja(go));
          c.__exportStar(NE(), a);
          var A = xi();
          function T(oe) {
            return oe.kind === A.SyntaxKind.ImportType;
          }
          __name(T, "T");
          a.isImportTypeNode = T;
        } }), OE = Ur({ "node_modules/tsutils/typeguard/3.0/node.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.isSyntheticExpression = a.isRestTypeNode = a.isOptionalTypeNode = void 0;
          var c = (Vo(), Ja(go));
          c.__exportStar(IE(), a);
          var A = xi();
          function T(I) {
            return I.kind === A.SyntaxKind.OptionalType;
          }
          __name(T, "T");
          a.isOptionalTypeNode = T;
          function oe(I) {
            return I.kind === A.SyntaxKind.RestType;
          }
          __name(oe, "oe");
          a.isRestTypeNode = oe;
          function z(I) {
            return I.kind === A.SyntaxKind.SyntheticExpression;
          }
          __name(z, "z");
          a.isSyntheticExpression = z;
        } }), ey = Ur({ "node_modules/tsutils/typeguard/3.2/node.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.isBigIntLiteral = void 0;
          var c = (Vo(), Ja(go));
          c.__exportStar(OE(), a);
          var A = xi();
          function T(oe) {
            return oe.kind === A.SyntaxKind.BigIntLiteral;
          }
          __name(T, "T");
          a.isBigIntLiteral = T;
        } }), ry = Ur({ "node_modules/tsutils/typeguard/node.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true });
          var c = (Vo(), Ja(go));
          c.__exportStar(ey(), a);
        } }), ME = Ur({ "node_modules/tsutils/typeguard/2.8/type.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.isUniqueESSymbolType = a.isUnionType = a.isUnionOrIntersectionType = a.isTypeVariable = a.isTypeReference = a.isTypeParameter = a.isSubstitutionType = a.isObjectType = a.isLiteralType = a.isIntersectionType = a.isInterfaceType = a.isInstantiableType = a.isIndexedAccessype = a.isIndexedAccessType = a.isGenericType = a.isEnumType = a.isConditionalType = void 0;
          var c = xi();
          function A(se) {
            return (se.flags & c.TypeFlags.Conditional) !== 0;
          }
          __name(A, "A");
          a.isConditionalType = A;
          function T(se) {
            return (se.flags & c.TypeFlags.Enum) !== 0;
          }
          __name(T, "T");
          a.isEnumType = T;
          function oe(se) {
            return (se.flags & c.TypeFlags.Object) !== 0 && (se.objectFlags & c.ObjectFlags.ClassOrInterface) !== 0 && (se.objectFlags & c.ObjectFlags.Reference) !== 0;
          }
          __name(oe, "oe");
          a.isGenericType = oe;
          function z(se) {
            return (se.flags & c.TypeFlags.IndexedAccess) !== 0;
          }
          __name(z, "z");
          a.isIndexedAccessType = z;
          function I(se) {
            return (se.flags & c.TypeFlags.Index) !== 0;
          }
          __name(I, "I");
          a.isIndexedAccessype = I;
          function E(se) {
            return (se.flags & c.TypeFlags.Instantiable) !== 0;
          }
          __name(E, "E");
          a.isInstantiableType = E;
          function N(se) {
            return (se.flags & c.TypeFlags.Object) !== 0 && (se.objectFlags & c.ObjectFlags.ClassOrInterface) !== 0;
          }
          __name(N, "N");
          a.isInterfaceType = N;
          function e(se) {
            return (se.flags & c.TypeFlags.Intersection) !== 0;
          }
          __name(e, "e");
          a.isIntersectionType = e;
          function t(se) {
            return (se.flags & (c.TypeFlags.StringOrNumberLiteral | c.TypeFlags.BigIntLiteral)) !== 0;
          }
          __name(t, "t");
          a.isLiteralType = t;
          function x(se) {
            return (se.flags & c.TypeFlags.Object) !== 0;
          }
          __name(x, "x");
          a.isObjectType = x;
          function s(se) {
            return (se.flags & c.TypeFlags.Substitution) !== 0;
          }
          __name(s, "s");
          a.isSubstitutionType = s;
          function q(se) {
            return (se.flags & c.TypeFlags.TypeParameter) !== 0;
          }
          __name(q, "q");
          a.isTypeParameter = q;
          function F(se) {
            return (se.flags & c.TypeFlags.Object) !== 0 && (se.objectFlags & c.ObjectFlags.Reference) !== 0;
          }
          __name(F, "F");
          a.isTypeReference = F;
          function fe(se) {
            return (se.flags & c.TypeFlags.TypeVariable) !== 0;
          }
          __name(fe, "fe");
          a.isTypeVariable = fe;
          function Te(se) {
            return (se.flags & c.TypeFlags.UnionOrIntersection) !== 0;
          }
          __name(Te, "Te");
          a.isUnionOrIntersectionType = Te;
          function Se(se) {
            return (se.flags & c.TypeFlags.Union) !== 0;
          }
          __name(Se, "Se");
          a.isUnionType = Se;
          function J(se) {
            return (se.flags & c.TypeFlags.UniqueESSymbol) !== 0;
          }
          __name(J, "J");
          a.isUniqueESSymbolType = J;
        } }), Ag = Ur({ "node_modules/tsutils/typeguard/2.9/type.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true });
          var c = (Vo(), Ja(go));
          c.__exportStar(ME(), a);
        } }), LE = Ur({ "node_modules/tsutils/typeguard/3.0/type.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.isTupleTypeReference = a.isTupleType = void 0;
          var c = (Vo(), Ja(go));
          c.__exportStar(Ag(), a);
          var A = xi(), T = Ag();
          function oe(I) {
            return (I.flags & A.TypeFlags.Object && I.objectFlags & A.ObjectFlags.Tuple) !== 0;
          }
          __name(oe, "oe");
          a.isTupleType = oe;
          function z(I) {
            return T.isTypeReference(I) && oe(I.target);
          }
          __name(z, "z");
          a.isTupleTypeReference = z;
        } }), ty = Ur({ "node_modules/tsutils/typeguard/3.2/type.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true });
          var c = (Vo(), Ja(go));
          c.__exportStar(LE(), a);
        } }), RE = Ur({ "node_modules/tsutils/typeguard/3.2/index.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true });
          var c = (Vo(), Ja(go));
          c.__exportStar(ey(), a), c.__exportStar(ty(), a);
        } }), jE = Ur({ "node_modules/tsutils/typeguard/type.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true });
          var c = (Vo(), Ja(go));
          c.__exportStar(ty(), a);
        } }), JE = Ur({ "node_modules/tsutils/util/type.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.getBaseClassMemberOfClassElement = a.getIteratorYieldResultFromIteratorResult = a.getInstanceTypeOfClassLikeDeclaration = a.getConstructorTypeOfClassLikeDeclaration = a.getSymbolOfClassLikeDeclaration = a.getPropertyNameFromType = a.symbolHasReadonlyDeclaration = a.isPropertyReadonlyInType = a.getWellKnownSymbolPropertyOfType = a.getPropertyOfType = a.isBooleanLiteralType = a.isFalsyType = a.isThenableType = a.someTypePart = a.intersectionTypeParts = a.unionTypeParts = a.getCallSignaturesOfType = a.isTypeAssignableToString = a.isTypeAssignableToNumber = a.isOptionalChainingUndefinedMarkerType = a.removeOptionalChainingUndefinedMarkerType = a.removeOptionalityFromType = a.isEmptyObjectType = void 0;
          var c = xi(), A = jE(), T = ny(), oe = ry();
          function z(ie) {
            if (A.isObjectType(ie) && ie.objectFlags & c.ObjectFlags.Anonymous && ie.getProperties().length === 0 && ie.getCallSignatures().length === 0 && ie.getConstructSignatures().length === 0 && ie.getStringIndexType() === void 0 && ie.getNumberIndexType() === void 0) {
              let G = ie.getBaseTypes();
              return G === void 0 || G.every(z);
            }
            return false;
          }
          __name(z, "z");
          a.isEmptyObjectType = z;
          function I(ie, G) {
            if (!E(G, c.TypeFlags.Undefined))
              return G;
            let pe = E(G, c.TypeFlags.Null);
            return G = ie.getNonNullableType(G), pe ? ie.getNullableType(G, c.TypeFlags.Null) : G;
          }
          __name(I, "I");
          a.removeOptionalityFromType = I;
          function E(ie, G) {
            for (let pe of F(ie))
              if (T.isTypeFlagSet(pe, G))
                return true;
            return false;
          }
          __name(E, "E");
          function N(ie, G) {
            if (!A.isUnionType(G))
              return e(ie, G) ? G.getNonNullableType() : G;
            let pe = 0, j = false;
            for (let be of G.types)
              e(ie, be) ? j = true : pe |= be.flags;
            return j ? ie.getNullableType(G.getNonNullableType(), pe) : G;
          }
          __name(N, "N");
          a.removeOptionalChainingUndefinedMarkerType = N;
          function e(ie, G) {
            return T.isTypeFlagSet(G, c.TypeFlags.Undefined) && ie.getNullableType(G.getNonNullableType(), c.TypeFlags.Undefined) !== G;
          }
          __name(e, "e");
          a.isOptionalChainingUndefinedMarkerType = e;
          function t(ie, G) {
            return s(ie, G, c.TypeFlags.NumberLike);
          }
          __name(t, "t");
          a.isTypeAssignableToNumber = t;
          function x(ie, G) {
            return s(ie, G, c.TypeFlags.StringLike);
          }
          __name(x, "x");
          a.isTypeAssignableToString = x;
          function s(ie, G, pe) {
            pe |= c.TypeFlags.Any;
            let j;
            return (/* @__PURE__ */ __name(function be($e) {
              if (A.isTypeParameter($e) && $e.symbol !== void 0 && $e.symbol.declarations !== void 0) {
                if (j === void 0)
                  j = /* @__PURE__ */ new Set([$e]);
                else if (!j.has($e))
                  j.add($e);
                else
                  return false;
                let Re = $e.symbol.declarations[0];
                return Re.constraint === void 0 ? true : be(ie.getTypeFromTypeNode(Re.constraint));
              }
              return A.isUnionType($e) ? $e.types.every(be) : A.isIntersectionType($e) ? $e.types.some(be) : T.isTypeFlagSet($e, pe);
            }, "be"))(G);
          }
          __name(s, "s");
          function q(ie) {
            if (A.isUnionType(ie)) {
              let G = [];
              for (let pe of ie.types)
                G.push(...q(pe));
              return G;
            }
            if (A.isIntersectionType(ie)) {
              let G;
              for (let pe of ie.types) {
                let j = q(pe);
                if (j.length !== 0) {
                  if (G !== void 0)
                    return [];
                  G = j;
                }
              }
              return G === void 0 ? [] : G;
            }
            return ie.getCallSignatures();
          }
          __name(q, "q");
          a.getCallSignaturesOfType = q;
          function F(ie) {
            return A.isUnionType(ie) ? ie.types : [ie];
          }
          __name(F, "F");
          a.unionTypeParts = F;
          function fe(ie) {
            return A.isIntersectionType(ie) ? ie.types : [ie];
          }
          __name(fe, "fe");
          a.intersectionTypeParts = fe;
          function Te(ie, G, pe) {
            return G(ie) ? ie.types.some(pe) : pe(ie);
          }
          __name(Te, "Te");
          a.someTypePart = Te;
          function Se(ie, G) {
            let pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ie.getTypeAtLocation(G);
            for (let j of F(ie.getApparentType(pe))) {
              let be = j.getProperty("then");
              if (be === void 0)
                continue;
              let $e = ie.getTypeOfSymbolAtLocation(be, G);
              for (let Re of F($e))
                for (let Fe of Re.getCallSignatures())
                  if (Fe.parameters.length !== 0 && J(ie, Fe.parameters[0], G))
                    return true;
            }
            return false;
          }
          __name(Se, "Se");
          a.isThenableType = Se;
          function J(ie, G, pe) {
            let j = ie.getApparentType(ie.getTypeOfSymbolAtLocation(G, pe));
            if (G.valueDeclaration.dotDotDotToken && (j = j.getNumberIndexType(), j === void 0))
              return false;
            for (let be of F(j))
              if (be.getCallSignatures().length !== 0)
                return true;
            return false;
          }
          __name(J, "J");
          function se(ie) {
            return ie.flags & (c.TypeFlags.Undefined | c.TypeFlags.Null | c.TypeFlags.Void) ? true : A.isLiteralType(ie) ? !ie.value : Le(ie, false);
          }
          __name(se, "se");
          a.isFalsyType = se;
          function Le(ie, G) {
            return T.isTypeFlagSet(ie, c.TypeFlags.BooleanLiteral) && ie.intrinsicName === (G ? "true" : "false");
          }
          __name(Le, "Le");
          a.isBooleanLiteralType = Le;
          function Q(ie, G) {
            return G.startsWith("__") ? ie.getProperties().find((pe) => pe.escapedName === G) : ie.getProperty(G);
          }
          __name(Q, "Q");
          a.getPropertyOfType = Q;
          function Be(ie, G, pe) {
            let j = "__@" + G;
            for (let be of ie.getProperties()) {
              if (!be.name.startsWith(j))
                continue;
              let $e = pe.getApparentType(pe.getTypeAtLocation(be.valueDeclaration.name.expression)).symbol;
              if (be.escapedName === je(pe, $e, G))
                return be;
            }
          }
          __name(Be, "Be");
          a.getWellKnownSymbolPropertyOfType = Be;
          function je(ie, G, pe) {
            let j = G && ie.getTypeOfSymbolAtLocation(G, G.valueDeclaration).getProperty(pe), be = j && ie.getTypeOfSymbolAtLocation(j, j.valueDeclaration);
            return be && A.isUniqueESSymbolType(be) ? be.escapedName : "__@" + pe;
          }
          __name(je, "je");
          function W(ie, G, pe) {
            let j = false, be = false;
            for (let $e of F(ie))
              if (Q($e, G) === void 0) {
                let Re = (T.isNumericPropertyName(G) ? pe.getIndexInfoOfType($e, c.IndexKind.Number) : void 0) || pe.getIndexInfoOfType($e, c.IndexKind.String);
                if (Re !== void 0 && Re.isReadonly) {
                  if (j)
                    return true;
                  be = true;
                }
              } else {
                if (be || B($e, G, pe))
                  return true;
                j = true;
              }
            return false;
          }
          __name(W, "W");
          a.isPropertyReadonlyInType = W;
          function B(ie, G, pe) {
            return Te(ie, A.isIntersectionType, (j) => {
              let be = Q(j, G);
              if (be === void 0)
                return false;
              if (be.flags & c.SymbolFlags.Transient) {
                if (/^(?:[1-9]\d*|0)$/.test(G) && A.isTupleTypeReference(j))
                  return j.target.readonly;
                switch (U(j, G, pe)) {
                  case true:
                    return true;
                  case false:
                    return false;
                  default:
                }
              }
              return T.isSymbolFlagSet(be, c.SymbolFlags.ValueModule) || m(be, pe);
            });
          }
          __name(B, "B");
          function U(ie, G, pe) {
            if (!A.isObjectType(ie) || !T.isObjectFlagSet(ie, c.ObjectFlags.Mapped))
              return;
            let j = ie.symbol.declarations[0];
            return j.readonlyToken !== void 0 && !/^__@[^@]+$/.test(G) ? j.readonlyToken.kind !== c.SyntaxKind.MinusToken : W(ie.modifiersType, G, pe);
          }
          __name(U, "U");
          function m(ie, G) {
            return (ie.flags & c.SymbolFlags.Accessor) === c.SymbolFlags.GetAccessor || ie.declarations !== void 0 && ie.declarations.some((pe) => T.isModifierFlagSet(pe, c.ModifierFlags.Readonly) || oe.isVariableDeclaration(pe) && T.isNodeFlagSet(pe.parent, c.NodeFlags.Const) || oe.isCallExpression(pe) && T.isReadonlyAssignmentDeclaration(pe, G) || oe.isEnumMember(pe) || (oe.isPropertyAssignment(pe) || oe.isShorthandPropertyAssignment(pe)) && T.isInConstContext(pe.parent));
          }
          __name(m, "m");
          a.symbolHasReadonlyDeclaration = m;
          function v(ie) {
            if (ie.flags & (c.TypeFlags.StringLiteral | c.TypeFlags.NumberLiteral)) {
              let G = String(ie.value);
              return { displayName: G, symbolName: c.escapeLeadingUnderscores(G) };
            }
            if (A.isUniqueESSymbolType(ie))
              return { displayName: `[${ie.symbol ? `${g(ie.symbol) ? "Symbol." : ""}${ie.symbol.name}` : ie.escapedName.replace(/^__@|@\d+$/g, "")}]`, symbolName: ie.escapedName };
          }
          __name(v, "v");
          a.getPropertyNameFromType = v;
          function g(ie) {
            return T.isSymbolFlagSet(ie, c.SymbolFlags.Property) && ie.valueDeclaration !== void 0 && oe.isInterfaceDeclaration(ie.valueDeclaration.parent) && ie.valueDeclaration.parent.name.text === "SymbolConstructor" && O(ie.valueDeclaration.parent);
          }
          __name(g, "g");
          function O(ie) {
            return T.isNodeFlagSet(ie.parent, c.NodeFlags.GlobalAugmentation) || oe.isSourceFile(ie.parent) && !c.isExternalModule(ie.parent);
          }
          __name(O, "O");
          function S(ie, G) {
            var pe;
            return G.getSymbolAtLocation((pe = ie.name) !== null && pe !== void 0 ? pe : T.getChildOfKind(ie, c.SyntaxKind.ClassKeyword));
          }
          __name(S, "S");
          a.getSymbolOfClassLikeDeclaration = S;
          function te(ie, G) {
            return ie.kind === c.SyntaxKind.ClassExpression ? G.getTypeAtLocation(ie) : G.getTypeOfSymbolAtLocation(S(ie, G), ie);
          }
          __name(te, "te");
          a.getConstructorTypeOfClassLikeDeclaration = te;
          function Je(ie, G) {
            return ie.kind === c.SyntaxKind.ClassDeclaration ? G.getTypeAtLocation(ie) : G.getDeclaredTypeOfSymbol(S(ie, G));
          }
          __name(Je, "Je");
          a.getInstanceTypeOfClassLikeDeclaration = Je;
          function qe(ie, G, pe) {
            return A.isUnionType(ie) && ie.types.find((j) => {
              let be = j.getProperty("done");
              return be !== void 0 && Le(I(pe, pe.getTypeOfSymbolAtLocation(be, G)), false);
            }) || ie;
          }
          __name(qe, "qe");
          a.getIteratorYieldResultFromIteratorResult = qe;
          function ge(ie, G) {
            if (!oe.isClassLikeDeclaration(ie.parent))
              return;
            let pe = T.getBaseOfClassLikeExpression(ie.parent);
            if (pe === void 0)
              return;
            let j = T.getSingleLateBoundPropertyNameOfPropertyName(ie.name, G);
            if (j === void 0)
              return;
            let be = G.getTypeAtLocation(T.hasModifier(ie.modifiers, c.SyntaxKind.StaticKeyword) ? pe.expression : pe);
            return Q(be, j.symbolName);
          }
          __name(ge, "ge");
          a.getBaseClassMemberOfClassElement = ge;
        } }), ny = Ur({ "node_modules/tsutils/util/util.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.isValidIdentifier = a.getLineBreakStyle = a.getLineRanges = a.forEachComment = a.forEachTokenWithTrivia = a.forEachToken = a.isFunctionWithBody = a.hasOwnThisReference = a.isBlockScopeBoundary = a.isFunctionScopeBoundary = a.isTypeScopeBoundary = a.isScopeBoundary = a.ScopeBoundarySelector = a.ScopeBoundary = a.isInSingleStatementContext = a.isBlockScopedDeclarationStatement = a.isBlockScopedVariableDeclaration = a.isBlockScopedVariableDeclarationList = a.getVariableDeclarationKind = a.VariableDeclarationKind = a.forEachDeclaredVariable = a.forEachDestructuringIdentifier = a.getPropertyName = a.getWrappedNodeAtPosition = a.getAstNodeAtPosition = a.commentText = a.isPositionInComment = a.getCommentAtPosition = a.getTokenAtPosition = a.getNextToken = a.getPreviousToken = a.getNextStatement = a.getPreviousStatement = a.isModifierFlagSet = a.isObjectFlagSet = a.isSymbolFlagSet = a.isTypeFlagSet = a.isNodeFlagSet = a.hasAccessModifier = a.isParameterProperty = a.hasModifier = a.getModifier = a.isThisParameter = a.isKeywordKind = a.isJsDocKind = a.isTypeNodeKind = a.isAssignmentKind = a.isNodeKind = a.isTokenKind = a.getChildOfKind = void 0, a.getBaseOfClassLikeExpression = a.hasExhaustiveCaseClauses = a.formatPseudoBigInt = a.unwrapParentheses = a.getSingleLateBoundPropertyNameOfPropertyName = a.getLateBoundPropertyNamesOfPropertyName = a.getLateBoundPropertyNames = a.getPropertyNameOfWellKnownSymbol = a.isWellKnownSymbolLiterally = a.isBindableObjectDefinePropertyCall = a.isReadonlyAssignmentDeclaration = a.isInConstContext = a.isConstAssertion = a.getTsCheckDirective = a.getCheckJsDirective = a.isAmbientModule = a.isCompilerOptionEnabled = a.isStrictCompilerOptionEnabled = a.getIIFE = a.isAmbientModuleBlock = a.isStatementInAmbientContext = a.findImportLikeNodes = a.findImports = a.ImportKind = a.parseJsDocOfNode = a.getJsDoc = a.canHaveJsDoc = a.isReassignmentTarget = a.getAccessKind = a.AccessKind = a.isExpressionValueUsed = a.getDeclarationOfBindingElement = a.hasSideEffects = a.SideEffectOptions = a.isSameLine = a.isNumericPropertyName = a.isValidJsxIdentifier = a.isValidNumericLiteral = a.isValidPropertyName = a.isValidPropertyAccess = void 0;
          var c = xi(), A = ry(), T = RE(), oe = JE();
          function z(k, ue, Qe) {
            for (let Sr of k.getChildren(Qe))
              if (Sr.kind === ue)
                return Sr;
          }
          __name(z, "z");
          a.getChildOfKind = z;
          function I(k) {
            return k >= c.SyntaxKind.FirstToken && k <= c.SyntaxKind.LastToken;
          }
          __name(I, "I");
          a.isTokenKind = I;
          function E(k) {
            return k >= c.SyntaxKind.FirstNode;
          }
          __name(E, "E");
          a.isNodeKind = E;
          function N(k) {
            return k >= c.SyntaxKind.FirstAssignment && k <= c.SyntaxKind.LastAssignment;
          }
          __name(N, "N");
          a.isAssignmentKind = N;
          function e(k) {
            return k >= c.SyntaxKind.FirstTypeNode && k <= c.SyntaxKind.LastTypeNode;
          }
          __name(e, "e");
          a.isTypeNodeKind = e;
          function t(k) {
            return k >= c.SyntaxKind.FirstJSDocNode && k <= c.SyntaxKind.LastJSDocNode;
          }
          __name(t, "t");
          a.isJsDocKind = t;
          function x(k) {
            return k >= c.SyntaxKind.FirstKeyword && k <= c.SyntaxKind.LastKeyword;
          }
          __name(x, "x");
          a.isKeywordKind = x;
          function s(k) {
            return k.name.kind === c.SyntaxKind.Identifier && k.name.originalKeywordKind === c.SyntaxKind.ThisKeyword;
          }
          __name(s, "s");
          a.isThisParameter = s;
          function q(k, ue) {
            if (k.modifiers !== void 0) {
              for (let Qe of k.modifiers)
                if (Qe.kind === ue)
                  return Qe;
            }
          }
          __name(q, "q");
          a.getModifier = q;
          function F(k) {
            if (k === void 0)
              return false;
            for (var ue = arguments.length, Qe = new Array(ue > 1 ? ue - 1 : 0), Sr = 1; Sr < ue; Sr++)
              Qe[Sr - 1] = arguments[Sr];
            for (let Kr of k)
              if (Qe.includes(Kr.kind))
                return true;
            return false;
          }
          __name(F, "F");
          a.hasModifier = F;
          function fe(k) {
            return F(k.modifiers, c.SyntaxKind.PublicKeyword, c.SyntaxKind.ProtectedKeyword, c.SyntaxKind.PrivateKeyword, c.SyntaxKind.ReadonlyKeyword);
          }
          __name(fe, "fe");
          a.isParameterProperty = fe;
          function Te(k) {
            return se(k, c.ModifierFlags.AccessibilityModifier);
          }
          __name(Te, "Te");
          a.hasAccessModifier = Te;
          function Se(k, ue) {
            return (k.flags & ue) !== 0;
          }
          __name(Se, "Se");
          a.isNodeFlagSet = Se, a.isTypeFlagSet = Se, a.isSymbolFlagSet = Se;
          function J(k, ue) {
            return (k.objectFlags & ue) !== 0;
          }
          __name(J, "J");
          a.isObjectFlagSet = J;
          function se(k, ue) {
            return (c.getCombinedModifierFlags(k) & ue) !== 0;
          }
          __name(se, "se");
          a.isModifierFlagSet = se;
          function Le(k) {
            let ue = k.parent;
            if (A.isBlockLike(ue)) {
              let Qe = ue.statements.indexOf(k);
              if (Qe > 0)
                return ue.statements[Qe - 1];
            }
          }
          __name(Le, "Le");
          a.getPreviousStatement = Le;
          function Q(k) {
            let ue = k.parent;
            if (A.isBlockLike(ue)) {
              let Qe = ue.statements.indexOf(k);
              if (Qe < ue.statements.length)
                return ue.statements[Qe + 1];
            }
          }
          __name(Q, "Q");
          a.getNextStatement = Q;
          function Be(k, ue) {
            let { pos: Qe } = k;
            if (Qe !== 0) {
              do
                k = k.parent;
              while (k.pos === Qe);
              return B(k, Qe - 1, ue != null ? ue : k.getSourceFile(), false);
            }
          }
          __name(Be, "Be");
          a.getPreviousToken = Be;
          function je(k, ue) {
            if (k.kind === c.SyntaxKind.SourceFile || k.kind === c.SyntaxKind.EndOfFileToken)
              return;
            let Qe = k.end;
            for (k = k.parent; k.end === Qe; ) {
              if (k.parent === void 0)
                return k.endOfFileToken;
              k = k.parent;
            }
            return B(k, Qe, ue != null ? ue : k.getSourceFile(), false);
          }
          __name(je, "je");
          a.getNextToken = je;
          function W(k, ue, Qe, Sr) {
            if (!(ue < k.pos || ue >= k.end))
              return I(k.kind) ? k : B(k, ue, Qe != null ? Qe : k.getSourceFile(), Sr === true);
          }
          __name(W, "W");
          a.getTokenAtPosition = W;
          function B(k, ue, Qe, Sr) {
            if (!Sr && (k = O(k, ue), I(k.kind)))
              return k;
            e:
              for (; ; ) {
                for (let Kr of k.getChildren(Qe))
                  if (Kr.end > ue && (Sr || Kr.kind !== c.SyntaxKind.JSDocComment)) {
                    if (I(Kr.kind))
                      return Kr;
                    k = Kr;
                    continue e;
                  }
                return;
              }
          }
          __name(B, "B");
          function U(k, ue) {
            let Qe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : k, Sr = W(Qe, ue, k);
            if (Sr === void 0 || Sr.kind === c.SyntaxKind.JsxText || ue >= Sr.end - (c.tokenToString(Sr.kind) || "").length)
              return;
            let Kr = Sr.pos === 0 ? (c.getShebang(k.text) || "").length : Sr.pos;
            return Kr !== 0 && c.forEachTrailingCommentRange(k.text, Kr, m, ue) || c.forEachLeadingCommentRange(k.text, Kr, m, ue);
          }
          __name(U, "U");
          a.getCommentAtPosition = U;
          function m(k, ue, Qe, Sr, Kr) {
            return Kr >= k && Kr < ue ? { pos: k, end: ue, kind: Qe } : void 0;
          }
          __name(m, "m");
          function v(k, ue, Qe) {
            return U(k, ue, Qe) !== void 0;
          }
          __name(v, "v");
          a.isPositionInComment = v;
          function g(k, ue) {
            return k.substring(ue.pos + 2, ue.kind === c.SyntaxKind.SingleLineCommentTrivia ? ue.end : ue.end - 2);
          }
          __name(g, "g");
          a.commentText = g;
          function O(k, ue) {
            if (!(k.pos > ue || k.end <= ue)) {
              for (; E(k.kind); ) {
                let Qe = c.forEachChild(k, (Sr) => Sr.pos <= ue && Sr.end > ue ? Sr : void 0);
                if (Qe === void 0)
                  break;
                k = Qe;
              }
              return k;
            }
          }
          __name(O, "O");
          a.getAstNodeAtPosition = O;
          function S(k, ue) {
            if (k.node.pos > ue || k.node.end <= ue)
              return;
            e:
              for (; ; ) {
                for (let Qe of k.children) {
                  if (Qe.node.pos > ue)
                    return k;
                  if (Qe.node.end > ue) {
                    k = Qe;
                    continue e;
                  }
                }
                return k;
              }
          }
          __name(S, "S");
          a.getWrappedNodeAtPosition = S;
          function te(k) {
            if (k.kind === c.SyntaxKind.ComputedPropertyName) {
              let ue = Lt(k.expression);
              if (A.isPrefixUnaryExpression(ue)) {
                let Qe = false;
                switch (ue.operator) {
                  case c.SyntaxKind.MinusToken:
                    Qe = true;
                  case c.SyntaxKind.PlusToken:
                    return A.isNumericLiteral(ue.operand) ? `${Qe ? "-" : ""}${ue.operand.text}` : T.isBigIntLiteral(ue.operand) ? `${Qe ? "-" : ""}${ue.operand.text.slice(0, -1)}` : void 0;
                  default:
                    return;
                }
              }
              return T.isBigIntLiteral(ue) ? ue.text.slice(0, -1) : A.isNumericOrStringLikeLiteral(ue) ? ue.text : void 0;
            }
            return k.kind === c.SyntaxKind.PrivateIdentifier ? void 0 : k.text;
          }
          __name(te, "te");
          a.getPropertyName = te;
          function Je(k, ue) {
            for (let Qe of k.elements) {
              if (Qe.kind !== c.SyntaxKind.BindingElement)
                continue;
              let Sr;
              if (Qe.name.kind === c.SyntaxKind.Identifier ? Sr = ue(Qe) : Sr = Je(Qe.name, ue), Sr)
                return Sr;
            }
          }
          __name(Je, "Je");
          a.forEachDestructuringIdentifier = Je;
          function qe(k, ue) {
            for (let Qe of k.declarations) {
              let Sr;
              if (Qe.name.kind === c.SyntaxKind.Identifier ? Sr = ue(Qe) : Sr = Je(Qe.name, ue), Sr)
                return Sr;
            }
          }
          __name(qe, "qe");
          a.forEachDeclaredVariable = qe;
          var ge;
          (function(k) {
            k[k.Var = 0] = "Var", k[k.Let = 1] = "Let", k[k.Const = 2] = "Const";
          })(ge = a.VariableDeclarationKind || (a.VariableDeclarationKind = {}));
          function ie(k) {
            return k.flags & c.NodeFlags.Let ? 1 : k.flags & c.NodeFlags.Const ? 2 : 0;
          }
          __name(ie, "ie");
          a.getVariableDeclarationKind = ie;
          function G(k) {
            return (k.flags & c.NodeFlags.BlockScoped) !== 0;
          }
          __name(G, "G");
          a.isBlockScopedVariableDeclarationList = G;
          function pe(k) {
            let ue = k.parent;
            return ue.kind === c.SyntaxKind.CatchClause || G(ue);
          }
          __name(pe, "pe");
          a.isBlockScopedVariableDeclaration = pe;
          function j(k) {
            switch (k.kind) {
              case c.SyntaxKind.VariableStatement:
                return G(k.declarationList);
              case c.SyntaxKind.ClassDeclaration:
              case c.SyntaxKind.EnumDeclaration:
              case c.SyntaxKind.InterfaceDeclaration:
              case c.SyntaxKind.TypeAliasDeclaration:
                return true;
              default:
                return false;
            }
          }
          __name(j, "j");
          a.isBlockScopedDeclarationStatement = j;
          function be(k) {
            switch (k.parent.kind) {
              case c.SyntaxKind.ForStatement:
              case c.SyntaxKind.ForInStatement:
              case c.SyntaxKind.ForOfStatement:
              case c.SyntaxKind.WhileStatement:
              case c.SyntaxKind.DoStatement:
              case c.SyntaxKind.IfStatement:
              case c.SyntaxKind.WithStatement:
              case c.SyntaxKind.LabeledStatement:
                return true;
              default:
                return false;
            }
          }
          __name(be, "be");
          a.isInSingleStatementContext = be;
          var $e;
          (function(k) {
            k[k.None = 0] = "None", k[k.Function = 1] = "Function", k[k.Block = 2] = "Block", k[k.Type = 4] = "Type", k[k.ConditionalType = 8] = "ConditionalType";
          })($e = a.ScopeBoundary || (a.ScopeBoundary = {}));
          var Re;
          (function(k) {
            k[k.Function = 1] = "Function", k[k.Block = 3] = "Block", k[k.Type = 7] = "Type", k[k.InferType = 8] = "InferType";
          })(Re = a.ScopeBoundarySelector || (a.ScopeBoundarySelector = {}));
          function Fe(k) {
            return ze(k) || ve(k) || dr(k);
          }
          __name(Fe, "Fe");
          a.isScopeBoundary = Fe;
          function dr(k) {
            switch (k.kind) {
              case c.SyntaxKind.InterfaceDeclaration:
              case c.SyntaxKind.TypeAliasDeclaration:
              case c.SyntaxKind.MappedType:
                return 4;
              case c.SyntaxKind.ConditionalType:
                return 8;
              default:
                return 0;
            }
          }
          __name(dr, "dr");
          a.isTypeScopeBoundary = dr;
          function ze(k) {
            switch (k.kind) {
              case c.SyntaxKind.FunctionExpression:
              case c.SyntaxKind.ArrowFunction:
              case c.SyntaxKind.Constructor:
              case c.SyntaxKind.ModuleDeclaration:
              case c.SyntaxKind.ClassDeclaration:
              case c.SyntaxKind.ClassExpression:
              case c.SyntaxKind.EnumDeclaration:
              case c.SyntaxKind.MethodDeclaration:
              case c.SyntaxKind.FunctionDeclaration:
              case c.SyntaxKind.GetAccessor:
              case c.SyntaxKind.SetAccessor:
              case c.SyntaxKind.MethodSignature:
              case c.SyntaxKind.CallSignature:
              case c.SyntaxKind.ConstructSignature:
              case c.SyntaxKind.ConstructorType:
              case c.SyntaxKind.FunctionType:
                return 1;
              case c.SyntaxKind.SourceFile:
                return c.isExternalModule(k) ? 1 : 0;
              default:
                return 0;
            }
          }
          __name(ze, "ze");
          a.isFunctionScopeBoundary = ze;
          function ve(k) {
            switch (k.kind) {
              case c.SyntaxKind.Block:
                let ue = k.parent;
                return ue.kind !== c.SyntaxKind.CatchClause && (ue.kind === c.SyntaxKind.SourceFile || !ze(ue)) ? 2 : 0;
              case c.SyntaxKind.ForStatement:
              case c.SyntaxKind.ForInStatement:
              case c.SyntaxKind.ForOfStatement:
              case c.SyntaxKind.CaseBlock:
              case c.SyntaxKind.CatchClause:
              case c.SyntaxKind.WithStatement:
                return 2;
              default:
                return 0;
            }
          }
          __name(ve, "ve");
          a.isBlockScopeBoundary = ve;
          function er(k) {
            switch (k.kind) {
              case c.SyntaxKind.ClassDeclaration:
              case c.SyntaxKind.ClassExpression:
              case c.SyntaxKind.FunctionExpression:
                return true;
              case c.SyntaxKind.FunctionDeclaration:
                return k.body !== void 0;
              case c.SyntaxKind.MethodDeclaration:
              case c.SyntaxKind.GetAccessor:
              case c.SyntaxKind.SetAccessor:
                return k.parent.kind === c.SyntaxKind.ObjectLiteralExpression;
              default:
                return false;
            }
          }
          __name(er, "er");
          a.hasOwnThisReference = er;
          function ar(k) {
            switch (k.kind) {
              case c.SyntaxKind.GetAccessor:
              case c.SyntaxKind.SetAccessor:
              case c.SyntaxKind.FunctionDeclaration:
              case c.SyntaxKind.MethodDeclaration:
              case c.SyntaxKind.Constructor:
                return k.body !== void 0;
              case c.SyntaxKind.FunctionExpression:
              case c.SyntaxKind.ArrowFunction:
                return true;
              default:
                return false;
            }
          }
          __name(ar, "ar");
          a.isFunctionWithBody = ar;
          function Cr(k, ue) {
            let Qe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : k.getSourceFile(), Sr = [];
            for (; ; ) {
              if (I(k.kind))
                ue(k);
              else if (k.kind !== c.SyntaxKind.JSDocComment) {
                let Kr = k.getChildren(Qe);
                if (Kr.length === 1) {
                  k = Kr[0];
                  continue;
                }
                for (let Hr = Kr.length - 1; Hr >= 0; --Hr)
                  Sr.push(Kr[Hr]);
              }
              if (Sr.length === 0)
                break;
              k = Sr.pop();
            }
          }
          __name(Cr, "Cr");
          a.forEachToken = Cr;
          function Ce(k, ue) {
            let Qe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : k.getSourceFile(), Sr = Qe.text, Kr = c.createScanner(Qe.languageVersion, false, Qe.languageVariant, Sr);
            return Cr(k, (Hr) => {
              let Ct = Hr.kind === c.SyntaxKind.JsxText || Hr.pos === Hr.end ? Hr.pos : Hr.getStart(Qe);
              if (Ct !== Hr.pos) {
                Kr.setTextPos(Hr.pos);
                let Xt = Kr.scan(), cn = Kr.getTokenPos();
                for (; cn < Ct; ) {
                  let In = Kr.getTextPos();
                  if (ue(Sr, Xt, { pos: cn, end: In }, Hr.parent), In === Ct)
                    break;
                  Xt = Kr.scan(), cn = Kr.getTokenPos();
                }
              }
              return ue(Sr, Hr.kind, { end: Hr.end, pos: Ct }, Hr.parent);
            }, Qe);
          }
          __name(Ce, "Ce");
          a.forEachTokenWithTrivia = Ce;
          function Xe(k, ue) {
            let Qe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : k.getSourceFile(), Sr = Qe.text, Kr = Qe.languageVariant !== c.LanguageVariant.JSX;
            return Cr(k, (Ct) => {
              if (Ct.pos !== Ct.end && (Ct.kind !== c.SyntaxKind.JsxText && c.forEachLeadingCommentRange(Sr, Ct.pos === 0 ? (c.getShebang(Sr) || "").length : Ct.pos, Hr), Kr || gr(Ct)))
                return c.forEachTrailingCommentRange(Sr, Ct.end, Hr);
            }, Qe);
            function Hr(Ct, Xt, cn) {
              ue(Sr, { pos: Ct, end: Xt, kind: cn });
            }
            __name(Hr, "Hr");
          }
          __name(Xe, "Xe");
          a.forEachComment = Xe;
          function gr(k) {
            switch (k.kind) {
              case c.SyntaxKind.CloseBraceToken:
                return k.parent.kind !== c.SyntaxKind.JsxExpression || !X(k.parent.parent);
              case c.SyntaxKind.GreaterThanToken:
                switch (k.parent.kind) {
                  case c.SyntaxKind.JsxOpeningElement:
                    return k.end !== k.parent.end;
                  case c.SyntaxKind.JsxOpeningFragment:
                    return false;
                  case c.SyntaxKind.JsxSelfClosingElement:
                    return k.end !== k.parent.end || !X(k.parent.parent);
                  case c.SyntaxKind.JsxClosingElement:
                  case c.SyntaxKind.JsxClosingFragment:
                    return !X(k.parent.parent.parent);
                }
            }
            return true;
          }
          __name(gr, "gr");
          function X(k) {
            return k.kind === c.SyntaxKind.JsxElement || k.kind === c.SyntaxKind.JsxFragment;
          }
          __name(X, "X");
          function Ee(k) {
            let ue = k.getLineStarts(), Qe = [], Sr = ue.length, Kr = k.text, Hr = 0;
            for (let Ct = 1; Ct < Sr; ++Ct) {
              let Xt = ue[Ct], cn = Xt;
              for (; cn > Hr && c.isLineBreak(Kr.charCodeAt(cn - 1)); --cn)
                ;
              Qe.push({ pos: Hr, end: Xt, contentLength: cn - Hr }), Hr = Xt;
            }
            return Qe.push({ pos: Hr, end: k.end, contentLength: k.end - Hr }), Qe;
          }
          __name(Ee, "Ee");
          a.getLineRanges = Ee;
          function we(k) {
            let ue = k.getLineStarts();
            return ue.length === 1 || ue[1] < 2 || k.text[ue[1] - 2] !== "\r" ? `
` : `\r
`;
          }
          __name(we, "we");
          a.getLineBreakStyle = we;
          var he;
          function yr(k, ue) {
            return he === void 0 ? he = c.createScanner(ue, false, void 0, k) : (he.setScriptTarget(ue), he.setText(k)), he.scan(), he;
          }
          __name(yr, "yr");
          function kr(k) {
            let ue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c.ScriptTarget.Latest, Qe = yr(k, ue);
            return Qe.isIdentifier() && Qe.getTextPos() === k.length && Qe.getTokenPos() === 0;
          }
          __name(kr, "kr");
          a.isValidIdentifier = kr;
          function nr(k) {
            return k >= 65536 ? 2 : 1;
          }
          __name(nr, "nr");
          function tr(k) {
            let ue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c.ScriptTarget.Latest;
            if (k.length === 0)
              return false;
            let Qe = k.codePointAt(0);
            if (!c.isIdentifierStart(Qe, ue))
              return false;
            for (let Sr = nr(Qe); Sr < k.length; Sr += nr(Qe))
              if (Qe = k.codePointAt(Sr), !c.isIdentifierPart(Qe, ue))
                return false;
            return true;
          }
          __name(tr, "tr");
          a.isValidPropertyAccess = tr;
          function Lr(k) {
            let ue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c.ScriptTarget.Latest;
            if (tr(k, ue))
              return true;
            let Qe = yr(k, ue);
            return Qe.getTextPos() === k.length && Qe.getToken() === c.SyntaxKind.NumericLiteral && Qe.getTokenValue() === k;
          }
          __name(Lr, "Lr");
          a.isValidPropertyName = Lr;
          function zr(k) {
            let ue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c.ScriptTarget.Latest, Qe = yr(k, ue);
            return Qe.getToken() === c.SyntaxKind.NumericLiteral && Qe.getTextPos() === k.length && Qe.getTokenPos() === 0;
          }
          __name(zr, "zr");
          a.isValidNumericLiteral = zr;
          function ye(k) {
            let ue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c.ScriptTarget.Latest;
            if (k.length === 0)
              return false;
            let Qe = false, Sr = k.codePointAt(0);
            if (!c.isIdentifierStart(Sr, ue))
              return false;
            for (let Kr = nr(Sr); Kr < k.length; Kr += nr(Sr))
              if (Sr = k.codePointAt(Kr), !c.isIdentifierPart(Sr, ue) && Sr !== 45)
                if (!Qe && Sr === 58 && Kr + nr(Sr) !== k.length)
                  Qe = true;
                else
                  return false;
            return true;
          }
          __name(ye, "ye");
          a.isValidJsxIdentifier = ye;
          function ir(k) {
            return String(+k) === k;
          }
          __name(ir, "ir");
          a.isNumericPropertyName = ir;
          function Dr(k, ue, Qe) {
            return c.getLineAndCharacterOfPosition(k, ue).line === c.getLineAndCharacterOfPosition(k, Qe).line;
          }
          __name(Dr, "Dr");
          a.isSameLine = Dr;
          var Pr;
          (function(k) {
            k[k.None = 0] = "None", k[k.TaggedTemplate = 1] = "TaggedTemplate", k[k.Constructor = 2] = "Constructor", k[k.JsxElement = 4] = "JsxElement";
          })(Pr = a.SideEffectOptions || (a.SideEffectOptions = {}));
          function Br(k, ue) {
            var Qe, Sr;
            let Kr = [];
            for (; ; ) {
              switch (k.kind) {
                case c.SyntaxKind.CallExpression:
                case c.SyntaxKind.PostfixUnaryExpression:
                case c.SyntaxKind.AwaitExpression:
                case c.SyntaxKind.YieldExpression:
                case c.SyntaxKind.DeleteExpression:
                  return true;
                case c.SyntaxKind.TypeAssertionExpression:
                case c.SyntaxKind.AsExpression:
                case c.SyntaxKind.ParenthesizedExpression:
                case c.SyntaxKind.NonNullExpression:
                case c.SyntaxKind.VoidExpression:
                case c.SyntaxKind.TypeOfExpression:
                case c.SyntaxKind.PropertyAccessExpression:
                case c.SyntaxKind.SpreadElement:
                case c.SyntaxKind.PartiallyEmittedExpression:
                  k = k.expression;
                  continue;
                case c.SyntaxKind.BinaryExpression:
                  if (N(k.operatorToken.kind))
                    return true;
                  Kr.push(k.right), k = k.left;
                  continue;
                case c.SyntaxKind.PrefixUnaryExpression:
                  switch (k.operator) {
                    case c.SyntaxKind.PlusPlusToken:
                    case c.SyntaxKind.MinusMinusToken:
                      return true;
                    default:
                      k = k.operand;
                      continue;
                  }
                case c.SyntaxKind.ElementAccessExpression:
                  k.argumentExpression !== void 0 && Kr.push(k.argumentExpression), k = k.expression;
                  continue;
                case c.SyntaxKind.ConditionalExpression:
                  Kr.push(k.whenTrue, k.whenFalse), k = k.condition;
                  continue;
                case c.SyntaxKind.NewExpression:
                  if (ue & 2)
                    return true;
                  k.arguments !== void 0 && Kr.push(...k.arguments), k = k.expression;
                  continue;
                case c.SyntaxKind.TaggedTemplateExpression:
                  if (ue & 1)
                    return true;
                  if (Kr.push(k.tag), k = k.template, k.kind === c.SyntaxKind.NoSubstitutionTemplateLiteral)
                    break;
                case c.SyntaxKind.TemplateExpression:
                  for (let Hr of k.templateSpans)
                    Kr.push(Hr.expression);
                  break;
                case c.SyntaxKind.ClassExpression: {
                  if (k.decorators !== void 0)
                    return true;
                  for (let Ct of k.members) {
                    if (Ct.decorators !== void 0)
                      return true;
                    if (!F(Ct.modifiers, c.SyntaxKind.DeclareKeyword))
                      if (((Qe = Ct.name) === null || Qe === void 0 ? void 0 : Qe.kind) === c.SyntaxKind.ComputedPropertyName && Kr.push(Ct.name.expression), A.isMethodDeclaration(Ct)) {
                        for (let Xt of Ct.parameters)
                          if (Xt.decorators !== void 0)
                            return true;
                      } else
                        A.isPropertyDeclaration(Ct) && Ct.initializer !== void 0 && F(Ct.modifiers, c.SyntaxKind.StaticKeyword) && Kr.push(Ct.initializer);
                  }
                  let Hr = at(k);
                  if (Hr === void 0)
                    break;
                  k = Hr.expression;
                  continue;
                }
                case c.SyntaxKind.ArrayLiteralExpression:
                  Kr.push(...k.elements);
                  break;
                case c.SyntaxKind.ObjectLiteralExpression:
                  for (let Hr of k.properties)
                    switch (((Sr = Hr.name) === null || Sr === void 0 ? void 0 : Sr.kind) === c.SyntaxKind.ComputedPropertyName && Kr.push(Hr.name.expression), Hr.kind) {
                      case c.SyntaxKind.PropertyAssignment:
                        Kr.push(Hr.initializer);
                        break;
                      case c.SyntaxKind.SpreadAssignment:
                        Kr.push(Hr.expression);
                    }
                  break;
                case c.SyntaxKind.JsxExpression:
                  if (k.expression === void 0)
                    break;
                  k = k.expression;
                  continue;
                case c.SyntaxKind.JsxElement:
                case c.SyntaxKind.JsxFragment:
                  for (let Hr of k.children)
                    Hr.kind !== c.SyntaxKind.JsxText && Kr.push(Hr);
                  if (k.kind === c.SyntaxKind.JsxFragment)
                    break;
                  k = k.openingElement;
                case c.SyntaxKind.JsxSelfClosingElement:
                case c.SyntaxKind.JsxOpeningElement:
                  if (ue & 4)
                    return true;
                  for (let Hr of k.attributes.properties)
                    Hr.kind === c.SyntaxKind.JsxSpreadAttribute ? Kr.push(Hr.expression) : Hr.initializer !== void 0 && Kr.push(Hr.initializer);
                  break;
                case c.SyntaxKind.CommaListExpression:
                  Kr.push(...k.elements);
              }
              if (Kr.length === 0)
                return false;
              k = Kr.pop();
            }
          }
          __name(Br, "Br");
          a.hasSideEffects = Br;
          function ut(k) {
            let ue = k.parent.parent;
            for (; ue.kind === c.SyntaxKind.BindingElement; )
              ue = ue.parent.parent;
            return ue;
          }
          __name(ut, "ut");
          a.getDeclarationOfBindingElement = ut;
          function rt(k) {
            for (; ; ) {
              let ue = k.parent;
              switch (ue.kind) {
                case c.SyntaxKind.CallExpression:
                case c.SyntaxKind.NewExpression:
                case c.SyntaxKind.ElementAccessExpression:
                case c.SyntaxKind.WhileStatement:
                case c.SyntaxKind.DoStatement:
                case c.SyntaxKind.WithStatement:
                case c.SyntaxKind.ThrowStatement:
                case c.SyntaxKind.ReturnStatement:
                case c.SyntaxKind.JsxExpression:
                case c.SyntaxKind.JsxSpreadAttribute:
                case c.SyntaxKind.JsxElement:
                case c.SyntaxKind.JsxFragment:
                case c.SyntaxKind.JsxSelfClosingElement:
                case c.SyntaxKind.ComputedPropertyName:
                case c.SyntaxKind.ArrowFunction:
                case c.SyntaxKind.ExportSpecifier:
                case c.SyntaxKind.ExportAssignment:
                case c.SyntaxKind.ImportDeclaration:
                case c.SyntaxKind.ExternalModuleReference:
                case c.SyntaxKind.Decorator:
                case c.SyntaxKind.TaggedTemplateExpression:
                case c.SyntaxKind.TemplateSpan:
                case c.SyntaxKind.ExpressionWithTypeArguments:
                case c.SyntaxKind.TypeOfExpression:
                case c.SyntaxKind.AwaitExpression:
                case c.SyntaxKind.YieldExpression:
                case c.SyntaxKind.LiteralType:
                case c.SyntaxKind.JsxAttributes:
                case c.SyntaxKind.JsxOpeningElement:
                case c.SyntaxKind.JsxClosingElement:
                case c.SyntaxKind.IfStatement:
                case c.SyntaxKind.CaseClause:
                case c.SyntaxKind.SwitchStatement:
                  return true;
                case c.SyntaxKind.PropertyAccessExpression:
                  return ue.expression === k;
                case c.SyntaxKind.QualifiedName:
                  return ue.left === k;
                case c.SyntaxKind.ShorthandPropertyAssignment:
                  return ue.objectAssignmentInitializer === k || !Z(ue);
                case c.SyntaxKind.PropertyAssignment:
                  return ue.initializer === k && !Z(ue);
                case c.SyntaxKind.SpreadAssignment:
                case c.SyntaxKind.SpreadElement:
                case c.SyntaxKind.ArrayLiteralExpression:
                  return !Z(ue);
                case c.SyntaxKind.ParenthesizedExpression:
                case c.SyntaxKind.AsExpression:
                case c.SyntaxKind.TypeAssertionExpression:
                case c.SyntaxKind.PostfixUnaryExpression:
                case c.SyntaxKind.PrefixUnaryExpression:
                case c.SyntaxKind.NonNullExpression:
                  k = ue;
                  continue;
                case c.SyntaxKind.ForStatement:
                  return ue.condition === k;
                case c.SyntaxKind.ForInStatement:
                case c.SyntaxKind.ForOfStatement:
                  return ue.expression === k;
                case c.SyntaxKind.ConditionalExpression:
                  if (ue.condition === k)
                    return true;
                  k = ue;
                  break;
                case c.SyntaxKind.PropertyDeclaration:
                case c.SyntaxKind.BindingElement:
                case c.SyntaxKind.VariableDeclaration:
                case c.SyntaxKind.Parameter:
                case c.SyntaxKind.EnumMember:
                  return ue.initializer === k;
                case c.SyntaxKind.ImportEqualsDeclaration:
                  return ue.moduleReference === k;
                case c.SyntaxKind.CommaListExpression:
                  if (ue.elements[ue.elements.length - 1] !== k)
                    return false;
                  k = ue;
                  break;
                case c.SyntaxKind.BinaryExpression:
                  if (ue.right === k) {
                    if (ue.operatorToken.kind === c.SyntaxKind.CommaToken) {
                      k = ue;
                      break;
                    }
                    return true;
                  }
                  switch (ue.operatorToken.kind) {
                    case c.SyntaxKind.CommaToken:
                    case c.SyntaxKind.EqualsToken:
                      return false;
                    case c.SyntaxKind.EqualsEqualsEqualsToken:
                    case c.SyntaxKind.EqualsEqualsToken:
                    case c.SyntaxKind.ExclamationEqualsEqualsToken:
                    case c.SyntaxKind.ExclamationEqualsToken:
                    case c.SyntaxKind.InstanceOfKeyword:
                    case c.SyntaxKind.PlusToken:
                    case c.SyntaxKind.MinusToken:
                    case c.SyntaxKind.AsteriskToken:
                    case c.SyntaxKind.SlashToken:
                    case c.SyntaxKind.PercentToken:
                    case c.SyntaxKind.AsteriskAsteriskToken:
                    case c.SyntaxKind.GreaterThanToken:
                    case c.SyntaxKind.GreaterThanGreaterThanToken:
                    case c.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                    case c.SyntaxKind.GreaterThanEqualsToken:
                    case c.SyntaxKind.LessThanToken:
                    case c.SyntaxKind.LessThanLessThanToken:
                    case c.SyntaxKind.LessThanEqualsToken:
                    case c.SyntaxKind.AmpersandToken:
                    case c.SyntaxKind.BarToken:
                    case c.SyntaxKind.CaretToken:
                    case c.SyntaxKind.BarBarToken:
                    case c.SyntaxKind.AmpersandAmpersandToken:
                    case c.SyntaxKind.QuestionQuestionToken:
                    case c.SyntaxKind.InKeyword:
                    case c.SyntaxKind.QuestionQuestionEqualsToken:
                    case c.SyntaxKind.AmpersandAmpersandEqualsToken:
                    case c.SyntaxKind.BarBarEqualsToken:
                      return true;
                    default:
                      k = ue;
                  }
                  break;
                default:
                  return false;
              }
            }
          }
          __name(rt, "rt");
          a.isExpressionValueUsed = rt;
          function Z(k) {
            switch (k.kind) {
              case c.SyntaxKind.ShorthandPropertyAssignment:
                if (k.objectAssignmentInitializer !== void 0)
                  return true;
              case c.SyntaxKind.PropertyAssignment:
              case c.SyntaxKind.SpreadAssignment:
                k = k.parent;
                break;
              case c.SyntaxKind.SpreadElement:
                if (k.parent.kind !== c.SyntaxKind.ArrayLiteralExpression)
                  return false;
                k = k.parent;
            }
            for (; ; )
              switch (k.parent.kind) {
                case c.SyntaxKind.BinaryExpression:
                  return k.parent.left === k && k.parent.operatorToken.kind === c.SyntaxKind.EqualsToken;
                case c.SyntaxKind.ForOfStatement:
                  return k.parent.initializer === k;
                case c.SyntaxKind.ArrayLiteralExpression:
                case c.SyntaxKind.ObjectLiteralExpression:
                  k = k.parent;
                  break;
                case c.SyntaxKind.SpreadAssignment:
                case c.SyntaxKind.PropertyAssignment:
                  k = k.parent.parent;
                  break;
                case c.SyntaxKind.SpreadElement:
                  if (k.parent.parent.kind !== c.SyntaxKind.ArrayLiteralExpression)
                    return false;
                  k = k.parent.parent;
                  break;
                default:
                  return false;
              }
          }
          __name(Z, "Z");
          var f;
          (function(k) {
            k[k.None = 0] = "None", k[k.Read = 1] = "Read", k[k.Write = 2] = "Write", k[k.Delete = 4] = "Delete", k[k.ReadWrite = 3] = "ReadWrite", k[k.Modification = 6] = "Modification";
          })(f = a.AccessKind || (a.AccessKind = {}));
          function h(k) {
            let ue = k.parent;
            switch (ue.kind) {
              case c.SyntaxKind.DeleteExpression:
                return 4;
              case c.SyntaxKind.PostfixUnaryExpression:
                return 3;
              case c.SyntaxKind.PrefixUnaryExpression:
                return ue.operator === c.SyntaxKind.PlusPlusToken || ue.operator === c.SyntaxKind.MinusMinusToken ? 3 : 1;
              case c.SyntaxKind.BinaryExpression:
                return ue.right === k ? 1 : N(ue.operatorToken.kind) ? ue.operatorToken.kind === c.SyntaxKind.EqualsToken ? 2 : 3 : 1;
              case c.SyntaxKind.ShorthandPropertyAssignment:
                return ue.objectAssignmentInitializer === k ? 1 : Z(ue) ? 2 : 1;
              case c.SyntaxKind.PropertyAssignment:
                return ue.name === k ? 0 : Z(ue) ? 2 : 1;
              case c.SyntaxKind.ArrayLiteralExpression:
              case c.SyntaxKind.SpreadElement:
              case c.SyntaxKind.SpreadAssignment:
                return Z(ue) ? 2 : 1;
              case c.SyntaxKind.ParenthesizedExpression:
              case c.SyntaxKind.NonNullExpression:
              case c.SyntaxKind.TypeAssertionExpression:
              case c.SyntaxKind.AsExpression:
                return h(ue);
              case c.SyntaxKind.ForOfStatement:
              case c.SyntaxKind.ForInStatement:
                return ue.initializer === k ? 2 : 1;
              case c.SyntaxKind.ExpressionWithTypeArguments:
                return ue.parent.token === c.SyntaxKind.ExtendsKeyword && ue.parent.parent.kind !== c.SyntaxKind.InterfaceDeclaration ? 1 : 0;
              case c.SyntaxKind.ComputedPropertyName:
              case c.SyntaxKind.ExpressionStatement:
              case c.SyntaxKind.TypeOfExpression:
              case c.SyntaxKind.ElementAccessExpression:
              case c.SyntaxKind.ForStatement:
              case c.SyntaxKind.IfStatement:
              case c.SyntaxKind.DoStatement:
              case c.SyntaxKind.WhileStatement:
              case c.SyntaxKind.SwitchStatement:
              case c.SyntaxKind.WithStatement:
              case c.SyntaxKind.ThrowStatement:
              case c.SyntaxKind.CallExpression:
              case c.SyntaxKind.NewExpression:
              case c.SyntaxKind.TaggedTemplateExpression:
              case c.SyntaxKind.JsxExpression:
              case c.SyntaxKind.Decorator:
              case c.SyntaxKind.TemplateSpan:
              case c.SyntaxKind.JsxOpeningElement:
              case c.SyntaxKind.JsxSelfClosingElement:
              case c.SyntaxKind.JsxSpreadAttribute:
              case c.SyntaxKind.VoidExpression:
              case c.SyntaxKind.ReturnStatement:
              case c.SyntaxKind.AwaitExpression:
              case c.SyntaxKind.YieldExpression:
              case c.SyntaxKind.ConditionalExpression:
              case c.SyntaxKind.CaseClause:
              case c.SyntaxKind.JsxElement:
                return 1;
              case c.SyntaxKind.ArrowFunction:
                return ue.body === k ? 1 : 2;
              case c.SyntaxKind.PropertyDeclaration:
              case c.SyntaxKind.VariableDeclaration:
              case c.SyntaxKind.Parameter:
              case c.SyntaxKind.EnumMember:
              case c.SyntaxKind.BindingElement:
              case c.SyntaxKind.JsxAttribute:
                return ue.initializer === k ? 1 : 0;
              case c.SyntaxKind.PropertyAccessExpression:
                return ue.expression === k ? 1 : 0;
              case c.SyntaxKind.ExportAssignment:
                return ue.isExportEquals ? 1 : 0;
            }
            return 0;
          }
          __name(h, "h");
          a.getAccessKind = h;
          function ae(k) {
            return (h(k) & 2) !== 0;
          }
          __name(ae, "ae");
          a.isReassignmentTarget = ae;
          function xr(k) {
            switch (k.kind) {
              case c.SyntaxKind.Parameter:
              case c.SyntaxKind.CallSignature:
              case c.SyntaxKind.ConstructSignature:
              case c.SyntaxKind.MethodSignature:
              case c.SyntaxKind.PropertySignature:
              case c.SyntaxKind.ArrowFunction:
              case c.SyntaxKind.ParenthesizedExpression:
              case c.SyntaxKind.SpreadAssignment:
              case c.SyntaxKind.ShorthandPropertyAssignment:
              case c.SyntaxKind.PropertyAssignment:
              case c.SyntaxKind.FunctionExpression:
              case c.SyntaxKind.LabeledStatement:
              case c.SyntaxKind.ExpressionStatement:
              case c.SyntaxKind.VariableStatement:
              case c.SyntaxKind.FunctionDeclaration:
              case c.SyntaxKind.Constructor:
              case c.SyntaxKind.MethodDeclaration:
              case c.SyntaxKind.PropertyDeclaration:
              case c.SyntaxKind.GetAccessor:
              case c.SyntaxKind.SetAccessor:
              case c.SyntaxKind.ClassDeclaration:
              case c.SyntaxKind.ClassExpression:
              case c.SyntaxKind.InterfaceDeclaration:
              case c.SyntaxKind.TypeAliasDeclaration:
              case c.SyntaxKind.EnumMember:
              case c.SyntaxKind.EnumDeclaration:
              case c.SyntaxKind.ModuleDeclaration:
              case c.SyntaxKind.ImportEqualsDeclaration:
              case c.SyntaxKind.ImportDeclaration:
              case c.SyntaxKind.NamespaceExportDeclaration:
              case c.SyntaxKind.ExportAssignment:
              case c.SyntaxKind.IndexSignature:
              case c.SyntaxKind.FunctionType:
              case c.SyntaxKind.ConstructorType:
              case c.SyntaxKind.JSDocFunctionType:
              case c.SyntaxKind.ExportDeclaration:
              case c.SyntaxKind.NamedTupleMember:
              case c.SyntaxKind.EndOfFileToken:
                return true;
              default:
                return false;
            }
          }
          __name(xr, "xr");
          a.canHaveJsDoc = xr;
          function jr(k, ue) {
            let Qe = [];
            for (let Sr of k.getChildren(ue)) {
              if (!A.isJsDoc(Sr))
                break;
              Qe.push(Sr);
            }
            return Qe;
          }
          __name(jr, "jr");
          a.getJsDoc = jr;
          function qr(k, ue) {
            let Qe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : k.getSourceFile();
            if (xr(k) && k.kind !== c.SyntaxKind.EndOfFileToken) {
              let Sr = jr(k, Qe);
              if (Sr.length !== 0 || !ue)
                return Sr;
            }
            return pt(k, k.getStart(Qe), Qe, ue);
          }
          __name(qr, "qr");
          a.parseJsDocOfNode = qr;
          function pt(k, ue, Qe, Sr) {
            let Kr = c[Sr && Dr(Qe, k.pos, ue) ? "forEachTrailingCommentRange" : "forEachLeadingCommentRange"](Qe.text, k.pos, (yn, hn, ln) => ln === c.SyntaxKind.MultiLineCommentTrivia && Qe.text[yn + 2] === "*" ? { pos: yn } : void 0);
            if (Kr === void 0)
              return [];
            let Hr = Kr.pos, Ct = Qe.text.slice(Hr, ue), Xt = c.createSourceFile("jsdoc.ts", `${Ct}var a;`, Qe.languageVersion), cn = jr(Xt.statements[0], Xt);
            for (let yn of cn)
              In(yn, k);
            return cn;
            function In(yn, hn) {
              return yn.pos += Hr, yn.end += Hr, yn.parent = hn, c.forEachChild(yn, (ln) => In(ln, yn), (ln) => {
                ln.pos += Hr, ln.end += Hr;
                for (let En of ln)
                  In(En, yn);
              });
            }
            __name(In, "In");
          }
          __name(pt, "pt");
          var Ge;
          (function(k) {
            k[k.ImportDeclaration = 1] = "ImportDeclaration", k[k.ImportEquals = 2] = "ImportEquals", k[k.ExportFrom = 4] = "ExportFrom", k[k.DynamicImport = 8] = "DynamicImport", k[k.Require = 16] = "Require", k[k.ImportType = 32] = "ImportType", k[k.All = 63] = "All", k[k.AllImports = 59] = "AllImports", k[k.AllStaticImports = 3] = "AllStaticImports", k[k.AllImportExpressions = 24] = "AllImportExpressions", k[k.AllRequireLike = 18] = "AllRequireLike", k[k.AllNestedImports = 56] = "AllNestedImports", k[k.AllTopLevelImports = 7] = "AllTopLevelImports";
          })(Ge = a.ImportKind || (a.ImportKind = {}));
          function K(k, ue) {
            let Qe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true, Sr = [];
            for (let Hr of r(k, ue, Qe))
              switch (Hr.kind) {
                case c.SyntaxKind.ImportDeclaration:
                  Kr(Hr.moduleSpecifier);
                  break;
                case c.SyntaxKind.ImportEqualsDeclaration:
                  Kr(Hr.moduleReference.expression);
                  break;
                case c.SyntaxKind.ExportDeclaration:
                  Kr(Hr.moduleSpecifier);
                  break;
                case c.SyntaxKind.CallExpression:
                  Kr(Hr.arguments[0]);
                  break;
                case c.SyntaxKind.ImportType:
                  A.isLiteralTypeNode(Hr.argument) && Kr(Hr.argument.literal);
                  break;
                default:
                  throw new Error("unexpected node");
              }
            return Sr;
            function Kr(Hr) {
              A.isTextualLiteral(Hr) && Sr.push(Hr);
            }
            __name(Kr, "Kr");
          }
          __name(K, "K");
          a.findImports = K;
          function r(k, ue) {
            let Qe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            return new ct(k, ue, Qe).find();
          }
          __name(r, "r");
          a.findImportLikeNodes = r;
          var ct = /* @__PURE__ */ __name(class {
            constructor(k, ue, Qe) {
              this._sourceFile = k, this._options = ue, this._ignoreFileName = Qe, this._result = [];
            }
            find() {
              return this._sourceFile.isDeclarationFile && (this._options &= -25), this._options & 7 && this._findImports(this._sourceFile.statements), this._options & 56 && this._findNestedImports(), this._result;
            }
            _findImports(k) {
              for (let ue of k)
                A.isImportDeclaration(ue) ? this._options & 1 && this._result.push(ue) : A.isImportEqualsDeclaration(ue) ? this._options & 2 && ue.moduleReference.kind === c.SyntaxKind.ExternalModuleReference && this._result.push(ue) : A.isExportDeclaration(ue) ? ue.moduleSpecifier !== void 0 && this._options & 4 && this._result.push(ue) : A.isModuleDeclaration(ue) && this._findImportsInModule(ue);
            }
            _findImportsInModule(k) {
              if (k.body !== void 0) {
                if (k.body.kind === c.SyntaxKind.ModuleDeclaration)
                  return this._findImportsInModule(k.body);
                this._findImports(k.body.statements);
              }
            }
            _findNestedImports() {
              let k = this._ignoreFileName || (this._sourceFile.flags & c.NodeFlags.JavaScriptFile) !== 0, ue, Qe;
              if ((this._options & 56) === 16) {
                if (!k)
                  return;
                ue = /\brequire\s*[</(]/g, Qe = false;
              } else
                this._options & 16 && k ? (ue = /\b(?:import|require)\s*[</(]/g, Qe = (this._options & 32) !== 0) : (ue = /\bimport\s*[</(]/g, Qe = k && (this._options & 32) !== 0);
              for (let Sr = ue.exec(this._sourceFile.text); Sr !== null; Sr = ue.exec(this._sourceFile.text)) {
                let Kr = B(this._sourceFile, Sr.index, this._sourceFile, Sr[0][0] === "i" && Qe);
                if (Kr.kind === c.SyntaxKind.ImportKeyword) {
                  if (Kr.end - 6 !== Sr.index)
                    continue;
                  switch (Kr.parent.kind) {
                    case c.SyntaxKind.ImportType:
                      this._result.push(Kr.parent);
                      break;
                    case c.SyntaxKind.CallExpression:
                      Kr.parent.arguments.length > 1 && this._result.push(Kr.parent);
                  }
                } else
                  Kr.kind === c.SyntaxKind.Identifier && Kr.end - 7 === Sr.index && Kr.parent.kind === c.SyntaxKind.CallExpression && Kr.parent.expression === Kr && Kr.parent.arguments.length === 1 && this._result.push(Kr.parent);
              }
            }
          }, "ct");
          function ft(k) {
            for (; k.flags & c.NodeFlags.NestedNamespace; )
              k = k.parent;
            return F(k.modifiers, c.SyntaxKind.DeclareKeyword) || Ie(k.parent);
          }
          __name(ft, "ft");
          a.isStatementInAmbientContext = ft;
          function Ie(k) {
            for (; k.kind === c.SyntaxKind.ModuleBlock; ) {
              do
                k = k.parent;
              while (k.flags & c.NodeFlags.NestedNamespace);
              if (F(k.modifiers, c.SyntaxKind.DeclareKeyword))
                return true;
              k = k.parent;
            }
            return false;
          }
          __name(Ie, "Ie");
          a.isAmbientModuleBlock = Ie;
          function me(k) {
            let ue = k.parent;
            for (; ue.kind === c.SyntaxKind.ParenthesizedExpression; )
              ue = ue.parent;
            return A.isCallExpression(ue) && k.end <= ue.expression.end ? ue : void 0;
          }
          __name(me, "me");
          a.getIIFE = me;
          function xe(k, ue) {
            return (k.strict ? k[ue] !== false : k[ue] === true) && (ue !== "strictPropertyInitialization" || xe(k, "strictNullChecks"));
          }
          __name(xe, "xe");
          a.isStrictCompilerOptionEnabled = xe;
          function Ye(k, ue) {
            switch (ue) {
              case "stripInternal":
              case "declarationMap":
              case "emitDeclarationOnly":
                return k[ue] === true && Ye(k, "declaration");
              case "declaration":
                return k.declaration || Ye(k, "composite");
              case "incremental":
                return k.incremental === void 0 ? Ye(k, "composite") : k.incremental;
              case "skipDefaultLibCheck":
                return k.skipDefaultLibCheck || Ye(k, "skipLibCheck");
              case "suppressImplicitAnyIndexErrors":
                return k.suppressImplicitAnyIndexErrors === true && Ye(k, "noImplicitAny");
              case "allowSyntheticDefaultImports":
                return k.allowSyntheticDefaultImports !== void 0 ? k.allowSyntheticDefaultImports : Ye(k, "esModuleInterop") || k.module === c.ModuleKind.System;
              case "noUncheckedIndexedAccess":
                return k.noUncheckedIndexedAccess === true && Ye(k, "strictNullChecks");
              case "allowJs":
                return k.allowJs === void 0 ? Ye(k, "checkJs") : k.allowJs;
              case "noImplicitAny":
              case "noImplicitThis":
              case "strictNullChecks":
              case "strictFunctionTypes":
              case "strictPropertyInitialization":
              case "alwaysStrict":
              case "strictBindCallApply":
                return xe(k, ue);
            }
            return k[ue] === true;
          }
          __name(Ye, "Ye");
          a.isCompilerOptionEnabled = Ye;
          function vr(k) {
            return k.name.kind === c.SyntaxKind.StringLiteral || (k.flags & c.NodeFlags.GlobalAugmentation) !== 0;
          }
          __name(vr, "vr");
          a.isAmbientModule = vr;
          function nt(k) {
            return pr(k);
          }
          __name(nt, "nt");
          a.getCheckJsDirective = nt;
          function pr(k) {
            let ue;
            return c.forEachLeadingCommentRange(k, (c.getShebang(k) || "").length, (Qe, Sr, Kr) => {
              if (Kr === c.SyntaxKind.SingleLineCommentTrivia) {
                let Hr = k.slice(Qe, Sr), Ct = /^\/{2,3}\s*@ts-(no)?check(?:\s|$)/i.exec(Hr);
                Ct !== null && (ue = { pos: Qe, end: Sr, enabled: Ct[1] === void 0 });
              }
            }), ue;
          }
          __name(pr, "pr");
          a.getTsCheckDirective = pr;
          function Mr(k) {
            return A.isTypeReferenceNode(k.type) && k.type.typeName.kind === c.SyntaxKind.Identifier && k.type.typeName.escapedText === "const";
          }
          __name(Mr, "Mr");
          a.isConstAssertion = Mr;
          function ot(k) {
            let ue = k;
            for (; ; ) {
              let Qe = ue.parent;
              e:
                switch (Qe.kind) {
                  case c.SyntaxKind.TypeAssertionExpression:
                  case c.SyntaxKind.AsExpression:
                    return Mr(Qe);
                  case c.SyntaxKind.PrefixUnaryExpression:
                    if (ue.kind !== c.SyntaxKind.NumericLiteral)
                      return false;
                    switch (Qe.operator) {
                      case c.SyntaxKind.PlusToken:
                      case c.SyntaxKind.MinusToken:
                        ue = Qe;
                        break e;
                      default:
                        return false;
                    }
                  case c.SyntaxKind.PropertyAssignment:
                    if (Qe.initializer !== ue)
                      return false;
                    ue = Qe.parent;
                    break;
                  case c.SyntaxKind.ShorthandPropertyAssignment:
                    ue = Qe.parent;
                    break;
                  case c.SyntaxKind.ParenthesizedExpression:
                  case c.SyntaxKind.ArrayLiteralExpression:
                  case c.SyntaxKind.ObjectLiteralExpression:
                  case c.SyntaxKind.TemplateExpression:
                    ue = Qe;
                    break;
                  default:
                    return false;
                }
            }
          }
          __name(ot, "ot");
          a.isInConstContext = ot;
          function At(k, ue) {
            if (!re(k))
              return false;
            let Qe = ue.getTypeAtLocation(k.arguments[2]);
            if (Qe.getProperty("value") === void 0)
              return Qe.getProperty("set") === void 0;
            let Sr = Qe.getProperty("writable");
            if (Sr === void 0)
              return false;
            let Kr = Sr.valueDeclaration !== void 0 && A.isPropertyAssignment(Sr.valueDeclaration) ? ue.getTypeAtLocation(Sr.valueDeclaration.initializer) : ue.getTypeOfSymbolAtLocation(Sr, k.arguments[2]);
            return oe.isBooleanLiteralType(Kr, false);
          }
          __name(At, "At");
          a.isReadonlyAssignmentDeclaration = At;
          function re(k) {
            return k.arguments.length === 3 && A.isEntityNameExpression(k.arguments[0]) && A.isNumericOrStringLikeLiteral(k.arguments[1]) && A.isPropertyAccessExpression(k.expression) && k.expression.name.escapedText === "defineProperty" && A.isIdentifier(k.expression.expression) && k.expression.expression.escapedText === "Object";
          }
          __name(re, "re");
          a.isBindableObjectDefinePropertyCall = re;
          function de(k) {
            return c.isPropertyAccessExpression(k) && c.isIdentifier(k.expression) && k.expression.escapedText === "Symbol";
          }
          __name(de, "de");
          a.isWellKnownSymbolLiterally = de;
          function He(k) {
            return { displayName: `[Symbol.${k.name.text}]`, symbolName: "__@" + k.name.text };
          }
          __name(He, "He");
          a.getPropertyNameOfWellKnownSymbol = He;
          var Nr = ((k) => {
            let [ue, Qe] = k;
            return ue < "4" || ue === "4" && Qe < "3";
          })(c.versionMajorMinor.split("."));
          function Yr(k, ue) {
            let Qe = { known: true, names: [] };
            if (k = Lt(k), Nr && de(k))
              Qe.names.push(He(k));
            else {
              let Sr = ue.getTypeAtLocation(k);
              for (let Kr of oe.unionTypeParts(ue.getBaseConstraintOfType(Sr) || Sr)) {
                let Hr = oe.getPropertyNameFromType(Kr);
                Hr ? Qe.names.push(Hr) : Qe.known = false;
              }
            }
            return Qe;
          }
          __name(Yr, "Yr");
          a.getLateBoundPropertyNames = Yr;
          function St(k, ue) {
            let Qe = te(k);
            return Qe !== void 0 ? { known: true, names: [{ displayName: Qe, symbolName: c.escapeLeadingUnderscores(Qe) }] } : k.kind === c.SyntaxKind.PrivateIdentifier ? { known: true, names: [{ displayName: k.text, symbolName: ue.getSymbolAtLocation(k).escapedName }] } : Yr(k.expression, ue);
          }
          __name(St, "St");
          a.getLateBoundPropertyNamesOfPropertyName = St;
          function Dt(k, ue) {
            let Qe = te(k);
            if (Qe !== void 0)
              return { displayName: Qe, symbolName: c.escapeLeadingUnderscores(Qe) };
            if (k.kind === c.SyntaxKind.PrivateIdentifier)
              return { displayName: k.text, symbolName: ue.getSymbolAtLocation(k).escapedName };
            let { expression: Sr } = k;
            return Nr && de(Sr) ? He(Sr) : oe.getPropertyNameFromType(ue.getTypeAtLocation(Sr));
          }
          __name(Dt, "Dt");
          a.getSingleLateBoundPropertyNameOfPropertyName = Dt;
          function Lt(k) {
            for (; k.kind === c.SyntaxKind.ParenthesizedExpression; )
              k = k.expression;
            return k;
          }
          __name(Lt, "Lt");
          a.unwrapParentheses = Lt;
          function zt(k) {
            return `${k.negative ? "-" : ""}${k.base10Value}n`;
          }
          __name(zt, "zt");
          a.formatPseudoBigInt = zt;
          function Zt(k, ue) {
            let Qe = k.caseBlock.clauses.filter(A.isCaseClause);
            if (Qe.length === 0)
              return false;
            let Sr = oe.unionTypeParts(ue.getTypeAtLocation(k.expression));
            if (Sr.length > Qe.length)
              return false;
            let Kr = new Set(Sr.map(mt));
            if (Kr.has(void 0))
              return false;
            let Hr = /* @__PURE__ */ new Set();
            for (let Ct of Qe) {
              let Xt = ue.getTypeAtLocation(Ct.expression);
              if (a.isTypeFlagSet(Xt, c.TypeFlags.Never))
                continue;
              let cn = mt(Xt);
              if (Kr.has(cn))
                Hr.add(cn);
              else if (cn !== "null" && cn !== "undefined")
                return false;
            }
            return Kr.size === Hr.size;
          }
          __name(Zt, "Zt");
          a.hasExhaustiveCaseClauses = Zt;
          function mt(k) {
            if (a.isTypeFlagSet(k, c.TypeFlags.Null))
              return "null";
            if (a.isTypeFlagSet(k, c.TypeFlags.Undefined))
              return "undefined";
            if (a.isTypeFlagSet(k, c.TypeFlags.NumberLiteral))
              return `${a.isTypeFlagSet(k, c.TypeFlags.EnumLiteral) ? "enum:" : ""}${k.value}`;
            if (a.isTypeFlagSet(k, c.TypeFlags.StringLiteral))
              return `${a.isTypeFlagSet(k, c.TypeFlags.EnumLiteral) ? "enum:" : ""}string:${k.value}`;
            if (a.isTypeFlagSet(k, c.TypeFlags.BigIntLiteral))
              return zt(k.value);
            if (T.isUniqueESSymbolType(k))
              return k.escapedName;
            if (oe.isBooleanLiteralType(k, true))
              return "true";
            if (oe.isBooleanLiteralType(k, false))
              return "false";
          }
          __name(mt, "mt");
          function at(k) {
            var ue;
            if (((ue = k.heritageClauses) === null || ue === void 0 ? void 0 : ue[0].token) === c.SyntaxKind.ExtendsKeyword)
              return k.heritageClauses[0].types[0];
          }
          __name(at, "at");
          a.getBaseOfClassLikeExpression = at;
        } }), FE = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/convert-comments.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(e, t, x, s) {
            s === void 0 && (s = x);
            var q = Object.getOwnPropertyDescriptor(t, x);
            (!q || ("get" in q ? !t.__esModule : q.writable || q.configurable)) && (q = { enumerable: true, get: function() {
              return t[x];
            } }), Object.defineProperty(e, s, q);
          } : function(e, t, x, s) {
            s === void 0 && (s = x), e[s] = t[x];
          }), A = a && a.__setModuleDefault || (Object.create ? function(e, t) {
            Object.defineProperty(e, "default", { enumerable: true, value: t });
          } : function(e, t) {
            e.default = t;
          }), T = a && a.__importStar || function(e) {
            if (e && e.__esModule)
              return e;
            var t = {};
            if (e != null)
              for (var x in e)
                x !== "default" && Object.prototype.hasOwnProperty.call(e, x) && c(t, e, x);
            return A(t, e), t;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.convertComments = void 0;
          var oe = ny(), z = T(xi()), I = Al(), E = wl();
          function N(e, t) {
            let x = [];
            return (0, oe.forEachComment)(e, (s, q) => {
              let F = q.kind == z.SyntaxKind.SingleLineCommentTrivia ? E.AST_TOKEN_TYPES.Line : E.AST_TOKEN_TYPES.Block, fe = [q.pos, q.end], Te = (0, I.getLocFor)(fe[0], fe[1], e), Se = fe[0] + 2, J = q.kind === z.SyntaxKind.SingleLineCommentTrivia ? fe[1] - Se : fe[1] - Se - 2;
              x.push({ type: F, value: t.slice(Se, Se + J), range: fe, loc: Te });
            }, e), x;
          }
          __name(N, "N");
          a.convertComments = N;
        } }), iy = Ur({ "node_modules/eslint-visitor-keys/dist/eslint-visitor-keys.cjs"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true });
          var c = { AssignmentExpression: ["left", "right"], AssignmentPattern: ["left", "right"], ArrayExpression: ["elements"], ArrayPattern: ["elements"], ArrowFunctionExpression: ["params", "body"], AwaitExpression: ["argument"], BlockStatement: ["body"], BinaryExpression: ["left", "right"], BreakStatement: ["label"], CallExpression: ["callee", "arguments"], CatchClause: ["param", "body"], ChainExpression: ["expression"], ClassBody: ["body"], ClassDeclaration: ["id", "superClass", "body"], ClassExpression: ["id", "superClass", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["body", "test"], EmptyStatement: [], ExportAllDeclaration: ["exported", "source"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source"], ExportSpecifier: ["exported", "local"], ExpressionStatement: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], ForStatement: ["init", "test", "update", "body"], ForInStatement: ["left", "right", "body"], ForOfStatement: ["left", "right", "body"], FunctionDeclaration: ["id", "params", "body"], FunctionExpression: ["id", "params", "body"], Identifier: [], IfStatement: ["test", "consequent", "alternate"], ImportDeclaration: ["specifiers", "source"], ImportDefaultSpecifier: ["local"], ImportExpression: ["source"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["imported", "local"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXClosingFragment: [], JSXOpeningFragment: [], Literal: [], LabeledStatement: ["label", "body"], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], MetaProperty: ["meta", "property"], MethodDefinition: ["key", "value"], NewExpression: ["callee", "arguments"], ObjectExpression: ["properties"], ObjectPattern: ["properties"], PrivateIdentifier: [], Program: ["body"], Property: ["key", "value"], PropertyDefinition: ["key", "value"], RestElement: ["argument"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], SpreadElement: ["argument"], StaticBlock: ["body"], Super: [], SwitchStatement: ["discriminant", "cases"], SwitchCase: ["test", "consequent"], TaggedTemplateExpression: ["tag", "quasi"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], YieldExpression: ["argument"] }, A = Object.keys(c);
          for (let E of A)
            Object.freeze(c[E]);
          Object.freeze(c);
          var T = /* @__PURE__ */ new Set(["parent", "leadingComments", "trailingComments"]);
          function oe(E) {
            return !T.has(E) && E[0] !== "_";
          }
          __name(oe, "oe");
          function z(E) {
            return Object.keys(E).filter(oe);
          }
          __name(z, "z");
          function I(E) {
            let N = Object.assign({}, c);
            for (let e of Object.keys(E))
              if (Object.prototype.hasOwnProperty.call(N, e)) {
                let t = new Set(E[e]);
                for (let x of N[e])
                  t.add(x);
                N[e] = Object.freeze(Array.from(t));
              } else
                N[e] = Object.freeze(Array.from(E[e]));
            return Object.freeze(N);
          }
          __name(I, "I");
          a.KEYS = c, a.getKeys = z, a.unionWith = I;
        } }), BE = Ur({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/visitor-keys/dist/get-keys.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.getKeys = void 0;
          var c = iy(), A = c.getKeys;
          a.getKeys = A;
        } }), qE = Ur({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/visitor-keys/dist/visitor-keys.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(N, e, t, x) {
            x === void 0 && (x = t);
            var s = Object.getOwnPropertyDescriptor(e, t);
            (!s || ("get" in s ? !e.__esModule : s.writable || s.configurable)) && (s = { enumerable: true, get: function() {
              return e[t];
            } }), Object.defineProperty(N, x, s);
          } : function(N, e, t, x) {
            x === void 0 && (x = t), N[x] = e[t];
          }), A = a && a.__setModuleDefault || (Object.create ? function(N, e) {
            Object.defineProperty(N, "default", { enumerable: true, value: e });
          } : function(N, e) {
            N.default = e;
          }), T = a && a.__importStar || function(N) {
            if (N && N.__esModule)
              return N;
            var e = {};
            if (N != null)
              for (var t in N)
                t !== "default" && Object.prototype.hasOwnProperty.call(N, t) && c(e, N, t);
            return A(e, N), e;
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.visitorKeys = void 0;
          var oe = T(iy()), z = (() => {
            let N = ["typeParameters", "params", "returnType"], e = [...N, "body"], t = ["decorators", "key", "typeAnnotation"];
            return { AnonymousFunction: e, Function: ["id", ...e], FunctionType: N, ClassDeclaration: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "implements", "body"], AbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], PropertyDefinition: [...t, "value"], TypeAssertion: ["expression", "typeAnnotation"] };
          })(), I = { AccessorProperty: z.PropertyDefinition, ArrayPattern: ["decorators", "elements", "typeAnnotation"], ArrowFunctionExpression: z.AnonymousFunction, AssignmentPattern: ["decorators", "left", "right", "typeAnnotation"], CallExpression: ["callee", "typeParameters", "arguments"], ClassDeclaration: z.ClassDeclaration, ClassExpression: z.ClassDeclaration, Decorator: ["expression"], ExportAllDeclaration: ["exported", "source", "assertions"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "assertions"], FunctionDeclaration: z.Function, FunctionExpression: z.Function, Identifier: ["decorators", "typeAnnotation"], ImportAttribute: ["key", "value"], ImportDeclaration: ["specifiers", "source", "assertions"], ImportExpression: ["source", "attributes"], JSXClosingFragment: [], JSXOpeningElement: ["name", "typeParameters", "attributes"], JSXOpeningFragment: [], JSXSpreadChild: ["expression"], MethodDefinition: ["decorators", "key", "value", "typeParameters"], NewExpression: ["callee", "typeParameters", "arguments"], ObjectPattern: ["decorators", "properties", "typeAnnotation"], PropertyDefinition: z.PropertyDefinition, RestElement: ["decorators", "argument", "typeAnnotation"], StaticBlock: ["body"], TaggedTemplateExpression: ["tag", "typeParameters", "quasi"], TSAbstractAccessorProperty: z.AbstractPropertyDefinition, TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: z.AbstractPropertyDefinition, TSAnyKeyword: [], TSArrayType: ["elementType"], TSAsExpression: z.TypeAssertion, TSAsyncKeyword: [], TSBigIntKeyword: [], TSBooleanKeyword: [], TSCallSignatureDeclaration: z.FunctionType, TSClassImplements: ["expression", "typeParameters"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSConstructorType: z.FunctionType, TSConstructSignatureDeclaration: z.FunctionType, TSDeclareFunction: z.Function, TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", ...z.FunctionType], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSExportAssignment: ["expression"], TSExportKeyword: [], TSExternalModuleReference: ["expression"], TSFunctionType: z.FunctionType, TSImportEqualsDeclaration: ["id", "moduleReference"], TSImportType: ["parameter", "qualifier", "typeParameters"], TSIndexedAccessType: ["indexType", "objectType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSInferType: ["typeParameter"], TSInstantiationExpression: ["expression", "typeParameters"], TSInterfaceBody: ["body"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceHeritage: ["expression", "typeParameters"], TSIntersectionType: ["types"], TSIntrinsicKeyword: [], TSLiteralType: ["literal"], TSMappedType: ["nameType", "typeParameter", "typeAnnotation"], TSMethodSignature: ["typeParameters", "key", "params", "returnType"], TSModuleBlock: ["body"], TSModuleDeclaration: ["id", "body"], TSNamedTupleMember: ["label", "elementType"], TSNamespaceExportDeclaration: ["id"], TSNeverKeyword: [], TSNonNullExpression: ["expression"], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSOptionalType: ["typeAnnotation"], TSParameterProperty: ["decorators", "parameter"], TSPrivateKeyword: [], TSPropertySignature: ["typeAnnotation", "key", "initializer"], TSProtectedKeyword: [], TSPublicKeyword: [], TSQualifiedName: ["left", "right"], TSReadonlyKeyword: [], TSRestType: ["typeAnnotation"], TSSatisfiesExpression: ["typeAnnotation", "expression"], TSStaticKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSTemplateLiteralType: ["quasis", "types"], TSThisType: [], TSTupleType: ["elementTypes"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSTypeAnnotation: ["typeAnnotation"], TSTypeAssertion: z.TypeAssertion, TSTypeLiteral: ["members"], TSTypeOperator: ["typeAnnotation"], TSTypeParameter: ["name", "constraint", "default"], TSTypeParameterDeclaration: ["params"], TSTypeParameterInstantiation: ["params"], TSTypePredicate: ["typeAnnotation", "parameterName"], TSTypeQuery: ["exprName", "typeParameters"], TSTypeReference: ["typeName", "typeParameters"], TSUndefinedKeyword: [], TSUnionType: ["types"], TSUnknownKeyword: [], TSVoidKeyword: [] }, E = oe.unionWith(I);
          a.visitorKeys = E;
        } }), ay = Ur({ "node_modules/@typescript-eslint/typescript-estree/node_modules/@typescript-eslint/visitor-keys/dist/index.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.visitorKeys = a.getKeys = void 0;
          var c = BE();
          Object.defineProperty(a, "getKeys", { enumerable: true, get: function() {
            return c.getKeys;
          } });
          var A = qE();
          Object.defineProperty(a, "visitorKeys", { enumerable: true, get: function() {
            return A.visitorKeys;
          } });
        } }), oy = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/simple-traverse.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.simpleTraverse = void 0;
          var c = ay();
          function A(I) {
            return I !== null && typeof I == "object" && typeof I.type == "string";
          }
          __name(A, "A");
          function T(I, E) {
            let N = I[E.type];
            return N != null ? N : [];
          }
          __name(T, "T");
          var oe = /* @__PURE__ */ __name(class {
            constructor(I) {
              let E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              this.allVisitorKeys = c.visitorKeys, this.selectors = I, this.setParentPointers = E;
            }
            traverse(I, E) {
              if (!A(I))
                return;
              this.setParentPointers && (I.parent = E), "enter" in this.selectors ? this.selectors.enter(I, E) : I.type in this.selectors && this.selectors[I.type](I, E);
              let N = T(this.allVisitorKeys, I);
              if (!(N.length < 1))
                for (let e of N) {
                  let t = I[e];
                  if (Array.isArray(t))
                    for (let x of t)
                      this.traverse(x, I);
                  else
                    this.traverse(t, I);
                }
            }
          }, "oe");
          function z(I, E) {
            let N = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            new oe(E, N).traverse(I, void 0);
          }
          __name(z, "z");
          a.simpleTraverse = z;
        } }), UE = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/ast-converter.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.astConverter = void 0;
          var c = Yg(), A = FE(), T = Al(), oe = oy();
          function z(I, E, N) {
            let { parseDiagnostics: e } = I;
            if (e.length)
              throw (0, c.convertError)(e[0]);
            let t = new c.Converter(I, { errorOnUnknownASTType: E.errorOnUnknownASTType || false, shouldPreserveNodeMaps: N }), x = t.convertProgram();
            (!E.range || !E.loc) && (0, oe.simpleTraverse)(x, { enter: (q) => {
              E.range || delete q.range, E.loc || delete q.loc;
            } }), E.tokens && (x.tokens = (0, T.convertTokens)(I)), E.comment && (x.comments = (0, A.convertComments)(I, E.code));
            let s = t.getASTMaps();
            return { estree: x, astMaps: s };
          }
          __name(z, "z");
          a.astConverter = z;
        } }), sy = {};
        bl(sy, { basename: () => py, default: () => dy, delimiter: () => Vp, dirname: () => ly, extname: () => fy, isAbsolute: () => nf, join: () => cy, normalize: () => tf, relative: () => uy, resolve: () => vl, sep: () => zp });
        function _y(a, c) {
          for (var A = 0, T = a.length - 1; T >= 0; T--) {
            var oe = a[T];
            oe === "." ? a.splice(T, 1) : oe === ".." ? (a.splice(T, 1), A++) : A && (a.splice(T, 1), A--);
          }
          if (c)
            for (; A--; A)
              a.unshift("..");
          return a;
        }
        __name(_y, "_y");
        function vl() {
          for (var a = "", c = false, A = arguments.length - 1; A >= -1 && !c; A--) {
            var T = A >= 0 ? arguments[A] : "/";
            if (typeof T != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!T)
              continue;
            a = T + "/" + a, c = T.charAt(0) === "/";
          }
          return a = _y(af(a.split("/"), function(oe) {
            return !!oe;
          }), !c).join("/"), (c ? "/" : "") + a || ".";
        }
        __name(vl, "vl");
        function tf(a) {
          var c = nf(a), A = my(a, -1) === "/";
          return a = _y(af(a.split("/"), function(T) {
            return !!T;
          }), !c).join("/"), !a && !c && (a = "."), a && A && (a += "/"), (c ? "/" : "") + a;
        }
        __name(tf, "tf");
        function nf(a) {
          return a.charAt(0) === "/";
        }
        __name(nf, "nf");
        function cy() {
          var a = Array.prototype.slice.call(arguments, 0);
          return tf(af(a, function(c, A) {
            if (typeof c != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return c;
          }).join("/"));
        }
        __name(cy, "cy");
        function uy(a, c) {
          a = vl(a).substr(1), c = vl(c).substr(1);
          function A(e) {
            for (var t = 0; t < e.length && e[t] === ""; t++)
              ;
            for (var x = e.length - 1; x >= 0 && e[x] === ""; x--)
              ;
            return t > x ? [] : e.slice(t, x - t + 1);
          }
          __name(A, "A");
          for (var T = A(a.split("/")), oe = A(c.split("/")), z = Math.min(T.length, oe.length), I = z, E = 0; E < z; E++)
            if (T[E] !== oe[E]) {
              I = E;
              break;
            }
          for (var N = [], E = I; E < T.length; E++)
            N.push("..");
          return N = N.concat(oe.slice(I)), N.join("/");
        }
        __name(uy, "uy");
        function ly(a) {
          var c = kl(a), A = c[0], T = c[1];
          return !A && !T ? "." : (T && (T = T.substr(0, T.length - 1)), A + T);
        }
        __name(ly, "ly");
        function py(a, c) {
          var A = kl(a)[2];
          return c && A.substr(-1 * c.length) === c && (A = A.substr(0, A.length - c.length)), A;
        }
        __name(py, "py");
        function fy(a) {
          return kl(a)[3];
        }
        __name(fy, "fy");
        function af(a, c) {
          if (a.filter)
            return a.filter(c);
          for (var A = [], T = 0; T < a.length; T++)
            c(a[T], T, a) && A.push(a[T]);
          return A;
        }
        __name(af, "af");
        var kg, kl, zp, Vp, dy, my, zE = Ju({ "node-modules-polyfills:path"() {
          Jr(), kg = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, kl = /* @__PURE__ */ __name(function(a) {
            return kg.exec(a).slice(1);
          }, "kl"), zp = "/", Vp = ":", dy = { extname: fy, basename: py, dirname: ly, sep: zp, delimiter: Vp, relative: uy, join: cy, isAbsolute: nf, normalize: tf, resolve: vl }, my = "ab".substr(-1) === "b" ? function(a, c, A) {
            return a.substr(c, A);
          } : function(a, c, A) {
            return c < 0 && (c = a.length + c), a.substr(c, A);
          };
        } }), Uc = Ur({ "node-modules-polyfills-commonjs:path"(a, c) {
          Jr();
          var A = (zE(), Ja(sy));
          if (A && A.default) {
            c.exports = A.default;
            for (let T in A)
              c.exports[T] = A[T];
          } else
            A && (c.exports = A);
        } }), zc = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/shared.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(se, Le, Q, Be) {
            Be === void 0 && (Be = Q);
            var je = Object.getOwnPropertyDescriptor(Le, Q);
            (!je || ("get" in je ? !Le.__esModule : je.writable || je.configurable)) && (je = { enumerable: true, get: function() {
              return Le[Q];
            } }), Object.defineProperty(se, Be, je);
          } : function(se, Le, Q, Be) {
            Be === void 0 && (Be = Q), se[Be] = Le[Q];
          }), A = a && a.__setModuleDefault || (Object.create ? function(se, Le) {
            Object.defineProperty(se, "default", { enumerable: true, value: Le });
          } : function(se, Le) {
            se.default = Le;
          }), T = a && a.__importStar || function(se) {
            if (se && se.__esModule)
              return se;
            var Le = {};
            if (se != null)
              for (var Q in se)
                Q !== "default" && Object.prototype.hasOwnProperty.call(se, Q) && c(Le, se, Q);
            return A(Le, se), Le;
          }, oe = a && a.__importDefault || function(se) {
            return se && se.__esModule ? se : { default: se };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.getModuleResolver = a.getAstFromProgram = a.getCanonicalFileName = a.ensureAbsolutePath = a.createDefaultCompilerOptionsFromExtra = a.canonicalDirname = a.CORE_COMPILER_OPTIONS = void 0;
          var z = oe(Uc()), I = T(xi()), E = { noEmit: true, noUnusedLocals: true, noUnusedParameters: true };
          a.CORE_COMPILER_OPTIONS = E;
          var N = Object.assign(Object.assign({}, E), { allowNonTsExtensions: true, allowJs: true, checkJs: true });
          function e(se) {
            return se.debugLevel.has("typescript") ? Object.assign(Object.assign({}, N), { extendedDiagnostics: true }) : N;
          }
          __name(e, "e");
          a.createDefaultCompilerOptionsFromExtra = e;
          var t = I.sys !== void 0 ? I.sys.useCaseSensitiveFileNames : true, x = t ? (se) => se : (se) => se.toLowerCase();
          function s(se) {
            let Le = z.default.normalize(se);
            return Le.endsWith(z.default.sep) && (Le = Le.slice(0, -1)), x(Le);
          }
          __name(s, "s");
          a.getCanonicalFileName = s;
          function q(se, Le) {
            return z.default.isAbsolute(se) ? se : z.default.join(Le || "/prettier-security-dirname-placeholder", se);
          }
          __name(q, "q");
          a.ensureAbsolutePath = q;
          function F(se) {
            return z.default.dirname(se);
          }
          __name(F, "F");
          a.canonicalDirname = F;
          var fe = [I.Extension.Dts, I.Extension.Dcts, I.Extension.Dmts];
          function Te(se) {
            var Le;
            return se ? (Le = fe.find((Q) => se.endsWith(Q))) !== null && Le !== void 0 ? Le : z.default.extname(se) : null;
          }
          __name(Te, "Te");
          function Se(se, Le) {
            let Q = se.getSourceFile(Le.filePath), Be = Te(Le.filePath), je = Te(Q == null ? void 0 : Q.fileName);
            if (Be === je)
              return Q && { ast: Q, program: se };
          }
          __name(Se, "Se");
          a.getAstFromProgram = Se;
          function J(se) {
            let Le;
            try {
              throw new Error("Dynamic require is not supported");
            } catch {
              let Be = ["Could not find the provided parserOptions.moduleResolver.", "Hint: use an absolute path if you are not in control over where the ESLint instance runs."];
              throw new Error(Be.join(`
`));
            }
            return Le;
          }
          __name(J, "J");
          a.getModuleResolver = J;
        } }), VE = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/createDefaultProgram.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(x, s, q, F) {
            F === void 0 && (F = q);
            var fe = Object.getOwnPropertyDescriptor(s, q);
            (!fe || ("get" in fe ? !s.__esModule : fe.writable || fe.configurable)) && (fe = { enumerable: true, get: function() {
              return s[q];
            } }), Object.defineProperty(x, F, fe);
          } : function(x, s, q, F) {
            F === void 0 && (F = q), x[F] = s[q];
          }), A = a && a.__setModuleDefault || (Object.create ? function(x, s) {
            Object.defineProperty(x, "default", { enumerable: true, value: s });
          } : function(x, s) {
            x.default = s;
          }), T = a && a.__importStar || function(x) {
            if (x && x.__esModule)
              return x;
            var s = {};
            if (x != null)
              for (var q in x)
                q !== "default" && Object.prototype.hasOwnProperty.call(x, q) && c(s, x, q);
            return A(s, x), s;
          }, oe = a && a.__importDefault || function(x) {
            return x && x.__esModule ? x : { default: x };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.createDefaultProgram = void 0;
          var z = oe(Ps()), I = oe(Uc()), E = T(xi()), N = zc(), e = (0, z.default)("typescript-eslint:typescript-estree:createDefaultProgram");
          function t(x) {
            var s;
            if (e("Getting default program for: %s", x.filePath || "unnamed file"), ((s = x.projects) === null || s === void 0 ? void 0 : s.length) !== 1)
              return;
            let q = x.projects[0], F = E.getParsedCommandLineOfConfigFile(q, (0, N.createDefaultCompilerOptionsFromExtra)(x), Object.assign(Object.assign({}, E.sys), { onUnRecoverableConfigFileDiagnostic: () => {
            } }));
            if (!F)
              return;
            let fe = E.createCompilerHost(F.options, true);
            x.moduleResolver && (fe.resolveModuleNames = (0, N.getModuleResolver)(x.moduleResolver).resolveModuleNames);
            let Te = fe.readFile;
            fe.readFile = (se) => I.default.normalize(se) === I.default.normalize(x.filePath) ? x.code : Te(se);
            let Se = E.createProgram([x.filePath], F.options, fe), J = Se.getSourceFile(x.filePath);
            return J && { ast: J, program: Se };
          }
          __name(t, "t");
          a.createDefaultProgram = t;
        } }), of = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/getScriptKind.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(e, t, x, s) {
            s === void 0 && (s = x);
            var q = Object.getOwnPropertyDescriptor(t, x);
            (!q || ("get" in q ? !t.__esModule : q.writable || q.configurable)) && (q = { enumerable: true, get: function() {
              return t[x];
            } }), Object.defineProperty(e, s, q);
          } : function(e, t, x, s) {
            s === void 0 && (s = x), e[s] = t[x];
          }), A = a && a.__setModuleDefault || (Object.create ? function(e, t) {
            Object.defineProperty(e, "default", { enumerable: true, value: t });
          } : function(e, t) {
            e.default = t;
          }), T = a && a.__importStar || function(e) {
            if (e && e.__esModule)
              return e;
            var t = {};
            if (e != null)
              for (var x in e)
                x !== "default" && Object.prototype.hasOwnProperty.call(e, x) && c(t, e, x);
            return A(t, e), t;
          }, oe = a && a.__importDefault || function(e) {
            return e && e.__esModule ? e : { default: e };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.getLanguageVariant = a.getScriptKind = void 0;
          var z = oe(Uc()), I = T(xi());
          function E(e, t) {
            switch (z.default.extname(e).toLowerCase()) {
              case I.Extension.Js:
              case I.Extension.Cjs:
              case I.Extension.Mjs:
                return I.ScriptKind.JS;
              case I.Extension.Jsx:
                return I.ScriptKind.JSX;
              case I.Extension.Ts:
              case I.Extension.Cts:
              case I.Extension.Mts:
                return I.ScriptKind.TS;
              case I.Extension.Tsx:
                return I.ScriptKind.TSX;
              case I.Extension.Json:
                return I.ScriptKind.JSON;
              default:
                return t ? I.ScriptKind.TSX : I.ScriptKind.TS;
            }
          }
          __name(E, "E");
          a.getScriptKind = E;
          function N(e) {
            switch (e) {
              case I.ScriptKind.TSX:
              case I.ScriptKind.JSX:
              case I.ScriptKind.JS:
              case I.ScriptKind.JSON:
                return I.LanguageVariant.JSX;
              default:
                return I.LanguageVariant.Standard;
            }
          }
          __name(N, "N");
          a.getLanguageVariant = N;
        } }), WE = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/createIsolatedProgram.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(x, s, q, F) {
            F === void 0 && (F = q);
            var fe = Object.getOwnPropertyDescriptor(s, q);
            (!fe || ("get" in fe ? !s.__esModule : fe.writable || fe.configurable)) && (fe = { enumerable: true, get: function() {
              return s[q];
            } }), Object.defineProperty(x, F, fe);
          } : function(x, s, q, F) {
            F === void 0 && (F = q), x[F] = s[q];
          }), A = a && a.__setModuleDefault || (Object.create ? function(x, s) {
            Object.defineProperty(x, "default", { enumerable: true, value: s });
          } : function(x, s) {
            x.default = s;
          }), T = a && a.__importStar || function(x) {
            if (x && x.__esModule)
              return x;
            var s = {};
            if (x != null)
              for (var q in x)
                q !== "default" && Object.prototype.hasOwnProperty.call(x, q) && c(s, x, q);
            return A(s, x), s;
          }, oe = a && a.__importDefault || function(x) {
            return x && x.__esModule ? x : { default: x };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.createIsolatedProgram = void 0;
          var z = oe(Ps()), I = T(xi()), E = of(), N = zc(), e = (0, z.default)("typescript-eslint:typescript-estree:createIsolatedProgram");
          function t(x) {
            e("Getting isolated program in %s mode for: %s", x.jsx ? "TSX" : "TS", x.filePath);
            let s = { fileExists() {
              return true;
            }, getCanonicalFileName() {
              return x.filePath;
            }, getCurrentDirectory() {
              return "";
            }, getDirectories() {
              return [];
            }, getDefaultLibFileName() {
              return "lib.d.ts";
            }, getNewLine() {
              return `
`;
            }, getSourceFile(fe) {
              return I.createSourceFile(fe, x.code, I.ScriptTarget.Latest, true, (0, E.getScriptKind)(x.filePath, x.jsx));
            }, readFile() {
            }, useCaseSensitiveFileNames() {
              return true;
            }, writeFile() {
              return null;
            } }, q = I.createProgram([x.filePath], Object.assign({ noResolve: true, target: I.ScriptTarget.Latest, jsx: x.jsx ? I.JsxEmit.Preserve : void 0 }, (0, N.createDefaultCompilerOptionsFromExtra)(x)), s), F = q.getSourceFile(x.filePath);
            if (!F)
              throw new Error("Expected an ast to be returned for the single-file isolated program.");
            return { ast: F, program: q };
          }
          __name(t, "t");
          a.createIsolatedProgram = t;
        } }), gy = {};
        bl(gy, { default: () => yy });
        var yy, KE = Ju({ "node-modules-polyfills:fs"() {
          Jr(), yy = {};
        } }), hy = Ur({ "node-modules-polyfills-commonjs:fs"(a, c) {
          Jr();
          var A = (KE(), Ja(gy));
          if (A && A.default) {
            c.exports = A.default;
            for (let T in A)
              c.exports[T] = A[T];
          } else
            A && (c.exports = A);
        } }), vy = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/createWatchProgram.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(v, g, O, S) {
            S === void 0 && (S = O);
            var te = Object.getOwnPropertyDescriptor(g, O);
            (!te || ("get" in te ? !g.__esModule : te.writable || te.configurable)) && (te = { enumerable: true, get: function() {
              return g[O];
            } }), Object.defineProperty(v, S, te);
          } : function(v, g, O, S) {
            S === void 0 && (S = O), v[S] = g[O];
          }), A = a && a.__setModuleDefault || (Object.create ? function(v, g) {
            Object.defineProperty(v, "default", { enumerable: true, value: g });
          } : function(v, g) {
            v.default = g;
          }), T = a && a.__importStar || function(v) {
            if (v && v.__esModule)
              return v;
            var g = {};
            if (v != null)
              for (var O in v)
                O !== "default" && Object.prototype.hasOwnProperty.call(v, O) && c(g, v, O);
            return A(g, v), g;
          }, oe = a && a.__importDefault || function(v) {
            return v && v.__esModule ? v : { default: v };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.getProgramsForProjects = a.createWatchProgram = a.clearWatchCaches = void 0;
          var z = oe(Ps()), I = oe(hy()), E = oe(Zp()), N = T(xi()), e = zc(), t = (0, z.default)("typescript-eslint:typescript-estree:createWatchProgram"), x = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), q = /* @__PURE__ */ new Map(), F = /* @__PURE__ */ new Map(), fe = /* @__PURE__ */ new Map(), Te = /* @__PURE__ */ new Map();
          function Se() {
            x.clear(), s.clear(), q.clear(), Te.clear(), F.clear(), fe.clear();
          }
          __name(Se, "Se");
          a.clearWatchCaches = Se;
          function J(v) {
            return (g, O) => {
              let S = (0, e.getCanonicalFileName)(g), te = (() => {
                let Je = v.get(S);
                return Je || (Je = /* @__PURE__ */ new Set(), v.set(S, Je)), Je;
              })();
              return te.add(O), { close: () => {
                te.delete(O);
              } };
            };
          }
          __name(J, "J");
          var se = { code: "", filePath: "" };
          function Le(v) {
            throw new Error(N.flattenDiagnosticMessageText(v.messageText, N.sys.newLine));
          }
          __name(Le, "Le");
          function Q(v) {
            var g;
            return !((g = N.sys) === null || g === void 0) && g.createHash ? N.sys.createHash(v) : v;
          }
          __name(Q, "Q");
          function Be(v, g, O) {
            let S = O.EXPERIMENTAL_useSourceOfProjectReferenceRedirect ? new Set(g.getSourceFiles().map((te) => (0, e.getCanonicalFileName)(te.fileName))) : new Set(g.getRootFileNames().map((te) => (0, e.getCanonicalFileName)(te)));
            return F.set(v, S), S;
          }
          __name(Be, "Be");
          function je(v) {
            let g = (0, e.getCanonicalFileName)(v.filePath), O = [];
            se.code = v.code, se.filePath = g;
            let S = s.get(g), te = Q(v.code);
            Te.get(g) !== te && S && S.size > 0 && S.forEach((qe) => qe(g, N.FileWatcherEventKind.Changed));
            let Je = new Set(v.projects);
            for (let [qe, ge] of x.entries()) {
              if (!Je.has(qe))
                continue;
              let ie = F.get(qe), G = null;
              if (ie || (G = ge.getProgram().getProgram(), ie = Be(qe, G, v)), ie.has(g))
                return t("Found existing program for file. %s", g), G = G != null ? G : ge.getProgram().getProgram(), G.getTypeChecker(), [G];
            }
            t("File did not belong to any existing programs, moving to create/update. %s", g);
            for (let qe of v.projects) {
              let ge = x.get(qe);
              if (ge) {
                let j = m(ge, g, qe);
                if (!j)
                  continue;
                if (j.getTypeChecker(), Be(qe, j, v).has(g))
                  return t("Found updated program for file. %s", g), [j];
                O.push(j);
                continue;
              }
              let ie = B(qe, v);
              x.set(qe, ie);
              let G = ie.getProgram().getProgram();
              if (G.getTypeChecker(), Be(qe, G, v).has(g))
                return t("Found program for file. %s", g), [G];
              O.push(G);
            }
            return O;
          }
          __name(je, "je");
          a.getProgramsForProjects = je;
          var W = E.default.satisfies(N.version, ">=3.9.0-beta", { includePrerelease: true });
          function B(v, g) {
            t("Creating watch program for %s.", v);
            let O = N.createWatchCompilerHost(v, (0, e.createDefaultCompilerOptionsFromExtra)(g), N.sys, N.createAbstractBuilder, Le, () => {
            });
            g.moduleResolver && (O.resolveModuleNames = (0, e.getModuleResolver)(g.moduleResolver).resolveModuleNames);
            let S = O.readFile;
            O.readFile = (ge, ie) => {
              let G = (0, e.getCanonicalFileName)(ge), pe = G === se.filePath ? se.code : S(G, ie);
              return pe !== void 0 && Te.set(G, Q(pe)), pe;
            }, O.onUnRecoverableConfigFileDiagnostic = Le, O.afterProgramCreate = (ge) => {
              let ie = ge.getConfigFileParsingDiagnostics().filter((G) => G.category === N.DiagnosticCategory.Error && G.code !== 18003);
              ie.length > 0 && Le(ie[0]);
            }, O.watchFile = J(s), O.watchDirectory = J(q);
            let te = O.onCachedDirectoryStructureHostCreate;
            O.onCachedDirectoryStructureHostCreate = (ge) => {
              let ie = ge.readDirectory;
              ge.readDirectory = (G, pe, j, be, $e) => ie(G, pe ? pe.concat(g.extraFileExtensions) : void 0, j, be, $e), te(ge);
            }, O.extraFileExtensions = g.extraFileExtensions.map((ge) => ({ extension: ge, isMixedContent: true, scriptKind: N.ScriptKind.Deferred })), O.trace = t, O.useSourceOfProjectReferenceRedirect = () => g.EXPERIMENTAL_useSourceOfProjectReferenceRedirect;
            let Je;
            W ? (O.setTimeout = void 0, O.clearTimeout = void 0) : (t("Running without timeout fix"), O.setTimeout = function(ge, ie) {
              for (var G = arguments.length, pe = new Array(G > 2 ? G - 2 : 0), j = 2; j < G; j++)
                pe[j - 2] = arguments[j];
              return Je = ge.bind(void 0, ...pe), Je;
            }, O.clearTimeout = () => {
              Je = void 0;
            });
            let qe = N.createWatchProgram(O);
            if (!W) {
              let ge = qe.getProgram;
              qe.getProgram = () => (Je && Je(), Je = void 0, ge.call(qe));
            }
            return qe;
          }
          __name(B, "B");
          a.createWatchProgram = B;
          function U(v) {
            let O = I.default.statSync(v).mtimeMs, S = fe.get(v);
            return fe.set(v, O), S === void 0 ? false : Math.abs(S - O) > Number.EPSILON;
          }
          __name(U, "U");
          function m(v, g, O) {
            let S = v.getProgram().getProgram();
            if (Ea.env.TSESTREE_NO_INVALIDATION === "true")
              return S;
            U(O) && (t("tsconfig has changed - triggering program update. %s", O), s.get(O).forEach((be) => be(O, N.FileWatcherEventKind.Changed)), F.delete(O));
            let te = S.getSourceFile(g);
            if (te)
              return S;
            t("File was not found in program - triggering folder update. %s", g);
            let Je = (0, e.canonicalDirname)(g), qe = null, ge = Je, ie = false;
            for (; qe !== ge; ) {
              qe = ge;
              let be = q.get(qe);
              be && (be.forEach(($e) => {
                Je !== qe && $e(Je, N.FileWatcherEventKind.Changed), $e(qe, N.FileWatcherEventKind.Changed);
              }), ie = true), ge = (0, e.canonicalDirname)(qe);
            }
            if (!ie)
              return t("No callback found for file, not part of this program. %s", g), null;
            if (F.delete(O), S = v.getProgram().getProgram(), te = S.getSourceFile(g), te)
              return S;
            t("File was still not found in program after directory update - checking file deletions. %s", g);
            let pe = S.getRootFileNames().find((be) => !I.default.existsSync(be));
            if (!pe)
              return null;
            let j = s.get((0, e.getCanonicalFileName)(pe));
            return j ? (t("Marking file as deleted. %s", pe), j.forEach((be) => be(pe, N.FileWatcherEventKind.Deleted)), F.delete(O), S = v.getProgram().getProgram(), te = S.getSourceFile(g), te ? S : (t("File was still not found in program after deletion check, assuming it is not part of this program. %s", g), null)) : (t("Could not find watch callbacks for root file. %s", pe), S);
          }
          __name(m, "m");
        } }), HE = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/createProjectProgram.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(F, fe, Te, Se) {
            Se === void 0 && (Se = Te);
            var J = Object.getOwnPropertyDescriptor(fe, Te);
            (!J || ("get" in J ? !fe.__esModule : J.writable || J.configurable)) && (J = { enumerable: true, get: function() {
              return fe[Te];
            } }), Object.defineProperty(F, Se, J);
          } : function(F, fe, Te, Se) {
            Se === void 0 && (Se = Te), F[Se] = fe[Te];
          }), A = a && a.__setModuleDefault || (Object.create ? function(F, fe) {
            Object.defineProperty(F, "default", { enumerable: true, value: fe });
          } : function(F, fe) {
            F.default = fe;
          }), T = a && a.__importStar || function(F) {
            if (F && F.__esModule)
              return F;
            var fe = {};
            if (F != null)
              for (var Te in F)
                Te !== "default" && Object.prototype.hasOwnProperty.call(F, Te) && c(fe, F, Te);
            return A(fe, F), fe;
          }, oe = a && a.__importDefault || function(F) {
            return F && F.__esModule ? F : { default: F };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.createProjectProgram = void 0;
          var z = oe(Ps()), I = oe(Uc()), E = T(xi()), N = Al(), e = vy(), t = zc(), x = (0, z.default)("typescript-eslint:typescript-estree:createProjectProgram"), s = [E.Extension.Ts, E.Extension.Tsx, E.Extension.Js, E.Extension.Jsx, E.Extension.Mjs, E.Extension.Mts, E.Extension.Cjs, E.Extension.Cts];
          function q(F) {
            x("Creating project program for: %s", F.filePath);
            let fe = (0, e.getProgramsForProjects)(F), Te = (0, N.firstDefined)(fe, (B) => (0, t.getAstFromProgram)(B, F));
            if (Te || F.createDefaultProgram)
              return Te;
            let Se = /* @__PURE__ */ __name((B) => {
              let U = I.default.relative(F.tsconfigRootDir || "/prettier-security-dirname-placeholder", B);
              return F.tsconfigRootDir ? `<tsconfigRootDir>/${U}` : `<cwd>/${U}`;
            }, "Se"), J = Se(F.filePath), se = F.projects.map(Se), Le = se.length === 1 ? se[0] : `
${se.map((B) => `- ${B}`).join(`
`)}`, Q = [`ESLint was configured to run on \`${J}\` using \`parserOptions.project\`: ${Le}`], Be = false, je = F.extraFileExtensions || [];
            je.forEach((B) => {
              B.startsWith(".") || Q.push(`Found unexpected extension \`${B}\` specified with the \`parserOptions.extraFileExtensions\` option. Did you mean \`.${B}\`?`), s.includes(B) && Q.push(`You unnecessarily included the extension \`${B}\` with the \`parserOptions.extraFileExtensions\` option. This extension is already handled by the parser by default.`);
            });
            let W = I.default.extname(F.filePath);
            if (!s.includes(W)) {
              let B = `The extension for the file (\`${W}\`) is non-standard`;
              je.length > 0 ? je.includes(W) || (Q.push(`${B}. It should be added to your existing \`parserOptions.extraFileExtensions\`.`), Be = true) : (Q.push(`${B}. You should add \`parserOptions.extraFileExtensions\` to your config.`), Be = true);
            }
            if (!Be) {
              let [B, U] = F.projects.length === 1 ? ["that TSConfig does not", "that TSConfig"] : ["none of those TSConfigs", "one of those TSConfigs"];
              Q.push(`However, ${B} include this file. Either:`, "- Change ESLint's list of included files to not include this file", `- Change ${U} to include this file`, "- Create a new TSConfig that includes this file and include it in your parserOptions.project", "See the TypeScript ESLint docs for more info: https://typescript-eslint.io/docs/linting/troubleshooting##i-get-errors-telling-me-eslint-was-configured-to-run--however-that-tsconfig-does-not--none-of-those-tsconfigs-include-this-file");
            }
            throw new Error(Q.join(`
`));
          }
          __name(q, "q");
          a.createProjectProgram = q;
        } }), GE = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/createSourceFile.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(t, x, s, q) {
            q === void 0 && (q = s);
            var F = Object.getOwnPropertyDescriptor(x, s);
            (!F || ("get" in F ? !x.__esModule : F.writable || F.configurable)) && (F = { enumerable: true, get: function() {
              return x[s];
            } }), Object.defineProperty(t, q, F);
          } : function(t, x, s, q) {
            q === void 0 && (q = s), t[q] = x[s];
          }), A = a && a.__setModuleDefault || (Object.create ? function(t, x) {
            Object.defineProperty(t, "default", { enumerable: true, value: x });
          } : function(t, x) {
            t.default = x;
          }), T = a && a.__importStar || function(t) {
            if (t && t.__esModule)
              return t;
            var x = {};
            if (t != null)
              for (var s in t)
                s !== "default" && Object.prototype.hasOwnProperty.call(t, s) && c(x, t, s);
            return A(x, t), x;
          }, oe = a && a.__importDefault || function(t) {
            return t && t.__esModule ? t : { default: t };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.createSourceFile = void 0;
          var z = oe(Ps()), I = T(xi()), E = of(), N = (0, z.default)("typescript-eslint:typescript-estree:createSourceFile");
          function e(t) {
            return N("Getting AST without type information in %s mode for: %s", t.jsx ? "TSX" : "TS", t.filePath), I.createSourceFile(t.filePath, t.code, I.ScriptTarget.Latest, true, (0, E.getScriptKind)(t.filePath, t.jsx));
          }
          __name(e, "e");
          a.createSourceFile = e;
        } }), by = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/create-program/useProvidedPrograms.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(F, fe, Te, Se) {
            Se === void 0 && (Se = Te);
            var J = Object.getOwnPropertyDescriptor(fe, Te);
            (!J || ("get" in J ? !fe.__esModule : J.writable || J.configurable)) && (J = { enumerable: true, get: function() {
              return fe[Te];
            } }), Object.defineProperty(F, Se, J);
          } : function(F, fe, Te, Se) {
            Se === void 0 && (Se = Te), F[Se] = fe[Te];
          }), A = a && a.__setModuleDefault || (Object.create ? function(F, fe) {
            Object.defineProperty(F, "default", { enumerable: true, value: fe });
          } : function(F, fe) {
            F.default = fe;
          }), T = a && a.__importStar || function(F) {
            if (F && F.__esModule)
              return F;
            var fe = {};
            if (F != null)
              for (var Te in F)
                Te !== "default" && Object.prototype.hasOwnProperty.call(F, Te) && c(fe, F, Te);
            return A(fe, F), fe;
          }, oe = a && a.__importDefault || function(F) {
            return F && F.__esModule ? F : { default: F };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.createProgramFromConfigFile = a.useProvidedPrograms = void 0;
          var z = oe(Ps()), I = T(hy()), E = T(Uc()), N = T(xi()), e = zc(), t = (0, z.default)("typescript-eslint:typescript-estree:useProvidedProgram");
          function x(F, fe) {
            t("Retrieving ast for %s from provided program instance(s)", fe.filePath);
            let Te;
            for (let Se of F)
              if (Te = (0, e.getAstFromProgram)(Se, fe), Te)
                break;
            if (!Te) {
              let Se = E.relative(fe.tsconfigRootDir || "/prettier-security-dirname-placeholder", fe.filePath), J = ['"parserOptions.programs" has been provided for @typescript-eslint/parser.', `The file was not found in any of the provided program instance(s): ${Se}`];
              throw new Error(J.join(`
`));
            }
            return Te.program.getTypeChecker(), Te;
          }
          __name(x, "x");
          a.useProvidedPrograms = x;
          function s(F, fe) {
            if (N.sys === void 0)
              throw new Error("`createProgramFromConfigFile` is only supported in a Node-like environment.");
            let Se = N.getParsedCommandLineOfConfigFile(F, e.CORE_COMPILER_OPTIONS, { onUnRecoverableConfigFileDiagnostic: (se) => {
              throw new Error(q([se]));
            }, fileExists: I.existsSync, getCurrentDirectory: () => fe && E.resolve(fe) || "/prettier-security-dirname-placeholder", readDirectory: N.sys.readDirectory, readFile: (se) => I.readFileSync(se, "utf-8"), useCaseSensitiveFileNames: N.sys.useCaseSensitiveFileNames });
            if (Se.errors.length)
              throw new Error(q(Se.errors));
            let J = N.createCompilerHost(Se.options, true);
            return N.createProgram(Se.fileNames, Se.options, J);
          }
          __name(s, "s");
          a.createProgramFromConfigFile = s;
          function q(F) {
            return N.formatDiagnostics(F, { getCanonicalFileName: (fe) => fe, getCurrentDirectory: Ea.cwd, getNewLine: () => `
` });
          }
          __name(q, "q");
        } }), XE = Ur({ "node_modules/is-extglob/index.js"(a, c) {
          Jr(), c.exports = function(T) {
            if (typeof T != "string" || T === "")
              return false;
            for (var oe; oe = /(\\).|([@?!+*]\(.*\))/g.exec(T); ) {
              if (oe[2])
                return true;
              T = T.slice(oe.index + oe[0].length);
            }
            return false;
          };
        } }), $E = Ur({ "node_modules/is-glob/index.js"(a, c) {
          Jr();
          var A = XE(), T = { "{": "}", "(": ")", "[": "]" }, oe = /* @__PURE__ */ __name(function(I) {
            if (I[0] === "!")
              return true;
            for (var E = 0, N = -2, e = -2, t = -2, x = -2, s = -2; E < I.length; ) {
              if (I[E] === "*" || I[E + 1] === "?" && /[\].+)]/.test(I[E]) || e !== -1 && I[E] === "[" && I[E + 1] !== "]" && (e < E && (e = I.indexOf("]", E)), e > E && (s === -1 || s > e || (s = I.indexOf("\\", E), s === -1 || s > e))) || t !== -1 && I[E] === "{" && I[E + 1] !== "}" && (t = I.indexOf("}", E), t > E && (s = I.indexOf("\\", E), s === -1 || s > t)) || x !== -1 && I[E] === "(" && I[E + 1] === "?" && /[:!=]/.test(I[E + 2]) && I[E + 3] !== ")" && (x = I.indexOf(")", E), x > E && (s = I.indexOf("\\", E), s === -1 || s > x)) || N !== -1 && I[E] === "(" && I[E + 1] !== "|" && (N < E && (N = I.indexOf("|", E)), N !== -1 && I[N + 1] !== ")" && (x = I.indexOf(")", N), x > N && (s = I.indexOf("\\", N), s === -1 || s > x))))
                return true;
              if (I[E] === "\\") {
                var q = I[E + 1];
                E += 2;
                var F = T[q];
                if (F) {
                  var fe = I.indexOf(F, E);
                  fe !== -1 && (E = fe + 1);
                }
                if (I[E] === "!")
                  return true;
              } else
                E++;
            }
            return false;
          }, "oe"), z = /* @__PURE__ */ __name(function(I) {
            if (I[0] === "!")
              return true;
            for (var E = 0; E < I.length; ) {
              if (/[*?{}()[\]]/.test(I[E]))
                return true;
              if (I[E] === "\\") {
                var N = I[E + 1];
                E += 2;
                var e = T[N];
                if (e) {
                  var t = I.indexOf(e, E);
                  t !== -1 && (E = t + 1);
                }
                if (I[E] === "!")
                  return true;
              } else
                E++;
            }
            return false;
          }, "z");
          c.exports = function(E, N) {
            if (typeof E != "string" || E === "")
              return false;
            if (A(E))
              return true;
            var e = oe;
            return N && N.strict === false && (e = z), e(E);
          };
        } }), QE = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/inferSingleRun.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.inferSingleRun = void 0;
          var c = Uc();
          function A(T) {
            return (T == null ? void 0 : T.project) == null || (T == null ? void 0 : T.programs) != null || Ea.env.TSESTREE_SINGLE_RUN === "false" ? false : !!(Ea.env.TSESTREE_SINGLE_RUN === "true" || T != null && T.allowAutomaticSingleRunInference && (Ea.env.CI === "true" || Ea.argv[1].endsWith((0, c.normalize)("node_modules/.bin/eslint"))));
          }
          __name(A, "A");
          a.inferSingleRun = A;
        } }), YE = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/warnAboutTSVersion.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(q, F, fe, Te) {
            Te === void 0 && (Te = fe);
            var Se = Object.getOwnPropertyDescriptor(F, fe);
            (!Se || ("get" in Se ? !F.__esModule : Se.writable || Se.configurable)) && (Se = { enumerable: true, get: function() {
              return F[fe];
            } }), Object.defineProperty(q, Te, Se);
          } : function(q, F, fe, Te) {
            Te === void 0 && (Te = fe), q[Te] = F[fe];
          }), A = a && a.__setModuleDefault || (Object.create ? function(q, F) {
            Object.defineProperty(q, "default", { enumerable: true, value: F });
          } : function(q, F) {
            q.default = F;
          }), T = a && a.__importStar || function(q) {
            if (q && q.__esModule)
              return q;
            var F = {};
            if (q != null)
              for (var fe in q)
                fe !== "default" && Object.prototype.hasOwnProperty.call(q, fe) && c(F, q, fe);
            return A(F, q), F;
          }, oe = a && a.__importDefault || function(q) {
            return q && q.__esModule ? q : { default: q };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.warnAboutTSVersion = void 0;
          var z = oe(Zp()), I = T(xi()), E = ">=3.3.1 <5.0.0", N = [], e = I.version, t = z.default.satisfies(e, [E].concat(N).join(" || ")), x = false;
          function s(q) {
            var F;
            if (!t && !x) {
              if (typeof Ea > "u" ? false : (F = Ea.stdout) === null || F === void 0 ? void 0 : F.isTTY) {
                let Te = "=============", Se = [Te, "WARNING: You are currently running a version of TypeScript which is not officially supported by @typescript-eslint/typescript-estree.", "You may find that it works just fine, or you may not.", `SUPPORTED TYPESCRIPT VERSIONS: ${E}`, `YOUR TYPESCRIPT VERSION: ${e}`, "Please only submit bug reports when using the officially supported version.", Te];
                q.log(Se.join(`

`));
              }
              x = true;
            }
          }
          __name(s, "s");
          a.warnAboutTSVersion = s;
        } }), ZE = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/parseSettings/createParseSettings.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__importDefault || function(F) {
            return F && F.__esModule ? F : { default: F };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.createParseSettings = void 0;
          var A = c(Ps()), T = {}, oe = c($E()), z = zc(), I = QE(), E = YE(), N = (0, A.default)("typescript-eslint:typescript-estree:parser:parseSettings:createParseSettings");
          function e(F) {
            let fe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var Te, Se;
            let J = typeof fe.tsconfigRootDir == "string" ? fe.tsconfigRootDir : "/prettier-security-dirname-placeholder", se = { code: t(F), comment: fe.comment === true, comments: [], createDefaultProgram: fe.createDefaultProgram === true, debugLevel: fe.debugLevel === true ? /* @__PURE__ */ new Set(["typescript-eslint"]) : Array.isArray(fe.debugLevel) ? new Set(fe.debugLevel) : /* @__PURE__ */ new Set(), errorOnTypeScriptSyntacticAndSemanticIssues: false, errorOnUnknownASTType: fe.errorOnUnknownASTType === true, EXPERIMENTAL_useSourceOfProjectReferenceRedirect: fe.EXPERIMENTAL_useSourceOfProjectReferenceRedirect === true, extraFileExtensions: Array.isArray(fe.extraFileExtensions) && fe.extraFileExtensions.every((Le) => typeof Le == "string") ? fe.extraFileExtensions : [], filePath: (0, z.ensureAbsolutePath)(typeof fe.filePath == "string" && fe.filePath !== "<input>" ? fe.filePath : x(fe.jsx), J), jsx: fe.jsx === true, loc: fe.loc === true, log: typeof fe.loggerFn == "function" ? fe.loggerFn : fe.loggerFn === false ? () => {
            } : console.log, moduleResolver: (Te = fe.moduleResolver) !== null && Te !== void 0 ? Te : "", preserveNodeMaps: fe.preserveNodeMaps !== false, programs: Array.isArray(fe.programs) ? fe.programs : null, projects: [], range: fe.range === true, singleRun: (0, I.inferSingleRun)(fe), tokens: fe.tokens === true ? [] : null, tsconfigRootDir: J };
            if (se.debugLevel.size > 0) {
              let Le = [];
              se.debugLevel.has("typescript-eslint") && Le.push("typescript-eslint:*"), (se.debugLevel.has("eslint") || A.default.enabled("eslint:*,-eslint:code-path")) && Le.push("eslint:*,-eslint:code-path"), A.default.enable(Le.join(","));
            }
            if (Array.isArray(fe.programs)) {
              if (!fe.programs.length)
                throw new Error("You have set parserOptions.programs to an empty array. This will cause all files to not be found in existing programs. Either provide one or more existing TypeScript Program instances in the array, or remove the parserOptions.programs setting.");
              N("parserOptions.programs was provided, so parserOptions.project will be ignored.");
            }
            if (!se.programs) {
              let Le = ((Se = fe.projectFolderIgnoreList) !== null && Se !== void 0 ? Se : ["**/node_modules/**"]).reduce((Q, Be) => (typeof Be == "string" && Q.push(Be), Q), []).map((Q) => Q.startsWith("!") ? Q : `!${Q}`);
              se.projects = q(J, fe.project, Le);
            }
            return (0, E.warnAboutTSVersion)(se), se;
          }
          __name(e, "e");
          a.createParseSettings = e;
          function t(F) {
            return typeof F != "string" ? String(F) : F;
          }
          __name(t, "t");
          function x(F) {
            return F ? "estree.tsx" : "estree.ts";
          }
          __name(x, "x");
          function s(F, fe) {
            return (0, z.getCanonicalFileName)((0, z.ensureAbsolutePath)(F, fe));
          }
          __name(s, "s");
          function q(F, fe, Te) {
            let Se = [];
            if (typeof fe == "string")
              Se.push(fe);
            else if (Array.isArray(fe))
              for (let Q of fe)
                typeof Q == "string" && Se.push(Q);
            if (Se.length === 0)
              return [];
            let J = Se.filter((Q) => !(0, oe.default)(Q)), se = Se.filter((Q) => (0, oe.default)(Q)), Le = new Set(J.concat((0, T.sync)([...se, ...Te], { cwd: F })).map((Q) => s(Q, F)));
            return N("parserOptions.project (excluding ignored) matched projects: %s", Le), Array.from(Le);
          }
          __name(q, "q");
        } }), eT = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/semantic-or-syntactic-errors.js"(a) {
          "use strict";
          Jr(), Object.defineProperty(a, "__esModule", { value: true }), a.getFirstSemanticOrSyntacticError = void 0;
          var c = xi();
          function A(z, I) {
            try {
              let E = T(z.getSyntacticDiagnostics(I));
              if (E.length)
                return oe(E[0]);
              let N = T(z.getSemanticDiagnostics(I));
              return N.length ? oe(N[0]) : void 0;
            } catch (E) {
              console.warn(`Warning From TSC: "${E.message}`);
              return;
            }
          }
          __name(A, "A");
          a.getFirstSemanticOrSyntacticError = A;
          function T(z) {
            return z.filter((I) => {
              switch (I.code) {
                case 1013:
                case 1014:
                case 1044:
                case 1045:
                case 1048:
                case 1049:
                case 1070:
                case 1071:
                case 1085:
                case 1090:
                case 1096:
                case 1097:
                case 1098:
                case 1099:
                case 1117:
                case 1121:
                case 1123:
                case 1141:
                case 1162:
                case 1164:
                case 1172:
                case 1173:
                case 1175:
                case 1176:
                case 1190:
                case 1196:
                case 1200:
                case 1206:
                case 1211:
                case 1242:
                case 1246:
                case 1255:
                case 1308:
                case 2364:
                case 2369:
                case 2452:
                case 2462:
                case 8017:
                case 17012:
                case 17013:
                  return true;
              }
              return false;
            });
          }
          __name(T, "T");
          function oe(z) {
            return Object.assign(Object.assign({}, z), { message: (0, c.flattenDiagnosticMessageText)(z.messageText, c.sys.newLine) });
          }
          __name(oe, "oe");
        } }), rT = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/parser.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__importDefault || function(Be) {
            return Be && Be.__esModule ? Be : { default: Be };
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.clearParseAndGenerateServicesCalls = a.clearProgramCache = a.parseWithNodeMaps = a.parseAndGenerateServices = a.parse = void 0;
          var A = c(Ps()), T = UE(), oe = Yg(), z = VE(), I = WE(), E = HE(), N = GE(), e = by(), t = ZE(), x = eT(), s = (0, A.default)("typescript-eslint:typescript-estree:parser"), q = /* @__PURE__ */ new Map();
          function F() {
            q.clear();
          }
          __name(F, "F");
          a.clearProgramCache = F;
          function fe(Be, je) {
            return Be.programs && (0, e.useProvidedPrograms)(Be.programs, Be) || je && (0, E.createProjectProgram)(Be) || je && Be.createDefaultProgram && (0, z.createDefaultProgram)(Be) || (0, I.createIsolatedProgram)(Be);
          }
          __name(fe, "fe");
          function Te(Be, je) {
            let { ast: W } = Se(Be, je, false);
            return W;
          }
          __name(Te, "Te");
          a.parse = Te;
          function Se(Be, je, W) {
            let B = (0, t.createParseSettings)(Be, je);
            if (je != null && je.errorOnTypeScriptSyntacticAndSemanticIssues)
              throw new Error('"errorOnTypeScriptSyntacticAndSemanticIssues" is only supported for parseAndGenerateServices()');
            let U = (0, N.createSourceFile)(B), { estree: m, astMaps: v } = (0, T.astConverter)(U, B, W);
            return { ast: m, esTreeNodeToTSNodeMap: v.esTreeNodeToTSNodeMap, tsNodeToESTreeNodeMap: v.tsNodeToESTreeNodeMap };
          }
          __name(Se, "Se");
          function J(Be, je) {
            return Se(Be, je, true);
          }
          __name(J, "J");
          a.parseWithNodeMaps = J;
          var se = {};
          function Le() {
            se = {};
          }
          __name(Le, "Le");
          a.clearParseAndGenerateServicesCalls = Le;
          function Q(Be, je) {
            var W, B;
            let U = (0, t.createParseSettings)(Be, je);
            typeof je < "u" && typeof je.errorOnTypeScriptSyntacticAndSemanticIssues == "boolean" && je.errorOnTypeScriptSyntacticAndSemanticIssues && (U.errorOnTypeScriptSyntacticAndSemanticIssues = true), U.singleRun && !U.programs && ((W = U.projects) === null || W === void 0 ? void 0 : W.length) > 0 && (U.programs = { *[Symbol.iterator]() {
              for (let Je of U.projects) {
                let qe = q.get(Je);
                if (qe)
                  yield qe;
                else {
                  s("Detected single-run/CLI usage, creating Program once ahead of time for project: %s", Je);
                  let ge = (0, e.createProgramFromConfigFile)(Je);
                  q.set(Je, ge), yield ge;
                }
              }
            } });
            let m = U.programs != null || ((B = U.projects) === null || B === void 0 ? void 0 : B.length) > 0;
            U.singleRun && je.filePath && (se[je.filePath] = (se[je.filePath] || 0) + 1);
            let { ast: v, program: g } = U.singleRun && je.filePath && se[je.filePath] > 1 ? (0, I.createIsolatedProgram)(U) : fe(U, m), O = typeof U.preserveNodeMaps == "boolean" ? U.preserveNodeMaps : true, { estree: S, astMaps: te } = (0, T.astConverter)(v, U, O);
            if (g && U.errorOnTypeScriptSyntacticAndSemanticIssues) {
              let Je = (0, x.getFirstSemanticOrSyntacticError)(g, v);
              if (Je)
                throw (0, oe.convertError)(Je);
            }
            return { ast: S, services: { hasFullTypeInformation: m, program: g, esTreeNodeToTSNodeMap: te.esTreeNodeToTSNodeMap, tsNodeToESTreeNodeMap: te.tsNodeToESTreeNodeMap } };
          }
          __name(Q, "Q");
          a.parseAndGenerateServices = Q;
        } }), tT = Ur({ "node_modules/@typescript-eslint/typescript-estree/package.json"(a, c) {
          c.exports = { name: "@typescript-eslint/typescript-estree", version: "5.45.0", description: "A parser that converts TypeScript source code into an ESTree compatible form", main: "dist/index.js", types: "dist/index.d.ts", files: ["dist", "_ts3.4", "README.md", "LICENSE"], engines: { node: "^12.22.0 || ^14.17.0 || >=16.0.0" }, repository: { type: "git", url: "https://github.com/typescript-eslint/typescript-eslint.git", directory: "packages/typescript-estree" }, bugs: { url: "https://github.com/typescript-eslint/typescript-eslint/issues" }, license: "BSD-2-Clause", keywords: ["ast", "estree", "ecmascript", "javascript", "typescript", "parser", "syntax"], scripts: { build: "tsc -b tsconfig.build.json", postbuild: "downlevel-dts dist _ts3.4/dist", clean: "tsc -b tsconfig.build.json --clean", postclean: "rimraf dist && rimraf _ts3.4 && rimraf coverage", format: 'prettier --write "./**/*.{ts,mts,cts,tsx,js,mjs,cjs,jsx,json,md,css}" --ignore-path ../../.prettierignore', lint: "nx lint", test: "jest --coverage", typecheck: "tsc -p tsconfig.json --noEmit" }, dependencies: { "@typescript-eslint/types": "5.45.0", "@typescript-eslint/visitor-keys": "5.45.0", debug: "^4.3.4", globby: "^11.1.0", "is-glob": "^4.0.3", semver: "^7.3.7", tsutils: "^3.21.0" }, devDependencies: { "@babel/code-frame": "*", "@babel/parser": "*", "@types/babel__code-frame": "*", "@types/debug": "*", "@types/glob": "*", "@types/is-glob": "*", "@types/semver": "*", "@types/tmp": "*", "@typescript-eslint/shared-fixtures": "5.45.0", glob: "*", "jest-specific-snapshot": "*", "make-dir": "*", tmp: "*", typescript: "*" }, peerDependenciesMeta: { typescript: { optional: true } }, funding: { type: "opencollective", url: "https://opencollective.com/typescript-eslint" }, typesVersions: { "<3.8": { "*": ["_ts3.4/*"] } }, gitHead: "267da4e416f7de6892336db8a2360d7af702b73c" };
        } }), nT = Ur({ "node_modules/@typescript-eslint/typescript-estree/dist/index.js"(a) {
          "use strict";
          Jr();
          var c = a && a.__createBinding || (Object.create ? function(e, t, x, s) {
            s === void 0 && (s = x);
            var q = Object.getOwnPropertyDescriptor(t, x);
            (!q || ("get" in q ? !t.__esModule : q.writable || q.configurable)) && (q = { enumerable: true, get: function() {
              return t[x];
            } }), Object.defineProperty(e, s, q);
          } : function(e, t, x, s) {
            s === void 0 && (s = x), e[s] = t[x];
          }), A = a && a.__exportStar || function(e, t) {
            for (var x in e)
              x !== "default" && !Object.prototype.hasOwnProperty.call(t, x) && c(t, e, x);
          };
          Object.defineProperty(a, "__esModule", { value: true }), a.version = a.visitorKeys = a.typescriptVersionIsAtLeast = a.createProgram = a.clearCaches = a.simpleTraverse = a.clearProgramCache = a.parseWithNodeMaps = a.parseAndGenerateServices = a.parse = void 0;
          var T = rT();
          Object.defineProperty(a, "parse", { enumerable: true, get: function() {
            return T.parse;
          } }), Object.defineProperty(a, "parseAndGenerateServices", { enumerable: true, get: function() {
            return T.parseAndGenerateServices;
          } }), Object.defineProperty(a, "parseWithNodeMaps", { enumerable: true, get: function() {
            return T.parseWithNodeMaps;
          } }), Object.defineProperty(a, "clearProgramCache", { enumerable: true, get: function() {
            return T.clearProgramCache;
          } });
          var oe = oy();
          Object.defineProperty(a, "simpleTraverse", { enumerable: true, get: function() {
            return oe.simpleTraverse;
          } }), A(wl(), a);
          var z = vy();
          Object.defineProperty(a, "clearCaches", { enumerable: true, get: function() {
            return z.clearWatchCaches;
          } });
          var I = by();
          Object.defineProperty(a, "createProgram", { enumerable: true, get: function() {
            return I.createProgramFromConfigFile;
          } }), A(of(), a);
          var E = ef();
          Object.defineProperty(a, "typescriptVersionIsAtLeast", { enumerable: true, get: function() {
            return E.typescriptVersionIsAtLeast;
          } }), A(rf(), a);
          var N = ay();
          Object.defineProperty(a, "visitorKeys", { enumerable: true, get: function() {
            return N.visitorKeys;
          } }), a.version = tT().version;
        } });
        Jr();
        var iT = Ng(), aT = mb(), oT = Db(), sT = xb(), _T = Ib(), Pg = { loc: true, range: true, comment: true, jsx: true, tokens: true, loggerFn: false, project: [] };
        function cT(a) {
          let { message: c, lineNumber: A, column: T } = a;
          return typeof A != "number" ? a : iT(c, { start: { line: A, column: T + 1 } });
        }
        __name(cT, "cT");
        function uT(a, c) {
          let A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, T = sT(a), oe = lT(a), { parseWithNodeMaps: z } = nT(), { result: I, error: E } = aT(() => z(T, Object.assign(Object.assign({}, Pg), {}, { jsx: oe })), () => z(T, Object.assign(Object.assign({}, Pg), {}, { jsx: !oe })));
          if (!I)
            throw cT(E);
          return A.originalText = a, A.tsParseResult = I, _T(I.ast, A);
        }
        __name(uT, "uT");
        function lT(a) {
          return new RegExp(["(?:^[^\"'`]*</)", "|", "(?:^[^/]{2}.*/>)"].join(""), "m").test(a);
        }
        __name(lT, "lT");
        Ey.exports = { parsers: { typescript: oT(uT) } };
      });
      return pT();
    });
  }
});

// node_modules/prettier/standalone.js
var require_standalone = __commonJS({
  "node_modules/prettier/standalone.js"(exports, module) {
    init_define_process();
    (function(e) {
      if (typeof exports == "object" && typeof module == "object")
        module.exports = e();
      else if (typeof define == "function" && define.amd)
        define(e);
      else {
        var f = typeof globalThis < "u" ? globalThis : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : this || {};
        f.prettier = e();
      }
    })(function() {
      "use strict";
      var Ne = /* @__PURE__ */ __name((e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports), "Ne");
      var Qe = Ne((Ng, nu) => {
        var ur = /* @__PURE__ */ __name(function(e) {
          return e && e.Math == Math && e;
        }, "ur");
        nu.exports = ur(typeof globalThis == "object" && globalThis) || ur(typeof window == "object" && window) || ur(typeof self == "object" && self) || ur(typeof globalThis == "object" && globalThis) || function() {
          return this;
        }() || Function("return this")();
      });
      var dt = Ne((wg, uu) => {
        uu.exports = function(e) {
          try {
            return !!e();
          } catch {
            return true;
          }
        };
      });
      var Ft = Ne((_g, su) => {
        var vo = dt();
        su.exports = !vo(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var sr = Ne((Pg, iu) => {
        var Co = dt();
        iu.exports = !Co(function() {
          var e = function() {
          }.bind();
          return typeof e != "function" || e.hasOwnProperty("prototype");
        });
      });
      var At = Ne((Ig, au) => {
        var Eo = sr(), ir = Function.prototype.call;
        au.exports = Eo ? ir.bind(ir) : function() {
          return ir.apply(ir, arguments);
        };
      });
      var pu = Ne((cu) => {
        "use strict";
        var ou = {}.propertyIsEnumerable, lu = Object.getOwnPropertyDescriptor, Fo = lu && !ou.call({ 1: 2 }, 1);
        cu.f = Fo ? function(n) {
          var t = lu(this, n);
          return !!t && t.enumerable;
        } : ou;
      });
      var ar = Ne((Lg, fu) => {
        fu.exports = function(e, n) {
          return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: n };
        };
      });
      var ct = Ne((jg, du) => {
        var Du = sr(), mu = Function.prototype, Ao = mu.bind, Mr = mu.call, So = Du && Ao.bind(Mr, Mr);
        du.exports = Du ? function(e) {
          return e && So(e);
        } : function(e) {
          return e && function() {
            return Mr.apply(e, arguments);
          };
        };
      });
      var or = Ne((Og, yu) => {
        var gu = ct(), xo = gu({}.toString), bo = gu("".slice);
        yu.exports = function(e) {
          return bo(xo(e), 8, -1);
        };
      });
      var vu = Ne((qg, hu) => {
        var To = Qe(), Bo = ct(), No = dt(), wo = or(), Rr = To.Object, _o = Bo("".split);
        hu.exports = No(function() {
          return !Rr("z").propertyIsEnumerable(0);
        }) ? function(e) {
          return wo(e) == "String" ? _o(e, "") : Rr(e);
        } : Rr;
      });
      var $r = Ne((Mg, Cu) => {
        var Po = Qe(), Io = Po.TypeError;
        Cu.exports = function(e) {
          if (e == null)
            throw Io("Can't call method on " + e);
          return e;
        };
      });
      var lr = Ne((Rg, Eu) => {
        var ko = vu(), Lo = $r();
        Eu.exports = function(e) {
          return ko(Lo(e));
        };
      });
      var pt = Ne(($g, Fu) => {
        Fu.exports = function(e) {
          return typeof e == "function";
        };
      });
      var St = Ne((Vg, Au) => {
        var jo = pt();
        Au.exports = function(e) {
          return typeof e == "object" ? e !== null : jo(e);
        };
      });
      var $t = Ne((Wg, Su) => {
        var Vr = Qe(), Oo = pt(), qo = /* @__PURE__ */ __name(function(e) {
          return Oo(e) ? e : void 0;
        }, "qo");
        Su.exports = function(e, n) {
          return arguments.length < 2 ? qo(Vr[e]) : Vr[e] && Vr[e][n];
        };
      });
      var Wr = Ne((Hg, xu) => {
        var Mo = ct();
        xu.exports = Mo({}.isPrototypeOf);
      });
      var Tu = Ne((Gg, bu) => {
        var Ro = $t();
        bu.exports = Ro("navigator", "userAgent") || "";
      });
      var ku = Ne((Ug, Iu) => {
        var Pu = Qe(), Hr = Tu(), Bu = Pu.process, Nu = Pu.Deno, wu = Bu && Bu.versions || Nu && Nu.version, _u = wu && wu.v8, mt, cr;
        _u && (mt = _u.split("."), cr = mt[0] > 0 && mt[0] < 4 ? 1 : +(mt[0] + mt[1]));
        !cr && Hr && (mt = Hr.match(/Edge\/(\d+)/), (!mt || mt[1] >= 74) && (mt = Hr.match(/Chrome\/(\d+)/), mt && (cr = +mt[1])));
        Iu.exports = cr;
      });
      var Gr = Ne((Jg, ju) => {
        var Lu = ku(), $o = dt();
        ju.exports = !!Object.getOwnPropertySymbols && !$o(function() {
          var e = Symbol();
          return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Lu && Lu < 41;
        });
      });
      var Ur = Ne((zg, Ou) => {
        var Vo = Gr();
        Ou.exports = Vo && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Jr = Ne((Xg, qu) => {
        var Wo = Qe(), Ho = $t(), Go = pt(), Uo = Wr(), Jo = Ur(), zo = Wo.Object;
        qu.exports = Jo ? function(e) {
          return typeof e == "symbol";
        } : function(e) {
          var n = Ho("Symbol");
          return Go(n) && Uo(n.prototype, zo(e));
        };
      });
      var pr = Ne((Kg, Mu) => {
        var Xo = Qe(), Ko = Xo.String;
        Mu.exports = function(e) {
          try {
            return Ko(e);
          } catch {
            return "Object";
          }
        };
      });
      var Vt = Ne((Yg, Ru) => {
        var Yo = Qe(), Qo = pt(), Zo = pr(), el = Yo.TypeError;
        Ru.exports = function(e) {
          if (Qo(e))
            return e;
          throw el(Zo(e) + " is not a function");
        };
      });
      var fr = Ne((Qg, $u) => {
        var tl = Vt();
        $u.exports = function(e, n) {
          var t = e[n];
          return t == null ? void 0 : tl(t);
        };
      });
      var Wu = Ne((Zg, Vu) => {
        var rl = Qe(), zr = At(), Xr = pt(), Kr = St(), nl = rl.TypeError;
        Vu.exports = function(e, n) {
          var t, s;
          if (n === "string" && Xr(t = e.toString) && !Kr(s = zr(t, e)) || Xr(t = e.valueOf) && !Kr(s = zr(t, e)) || n !== "string" && Xr(t = e.toString) && !Kr(s = zr(t, e)))
            return s;
          throw nl("Can't convert object to primitive value");
        };
      });
      var Gu = Ne((e0, Hu) => {
        Hu.exports = false;
      });
      var Dr = Ne((t0, Ju) => {
        var Uu = Qe(), ul = Object.defineProperty;
        Ju.exports = function(e, n) {
          try {
            ul(Uu, e, { value: n, configurable: true, writable: true });
          } catch {
            Uu[e] = n;
          }
          return n;
        };
      });
      var mr = Ne((r0, Xu) => {
        var sl = Qe(), il = Dr(), zu = "__core-js_shared__", al = sl[zu] || il(zu, {});
        Xu.exports = al;
      });
      var Yr = Ne((n0, Yu) => {
        var ol = Gu(), Ku = mr();
        (Yu.exports = function(e, n) {
          return Ku[e] || (Ku[e] = n !== void 0 ? n : {});
        })("versions", []).push({ version: "3.22.2", mode: ol ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var dr = Ne((u0, Qu) => {
        var ll = Qe(), cl = $r(), pl = ll.Object;
        Qu.exports = function(e) {
          return pl(cl(e));
        };
      });
      var ht = Ne((s0, Zu) => {
        var fl = ct(), Dl = dr(), ml = fl({}.hasOwnProperty);
        Zu.exports = Object.hasOwn || function(n, t) {
          return ml(Dl(n), t);
        };
      });
      var Qr = Ne((i0, es) => {
        var dl = ct(), gl = 0, yl = Math.random(), hl = dl(1 .toString);
        es.exports = function(e) {
          return "Symbol(" + (e === void 0 ? "" : e) + ")_" + hl(++gl + yl, 36);
        };
      });
      var bt = Ne((a0, ss) => {
        var vl = Qe(), Cl = Yr(), ts = ht(), El = Qr(), rs = Gr(), us = Ur(), _t = Cl("wks"), xt = vl.Symbol, ns = xt && xt.for, Fl = us ? xt : xt && xt.withoutSetter || El;
        ss.exports = function(e) {
          if (!ts(_t, e) || !(rs || typeof _t[e] == "string")) {
            var n = "Symbol." + e;
            rs && ts(xt, e) ? _t[e] = xt[e] : us && ns ? _t[e] = ns(n) : _t[e] = Fl(n);
          }
          return _t[e];
        };
      });
      var ls = Ne((o0, os) => {
        var Al = Qe(), Sl = At(), is = St(), as = Jr(), xl = fr(), bl = Wu(), Tl = bt(), Bl = Al.TypeError, Nl = Tl("toPrimitive");
        os.exports = function(e, n) {
          if (!is(e) || as(e))
            return e;
          var t = xl(e, Nl), s;
          if (t) {
            if (n === void 0 && (n = "default"), s = Sl(t, e, n), !is(s) || as(s))
              return s;
            throw Bl("Can't convert object to primitive value");
          }
          return n === void 0 && (n = "number"), bl(e, n);
        };
      });
      var gr = Ne((l0, cs) => {
        var wl = ls(), _l = Jr();
        cs.exports = function(e) {
          var n = wl(e, "string");
          return _l(n) ? n : n + "";
        };
      });
      var Ds = Ne((c0, fs) => {
        var Pl = Qe(), ps = St(), Zr = Pl.document, Il = ps(Zr) && ps(Zr.createElement);
        fs.exports = function(e) {
          return Il ? Zr.createElement(e) : {};
        };
      });
      var en = Ne((p0, ms) => {
        var kl = Ft(), Ll = dt(), jl = Ds();
        ms.exports = !kl && !Ll(function() {
          return Object.defineProperty(jl("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var tn = Ne((gs) => {
        var Ol = Ft(), ql = At(), Ml = pu(), Rl = ar(), $l = lr(), Vl = gr(), Wl = ht(), Hl = en(), ds = Object.getOwnPropertyDescriptor;
        gs.f = Ol ? ds : function(n, t) {
          if (n = $l(n), t = Vl(t), Hl)
            try {
              return ds(n, t);
            } catch {
            }
          if (Wl(n, t))
            return Rl(!ql(Ml.f, n, t), n[t]);
        };
      });
      var hs = Ne((D0, ys) => {
        var Gl = Ft(), Ul = dt();
        ys.exports = Gl && Ul(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Pt = Ne((m0, Cs) => {
        var vs = Qe(), Jl = St(), zl = vs.String, Xl = vs.TypeError;
        Cs.exports = function(e) {
          if (Jl(e))
            return e;
          throw Xl(zl(e) + " is not an object");
        };
      });
      var hr = Ne((Fs) => {
        var Kl = Qe(), Yl = Ft(), Ql = en(), Zl = hs(), yr = Pt(), Es = gr(), ec = Kl.TypeError, rn = Object.defineProperty, tc = Object.getOwnPropertyDescriptor, nn = "enumerable", un = "configurable", sn = "writable";
        Fs.f = Yl ? Zl ? function(n, t, s) {
          if (yr(n), t = Es(t), yr(s), typeof n == "function" && t === "prototype" && "value" in s && sn in s && !s[sn]) {
            var a = tc(n, t);
            a && a[sn] && (n[t] = s.value, s = { configurable: un in s ? s[un] : a[un], enumerable: nn in s ? s[nn] : a[nn], writable: false });
          }
          return rn(n, t, s);
        } : rn : function(n, t, s) {
          if (yr(n), t = Es(t), yr(s), Ql)
            try {
              return rn(n, t, s);
            } catch {
            }
          if ("get" in s || "set" in s)
            throw ec("Accessors not supported");
          return "value" in s && (n[t] = s.value), n;
        };
      });
      var vr = Ne((g0, As) => {
        var rc = Ft(), nc = hr(), uc = ar();
        As.exports = rc ? function(e, n, t) {
          return nc.f(e, n, uc(1, t));
        } : function(e, n, t) {
          return e[n] = t, e;
        };
      });
      var Cr = Ne((y0, Ss) => {
        var sc = ct(), ic = pt(), an = mr(), ac = sc(Function.toString);
        ic(an.inspectSource) || (an.inspectSource = function(e) {
          return ac(e);
        });
        Ss.exports = an.inspectSource;
      });
      var Ts = Ne((h0, bs) => {
        var oc = Qe(), lc = pt(), cc = Cr(), xs = oc.WeakMap;
        bs.exports = lc(xs) && /native code/.test(cc(xs));
      });
      var ws = Ne((v0, Ns) => {
        var pc = Yr(), fc = Qr(), Bs = pc("keys");
        Ns.exports = function(e) {
          return Bs[e] || (Bs[e] = fc(e));
        };
      });
      var on = Ne((C0, _s) => {
        _s.exports = {};
      });
      var Os = Ne((E0, js) => {
        var Dc = Ts(), Ls = Qe(), ln = ct(), mc = St(), dc = vr(), cn = ht(), pn = mr(), gc = ws(), yc = on(), Ps = "Object already initialized", Dn = Ls.TypeError, hc = Ls.WeakMap, Er, Wt, Fr, vc = /* @__PURE__ */ __name(function(e) {
          return Fr(e) ? Wt(e) : Er(e, {});
        }, "vc"), Cc = /* @__PURE__ */ __name(function(e) {
          return function(n) {
            var t;
            if (!mc(n) || (t = Wt(n)).type !== e)
              throw Dn("Incompatible receiver, " + e + " required");
            return t;
          };
        }, "Cc");
        Dc || pn.state ? (vt = pn.state || (pn.state = new hc()), Is = ln(vt.get), fn = ln(vt.has), ks = ln(vt.set), Er = /* @__PURE__ */ __name(function(e, n) {
          if (fn(vt, e))
            throw new Dn(Ps);
          return n.facade = e, ks(vt, e, n), n;
        }, "Er"), Wt = /* @__PURE__ */ __name(function(e) {
          return Is(vt, e) || {};
        }, "Wt"), Fr = /* @__PURE__ */ __name(function(e) {
          return fn(vt, e);
        }, "Fr")) : (Tt = gc("state"), yc[Tt] = true, Er = /* @__PURE__ */ __name(function(e, n) {
          if (cn(e, Tt))
            throw new Dn(Ps);
          return n.facade = e, dc(e, Tt, n), n;
        }, "Er"), Wt = /* @__PURE__ */ __name(function(e) {
          return cn(e, Tt) ? e[Tt] : {};
        }, "Wt"), Fr = /* @__PURE__ */ __name(function(e) {
          return cn(e, Tt);
        }, "Fr"));
        var vt, Is, fn, ks, Tt;
        js.exports = { set: Er, get: Wt, has: Fr, enforce: vc, getterFor: Cc };
      });
      var Rs = Ne((F0, Ms) => {
        var mn = Ft(), Ec = ht(), qs = Function.prototype, Fc = mn && Object.getOwnPropertyDescriptor, dn = Ec(qs, "name"), Ac = dn && function() {
        }.name === "something", Sc = dn && (!mn || mn && Fc(qs, "name").configurable);
        Ms.exports = { EXISTS: dn, PROPER: Ac, CONFIGURABLE: Sc };
      });
      var Gs = Ne((A0, Hs) => {
        var xc = Qe(), $s = pt(), bc = ht(), Vs = vr(), Tc = Dr(), Bc = Cr(), Ws = Os(), Nc = Rs().CONFIGURABLE, wc = Ws.get, _c = Ws.enforce, Pc = String(String).split("String");
        (Hs.exports = function(e, n, t, s) {
          var a = s ? !!s.unsafe : false, r = s ? !!s.enumerable : false, u = s ? !!s.noTargetGet : false, i = s && s.name !== void 0 ? s.name : n, l;
          if ($s(t) && (String(i).slice(0, 7) === "Symbol(" && (i = "[" + String(i).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!bc(t, "name") || Nc && t.name !== i) && Vs(t, "name", i), l = _c(t), l.source || (l.source = Pc.join(typeof i == "string" ? i : ""))), e === xc) {
            r ? e[n] = t : Tc(n, t);
            return;
          } else
            a ? !u && e[n] && (r = true) : delete e[n];
          r ? e[n] = t : Vs(e, n, t);
        })(Function.prototype, "toString", function() {
          return $s(this) && wc(this).source || Bc(this);
        });
      });
      var Ar = Ne((S0, Us) => {
        var Ic = Math.ceil, kc = Math.floor;
        Us.exports = function(e) {
          var n = +e;
          return n !== n || n === 0 ? 0 : (n > 0 ? kc : Ic)(n);
        };
      });
      var zs = Ne((x0, Js) => {
        var Lc = Ar(), jc = Math.max, Oc = Math.min;
        Js.exports = function(e, n) {
          var t = Lc(e);
          return t < 0 ? jc(t + n, 0) : Oc(t, n);
        };
      });
      var Ks = Ne((b0, Xs) => {
        var qc = Ar(), Mc = Math.min;
        Xs.exports = function(e) {
          return e > 0 ? Mc(qc(e), 9007199254740991) : 0;
        };
      });
      var It = Ne((T0, Ys) => {
        var Rc = Ks();
        Ys.exports = function(e) {
          return Rc(e.length);
        };
      });
      var ei = Ne((B0, Zs) => {
        var $c = lr(), Vc = zs(), Wc = It(), Qs = /* @__PURE__ */ __name(function(e) {
          return function(n, t, s) {
            var a = $c(n), r = Wc(a), u = Vc(s, r), i;
            if (e && t != t) {
              for (; r > u; )
                if (i = a[u++], i != i)
                  return true;
            } else
              for (; r > u; u++)
                if ((e || u in a) && a[u] === t)
                  return e || u || 0;
            return !e && -1;
          };
        }, "Qs");
        Zs.exports = { includes: Qs(true), indexOf: Qs(false) };
      });
      var ni = Ne((N0, ri) => {
        var Hc = ct(), gn = ht(), Gc = lr(), Uc = ei().indexOf, Jc = on(), ti = Hc([].push);
        ri.exports = function(e, n) {
          var t = Gc(e), s = 0, a = [], r;
          for (r in t)
            !gn(Jc, r) && gn(t, r) && ti(a, r);
          for (; n.length > s; )
            gn(t, r = n[s++]) && (~Uc(a, r) || ti(a, r));
          return a;
        };
      });
      var si = Ne((w0, ui) => {
        ui.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var ai = Ne((ii) => {
        var zc = ni(), Xc = si(), Kc = Xc.concat("length", "prototype");
        ii.f = Object.getOwnPropertyNames || function(n) {
          return zc(n, Kc);
        };
      });
      var li = Ne((oi) => {
        oi.f = Object.getOwnPropertySymbols;
      });
      var pi = Ne((I0, ci) => {
        var Yc = $t(), Qc = ct(), Zc = ai(), ep = li(), tp = Pt(), rp = Qc([].concat);
        ci.exports = Yc("Reflect", "ownKeys") || function(n) {
          var t = Zc.f(tp(n)), s = ep.f;
          return s ? rp(t, s(n)) : t;
        };
      });
      var mi = Ne((k0, Di) => {
        var fi = ht(), np = pi(), up = tn(), sp = hr();
        Di.exports = function(e, n, t) {
          for (var s = np(n), a = sp.f, r = up.f, u = 0; u < s.length; u++) {
            var i = s[u];
            !fi(e, i) && !(t && fi(t, i)) && a(e, i, r(n, i));
          }
        };
      });
      var gi = Ne((L0, di) => {
        var ip = dt(), ap = pt(), op = /#|\.prototype\./, Ht = /* @__PURE__ */ __name(function(e, n) {
          var t = cp[lp(e)];
          return t == fp ? true : t == pp ? false : ap(n) ? ip(n) : !!n;
        }, "Ht"), lp = Ht.normalize = function(e) {
          return String(e).replace(op, ".").toLowerCase();
        }, cp = Ht.data = {}, pp = Ht.NATIVE = "N", fp = Ht.POLYFILL = "P";
        di.exports = Ht;
      });
      var Gt = Ne((j0, yi) => {
        var yn = Qe(), Dp = tn().f, mp = vr(), dp = Gs(), gp = Dr(), yp = mi(), hp = gi();
        yi.exports = function(e, n) {
          var t = e.target, s = e.global, a = e.stat, r, u, i, l, c, y;
          if (s ? u = yn : a ? u = yn[t] || gp(t, {}) : u = (yn[t] || {}).prototype, u)
            for (i in n) {
              if (c = n[i], e.noTargetGet ? (y = Dp(u, i), l = y && y.value) : l = u[i], r = hp(s ? i : t + (a ? "." : "#") + i, e.forced), !r && l !== void 0) {
                if (typeof c == typeof l)
                  continue;
                yp(c, l);
              }
              (e.sham || l && l.sham) && mp(c, "sham", true), dp(u, i, c, e);
            }
        };
      });
      var hn = Ne((O0, hi) => {
        var vp = or();
        hi.exports = Array.isArray || function(n) {
          return vp(n) == "Array";
        };
      });
      var vn = Ne((q0, Ci) => {
        var vi = ct(), Cp = Vt(), Ep = sr(), Fp = vi(vi.bind);
        Ci.exports = function(e, n) {
          return Cp(e), n === void 0 ? e : Ep ? Fp(e, n) : function() {
            return e.apply(n, arguments);
          };
        };
      });
      var Cn = Ne((M0, Fi) => {
        "use strict";
        var Ap = Qe(), Sp = hn(), xp = It(), bp = vn(), Tp = Ap.TypeError, Ei = /* @__PURE__ */ __name(function(e, n, t, s, a, r, u, i) {
          for (var l = a, c = 0, y = u ? bp(u, i) : false, h, g; c < s; ) {
            if (c in t) {
              if (h = y ? y(t[c], c, n) : t[c], r > 0 && Sp(h))
                g = xp(h), l = Ei(e, n, h, g, l, r - 1) - 1;
              else {
                if (l >= 9007199254740991)
                  throw Tp("Exceed the acceptable array length");
                e[l] = h;
              }
              l++;
            }
            c++;
          }
          return l;
        }, "Ei");
        Fi.exports = Ei;
      });
      var xi = Ne((R0, Si) => {
        var Bp = bt(), Np = Bp("toStringTag"), Ai = {};
        Ai[Np] = "z";
        Si.exports = String(Ai) === "[object z]";
      });
      var En = Ne(($0, bi) => {
        var wp = Qe(), _p = xi(), Pp = pt(), Sr = or(), Ip = bt(), kp = Ip("toStringTag"), Lp = wp.Object, jp = Sr(function() {
          return arguments;
        }()) == "Arguments", Op = /* @__PURE__ */ __name(function(e, n) {
          try {
            return e[n];
          } catch {
          }
        }, "Op");
        bi.exports = _p ? Sr : function(e) {
          var n, t, s;
          return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Op(n = Lp(e), kp)) == "string" ? t : jp ? Sr(n) : (s = Sr(n)) == "Object" && Pp(n.callee) ? "Arguments" : s;
        };
      });
      var Pi = Ne((V0, _i) => {
        var qp = ct(), Mp = dt(), Ti = pt(), Rp = En(), $p = $t(), Vp = Cr(), Bi = /* @__PURE__ */ __name(function() {
        }, "Bi"), Wp = [], Ni = $p("Reflect", "construct"), Fn = /^\s*(?:class|function)\b/, Hp = qp(Fn.exec), Gp = !Fn.exec(Bi), Ut = /* @__PURE__ */ __name(function(n) {
          if (!Ti(n))
            return false;
          try {
            return Ni(Bi, Wp, n), true;
          } catch {
            return false;
          }
        }, "Ut"), wi = /* @__PURE__ */ __name(function(n) {
          if (!Ti(n))
            return false;
          switch (Rp(n)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Gp || !!Hp(Fn, Vp(n));
          } catch {
            return true;
          }
        }, "wi");
        wi.sham = true;
        _i.exports = !Ni || Mp(function() {
          var e;
          return Ut(Ut.call) || !Ut(Object) || !Ut(function() {
            e = true;
          }) || e;
        }) ? wi : Ut;
      });
      var ji = Ne((W0, Li) => {
        var Up = Qe(), Ii = hn(), Jp = Pi(), zp = St(), Xp = bt(), Kp = Xp("species"), ki = Up.Array;
        Li.exports = function(e) {
          var n;
          return Ii(e) && (n = e.constructor, Jp(n) && (n === ki || Ii(n.prototype)) ? n = void 0 : zp(n) && (n = n[Kp], n === null && (n = void 0))), n === void 0 ? ki : n;
        };
      });
      var An = Ne((H0, Oi) => {
        var Yp = ji();
        Oi.exports = function(e, n) {
          return new (Yp(e))(n === 0 ? 0 : n);
        };
      });
      var qi = Ne(() => {
        "use strict";
        var Qp = Gt(), Zp = Cn(), ef = Vt(), tf = dr(), rf = It(), nf = An();
        Qp({ target: "Array", proto: true }, { flatMap: function(n) {
          var t = tf(this), s = rf(t), a;
          return ef(n), a = nf(t, 0), a.length = Zp(a, t, t, s, 0, 1, n, arguments.length > 1 ? arguments[1] : void 0), a;
        } });
      });
      var Sn = Ne((J0, Mi) => {
        Mi.exports = {};
      });
      var $i = Ne((z0, Ri) => {
        var uf = bt(), sf = Sn(), af = uf("iterator"), of = Array.prototype;
        Ri.exports = function(e) {
          return e !== void 0 && (sf.Array === e || of[af] === e);
        };
      });
      var xn = Ne((X0, Wi) => {
        var lf = En(), Vi = fr(), cf = Sn(), pf = bt(), ff = pf("iterator");
        Wi.exports = function(e) {
          if (e != null)
            return Vi(e, ff) || Vi(e, "@@iterator") || cf[lf(e)];
        };
      });
      var Gi = Ne((K0, Hi) => {
        var Df = Qe(), mf = At(), df = Vt(), gf = Pt(), yf = pr(), hf = xn(), vf = Df.TypeError;
        Hi.exports = function(e, n) {
          var t = arguments.length < 2 ? hf(e) : n;
          if (df(t))
            return gf(mf(t, e));
          throw vf(yf(e) + " is not iterable");
        };
      });
      var zi = Ne((Y0, Ji) => {
        var Cf = At(), Ui = Pt(), Ef = fr();
        Ji.exports = function(e, n, t) {
          var s, a;
          Ui(e);
          try {
            if (s = Ef(e, "return"), !s) {
              if (n === "throw")
                throw t;
              return t;
            }
            s = Cf(s, e);
          } catch (r) {
            a = true, s = r;
          }
          if (n === "throw")
            throw t;
          if (a)
            throw s;
          return Ui(s), t;
        };
      });
      var Zi = Ne((Q0, Qi) => {
        var Ff = Qe(), Af = vn(), Sf = At(), xf = Pt(), bf = pr(), Tf = $i(), Bf = It(), Xi = Wr(), Nf = Gi(), wf = xn(), Ki = zi(), _f = Ff.TypeError, xr = /* @__PURE__ */ __name(function(e, n) {
          this.stopped = e, this.result = n;
        }, "xr"), Yi = xr.prototype;
        Qi.exports = function(e, n, t) {
          var s = t && t.that, a = !!(t && t.AS_ENTRIES), r = !!(t && t.IS_ITERATOR), u = !!(t && t.INTERRUPTED), i = Af(n, s), l, c, y, h, g, p, D, v = /* @__PURE__ */ __name(function(T) {
            return l && Ki(l, "normal", T), new xr(true, T);
          }, "v"), w = /* @__PURE__ */ __name(function(T) {
            return a ? (xf(T), u ? i(T[0], T[1], v) : i(T[0], T[1])) : u ? i(T, v) : i(T);
          }, "w");
          if (r)
            l = e;
          else {
            if (c = wf(e), !c)
              throw _f(bf(e) + " is not iterable");
            if (Tf(c)) {
              for (y = 0, h = Bf(e); h > y; y++)
                if (g = w(e[y]), g && Xi(Yi, g))
                  return g;
              return new xr(false);
            }
            l = Nf(e, c);
          }
          for (p = l.next; !(D = Sf(p, l)).done; ) {
            try {
              g = w(D.value);
            } catch (T) {
              Ki(l, "throw", T);
            }
            if (typeof g == "object" && g && Xi(Yi, g))
              return g;
          }
          return new xr(false);
        };
      });
      var ta = Ne((Z0, ea) => {
        "use strict";
        var Pf = gr(), If = hr(), kf = ar();
        ea.exports = function(e, n, t) {
          var s = Pf(n);
          s in e ? If.f(e, s, kf(0, t)) : e[s] = t;
        };
      });
      var ra = Ne(() => {
        var Lf = Gt(), jf = Zi(), Of = ta();
        Lf({ target: "Object", stat: true }, { fromEntries: function(n) {
          var t = {};
          return jf(n, function(s, a) {
            Of(t, s, a);
          }, { AS_ENTRIES: true }), t;
        } });
      });
      var na = Ne(() => {
        var qf = Gt(), Mf = Qe();
        qf({ global: true }, { globalThis: Mf });
      });
      var ua = Ne(() => {
        na();
      });
      var sa = Ne(() => {
        "use strict";
        var Rf = Gt(), $f = Cn(), Vf = dr(), Wf = It(), Hf = Ar(), Gf = An();
        Rf({ target: "Array", proto: true }, { flat: function() {
          var n = arguments.length ? arguments[0] : void 0, t = Vf(this), s = Wf(t), a = Gf(t, 0);
          return a.length = $f(a, t, t, s, 0, n === void 0 ? 1 : Hf(n)), a;
        } });
      });
      var Tg = Ne((ly, mo) => {
        var Uf = ["cliName", "cliCategory", "cliDescription"], Jf = ["_"], zf = ["languageId"];
        function Ln(e, n) {
          if (e == null)
            return {};
          var t = Xf(e, n), s, a;
          if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            for (a = 0; a < r.length; a++)
              s = r[a], !(n.indexOf(s) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s) || (t[s] = e[s]));
          }
          return t;
        }
        __name(Ln, "Ln");
        function Xf(e, n) {
          if (e == null)
            return {};
          var t = {}, s = Object.keys(e), a, r;
          for (r = 0; r < s.length; r++)
            a = s[r], !(n.indexOf(a) >= 0) && (t[a] = e[a]);
          return t;
        }
        __name(Xf, "Xf");
        qi();
        ra();
        ua();
        sa();
        var Kf = Object.create, wr = Object.defineProperty, Yf = Object.getOwnPropertyDescriptor, jn = Object.getOwnPropertyNames, Qf = Object.getPrototypeOf, Zf = Object.prototype.hasOwnProperty, gt = /* @__PURE__ */ __name((e, n) => function() {
          return e && (n = (0, e[jn(e)[0]])(e = 0)), n;
        }, "gt"), ee = /* @__PURE__ */ __name((e, n) => function() {
          return n || (0, e[jn(e)[0]])((n = { exports: {} }).exports, n), n.exports;
        }, "ee"), zt = /* @__PURE__ */ __name((e, n) => {
          for (var t in n)
            wr(e, t, { get: n[t], enumerable: true });
        }, "zt"), pa = /* @__PURE__ */ __name((e, n, t, s) => {
          if (n && typeof n == "object" || typeof n == "function")
            for (let a of jn(n))
              !Zf.call(e, a) && a !== t && wr(e, a, { get: () => n[a], enumerable: !(s = Yf(n, a)) || s.enumerable });
          return e;
        }, "pa"), eD = /* @__PURE__ */ __name((e, n, t) => (t = e != null ? Kf(Qf(e)) : {}, pa(n || !e || !e.__esModule ? wr(t, "default", { value: e, enumerable: true }) : t, e)), "eD"), ft = /* @__PURE__ */ __name((e) => pa(wr({}, "__esModule", { value: true }), e), "ft"), ia, aa, Nt, re = gt({ "<define:process>"() {
          ia = {}, aa = [], Nt = { env: ia, argv: aa };
        } }), fa = ee({ "package.json"(e, n) {
          n.exports = { version: "2.8.1" };
        } }), tD = ee({ "node_modules/diff/lib/diff/base.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.default = n;
          function n() {
          }
          __name(n, "n");
          n.prototype = { diff: function(r, u) {
            var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = i.callback;
            typeof i == "function" && (l = i, i = {}), this.options = i;
            var c = this;
            function y(A) {
              return l ? (setTimeout(function() {
                l(void 0, A);
              }, 0), true) : A;
            }
            __name(y, "y");
            r = this.castInput(r), u = this.castInput(u), r = this.removeEmpty(this.tokenize(r)), u = this.removeEmpty(this.tokenize(u));
            var h = u.length, g = r.length, p = 1, D = h + g, v = [{ newPos: -1, components: [] }], w = this.extractCommon(v[0], u, r, 0);
            if (v[0].newPos + 1 >= h && w + 1 >= g)
              return y([{ value: this.join(u), count: u.length }]);
            function T() {
              for (var A = -1 * p; A <= p; A += 2) {
                var B = void 0, I = v[A - 1], P = v[A + 1], $ = (P ? P.newPos : 0) - A;
                I && (v[A - 1] = void 0);
                var f = I && I.newPos + 1 < h, x = P && 0 <= $ && $ < g;
                if (!f && !x) {
                  v[A] = void 0;
                  continue;
                }
                if (!f || x && I.newPos < P.newPos ? (B = s(P), c.pushComponent(B.components, void 0, true)) : (B = I, B.newPos++, c.pushComponent(B.components, true, void 0)), $ = c.extractCommon(B, u, r, A), B.newPos + 1 >= h && $ + 1 >= g)
                  return y(t(c, B.components, u, r, c.useLongestToken));
                v[A] = B;
              }
              p++;
            }
            __name(T, "T");
            if (l)
              (/* @__PURE__ */ __name(function A() {
                setTimeout(function() {
                  if (p > D)
                    return l();
                  T() || A();
                }, 0);
              }, "A"))();
            else
              for (; p <= D; ) {
                var F = T();
                if (F)
                  return F;
              }
          }, pushComponent: function(r, u, i) {
            var l = r[r.length - 1];
            l && l.added === u && l.removed === i ? r[r.length - 1] = { count: l.count + 1, added: u, removed: i } : r.push({ count: 1, added: u, removed: i });
          }, extractCommon: function(r, u, i, l) {
            for (var c = u.length, y = i.length, h = r.newPos, g = h - l, p = 0; h + 1 < c && g + 1 < y && this.equals(u[h + 1], i[g + 1]); )
              h++, g++, p++;
            return p && r.components.push({ count: p }), r.newPos = h, g;
          }, equals: function(r, u) {
            return this.options.comparator ? this.options.comparator(r, u) : r === u || this.options.ignoreCase && r.toLowerCase() === u.toLowerCase();
          }, removeEmpty: function(r) {
            for (var u = [], i = 0; i < r.length; i++)
              r[i] && u.push(r[i]);
            return u;
          }, castInput: function(r) {
            return r;
          }, tokenize: function(r) {
            return r.split("");
          }, join: function(r) {
            return r.join("");
          } };
          function t(a, r, u, i, l) {
            for (var c = 0, y = r.length, h = 0, g = 0; c < y; c++) {
              var p = r[c];
              if (p.removed) {
                if (p.value = a.join(i.slice(g, g + p.count)), g += p.count, c && r[c - 1].added) {
                  var v = r[c - 1];
                  r[c - 1] = r[c], r[c] = v;
                }
              } else {
                if (!p.added && l) {
                  var D = u.slice(h, h + p.count);
                  D = D.map(function(T, F) {
                    var A = i[g + F];
                    return A.length > T.length ? A : T;
                  }), p.value = a.join(D);
                } else
                  p.value = a.join(u.slice(h, h + p.count));
                h += p.count, p.added || (g += p.count);
              }
            }
            var w = r[y - 1];
            return y > 1 && typeof w.value == "string" && (w.added || w.removed) && a.equals("", w.value) && (r[y - 2].value += w.value, r.pop()), r;
          }
          __name(t, "t");
          function s(a) {
            return { newPos: a.newPos, components: a.components.slice(0) };
          }
          __name(s, "s");
        } }), rD = ee({ "node_modules/diff/lib/diff/array.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a, e.arrayDiff = void 0;
          var n = t(tD());
          function t(r) {
            return r && r.__esModule ? r : { default: r };
          }
          __name(t, "t");
          var s = new n.default();
          e.arrayDiff = s, s.tokenize = function(r) {
            return r.slice();
          }, s.join = s.removeEmpty = function(r) {
            return r;
          };
          function a(r, u, i) {
            return s.diff(r, u, i);
          }
          __name(a, "a");
        } }), On = ee({ "src/document/doc-builders.js"(e, n) {
          "use strict";
          re();
          function t(E) {
            return { type: "concat", parts: E };
          }
          __name(t, "t");
          function s(E) {
            return { type: "indent", contents: E };
          }
          __name(s, "s");
          function a(E, o) {
            return { type: "align", contents: o, n: E };
          }
          __name(a, "a");
          function r(E) {
            let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return { type: "group", id: o.id, contents: E, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
          }
          __name(r, "r");
          function u(E) {
            return a(Number.NEGATIVE_INFINITY, E);
          }
          __name(u, "u");
          function i(E) {
            return a({ type: "root" }, E);
          }
          __name(i, "i");
          function l(E) {
            return a(-1, E);
          }
          __name(l, "l");
          function c(E, o) {
            return r(E[0], Object.assign(Object.assign({}, o), {}, { expandedStates: E }));
          }
          __name(c, "c");
          function y(E) {
            return { type: "fill", parts: E };
          }
          __name(y, "y");
          function h(E, o) {
            let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return { type: "if-break", breakContents: E, flatContents: o, groupId: d.groupId };
          }
          __name(h, "h");
          function g(E, o) {
            return { type: "indent-if-break", contents: E, groupId: o.groupId, negate: o.negate };
          }
          __name(g, "g");
          function p(E) {
            return { type: "line-suffix", contents: E };
          }
          __name(p, "p");
          var D = { type: "line-suffix-boundary" }, v = { type: "break-parent" }, w = { type: "trim" }, T = { type: "line", hard: true }, F = { type: "line", hard: true, literal: true }, A = { type: "line" }, B = { type: "line", soft: true }, I = t([T, v]), P = t([F, v]), $ = { type: "cursor", placeholder: Symbol("cursor") };
          function f(E, o) {
            let d = [];
            for (let C = 0; C < o.length; C++)
              C !== 0 && d.push(E), d.push(o[C]);
            return t(d);
          }
          __name(f, "f");
          function x(E, o, d) {
            let C = E;
            if (o > 0) {
              for (let _ = 0; _ < Math.floor(o / d); ++_)
                C = s(C);
              C = a(o % d, C), C = a(Number.NEGATIVE_INFINITY, C);
            }
            return C;
          }
          __name(x, "x");
          function m(E, o) {
            return { type: "label", label: E, contents: o };
          }
          __name(m, "m");
          n.exports = { concat: t, join: f, line: A, softline: B, hardline: I, literalline: P, group: r, conditionalGroup: c, fill: y, lineSuffix: p, lineSuffixBoundary: D, cursor: $, breakParent: v, ifBreak: h, trim: w, indent: s, indentIfBreak: g, align: a, addAlignmentToDoc: x, markAsRoot: i, dedentToRoot: u, dedent: l, hardlineWithoutBreakParent: T, literallineWithoutBreakParent: F, label: m };
        } }), qn = ee({ "src/common/end-of-line.js"(e, n) {
          "use strict";
          re();
          function t(u) {
            let i = u.indexOf("\r");
            return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          __name(t, "t");
          function s(u) {
            switch (u) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          __name(s, "s");
          function a(u, i) {
            let l;
            switch (i) {
              case `
`:
                l = /\n/g;
                break;
              case "\r":
                l = /\r/g;
                break;
              case `\r
`:
                l = /\r\n/g;
                break;
              default:
                throw new Error(`Unexpected "eol" ${JSON.stringify(i)}.`);
            }
            let c = u.match(l);
            return c ? c.length : 0;
          }
          __name(a, "a");
          function r(u) {
            return u.replace(/\r\n?/g, `
`);
          }
          __name(r, "r");
          n.exports = { guessEndOfLine: t, convertEndOfLineToChars: s, countEndOfLineChars: a, normalizeEndOfLine: r };
        } }), lt = ee({ "src/utils/get-last.js"(e, n) {
          "use strict";
          re();
          var t = /* @__PURE__ */ __name((s) => s[s.length - 1], "t");
          n.exports = t;
        } });
        function nD() {
          let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(n, e ? void 0 : "g");
        }
        __name(nD, "nD");
        var uD = gt({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
          re();
        } });
        function sD(e) {
          if (typeof e != "string")
            throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
          return e.replace(nD(), "");
        }
        __name(sD, "sD");
        var iD = gt({ "node_modules/strip-ansi/index.js"() {
          re(), uD();
        } });
        function aD(e) {
          return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
        }
        __name(aD, "aD");
        var oD = gt({ "node_modules/is-fullwidth-code-point/index.js"() {
          re();
        } }), lD = ee({ "node_modules/emoji-regex/index.js"(e, n) {
          "use strict";
          re(), n.exports = function() {
            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
          };
        } }), Da = {};
        zt(Da, { default: () => cD });
        function cD(e) {
          if (typeof e != "string" || e.length === 0 || (e = sD(e), e.length === 0))
            return 0;
          e = e.replace((0, ma.default)(), "  ");
          let n = 0;
          for (let t = 0; t < e.length; t++) {
            let s = e.codePointAt(t);
            s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, n += aD(s) ? 2 : 1);
          }
          return n;
        }
        __name(cD, "cD");
        var ma, pD = gt({ "node_modules/string-width/index.js"() {
          re(), iD(), oD(), ma = eD(lD());
        } }), da = ee({ "src/utils/get-string-width.js"(e, n) {
          "use strict";
          re();
          var t = (pD(), ft(Da)).default, s = /[^\x20-\x7F]/;
          function a(r) {
            return r ? s.test(r) ? t(r) : r.length : 0;
          }
          __name(a, "a");
          n.exports = a;
        } }), Xt = ee({ "src/document/doc-utils.js"(e, n) {
          "use strict";
          re();
          var t = lt(), { literalline: s, join: a } = On(), r = /* @__PURE__ */ __name((o) => Array.isArray(o) || o && o.type === "concat", "r"), u = /* @__PURE__ */ __name((o) => {
            if (Array.isArray(o))
              return o;
            if (o.type !== "concat" && o.type !== "fill")
              throw new Error("Expect doc type to be `concat` or `fill`.");
            return o.parts;
          }, "u"), i = {};
          function l(o, d, C, _) {
            let b = [o];
            for (; b.length > 0; ) {
              let N = b.pop();
              if (N === i) {
                C(b.pop());
                continue;
              }
              if (C && b.push(N, i), !d || d(N) !== false)
                if (r(N) || N.type === "fill") {
                  let k = u(N);
                  for (let R = k.length, M = R - 1; M >= 0; --M)
                    b.push(k[M]);
                } else if (N.type === "if-break")
                  N.flatContents && b.push(N.flatContents), N.breakContents && b.push(N.breakContents);
                else if (N.type === "group" && N.expandedStates)
                  if (_)
                    for (let k = N.expandedStates.length, R = k - 1; R >= 0; --R)
                      b.push(N.expandedStates[R]);
                  else
                    b.push(N.contents);
                else
                  N.contents && b.push(N.contents);
            }
          }
          __name(l, "l");
          function c(o, d) {
            let C = /* @__PURE__ */ new Map();
            return _(o);
            function _(N) {
              if (C.has(N))
                return C.get(N);
              let k = b(N);
              return C.set(N, k), k;
            }
            __name(_, "_");
            function b(N) {
              if (Array.isArray(N))
                return d(N.map(_));
              if (N.type === "concat" || N.type === "fill") {
                let k = N.parts.map(_);
                return d(Object.assign(Object.assign({}, N), {}, { parts: k }));
              }
              if (N.type === "if-break") {
                let k = N.breakContents && _(N.breakContents), R = N.flatContents && _(N.flatContents);
                return d(Object.assign(Object.assign({}, N), {}, { breakContents: k, flatContents: R }));
              }
              if (N.type === "group" && N.expandedStates) {
                let k = N.expandedStates.map(_), R = k[0];
                return d(Object.assign(Object.assign({}, N), {}, { contents: R, expandedStates: k }));
              }
              if (N.contents) {
                let k = _(N.contents);
                return d(Object.assign(Object.assign({}, N), {}, { contents: k }));
              }
              return d(N);
            }
            __name(b, "b");
          }
          __name(c, "c");
          function y(o, d, C) {
            let _ = C, b = false;
            function N(k) {
              let R = d(k);
              if (R !== void 0 && (b = true, _ = R), b)
                return false;
            }
            __name(N, "N");
            return l(o, N), _;
          }
          __name(y, "y");
          function h(o) {
            if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent")
              return true;
          }
          __name(h, "h");
          function g(o) {
            return y(o, h, false);
          }
          __name(g, "g");
          function p(o) {
            if (o.length > 0) {
              let d = t(o);
              !d.expandedStates && !d.break && (d.break = "propagated");
            }
            return null;
          }
          __name(p, "p");
          function D(o) {
            let d = /* @__PURE__ */ new Set(), C = [];
            function _(N) {
              if (N.type === "break-parent" && p(C), N.type === "group") {
                if (C.push(N), d.has(N))
                  return false;
                d.add(N);
              }
            }
            __name(_, "_");
            function b(N) {
              N.type === "group" && C.pop().break && p(C);
            }
            __name(b, "b");
            l(o, _, b, true);
          }
          __name(D, "D");
          function v(o) {
            return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
          }
          __name(v, "v");
          function w(o) {
            return c(o, v);
          }
          __name(w, "w");
          var T = /* @__PURE__ */ __name((o, d) => o && o.type === "line" && o.hard && d && d.type === "break-parent", "T");
          function F(o) {
            if (!o)
              return o;
            if (r(o) || o.type === "fill") {
              let d = u(o);
              for (; d.length > 1 && T(...d.slice(-2)); )
                d.length -= 2;
              if (d.length > 0) {
                let C = F(t(d));
                d[d.length - 1] = C;
              }
              return Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
            }
            switch (o.type) {
              case "align":
              case "indent":
              case "indent-if-break":
              case "group":
              case "line-suffix":
              case "label": {
                let d = F(o.contents);
                return Object.assign(Object.assign({}, o), {}, { contents: d });
              }
              case "if-break": {
                let d = F(o.breakContents), C = F(o.flatContents);
                return Object.assign(Object.assign({}, o), {}, { breakContents: d, flatContents: C });
              }
            }
            return o;
          }
          __name(F, "F");
          function A(o) {
            return F(I(o));
          }
          __name(A, "A");
          function B(o) {
            switch (o.type) {
              case "fill":
                if (o.parts.every((C) => C === ""))
                  return "";
                break;
              case "group":
                if (!o.contents && !o.id && !o.break && !o.expandedStates)
                  return "";
                if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates)
                  return o.contents;
                break;
              case "align":
              case "indent":
              case "indent-if-break":
              case "line-suffix":
                if (!o.contents)
                  return "";
                break;
              case "if-break":
                if (!o.flatContents && !o.breakContents)
                  return "";
                break;
            }
            if (!r(o))
              return o;
            let d = [];
            for (let C of u(o)) {
              if (!C)
                continue;
              let [_, ...b] = r(C) ? u(C) : [C];
              typeof _ == "string" && typeof t(d) == "string" ? d[d.length - 1] += _ : d.push(_), d.push(...b);
            }
            return d.length === 0 ? "" : d.length === 1 ? d[0] : Array.isArray(o) ? d : Object.assign(Object.assign({}, o), {}, { parts: d });
          }
          __name(B, "B");
          function I(o) {
            return c(o, (d) => B(d));
          }
          __name(I, "I");
          function P(o) {
            let d = [], C = o.filter(Boolean);
            for (; C.length > 0; ) {
              let _ = C.shift();
              if (!!_) {
                if (r(_)) {
                  C.unshift(...u(_));
                  continue;
                }
                if (d.length > 0 && typeof t(d) == "string" && typeof _ == "string") {
                  d[d.length - 1] += _;
                  continue;
                }
                d.push(_);
              }
            }
            return d;
          }
          __name(P, "P");
          function $(o) {
            return c(o, (d) => Array.isArray(d) ? P(d) : d.parts ? Object.assign(Object.assign({}, d), {}, { parts: P(d.parts) }) : d);
          }
          __name($, "$");
          function f(o) {
            return c(o, (d) => typeof d == "string" && d.includes(`
`) ? x(d) : d);
          }
          __name(f, "f");
          function x(o) {
            let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
            return a(d, o.split(`
`)).parts;
          }
          __name(x, "x");
          function m(o) {
            if (o.type === "line")
              return true;
          }
          __name(m, "m");
          function E(o) {
            return y(o, m, false);
          }
          __name(E, "E");
          n.exports = { isConcat: r, getDocParts: u, willBreak: g, traverseDoc: l, findInDoc: y, mapDoc: c, propagateBreaks: D, removeLines: w, stripTrailingHardline: A, normalizeParts: P, normalizeDoc: $, cleanDoc: I, replaceTextEndOfLine: x, replaceEndOfLine: f, canBreak: E };
        } }), fD = ee({ "src/document/doc-printer.js"(e, n) {
          "use strict";
          re();
          var { convertEndOfLineToChars: t } = qn(), s = lt(), a = da(), { fill: r, cursor: u, indent: i } = On(), { isConcat: l, getDocParts: c } = Xt(), y, h = 1, g = 2;
          function p() {
            return { value: "", length: 0, queue: [] };
          }
          __name(p, "p");
          function D(B, I) {
            return w(B, { type: "indent" }, I);
          }
          __name(D, "D");
          function v(B, I, P) {
            return I === Number.NEGATIVE_INFINITY ? B.root || p() : I < 0 ? w(B, { type: "dedent" }, P) : I ? I.type === "root" ? Object.assign(Object.assign({}, B), {}, { root: B }) : w(B, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, P) : B;
          }
          __name(v, "v");
          function w(B, I, P) {
            let $ = I.type === "dedent" ? B.queue.slice(0, -1) : [...B.queue, I], f = "", x = 0, m = 0, E = 0;
            for (let k of $)
              switch (k.type) {
                case "indent":
                  C(), P.useTabs ? o(1) : d(P.tabWidth);
                  break;
                case "stringAlign":
                  C(), f += k.n, x += k.n.length;
                  break;
                case "numberAlign":
                  m += 1, E += k.n;
                  break;
                default:
                  throw new Error(`Unexpected type '${k.type}'`);
              }
            return b(), Object.assign(Object.assign({}, B), {}, { value: f, length: x, queue: $ });
            function o(k) {
              f += "	".repeat(k), x += P.tabWidth * k;
            }
            __name(o, "o");
            function d(k) {
              f += " ".repeat(k), x += k;
            }
            __name(d, "d");
            function C() {
              P.useTabs ? _() : b();
            }
            __name(C, "C");
            function _() {
              m > 0 && o(m), N();
            }
            __name(_, "_");
            function b() {
              E > 0 && d(E), N();
            }
            __name(b, "b");
            function N() {
              m = 0, E = 0;
            }
            __name(N, "N");
          }
          __name(w, "w");
          function T(B) {
            if (B.length === 0)
              return 0;
            let I = 0;
            for (; B.length > 0 && typeof s(B) == "string" && /^[\t ]*$/.test(s(B)); )
              I += B.pop().length;
            if (B.length > 0 && typeof s(B) == "string") {
              let P = s(B).replace(/[\t ]*$/, "");
              I += s(B).length - P.length, B[B.length - 1] = P;
            }
            return I;
          }
          __name(T, "T");
          function F(B, I, P, $, f) {
            let x = I.length, m = [B], E = [];
            for (; P >= 0; ) {
              if (m.length === 0) {
                if (x === 0)
                  return true;
                m.push(I[--x]);
                continue;
              }
              let { mode: o, doc: d } = m.pop();
              if (typeof d == "string")
                E.push(d), P -= a(d);
              else if (l(d) || d.type === "fill") {
                let C = c(d);
                for (let _ = C.length - 1; _ >= 0; _--)
                  m.push({ mode: o, doc: C[_] });
              } else
                switch (d.type) {
                  case "indent":
                  case "align":
                  case "indent-if-break":
                  case "label":
                    m.push({ mode: o, doc: d.contents });
                    break;
                  case "trim":
                    P += T(E);
                    break;
                  case "group": {
                    if (f && d.break)
                      return false;
                    let C = d.break ? h : o, _ = d.expandedStates && C === h ? s(d.expandedStates) : d.contents;
                    m.push({ mode: C, doc: _ });
                    break;
                  }
                  case "if-break": {
                    let _ = (d.groupId ? y[d.groupId] || g : o) === h ? d.breakContents : d.flatContents;
                    _ && m.push({ mode: o, doc: _ });
                    break;
                  }
                  case "line":
                    if (o === h || d.hard)
                      return true;
                    d.soft || (E.push(" "), P--);
                    break;
                  case "line-suffix":
                    $ = true;
                    break;
                  case "line-suffix-boundary":
                    if ($)
                      return false;
                    break;
                }
            }
            return false;
          }
          __name(F, "F");
          function A(B, I) {
            y = {};
            let P = I.printWidth, $ = t(I.endOfLine), f = 0, x = [{ ind: p(), mode: h, doc: B }], m = [], E = false, o = [];
            for (; x.length > 0; ) {
              let { ind: C, mode: _, doc: b } = x.pop();
              if (typeof b == "string") {
                let N = $ !== `
` ? b.replace(/\n/g, $) : b;
                m.push(N), f += a(N);
              } else if (l(b)) {
                let N = c(b);
                for (let k = N.length - 1; k >= 0; k--)
                  x.push({ ind: C, mode: _, doc: N[k] });
              } else
                switch (b.type) {
                  case "cursor":
                    m.push(u.placeholder);
                    break;
                  case "indent":
                    x.push({ ind: D(C, I), mode: _, doc: b.contents });
                    break;
                  case "align":
                    x.push({ ind: v(C, b.n, I), mode: _, doc: b.contents });
                    break;
                  case "trim":
                    f -= T(m);
                    break;
                  case "group":
                    switch (_) {
                      case g:
                        if (!E) {
                          x.push({ ind: C, mode: b.break ? h : g, doc: b.contents });
                          break;
                        }
                      case h: {
                        E = false;
                        let N = { ind: C, mode: g, doc: b.contents }, k = P - f, R = o.length > 0;
                        if (!b.break && F(N, x, k, R))
                          x.push(N);
                        else if (b.expandedStates) {
                          let M = s(b.expandedStates);
                          if (b.break) {
                            x.push({ ind: C, mode: h, doc: M });
                            break;
                          } else
                            for (let q = 1; q < b.expandedStates.length + 1; q++)
                              if (q >= b.expandedStates.length) {
                                x.push({ ind: C, mode: h, doc: M });
                                break;
                              } else {
                                let J = b.expandedStates[q], L = { ind: C, mode: g, doc: J };
                                if (F(L, x, k, R)) {
                                  x.push(L);
                                  break;
                                }
                              }
                        } else
                          x.push({ ind: C, mode: h, doc: b.contents });
                        break;
                      }
                    }
                    b.id && (y[b.id] = s(x).mode);
                    break;
                  case "fill": {
                    let N = P - f, { parts: k } = b;
                    if (k.length === 0)
                      break;
                    let [R, M] = k, q = { ind: C, mode: g, doc: R }, J = { ind: C, mode: h, doc: R }, L = F(q, [], N, o.length > 0, true);
                    if (k.length === 1) {
                      L ? x.push(q) : x.push(J);
                      break;
                    }
                    let Y = { ind: C, mode: g, doc: M }, V = { ind: C, mode: h, doc: M };
                    if (k.length === 2) {
                      L ? x.push(Y, q) : x.push(V, J);
                      break;
                    }
                    k.splice(0, 2);
                    let O = { ind: C, mode: _, doc: r(k) }, K = k[0];
                    F({ ind: C, mode: g, doc: [R, M, K] }, [], N, o.length > 0, true) ? x.push(O, Y, q) : L ? x.push(O, V, q) : x.push(O, V, J);
                    break;
                  }
                  case "if-break":
                  case "indent-if-break": {
                    let N = b.groupId ? y[b.groupId] : _;
                    if (N === h) {
                      let k = b.type === "if-break" ? b.breakContents : b.negate ? b.contents : i(b.contents);
                      k && x.push({ ind: C, mode: _, doc: k });
                    }
                    if (N === g) {
                      let k = b.type === "if-break" ? b.flatContents : b.negate ? i(b.contents) : b.contents;
                      k && x.push({ ind: C, mode: _, doc: k });
                    }
                    break;
                  }
                  case "line-suffix":
                    o.push({ ind: C, mode: _, doc: b.contents });
                    break;
                  case "line-suffix-boundary":
                    o.length > 0 && x.push({ ind: C, mode: _, doc: { type: "line", hard: true } });
                    break;
                  case "line":
                    switch (_) {
                      case g:
                        if (b.hard)
                          E = true;
                        else {
                          b.soft || (m.push(" "), f += 1);
                          break;
                        }
                      case h:
                        if (o.length > 0) {
                          x.push({ ind: C, mode: _, doc: b }, ...o.reverse()), o.length = 0;
                          break;
                        }
                        b.literal ? C.root ? (m.push($, C.root.value), f = C.root.length) : (m.push($), f = 0) : (f -= T(m), m.push($ + C.value), f = C.length);
                        break;
                    }
                    break;
                  case "label":
                    x.push({ ind: C, mode: _, doc: b.contents });
                    break;
                  default:
                }
              x.length === 0 && o.length > 0 && (x.push(...o.reverse()), o.length = 0);
            }
            let d = m.indexOf(u.placeholder);
            if (d !== -1) {
              let C = m.indexOf(u.placeholder, d + 1), _ = m.slice(0, d).join(""), b = m.slice(d + 1, C).join(""), N = m.slice(C + 1).join("");
              return { formatted: _ + b + N, cursorNodeStart: _.length, cursorNodeText: b };
            }
            return { formatted: m.join("") };
          }
          __name(A, "A");
          n.exports = { printDocToString: A };
        } }), DD = ee({ "src/document/doc-debug.js"(e, n) {
          "use strict";
          re();
          var { isConcat: t, getDocParts: s } = Xt();
          function a(u) {
            if (!u)
              return "";
            if (t(u)) {
              let i = [];
              for (let l of s(u))
                if (t(l))
                  i.push(...a(l).parts);
                else {
                  let c = a(l);
                  c !== "" && i.push(c);
                }
              return { type: "concat", parts: i };
            }
            return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a(u.breakContents), flatContents: a(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents) }) : u;
          }
          __name(a, "a");
          function r(u) {
            let i = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ new Set();
            return c(a(u));
            function c(h, g, p) {
              if (typeof h == "string")
                return JSON.stringify(h);
              if (t(h)) {
                let D = s(h).map(c).filter(Boolean);
                return D.length === 1 ? D[0] : `[${D.join(", ")}]`;
              }
              if (h.type === "line") {
                let D = Array.isArray(p) && p[g + 1] && p[g + 1].type === "break-parent";
                return h.literal ? D ? "literalline" : "literallineWithoutBreakParent" : h.hard ? D ? "hardline" : "hardlineWithoutBreakParent" : h.soft ? "softline" : "line";
              }
              if (h.type === "break-parent")
                return Array.isArray(p) && p[g - 1] && p[g - 1].type === "line" && p[g - 1].hard ? void 0 : "breakParent";
              if (h.type === "trim")
                return "trim";
              if (h.type === "indent")
                return "indent(" + c(h.contents) + ")";
              if (h.type === "align")
                return h.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + c(h.contents) + ")" : h.n < 0 ? "dedent(" + c(h.contents) + ")" : h.n.type === "root" ? "markAsRoot(" + c(h.contents) + ")" : "align(" + JSON.stringify(h.n) + ", " + c(h.contents) + ")";
              if (h.type === "if-break")
                return "ifBreak(" + c(h.breakContents) + (h.flatContents ? ", " + c(h.flatContents) : "") + (h.groupId ? (h.flatContents ? "" : ', ""') + `, { groupId: ${y(h.groupId)} }` : "") + ")";
              if (h.type === "indent-if-break") {
                let D = [];
                h.negate && D.push("negate: true"), h.groupId && D.push(`groupId: ${y(h.groupId)}`);
                let v = D.length > 0 ? `, { ${D.join(", ")} }` : "";
                return `indentIfBreak(${c(h.contents)}${v})`;
              }
              if (h.type === "group") {
                let D = [];
                h.break && h.break !== "propagated" && D.push("shouldBreak: true"), h.id && D.push(`id: ${y(h.id)}`);
                let v = D.length > 0 ? `, { ${D.join(", ")} }` : "";
                return h.expandedStates ? `conditionalGroup([${h.expandedStates.map((w) => c(w)).join(",")}]${v})` : `group(${c(h.contents)}${v})`;
              }
              if (h.type === "fill")
                return `fill([${h.parts.map((D) => c(D)).join(", ")}])`;
              if (h.type === "line-suffix")
                return "lineSuffix(" + c(h.contents) + ")";
              if (h.type === "line-suffix-boundary")
                return "lineSuffixBoundary";
              if (h.type === "label")
                return `label(${JSON.stringify(h.label)}, ${c(h.contents)})`;
              throw new Error("Unknown doc type " + h.type);
            }
            __name(c, "c");
            function y(h) {
              if (typeof h != "symbol")
                return JSON.stringify(String(h));
              if (h in i)
                return i[h];
              let g = String(h).slice(7, -1) || "symbol";
              for (let p = 0; ; p++) {
                let D = g + (p > 0 ? ` #${p}` : "");
                if (!l.has(D))
                  return l.add(D), i[h] = `Symbol.for(${JSON.stringify(D)})`;
              }
            }
            __name(y, "y");
          }
          __name(r, "r");
          n.exports = { printDocToDebug: r };
        } }), qe = ee({ "src/document/index.js"(e, n) {
          "use strict";
          re(), n.exports = { builders: On(), printer: fD(), utils: Xt(), debug: DD() };
        } }), ga = {};
        zt(ga, { default: () => mD });
        function mD(e) {
          if (typeof e != "string")
            throw new TypeError("Expected a string");
          return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        __name(mD, "mD");
        var dD = gt({ "node_modules/escape-string-regexp/index.js"() {
          re();
        } }), ya = ee({ "node_modules/semver/internal/debug.js"(e, n) {
          re();
          var t = typeof Nt == "object" && Nt.env && Nt.env.NODE_DEBUG && /\bsemver\b/i.test(Nt.env.NODE_DEBUG) ? function() {
            for (var s = arguments.length, a = new Array(s), r = 0; r < s; r++)
              a[r] = arguments[r];
            return console.error("SEMVER", ...a);
          } : () => {
          };
          n.exports = t;
        } }), ha = ee({ "node_modules/semver/internal/constants.js"(e, n) {
          re();
          var t = "2.0.0", s = 256, a = Number.MAX_SAFE_INTEGER || 9007199254740991, r = 16;
          n.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s, MAX_SAFE_INTEGER: a, MAX_SAFE_COMPONENT_LENGTH: r };
        } }), gD = ee({ "node_modules/semver/internal/re.js"(e, n) {
          re();
          var { MAX_SAFE_COMPONENT_LENGTH: t } = ha(), s = ya();
          e = n.exports = {};
          var a = e.re = [], r = e.src = [], u = e.t = {}, i = 0, l = /* @__PURE__ */ __name((c, y, h) => {
            let g = i++;
            s(c, g, y), u[c] = g, r[g] = y, a[g] = new RegExp(y, h ? "g" : void 0);
          }, "l");
          l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${r[u.NUMERICIDENTIFIER]})\\.(${r[u.NUMERICIDENTIFIER]})\\.(${r[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${r[u.NUMERICIDENTIFIERLOOSE]})\\.(${r[u.NUMERICIDENTIFIERLOOSE]})\\.(${r[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${r[u.NUMERICIDENTIFIER]}|${r[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${r[u.NUMERICIDENTIFIERLOOSE]}|${r[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${r[u.PRERELEASEIDENTIFIER]}(?:\\.${r[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${r[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${r[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${r[u.BUILDIDENTIFIER]}(?:\\.${r[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${r[u.MAINVERSION]}${r[u.PRERELEASE]}?${r[u.BUILD]}?`), l("FULL", `^${r[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${r[u.MAINVERSIONLOOSE]}${r[u.PRERELEASELOOSE]}?${r[u.BUILD]}?`), l("LOOSE", `^${r[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${r[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${r[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${r[u.XRANGEIDENTIFIER]})(?:\\.(${r[u.XRANGEIDENTIFIER]})(?:\\.(${r[u.XRANGEIDENTIFIER]})(?:${r[u.PRERELEASE]})?${r[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${r[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${r[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${r[u.XRANGEIDENTIFIERLOOSE]})(?:${r[u.PRERELEASELOOSE]})?${r[u.BUILD]}?)?)?`), l("XRANGE", `^${r[u.GTLT]}\\s*${r[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${r[u.GTLT]}\\s*${r[u.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), l("COERCERTL", r[u.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${r[u.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", l("TILDE", `^${r[u.LONETILDE]}${r[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${r[u.LONETILDE]}${r[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${r[u.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", l("CARET", `^${r[u.LONECARET]}${r[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${r[u.LONECARET]}${r[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${r[u.GTLT]}\\s*(${r[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${r[u.GTLT]}\\s*(${r[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${r[u.GTLT]}\\s*(${r[u.LOOSEPLAIN]}|${r[u.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${r[u.XRANGEPLAIN]})\\s+-\\s+(${r[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${r[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${r[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        } }), yD = ee({ "node_modules/semver/internal/parse-options.js"(e, n) {
          re();
          var t = ["includePrerelease", "loose", "rtl"], s = /* @__PURE__ */ __name((a) => a ? typeof a != "object" ? { loose: true } : t.filter((r) => a[r]).reduce((r, u) => (r[u] = true, r), {}) : {}, "s");
          n.exports = s;
        } }), hD = ee({ "node_modules/semver/internal/identifiers.js"(e, n) {
          re();
          var t = /^[0-9]+$/, s = /* @__PURE__ */ __name((r, u) => {
            let i = t.test(r), l = t.test(u);
            return i && l && (r = +r, u = +u), r === u ? 0 : i && !l ? -1 : l && !i ? 1 : r < u ? -1 : 1;
          }, "s"), a = /* @__PURE__ */ __name((r, u) => s(u, r), "a");
          n.exports = { compareIdentifiers: s, rcompareIdentifiers: a };
        } }), vD = ee({ "node_modules/semver/classes/semver.js"(e, n) {
          re();
          var t = ya(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: a } = ha(), { re: r, t: u } = gD(), i = yD(), { compareIdentifiers: l } = hD(), c = /* @__PURE__ */ __name(class {
            constructor(y, h) {
              if (h = i(h), y instanceof c) {
                if (y.loose === !!h.loose && y.includePrerelease === !!h.includePrerelease)
                  return y;
                y = y.version;
              } else if (typeof y != "string")
                throw new TypeError(`Invalid Version: ${y}`);
              if (y.length > s)
                throw new TypeError(`version is longer than ${s} characters`);
              t("SemVer", y, h), this.options = h, this.loose = !!h.loose, this.includePrerelease = !!h.includePrerelease;
              let g = y.trim().match(h.loose ? r[u.LOOSE] : r[u.FULL]);
              if (!g)
                throw new TypeError(`Invalid Version: ${y}`);
              if (this.raw = y, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > a || this.major < 0)
                throw new TypeError("Invalid major version");
              if (this.minor > a || this.minor < 0)
                throw new TypeError("Invalid minor version");
              if (this.patch > a || this.patch < 0)
                throw new TypeError("Invalid patch version");
              g[4] ? this.prerelease = g[4].split(".").map((p) => {
                if (/^[0-9]+$/.test(p)) {
                  let D = +p;
                  if (D >= 0 && D < a)
                    return D;
                }
                return p;
              }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
            }
            format() {
              return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
            }
            toString() {
              return this.version;
            }
            compare(y) {
              if (t("SemVer.compare", this.version, this.options, y), !(y instanceof c)) {
                if (typeof y == "string" && y === this.version)
                  return 0;
                y = new c(y, this.options);
              }
              return y.version === this.version ? 0 : this.compareMain(y) || this.comparePre(y);
            }
            compareMain(y) {
              return y instanceof c || (y = new c(y, this.options)), l(this.major, y.major) || l(this.minor, y.minor) || l(this.patch, y.patch);
            }
            comparePre(y) {
              if (y instanceof c || (y = new c(y, this.options)), this.prerelease.length && !y.prerelease.length)
                return -1;
              if (!this.prerelease.length && y.prerelease.length)
                return 1;
              if (!this.prerelease.length && !y.prerelease.length)
                return 0;
              let h = 0;
              do {
                let g = this.prerelease[h], p = y.prerelease[h];
                if (t("prerelease compare", h, g, p), g === void 0 && p === void 0)
                  return 0;
                if (p === void 0)
                  return 1;
                if (g === void 0)
                  return -1;
                if (g === p)
                  continue;
                return l(g, p);
              } while (++h);
            }
            compareBuild(y) {
              y instanceof c || (y = new c(y, this.options));
              let h = 0;
              do {
                let g = this.build[h], p = y.build[h];
                if (t("prerelease compare", h, g, p), g === void 0 && p === void 0)
                  return 0;
                if (p === void 0)
                  return 1;
                if (g === void 0)
                  return -1;
                if (g === p)
                  continue;
                return l(g, p);
              } while (++h);
            }
            inc(y, h) {
              switch (y) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", h);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", h);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", h), this.inc("pre", h);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", h), this.inc("pre", h);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0)
                    this.prerelease = [0];
                  else {
                    let g = this.prerelease.length;
                    for (; --g >= 0; )
                      typeof this.prerelease[g] == "number" && (this.prerelease[g]++, g = -2);
                    g === -1 && this.prerelease.push(0);
                  }
                  h && (l(this.prerelease[0], h) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [h, 0]) : this.prerelease = [h, 0]);
                  break;
                default:
                  throw new Error(`invalid increment argument: ${y}`);
              }
              return this.format(), this.raw = this.version, this;
            }
          }, "c");
          n.exports = c;
        } }), Mn = ee({ "node_modules/semver/functions/compare.js"(e, n) {
          re();
          var t = vD(), s = /* @__PURE__ */ __name((a, r, u) => new t(a, u).compare(new t(r, u)), "s");
          n.exports = s;
        } }), CD = ee({ "node_modules/semver/functions/lt.js"(e, n) {
          re();
          var t = Mn(), s = /* @__PURE__ */ __name((a, r, u) => t(a, r, u) < 0, "s");
          n.exports = s;
        } }), ED = ee({ "node_modules/semver/functions/gte.js"(e, n) {
          re();
          var t = Mn(), s = /* @__PURE__ */ __name((a, r, u) => t(a, r, u) >= 0, "s");
          n.exports = s;
        } }), FD = ee({ "src/utils/arrayify.js"(e, n) {
          "use strict";
          re(), n.exports = (t, s) => Object.entries(t).map((a) => {
            let [r, u] = a;
            return Object.assign({ [s]: r }, u);
          });
        } }), AD = ee({ "node_modules/outdent/lib/index.js"(e, n) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
          function t() {
            for (var F = [], A = 0; A < arguments.length; A++)
              F[A] = arguments[A];
          }
          __name(t, "t");
          function s() {
            return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a();
          }
          __name(s, "s");
          function a() {
            return { add: t, delete: t, get: t, set: t, has: function(F) {
              return false;
            } };
          }
          __name(a, "a");
          var r = Object.prototype.hasOwnProperty, u = /* @__PURE__ */ __name(function(F, A) {
            return r.call(F, A);
          }, "u");
          function i(F, A) {
            for (var B in A)
              u(A, B) && (F[B] = A[B]);
            return F;
          }
          __name(i, "i");
          var l = /^[ \t]*(?:\r\n|\r|\n)/, c = /(?:\r\n|\r|\n)[ \t]*$/, y = /^(?:[\r\n]|$)/, h = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function p(F, A, B) {
            var I = 0, P = F[0].match(h);
            P && (I = P[1].length);
            var $ = "(\\r\\n|\\r|\\n).{0," + I + "}", f = new RegExp($, "g");
            A && (F = F.slice(1));
            var x = B.newline, m = B.trimLeadingNewline, E = B.trimTrailingNewline, o = typeof x == "string", d = F.length, C = F.map(function(_, b) {
              return _ = _.replace(f, "$1"), b === 0 && m && (_ = _.replace(l, "")), b === d - 1 && E && (_ = _.replace(c, "")), o && (_ = _.replace(/\r\n|\n|\r/g, function(N) {
                return x;
              })), _;
            });
            return C;
          }
          __name(p, "p");
          function D(F, A) {
            for (var B = "", I = 0, P = F.length; I < P; I++)
              B += F[I], I < P - 1 && (B += A[I]);
            return B;
          }
          __name(D, "D");
          function v(F) {
            return u(F, "raw") && u(F, "length");
          }
          __name(v, "v");
          function w(F) {
            var A = s(), B = s();
            function I($) {
              for (var f = [], x = 1; x < arguments.length; x++)
                f[x - 1] = arguments[x];
              if (v($)) {
                var m = $, E = (f[0] === I || f[0] === T) && g.test(m[0]) && y.test(m[1]), o = E ? B : A, d = o.get(m);
                if (d || (d = p(m, E, F), o.set(m, d)), f.length === 0)
                  return d[0];
                var C = D(d, E ? f.slice(1) : f);
                return C;
              } else
                return w(i(i({}, F), $ || {}));
            }
            __name(I, "I");
            var P = i(I, { string: function($) {
              return p([$], false, F)[0];
            } });
            return P;
          }
          __name(w, "w");
          var T = w({ trimLeadingNewline: true, trimTrailingNewline: true });
          if (e.outdent = T, e.default = T, typeof n < "u")
            try {
              n.exports = T, Object.defineProperty(T, "__esModule", { value: true }), T.default = T, T.outdent = T;
            } catch {
            }
        } }), SD = ee({ "src/main/core-options.js"(e, n) {
          "use strict";
          re();
          var { outdent: t } = AD(), s = "Config", a = "Editor", r = "Format", u = "Other", i = "Output", l = "Global", c = "Special", y = { cursorOffset: { since: "1.4.0", category: c, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: c, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: c, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (h) => typeof h == "string" || typeof h == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: t`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (h) => typeof h == "string" || typeof h == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: c, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, rangeStart: { since: "1.4.0", category: c, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, requirePragma: { since: "1.7.0", category: c, type: "boolean", default: false, description: t`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
          n.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: a, CATEGORY_FORMAT: r, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: c, options: y };
        } }), Rn = ee({ "src/main/support.js"(e, n) {
          "use strict";
          re();
          var t = { compare: Mn(), lt: CD(), gte: ED() }, s = FD(), a = fa().version, r = SD().options;
          function u() {
            let { plugins: l = [], showUnreleased: c = false, showDeprecated: y = false, showInternal: h = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = a.split("-", 1)[0], p = l.flatMap((F) => F.languages || []).filter(v), D = s(Object.assign({}, ...l.map((F) => {
              let { options: A } = F;
              return A;
            }), r), "name").filter((F) => v(F) && w(F)).sort((F, A) => F.name === A.name ? 0 : F.name < A.name ? -1 : 1).map(T).map((F) => {
              F = Object.assign({}, F), Array.isArray(F.default) && (F.default = F.default.length === 1 ? F.default[0].value : F.default.filter(v).sort((B, I) => t.compare(I.since, B.since))[0].value), Array.isArray(F.choices) && (F.choices = F.choices.filter((B) => v(B) && w(B)), F.name === "parser" && i(F, p, l));
              let A = Object.fromEntries(l.filter((B) => B.defaultOptions && B.defaultOptions[F.name] !== void 0).map((B) => [B.name, B.defaultOptions[F.name]]));
              return Object.assign(Object.assign({}, F), {}, { pluginDefaults: A });
            });
            return { languages: p, options: D };
            function v(F) {
              return c || !("since" in F) || F.since && t.gte(g, F.since);
            }
            __name(v, "v");
            function w(F) {
              return y || !("deprecated" in F) || F.deprecated && t.lt(g, F.deprecated);
            }
            __name(w, "w");
            function T(F) {
              if (h)
                return F;
              let { cliName: A, cliCategory: B, cliDescription: I } = F;
              return Ln(F, Uf);
            }
            __name(T, "T");
          }
          __name(u, "u");
          function i(l, c, y) {
            let h = new Set(l.choices.map((g) => g.value));
            for (let g of c)
              if (g.parsers) {
                for (let p of g.parsers)
                  if (!h.has(p)) {
                    h.add(p);
                    let D = y.find((w) => w.parsers && w.parsers[p]), v = g.name;
                    D && D.name && (v += ` (plugin: ${D.name})`), l.choices.push({ value: p, description: v });
                  }
              }
          }
          __name(i, "i");
          n.exports = { getSupportInfo: u };
        } }), $n = ee({ "src/utils/is-non-empty-array.js"(e, n) {
          "use strict";
          re();
          function t(s) {
            return Array.isArray(s) && s.length > 0;
          }
          __name(t, "t");
          n.exports = t;
        } }), _r = ee({ "src/utils/text/skip.js"(e, n) {
          "use strict";
          re();
          function t(i) {
            return (l, c, y) => {
              let h = y && y.backwards;
              if (c === false)
                return false;
              let { length: g } = l, p = c;
              for (; p >= 0 && p < g; ) {
                let D = l.charAt(p);
                if (i instanceof RegExp) {
                  if (!i.test(D))
                    return p;
                } else if (!i.includes(D))
                  return p;
                h ? p-- : p++;
              }
              return p === -1 || p === g ? p : false;
            };
          }
          __name(t, "t");
          var s = t(/\s/), a = t(" 	"), r = t(",; 	"), u = t(/[^\n\r]/);
          n.exports = { skipWhitespace: s, skipSpaces: a, skipToLineEnd: r, skipEverythingButNewLine: u };
        } }), va = ee({ "src/utils/text/skip-inline-comment.js"(e, n) {
          "use strict";
          re();
          function t(s, a) {
            if (a === false)
              return false;
            if (s.charAt(a) === "/" && s.charAt(a + 1) === "*") {
              for (let r = a + 2; r < s.length; ++r)
                if (s.charAt(r) === "*" && s.charAt(r + 1) === "/")
                  return r + 2;
            }
            return a;
          }
          __name(t, "t");
          n.exports = t;
        } }), Ca = ee({ "src/utils/text/skip-trailing-comment.js"(e, n) {
          "use strict";
          re();
          var { skipEverythingButNewLine: t } = _r();
          function s(a, r) {
            return r === false ? false : a.charAt(r) === "/" && a.charAt(r + 1) === "/" ? t(a, r) : r;
          }
          __name(s, "s");
          n.exports = s;
        } }), Ea = ee({ "src/utils/text/skip-newline.js"(e, n) {
          "use strict";
          re();
          function t(s, a, r) {
            let u = r && r.backwards;
            if (a === false)
              return false;
            let i = s.charAt(a);
            if (u) {
              if (s.charAt(a - 1) === "\r" && i === `
`)
                return a - 2;
              if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                return a - 1;
            } else {
              if (i === "\r" && s.charAt(a + 1) === `
`)
                return a + 2;
              if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                return a + 1;
            }
            return a;
          }
          __name(t, "t");
          n.exports = t;
        } }), xD = ee({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, n) {
          "use strict";
          re();
          var t = va(), s = Ea(), a = Ca(), { skipSpaces: r } = _r();
          function u(i, l) {
            let c = null, y = l;
            for (; y !== c; )
              c = y, y = r(i, y), y = t(i, y), y = a(i, y), y = s(i, y);
            return y;
          }
          __name(u, "u");
          n.exports = u;
        } }), Ge = ee({ "src/common/util.js"(e, n) {
          "use strict";
          re();
          var { default: t } = (dD(), ft(ga)), s = lt(), { getSupportInfo: a } = Rn(), r = $n(), u = da(), { skipWhitespace: i, skipSpaces: l, skipToLineEnd: c, skipEverythingButNewLine: y } = _r(), h = va(), g = Ca(), p = Ea(), D = xD(), v = /* @__PURE__ */ __name((V) => V[V.length - 2], "v");
          function w(V) {
            return (O, K, se) => {
              let Q = se && se.backwards;
              if (K === false)
                return false;
              let { length: le } = O, W = K;
              for (; W >= 0 && W < le; ) {
                let X = O.charAt(W);
                if (V instanceof RegExp) {
                  if (!V.test(X))
                    return W;
                } else if (!V.includes(X))
                  return W;
                Q ? W-- : W++;
              }
              return W === -1 || W === le ? W : false;
            };
          }
          __name(w, "w");
          function T(V, O) {
            let K = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, se = l(V, K.backwards ? O - 1 : O, K), Q = p(V, se, K);
            return se !== Q;
          }
          __name(T, "T");
          function F(V, O, K) {
            for (let se = O; se < K; ++se)
              if (V.charAt(se) === `
`)
                return true;
            return false;
          }
          __name(F, "F");
          function A(V, O, K) {
            let se = K(O) - 1;
            se = l(V, se, { backwards: true }), se = p(V, se, { backwards: true }), se = l(V, se, { backwards: true });
            let Q = p(V, se, { backwards: true });
            return se !== Q;
          }
          __name(A, "A");
          function B(V, O) {
            let K = null, se = O;
            for (; se !== K; )
              K = se, se = c(V, se), se = h(V, se), se = l(V, se);
            return se = g(V, se), se = p(V, se), se !== false && T(V, se);
          }
          __name(B, "B");
          function I(V, O, K) {
            return B(V, K(O));
          }
          __name(I, "I");
          function P(V, O, K) {
            return D(V, K(O));
          }
          __name(P, "P");
          function $(V, O, K) {
            return V.charAt(P(V, O, K));
          }
          __name($, "$");
          function f(V, O) {
            let K = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return l(V, K.backwards ? O - 1 : O, K) !== O;
          }
          __name(f, "f");
          function x(V, O) {
            let K = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, se = 0;
            for (let Q = K; Q < V.length; ++Q)
              V[Q] === "	" ? se = se + O - se % O : se++;
            return se;
          }
          __name(x, "x");
          function m(V, O) {
            let K = V.lastIndexOf(`
`);
            return K === -1 ? 0 : x(V.slice(K + 1).match(/^[\t ]*/)[0], O);
          }
          __name(m, "m");
          function E(V, O) {
            let K = { quote: '"', regex: /"/g, escaped: "&quot;" }, se = { quote: "'", regex: /'/g, escaped: "&apos;" }, Q = O === "'" ? se : K, le = Q === se ? K : se, W = Q;
            if (V.includes(Q.quote) || V.includes(le.quote)) {
              let X = (V.match(Q.regex) || []).length, oe = (V.match(le.regex) || []).length;
              W = X > oe ? le : Q;
            }
            return W;
          }
          __name(E, "E");
          function o(V, O) {
            let K = V.slice(1, -1), se = O.parser === "json" || O.parser === "json5" && O.quoteProps === "preserve" && !O.singleQuote ? '"' : O.__isInHtmlAttribute ? "'" : E(K, O.singleQuote ? "'" : '"').quote;
            return d(K, se, !(O.parser === "css" || O.parser === "less" || O.parser === "scss" || O.__embeddedInHtml));
          }
          __name(o, "o");
          function d(V, O, K) {
            let se = O === '"' ? "'" : '"', Q = /\\(.)|(["'])/gs, le = V.replace(Q, (W, X, oe) => X === se ? X : oe === O ? "\\" + oe : oe || (K && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(X) ? X : "\\" + X));
            return O + le + O;
          }
          __name(d, "d");
          function C(V) {
            return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          }
          __name(C, "C");
          function _(V, O) {
            let K = V.match(new RegExp(`(${t(O)})+`, "g"));
            return K === null ? 0 : K.reduce((se, Q) => Math.max(se, Q.length / O.length), 0);
          }
          __name(_, "_");
          function b(V, O) {
            let K = V.match(new RegExp(`(${t(O)})+`, "g"));
            if (K === null)
              return 0;
            let se = /* @__PURE__ */ new Map(), Q = 0;
            for (let le of K) {
              let W = le.length / O.length;
              se.set(W, true), W > Q && (Q = W);
            }
            for (let le = 1; le < Q; le++)
              if (!se.get(le))
                return le;
            return Q + 1;
          }
          __name(b, "b");
          function N(V, O) {
            (V.comments || (V.comments = [])).push(O), O.printed = false, O.nodeDescription = Y(V);
          }
          __name(N, "N");
          function k(V, O) {
            O.leading = true, O.trailing = false, N(V, O);
          }
          __name(k, "k");
          function R(V, O, K) {
            O.leading = false, O.trailing = false, K && (O.marker = K), N(V, O);
          }
          __name(R, "R");
          function M(V, O) {
            O.leading = false, O.trailing = true, N(V, O);
          }
          __name(M, "M");
          function q(V, O) {
            let { languages: K } = a({ plugins: O.plugins }), se = K.find((Q) => {
              let { name: le } = Q;
              return le.toLowerCase() === V;
            }) || K.find((Q) => {
              let { aliases: le } = Q;
              return Array.isArray(le) && le.includes(V);
            }) || K.find((Q) => {
              let { extensions: le } = Q;
              return Array.isArray(le) && le.includes(`.${V}`);
            });
            return se && se.parsers[0];
          }
          __name(q, "q");
          function J(V) {
            return V && V.type === "front-matter";
          }
          __name(J, "J");
          function L(V) {
            let O = /* @__PURE__ */ new WeakMap();
            return function(K) {
              return O.has(K) || O.set(K, Symbol(V)), O.get(K);
            };
          }
          __name(L, "L");
          function Y(V) {
            let O = V.type || V.kind || "(unknown type)", K = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
            return K.length > 20 && (K = K.slice(0, 19) + "\u2026"), O + (K ? " " + K : "");
          }
          __name(Y, "Y");
          n.exports = { inferParserByLanguage: q, getStringWidth: u, getMaxContinuousCount: _, getMinNotPresentContinuousCount: b, getPenultimate: v, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: D, getNextNonSpaceNonCommentCharacterIndex: P, getNextNonSpaceNonCommentCharacter: $, skip: w, skipWhitespace: i, skipSpaces: l, skipToLineEnd: c, skipEverythingButNewLine: y, skipInlineComment: h, skipTrailingComment: g, skipNewline: p, isNextLineEmptyAfterIndex: B, isNextLineEmpty: I, isPreviousLineEmpty: A, hasNewline: T, hasNewlineInRange: F, hasSpaces: f, getAlignmentSize: x, getIndentSize: m, getPreferredQuote: E, printString: o, printNumber: C, makeString: d, addLeadingComment: k, addDanglingComment: R, addTrailingComment: M, isFrontMatterNode: J, isNonEmptyArray: r, createGroupIdMapper: L };
        } }), Fa = {};
        zt(Fa, { basename: () => Ta, default: () => Na, delimiter: () => wn, dirname: () => ba, extname: () => Ba, isAbsolute: () => Wn, join: () => Sa, normalize: () => Vn, relative: () => xa, resolve: () => Nr, sep: () => Nn });
        function Aa(e, n) {
          for (var t = 0, s = e.length - 1; s >= 0; s--) {
            var a = e[s];
            a === "." ? e.splice(s, 1) : a === ".." ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);
          }
          if (n)
            for (; t--; t)
              e.unshift("..");
          return e;
        }
        __name(Aa, "Aa");
        function Nr() {
          for (var e = "", n = false, t = arguments.length - 1; t >= -1 && !n; t--) {
            var s = t >= 0 ? arguments[t] : "/";
            if (typeof s != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!s)
              continue;
            e = s + "/" + e, n = s.charAt(0) === "/";
          }
          return e = Aa(Hn(e.split("/"), function(a) {
            return !!a;
          }), !n).join("/"), (n ? "/" : "") + e || ".";
        }
        __name(Nr, "Nr");
        function Vn(e) {
          var n = Wn(e), t = wa(e, -1) === "/";
          return e = Aa(Hn(e.split("/"), function(s) {
            return !!s;
          }), !n).join("/"), !e && !n && (e = "."), e && t && (e += "/"), (n ? "/" : "") + e;
        }
        __name(Vn, "Vn");
        function Wn(e) {
          return e.charAt(0) === "/";
        }
        __name(Wn, "Wn");
        function Sa() {
          var e = Array.prototype.slice.call(arguments, 0);
          return Vn(Hn(e, function(n, t) {
            if (typeof n != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return n;
          }).join("/"));
        }
        __name(Sa, "Sa");
        function xa(e, n) {
          e = Nr(e).substr(1), n = Nr(n).substr(1);
          function t(c) {
            for (var y = 0; y < c.length && c[y] === ""; y++)
              ;
            for (var h = c.length - 1; h >= 0 && c[h] === ""; h--)
              ;
            return y > h ? [] : c.slice(y, h - y + 1);
          }
          __name(t, "t");
          for (var s = t(e.split("/")), a = t(n.split("/")), r = Math.min(s.length, a.length), u = r, i = 0; i < r; i++)
            if (s[i] !== a[i]) {
              u = i;
              break;
            }
          for (var l = [], i = u; i < s.length; i++)
            l.push("..");
          return l = l.concat(a.slice(u)), l.join("/");
        }
        __name(xa, "xa");
        function ba(e) {
          var n = Pr(e), t = n[0], s = n[1];
          return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
        }
        __name(ba, "ba");
        function Ta(e, n) {
          var t = Pr(e)[2];
          return n && t.substr(-1 * n.length) === n && (t = t.substr(0, t.length - n.length)), t;
        }
        __name(Ta, "Ta");
        function Ba(e) {
          return Pr(e)[3];
        }
        __name(Ba, "Ba");
        function Hn(e, n) {
          if (e.filter)
            return e.filter(n);
          for (var t = [], s = 0; s < e.length; s++)
            n(e[s], s, e) && t.push(e[s]);
          return t;
        }
        __name(Hn, "Hn");
        var oa, Pr, Nn, wn, Na, wa, bD = gt({ "node-modules-polyfills:path"() {
          re(), oa = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Pr = /* @__PURE__ */ __name(function(e) {
            return oa.exec(e).slice(1);
          }, "Pr"), Nn = "/", wn = ":", Na = { extname: Ba, basename: Ta, dirname: ba, sep: Nn, delimiter: wn, relative: xa, join: Sa, isAbsolute: Wn, normalize: Vn, resolve: Nr }, wa = "ab".substr(-1) === "b" ? function(e, n, t) {
            return e.substr(n, t);
          } : function(e, n, t) {
            return n < 0 && (n = e.length + n), e.substr(n, t);
          };
        } }), TD = ee({ "node-modules-polyfills-commonjs:path"(e, n) {
          re();
          var t = (bD(), ft(Fa));
          if (t && t.default) {
            n.exports = t.default;
            for (let s in t)
              n.exports[s] = t[s];
          } else
            t && (n.exports = t);
        } }), Kt = ee({ "src/common/errors.js"(e, n) {
          "use strict";
          re();
          var t = /* @__PURE__ */ __name(class extends Error {
          }, "t"), s = /* @__PURE__ */ __name(class extends Error {
          }, "s"), a = /* @__PURE__ */ __name(class extends Error {
          }, "a"), r = /* @__PURE__ */ __name(class extends Error {
          }, "r");
          n.exports = { ConfigError: t, DebugError: s, UndefinedParserError: a, ArgExpansionBailout: r };
        } }), yt = {};
        zt(yt, { __assign: () => Br, __asyncDelegator: () => RD, __asyncGenerator: () => MD, __asyncValues: () => $D, __await: () => Jt, __awaiter: () => ID, __classPrivateFieldGet: () => GD, __classPrivateFieldSet: () => UD, __createBinding: () => LD, __decorate: () => wD, __exportStar: () => jD, __extends: () => BD, __generator: () => kD, __importDefault: () => HD, __importStar: () => WD, __makeTemplateObject: () => VD, __metadata: () => PD, __param: () => _D, __read: () => _a, __rest: () => ND, __spread: () => OD, __spreadArrays: () => qD, __values: () => _n });
        function BD(e, n) {
          Tr(e, n);
          function t() {
            this.constructor = e;
          }
          __name(t, "t");
          e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());
        }
        __name(BD, "BD");
        function ND(e, n) {
          var t = {};
          for (var s in e)
            Object.prototype.hasOwnProperty.call(e, s) && n.indexOf(s) < 0 && (t[s] = e[s]);
          if (e != null && typeof Object.getOwnPropertySymbols == "function")
            for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++)
              n.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t[s[a]] = e[s[a]]);
          return t;
        }
        __name(ND, "ND");
        function wD(e, n, t, s) {
          var a = arguments.length, r = a < 3 ? n : s === null ? s = Object.getOwnPropertyDescriptor(n, t) : s, u;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            r = Reflect.decorate(e, n, t, s);
          else
            for (var i = e.length - 1; i >= 0; i--)
              (u = e[i]) && (r = (a < 3 ? u(r) : a > 3 ? u(n, t, r) : u(n, t)) || r);
          return a > 3 && r && Object.defineProperty(n, t, r), r;
        }
        __name(wD, "wD");
        function _D(e, n) {
          return function(t, s) {
            n(t, s, e);
          };
        }
        __name(_D, "_D");
        function PD(e, n) {
          if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
            return Reflect.metadata(e, n);
        }
        __name(PD, "PD");
        function ID(e, n, t, s) {
          function a(r) {
            return r instanceof t ? r : new t(function(u) {
              u(r);
            });
          }
          __name(a, "a");
          return new (t || (t = Promise))(function(r, u) {
            function i(y) {
              try {
                c(s.next(y));
              } catch (h) {
                u(h);
              }
            }
            __name(i, "i");
            function l(y) {
              try {
                c(s.throw(y));
              } catch (h) {
                u(h);
              }
            }
            __name(l, "l");
            function c(y) {
              y.done ? r(y.value) : a(y.value).then(i, l);
            }
            __name(c, "c");
            c((s = s.apply(e, n || [])).next());
          });
        }
        __name(ID, "ID");
        function kD(e, n) {
          var t = { label: 0, sent: function() {
            if (r[0] & 1)
              throw r[1];
            return r[1];
          }, trys: [], ops: [] }, s, a, r, u;
          return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
            return this;
          }), u;
          function i(c) {
            return function(y) {
              return l([c, y]);
            };
          }
          __name(i, "i");
          function l(c) {
            if (s)
              throw new TypeError("Generator is already executing.");
            for (; t; )
              try {
                if (s = 1, a && (r = c[0] & 2 ? a.return : c[0] ? a.throw || ((r = a.return) && r.call(a), 0) : a.next) && !(r = r.call(a, c[1])).done)
                  return r;
                switch (a = 0, r && (c = [c[0] & 2, r.value]), c[0]) {
                  case 0:
                  case 1:
                    r = c;
                    break;
                  case 4:
                    return t.label++, { value: c[1], done: false };
                  case 5:
                    t.label++, a = c[1], c = [0];
                    continue;
                  case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                  default:
                    if (r = t.trys, !(r = r.length > 0 && r[r.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                      t = 0;
                      continue;
                    }
                    if (c[0] === 3 && (!r || c[1] > r[0] && c[1] < r[3])) {
                      t.label = c[1];
                      break;
                    }
                    if (c[0] === 6 && t.label < r[1]) {
                      t.label = r[1], r = c;
                      break;
                    }
                    if (r && t.label < r[2]) {
                      t.label = r[2], t.ops.push(c);
                      break;
                    }
                    r[2] && t.ops.pop(), t.trys.pop();
                    continue;
                }
                c = n.call(e, t);
              } catch (y) {
                c = [6, y], a = 0;
              } finally {
                s = r = 0;
              }
            if (c[0] & 5)
              throw c[1];
            return { value: c[0] ? c[1] : void 0, done: true };
          }
          __name(l, "l");
        }
        __name(kD, "kD");
        function LD(e, n, t, s) {
          s === void 0 && (s = t), e[s] = n[t];
        }
        __name(LD, "LD");
        function jD(e, n) {
          for (var t in e)
            t !== "default" && !n.hasOwnProperty(t) && (n[t] = e[t]);
        }
        __name(jD, "jD");
        function _n(e) {
          var n = typeof Symbol == "function" && Symbol.iterator, t = n && e[n], s = 0;
          if (t)
            return t.call(e);
          if (e && typeof e.length == "number")
            return { next: function() {
              return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e };
            } };
          throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        __name(_n, "_n");
        function _a(e, n) {
          var t = typeof Symbol == "function" && e[Symbol.iterator];
          if (!t)
            return e;
          var s = t.call(e), a, r = [], u;
          try {
            for (; (n === void 0 || n-- > 0) && !(a = s.next()).done; )
              r.push(a.value);
          } catch (i) {
            u = { error: i };
          } finally {
            try {
              a && !a.done && (t = s.return) && t.call(s);
            } finally {
              if (u)
                throw u.error;
            }
          }
          return r;
        }
        __name(_a, "_a");
        function OD() {
          for (var e = [], n = 0; n < arguments.length; n++)
            e = e.concat(_a(arguments[n]));
          return e;
        }
        __name(OD, "OD");
        function qD() {
          for (var e = 0, n = 0, t = arguments.length; n < t; n++)
            e += arguments[n].length;
          for (var s = Array(e), a = 0, n = 0; n < t; n++)
            for (var r = arguments[n], u = 0, i = r.length; u < i; u++, a++)
              s[a] = r[u];
          return s;
        }
        __name(qD, "qD");
        function Jt(e) {
          return this instanceof Jt ? (this.v = e, this) : new Jt(e);
        }
        __name(Jt, "Jt");
        function MD(e, n, t) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var s = t.apply(e, n || []), a, r = [];
          return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function() {
            return this;
          }, a;
          function u(g) {
            s[g] && (a[g] = function(p) {
              return new Promise(function(D, v) {
                r.push([g, p, D, v]) > 1 || i(g, p);
              });
            });
          }
          __name(u, "u");
          function i(g, p) {
            try {
              l(s[g](p));
            } catch (D) {
              h(r[0][3], D);
            }
          }
          __name(i, "i");
          function l(g) {
            g.value instanceof Jt ? Promise.resolve(g.value.v).then(c, y) : h(r[0][2], g);
          }
          __name(l, "l");
          function c(g) {
            i("next", g);
          }
          __name(c, "c");
          function y(g) {
            i("throw", g);
          }
          __name(y, "y");
          function h(g, p) {
            g(p), r.shift(), r.length && i(r[0][0], r[0][1]);
          }
          __name(h, "h");
        }
        __name(MD, "MD");
        function RD(e) {
          var n, t;
          return n = {}, s("next"), s("throw", function(a) {
            throw a;
          }), s("return"), n[Symbol.iterator] = function() {
            return this;
          }, n;
          function s(a, r) {
            n[a] = e[a] ? function(u) {
              return (t = !t) ? { value: Jt(e[a](u)), done: a === "return" } : r ? r(u) : u;
            } : r;
          }
          __name(s, "s");
        }
        __name(RD, "RD");
        function $D(e) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var n = e[Symbol.asyncIterator], t;
          return n ? n.call(e) : (e = typeof _n == "function" ? _n(e) : e[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
            return this;
          }, t);
          function s(r) {
            t[r] = e[r] && function(u) {
              return new Promise(function(i, l) {
                u = e[r](u), a(i, l, u.done, u.value);
              });
            };
          }
          __name(s, "s");
          function a(r, u, i, l) {
            Promise.resolve(l).then(function(c) {
              r({ value: c, done: i });
            }, u);
          }
          __name(a, "a");
        }
        __name($D, "$D");
        function VD(e, n) {
          return Object.defineProperty ? Object.defineProperty(e, "raw", { value: n }) : e.raw = n, e;
        }
        __name(VD, "VD");
        function WD(e) {
          if (e && e.__esModule)
            return e;
          var n = {};
          if (e != null)
            for (var t in e)
              Object.hasOwnProperty.call(e, t) && (n[t] = e[t]);
          return n.default = e, n;
        }
        __name(WD, "WD");
        function HD(e) {
          return e && e.__esModule ? e : { default: e };
        }
        __name(HD, "HD");
        function GD(e, n) {
          if (!n.has(e))
            throw new TypeError("attempted to get private field on non-instance");
          return n.get(e);
        }
        __name(GD, "GD");
        function UD(e, n, t) {
          if (!n.has(e))
            throw new TypeError("attempted to set private field on non-instance");
          return n.set(e, t), t;
        }
        __name(UD, "UD");
        var Tr, Br, Ct = gt({ "node_modules/tslib/tslib.es6.js"() {
          re(), Tr = /* @__PURE__ */ __name(function(e, n) {
            return Tr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
              t.__proto__ = s;
            } || function(t, s) {
              for (var a in s)
                s.hasOwnProperty(a) && (t[a] = s[a]);
            }, Tr(e, n);
          }, "Tr"), Br = /* @__PURE__ */ __name(function() {
            return Br = Object.assign || function(n) {
              for (var t, s = 1, a = arguments.length; s < a; s++) {
                t = arguments[s];
                for (var r in t)
                  Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
              }
              return n;
            }, Br.apply(this, arguments);
          }, "Br");
        } }), Pa = ee({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (n) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n) ? n : JSON.stringify(n), value(n) {
            if (n === null || typeof n != "object")
              return JSON.stringify(n);
            if (Array.isArray(n))
              return `[${n.map((s) => e.apiDescriptor.value(s)).join(", ")}]`;
            let t = Object.keys(n);
            return t.length === 0 ? "{}" : `{ ${t.map((s) => `${e.apiDescriptor.key(s)}: ${e.apiDescriptor.value(n[s])}`).join(", ")} }`;
          }, pair: (n) => {
            let { key: t, value: s } = n;
            return e.apiDescriptor.value({ [t]: s });
          } };
        } }), JD = ee({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (Ct(), ft(yt));
          n.__exportStar(Pa(), e);
        } }), Ir = ee({ "scripts/build/shims/chalk.cjs"(e, n) {
          "use strict";
          re();
          var t = /* @__PURE__ */ __name((s) => s, "t");
          t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, n.exports = t;
        } }), Ia = ee({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Ir();
          e.commonDeprecatedHandler = (t, s, a) => {
            let { descriptor: r } = a, u = [`${n.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t))} is deprecated`];
            return s && u.push(`we now treat it as ${n.default.blue(typeof s == "string" ? r.key(s) : r.pair(s))}`), u.join("; ") + ".";
          };
        } }), zD = ee({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (Ct(), ft(yt));
          n.__exportStar(Ia(), e);
        } }), XD = ee({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Ir();
          e.commonInvalidHandler = (t, s, a) => [`Invalid ${n.default.red(a.descriptor.key(t))} value.`, `Expected ${n.default.blue(a.schemas[t].expected(a))},`, `but received ${n.default.red(a.descriptor.value(s))}.`].join(" ");
        } }), ka = ee({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (Ct(), ft(yt));
          n.__exportStar(XD(), e);
        } }), KD = ee({ "node_modules/vnopts/node_modules/leven/index.js"(e, n) {
          "use strict";
          re();
          var t = [], s = [];
          n.exports = function(a, r) {
            if (a === r)
              return 0;
            var u = a;
            a.length > r.length && (a = r, r = u);
            var i = a.length, l = r.length;
            if (i === 0)
              return l;
            if (l === 0)
              return i;
            for (; i > 0 && a.charCodeAt(~-i) === r.charCodeAt(~-l); )
              i--, l--;
            if (i === 0)
              return l;
            for (var c = 0; c < i && a.charCodeAt(c) === r.charCodeAt(c); )
              c++;
            if (i -= c, l -= c, i === 0)
              return l;
            for (var y, h, g, p, D = 0, v = 0; D < i; )
              s[c + D] = a.charCodeAt(c + D), t[D] = ++D;
            for (; v < l; )
              for (y = r.charCodeAt(c + v), g = v++, h = v, D = 0; D < i; D++)
                p = y === s[c + D] ? g : g + 1, g = t[D], h = t[D] = g > h ? p > h ? h + 1 : p : p > g ? g + 1 : p;
            return h;
          };
        } }), La = ee({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Ir(), t = KD();
          e.levenUnknownHandler = (s, a, r) => {
            let { descriptor: u, logger: i, schemas: l } = r, c = [`Ignored unknown option ${n.default.yellow(u.pair({ key: s, value: a }))}.`], y = Object.keys(l).sort().find((h) => t(s, h) < 3);
            y && c.push(`Did you mean ${n.default.blue(u.key(y))}?`), i.warn(c.join(" "));
          };
        } }), YD = ee({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (Ct(), ft(yt));
          n.__exportStar(La(), e);
        } }), QD = ee({ "node_modules/vnopts/lib/handlers/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (Ct(), ft(yt));
          n.__exportStar(zD(), e), n.__exportStar(ka(), e), n.__exportStar(YD(), e);
        } }), Et = ee({ "node_modules/vnopts/lib/schema.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
          function t(r, u) {
            let i = new r(u), l = Object.create(i);
            for (let c of n)
              c in u && (l[c] = a(u[c], i, s.prototype[c].length));
            return l;
          }
          __name(t, "t");
          e.createSchema = t;
          var s = /* @__PURE__ */ __name(class {
            constructor(r) {
              this.name = r.name;
            }
            static create(r) {
              return t(this, r);
            }
            default(r) {
            }
            expected(r) {
              return "nothing";
            }
            validate(r, u) {
              return false;
            }
            deprecated(r, u) {
              return false;
            }
            forward(r, u) {
            }
            redirect(r, u) {
            }
            overlap(r, u, i) {
              return r;
            }
            preprocess(r, u) {
              return r;
            }
            postprocess(r, u) {
              return r;
            }
          }, "s");
          e.Schema = s;
          function a(r, u, i) {
            return typeof r == "function" ? function() {
              for (var l = arguments.length, c = new Array(l), y = 0; y < l; y++)
                c[y] = arguments[y];
              return r(...c.slice(0, i - 1), u, ...c.slice(i - 1));
            } : () => r;
          }
          __name(a, "a");
        } }), ZD = ee({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Et(), t = /* @__PURE__ */ __name(class extends n.Schema {
            constructor(s) {
              super(s), this._sourceName = s.sourceName;
            }
            expected(s) {
              return s.schemas[this._sourceName].expected(s);
            }
            validate(s, a) {
              return a.schemas[this._sourceName].validate(s, a);
            }
            redirect(s, a) {
              return this._sourceName;
            }
          }, "t");
          e.AliasSchema = t;
        } }), em = ee({ "node_modules/vnopts/lib/schemas/any.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Et(), t = /* @__PURE__ */ __name(class extends n.Schema {
            expected() {
              return "anything";
            }
            validate() {
              return true;
            }
          }, "t");
          e.AnySchema = t;
        } }), tm = ee({ "node_modules/vnopts/lib/schemas/array.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (Ct(), ft(yt)), t = Et(), s = /* @__PURE__ */ __name(class extends t.Schema {
            constructor(r) {
              var { valueSchema: u, name: i = u.name } = r, l = n.__rest(r, ["valueSchema", "name"]);
              super(Object.assign({}, l, { name: i })), this._valueSchema = u;
            }
            expected(r) {
              return `an array of ${this._valueSchema.expected(r)}`;
            }
            validate(r, u) {
              if (!Array.isArray(r))
                return false;
              let i = [];
              for (let l of r) {
                let c = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);
                c !== true && i.push(c.value);
              }
              return i.length === 0 ? true : { value: i };
            }
            deprecated(r, u) {
              let i = [];
              for (let l of r) {
                let c = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);
                c !== false && i.push(...c.map((y) => {
                  let { value: h } = y;
                  return { value: [h] };
                }));
              }
              return i;
            }
            forward(r, u) {
              let i = [];
              for (let l of r) {
                let c = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);
                i.push(...c.map(a));
              }
              return i;
            }
            redirect(r, u) {
              let i = [], l = [];
              for (let c of r) {
                let y = u.normalizeRedirectResult(this._valueSchema.redirect(c, u), c);
                "remain" in y && i.push(y.remain), l.push(...y.redirect.map(a));
              }
              return i.length === 0 ? { redirect: l } : { redirect: l, remain: i };
            }
            overlap(r, u) {
              return r.concat(u);
            }
          }, "s");
          e.ArraySchema = s;
          function a(r) {
            let { from: u, to: i } = r;
            return { from: [u], to: i };
          }
          __name(a, "a");
        } }), rm = ee({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Et(), t = /* @__PURE__ */ __name(class extends n.Schema {
            expected() {
              return "true or false";
            }
            validate(s) {
              return typeof s == "boolean";
            }
          }, "t");
          e.BooleanSchema = t;
        } }), Gn = ee({ "node_modules/vnopts/lib/utils.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          function n(p, D) {
            let v = /* @__PURE__ */ Object.create(null);
            for (let w of p) {
              let T = w[D];
              if (v[T])
                throw new Error(`Duplicate ${D} ${JSON.stringify(T)}`);
              v[T] = w;
            }
            return v;
          }
          __name(n, "n");
          e.recordFromArray = n;
          function t(p, D) {
            let v = /* @__PURE__ */ new Map();
            for (let w of p) {
              let T = w[D];
              if (v.has(T))
                throw new Error(`Duplicate ${D} ${JSON.stringify(T)}`);
              v.set(T, w);
            }
            return v;
          }
          __name(t, "t");
          e.mapFromArray = t;
          function s() {
            let p = /* @__PURE__ */ Object.create(null);
            return (D) => {
              let v = JSON.stringify(D);
              return p[v] ? true : (p[v] = true, false);
            };
          }
          __name(s, "s");
          e.createAutoChecklist = s;
          function a(p, D) {
            let v = [], w = [];
            for (let T of p)
              D(T) ? v.push(T) : w.push(T);
            return [v, w];
          }
          __name(a, "a");
          e.partition = a;
          function r(p) {
            return p === Math.floor(p);
          }
          __name(r, "r");
          e.isInt = r;
          function u(p, D) {
            if (p === D)
              return 0;
            let v = typeof p, w = typeof D, T = ["undefined", "object", "boolean", "number", "string"];
            return v !== w ? T.indexOf(v) - T.indexOf(w) : v !== "string" ? Number(p) - Number(D) : p.localeCompare(D);
          }
          __name(u, "u");
          e.comparePrimitive = u;
          function i(p) {
            return p === void 0 ? {} : p;
          }
          __name(i, "i");
          e.normalizeDefaultResult = i;
          function l(p, D) {
            return p === true ? true : p === false ? { value: D } : p;
          }
          __name(l, "l");
          e.normalizeValidateResult = l;
          function c(p, D) {
            let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            return p === false ? false : p === true ? v ? true : [{ value: D }] : "value" in p ? [p] : p.length === 0 ? false : p;
          }
          __name(c, "c");
          e.normalizeDeprecatedResult = c;
          function y(p, D) {
            return typeof p == "string" || "key" in p ? { from: D, to: p } : "from" in p ? { from: p.from, to: p.to } : { from: D, to: p.to };
          }
          __name(y, "y");
          e.normalizeTransferResult = y;
          function h(p, D) {
            return p === void 0 ? [] : Array.isArray(p) ? p.map((v) => y(v, D)) : [y(p, D)];
          }
          __name(h, "h");
          e.normalizeForwardResult = h;
          function g(p, D) {
            let v = h(typeof p == "object" && "redirect" in p ? p.redirect : p, D);
            return v.length === 0 ? { remain: D, redirect: v } : typeof p == "object" && "remain" in p ? { remain: p.remain, redirect: v } : { redirect: v };
          }
          __name(g, "g");
          e.normalizeRedirectResult = g;
        } }), nm = ee({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Et(), t = Gn(), s = /* @__PURE__ */ __name(class extends n.Schema {
            constructor(a) {
              super(a), this._choices = t.mapFromArray(a.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
            }
            expected(a) {
              let { descriptor: r } = a, u = Array.from(this._choices.keys()).map((c) => this._choices.get(c)).filter((c) => !c.deprecated).map((c) => c.value).sort(t.comparePrimitive).map(r.value), i = u.slice(0, -2), l = u.slice(-2);
              return i.concat(l.join(" or ")).join(", ");
            }
            validate(a) {
              return this._choices.has(a);
            }
            deprecated(a) {
              let r = this._choices.get(a);
              return r && r.deprecated ? { value: a } : false;
            }
            forward(a) {
              let r = this._choices.get(a);
              return r ? r.forward : void 0;
            }
            redirect(a) {
              let r = this._choices.get(a);
              return r ? r.redirect : void 0;
            }
          }, "s");
          e.ChoiceSchema = s;
        } }), ja = ee({ "node_modules/vnopts/lib/schemas/number.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Et(), t = /* @__PURE__ */ __name(class extends n.Schema {
            expected() {
              return "a number";
            }
            validate(s, a) {
              return typeof s == "number";
            }
          }, "t");
          e.NumberSchema = t;
        } }), um = ee({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Gn(), t = ja(), s = /* @__PURE__ */ __name(class extends t.NumberSchema {
            expected() {
              return "an integer";
            }
            validate(a, r) {
              return r.normalizeValidateResult(super.validate(a, r), a) === true && n.isInt(a);
            }
          }, "s");
          e.IntegerSchema = s;
        } }), sm = ee({ "node_modules/vnopts/lib/schemas/string.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Et(), t = /* @__PURE__ */ __name(class extends n.Schema {
            expected() {
              return "a string";
            }
            validate(s) {
              return typeof s == "string";
            }
          }, "t");
          e.StringSchema = t;
        } }), im = ee({ "node_modules/vnopts/lib/schemas/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (Ct(), ft(yt));
          n.__exportStar(ZD(), e), n.__exportStar(em(), e), n.__exportStar(tm(), e), n.__exportStar(rm(), e), n.__exportStar(nm(), e), n.__exportStar(um(), e), n.__exportStar(ja(), e), n.__exportStar(sm(), e);
        } }), am = ee({ "node_modules/vnopts/lib/defaults.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Pa(), t = Ia(), s = ka(), a = La();
          e.defaultDescriptor = n.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
        } }), om = ee({ "node_modules/vnopts/lib/normalize.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = am(), t = Gn();
          e.normalize = (a, r, u) => new s(r, u).normalize(a);
          var s = /* @__PURE__ */ __name(class {
            constructor(a, r) {
              let { logger: u = console, descriptor: i = n.defaultDescriptor, unknown: l = n.defaultUnknownHandler, invalid: c = n.defaultInvalidHandler, deprecated: y = n.defaultDeprecatedHandler } = r || {};
              this._utils = { descriptor: i, logger: u || { warn: () => {
              } }, schemas: t.recordFromArray(a, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = l, this._invalidHandler = c, this._deprecatedHandler = y, this.cleanHistory();
            }
            cleanHistory() {
              this._hasDeprecationWarned = t.createAutoChecklist();
            }
            normalize(a) {
              let r = {}, u = [a], i = /* @__PURE__ */ __name(() => {
                for (; u.length !== 0; ) {
                  let l = u.shift(), c = this._applyNormalization(l, r);
                  u.push(...c);
                }
              }, "i");
              i();
              for (let l of Object.keys(this._utils.schemas)) {
                let c = this._utils.schemas[l];
                if (!(l in r)) {
                  let y = t.normalizeDefaultResult(c.default(this._utils));
                  "value" in y && u.push({ [l]: y.value });
                }
              }
              i();
              for (let l of Object.keys(this._utils.schemas)) {
                let c = this._utils.schemas[l];
                l in r && (r[l] = c.postprocess(r[l], this._utils));
              }
              return r;
            }
            _applyNormalization(a, r) {
              let u = [], [i, l] = t.partition(Object.keys(a), (c) => c in this._utils.schemas);
              for (let c of i) {
                let y = this._utils.schemas[c], h = y.preprocess(a[c], this._utils), g = t.normalizeValidateResult(y.validate(h, this._utils), h);
                if (g !== true) {
                  let { value: T } = g, F = this._invalidHandler(c, T, this._utils);
                  throw typeof F == "string" ? new Error(F) : F;
                }
                let p = /* @__PURE__ */ __name((T) => {
                  let { from: F, to: A } = T;
                  u.push(typeof A == "string" ? { [A]: F } : { [A.key]: A.value });
                }, "p"), D = /* @__PURE__ */ __name((T) => {
                  let { value: F, redirectTo: A } = T, B = t.normalizeDeprecatedResult(y.deprecated(F, this._utils), h, true);
                  if (B !== false)
                    if (B === true)
                      this._hasDeprecationWarned(c) || this._utils.logger.warn(this._deprecatedHandler(c, A, this._utils));
                    else
                      for (let { value: I } of B) {
                        let P = { key: c, value: I };
                        if (!this._hasDeprecationWarned(P)) {
                          let $ = typeof A == "string" ? { key: A, value: I } : A;
                          this._utils.logger.warn(this._deprecatedHandler(P, $, this._utils));
                        }
                      }
                }, "D");
                t.normalizeForwardResult(y.forward(h, this._utils), h).forEach(p);
                let w = t.normalizeRedirectResult(y.redirect(h, this._utils), h);
                if (w.redirect.forEach(p), "remain" in w) {
                  let T = w.remain;
                  r[c] = c in r ? y.overlap(r[c], T, this._utils) : T, D({ value: T });
                }
                for (let { from: T, to: F } of w.redirect)
                  D({ value: T, redirectTo: F });
              }
              for (let c of l) {
                let y = a[c], h = this._unknownHandler(c, y, this._utils);
                if (h)
                  for (let g of Object.keys(h)) {
                    let p = { [g]: h[g] };
                    g in this._utils.schemas ? u.push(p) : Object.assign(r, p);
                  }
              }
              return u;
            }
          }, "s");
          e.Normalizer = s;
        } }), lm = ee({ "node_modules/vnopts/lib/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (Ct(), ft(yt));
          n.__exportStar(JD(), e), n.__exportStar(QD(), e), n.__exportStar(im(), e), n.__exportStar(om(), e), n.__exportStar(Et(), e);
        } }), cm = ee({ "src/main/options-normalizer.js"(e, n) {
          "use strict";
          re();
          var t = lm(), s = lt(), a = { key: (g) => g.length === 1 ? `-${g}` : `--${g}`, value: (g) => t.apiDescriptor.value(g), pair: (g) => {
            let { key: p, value: D } = g;
            return D === false ? `--no-${p}` : D === true ? a.key(p) : D === "" ? `${a.key(p)} without an argument` : `${a.key(p)}=${D}`;
          } }, r = /* @__PURE__ */ __name((g) => {
            let { colorsModule: p, levenshteinDistance: D } = g;
            return class extends t.ChoiceSchema {
              constructor(w) {
                let { name: T, flags: F } = w;
                super({ name: T, choices: F }), this._flags = [...F].sort();
              }
              preprocess(w, T) {
                if (typeof w == "string" && w.length > 0 && !this._flags.includes(w)) {
                  let F = this._flags.find((A) => D(A, w) < 3);
                  if (F)
                    return T.logger.warn([`Unknown flag ${p.yellow(T.descriptor.value(w))},`, `did you mean ${p.blue(T.descriptor.value(F))}?`].join(" ")), F;
                }
                return w;
              }
              expected() {
                return "a flag";
              }
            };
          }, "r"), u;
          function i(g, p) {
            let { logger: D = false, isCLI: v = false, passThrough: w = false, colorsModule: T = null, levenshteinDistance: F = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, A = w ? Array.isArray(w) ? (x, m) => w.includes(x) ? { [x]: m } : void 0 : (x, m) => ({ [x]: m }) : (x, m, E) => {
              let o = E.schemas, { _: d } = o, C = Ln(o, Jf);
              return t.levenUnknownHandler(x, m, Object.assign(Object.assign({}, E), {}, { schemas: C }));
            }, B = v ? a : t.apiDescriptor, I = l(p, { isCLI: v, colorsModule: T, levenshteinDistance: F }), P = new t.Normalizer(I, { logger: D, unknown: A, descriptor: B }), $ = D !== false;
            $ && u && (P._hasDeprecationWarned = u);
            let f = P.normalize(g);
            return $ && (u = P._hasDeprecationWarned), v && f["plugin-search"] === false && (f["plugin-search-dir"] = false), f;
          }
          __name(i, "i");
          function l(g, p) {
            let { isCLI: D, colorsModule: v, levenshteinDistance: w } = p, T = [];
            D && T.push(t.AnySchema.create({ name: "_" }));
            for (let F of g)
              T.push(c(F, { isCLI: D, optionInfos: g, colorsModule: v, levenshteinDistance: w })), F.alias && D && T.push(t.AliasSchema.create({ name: F.alias, sourceName: F.name }));
            return T;
          }
          __name(l, "l");
          function c(g, p) {
            let { isCLI: D, optionInfos: v, colorsModule: w, levenshteinDistance: T } = p, { name: F } = g;
            if (F === "plugin-search-dir" || F === "pluginSearchDirs")
              return t.AnySchema.create({ name: F, preprocess(P) {
                return P === false || (P = Array.isArray(P) ? P : [P]), P;
              }, validate(P) {
                return P === false ? true : P.every(($) => typeof $ == "string");
              }, expected() {
                return "false or paths to plugin search dir";
              } });
            let A = { name: F }, B, I = {};
            switch (g.type) {
              case "int":
                B = t.IntegerSchema, D && (A.preprocess = Number);
                break;
              case "string":
                B = t.StringSchema;
                break;
              case "choice":
                B = t.ChoiceSchema, A.choices = g.choices.map((P) => typeof P == "object" && P.redirect ? Object.assign(Object.assign({}, P), {}, { redirect: { to: { key: g.name, value: P.redirect } } }) : P);
                break;
              case "boolean":
                B = t.BooleanSchema;
                break;
              case "flag":
                B = r({ colorsModule: w, levenshteinDistance: T }), A.flags = v.flatMap((P) => [P.alias, P.description && P.name, P.oppositeDescription && `no-${P.name}`].filter(Boolean));
                break;
              case "path":
                B = t.StringSchema;
                break;
              default:
                throw new Error(`Unexpected type ${g.type}`);
            }
            if (g.exception ? A.validate = (P, $, f) => g.exception(P) || $.validate(P, f) : A.validate = (P, $, f) => P === void 0 || $.validate(P, f), g.redirect && (I.redirect = (P) => P ? { to: { key: g.redirect.option, value: g.redirect.value } } : void 0), g.deprecated && (I.deprecated = true), D && !g.array) {
              let P = A.preprocess || (($) => $);
              A.preprocess = ($, f, x) => f.preprocess(P(Array.isArray($) ? s($) : $), x);
            }
            return g.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, D ? { preprocess: (P) => Array.isArray(P) ? P : [P] } : {}), I), {}, { valueSchema: B.create(A) })) : B.create(Object.assign(Object.assign({}, A), I));
          }
          __name(c, "c");
          function y(g, p, D) {
            return i(g, p, D);
          }
          __name(y, "y");
          function h(g, p, D) {
            return i(g, p, Object.assign({ isCLI: true }, D));
          }
          __name(h, "h");
          n.exports = { normalizeApiOptions: y, normalizeCliOptions: h };
        } }), it = ee({ "src/language-js/loc.js"(e, n) {
          "use strict";
          re();
          var t = $n();
          function s(l) {
            var c, y;
            let h = l.range ? l.range[0] : l.start, g = (c = (y = l.declaration) === null || y === void 0 ? void 0 : y.decorators) !== null && c !== void 0 ? c : l.decorators;
            return t(g) ? Math.min(s(g[0]), h) : h;
          }
          __name(s, "s");
          function a(l) {
            return l.range ? l.range[1] : l.end;
          }
          __name(a, "a");
          function r(l, c) {
            let y = s(l);
            return Number.isInteger(y) && y === s(c);
          }
          __name(r, "r");
          function u(l, c) {
            let y = a(l);
            return Number.isInteger(y) && y === a(c);
          }
          __name(u, "u");
          function i(l, c) {
            return r(l, c) && u(l, c);
          }
          __name(i, "i");
          n.exports = { locStart: s, locEnd: a, hasSameLocStart: r, hasSameLoc: i };
        } }), pm = ee({ "src/main/load-parser.js"(e, n) {
          re(), n.exports = () => {
          };
        } }), fm = ee({ "scripts/build/shims/babel-highlight.cjs"(e, n) {
          "use strict";
          re();
          var t = Ir(), s = { shouldHighlight: () => false, getChalk: () => t };
          n.exports = s;
        } }), Dm = ee({ "node_modules/@babel/code-frame/lib/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i;
          var n = fm(), t = false;
          function s(l) {
            return { gutter: l.grey, marker: l.red.bold, message: l.red.bold };
          }
          __name(s, "s");
          var a = /\r\n|[\n\r\u2028\u2029]/;
          function r(l, c, y) {
            let h = Object.assign({ column: 0, line: -1 }, l.start), g = Object.assign({}, h, l.end), { linesAbove: p = 2, linesBelow: D = 3 } = y || {}, v = h.line, w = h.column, T = g.line, F = g.column, A = Math.max(v - (p + 1), 0), B = Math.min(c.length, T + D);
            v === -1 && (A = 0), T === -1 && (B = c.length);
            let I = T - v, P = {};
            if (I)
              for (let $ = 0; $ <= I; $++) {
                let f = $ + v;
                if (!w)
                  P[f] = true;
                else if ($ === 0) {
                  let x = c[f - 1].length;
                  P[f] = [w, x - w + 1];
                } else if ($ === I)
                  P[f] = [0, F];
                else {
                  let x = c[f - $].length;
                  P[f] = [0, x];
                }
              }
            else
              w === F ? w ? P[v] = [w, 0] : P[v] = true : P[v] = [w, F - w];
            return { start: A, end: B, markerLines: P };
          }
          __name(r, "r");
          function u(l, c) {
            let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, h = (y.highlightCode || y.forceColor) && (0, n.shouldHighlight)(y), g = (0, n.getChalk)(y), p = s(g), D = /* @__PURE__ */ __name(($, f) => h ? $(f) : f, "D"), v = l.split(a), { start: w, end: T, markerLines: F } = r(c, v, y), A = c.start && typeof c.start.column == "number", B = String(T).length, P = (h ? (0, n.default)(l, y) : l).split(a, T).slice(w, T).map(($, f) => {
              let x = w + 1 + f, E = ` ${` ${x}`.slice(-B)} |`, o = F[x], d = !F[x + 1];
              if (o) {
                let C = "";
                if (Array.isArray(o)) {
                  let _ = $.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), b = o[1] || 1;
                  C = [`
 `, D(p.gutter, E.replace(/\d/g, " ")), " ", _, D(p.marker, "^").repeat(b)].join(""), d && y.message && (C += " " + D(p.message, y.message));
                }
                return [D(p.marker, ">"), D(p.gutter, E), $.length > 0 ? ` ${$}` : "", C].join("");
              } else
                return ` ${D(p.gutter, E)}${$.length > 0 ? ` ${$}` : ""}`;
            }).join(`
`);
            return y.message && !A && (P = `${" ".repeat(B + 1)}${y.message}
${P}`), h ? g.reset(P) : P;
          }
          __name(u, "u");
          function i(l, c, y) {
            let h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            if (!t) {
              t = true;
              let p = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
              if (Nt.emitWarning)
                Nt.emitWarning(p, "DeprecationWarning");
              else {
                let D = new Error(p);
                D.name = "DeprecationWarning", console.warn(new Error(p));
              }
            }
            return y = Math.max(y, 0), u(l, { start: { column: y, line: c } }, h);
          }
          __name(i, "i");
        } }), Un = ee({ "src/main/parser.js"(e, n) {
          "use strict";
          re();
          var { ConfigError: t } = Kt(), s = it(), a = pm(), { locStart: r, locEnd: u } = s, i = Object.getOwnPropertyNames, l = Object.getOwnPropertyDescriptor;
          function c(g) {
            let p = {};
            for (let D of g.plugins)
              if (!!D.parsers)
                for (let v of i(D.parsers))
                  Object.defineProperty(p, v, l(D.parsers, v));
            return p;
          }
          __name(c, "c");
          function y(g) {
            let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c(g);
            if (typeof g.parser == "function")
              return { parse: g.parser, astFormat: "estree", locStart: r, locEnd: u };
            if (typeof g.parser == "string") {
              if (Object.prototype.hasOwnProperty.call(p, g.parser))
                return p[g.parser];
              throw new t(`Couldn't resolve parser "${g.parser}". Parsers must be explicitly added to the standalone bundle.`);
            }
          }
          __name(y, "y");
          function h(g, p) {
            let D = c(p), v = Object.defineProperties({}, Object.fromEntries(Object.keys(D).map((T) => [T, { enumerable: true, get() {
              return D[T].parse;
            } }]))), w = y(p, D);
            try {
              return w.preprocess && (g = w.preprocess(g, p)), { text: g, ast: w.parse(g, v, p) };
            } catch (T) {
              let { loc: F } = T;
              if (F) {
                let { codeFrameColumns: A } = Dm();
                throw T.codeFrame = A(g, F, { highlightCode: true }), T.message += `
` + T.codeFrame, T;
              }
              throw T;
            }
          }
          __name(h, "h");
          n.exports = { parse: h, resolveParser: y };
        } }), Oa = ee({ "src/main/options.js"(e, n) {
          "use strict";
          re();
          var t = TD(), { UndefinedParserError: s } = Kt(), { getSupportInfo: a } = Rn(), r = cm(), { resolveParser: u } = Un(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
          function l(h) {
            let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = Object.assign({}, h), D = a({ plugins: h.plugins, showUnreleased: true, showDeprecated: true }).options, v = Object.assign(Object.assign({}, i), Object.fromEntries(D.filter((B) => B.default !== void 0).map((B) => [B.name, B.default])));
            if (!p.parser) {
              if (!p.filepath)
                (g.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), p.parser = "babel";
              else if (p.parser = y(p.filepath, p.plugins), !p.parser)
                throw new s(`No parser could be inferred for file: ${p.filepath}`);
            }
            let w = u(r.normalizeApiOptions(p, [D.find((B) => B.name === "parser")], { passThrough: true, logger: false }));
            p.astFormat = w.astFormat, p.locEnd = w.locEnd, p.locStart = w.locStart;
            let T = c(p);
            p.printer = T.printers[p.astFormat];
            let F = Object.fromEntries(D.filter((B) => B.pluginDefaults && B.pluginDefaults[T.name] !== void 0).map((B) => [B.name, B.pluginDefaults[T.name]])), A = Object.assign(Object.assign({}, v), F);
            for (let [B, I] of Object.entries(A))
              (p[B] === null || p[B] === void 0) && (p[B] = I);
            return p.parser === "json" && (p.trailingComma = "none"), r.normalizeApiOptions(p, D, Object.assign({ passThrough: Object.keys(i) }, g));
          }
          __name(l, "l");
          function c(h) {
            let { astFormat: g } = h;
            if (!g)
              throw new Error("getPlugin() requires astFormat to be set");
            let p = h.plugins.find((D) => D.printers && D.printers[g]);
            if (!p)
              throw new Error(`Couldn't find plugin for AST format "${g}"`);
            return p;
          }
          __name(c, "c");
          function y(h, g) {
            let p = t.basename(h).toLowerCase(), v = a({ plugins: g }).languages.filter((w) => w.since !== null).find((w) => w.extensions && w.extensions.some((T) => p.endsWith(T)) || w.filenames && w.filenames.some((T) => T.toLowerCase() === p));
            return v && v.parsers[0];
          }
          __name(y, "y");
          n.exports = { normalize: l, hiddenDefaults: i, inferParser: y };
        } }), mm = ee({ "src/main/massage-ast.js"(e, n) {
          "use strict";
          re();
          function t(s, a, r) {
            if (Array.isArray(s))
              return s.map((c) => t(c, a, r)).filter(Boolean);
            if (!s || typeof s != "object")
              return s;
            let u = a.printer.massageAstNode, i;
            u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
            let l = {};
            for (let [c, y] of Object.entries(s))
              !i.has(c) && typeof y != "function" && (l[c] = t(y, a, s));
            if (u) {
              let c = u(s, l, r);
              if (c === null)
                return;
              if (c)
                return c;
            }
            return l;
          }
          __name(t, "t");
          n.exports = t;
        } }), Yt = ee({ "scripts/build/shims/assert.cjs"(e, n) {
          "use strict";
          re();
          var t = /* @__PURE__ */ __name(() => {
          }, "t");
          t.ok = t, t.strictEqual = t, n.exports = t;
        } }), et = ee({ "src/main/comments.js"(e, n) {
          "use strict";
          re();
          var t = Yt(), { builders: { line: s, hardline: a, breakParent: r, indent: u, lineSuffix: i, join: l, cursor: c } } = qe(), { hasNewline: y, skipNewline: h, skipSpaces: g, isPreviousLineEmpty: p, addLeadingComment: D, addDanglingComment: v, addTrailingComment: w } = Ge(), T = /* @__PURE__ */ new WeakMap();
          function F(k, R, M) {
            if (!k)
              return;
            let { printer: q, locStart: J, locEnd: L } = R;
            if (M) {
              if (q.canAttachComment && q.canAttachComment(k)) {
                let V;
                for (V = M.length - 1; V >= 0 && !(J(M[V]) <= J(k) && L(M[V]) <= L(k)); --V)
                  ;
                M.splice(V + 1, 0, k);
                return;
              }
            } else if (T.has(k))
              return T.get(k);
            let Y = q.getCommentChildNodes && q.getCommentChildNodes(k, R) || typeof k == "object" && Object.entries(k).filter((V) => {
              let [O] = V;
              return O !== "enclosingNode" && O !== "precedingNode" && O !== "followingNode" && O !== "tokens" && O !== "comments" && O !== "parent";
            }).map((V) => {
              let [, O] = V;
              return O;
            });
            if (!!Y) {
              M || (M = [], T.set(k, M));
              for (let V of Y)
                F(V, R, M);
              return M;
            }
          }
          __name(F, "F");
          function A(k, R, M, q) {
            let { locStart: J, locEnd: L } = M, Y = J(R), V = L(R), O = F(k, M), K, se, Q = 0, le = O.length;
            for (; Q < le; ) {
              let W = Q + le >> 1, X = O[W], oe = J(X), ae = L(X);
              if (oe <= Y && V <= ae)
                return A(X, R, M, X);
              if (ae <= Y) {
                K = X, Q = W + 1;
                continue;
              }
              if (V <= oe) {
                se = X, le = W;
                continue;
              }
              throw new Error("Comment location overlaps with node location");
            }
            if (q && q.type === "TemplateLiteral") {
              let { quasis: W } = q, X = E(W, R, M);
              K && E(W, K, M) !== X && (K = null), se && E(W, se, M) !== X && (se = null);
            }
            return { enclosingNode: q, precedingNode: K, followingNode: se };
          }
          __name(A, "A");
          var B = /* @__PURE__ */ __name(() => false, "B");
          function I(k, R, M, q) {
            if (!Array.isArray(k))
              return;
            let J = [], { locStart: L, locEnd: Y, printer: { handleComments: V = {} } } = q, { avoidAstMutation: O, ownLine: K = B, endOfLine: se = B, remaining: Q = B } = V, le = k.map((W, X) => Object.assign(Object.assign({}, A(R, W, q)), {}, { comment: W, text: M, options: q, ast: R, isLastComment: k.length - 1 === X }));
            for (let [W, X] of le.entries()) {
              let { comment: oe, precedingNode: ae, enclosingNode: Ae, followingNode: z, text: H, options: Z, ast: ne, isLastComment: fe } = X;
              if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
                if (L(oe) - L(ne) <= 0) {
                  D(ne, oe);
                  continue;
                }
                if (Y(oe) - Y(ne) >= 0) {
                  w(ne, oe);
                  continue;
                }
              }
              let ge;
              if (O ? ge = [X] : (oe.enclosingNode = Ae, oe.precedingNode = ae, oe.followingNode = z, ge = [oe, H, Z, ne, fe]), $(H, Z, le, W))
                oe.placement = "ownLine", K(...ge) || (z ? D(z, oe) : ae ? w(ae, oe) : v(Ae || ne, oe));
              else if (f(H, Z, le, W))
                oe.placement = "endOfLine", se(...ge) || (ae ? w(ae, oe) : z ? D(z, oe) : v(Ae || ne, oe));
              else if (oe.placement = "remaining", !Q(...ge))
                if (ae && z) {
                  let Ce = J.length;
                  Ce > 0 && J[Ce - 1].followingNode !== z && x(J, H, Z), J.push(X);
                } else
                  ae ? w(ae, oe) : z ? D(z, oe) : v(Ae || ne, oe);
            }
            if (x(J, M, q), !O)
              for (let W of k)
                delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
          }
          __name(I, "I");
          var P = /* @__PURE__ */ __name((k) => !/[\S\n\u2028\u2029]/.test(k), "P");
          function $(k, R, M, q) {
            let { comment: J, precedingNode: L } = M[q], { locStart: Y, locEnd: V } = R, O = Y(J);
            if (L)
              for (let K = q - 1; K >= 0; K--) {
                let { comment: se, precedingNode: Q } = M[K];
                if (Q !== L || !P(k.slice(V(se), O)))
                  break;
                O = Y(se);
              }
            return y(k, O, { backwards: true });
          }
          __name($, "$");
          function f(k, R, M, q) {
            let { comment: J, followingNode: L } = M[q], { locStart: Y, locEnd: V } = R, O = V(J);
            if (L)
              for (let K = q + 1; K < M.length; K++) {
                let { comment: se, followingNode: Q } = M[K];
                if (Q !== L || !P(k.slice(O, Y(se))))
                  break;
                O = V(se);
              }
            return y(k, O);
          }
          __name(f, "f");
          function x(k, R, M) {
            let q = k.length;
            if (q === 0)
              return;
            let { precedingNode: J, followingNode: L, enclosingNode: Y } = k[0], V = M.printer.getGapRegex && M.printer.getGapRegex(Y) || /^[\s(]*$/, O = M.locStart(L), K;
            for (K = q; K > 0; --K) {
              let { comment: se, precedingNode: Q, followingNode: le } = k[K - 1];
              t.strictEqual(Q, J), t.strictEqual(le, L);
              let W = R.slice(M.locEnd(se), O);
              if (V.test(W))
                O = M.locStart(se);
              else
                break;
            }
            for (let [se, { comment: Q }] of k.entries())
              se < K ? w(J, Q) : D(L, Q);
            for (let se of [J, L])
              se.comments && se.comments.length > 1 && se.comments.sort((Q, le) => M.locStart(Q) - M.locStart(le));
            k.length = 0;
          }
          __name(x, "x");
          function m(k, R) {
            let M = k.getValue();
            return M.printed = true, R.printer.printComment(k, R);
          }
          __name(m, "m");
          function E(k, R, M) {
            let q = M.locStart(R) - 1;
            for (let J = 1; J < k.length; ++J)
              if (q < M.locStart(k[J]))
                return J - 1;
            return 0;
          }
          __name(E, "E");
          function o(k, R) {
            let M = k.getValue(), q = [m(k, R)], { printer: J, originalText: L, locStart: Y, locEnd: V } = R;
            if (J.isBlockComment && J.isBlockComment(M)) {
              let se = y(L, V(M)) ? y(L, Y(M), { backwards: true }) ? a : s : " ";
              q.push(se);
            } else
              q.push(a);
            let K = h(L, g(L, V(M)));
            return K !== false && y(L, K) && q.push(a), q;
          }
          __name(o, "o");
          function d(k, R) {
            let M = k.getValue(), q = m(k, R), { printer: J, originalText: L, locStart: Y } = R, V = J.isBlockComment && J.isBlockComment(M);
            if (y(L, Y(M), { backwards: true })) {
              let K = p(L, M, Y);
              return i([a, K ? a : "", q]);
            }
            let O = [" ", q];
            return V || (O = [i(O), r]), O;
          }
          __name(d, "d");
          function C(k, R, M, q) {
            let J = [], L = k.getValue();
            return !L || !L.comments || (k.each(() => {
              let Y = k.getValue();
              !Y.leading && !Y.trailing && (!q || q(Y)) && J.push(m(k, R));
            }, "comments"), J.length === 0) ? "" : M ? l(a, J) : u([a, l(a, J)]);
          }
          __name(C, "C");
          function _(k, R, M) {
            let q = k.getValue();
            if (!q)
              return {};
            let J = q.comments || [];
            M && (J = J.filter((O) => !M.has(O)));
            let L = q === R.cursorNode;
            if (J.length === 0) {
              let O = L ? c : "";
              return { leading: O, trailing: O };
            }
            let Y = [], V = [];
            return k.each(() => {
              let O = k.getValue();
              if (M && M.has(O))
                return;
              let { leading: K, trailing: se } = O;
              K ? Y.push(o(k, R)) : se && V.push(d(k, R));
            }, "comments"), L && (Y.unshift(c), V.push(c)), { leading: Y, trailing: V };
          }
          __name(_, "_");
          function b(k, R, M, q) {
            let { leading: J, trailing: L } = _(k, M, q);
            return !J && !L ? R : [J, R, L];
          }
          __name(b, "b");
          function N(k) {
            if (!!k)
              for (let R of k) {
                if (!R.printed)
                  throw new Error('Comment "' + R.value.trim() + '" was not printed. Please report this error!');
                delete R.printed;
              }
          }
          __name(N, "N");
          n.exports = { attach: I, printComments: b, printCommentsSeparately: _, printDanglingComments: C, getSortedChildNodes: F, ensureAllCommentsPrinted: N };
        } }), dm = ee({ "src/common/ast-path.js"(e, n) {
          "use strict";
          re();
          var t = lt();
          function s(u, i) {
            let l = a(u.stack, i);
            return l === -1 ? null : u.stack[l];
          }
          __name(s, "s");
          function a(u, i) {
            for (let l = u.length - 1; l >= 0; l -= 2) {
              let c = u[l];
              if (c && !Array.isArray(c) && --i < 0)
                return l;
            }
            return -1;
          }
          __name(a, "a");
          var r = /* @__PURE__ */ __name(class {
            constructor(u) {
              this.stack = [u];
            }
            getName() {
              let { stack: u } = this, { length: i } = u;
              return i > 1 ? u[i - 2] : null;
            }
            getValue() {
              return t(this.stack);
            }
            getNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s(this, u);
            }
            getParentNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s(this, u + 1);
            }
            call(u) {
              let { stack: i } = this, { length: l } = i, c = t(i);
              for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++)
                h[g - 1] = arguments[g];
              for (let D of h)
                c = c[D], i.push(D, c);
              let p = u(this);
              return i.length = l, p;
            }
            callParent(u) {
              let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = a(this.stack, i + 1), c = this.stack.splice(l + 1), y = u(this);
              return this.stack.push(...c), y;
            }
            each(u) {
              let { stack: i } = this, { length: l } = i, c = t(i);
              for (var y = arguments.length, h = new Array(y > 1 ? y - 1 : 0), g = 1; g < y; g++)
                h[g - 1] = arguments[g];
              for (let p of h)
                c = c[p], i.push(p, c);
              for (let p = 0; p < c.length; ++p)
                i.push(p, c[p]), u(this, p, c), i.length -= 2;
              i.length = l;
            }
            map(u) {
              let i = [];
              for (var l = arguments.length, c = new Array(l > 1 ? l - 1 : 0), y = 1; y < l; y++)
                c[y - 1] = arguments[y];
              return this.each((h, g, p) => {
                i[g] = u(h, g, p);
              }, ...c), i;
            }
            try(u) {
              let { stack: i } = this, l = [...i];
              try {
                return u();
              } finally {
                i.length = 0, i.push(...l);
              }
            }
            match() {
              let u = this.stack.length - 1, i = null, l = this.stack[u--];
              for (var c = arguments.length, y = new Array(c), h = 0; h < c; h++)
                y[h] = arguments[h];
              for (let g of y) {
                if (l === void 0)
                  return false;
                let p = null;
                if (typeof i == "number" && (p = i, i = this.stack[u--], l = this.stack[u--]), g && !g(l, i, p))
                  return false;
                i = this.stack[u--], l = this.stack[u--];
              }
              return true;
            }
            findAncestor(u) {
              let i = this.stack.length - 1, l = null, c = this.stack[i--];
              for (; c; ) {
                let y = null;
                if (typeof l == "number" && (y = l, l = this.stack[i--], c = this.stack[i--]), l !== null && u(c, l, y))
                  return c;
                l = this.stack[i--], c = this.stack[i--];
              }
            }
          }, "r");
          n.exports = r;
        } }), gm = ee({ "src/main/multiparser.js"(e, n) {
          "use strict";
          re();
          var { utils: { stripTrailingHardline: t } } = qe(), { normalize: s } = Oa(), a = et();
          function r(i, l, c, y) {
            if (c.printer.embed && c.embeddedLanguageFormatting === "auto")
              return c.printer.embed(i, l, (h, g, p) => u(h, g, c, y, p), c);
          }
          __name(r, "r");
          function u(i, l, c, y) {
            let { stripTrailingHardline: h = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g = s(Object.assign(Object.assign(Object.assign({}, c), l), {}, { parentParser: c.parser, originalText: i }), { passThrough: true }), p = Un().parse(i, g), { ast: D } = p;
            i = p.text;
            let v = D.comments;
            delete D.comments, a.attach(v, D, i, g), g[Symbol.for("comments")] = v || [], g[Symbol.for("tokens")] = D.tokens || [];
            let w = y(D, g);
            return a.ensureAllCommentsPrinted(v), h ? typeof w == "string" ? w.replace(/(?:\r?\n)*$/, "") : t(w) : w;
          }
          __name(u, "u");
          n.exports = { printSubtree: r };
        } }), ym = ee({ "src/main/ast-to-doc.js"(e, n) {
          "use strict";
          re();
          var t = dm(), { builders: { hardline: s, addAlignmentToDoc: a }, utils: { propagateBreaks: r } } = qe(), { printComments: u } = et(), i = gm();
          function l(h, g) {
            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: D } = g;
            D.preprocess && (h = D.preprocess(h, g));
            let v = /* @__PURE__ */ new Map(), w = new t(h), T = F();
            return p > 0 && (T = a([s, T], p, g.tabWidth)), r(T), T;
            function F(B, I) {
              return B === void 0 || B === w ? A(I) : Array.isArray(B) ? w.call(() => A(I), ...B) : w.call(() => A(I), B);
            }
            __name(F, "F");
            function A(B) {
              let I = w.getValue(), P = I && typeof I == "object" && B === void 0;
              if (P && v.has(I))
                return v.get(I);
              let $ = y(w, g, F, B);
              return P && v.set(I, $), $;
            }
            __name(A, "A");
          }
          __name(l, "l");
          function c(h, g) {
            let { originalText: p, [Symbol.for("comments")]: D, locStart: v, locEnd: w } = g, T = v(h), F = w(h), A = /* @__PURE__ */ new Set();
            for (let B of D)
              v(B) >= T && w(B) <= F && (B.printed = true, A.add(B));
            return { doc: p.slice(T, F), printedComments: A };
          }
          __name(c, "c");
          function y(h, g, p, D) {
            let v = h.getValue(), { printer: w } = g, T, F;
            if (w.hasPrettierIgnore && w.hasPrettierIgnore(h))
              ({ doc: T, printedComments: F } = c(v, g));
            else {
              if (v)
                try {
                  T = i.printSubtree(h, p, g, l);
                } catch (A) {
                  if (globalThis.PRETTIER_DEBUG)
                    throw A;
                }
              T || (T = w.print(h, g, p, D));
            }
            return (!w.willPrintOwnComments || !w.willPrintOwnComments(h, g)) && (T = u(h, T, g, F)), T;
          }
          __name(y, "y");
          n.exports = l;
        } }), hm = ee({ "src/main/range-util.js"(e, n) {
          "use strict";
          re();
          var t = Yt(), s = et(), a = /* @__PURE__ */ __name((D) => {
            let { parser: v } = D;
            return v === "json" || v === "json5" || v === "json-stringify";
          }, "a");
          function r(D, v) {
            let w = [D.node, ...D.parentNodes], T = /* @__PURE__ */ new Set([v.node, ...v.parentNodes]);
            return w.find((F) => y.has(F.type) && T.has(F));
          }
          __name(r, "r");
          function u(D) {
            let v = D.length - 1;
            for (; ; ) {
              let w = D[v];
              if (w && (w.type === "Program" || w.type === "File"))
                v--;
              else
                break;
            }
            return D.slice(0, v + 1);
          }
          __name(u, "u");
          function i(D, v, w) {
            let { locStart: T, locEnd: F } = w, A = D.node, B = v.node;
            if (A === B)
              return { startNode: A, endNode: B };
            let I = T(D.node);
            for (let $ of u(v.parentNodes))
              if (T($) >= I)
                B = $;
              else
                break;
            let P = F(v.node);
            for (let $ of u(D.parentNodes)) {
              if (F($) <= P)
                A = $;
              else
                break;
              if (A === B)
                break;
            }
            return { startNode: A, endNode: B };
          }
          __name(i, "i");
          function l(D, v, w, T) {
            let F = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], A = arguments.length > 5 ? arguments[5] : void 0, { locStart: B, locEnd: I } = w, P = B(D), $ = I(D);
            if (!(v > $ || v < P || A === "rangeEnd" && v === P || A === "rangeStart" && v === $)) {
              for (let f of s.getSortedChildNodes(D, w)) {
                let x = l(f, v, w, T, [D, ...F], A);
                if (x)
                  return x;
              }
              if (!T || T(D, F[0]))
                return { node: D, parentNodes: F };
            }
          }
          __name(l, "l");
          function c(D, v) {
            return v !== "DeclareExportDeclaration" && D !== "TypeParameterDeclaration" && (D === "Directive" || D === "TypeAlias" || D === "TSExportAssignment" || D.startsWith("Declare") || D.startsWith("TSDeclare") || D.endsWith("Statement") || D.endsWith("Declaration"));
          }
          __name(c, "c");
          var y = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), h = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
          function g(D, v, w) {
            if (!v)
              return false;
            switch (D.parser) {
              case "flow":
              case "babel":
              case "babel-flow":
              case "babel-ts":
              case "typescript":
              case "acorn":
              case "espree":
              case "meriyah":
              case "__babel_estree":
                return c(v.type, w && w.type);
              case "json":
              case "json5":
              case "json-stringify":
                return y.has(v.type);
              case "graphql":
                return h.has(v.kind);
              case "vue":
                return v.tag !== "root";
            }
            return false;
          }
          __name(g, "g");
          function p(D, v, w) {
            let { rangeStart: T, rangeEnd: F, locStart: A, locEnd: B } = v;
            t.ok(F > T);
            let I = D.slice(T, F).search(/\S/), P = I === -1;
            if (!P)
              for (T += I; F > T && !/\S/.test(D[F - 1]); --F)
                ;
            let $ = l(w, T, v, (E, o) => g(v, E, o), [], "rangeStart"), f = P ? $ : l(w, F, v, (E) => g(v, E), [], "rangeEnd");
            if (!$ || !f)
              return { rangeStart: 0, rangeEnd: 0 };
            let x, m;
            if (a(v)) {
              let E = r($, f);
              x = E, m = E;
            } else
              ({ startNode: x, endNode: m } = i($, f, v));
            return { rangeStart: Math.min(A(x), A(m)), rangeEnd: Math.max(B(x), B(m)) };
          }
          __name(p, "p");
          n.exports = { calculateRange: p, findNodeAtOffset: l };
        } }), vm = ee({ "src/main/core.js"(e, n) {
          "use strict";
          re();
          var { diffArrays: t } = rD(), { printer: { printDocToString: s }, debug: { printDocToDebug: a } } = qe(), { getAlignmentSize: r } = Ge(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: l, normalizeEndOfLine: c } = qn(), y = Oa().normalize, h = mm(), g = et(), p = Un(), D = ym(), v = hm(), w = "\uFEFF", T = Symbol("cursor");
          function F(m, E, o) {
            let d = E.comments;
            return d && (delete E.comments, g.attach(d, E, m, o)), o[Symbol.for("comments")] = d || [], o[Symbol.for("tokens")] = E.tokens || [], o.originalText = m, d;
          }
          __name(F, "F");
          function A(m, E) {
            let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            if (!m || m.trim().length === 0)
              return { formatted: "", cursorOffset: -1, comments: [] };
            let { ast: d, text: C } = p.parse(m, E);
            if (E.cursorOffset >= 0) {
              let k = v.findNodeAtOffset(d, E.cursorOffset, E);
              k && k.node && (E.cursorNode = k.node);
            }
            let _ = F(C, d, E), b = D(d, E, o), N = s(b, E);
            if (g.ensureAllCommentsPrinted(_), o > 0) {
              let k = N.formatted.trim();
              N.cursorNodeStart !== void 0 && (N.cursorNodeStart -= N.formatted.indexOf(k)), N.formatted = k + i(E.endOfLine);
            }
            if (E.cursorOffset >= 0) {
              let k, R, M, q, J;
              if (E.cursorNode && N.cursorNodeText ? (k = E.locStart(E.cursorNode), R = C.slice(k, E.locEnd(E.cursorNode)), M = E.cursorOffset - k, q = N.cursorNodeStart, J = N.cursorNodeText) : (k = 0, R = C, M = E.cursorOffset, q = 0, J = N.formatted), R === J)
                return { formatted: N.formatted, cursorOffset: q + M, comments: _ };
              let L = [...R];
              L.splice(M, 0, T);
              let Y = [...J], V = t(L, Y), O = q;
              for (let K of V)
                if (K.removed) {
                  if (K.value.includes(T))
                    break;
                } else
                  O += K.count;
              return { formatted: N.formatted, cursorOffset: O, comments: _ };
            }
            return { formatted: N.formatted, cursorOffset: -1, comments: _ };
          }
          __name(A, "A");
          function B(m, E) {
            let { ast: o, text: d } = p.parse(m, E), { rangeStart: C, rangeEnd: _ } = v.calculateRange(d, E, o), b = d.slice(C, _), N = Math.min(C, d.lastIndexOf(`
`, C) + 1), k = d.slice(N, C).match(/^\s*/)[0], R = r(k, E.tabWidth), M = A(b, Object.assign(Object.assign({}, E), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: E.cursorOffset > C && E.cursorOffset <= _ ? E.cursorOffset - C : -1, endOfLine: "lf" }), R), q = M.formatted.trimEnd(), { cursorOffset: J } = E;
            J > _ ? J += q.length - b.length : M.cursorOffset >= 0 && (J = M.cursorOffset + C);
            let L = d.slice(0, C) + q + d.slice(_);
            if (E.endOfLine !== "lf") {
              let Y = i(E.endOfLine);
              J >= 0 && Y === `\r
` && (J += l(L.slice(0, J), `
`)), L = L.replace(/\n/g, Y);
            }
            return { formatted: L, cursorOffset: J, comments: M.comments };
          }
          __name(B, "B");
          function I(m, E, o) {
            return typeof E != "number" || Number.isNaN(E) || E < 0 || E > m.length ? o : E;
          }
          __name(I, "I");
          function P(m, E) {
            let { cursorOffset: o, rangeStart: d, rangeEnd: C } = E;
            return o = I(m, o, -1), d = I(m, d, 0), C = I(m, C, m.length), Object.assign(Object.assign({}, E), {}, { cursorOffset: o, rangeStart: d, rangeEnd: C });
          }
          __name(P, "P");
          function $(m, E) {
            let { cursorOffset: o, rangeStart: d, rangeEnd: C, endOfLine: _ } = P(m, E), b = m.charAt(0) === w;
            if (b && (m = m.slice(1), o--, d--, C--), _ === "auto" && (_ = u(m)), m.includes("\r")) {
              let N = /* @__PURE__ */ __name((k) => l(m.slice(0, Math.max(k, 0)), `\r
`), "N");
              o -= N(o), d -= N(d), C -= N(C), m = c(m);
            }
            return { hasBOM: b, text: m, options: P(m, Object.assign(Object.assign({}, E), {}, { cursorOffset: o, rangeStart: d, rangeEnd: C, endOfLine: _ })) };
          }
          __name($, "$");
          function f(m, E) {
            let o = p.resolveParser(E);
            return !o.hasPragma || o.hasPragma(m);
          }
          __name(f, "f");
          function x(m, E) {
            let { hasBOM: o, text: d, options: C } = $(m, y(E));
            if (C.rangeStart >= C.rangeEnd && d !== "" || C.requirePragma && !f(d, C))
              return { formatted: m, cursorOffset: E.cursorOffset, comments: [] };
            let _;
            return C.rangeStart > 0 || C.rangeEnd < d.length ? _ = B(d, C) : (!C.requirePragma && C.insertPragma && C.printer.insertPragma && !f(d, C) && (d = C.printer.insertPragma(d)), _ = A(d, C)), o && (_.formatted = w + _.formatted, _.cursorOffset >= 0 && _.cursorOffset++), _;
          }
          __name(x, "x");
          n.exports = { formatWithCursor: x, parse(m, E, o) {
            let { text: d, options: C } = $(m, y(E)), _ = p.parse(d, C);
            return o && (_.ast = h(_.ast, C)), _;
          }, formatAST(m, E) {
            E = y(E);
            let o = D(m, E);
            return s(o, E);
          }, formatDoc(m, E) {
            return x(a(m), Object.assign(Object.assign({}, E), {}, { parser: "__js_expression" })).formatted;
          }, printToDoc(m, E) {
            E = y(E);
            let { ast: o, text: d } = p.parse(m, E);
            return F(d, o, E), D(o, E);
          }, printDocToString(m, E) {
            return s(m, y(E));
          } };
        } }), Cm = ee({ "src/common/util-shared.js"(e, n) {
          "use strict";
          re();
          var { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: r, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: c, skipToLineEnd: y, skipEverythingButNewLine: h, skipInlineComment: g, skipTrailingComment: p, hasNewline: D, hasNewlineInRange: v, hasSpaces: w, isNextLineEmpty: T, isNextLineEmptyAfterIndex: F, isPreviousLineEmpty: A, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: f } = Ge();
          n.exports = { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: r, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: c, skipToLineEnd: y, skipEverythingButNewLine: h, skipInlineComment: g, skipTrailingComment: p, hasNewline: D, hasNewlineInRange: v, hasSpaces: w, isNextLineEmpty: T, isNextLineEmptyAfterIndex: F, isPreviousLineEmpty: A, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I, addLeadingComment: P, addDanglingComment: $, addTrailingComment: f };
        } }), wt = ee({ "src/utils/create-language.js"(e, n) {
          "use strict";
          re(), n.exports = function(t, s) {
            let { languageId: a } = t, r = Ln(t, zf);
            return Object.assign(Object.assign({ linguistLanguageId: a }, r), s(t));
          };
        } }), Em = ee({ "node_modules/esutils/lib/ast.js"(e, n) {
          re(), function() {
            "use strict";
            function t(l) {
              if (l == null)
                return false;
              switch (l.type) {
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "Literal":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                  return true;
              }
              return false;
            }
            __name(t, "t");
            function s(l) {
              if (l == null)
                return false;
              switch (l.type) {
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                  return true;
              }
              return false;
            }
            __name(s, "s");
            function a(l) {
              if (l == null)
                return false;
              switch (l.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                  return true;
              }
              return false;
            }
            __name(a, "a");
            function r(l) {
              return a(l) || l != null && l.type === "FunctionDeclaration";
            }
            __name(r, "r");
            function u(l) {
              switch (l.type) {
                case "IfStatement":
                  return l.alternate != null ? l.alternate : l.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                  return l.body;
              }
              return null;
            }
            __name(u, "u");
            function i(l) {
              var c;
              if (l.type !== "IfStatement" || l.alternate == null)
                return false;
              c = l.consequent;
              do {
                if (c.type === "IfStatement" && c.alternate == null)
                  return true;
                c = u(c);
              } while (c);
              return false;
            }
            __name(i, "i");
            n.exports = { isExpression: t, isStatement: a, isIterationStatement: s, isSourceElement: r, isProblematicIfStatement: i, trailingStatement: u };
          }();
        } }), qa = ee({ "node_modules/esutils/lib/code.js"(e, n) {
          re(), function() {
            "use strict";
            var t, s, a, r, u, i;
            s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
            function l(F) {
              return 48 <= F && F <= 57;
            }
            __name(l, "l");
            function c(F) {
              return 48 <= F && F <= 57 || 97 <= F && F <= 102 || 65 <= F && F <= 70;
            }
            __name(c, "c");
            function y(F) {
              return F >= 48 && F <= 55;
            }
            __name(y, "y");
            a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
            function h(F) {
              return F === 32 || F === 9 || F === 11 || F === 12 || F === 160 || F >= 5760 && a.indexOf(F) >= 0;
            }
            __name(h, "h");
            function g(F) {
              return F === 10 || F === 13 || F === 8232 || F === 8233;
            }
            __name(g, "g");
            function p(F) {
              if (F <= 65535)
                return String.fromCharCode(F);
              var A = String.fromCharCode(Math.floor((F - 65536) / 1024) + 55296), B = String.fromCharCode((F - 65536) % 1024 + 56320);
              return A + B;
            }
            __name(p, "p");
            for (r = new Array(128), i = 0; i < 128; ++i)
              r[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
            for (u = new Array(128), i = 0; i < 128; ++i)
              u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
            function D(F) {
              return F < 128 ? r[F] : s.NonAsciiIdentifierStart.test(p(F));
            }
            __name(D, "D");
            function v(F) {
              return F < 128 ? u[F] : s.NonAsciiIdentifierPart.test(p(F));
            }
            __name(v, "v");
            function w(F) {
              return F < 128 ? r[F] : t.NonAsciiIdentifierStart.test(p(F));
            }
            __name(w, "w");
            function T(F) {
              return F < 128 ? u[F] : t.NonAsciiIdentifierPart.test(p(F));
            }
            __name(T, "T");
            n.exports = { isDecimalDigit: l, isHexDigit: c, isOctalDigit: y, isWhiteSpace: h, isLineTerminator: g, isIdentifierStartES5: D, isIdentifierPartES5: v, isIdentifierStartES6: w, isIdentifierPartES6: T };
          }();
        } }), Fm = ee({ "node_modules/esutils/lib/keyword.js"(e, n) {
          re(), function() {
            "use strict";
            var t = qa();
            function s(D) {
              switch (D) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }
            __name(s, "s");
            function a(D, v) {
              return !v && D === "yield" ? false : r(D, v);
            }
            __name(a, "a");
            function r(D, v) {
              if (v && s(D))
                return true;
              switch (D.length) {
                case 2:
                  return D === "if" || D === "in" || D === "do";
                case 3:
                  return D === "var" || D === "for" || D === "new" || D === "try";
                case 4:
                  return D === "this" || D === "else" || D === "case" || D === "void" || D === "with" || D === "enum";
                case 5:
                  return D === "while" || D === "break" || D === "catch" || D === "throw" || D === "const" || D === "yield" || D === "class" || D === "super";
                case 6:
                  return D === "return" || D === "typeof" || D === "delete" || D === "switch" || D === "export" || D === "import";
                case 7:
                  return D === "default" || D === "finally" || D === "extends";
                case 8:
                  return D === "function" || D === "continue" || D === "debugger";
                case 10:
                  return D === "instanceof";
                default:
                  return false;
              }
            }
            __name(r, "r");
            function u(D, v) {
              return D === "null" || D === "true" || D === "false" || a(D, v);
            }
            __name(u, "u");
            function i(D, v) {
              return D === "null" || D === "true" || D === "false" || r(D, v);
            }
            __name(i, "i");
            function l(D) {
              return D === "eval" || D === "arguments";
            }
            __name(l, "l");
            function c(D) {
              var v, w, T;
              if (D.length === 0 || (T = D.charCodeAt(0), !t.isIdentifierStartES5(T)))
                return false;
              for (v = 1, w = D.length; v < w; ++v)
                if (T = D.charCodeAt(v), !t.isIdentifierPartES5(T))
                  return false;
              return true;
            }
            __name(c, "c");
            function y(D, v) {
              return (D - 55296) * 1024 + (v - 56320) + 65536;
            }
            __name(y, "y");
            function h(D) {
              var v, w, T, F, A;
              if (D.length === 0)
                return false;
              for (A = t.isIdentifierStartES6, v = 0, w = D.length; v < w; ++v) {
                if (T = D.charCodeAt(v), 55296 <= T && T <= 56319) {
                  if (++v, v >= w || (F = D.charCodeAt(v), !(56320 <= F && F <= 57343)))
                    return false;
                  T = y(T, F);
                }
                if (!A(T))
                  return false;
                A = t.isIdentifierPartES6;
              }
              return true;
            }
            __name(h, "h");
            function g(D, v) {
              return c(D) && !u(D, v);
            }
            __name(g, "g");
            function p(D, v) {
              return h(D) && !i(D, v);
            }
            __name(p, "p");
            n.exports = { isKeywordES5: a, isKeywordES6: r, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: l, isIdentifierNameES5: c, isIdentifierNameES6: h, isIdentifierES5: g, isIdentifierES6: p };
          }();
        } }), Am = ee({ "node_modules/esutils/lib/utils.js"(e) {
          re(), function() {
            "use strict";
            e.ast = Em(), e.code = qa(), e.keyword = Fm();
          }();
        } }), Lt = ee({ "src/language-js/utils/is-block-comment.js"(e, n) {
          "use strict";
          re();
          var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s = /* @__PURE__ */ __name((a) => t.has(a == null ? void 0 : a.type), "s");
          n.exports = s;
        } }), Sm = ee({ "src/language-js/utils/is-node-matches.js"(e, n) {
          "use strict";
          re();
          function t(a, r) {
            let u = r.split(".");
            for (let i = u.length - 1; i >= 0; i--) {
              let l = u[i];
              if (i === 0)
                return a.type === "Identifier" && a.name === l;
              if (a.type !== "MemberExpression" || a.optional || a.computed || a.property.type !== "Identifier" || a.property.name !== l)
                return false;
              a = a.object;
            }
          }
          __name(t, "t");
          function s(a, r) {
            return r.some((u) => t(a, u));
          }
          __name(s, "s");
          n.exports = s;
        } }), Ke = ee({ "src/language-js/utils/index.js"(e, n) {
          "use strict";
          re();
          var t = Am().keyword.isIdentifierNameES5, { getLast: s, hasNewline: a, skipWhitespace: r, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: l } = Ge(), { locStart: c, locEnd: y, hasSameLocStart: h } = it(), g = Lt(), p = Sm(), D = "(?:(?=.)\\s)", v = new RegExp(`^${D}*:`), w = new RegExp(`^${D}*::`);
          function T(j) {
            var me, Ie;
            return ((me = j.extra) === null || me === void 0 ? void 0 : me.parenthesized) && g((Ie = j.trailingComments) === null || Ie === void 0 ? void 0 : Ie[0]) && v.test(j.trailingComments[0].value);
          }
          __name(T, "T");
          function F(j) {
            let me = j == null ? void 0 : j[0];
            return g(me) && w.test(me.value);
          }
          __name(F, "F");
          function A(j, me) {
            if (!j || typeof j != "object")
              return false;
            if (Array.isArray(j))
              return j.some((je) => A(je, me));
            let Ie = me(j);
            return typeof Ie == "boolean" ? Ie : Object.values(j).some((je) => A(je, me));
          }
          __name(A, "A");
          function B(j) {
            return j.type === "AssignmentExpression" || j.type === "BinaryExpression" || j.type === "LogicalExpression" || j.type === "NGPipeExpression" || j.type === "ConditionalExpression" || oe(j) || ae(j) || j.type === "SequenceExpression" || j.type === "TaggedTemplateExpression" || j.type === "BindExpression" || j.type === "UpdateExpression" && !j.prefix || nt(j) || j.type === "TSNonNullExpression";
          }
          __name(B, "B");
          function I(j) {
            var me, Ie, je, Ye, ut, ze;
            return j.expressions ? j.expressions[0] : (me = (Ie = (je = (Ye = (ut = (ze = j.left) !== null && ze !== void 0 ? ze : j.test) !== null && ut !== void 0 ? ut : j.callee) !== null && Ye !== void 0 ? Ye : j.object) !== null && je !== void 0 ? je : j.tag) !== null && Ie !== void 0 ? Ie : j.argument) !== null && me !== void 0 ? me : j.expression;
          }
          __name(I, "I");
          function P(j, me) {
            if (me.expressions)
              return ["expressions", 0];
            if (me.left)
              return ["left"];
            if (me.test)
              return ["test"];
            if (me.object)
              return ["object"];
            if (me.callee)
              return ["callee"];
            if (me.tag)
              return ["tag"];
            if (me.argument)
              return ["argument"];
            if (me.expression)
              return ["expression"];
            throw new Error("Unexpected node has no left side.");
          }
          __name(P, "P");
          function $(j) {
            return j = new Set(j), (me) => j.has(me == null ? void 0 : me.type);
          }
          __name($, "$");
          var f = $(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), x = $(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
          function m(j) {
            let me = j.getParentNode();
            return j.getName() === "declaration" && x(me) ? me : null;
          }
          __name(m, "m");
          var E = $(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
          function o(j) {
            return j.type === "NumericLiteral" || j.type === "Literal" && typeof j.value == "number";
          }
          __name(o, "o");
          function d(j) {
            return j.type === "UnaryExpression" && (j.operator === "+" || j.operator === "-") && o(j.argument);
          }
          __name(d, "d");
          function C(j) {
            return j.type === "StringLiteral" || j.type === "Literal" && typeof j.value == "string";
          }
          __name(C, "C");
          var _ = $(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b = $(["FunctionExpression", "ArrowFunctionExpression"]);
          function N(j) {
            return j.type === "FunctionExpression" || j.type === "ArrowFunctionExpression" && j.body.type === "BlockStatement";
          }
          __name(N, "N");
          function k(j) {
            return oe(j) && j.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(j.callee.name);
          }
          __name(k, "k");
          var R = $(["JSXElement", "JSXFragment"]);
          function M(j, me) {
            if (j.parentParser !== "markdown" && j.parentParser !== "mdx")
              return false;
            let Ie = me.getNode();
            if (!Ie.expression || !R(Ie.expression))
              return false;
            let je = me.getParentNode();
            return je.type === "Program" && je.body.length === 1;
          }
          __name(M, "M");
          function q(j) {
            return j.kind === "get" || j.kind === "set";
          }
          __name(q, "q");
          function J(j) {
            return q(j) || h(j, j.value);
          }
          __name(J, "J");
          function L(j) {
            return (j.type === "ObjectTypeProperty" || j.type === "ObjectTypeInternalSlot") && j.value.type === "FunctionTypeAnnotation" && !j.static && !J(j);
          }
          __name(L, "L");
          function Y(j) {
            return (j.type === "TypeAnnotation" || j.type === "TSTypeAnnotation") && j.typeAnnotation.type === "FunctionTypeAnnotation" && !j.static && !h(j, j.typeAnnotation);
          }
          __name(Y, "Y");
          var V = $(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
          function O(j) {
            return ae(j) || j.type === "BindExpression" && Boolean(j.object);
          }
          __name(O, "O");
          var K = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
          function se(j) {
            return j ? !!((j.type === "GenericTypeAnnotation" || j.type === "TSTypeReference") && !j.typeParameters || K.has(j.type)) : false;
          }
          __name(se, "se");
          function Q(j) {
            let me = /^(?:before|after)(?:Each|All)$/;
            return j.callee.type === "Identifier" && me.test(j.callee.name) && j.arguments.length === 1;
          }
          __name(Q, "Q");
          var le = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
          function W(j) {
            return p(j, le);
          }
          __name(W, "W");
          function X(j, me) {
            if (j.type !== "CallExpression")
              return false;
            if (j.arguments.length === 1) {
              if (k(j) && me && X(me))
                return b(j.arguments[0]);
              if (Q(j))
                return k(j.arguments[0]);
            } else if ((j.arguments.length === 2 || j.arguments.length === 3) && (j.arguments[0].type === "TemplateLiteral" || C(j.arguments[0])) && W(j.callee))
              return j.arguments[2] && !o(j.arguments[2]) ? false : (j.arguments.length === 2 ? b(j.arguments[1]) : N(j.arguments[1]) && Fe(j.arguments[1]).length <= 1) || k(j.arguments[1]);
            return false;
          }
          __name(X, "X");
          var oe = $(["CallExpression", "OptionalCallExpression"]), ae = $(["MemberExpression", "OptionalMemberExpression"]);
          function Ae(j) {
            let me = "expressions";
            j.type === "TSTemplateLiteralType" && (me = "types");
            let Ie = j[me];
            return Ie.length === 0 ? false : Ie.every((je) => {
              if (ue(je))
                return false;
              if (je.type === "Identifier" || je.type === "ThisExpression")
                return true;
              if (ae(je)) {
                let Ye = je;
                for (; ae(Ye); )
                  if (Ye.property.type !== "Identifier" && Ye.property.type !== "Literal" && Ye.property.type !== "StringLiteral" && Ye.property.type !== "NumericLiteral" || (Ye = Ye.object, ue(Ye)))
                    return false;
                return Ye.type === "Identifier" || Ye.type === "ThisExpression";
              }
              return false;
            });
          }
          __name(Ae, "Ae");
          function z(j, me) {
            return j === "+" || j === "-" ? j + me : me;
          }
          __name(z, "z");
          function H(j, me) {
            let Ie = c(me), je = r(j, y(me));
            return je !== false && j.slice(Ie, Ie + 2) === "/*" && j.slice(je, je + 2) === "*/";
          }
          __name(H, "H");
          function Z(j, me) {
            return R(me) ? Ve(me) : ue(me, ke.Leading, (Ie) => a(j, y(Ie)));
          }
          __name(Z, "Z");
          function ne(j, me) {
            return me.parser !== "json" && C(j.key) && ce(j.key).slice(1, -1) === j.key.value && (t(j.key.value) && !(me.parser === "babel-ts" && j.type === "ClassProperty" || me.parser === "typescript" && j.type === "PropertyDefinition") || fe(j.key.value) && String(Number(j.key.value)) === j.key.value && (me.parser === "babel" || me.parser === "acorn" || me.parser === "espree" || me.parser === "meriyah" || me.parser === "__babel_estree"));
          }
          __name(ne, "ne");
          function fe(j) {
            return /^(?:\d+|\d+\.\d+)$/.test(j);
          }
          __name(fe, "fe");
          function ge(j, me) {
            let Ie = /^[fx]?(?:describe|it|test)$/;
            return me.type === "TaggedTemplateExpression" && me.quasi === j && me.tag.type === "MemberExpression" && me.tag.property.type === "Identifier" && me.tag.property.name === "each" && (me.tag.object.type === "Identifier" && Ie.test(me.tag.object.name) || me.tag.object.type === "MemberExpression" && me.tag.object.property.type === "Identifier" && (me.tag.object.property.name === "only" || me.tag.object.property.name === "skip") && me.tag.object.object.type === "Identifier" && Ie.test(me.tag.object.object.name));
          }
          __name(ge, "ge");
          function Ce(j) {
            return j.quasis.some((me) => me.value.raw.includes(`
`));
          }
          __name(Ce, "Ce");
          function _e(j, me) {
            return (j.type === "TemplateLiteral" && Ce(j) || j.type === "TaggedTemplateExpression" && Ce(j.quasi)) && !a(me, c(j), { backwards: true });
          }
          __name(_e, "_e");
          function Oe(j) {
            if (!ue(j))
              return false;
            let me = s(st(j, ke.Dangling));
            return me && !g(me);
          }
          __name(Oe, "Oe");
          function pe(j) {
            if (j.length <= 1)
              return false;
            let me = 0;
            for (let Ie of j)
              if (b(Ie)) {
                if (me += 1, me > 1)
                  return true;
              } else if (oe(Ie)) {
                for (let je of Ie.arguments)
                  if (b(je))
                    return true;
              }
            return false;
          }
          __name(pe, "pe");
          function ie(j) {
            let me = j.getValue(), Ie = j.getParentNode();
            return oe(me) && oe(Ie) && Ie.callee === me && me.arguments.length > Ie.arguments.length && Ie.arguments.length > 0;
          }
          __name(ie, "ie");
          function ve(j, me) {
            if (me >= 2)
              return false;
            let Ie = /* @__PURE__ */ __name((ze) => ve(ze, me + 1), "Ie"), je = j.type === "Literal" && "regex" in j && j.regex.pattern || j.type === "RegExpLiteral" && j.pattern;
            if (je && l(je) > 5)
              return false;
            if (j.type === "Literal" || j.type === "BigIntLiteral" || j.type === "DecimalLiteral" || j.type === "BooleanLiteral" || j.type === "NullLiteral" || j.type === "NumericLiteral" || j.type === "RegExpLiteral" || j.type === "StringLiteral" || j.type === "Identifier" || j.type === "ThisExpression" || j.type === "Super" || j.type === "PrivateName" || j.type === "PrivateIdentifier" || j.type === "ArgumentPlaceholder" || j.type === "Import")
              return true;
            if (j.type === "TemplateLiteral")
              return j.quasis.every((ze) => !ze.value.raw.includes(`
`)) && j.expressions.every(Ie);
            if (j.type === "ObjectExpression")
              return j.properties.every((ze) => !ze.computed && (ze.shorthand || ze.value && Ie(ze.value)));
            if (j.type === "ArrayExpression")
              return j.elements.every((ze) => ze === null || Ie(ze));
            if (He(j))
              return (j.type === "ImportExpression" || ve(j.callee, me)) && Je(j).every(Ie);
            if (ae(j))
              return ve(j.object, me) && ve(j.property, me);
            let Ye = { "!": true, "-": true, "+": true, "~": true };
            if (j.type === "UnaryExpression" && Ye[j.operator])
              return ve(j.argument, me);
            let ut = { "++": true, "--": true };
            return j.type === "UpdateExpression" && ut[j.operator] ? ve(j.argument, me) : j.type === "TSNonNullExpression" ? ve(j.expression, me) : false;
          }
          __name(ve, "ve");
          function ce(j) {
            var me, Ie;
            return (me = (Ie = j.extra) === null || Ie === void 0 ? void 0 : Ie.raw) !== null && me !== void 0 ? me : j.raw;
          }
          __name(ce, "ce");
          function U(j) {
            return j;
          }
          __name(U, "U");
          function de(j) {
            return j.filepath && /\.tsx$/i.test(j.filepath);
          }
          __name(de, "de");
          function De(j) {
            let me = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
            return j.trailingComma === "es5" && me === "es5" || j.trailingComma === "all" && (me === "all" || me === "es5");
          }
          __name(De, "De");
          function he(j, me) {
            switch (j = Ee(j), j.type) {
              case "FunctionExpression":
              case "ClassExpression":
              case "DoExpression":
                return me;
              case "ObjectExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return he(j.object, me);
              case "TaggedTemplateExpression":
                return j.tag.type === "FunctionExpression" ? false : he(j.tag, me);
              case "CallExpression":
              case "OptionalCallExpression":
                return j.callee.type === "FunctionExpression" ? false : he(j.callee, me);
              case "ConditionalExpression":
                return he(j.test, me);
              case "UpdateExpression":
                return !j.prefix && he(j.argument, me);
              case "BindExpression":
                return j.object && he(j.object, me);
              case "SequenceExpression":
                return he(j.expressions[0], me);
              case "TSSatisfiesExpression":
              case "TSAsExpression":
              case "TSNonNullExpression":
                return he(j.expression, me);
              default:
                return false;
            }
          }
          __name(he, "he");
          var Be = { "==": true, "!=": true, "===": true, "!==": true }, Se = { "*": true, "/": true, "%": true }, ye = { ">>": true, ">>>": true, "<<": true };
          function S(j, me) {
            return !(te(me) !== te(j) || j === "**" || Be[j] && Be[me] || me === "%" && Se[j] || j === "%" && Se[me] || me !== j && Se[me] && Se[j] || ye[j] && ye[me]);
          }
          __name(S, "S");
          var G = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((j, me) => j.map((Ie) => [Ie, me])));
          function te(j) {
            return G.get(j);
          }
          __name(te, "te");
          function Ee(j) {
            for (; j.left; )
              j = j.left;
            return j;
          }
          __name(Ee, "Ee");
          function Re(j) {
            return Boolean(ye[j]) || j === "|" || j === "^" || j === "&";
          }
          __name(Re, "Re");
          function Te(j) {
            var me;
            if (j.rest)
              return true;
            let Ie = Fe(j);
            return ((me = s(Ie)) === null || me === void 0 ? void 0 : me.type) === "RestElement";
          }
          __name(Te, "Te");
          var Pe = /* @__PURE__ */ new WeakMap();
          function Fe(j) {
            if (Pe.has(j))
              return Pe.get(j);
            let me = [];
            return j.this && me.push(j.this), Array.isArray(j.parameters) ? me.push(...j.parameters) : Array.isArray(j.params) && me.push(...j.params), j.rest && me.push(j.rest), Pe.set(j, me), me;
          }
          __name(Fe, "Fe");
          function Ze(j, me) {
            let Ie = j.getValue(), je = 0, Ye = /* @__PURE__ */ __name((ut) => me(ut, je++), "Ye");
            Ie.this && j.call(Ye, "this"), Array.isArray(Ie.parameters) ? j.each(Ye, "parameters") : Array.isArray(Ie.params) && j.each(Ye, "params"), Ie.rest && j.call(Ye, "rest");
          }
          __name(Ze, "Ze");
          var xe = /* @__PURE__ */ new WeakMap();
          function Je(j) {
            if (xe.has(j))
              return xe.get(j);
            let me = j.arguments;
            return j.type === "ImportExpression" && (me = [j.source], j.attributes && me.push(j.attributes)), xe.set(j, me), me;
          }
          __name(Je, "Je");
          function we(j, me) {
            let Ie = j.getValue();
            Ie.type === "ImportExpression" ? (j.call((je) => me(je, 0), "source"), Ie.attributes && j.call((je) => me(je, 1), "attributes")) : j.each(me, "arguments");
          }
          __name(we, "we");
          function Le(j) {
            return j.value.trim() === "prettier-ignore" && !j.unignore;
          }
          __name(Le, "Le");
          function Ve(j) {
            return j && (j.prettierIgnore || ue(j, ke.PrettierIgnore));
          }
          __name(Ve, "Ve");
          function be(j) {
            let me = j.getValue();
            return Ve(me);
          }
          __name(be, "be");
          var ke = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, Me = /* @__PURE__ */ __name((j, me) => {
            if (typeof j == "function" && (me = j, j = 0), j || me)
              return (Ie, je, Ye) => !(j & ke.Leading && !Ie.leading || j & ke.Trailing && !Ie.trailing || j & ke.Dangling && (Ie.leading || Ie.trailing) || j & ke.Block && !g(Ie) || j & ke.Line && !f(Ie) || j & ke.First && je !== 0 || j & ke.Last && je !== Ye.length - 1 || j & ke.PrettierIgnore && !Le(Ie) || me && !me(Ie));
          }, "Me");
          function ue(j, me, Ie) {
            if (!u(j == null ? void 0 : j.comments))
              return false;
            let je = Me(me, Ie);
            return je ? j.comments.some(je) : true;
          }
          __name(ue, "ue");
          function st(j, me, Ie) {
            if (!Array.isArray(j == null ? void 0 : j.comments))
              return [];
            let je = Me(me, Ie);
            return je ? j.comments.filter(je) : j.comments;
          }
          __name(st, "st");
          var rt = /* @__PURE__ */ __name((j, me) => {
            let { originalText: Ie } = me;
            return i(Ie, y(j));
          }, "rt");
          function He(j) {
            return oe(j) || j.type === "NewExpression" || j.type === "ImportExpression";
          }
          __name(He, "He");
          function Ue(j) {
            return j && (j.type === "ObjectProperty" || j.type === "Property" && !j.method && j.kind === "init");
          }
          __name(Ue, "Ue");
          function Xe(j) {
            return Boolean(j.__isUsingHackPipeline);
          }
          __name(Xe, "Xe");
          var at = Symbol("ifWithoutBlockAndSameLineComment");
          function nt(j) {
            return j.type === "TSAsExpression" || j.type === "TSSatisfiesExpression";
          }
          __name(nt, "nt");
          n.exports = { getFunctionParameters: Fe, iterateFunctionParametersPath: Ze, getCallArguments: Je, iterateCallArgumentsPath: we, hasRestParameter: Te, getLeftSide: I, getLeftSidePathName: P, getParentExportDeclaration: m, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: F, hasFlowShorthandAnnotationComment: T, hasLeadingOwnLineComment: Z, hasNakedLeftSide: B, hasNode: A, hasIgnoreComment: be, hasNodeIgnoreComment: Ve, identity: U, isBinaryish: V, isCallLikeExpression: He, isEnabledHackPipeline: Xe, isLineComment: f, isPrettierIgnoreComment: Le, isCallExpression: oe, isMemberExpression: ae, isExportDeclaration: x, isFlowAnnotationComment: H, isFunctionCompositionArgs: pe, isFunctionNotation: J, isFunctionOrArrowExpression: b, isGetterOrSetter: q, isJestEachTemplateLiteral: ge, isJsxNode: R, isLiteral: E, isLongCurriedCallExpression: ie, isSimpleCallArgument: ve, isMemberish: O, isNumericLiteral: o, isSignedNumericLiteral: d, isObjectProperty: Ue, isObjectType: _, isObjectTypePropertyAFunction: L, isSimpleType: se, isSimpleNumber: fe, isSimpleTemplateLiteral: Ae, isStringLiteral: C, isStringPropSafeToUnquote: ne, isTemplateOnItsOwnLine: _e, isTestCall: X, isTheOnlyJsxElementInMarkdown: M, isTSXFile: de, isTypeAnnotationAFunction: Y, isNextLineEmpty: rt, needsHardlineAfterDanglingComment: Oe, rawText: ce, shouldPrintComma: De, isBitwiseOperator: Re, shouldFlatten: S, startsWithNoLookaheadToken: he, getPrecedence: te, hasComment: ue, getComments: st, CommentCheckFlags: ke, markerForIfWithoutBlockAndSameLineComment: at, isTSTypeExpression: nt };
        } }), jt = ee({ "src/language-js/print/template-literal.js"(e, n) {
          "use strict";
          re();
          var t = lt(), { getStringWidth: s, getIndentSize: a } = Ge(), { builders: { join: r, hardline: u, softline: i, group: l, indent: c, align: y, lineSuffixBoundary: h, addAlignmentToDoc: g }, printer: { printDocToString: p }, utils: { mapDoc: D } } = qe(), { isBinaryish: v, isJestEachTemplateLiteral: w, isSimpleTemplateLiteral: T, hasComment: F, isMemberExpression: A, isTSTypeExpression: B } = Ke();
          function I(E, o, d) {
            let C = E.getValue();
            if (C.type === "TemplateLiteral" && w(C, E.getParentNode())) {
              let M = P(E, d, o);
              if (M)
                return M;
            }
            let b = "expressions";
            C.type === "TSTemplateLiteralType" && (b = "types");
            let N = [], k = E.map(o, b), R = T(C);
            return R && (k = k.map((M) => p(M, Object.assign(Object.assign({}, d), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), N.push(h, "`"), E.each((M) => {
              let q = M.getName();
              if (N.push(o()), q < k.length) {
                let { tabWidth: J } = d, L = M.getValue(), Y = a(L.value.raw, J), V = k[q];
                if (!R) {
                  let K = C[b][q];
                  (F(K) || A(K) || K.type === "ConditionalExpression" || K.type === "SequenceExpression" || B(K) || v(K)) && (V = [c([i, V]), i]);
                }
                let O = Y === 0 && L.value.raw.endsWith(`
`) ? y(Number.NEGATIVE_INFINITY, V) : g(V, Y, J);
                N.push(l(["${", O, h, "}"]));
              }
            }, "quasis"), N.push("`"), N;
          }
          __name(I, "I");
          function P(E, o, d) {
            let C = E.getNode(), _ = C.quasis[0].value.raw.trim().split(/\s*\|\s*/);
            if (_.length > 1 || _.some((b) => b.length > 0)) {
              o.__inJestEach = true;
              let b = E.map(d, "expressions");
              o.__inJestEach = false;
              let N = [], k = b.map((L) => "${" + p(L, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), R = [{ hasLineBreak: false, cells: [] }];
              for (let L = 1; L < C.quasis.length; L++) {
                let Y = t(R), V = k[L - 1];
                Y.cells.push(V), V.includes(`
`) && (Y.hasLineBreak = true), C.quasis[L].value.raw.includes(`
`) && R.push({ hasLineBreak: false, cells: [] });
              }
              let M = Math.max(_.length, ...R.map((L) => L.cells.length)), q = Array.from({ length: M }).fill(0), J = [{ cells: _ }, ...R.filter((L) => L.cells.length > 0)];
              for (let { cells: L } of J.filter((Y) => !Y.hasLineBreak))
                for (let [Y, V] of L.entries())
                  q[Y] = Math.max(q[Y], s(V));
              return N.push(h, "`", c([u, r(u, J.map((L) => r(" | ", L.cells.map((Y, V) => L.hasLineBreak ? Y : Y + " ".repeat(q[V] - s(Y))))))]), u, "`"), N;
            }
          }
          __name(P, "P");
          function $(E, o) {
            let d = E.getValue(), C = o();
            return F(d) && (C = l([c([i, C]), i])), ["${", C, h, "}"];
          }
          __name($, "$");
          function f(E, o) {
            return E.map((d) => $(d, o), "expressions");
          }
          __name(f, "f");
          function x(E, o) {
            return D(E, (d) => typeof d == "string" ? o ? d.replace(/(\\*)`/g, "$1$1\\`") : m(d) : d);
          }
          __name(x, "x");
          function m(E) {
            return E.replace(/([\\`]|\${)/g, "\\$1");
          }
          __name(m, "m");
          n.exports = { printTemplateLiteral: I, printTemplateExpressions: f, escapeTemplateCharacters: x, uncookTemplateElementValue: m };
        } }), xm = ee({ "src/language-js/embed/markdown.js"(e, n) {
          "use strict";
          re();
          var { builders: { indent: t, softline: s, literalline: a, dedentToRoot: r } } = qe(), { escapeTemplateCharacters: u } = jt();
          function i(c, y, h) {
            let p = c.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (T, F) => "\\".repeat(F.length / 2) + "`"), D = l(p), v = D !== "";
            v && (p = p.replace(new RegExp(`^${D}`, "gm"), ""));
            let w = u(h(p, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
            return ["`", v ? t([s, w]) : [a, r(w)], s, "`"];
          }
          __name(i, "i");
          function l(c) {
            let y = c.match(/^([^\S\n]*)\S/m);
            return y === null ? "" : y[1];
          }
          __name(l, "l");
          n.exports = i;
        } }), bm = ee({ "src/language-js/embed/css.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t } = Ge(), { builders: { indent: s, hardline: a, softline: r }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: l } } = qe(), { printTemplateExpressions: c } = jt();
          function y(p, D, v) {
            let w = p.getValue(), T = w.quasis.map((P) => P.value.raw), F = 0, A = T.reduce((P, $, f) => f === 0 ? $ : P + "@prettier-placeholder-" + F++ + "-id" + $, ""), B = v(A, { parser: "scss" }, { stripTrailingHardline: true }), I = c(p, D);
            return h(B, w, I);
          }
          __name(y, "y");
          function h(p, D, v) {
            if (D.quasis.length === 1 && !D.quasis[0].value.raw.trim())
              return "``";
            let T = g(p, v);
            if (!T)
              throw new Error("Couldn't insert all the expressions");
            return ["`", s([a, T]), r, "`"];
          }
          __name(h, "h");
          function g(p, D) {
            if (!t(D))
              return p;
            let v = 0, w = u(l(p), (T) => typeof T != "string" || !T.includes("@prettier-placeholder") ? T : T.split(/@prettier-placeholder-(\d+)-id/).map((F, A) => A % 2 === 0 ? i(F) : (v++, D[F])));
            return D.length === v ? w : null;
          }
          __name(g, "g");
          n.exports = y;
        } }), Tm = ee({ "src/language-js/embed/graphql.js"(e, n) {
          "use strict";
          re();
          var { builders: { indent: t, join: s, hardline: a } } = qe(), { escapeTemplateCharacters: r, printTemplateExpressions: u } = jt();
          function i(c, y, h) {
            let g = c.getValue(), p = g.quasis.length;
            if (p === 1 && g.quasis[0].value.raw.trim() === "")
              return "``";
            let D = u(c, y), v = [];
            for (let w = 0; w < p; w++) {
              let T = g.quasis[w], F = w === 0, A = w === p - 1, B = T.value.cooked, I = B.split(`
`), P = I.length, $ = D[w], f = P > 2 && I[0].trim() === "" && I[1].trim() === "", x = P > 2 && I[P - 1].trim() === "" && I[P - 2].trim() === "", m = I.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
              if (!A && /#[^\n\r]*$/.test(I[P - 1]))
                return null;
              let E = null;
              m ? E = l(I) : E = h(B, { parser: "graphql" }, { stripTrailingHardline: true }), E ? (E = r(E, false), !F && f && v.push(""), v.push(E), !A && x && v.push("")) : !F && !A && f && v.push(""), $ && v.push($);
            }
            return ["`", t([a, s(a, v)]), a, "`"];
          }
          __name(i, "i");
          function l(c) {
            let y = [], h = false, g = c.map((p) => p.trim());
            for (let [p, D] of g.entries())
              D !== "" && (g[p - 1] === "" && h ? y.push([a, D]) : y.push(D), h = true);
            return y.length === 0 ? null : s(a, y);
          }
          __name(l, "l");
          n.exports = i;
        } }), Bm = ee({ "src/language-js/embed/html.js"(e, n) {
          "use strict";
          re();
          var { builders: { indent: t, line: s, hardline: a, group: r }, utils: { mapDoc: u } } = qe(), { printTemplateExpressions: i, uncookTemplateElementValue: l } = jt(), c = 0;
          function y(h, g, p, D, v) {
            let { parser: w } = v, T = h.getValue(), F = c;
            c = c + 1 >>> 0;
            let A = /* @__PURE__ */ __name((d) => `PRETTIER_HTML_PLACEHOLDER_${d}_${F}_IN_JS`, "A"), B = T.quasis.map((d, C, _) => C === _.length - 1 ? d.value.cooked : d.value.cooked + A(C)).join(""), I = i(h, g);
            if (I.length === 0 && B.trim().length === 0)
              return "``";
            let P = new RegExp(A("(\\d+)"), "g"), $ = 0, f = p(B, { parser: w, __onHtmlRoot(d) {
              $ = d.children.length;
            } }, { stripTrailingHardline: true }), x = u(f, (d) => {
              if (typeof d != "string")
                return d;
              let C = [], _ = d.split(P);
              for (let b = 0; b < _.length; b++) {
                let N = _[b];
                if (b % 2 === 0) {
                  N && (N = l(N), D.__embeddedInHtml && (N = N.replace(/<\/(script)\b/gi, "<\\/$1")), C.push(N));
                  continue;
                }
                let k = Number(N);
                C.push(I[k]);
              }
              return C;
            }), m = /^\s/.test(B) ? " " : "", E = /\s$/.test(B) ? " " : "", o = D.htmlWhitespaceSensitivity === "ignore" ? a : m && E ? s : null;
            return r(o ? ["`", t([o, r(x)]), o, "`"] : ["`", m, $ > 1 ? t(r(x)) : r(x), E, "`"]);
          }
          __name(y, "y");
          n.exports = y;
        } }), Nm = ee({ "src/language-js/embed.js"(e, n) {
          "use strict";
          re();
          var { hasComment: t, CommentCheckFlags: s, isObjectProperty: a } = Ke(), r = xm(), u = bm(), i = Tm(), l = Bm();
          function c(f) {
            if (g(f) || w(f) || T(f) || p(f))
              return "css";
            if (B(f))
              return "graphql";
            if (P(f))
              return "html";
            if (D(f))
              return "angular";
            if (h(f))
              return "markdown";
          }
          __name(c, "c");
          function y(f, x, m, E) {
            let o = f.getValue();
            if (o.type !== "TemplateLiteral" || $(o))
              return;
            let d = c(f);
            if (!!d) {
              if (d === "markdown")
                return r(f, x, m);
              if (d === "css")
                return u(f, x, m);
              if (d === "graphql")
                return i(f, x, m);
              if (d === "html" || d === "angular")
                return l(f, x, m, E, { parser: d });
            }
          }
          __name(y, "y");
          function h(f) {
            let x = f.getValue(), m = f.getParentNode();
            return m && m.type === "TaggedTemplateExpression" && x.quasis.length === 1 && m.tag.type === "Identifier" && (m.tag.name === "md" || m.tag.name === "markdown");
          }
          __name(h, "h");
          function g(f) {
            let x = f.getValue(), m = f.getParentNode(), E = f.getParentNode(1);
            return E && x.quasis && m.type === "JSXExpressionContainer" && E.type === "JSXElement" && E.openingElement.name.name === "style" && E.openingElement.attributes.some((o) => o.name.name === "jsx") || m && m.type === "TaggedTemplateExpression" && m.tag.type === "Identifier" && m.tag.name === "css" || m && m.type === "TaggedTemplateExpression" && m.tag.type === "MemberExpression" && m.tag.object.name === "css" && (m.tag.property.name === "global" || m.tag.property.name === "resolve");
          }
          __name(g, "g");
          function p(f) {
            return f.match((x) => x.type === "TemplateLiteral", (x, m) => x.type === "ArrayExpression" && m === "elements", (x, m) => a(x) && x.key.type === "Identifier" && x.key.name === "styles" && m === "value", ...v);
          }
          __name(p, "p");
          function D(f) {
            return f.match((x) => x.type === "TemplateLiteral", (x, m) => a(x) && x.key.type === "Identifier" && x.key.name === "template" && m === "value", ...v);
          }
          __name(D, "D");
          var v = [(f, x) => f.type === "ObjectExpression" && x === "properties", (f, x) => f.type === "CallExpression" && f.callee.type === "Identifier" && f.callee.name === "Component" && x === "arguments", (f, x) => f.type === "Decorator" && x === "expression"];
          function w(f) {
            let x = f.getParentNode();
            if (!x || x.type !== "TaggedTemplateExpression")
              return false;
            let m = x.tag.type === "ParenthesizedExpression" ? x.tag.expression : x.tag;
            switch (m.type) {
              case "MemberExpression":
                return F(m.object) || A(m);
              case "CallExpression":
                return F(m.callee) || m.callee.type === "MemberExpression" && (m.callee.object.type === "MemberExpression" && (F(m.callee.object.object) || A(m.callee.object)) || m.callee.object.type === "CallExpression" && F(m.callee.object.callee));
              case "Identifier":
                return m.name === "css";
              default:
                return false;
            }
          }
          __name(w, "w");
          function T(f) {
            let x = f.getParentNode(), m = f.getParentNode(1);
            return m && x.type === "JSXExpressionContainer" && m.type === "JSXAttribute" && m.name.type === "JSXIdentifier" && m.name.name === "css";
          }
          __name(T, "T");
          function F(f) {
            return f.type === "Identifier" && f.name === "styled";
          }
          __name(F, "F");
          function A(f) {
            return /^[A-Z]/.test(f.object.name) && f.property.name === "extend";
          }
          __name(A, "A");
          function B(f) {
            let x = f.getValue(), m = f.getParentNode();
            return I(x, "GraphQL") || m && (m.type === "TaggedTemplateExpression" && (m.tag.type === "MemberExpression" && m.tag.object.name === "graphql" && m.tag.property.name === "experimental" || m.tag.type === "Identifier" && (m.tag.name === "gql" || m.tag.name === "graphql")) || m.type === "CallExpression" && m.callee.type === "Identifier" && m.callee.name === "graphql");
          }
          __name(B, "B");
          function I(f, x) {
            return t(f, s.Block | s.Leading, (m) => {
              let { value: E } = m;
              return E === ` ${x} `;
            });
          }
          __name(I, "I");
          function P(f) {
            return I(f.getValue(), "HTML") || f.match((x) => x.type === "TemplateLiteral", (x, m) => x.type === "TaggedTemplateExpression" && x.tag.type === "Identifier" && x.tag.name === "html" && m === "quasi");
          }
          __name(P, "P");
          function $(f) {
            let { quasis: x } = f;
            return x.some((m) => {
              let { value: { cooked: E } } = m;
              return E === null;
            });
          }
          __name($, "$");
          n.exports = y;
        } }), wm = ee({ "src/language-js/clean.js"(e, n) {
          "use strict";
          re();
          var t = Lt(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a = /* @__PURE__ */ __name((u) => {
            for (let i of u.quasis)
              delete i.value;
          }, "a");
          function r(u, i, l) {
            if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
              return null;
            if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((h) => h.name.name === "jsx"))
              for (let { type: h, expression: g } of i.children)
                h === "JSXExpressionContainer" && g.type === "TemplateLiteral" && a(g);
            u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
            let c = u.expression || u.callee;
            if (u.type === "Decorator" && c.type === "CallExpression" && c.callee.name === "Component" && c.arguments.length === 1) {
              let h = u.expression.arguments[0].properties;
              for (let [g, p] of i.expression.arguments[0].properties.entries())
                switch (h[g].key.name) {
                  case "styles":
                    p.value.type === "ArrayExpression" && a(p.value.elements[0]);
                    break;
                  case "template":
                    p.value.type === "TemplateLiteral" && a(p.value);
                    break;
                }
            }
            if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a(i.quasi), u.type === "TemplateLiteral") {
              var y;
              (((y = u.leadingComments) === null || y === void 0 ? void 0 : y.some((g) => t(g) && ["GraphQL", "HTML"].some((p) => g.value === ` ${p} `))) || l.type === "CallExpression" && l.callee.name === "graphql" || !u.leadingComments) && a(i);
            }
            if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
              return i.types[0];
          }
          __name(r, "r");
          r.ignoredProperties = s, n.exports = r;
        } }), Ma = {};
        zt(Ma, { EOL: () => kn, arch: () => _m, cpus: () => Ua, default: () => Ya, endianness: () => Ra, freemem: () => Ha, getNetworkInterfaces: () => Ka, hostname: () => $a, loadavg: () => Va, networkInterfaces: () => Xa, platform: () => Pm, release: () => za, tmpDir: () => Pn, tmpdir: () => In, totalmem: () => Ga, type: () => Ja, uptime: () => Wa });
        function Ra() {
          if (typeof br > "u") {
            var e = new ArrayBuffer(2), n = new Uint8Array(e), t = new Uint16Array(e);
            if (n[0] = 1, n[1] = 2, t[0] === 258)
              br = "BE";
            else if (t[0] === 513)
              br = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return br;
        }
        __name(Ra, "Ra");
        function $a() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        __name($a, "$a");
        function Va() {
          return [];
        }
        __name(Va, "Va");
        function Wa() {
          return 0;
        }
        __name(Wa, "Wa");
        function Ha() {
          return Number.MAX_VALUE;
        }
        __name(Ha, "Ha");
        function Ga() {
          return Number.MAX_VALUE;
        }
        __name(Ga, "Ga");
        function Ua() {
          return [];
        }
        __name(Ua, "Ua");
        function Ja() {
          return "Browser";
        }
        __name(Ja, "Ja");
        function za() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        __name(za, "za");
        function Xa() {
        }
        __name(Xa, "Xa");
        function Ka() {
        }
        __name(Ka, "Ka");
        function _m() {
          return "javascript";
        }
        __name(_m, "_m");
        function Pm() {
          return "browser";
        }
        __name(Pm, "Pm");
        function Pn() {
          return "/tmp";
        }
        __name(Pn, "Pn");
        var br, In, kn, Ya, Im = gt({ "node-modules-polyfills:os"() {
          re(), In = Pn, kn = `
`, Ya = { EOL: kn, tmpdir: In, tmpDir: Pn, networkInterfaces: Xa, getNetworkInterfaces: Ka, release: za, type: Ja, cpus: Ua, totalmem: Ga, freemem: Ha, uptime: Wa, loadavg: Va, hostname: $a, endianness: Ra };
        } }), km = ee({ "node-modules-polyfills-commonjs:os"(e, n) {
          re();
          var t = (Im(), ft(Ma));
          if (t && t.default) {
            n.exports = t.default;
            for (let s in t)
              n.exports[s] = t[s];
          } else
            t && (n.exports = t);
        } }), Lm = ee({ "node_modules/detect-newline/index.js"(e, n) {
          "use strict";
          re();
          var t = /* @__PURE__ */ __name((s) => {
            if (typeof s != "string")
              throw new TypeError("Expected a string");
            let a = s.match(/(?:\r?\n)/g) || [];
            if (a.length === 0)
              return;
            let r = a.filter((i) => i === `\r
`).length, u = a.length - r;
            return r > u ? `\r
` : `
`;
          }, "t");
          n.exports = t, n.exports.graceful = (s) => typeof s == "string" && t(s) || `
`;
        } }), jm = ee({ "node_modules/jest-docblock/build/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = p, e.parse = v, e.parseWithComments = w, e.print = T, e.strip = D;
          function n() {
            let A = km();
            return n = /* @__PURE__ */ __name(function() {
              return A;
            }, "n"), A;
          }
          __name(n, "n");
          function t() {
            let A = s(Lm());
            return t = /* @__PURE__ */ __name(function() {
              return A;
            }, "t"), A;
          }
          __name(t, "t");
          function s(A) {
            return A && A.__esModule ? A : { default: A };
          }
          __name(s, "s");
          var a = /\*\/$/, r = /^\/\*\*?/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, l = /^(\r?\n)+/, c = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, y = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, h = /(\r?\n|^) *\* ?/g, g = [];
          function p(A) {
            let B = A.match(u);
            return B ? B[0].trimLeft() : "";
          }
          __name(p, "p");
          function D(A) {
            let B = A.match(u);
            return B && B[0] ? A.substring(B[0].length) : A;
          }
          __name(D, "D");
          function v(A) {
            return w(A).pragmas;
          }
          __name(v, "v");
          function w(A) {
            let B = (0, t().default)(A) || n().EOL;
            A = A.replace(r, "").replace(a, "").replace(h, "$1");
            let I = "";
            for (; I !== A; )
              I = A, A = A.replace(c, `${B}$1 $2${B}`);
            A = A.replace(l, "").trimRight();
            let P = /* @__PURE__ */ Object.create(null), $ = A.replace(y, "").replace(l, "").trimRight(), f;
            for (; f = y.exec(A); ) {
              let x = f[2].replace(i, "");
              typeof P[f[1]] == "string" || Array.isArray(P[f[1]]) ? P[f[1]] = g.concat(P[f[1]], x) : P[f[1]] = x;
            }
            return { comments: $, pragmas: P };
          }
          __name(w, "w");
          function T(A) {
            let { comments: B = "", pragmas: I = {} } = A, P = (0, t().default)(B) || n().EOL, $ = "/**", f = " *", x = " */", m = Object.keys(I), E = m.map((d) => F(d, I[d])).reduce((d, C) => d.concat(C), []).map((d) => `${f} ${d}${P}`).join("");
            if (!B) {
              if (m.length === 0)
                return "";
              if (m.length === 1 && !Array.isArray(I[m[0]])) {
                let d = I[m[0]];
                return `${$} ${F(m[0], d)[0]}${x}`;
              }
            }
            let o = B.split(P).map((d) => `${f} ${d}`).join(P) + P;
            return $ + P + (B ? o : "") + (B && m.length ? f + P : "") + E + x;
          }
          __name(T, "T");
          function F(A, B) {
            return g.concat(B).map((I) => `@${A} ${I}`.trim());
          }
          __name(F, "F");
        } }), Om = ee({ "src/language-js/utils/get-shebang.js"(e, n) {
          "use strict";
          re();
          function t(s) {
            if (!s.startsWith("#!"))
              return "";
            let a = s.indexOf(`
`);
            return a === -1 ? s : s.slice(0, a);
          }
          __name(t, "t");
          n.exports = t;
        } }), Qa = ee({ "src/language-js/pragma.js"(e, n) {
          "use strict";
          re();
          var { parseWithComments: t, strip: s, extract: a, print: r } = jm(), { normalizeEndOfLine: u } = qn(), i = Om();
          function l(h) {
            let g = i(h);
            g && (h = h.slice(g.length + 1));
            let p = a(h), { pragmas: D, comments: v } = t(p);
            return { shebang: g, text: h, pragmas: D, comments: v };
          }
          __name(l, "l");
          function c(h) {
            let g = Object.keys(l(h).pragmas);
            return g.includes("prettier") || g.includes("format");
          }
          __name(c, "c");
          function y(h) {
            let { shebang: g, text: p, pragmas: D, comments: v } = l(h), w = s(p), T = r({ pragmas: Object.assign({ format: "" }, D), comments: v.trimStart() });
            return (g ? `${g}
` : "") + u(T) + (w.startsWith(`
`) ? `
` : `

`) + w;
          }
          __name(y, "y");
          n.exports = { hasPragma: c, insertPragma: y };
        } }), Za = ee({ "src/language-js/comments.js"(e, n) {
          "use strict";
          re();
          var { getLast: t, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a, getNextNonSpaceNonCommentCharacter: r, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: l, addDanglingComment: c, getNextNonSpaceNonCommentCharacterIndex: y, isNonEmptyArray: h } = Ge(), { getFunctionParameters: g, isPrettierIgnoreComment: p, isJsxNode: D, hasFlowShorthandAnnotationComment: v, hasFlowAnnotationComment: w, hasIgnoreComment: T, isCallLikeExpression: F, getCallArguments: A, isCallExpression: B, isMemberExpression: I, isObjectProperty: P, isLineComment: $, getComments: f, CommentCheckFlags: x, markerForIfWithoutBlockAndSameLineComment: m } = Ke(), { locStart: E, locEnd: o } = it(), d = Lt();
          function C(ye) {
            return [ce, ae, L, M, q, J, K, ge, Z, fe, Ce, _e, Q, Ae, z].some((S) => S(ye));
          }
          __name(C, "C");
          function _(ye) {
            return [R, ae, Y, Ce, M, q, J, K, Ae, H, ne, fe, ie, z, de].some((S) => S(ye));
          }
          __name(_, "_");
          function b(ye) {
            return [ce, M, q, V, oe, Q, fe, X, W, U, z, ve].some((S) => S(ye));
          }
          __name(b, "b");
          function N(ye, S) {
            let G = (ye.body || ye.properties).find((te) => {
              let { type: Ee } = te;
              return Ee !== "EmptyStatement";
            });
            G ? i(G, S) : c(ye, S);
          }
          __name(N, "N");
          function k(ye, S) {
            ye.type === "BlockStatement" ? N(ye, S) : i(ye, S);
          }
          __name(k, "k");
          function R(ye) {
            let { comment: S, followingNode: G } = ye;
            return G && Be(S) ? (i(G, S), true) : false;
          }
          __name(R, "R");
          function M(ye) {
            let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee, text: Re } = ye;
            if ((te == null ? void 0 : te.type) !== "IfStatement" || !Ee)
              return false;
            if (r(Re, S, o) === ")")
              return l(G, S), true;
            if (G === te.consequent && Ee === te.alternate) {
              if (G.type === "BlockStatement")
                l(G, S);
              else {
                let Pe = S.type === "SingleLine" || S.loc.start.line === S.loc.end.line, Fe = S.loc.start.line === G.loc.start.line;
                Pe && Fe ? c(G, S, m) : c(te, S);
              }
              return true;
            }
            return Ee.type === "BlockStatement" ? (N(Ee, S), true) : Ee.type === "IfStatement" ? (k(Ee.consequent, S), true) : te.consequent === Ee ? (i(Ee, S), true) : false;
          }
          __name(M, "M");
          function q(ye) {
            let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee, text: Re } = ye;
            return (te == null ? void 0 : te.type) !== "WhileStatement" || !Ee ? false : r(Re, S, o) === ")" ? (l(G, S), true) : Ee.type === "BlockStatement" ? (N(Ee, S), true) : te.body === Ee ? (i(Ee, S), true) : false;
          }
          __name(q, "q");
          function J(ye) {
            let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee } = ye;
            return (te == null ? void 0 : te.type) !== "TryStatement" && (te == null ? void 0 : te.type) !== "CatchClause" || !Ee ? false : te.type === "CatchClause" && G ? (l(G, S), true) : Ee.type === "BlockStatement" ? (N(Ee, S), true) : Ee.type === "TryStatement" ? (k(Ee.finalizer, S), true) : Ee.type === "CatchClause" ? (k(Ee.body, S), true) : false;
          }
          __name(J, "J");
          function L(ye) {
            let { comment: S, enclosingNode: G, followingNode: te } = ye;
            return I(G) && (te == null ? void 0 : te.type) === "Identifier" ? (i(G, S), true) : false;
          }
          __name(L, "L");
          function Y(ye) {
            let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee, text: Re } = ye, Te = G && !u(Re, o(G), E(S));
            return (!G || !Te) && ((te == null ? void 0 : te.type) === "ConditionalExpression" || (te == null ? void 0 : te.type) === "TSConditionalType") && Ee ? (i(Ee, S), true) : false;
          }
          __name(Y, "Y");
          function V(ye) {
            let { comment: S, precedingNode: G, enclosingNode: te } = ye;
            return P(te) && te.shorthand && te.key === G && te.value.type === "AssignmentPattern" ? (l(te.value.left, S), true) : false;
          }
          __name(V, "V");
          var O = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
          function K(ye) {
            let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee } = ye;
            if (O.has(te == null ? void 0 : te.type)) {
              if (h(te.decorators) && !(Ee && Ee.type === "Decorator"))
                return l(t(te.decorators), S), true;
              if (te.body && Ee === te.body)
                return N(te.body, S), true;
              if (Ee) {
                if (te.superClass && Ee === te.superClass && G && (G === te.id || G === te.typeParameters))
                  return l(G, S), true;
                for (let Re of ["implements", "extends", "mixins"])
                  if (te[Re] && Ee === te[Re][0])
                    return G && (G === te.id || G === te.typeParameters || G === te.superClass) ? l(G, S) : c(te, S, Re), true;
              }
            }
            return false;
          }
          __name(K, "K");
          var se = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition"]);
          function Q(ye) {
            let { comment: S, precedingNode: G, enclosingNode: te, text: Ee } = ye;
            return te && G && r(Ee, S, o) === "(" && (te.type === "Property" || te.type === "TSDeclareMethod" || te.type === "TSAbstractMethodDefinition") && G.type === "Identifier" && te.key === G && r(Ee, G, o) !== ":" || (G == null ? void 0 : G.type) === "Decorator" && se.has(te == null ? void 0 : te.type) ? (l(G, S), true) : false;
          }
          __name(Q, "Q");
          var le = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
          function W(ye) {
            let { comment: S, precedingNode: G, enclosingNode: te, text: Ee } = ye;
            return r(Ee, S, o) !== "(" ? false : G && le.has(te == null ? void 0 : te.type) ? (l(G, S), true) : false;
          }
          __name(W, "W");
          function X(ye) {
            let { comment: S, enclosingNode: G, text: te } = ye;
            if ((G == null ? void 0 : G.type) !== "ArrowFunctionExpression")
              return false;
            let Ee = y(te, S, o);
            return Ee !== false && te.slice(Ee, Ee + 2) === "=>" ? (c(G, S), true) : false;
          }
          __name(X, "X");
          function oe(ye) {
            let { comment: S, enclosingNode: G, text: te } = ye;
            return r(te, S, o) !== ")" ? false : G && (De(G) && g(G).length === 0 || F(G) && A(G).length === 0) ? (c(G, S), true) : ((G == null ? void 0 : G.type) === "MethodDefinition" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && g(G.value).length === 0 ? (c(G.value, S), true) : false;
          }
          __name(oe, "oe");
          function ae(ye) {
            let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee, text: Re } = ye;
            if ((G == null ? void 0 : G.type) === "FunctionTypeParam" && (te == null ? void 0 : te.type) === "FunctionTypeAnnotation" && (Ee == null ? void 0 : Ee.type) !== "FunctionTypeParam" || ((G == null ? void 0 : G.type) === "Identifier" || (G == null ? void 0 : G.type) === "AssignmentPattern") && te && De(te) && r(Re, S, o) === ")")
              return l(G, S), true;
            if ((te == null ? void 0 : te.type) === "FunctionDeclaration" && (Ee == null ? void 0 : Ee.type) === "BlockStatement") {
              let Te = (() => {
                let Pe = g(te);
                if (Pe.length > 0)
                  return a(Re, o(t(Pe)));
                let Fe = a(Re, o(te.id));
                return Fe !== false && a(Re, Fe + 1);
              })();
              if (E(S) > Te)
                return N(Ee, S), true;
            }
            return false;
          }
          __name(ae, "ae");
          function Ae(ye) {
            let { comment: S, enclosingNode: G } = ye;
            return (G == null ? void 0 : G.type) === "LabeledStatement" ? (i(G, S), true) : false;
          }
          __name(Ae, "Ae");
          function z(ye) {
            let { comment: S, enclosingNode: G } = ye;
            return ((G == null ? void 0 : G.type) === "ContinueStatement" || (G == null ? void 0 : G.type) === "BreakStatement") && !G.label ? (l(G, S), true) : false;
          }
          __name(z, "z");
          function H(ye) {
            let { comment: S, precedingNode: G, enclosingNode: te } = ye;
            return B(te) && G && te.callee === G && te.arguments.length > 0 ? (i(te.arguments[0], S), true) : false;
          }
          __name(H, "H");
          function Z(ye) {
            let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee } = ye;
            return (te == null ? void 0 : te.type) === "UnionTypeAnnotation" || (te == null ? void 0 : te.type) === "TSUnionType" ? (p(S) && (Ee.prettierIgnore = true, S.unignore = true), G ? (l(G, S), true) : false) : (((Ee == null ? void 0 : Ee.type) === "UnionTypeAnnotation" || (Ee == null ? void 0 : Ee.type) === "TSUnionType") && p(S) && (Ee.types[0].prettierIgnore = true, S.unignore = true), false);
          }
          __name(Z, "Z");
          function ne(ye) {
            let { comment: S, enclosingNode: G } = ye;
            return P(G) ? (i(G, S), true) : false;
          }
          __name(ne, "ne");
          function fe(ye) {
            let { comment: S, enclosingNode: G, followingNode: te, ast: Ee, isLastComment: Re } = ye;
            return Ee && Ee.body && Ee.body.length === 0 ? (Re ? c(Ee, S) : i(Ee, S), true) : (G == null ? void 0 : G.type) === "Program" && (G == null ? void 0 : G.body.length) === 0 && !h(G.directives) ? (Re ? c(G, S) : i(G, S), true) : (te == null ? void 0 : te.type) === "Program" && (te == null ? void 0 : te.body.length) === 0 && (G == null ? void 0 : G.type) === "ModuleExpression" ? (c(te, S), true) : false;
          }
          __name(fe, "fe");
          function ge(ye) {
            let { comment: S, enclosingNode: G } = ye;
            return (G == null ? void 0 : G.type) === "ForInStatement" || (G == null ? void 0 : G.type) === "ForOfStatement" ? (i(G, S), true) : false;
          }
          __name(ge, "ge");
          function Ce(ye) {
            let { comment: S, precedingNode: G, enclosingNode: te, text: Ee } = ye;
            if ((te == null ? void 0 : te.type) === "ImportSpecifier" || (te == null ? void 0 : te.type) === "ExportSpecifier")
              return i(te, S), true;
            let Re = (G == null ? void 0 : G.type) === "ImportSpecifier" && (te == null ? void 0 : te.type) === "ImportDeclaration", Te = (G == null ? void 0 : G.type) === "ExportSpecifier" && (te == null ? void 0 : te.type) === "ExportNamedDeclaration";
            return (Re || Te) && s(Ee, o(S)) ? (l(G, S), true) : false;
          }
          __name(Ce, "Ce");
          function _e(ye) {
            let { comment: S, enclosingNode: G } = ye;
            return (G == null ? void 0 : G.type) === "AssignmentPattern" ? (i(G, S), true) : false;
          }
          __name(_e, "_e");
          var Oe = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), pe = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
          function ie(ye) {
            let { comment: S, enclosingNode: G, followingNode: te } = ye;
            return Oe.has(G == null ? void 0 : G.type) && te && (pe.has(te.type) || d(S)) ? (i(te, S), true) : false;
          }
          __name(ie, "ie");
          function ve(ye) {
            let { comment: S, enclosingNode: G, followingNode: te, text: Ee } = ye;
            return !te && ((G == null ? void 0 : G.type) === "TSMethodSignature" || (G == null ? void 0 : G.type) === "TSDeclareFunction" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && r(Ee, S, o) === ";" ? (l(G, S), true) : false;
          }
          __name(ve, "ve");
          function ce(ye) {
            let { comment: S, enclosingNode: G, followingNode: te } = ye;
            if (p(S) && (G == null ? void 0 : G.type) === "TSMappedType" && (te == null ? void 0 : te.type) === "TSTypeParameter" && te.constraint)
              return G.prettierIgnore = true, S.unignore = true, true;
          }
          __name(ce, "ce");
          function U(ye) {
            let { comment: S, precedingNode: G, enclosingNode: te, followingNode: Ee } = ye;
            return (te == null ? void 0 : te.type) !== "TSMappedType" ? false : (Ee == null ? void 0 : Ee.type) === "TSTypeParameter" && Ee.name ? (i(Ee.name, S), true) : (G == null ? void 0 : G.type) === "TSTypeParameter" && G.constraint ? (l(G.constraint, S), true) : false;
          }
          __name(U, "U");
          function de(ye) {
            let { comment: S, enclosingNode: G, followingNode: te } = ye;
            return !G || G.type !== "SwitchCase" || G.test ? false : (te.type === "BlockStatement" && $(S) ? N(te, S) : c(G, S), true);
          }
          __name(de, "de");
          function De(ye) {
            return ye.type === "ArrowFunctionExpression" || ye.type === "FunctionExpression" || ye.type === "FunctionDeclaration" || ye.type === "ObjectMethod" || ye.type === "ClassMethod" || ye.type === "TSDeclareFunction" || ye.type === "TSCallSignatureDeclaration" || ye.type === "TSConstructSignatureDeclaration" || ye.type === "TSMethodSignature" || ye.type === "TSConstructorType" || ye.type === "TSFunctionType" || ye.type === "TSDeclareMethod";
          }
          __name(De, "De");
          function he(ye, S) {
            if ((S.parser === "typescript" || S.parser === "flow" || S.parser === "acorn" || S.parser === "espree" || S.parser === "meriyah" || S.parser === "__babel_estree") && ye.type === "MethodDefinition" && ye.value && ye.value.type === "FunctionExpression" && g(ye.value).length === 0 && !ye.value.returnType && !h(ye.value.typeParameters) && ye.value.body)
              return [...ye.decorators || [], ye.key, ye.value.body];
          }
          __name(he, "he");
          function Be(ye) {
            return d(ye) && ye.value[0] === "*" && /@type\b/.test(ye.value);
          }
          __name(Be, "Be");
          function Se(ye) {
            let S = ye.getValue(), G = ye.getParentNode(), te = /* @__PURE__ */ __name((Ee) => w(f(Ee, x.Leading)) || w(f(Ee, x.Trailing)), "te");
            return (S && (D(S) || v(S) || B(G) && te(S)) || G && (G.type === "JSXSpreadAttribute" || G.type === "JSXSpreadChild" || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType" || (G.type === "ClassDeclaration" || G.type === "ClassExpression") && G.superClass === S)) && (!T(ye) || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType");
          }
          __name(Se, "Se");
          n.exports = { handleOwnLineComment: C, handleEndOfLineComment: _, handleRemainingComment: b, isTypeCastComment: Be, getCommentChildNodes: he, willPrintOwnComments: Se };
        } }), Ot = ee({ "src/language-js/needs-parens.js"(e, n) {
          "use strict";
          re();
          var t = lt(), s = $n(), { getFunctionParameters: a, getLeftSidePathName: r, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: l, isBitwiseOperator: c, startsWithNoLookaheadToken: y, shouldFlatten: h, getPrecedence: g, isCallExpression: p, isMemberExpression: D, isObjectProperty: v, isTSTypeExpression: w } = Ke();
          function T(f, x) {
            let m = f.getParentNode();
            if (!m)
              return false;
            let E = f.getName(), o = f.getNode();
            if (x.__isInHtmlInterpolation && !x.bracketSpacing && I(o) && P(f))
              return true;
            if (F(o))
              return false;
            if (x.parser !== "flow" && u(f.getValue()))
              return true;
            if (o.type === "Identifier")
              return !!(o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name) || E === "left" && o.name === "async" && m.type === "ForOfStatement" && !m.await);
            switch (m.type) {
              case "ParenthesizedExpression":
                return false;
              case "ClassDeclaration":
              case "ClassExpression": {
                if (E === "superClass" && (o.type === "ArrowFunctionExpression" || o.type === "AssignmentExpression" || o.type === "AwaitExpression" || o.type === "BinaryExpression" || o.type === "ConditionalExpression" || o.type === "LogicalExpression" || o.type === "NewExpression" || o.type === "ObjectExpression" || o.type === "SequenceExpression" || o.type === "TaggedTemplateExpression" || o.type === "UnaryExpression" || o.type === "UpdateExpression" || o.type === "YieldExpression" || o.type === "TSNonNullExpression"))
                  return true;
                break;
              }
              case "ExportDefaultDeclaration":
                return $(f, x) || o.type === "SequenceExpression";
              case "Decorator": {
                if (E === "expression") {
                  let d = false, C = false, _ = o;
                  for (; _; )
                    switch (_.type) {
                      case "MemberExpression":
                        C = true, _ = _.object;
                        break;
                      case "CallExpression":
                        if (C || d)
                          return x.parser !== "typescript";
                        d = true, _ = _.callee;
                        break;
                      case "Identifier":
                        return false;
                      case "TaggedTemplateExpression":
                        return x.parser !== "typescript";
                      default:
                        return true;
                    }
                  return true;
                }
                break;
              }
              case "ExpressionStatement": {
                if (y(o, true))
                  return true;
                break;
              }
              case "ArrowFunctionExpression": {
                if (E === "body" && o.type !== "SequenceExpression" && y(o, false))
                  return true;
                break;
              }
            }
            switch (o.type) {
              case "UpdateExpression":
                if (m.type === "UnaryExpression")
                  return o.prefix && (o.operator === "++" && m.operator === "+" || o.operator === "--" && m.operator === "-");
              case "UnaryExpression":
                switch (m.type) {
                  case "UnaryExpression":
                    return o.operator === m.operator && (o.operator === "+" || o.operator === "-");
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return E === "object";
                  case "TaggedTemplateExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return E === "callee";
                  case "BinaryExpression":
                    return E === "left" && m.operator === "**";
                  case "TSNonNullExpression":
                    return true;
                  default:
                    return false;
                }
              case "BinaryExpression": {
                if (m.type === "UpdateExpression" || o.operator === "in" && A(f))
                  return true;
                if (o.operator === "|>" && o.extra && o.extra.parenthesized) {
                  let d = f.getParentNode(1);
                  if (d.type === "BinaryExpression" && d.operator === "|>")
                    return true;
                }
              }
              case "TSTypeAssertion":
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "LogicalExpression":
                switch (m.type) {
                  case "TSSatisfiesExpression":
                  case "TSAsExpression":
                    return !w(o);
                  case "ConditionalExpression":
                    return w(o);
                  case "CallExpression":
                  case "NewExpression":
                  case "OptionalCallExpression":
                    return E === "callee";
                  case "ClassExpression":
                  case "ClassDeclaration":
                    return E === "superClass";
                  case "TSTypeAssertion":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "JSXSpreadAttribute":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BindExpression":
                  case "AwaitExpression":
                  case "TSNonNullExpression":
                  case "UpdateExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return E === "object";
                  case "AssignmentExpression":
                  case "AssignmentPattern":
                    return E === "left" && (o.type === "TSTypeAssertion" || w(o));
                  case "LogicalExpression":
                    if (o.type === "LogicalExpression")
                      return m.operator !== o.operator;
                  case "BinaryExpression": {
                    let { operator: d, type: C } = o;
                    if (!d && C !== "TSTypeAssertion")
                      return true;
                    let _ = g(d), b = m.operator, N = g(b);
                    return N > _ || E === "right" && N === _ || N === _ && !h(b, d) ? true : N < _ && d === "%" ? b === "+" || b === "-" : !!c(b);
                  }
                  default:
                    return false;
                }
              case "SequenceExpression":
                switch (m.type) {
                  case "ReturnStatement":
                    return false;
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return E !== "expression";
                  case "ArrowFunctionExpression":
                    return E !== "body";
                  default:
                    return true;
                }
              case "YieldExpression":
                if (m.type === "UnaryExpression" || m.type === "AwaitExpression" || w(m) || m.type === "TSNonNullExpression")
                  return true;
              case "AwaitExpression":
                switch (m.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return E === "object";
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return E === "callee";
                  case "ConditionalExpression":
                    return E === "test";
                  case "BinaryExpression":
                    return !(!o.argument && m.operator === "|>");
                  default:
                    return false;
                }
              case "TSConditionalType":
                if (E === "extendsType" && m.type === "TSConditionalType")
                  return true;
              case "TSFunctionType":
              case "TSConstructorType":
                if (E === "extendsType" && m.type === "TSConditionalType") {
                  let d = (o.returnType || o.typeAnnotation).typeAnnotation;
                  if (d.type === "TSInferType" && d.typeParameter.constraint)
                    return true;
                }
                if (E === "checkType" && m.type === "TSConditionalType")
                  return true;
              case "TSUnionType":
              case "TSIntersectionType":
                if ((m.type === "TSUnionType" || m.type === "TSIntersectionType") && m.types.length > 1 && (!o.types || o.types.length > 1))
                  return true;
              case "TSInferType":
                if (o.type === "TSInferType" && m.type === "TSRestType")
                  return false;
              case "TSTypeOperator":
                return m.type === "TSArrayType" || m.type === "TSOptionalType" || m.type === "TSRestType" || E === "objectType" && m.type === "TSIndexedAccessType" || m.type === "TSTypeOperator" || m.type === "TSTypeAnnotation" && f.getParentNode(1).type.startsWith("TSJSDoc");
              case "ArrayTypeAnnotation":
                return m.type === "NullableTypeAnnotation";
              case "IntersectionTypeAnnotation":
              case "UnionTypeAnnotation":
                return m.type === "ArrayTypeAnnotation" || m.type === "NullableTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "UnionTypeAnnotation" || E === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
              case "NullableTypeAnnotation":
                return m.type === "ArrayTypeAnnotation" || E === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
              case "FunctionTypeAnnotation": {
                let d = m.type === "NullableTypeAnnotation" ? f.getParentNode(1) : m;
                return d.type === "UnionTypeAnnotation" || d.type === "IntersectionTypeAnnotation" || d.type === "ArrayTypeAnnotation" || E === "objectType" && (d.type === "IndexedAccessType" || d.type === "OptionalIndexedAccessType") || d.type === "NullableTypeAnnotation" || m.type === "FunctionTypeParam" && m.name === null && a(o).some((C) => C.typeAnnotation && C.typeAnnotation.type === "NullableTypeAnnotation");
              }
              case "OptionalIndexedAccessType":
                return E === "objectType" && m.type === "IndexedAccessType";
              case "TypeofTypeAnnotation":
                return E === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
              case "StringLiteral":
              case "NumericLiteral":
              case "Literal":
                if (typeof o.value == "string" && m.type === "ExpressionStatement" && !m.directive) {
                  let d = f.getParentNode(1);
                  return d.type === "Program" || d.type === "BlockStatement";
                }
                return E === "object" && m.type === "MemberExpression" && typeof o.value == "number";
              case "AssignmentExpression": {
                let d = f.getParentNode(1);
                return E === "body" && m.type === "ArrowFunctionExpression" ? true : E === "key" && (m.type === "ClassProperty" || m.type === "PropertyDefinition") && m.computed || (E === "init" || E === "update") && m.type === "ForStatement" ? false : m.type === "ExpressionStatement" ? o.left.type === "ObjectPattern" : !(E === "key" && m.type === "TSPropertySignature" || m.type === "AssignmentExpression" || m.type === "SequenceExpression" && d && d.type === "ForStatement" && (d.init === m || d.update === m) || E === "value" && m.type === "Property" && d && d.type === "ObjectPattern" && d.properties.includes(m) || m.type === "NGChainedExpression");
              }
              case "ConditionalExpression":
                switch (m.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "NGPipeExpression":
                  case "ExportDefaultDeclaration":
                  case "AwaitExpression":
                  case "JSXSpreadAttribute":
                  case "TSTypeAssertion":
                  case "TypeCastExpression":
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return E === "callee";
                  case "ConditionalExpression":
                    return E === "test";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return E === "object";
                  default:
                    return false;
                }
              case "FunctionExpression":
                switch (m.type) {
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return E === "callee";
                  case "TaggedTemplateExpression":
                    return true;
                  default:
                    return false;
                }
              case "ArrowFunctionExpression":
                switch (m.type) {
                  case "BinaryExpression":
                    return m.operator !== "|>" || o.extra && o.extra.parenthesized;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return E === "callee";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return E === "object";
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "AwaitExpression":
                  case "TSTypeAssertion":
                    return true;
                  case "ConditionalExpression":
                    return E === "test";
                  default:
                    return false;
                }
              case "ClassExpression":
                if (s(o.decorators))
                  return true;
                switch (m.type) {
                  case "NewExpression":
                    return E === "callee";
                  default:
                    return false;
                }
              case "OptionalMemberExpression":
              case "OptionalCallExpression": {
                let d = f.getParentNode(1);
                if (E === "object" && m.type === "MemberExpression" || E === "callee" && (m.type === "CallExpression" || m.type === "NewExpression") || m.type === "TSNonNullExpression" && d.type === "MemberExpression" && d.object === m)
                  return true;
              }
              case "CallExpression":
              case "MemberExpression":
              case "TaggedTemplateExpression":
              case "TSNonNullExpression":
                if (E === "callee" && (m.type === "BindExpression" || m.type === "NewExpression")) {
                  let d = o;
                  for (; d; )
                    switch (d.type) {
                      case "CallExpression":
                      case "OptionalCallExpression":
                        return true;
                      case "MemberExpression":
                      case "OptionalMemberExpression":
                      case "BindExpression":
                        d = d.object;
                        break;
                      case "TaggedTemplateExpression":
                        d = d.tag;
                        break;
                      case "TSNonNullExpression":
                        d = d.expression;
                        break;
                      default:
                        return false;
                    }
                }
                return false;
              case "BindExpression":
                return E === "callee" && (m.type === "BindExpression" || m.type === "NewExpression") || E === "object" && D(m);
              case "NGPipeExpression":
                return !(m.type === "NGRoot" || m.type === "NGMicrosyntaxExpression" || m.type === "ObjectProperty" && !(o.extra && o.extra.parenthesized) || m.type === "ArrayExpression" || p(m) && m.arguments[E] === o || E === "right" && m.type === "NGPipeExpression" || E === "property" && m.type === "MemberExpression" || m.type === "AssignmentExpression");
              case "JSXFragment":
              case "JSXElement":
                return E === "callee" || E === "left" && m.type === "BinaryExpression" && m.operator === "<" || m.type !== "ArrayExpression" && m.type !== "ArrowFunctionExpression" && m.type !== "AssignmentExpression" && m.type !== "AssignmentPattern" && m.type !== "BinaryExpression" && m.type !== "NewExpression" && m.type !== "ConditionalExpression" && m.type !== "ExpressionStatement" && m.type !== "JsExpressionRoot" && m.type !== "JSXAttribute" && m.type !== "JSXElement" && m.type !== "JSXExpressionContainer" && m.type !== "JSXFragment" && m.type !== "LogicalExpression" && !p(m) && !v(m) && m.type !== "ReturnStatement" && m.type !== "ThrowStatement" && m.type !== "TypeCastExpression" && m.type !== "VariableDeclarator" && m.type !== "YieldExpression";
              case "TypeAnnotation":
                return E === "returnType" && m.type === "ArrowFunctionExpression" && B(o);
            }
            return false;
          }
          __name(T, "T");
          function F(f) {
            return f.type === "BlockStatement" || f.type === "BreakStatement" || f.type === "ClassBody" || f.type === "ClassDeclaration" || f.type === "ClassMethod" || f.type === "ClassProperty" || f.type === "PropertyDefinition" || f.type === "ClassPrivateProperty" || f.type === "ContinueStatement" || f.type === "DebuggerStatement" || f.type === "DeclareClass" || f.type === "DeclareExportAllDeclaration" || f.type === "DeclareExportDeclaration" || f.type === "DeclareFunction" || f.type === "DeclareInterface" || f.type === "DeclareModule" || f.type === "DeclareModuleExports" || f.type === "DeclareVariable" || f.type === "DoWhileStatement" || f.type === "EnumDeclaration" || f.type === "ExportAllDeclaration" || f.type === "ExportDefaultDeclaration" || f.type === "ExportNamedDeclaration" || f.type === "ExpressionStatement" || f.type === "ForInStatement" || f.type === "ForOfStatement" || f.type === "ForStatement" || f.type === "FunctionDeclaration" || f.type === "IfStatement" || f.type === "ImportDeclaration" || f.type === "InterfaceDeclaration" || f.type === "LabeledStatement" || f.type === "MethodDefinition" || f.type === "ReturnStatement" || f.type === "SwitchStatement" || f.type === "ThrowStatement" || f.type === "TryStatement" || f.type === "TSDeclareFunction" || f.type === "TSEnumDeclaration" || f.type === "TSImportEqualsDeclaration" || f.type === "TSInterfaceDeclaration" || f.type === "TSModuleDeclaration" || f.type === "TSNamespaceExportDeclaration" || f.type === "TypeAlias" || f.type === "VariableDeclaration" || f.type === "WhileStatement" || f.type === "WithStatement";
          }
          __name(F, "F");
          function A(f) {
            let x = 0, m = f.getValue();
            for (; m; ) {
              let E = f.getParentNode(x++);
              if (E && E.type === "ForStatement" && E.init === m)
                return true;
              m = E;
            }
            return false;
          }
          __name(A, "A");
          function B(f) {
            return l(f, (x) => x.type === "ObjectTypeAnnotation" && l(x, (m) => m.type === "FunctionTypeAnnotation" || void 0) || void 0);
          }
          __name(B, "B");
          function I(f) {
            switch (f.type) {
              case "ObjectExpression":
                return true;
              default:
                return false;
            }
          }
          __name(I, "I");
          function P(f) {
            let x = f.getValue(), m = f.getParentNode(), E = f.getName();
            switch (m.type) {
              case "NGPipeExpression":
                if (typeof E == "number" && m.arguments[E] === x && m.arguments.length - 1 === E)
                  return f.callParent(P);
                break;
              case "ObjectProperty":
                if (E === "value") {
                  let o = f.getParentNode(1);
                  return t(o.properties) === m;
                }
                break;
              case "BinaryExpression":
              case "LogicalExpression":
                if (E === "right")
                  return f.callParent(P);
                break;
              case "ConditionalExpression":
                if (E === "alternate")
                  return f.callParent(P);
                break;
              case "UnaryExpression":
                if (m.prefix)
                  return f.callParent(P);
                break;
            }
            return false;
          }
          __name(P, "P");
          function $(f, x) {
            let m = f.getValue(), E = f.getParentNode();
            return m.type === "FunctionExpression" || m.type === "ClassExpression" ? E.type === "ExportDefaultDeclaration" || !T(f, x) : !i(m) || E.type !== "ExportDefaultDeclaration" && T(f, x) ? false : f.call((o) => $(o, x), ...r(f, m));
          }
          __name($, "$");
          n.exports = T;
        } }), eo = ee({ "src/language-js/print-preprocess.js"(e, n) {
          "use strict";
          re();
          function t(s, a) {
            switch (a.parser) {
              case "json":
              case "json5":
              case "json-stringify":
              case "__js_expression":
              case "__vue_expression":
              case "__vue_ts_expression":
                return Object.assign(Object.assign({}, s), {}, { type: a.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: a.rootMarker });
              default:
                return s;
            }
          }
          __name(t, "t");
          n.exports = t;
        } }), qm = ee({ "src/language-js/print/html-binding.js"(e, n) {
          "use strict";
          re();
          var { builders: { join: t, line: s, group: a, softline: r, indent: u } } = qe();
          function i(c, y, h) {
            let g = c.getValue();
            if (y.__onHtmlBindingRoot && c.getName() === null && y.__onHtmlBindingRoot(g, y), g.type === "File") {
              if (y.__isVueForBindingLeft)
                return c.call((p) => {
                  let D = t([",", s], p.map(h, "params")), { params: v } = p.getValue();
                  return v.length === 1 ? D : ["(", u([r, a(D)]), r, ")"];
                }, "program", "body", 0);
              if (y.__isVueBindings)
                return c.call((p) => t([",", s], p.map(h, "params")), "program", "body", 0);
            }
          }
          __name(i, "i");
          function l(c) {
            switch (c.type) {
              case "MemberExpression":
                switch (c.property.type) {
                  case "Identifier":
                  case "NumericLiteral":
                  case "StringLiteral":
                    return l(c.object);
                }
                return false;
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          __name(l, "l");
          n.exports = { isVueEventBindingExpression: l, printHtmlBinding: i };
        } }), Jn = ee({ "src/language-js/print/binaryish.js"(e, n) {
          "use strict";
          re();
          var { printComments: t } = et(), { getLast: s } = Ge(), { builders: { join: a, line: r, softline: u, group: i, indent: l, align: c, indentIfBreak: y }, utils: { cleanDoc: h, getDocParts: g, isConcat: p } } = qe(), { hasLeadingOwnLineComment: D, isBinaryish: v, isJsxNode: w, shouldFlatten: T, hasComment: F, CommentCheckFlags: A, isCallExpression: B, isMemberExpression: I, isObjectProperty: P, isEnabledHackPipeline: $ } = Ke(), f = 0;
          function x(o, d, C) {
            let _ = o.getValue(), b = o.getParentNode(), N = o.getParentNode(1), k = _ !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), R = $(d) && _.operator === "|>", M = m(o, C, d, false, k);
            if (k)
              return M;
            if (R)
              return i(M);
            if (B(b) && b.callee === _ || b.type === "UnaryExpression" || I(b) && !b.computed)
              return i([l([u, ...M]), u]);
            let q = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && N.type === "JSXAttribute" || _.operator !== "|" && b.type === "JsExpressionRoot" || _.type !== "NGPipeExpression" && (b.type === "NGRoot" && d.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && N.type === "NGMicrosyntax" && N.body.length === 1) || _ === b.body && b.type === "ArrowFunctionExpression" || _ !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && N.type !== "ReturnStatement" && N.type !== "ThrowStatement" && !B(N) || b.type === "TemplateLiteral", J = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), L = v(_.left) && T(_.operator, _.left.operator);
            if (q || E(_) && !L || !E(_) && J)
              return i(M);
            if (M.length === 0)
              return "";
            let Y = w(_.right), V = M.findIndex((W) => typeof W != "string" && !Array.isArray(W) && W.type === "group"), O = M.slice(0, V === -1 ? 1 : V + 1), K = M.slice(O.length, Y ? -1 : void 0), se = Symbol("logicalChain-" + ++f), Q = i([...O, l(K)], { id: se });
            if (!Y)
              return Q;
            let le = s(M);
            return i([Q, y(le, { groupId: se })]);
          }
          __name(x, "x");
          function m(o, d, C, _, b) {
            let N = o.getValue();
            if (!v(N))
              return [i(d())];
            let k = [];
            T(N.operator, N.left.operator) ? k = o.call((K) => m(K, d, C, true, b), "left") : k.push(i(d("left")));
            let R = E(N), M = (N.operator === "|>" || N.type === "NGPipeExpression" || N.operator === "|" && C.parser === "__vue_expression") && !D(C.originalText, N.right), q = N.type === "NGPipeExpression" ? "|" : N.operator, J = N.type === "NGPipeExpression" && N.arguments.length > 0 ? i(l([r, ": ", a([r, ": "], o.map(d, "arguments").map((K) => c(2, i(K))))])) : "", L;
            if (R)
              L = [q, " ", d("right"), J];
            else {
              let se = $(C) && q === "|>" ? o.call((Q) => m(Q, d, C, true, b), "right") : d("right");
              L = [M ? r : "", q, M ? " " : r, se, J];
            }
            let Y = o.getParentNode(), V = F(N.left, A.Trailing | A.Line), O = V || !(b && N.type === "LogicalExpression") && Y.type !== N.type && N.left.type !== N.type && N.right.type !== N.type;
            if (k.push(M ? "" : " ", O ? i(L, { shouldBreak: V }) : L), _ && F(N)) {
              let K = h(t(o, k, C));
              return p(K) || K.type === "fill" ? g(K) : [K];
            }
            return k;
          }
          __name(m, "m");
          function E(o) {
            return o.type !== "LogicalExpression" ? false : !!(o.right.type === "ObjectExpression" && o.right.properties.length > 0 || o.right.type === "ArrayExpression" && o.right.elements.length > 0 || w(o.right));
          }
          __name(E, "E");
          n.exports = { printBinaryishExpression: x, shouldInlineLogicalExpression: E };
        } }), Mm = ee({ "src/language-js/print/angular.js"(e, n) {
          "use strict";
          re();
          var { builders: { join: t, line: s, group: a } } = qe(), { hasNode: r, hasComment: u, getComments: i } = Ke(), { printBinaryishExpression: l } = Jn();
          function c(g, p, D) {
            let v = g.getValue();
            if (!!v.type.startsWith("NG"))
              switch (v.type) {
                case "NGRoot":
                  return [D("node"), u(v.node) ? " //" + i(v.node)[0].value.trimEnd() : ""];
                case "NGPipeExpression":
                  return l(g, p, D);
                case "NGChainedExpression":
                  return a(t([";", s], g.map((w) => h(w) ? D() : ["(", D(), ")"], "expressions")));
                case "NGEmptyExpression":
                  return "";
                case "NGQuotedExpression":
                  return [v.prefix, ": ", v.value.trim()];
                case "NGMicrosyntax":
                  return g.map((w, T) => [T === 0 ? "" : y(w.getValue(), T, v) ? " " : [";", s], D()], "body");
                case "NGMicrosyntaxKey":
                  return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(v.name) ? v.name : JSON.stringify(v.name);
                case "NGMicrosyntaxExpression":
                  return [D("expression"), v.alias === null ? "" : [" as ", D("alias")]];
                case "NGMicrosyntaxKeyedExpression": {
                  let w = g.getName(), T = g.getParentNode(), F = y(v, w, T) || (w === 1 && (v.key.name === "then" || v.key.name === "else") || w === 2 && v.key.name === "else" && T.body[w - 1].type === "NGMicrosyntaxKeyedExpression" && T.body[w - 1].key.name === "then") && T.body[0].type === "NGMicrosyntaxExpression";
                  return [D("key"), F ? " " : ": ", D("expression")];
                }
                case "NGMicrosyntaxLet":
                  return ["let ", D("key"), v.value === null ? "" : [" = ", D("value")]];
                case "NGMicrosyntaxAs":
                  return [D("key"), " as ", D("alias")];
                default:
                  throw new Error(`Unknown Angular node type: ${JSON.stringify(v.type)}.`);
              }
          }
          __name(c, "c");
          function y(g, p, D) {
            return g.type === "NGMicrosyntaxKeyedExpression" && g.key.name === "of" && p === 1 && D.body[0].type === "NGMicrosyntaxLet" && D.body[0].value === null;
          }
          __name(y, "y");
          function h(g) {
            return r(g.getValue(), (p) => {
              switch (p.type) {
                case void 0:
                  return false;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return true;
              }
            });
          }
          __name(h, "h");
          n.exports = { printAngular: c };
        } }), Rm = ee({ "src/language-js/print/jsx.js"(e, n) {
          "use strict";
          re();
          var { printComments: t, printDanglingComments: s } = et(), { builders: { line: a, hardline: r, softline: u, group: i, indent: l, conditionalGroup: c, fill: y, ifBreak: h, lineSuffixBoundary: g, join: p }, utils: { willBreak: D } } = qe(), { getLast: v, getPreferredQuote: w } = Ge(), { isJsxNode: T, rawText: F, isLiteral: A, isCallExpression: B, isStringLiteral: I, isBinaryish: P, hasComment: $, CommentCheckFlags: f, hasNodeIgnoreComment: x } = Ke(), m = Ot(), { willPrintOwnComments: E } = Za(), o = /* @__PURE__ */ __name((H) => H === "" || H === a || H === r || H === u, "o");
          function d(H, Z, ne) {
            let fe = H.getValue();
            if (fe.type === "JSXElement" && oe(fe))
              return [ne("openingElement"), ne("closingElement")];
            let ge = fe.type === "JSXElement" ? ne("openingElement") : ne("openingFragment"), Ce = fe.type === "JSXElement" ? ne("closingElement") : ne("closingFragment");
            if (fe.children.length === 1 && fe.children[0].type === "JSXExpressionContainer" && (fe.children[0].expression.type === "TemplateLiteral" || fe.children[0].expression.type === "TaggedTemplateExpression"))
              return [ge, ...H.map(ne, "children"), Ce];
            fe.children = fe.children.map((S) => Ae(S) ? { type: "JSXText", value: " ", raw: " " } : S);
            let _e = fe.children.some(T), Oe = fe.children.filter((S) => S.type === "JSXExpressionContainer").length > 1, pe = fe.type === "JSXElement" && fe.openingElement.attributes.length > 1, ie = D(ge) || _e || pe || Oe, ve = H.getParentNode().rootMarker === "mdx", ce = Z.singleQuote ? "{' '}" : '{" "}', U = ve ? " " : h([ce, u], " "), de = fe.openingElement && fe.openingElement.name && fe.openingElement.name.name === "fbt", De = C(H, Z, ne, U, de), he = fe.children.some((S) => ae(S));
            for (let S = De.length - 2; S >= 0; S--) {
              let G = De[S] === "" && De[S + 1] === "", te = De[S] === r && De[S + 1] === "" && De[S + 2] === r, Ee = (De[S] === u || De[S] === r) && De[S + 1] === "" && De[S + 2] === U, Re = De[S] === U && De[S + 1] === "" && (De[S + 2] === u || De[S + 2] === r), Te = De[S] === U && De[S + 1] === "" && De[S + 2] === U, Pe = De[S] === u && De[S + 1] === "" && De[S + 2] === r || De[S] === r && De[S + 1] === "" && De[S + 2] === u;
              te && he || G || Ee || Te || Pe ? De.splice(S, 2) : Re && De.splice(S + 1, 2);
            }
            for (; De.length > 0 && o(v(De)); )
              De.pop();
            for (; De.length > 1 && o(De[0]) && o(De[1]); )
              De.shift(), De.shift();
            let Be = [];
            for (let [S, G] of De.entries()) {
              if (G === U) {
                if (S === 1 && De[S - 1] === "") {
                  if (De.length === 2) {
                    Be.push(ce);
                    continue;
                  }
                  Be.push([ce, r]);
                  continue;
                } else if (S === De.length - 1) {
                  Be.push(ce);
                  continue;
                } else if (De[S - 1] === "" && De[S - 2] === r) {
                  Be.push(ce);
                  continue;
                }
              }
              Be.push(G), D(G) && (ie = true);
            }
            let Se = he ? y(Be) : i(Be, { shouldBreak: true });
            if (ve)
              return Se;
            let ye = i([ge, l([r, Se]), r, Ce]);
            return ie ? ye : c([i([ge, ...De, Ce]), ye]);
          }
          __name(d, "d");
          function C(H, Z, ne, fe, ge) {
            let Ce = [];
            return H.each((_e, Oe, pe) => {
              let ie = _e.getValue();
              if (A(ie)) {
                let ve = F(ie);
                if (ae(ie)) {
                  let ce = ve.split(le);
                  if (ce[0] === "") {
                    if (Ce.push(""), ce.shift(), /\n/.test(ce[0])) {
                      let de = pe[Oe + 1];
                      Ce.push(b(ge, ce[1], ie, de));
                    } else
                      Ce.push(fe);
                    ce.shift();
                  }
                  let U;
                  if (v(ce) === "" && (ce.pop(), U = ce.pop()), ce.length === 0)
                    return;
                  for (let [de, De] of ce.entries())
                    de % 2 === 1 ? Ce.push(a) : Ce.push(De);
                  if (U !== void 0)
                    if (/\n/.test(U)) {
                      let de = pe[Oe + 1];
                      Ce.push(b(ge, v(Ce), ie, de));
                    } else
                      Ce.push(fe);
                  else {
                    let de = pe[Oe + 1];
                    Ce.push(_(ge, v(Ce), ie, de));
                  }
                } else
                  /\n/.test(ve) ? ve.match(/\n/g).length > 1 && Ce.push("", r) : Ce.push("", fe);
              } else {
                let ve = ne();
                Ce.push(ve);
                let ce = pe[Oe + 1];
                if (ce && ae(ce)) {
                  let de = X(F(ce)).split(le)[0];
                  Ce.push(_(ge, de, ie, ce));
                } else
                  Ce.push(r);
              }
            }, "children"), Ce;
          }
          __name(C, "C");
          function _(H, Z, ne, fe) {
            return H ? "" : ne.type === "JSXElement" && !ne.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? Z.length === 1 ? u : r : u;
          }
          __name(_, "_");
          function b(H, Z, ne, fe) {
            return H ? r : Z.length === 1 ? ne.type === "JSXElement" && !ne.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? r : u : r;
          }
          __name(b, "b");
          function N(H, Z, ne) {
            let fe = H.getParentNode();
            if (!fe || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe.type])
              return Z;
            let Ce = H.match(void 0, (Oe) => Oe.type === "ArrowFunctionExpression", B, (Oe) => Oe.type === "JSXExpressionContainer"), _e = m(H, ne);
            return i([_e ? "" : h("("), l([u, Z]), u, _e ? "" : h(")")], { shouldBreak: Ce });
          }
          __name(N, "N");
          function k(H, Z, ne) {
            let fe = H.getValue(), ge = [];
            if (ge.push(ne("name")), fe.value) {
              let Ce;
              if (I(fe.value)) {
                let Oe = F(fe.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: pe, quote: ie, regex: ve } = w(Oe, Z.jsxSingleQuote ? "'" : '"');
                Oe = Oe.replace(ve, pe), Ce = [ie, Oe, ie];
              } else
                Ce = ne("value");
              ge.push("=", Ce);
            }
            return ge;
          }
          __name(k, "k");
          function R(H, Z, ne) {
            let fe = H.getValue(), ge = /* @__PURE__ */ __name((Ce, _e) => Ce.type === "JSXEmptyExpression" || !$(Ce) && (Ce.type === "ArrayExpression" || Ce.type === "ObjectExpression" || Ce.type === "ArrowFunctionExpression" || Ce.type === "AwaitExpression" && (ge(Ce.argument, Ce) || Ce.argument.type === "JSXElement") || B(Ce) || Ce.type === "FunctionExpression" || Ce.type === "TemplateLiteral" || Ce.type === "TaggedTemplateExpression" || Ce.type === "DoExpression" || T(_e) && (Ce.type === "ConditionalExpression" || P(Ce))), "ge");
            return ge(fe.expression, H.getParentNode(0)) ? i(["{", ne("expression"), g, "}"]) : i(["{", l([u, ne("expression")]), u, g, "}"]);
          }
          __name(R, "R");
          function M(H, Z, ne) {
            let fe = H.getValue(), ge = fe.name && $(fe.name) || fe.typeParameters && $(fe.typeParameters);
            if (fe.selfClosing && fe.attributes.length === 0 && !ge)
              return ["<", ne("name"), ne("typeParameters"), " />"];
            if (fe.attributes && fe.attributes.length === 1 && fe.attributes[0].value && I(fe.attributes[0].value) && !fe.attributes[0].value.value.includes(`
`) && !ge && !$(fe.attributes[0]))
              return i(["<", ne("name"), ne("typeParameters"), " ", ...H.map(ne, "attributes"), fe.selfClosing ? " />" : ">"]);
            let Ce = fe.attributes && fe.attributes.some((Oe) => Oe.value && I(Oe.value) && Oe.value.value.includes(`
`)), _e = Z.singleAttributePerLine && fe.attributes.length > 1 ? r : a;
            return i(["<", ne("name"), ne("typeParameters"), l(H.map(() => [_e, ne()], "attributes")), ...q(fe, Z, ge)], { shouldBreak: Ce });
          }
          __name(M, "M");
          function q(H, Z, ne) {
            return H.selfClosing ? [a, "/>"] : J(H, Z, ne) ? [">"] : [u, ">"];
          }
          __name(q, "q");
          function J(H, Z, ne) {
            let fe = H.attributes.length > 0 && $(v(H.attributes), f.Trailing);
            return H.attributes.length === 0 && !ne || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!ne || H.attributes.length > 0) && !fe;
          }
          __name(J, "J");
          function L(H, Z, ne) {
            let fe = H.getValue(), ge = [];
            ge.push("</");
            let Ce = ne("name");
            return $(fe.name, f.Leading | f.Line) ? ge.push(l([r, Ce]), r) : $(fe.name, f.Leading | f.Block) ? ge.push(" ", Ce) : ge.push(Ce), ge.push(">"), ge;
          }
          __name(L, "L");
          function Y(H, Z) {
            let ne = H.getValue(), fe = $(ne), ge = $(ne, f.Line), Ce = ne.type === "JSXOpeningFragment";
            return [Ce ? "<" : "</", l([ge ? r : fe && !Ce ? " " : "", s(H, Z, true)]), ge ? r : "", ">"];
          }
          __name(Y, "Y");
          function V(H, Z, ne) {
            let fe = t(H, d(H, Z, ne), Z);
            return N(H, fe, Z);
          }
          __name(V, "V");
          function O(H, Z) {
            let ne = H.getValue(), fe = $(ne, f.Line);
            return [s(H, Z, !fe), fe ? r : ""];
          }
          __name(O, "O");
          function K(H, Z, ne) {
            let fe = H.getValue();
            return ["{", H.call((ge) => {
              let Ce = ["...", ne()], _e = ge.getValue();
              return !$(_e) || !E(ge) ? Ce : [l([u, t(ge, Ce, Z)]), u];
            }, fe.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
          }
          __name(K, "K");
          function se(H, Z, ne) {
            let fe = H.getValue();
            if (!!fe.type.startsWith("JSX"))
              switch (fe.type) {
                case "JSXAttribute":
                  return k(H, Z, ne);
                case "JSXIdentifier":
                  return String(fe.name);
                case "JSXNamespacedName":
                  return p(":", [ne("namespace"), ne("name")]);
                case "JSXMemberExpression":
                  return p(".", [ne("object"), ne("property")]);
                case "JSXSpreadAttribute":
                  return K(H, Z, ne);
                case "JSXSpreadChild":
                  return K(H, Z, ne);
                case "JSXExpressionContainer":
                  return R(H, Z, ne);
                case "JSXFragment":
                case "JSXElement":
                  return V(H, Z, ne);
                case "JSXOpeningElement":
                  return M(H, Z, ne);
                case "JSXClosingElement":
                  return L(H, Z, ne);
                case "JSXOpeningFragment":
                case "JSXClosingFragment":
                  return Y(H, Z);
                case "JSXEmptyExpression":
                  return O(H, Z);
                case "JSXText":
                  throw new Error("JSXTest should be handled by JSXElement");
                default:
                  throw new Error(`Unknown JSX node type: ${JSON.stringify(fe.type)}.`);
              }
          }
          __name(se, "se");
          var Q = ` 
\r	`, le = new RegExp("([" + Q + "]+)"), W = new RegExp("[^" + Q + "]"), X = /* @__PURE__ */ __name((H) => H.replace(new RegExp("(?:^" + le.source + "|" + le.source + "$)"), ""), "X");
          function oe(H) {
            if (H.children.length === 0)
              return true;
            if (H.children.length > 1)
              return false;
            let Z = H.children[0];
            return A(Z) && !ae(Z);
          }
          __name(oe, "oe");
          function ae(H) {
            return A(H) && (W.test(F(H)) || !/\n/.test(F(H)));
          }
          __name(ae, "ae");
          function Ae(H) {
            return H.type === "JSXExpressionContainer" && A(H.expression) && H.expression.value === " " && !$(H.expression);
          }
          __name(Ae, "Ae");
          function z(H) {
            let Z = H.getValue(), ne = H.getParentNode();
            if (!ne || !Z || !T(Z) || !T(ne))
              return false;
            let fe = ne.children.indexOf(Z), ge = null;
            for (let Ce = fe; Ce > 0; Ce--) {
              let _e = ne.children[Ce - 1];
              if (!(_e.type === "JSXText" && !ae(_e))) {
                ge = _e;
                break;
              }
            }
            return ge && ge.type === "JSXExpressionContainer" && ge.expression.type === "JSXEmptyExpression" && x(ge.expression);
          }
          __name(z, "z");
          n.exports = { hasJsxIgnoreComment: z, printJsx: se };
        } }), Dt = ee({ "src/language-js/print/misc.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t } = Ge(), { builders: { indent: s, join: a, line: r } } = qe(), { isFlowAnnotationComment: u } = Ke();
          function i(v) {
            let w = v.getValue();
            return !w.optional || w.type === "Identifier" && w === v.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
          }
          __name(i, "i");
          function l(v) {
            return v.getValue().definite || v.match(void 0, (w, T) => T === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
          }
          __name(l, "l");
          function c(v, w, T) {
            let F = v.getValue();
            return F.typeArguments ? T("typeArguments") : F.typeParameters ? T("typeParameters") : "";
          }
          __name(c, "c");
          function y(v, w, T) {
            let F = v.getValue();
            if (!F.typeAnnotation)
              return "";
            let A = v.getParentNode(), B = A.type === "DeclareFunction" && A.id === F;
            return u(w.originalText, F.typeAnnotation) ? [" /*: ", T("typeAnnotation"), " */"] : [B ? "" : ": ", T("typeAnnotation")];
          }
          __name(y, "y");
          function h(v, w, T) {
            return ["::", T("callee")];
          }
          __name(h, "h");
          function g(v, w, T) {
            let F = v.getValue();
            return t(F.modifiers) ? [a(" ", v.map(T, "modifiers")), " "] : "";
          }
          __name(g, "g");
          function p(v, w, T) {
            return v.type === "EmptyStatement" ? ";" : v.type === "BlockStatement" || T ? [" ", w] : s([r, w]);
          }
          __name(p, "p");
          function D(v, w, T) {
            return ["...", T("argument"), y(v, w, T)];
          }
          __name(D, "D");
          n.exports = { printOptionalToken: i, printDefiniteToken: l, printFunctionTypeParameters: c, printBindExpressionCallee: h, printTypeScriptModifiers: g, printTypeAnnotation: y, printRestSpread: D, adjustClause: p };
        } }), Qt = ee({ "src/language-js/print/array.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, hardline: r, group: u, indent: i, ifBreak: l, fill: c } } = qe(), { getLast: y, hasNewline: h } = Ge(), { shouldPrintComma: g, hasComment: p, CommentCheckFlags: D, isNextLineEmpty: v, isNumericLiteral: w, isSignedNumericLiteral: T } = Ke(), { locStart: F } = it(), { printOptionalToken: A, printTypeAnnotation: B } = Dt();
          function I(x, m, E) {
            let o = x.getValue(), d = [], C = o.type === "TupleExpression" ? "#[" : "[", _ = "]";
            if (o.elements.length === 0)
              p(o, D.Dangling) ? d.push(u([C, t(x, m), a, _])) : d.push(C, _);
            else {
              let b = y(o.elements), N = !(b && b.type === "RestElement"), k = b === null, R = Symbol("array"), M = !m.__inJestEach && o.elements.length > 1 && o.elements.every((L, Y, V) => {
                let O = L && L.type;
                if (O !== "ArrayExpression" && O !== "ObjectExpression")
                  return false;
                let K = V[Y + 1];
                if (K && O !== K.type)
                  return false;
                let se = O === "ArrayExpression" ? "elements" : "properties";
                return L[se] && L[se].length > 1;
              }), q = P(o, m), J = N ? k ? "," : g(m) ? q ? l(",", "", { groupId: R }) : l(",") : "" : "";
              d.push(u([C, i([a, q ? f(x, m, E, J) : [$(x, m, "elements", E), J], t(x, m, true)]), a, _], { shouldBreak: M, id: R }));
            }
            return d.push(A(x), B(x, m, E)), d;
          }
          __name(I, "I");
          function P(x, m) {
            return x.elements.length > 1 && x.elements.every((E) => E && (w(E) || T(E) && !p(E.argument)) && !p(E, D.Trailing | D.Line, (o) => !h(m.originalText, F(o), { backwards: true })));
          }
          __name(P, "P");
          function $(x, m, E, o) {
            let d = [], C = [];
            return x.each((_) => {
              d.push(C, u(o())), C = [",", s], _.getValue() && v(_.getValue(), m) && C.push(a);
            }, E), d;
          }
          __name($, "$");
          function f(x, m, E, o) {
            let d = [];
            return x.each((C, _, b) => {
              let N = _ === b.length - 1;
              d.push([E(), N ? o : ","]), N || d.push(v(C.getValue(), m) ? [r, r] : p(b[_ + 1], D.Leading | D.Line) ? r : s);
            }, "elements"), c(d);
          }
          __name(f, "f");
          n.exports = { printArray: I, printArrayItems: $, isConciselyPrintedArray: P };
        } }), to = ee({ "src/language-js/print/call-arguments.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { getLast: s, getPenultimate: a } = Ge(), { getFunctionParameters: r, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: l, isJsxNode: c, isLongCurriedCallExpression: y, shouldPrintComma: h, getCallArguments: g, iterateCallArgumentsPath: p, isNextLineEmpty: D, isCallExpression: v, isStringLiteral: w, isObjectProperty: T, isTSTypeExpression: F } = Ke(), { builders: { line: A, hardline: B, softline: I, group: P, indent: $, conditionalGroup: f, ifBreak: x, breakParent: m }, utils: { willBreak: E } } = qe(), { ArgExpansionBailout: o } = Kt(), { isConciselyPrintedArray: d } = Qt();
          function C(q, J, L) {
            let Y = q.getValue(), V = Y.type === "ImportExpression", O = g(Y);
            if (O.length === 0)
              return ["(", t(q, J, true), ")"];
            if (k(O))
              return ["(", L(["arguments", 0]), ", ", L(["arguments", 1]), ")"];
            let K = false, se = false, Q = O.length - 1, le = [];
            p(q, (z, H) => {
              let Z = z.getNode(), ne = [L()];
              H === Q || (D(Z, J) ? (H === 0 && (se = true), K = true, ne.push(",", B, B)) : ne.push(",", A)), le.push(ne);
            });
            let W = !(V || Y.callee && Y.callee.type === "Import") && h(J, "all") ? "," : "";
            function X() {
              return P(["(", $([A, ...le]), W, A, ")"], { shouldBreak: true });
            }
            __name(X, "X");
            if (K || q.getParentNode().type !== "Decorator" && l(O))
              return X();
            let oe = N(O), ae = b(O, J);
            if (oe || ae) {
              if (oe ? le.slice(1).some(E) : le.slice(0, -1).some(E))
                return X();
              let z = [];
              try {
                q.try(() => {
                  p(q, (H, Z) => {
                    oe && Z === 0 && (z = [[L([], { expandFirstArg: true }), le.length > 1 ? "," : "", se ? B : A, se ? B : ""], ...le.slice(1)]), ae && Z === Q && (z = [...le.slice(0, -1), L([], { expandLastArg: true })]);
                  });
                });
              } catch (H) {
                if (H instanceof o)
                  return X();
                throw H;
              }
              return [le.some(E) ? m : "", f([["(", ...z, ")"], oe ? ["(", P(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...le.slice(0, -1), P(s(z), { shouldBreak: true }), ")"], X()])];
            }
            let Ae = ["(", $([I, ...le]), x(W), I, ")"];
            return y(q) ? Ae : P(Ae, { shouldBreak: le.some(E) || K });
          }
          __name(C, "C");
          function _(q) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return q.type === "ObjectExpression" && (q.properties.length > 0 || u(q)) || q.type === "ArrayExpression" && (q.elements.length > 0 || u(q)) || q.type === "TSTypeAssertion" && _(q.expression) || F(q) && _(q.expression) || q.type === "FunctionExpression" || q.type === "ArrowFunctionExpression" && (!q.returnType || !q.returnType.typeAnnotation || q.returnType.typeAnnotation.type !== "TSTypeReference" || R(q.body)) && (q.body.type === "BlockStatement" || q.body.type === "ArrowFunctionExpression" && _(q.body, true) || q.body.type === "ObjectExpression" || q.body.type === "ArrayExpression" || !J && (v(q.body) || q.body.type === "ConditionalExpression") || c(q.body)) || q.type === "DoExpression" || q.type === "ModuleExpression";
          }
          __name(_, "_");
          function b(q, J) {
            let L = s(q), Y = a(q);
            return !u(L, i.Leading) && !u(L, i.Trailing) && _(L) && (!Y || Y.type !== L.type) && (q.length !== 2 || Y.type !== "ArrowFunctionExpression" || L.type !== "ArrayExpression") && !(q.length > 1 && L.type === "ArrayExpression" && d(L, J));
          }
          __name(b, "b");
          function N(q) {
            if (q.length !== 2)
              return false;
            let [J, L] = q;
            return J.type === "ModuleExpression" && M(L) ? true : !u(J) && (J.type === "FunctionExpression" || J.type === "ArrowFunctionExpression" && J.body.type === "BlockStatement") && L.type !== "FunctionExpression" && L.type !== "ArrowFunctionExpression" && L.type !== "ConditionalExpression" && !_(L);
          }
          __name(N, "N");
          function k(q) {
            return q.length === 2 && q[0].type === "ArrowFunctionExpression" && r(q[0]).length === 0 && q[0].body.type === "BlockStatement" && q[1].type === "ArrayExpression" && !q.some((J) => u(J));
          }
          __name(k, "k");
          function R(q) {
            return q.type === "BlockStatement" && (q.body.some((J) => J.type !== "EmptyStatement") || u(q, i.Dangling));
          }
          __name(R, "R");
          function M(q) {
            return q.type === "ObjectExpression" && q.properties.length === 1 && T(q.properties[0]) && q.properties[0].key.type === "Identifier" && q.properties[0].key.name === "type" && w(q.properties[0].value) && q.properties[0].value.value === "module";
          }
          __name(M, "M");
          n.exports = C;
        } }), ro = ee({ "src/language-js/print/member.js"(e, n) {
          "use strict";
          re();
          var { builders: { softline: t, group: s, indent: a, label: r } } = qe(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: l } = Ke(), { printOptionalToken: c } = Dt();
          function y(g, p, D) {
            let v = g.getValue(), w = g.getParentNode(), T, F = 0;
            do
              T = g.getParentNode(F), F++;
            while (T && (i(T) || T.type === "TSNonNullExpression"));
            let A = D("object"), B = h(g, p, D), I = T && (T.type === "NewExpression" || T.type === "BindExpression" || T.type === "AssignmentExpression" && T.left.type !== "Identifier") || v.computed || v.object.type === "Identifier" && v.property.type === "Identifier" && !i(w) || (w.type === "AssignmentExpression" || w.type === "VariableDeclarator") && (l(v.object) && v.object.arguments.length > 0 || v.object.type === "TSNonNullExpression" && l(v.object.expression) && v.object.expression.arguments.length > 0 || A.label === "member-chain");
            return r(A.label === "member-chain" ? "member-chain" : "member", [A, I ? B : s(a([t, B]))]);
          }
          __name(y, "y");
          function h(g, p, D) {
            let v = D("property"), w = g.getValue(), T = c(g);
            return w.computed ? !w.property || u(w.property) ? [T, "[", v, "]"] : s([T, "[", a([t, v]), t, "]"]) : [T, ".", v];
          }
          __name(h, "h");
          n.exports = { printMemberExpression: y, printMemberLookup: h };
        } }), $m = ee({ "src/language-js/print/member-chain.js"(e, n) {
          "use strict";
          re();
          var { printComments: t } = et(), { getLast: s, isNextLineEmptyAfterIndex: a, getNextNonSpaceNonCommentCharacterIndex: r } = Ge(), u = Ot(), { isCallExpression: i, isMemberExpression: l, isFunctionOrArrowExpression: c, isLongCurriedCallExpression: y, isMemberish: h, isNumericLiteral: g, isSimpleCallArgument: p, hasComment: D, CommentCheckFlags: v, isNextLineEmpty: w } = Ke(), { locEnd: T } = it(), { builders: { join: F, hardline: A, group: B, indent: I, conditionalGroup: P, breakParent: $, label: f }, utils: { willBreak: x } } = qe(), m = to(), { printMemberLookup: E } = ro(), { printOptionalToken: o, printFunctionTypeParameters: d, printBindExpressionCallee: C } = Dt();
          function _(b, N, k) {
            let R = b.getParentNode(), M = !R || R.type === "ExpressionStatement", q = [];
            function J(ie) {
              let { originalText: ve } = N, ce = r(ve, ie, T);
              return ve.charAt(ce) === ")" ? ce !== false && a(ve, ce + 1) : w(ie, N);
            }
            __name(J, "J");
            function L(ie) {
              let ve = ie.getValue();
              i(ve) && (h(ve.callee) || i(ve.callee)) ? (q.unshift({ node: ve, printed: [t(ie, [o(ie), d(ie, N, k), m(ie, N, k)], N), J(ve) ? A : ""] }), ie.call((ce) => L(ce), "callee")) : h(ve) ? (q.unshift({ node: ve, needsParens: u(ie, N), printed: t(ie, l(ve) ? E(ie, N, k) : C(ie, N, k), N) }), ie.call((ce) => L(ce), "object")) : ve.type === "TSNonNullExpression" ? (q.unshift({ node: ve, printed: t(ie, "!", N) }), ie.call((ce) => L(ce), "expression")) : q.unshift({ node: ve, printed: k() });
            }
            __name(L, "L");
            let Y = b.getValue();
            q.unshift({ node: Y, printed: [o(b), d(b, N, k), m(b, N, k)] }), Y.callee && b.call((ie) => L(ie), "callee");
            let V = [], O = [q[0]], K = 1;
            for (; K < q.length && (q[K].node.type === "TSNonNullExpression" || i(q[K].node) || l(q[K].node) && q[K].node.computed && g(q[K].node.property)); ++K)
              O.push(q[K]);
            if (!i(q[0].node))
              for (; K + 1 < q.length && (h(q[K].node) && h(q[K + 1].node)); ++K)
                O.push(q[K]);
            V.push(O), O = [];
            let se = false;
            for (; K < q.length; ++K) {
              if (se && h(q[K].node)) {
                if (q[K].node.computed && g(q[K].node.property)) {
                  O.push(q[K]);
                  continue;
                }
                V.push(O), O = [], se = false;
              }
              (i(q[K].node) || q[K].node.type === "ImportExpression") && (se = true), O.push(q[K]), D(q[K].node, v.Trailing) && (V.push(O), O = [], se = false);
            }
            O.length > 0 && V.push(O);
            function Q(ie) {
              return /^[A-Z]|^[$_]+$/.test(ie);
            }
            __name(Q, "Q");
            function le(ie) {
              return ie.length <= N.tabWidth;
            }
            __name(le, "le");
            function W(ie) {
              let ve = ie[1].length > 0 && ie[1][0].node.computed;
              if (ie[0].length === 1) {
                let U = ie[0][0].node;
                return U.type === "ThisExpression" || U.type === "Identifier" && (Q(U.name) || M && le(U.name) || ve);
              }
              let ce = s(ie[0]).node;
              return l(ce) && ce.property.type === "Identifier" && (Q(ce.property.name) || ve);
            }
            __name(W, "W");
            let X = V.length >= 2 && !D(V[1][0].node) && W(V);
            function oe(ie) {
              let ve = ie.map((ce) => ce.printed);
              return ie.length > 0 && s(ie).needsParens ? ["(", ...ve, ")"] : ve;
            }
            __name(oe, "oe");
            function ae(ie) {
              return ie.length === 0 ? "" : I(B([A, F(A, ie.map(oe))]));
            }
            __name(ae, "ae");
            let Ae = V.map(oe), z = Ae, H = X ? 3 : 2, Z = V.flat(), ne = Z.slice(1, -1).some((ie) => D(ie.node, v.Leading)) || Z.slice(0, -1).some((ie) => D(ie.node, v.Trailing)) || V[H] && D(V[H][0].node, v.Leading);
            if (V.length <= H && !ne)
              return y(b) ? z : B(z);
            let fe = s(V[X ? 1 : 0]).node, ge = !i(fe) && J(fe), Ce = [oe(V[0]), X ? V.slice(1, 2).map(oe) : "", ge ? A : "", ae(V.slice(X ? 2 : 1))], _e = q.map((ie) => {
              let { node: ve } = ie;
              return ve;
            }).filter(i);
            function Oe() {
              let ie = s(s(V)).node, ve = s(Ae);
              return i(ie) && x(ve) && _e.slice(0, -1).some((ce) => ce.arguments.some(c));
            }
            __name(Oe, "Oe");
            let pe;
            return ne || _e.length > 2 && _e.some((ie) => !ie.arguments.every((ve) => p(ve, 0))) || Ae.slice(0, -1).some(x) || Oe() ? pe = B(Ce) : pe = [x(z) || ge ? $ : "", P([z, Ce])], f("member-chain", pe);
          }
          __name(_, "_");
          n.exports = _;
        } }), no = ee({ "src/language-js/print/call-expression.js"(e, n) {
          "use strict";
          re();
          var { builders: { join: t, group: s } } = qe(), a = Ot(), { getCallArguments: r, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: l, isStringLiteral: c, isTemplateOnItsOwnLine: y, isTestCall: h, iterateCallArgumentsPath: g } = Ke(), p = $m(), D = to(), { printOptionalToken: v, printFunctionTypeParameters: w } = Dt();
          function T(A, B, I) {
            let P = A.getValue(), $ = A.getParentNode(), f = P.type === "NewExpression", x = P.type === "ImportExpression", m = v(A), E = r(P);
            if (E.length > 0 && (!x && !f && F(P, $) || E.length === 1 && y(E[0], B.originalText) || !f && h(P, $))) {
              let C = [];
              return g(A, () => {
                C.push(I());
              }), [f ? "new " : "", I("callee"), m, w(A, B, I), "(", t(", ", C), ")"];
            }
            let o = (B.parser === "babel" || B.parser === "babel-flow") && P.callee && P.callee.type === "Identifier" && u(P.callee.trailingComments);
            if (o && (P.callee.trailingComments[0].printed = true), !x && !f && l(P.callee) && !A.call((C) => a(C, B), "callee"))
              return p(A, B, I);
            let d = [f ? "new " : "", x ? "import" : I("callee"), m, o ? `/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */` : "", w(A, B, I), D(A, B, I)];
            return x || i(P.callee) ? s(d) : d;
          }
          __name(T, "T");
          function F(A, B) {
            if (A.callee.type !== "Identifier")
              return false;
            if (A.callee.name === "require")
              return true;
            if (A.callee.name === "define") {
              let I = r(A);
              return B.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && c(I[0]) && I[1].type === "ArrayExpression");
            }
            return false;
          }
          __name(F, "F");
          n.exports = { printCallExpression: T };
        } }), Zt = ee({ "src/language-js/print/assignment.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t, getStringWidth: s } = Ge(), { builders: { line: a, group: r, indent: u, indentIfBreak: i, lineSuffixBoundary: l }, utils: { cleanDoc: c, willBreak: y, canBreak: h } } = qe(), { hasLeadingOwnLineComment: g, isBinaryish: p, isStringLiteral: D, isLiteral: v, isNumericLiteral: w, isCallExpression: T, isMemberExpression: F, getCallArguments: A, rawText: B, hasComment: I, isSignedNumericLiteral: P, isObjectProperty: $ } = Ke(), { shouldInlineLogicalExpression: f } = Jn(), { printCallExpression: x } = no();
          function m(W, X, oe, ae, Ae, z) {
            let H = d(W, X, oe, ae, z), Z = oe(z, { assignmentLayout: H });
            switch (H) {
              case "break-after-operator":
                return r([r(ae), Ae, r(u([a, Z]))]);
              case "never-break-after-operator":
                return r([r(ae), Ae, " ", Z]);
              case "fluid": {
                let ne = Symbol("assignment");
                return r([r(ae), Ae, r(u(a), { id: ne }), l, i(Z, { groupId: ne })]);
              }
              case "break-lhs":
                return r([ae, Ae, " ", r(Z)]);
              case "chain":
                return [r(ae), Ae, a, Z];
              case "chain-tail":
                return [r(ae), Ae, u([a, Z])];
              case "chain-tail-arrow-chain":
                return [r(ae), Ae, Z];
              case "only-left":
                return ae;
            }
          }
          __name(m, "m");
          function E(W, X, oe) {
            let ae = W.getValue();
            return m(W, X, oe, oe("left"), [" ", ae.operator], "right");
          }
          __name(E, "E");
          function o(W, X, oe) {
            return m(W, X, oe, oe("id"), " =", "init");
          }
          __name(o, "o");
          function d(W, X, oe, ae, Ae) {
            let z = W.getValue(), H = z[Ae];
            if (!H)
              return "only-left";
            let Z = !b(H);
            if (W.match(b, N, (Ce) => !Z || Ce.type !== "ExpressionStatement" && Ce.type !== "VariableDeclaration"))
              return Z ? H.type === "ArrowFunctionExpression" && H.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
            if (!Z && b(H.right) || g(X.originalText, H))
              return "break-after-operator";
            if (H.type === "CallExpression" && H.callee.name === "require" || X.parser === "json5" || X.parser === "json")
              return "never-break-after-operator";
            if (_(z) || k(z) || q(z) || J(z) && h(ae))
              return "break-lhs";
            let ge = se(z, ae, X);
            return W.call(() => C(W, X, oe, ge), Ae) ? "break-after-operator" : ge || H.type === "TemplateLiteral" || H.type === "TaggedTemplateExpression" || H.type === "BooleanLiteral" || w(H) || H.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
          }
          __name(d, "d");
          function C(W, X, oe, ae) {
            let Ae = W.getValue();
            if (p(Ae) && !f(Ae))
              return true;
            switch (Ae.type) {
              case "StringLiteralTypeAnnotation":
              case "SequenceExpression":
                return true;
              case "ConditionalExpression": {
                let { test: Z } = Ae;
                return p(Z) && !f(Z);
              }
              case "ClassExpression":
                return t(Ae.decorators);
            }
            if (ae)
              return false;
            let z = Ae, H = [];
            for (; ; )
              if (z.type === "UnaryExpression")
                z = z.argument, H.push("argument");
              else if (z.type === "TSNonNullExpression")
                z = z.expression, H.push("expression");
              else
                break;
            return !!(D(z) || W.call(() => V(W, X, oe), ...H));
          }
          __name(C, "C");
          function _(W) {
            if (N(W)) {
              let X = W.left || W.id;
              return X.type === "ObjectPattern" && X.properties.length > 2 && X.properties.some((oe) => $(oe) && (!oe.shorthand || oe.value && oe.value.type === "AssignmentPattern"));
            }
            return false;
          }
          __name(_, "_");
          function b(W) {
            return W.type === "AssignmentExpression";
          }
          __name(b, "b");
          function N(W) {
            return b(W) || W.type === "VariableDeclarator";
          }
          __name(N, "N");
          function k(W) {
            let X = R(W);
            if (t(X)) {
              let oe = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
              if (X.length > 1 && X.some((ae) => ae[oe] || ae.default))
                return true;
            }
            return false;
          }
          __name(k, "k");
          function R(W) {
            return M(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          __name(R, "R");
          function M(W) {
            return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
          }
          __name(M, "M");
          function q(W) {
            if (W.type !== "VariableDeclarator")
              return false;
            let { typeAnnotation: X } = W.id;
            if (!X || !X.typeAnnotation)
              return false;
            let oe = L(X.typeAnnotation);
            return t(oe) && oe.length > 1 && oe.some((ae) => t(L(ae)) || ae.type === "TSConditionalType");
          }
          __name(q, "q");
          function J(W) {
            return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
          }
          __name(J, "J");
          function L(W) {
            return Y(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          __name(L, "L");
          function Y(W) {
            return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
          }
          __name(Y, "Y");
          function V(W, X, oe) {
            let ae = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Ae = W.getValue(), z = /* @__PURE__ */ __name(() => V(W, X, oe, true), "z");
            if (Ae.type === "TSNonNullExpression")
              return W.call(z, "expression");
            if (T(Ae)) {
              if (x(W, X, oe).label === "member-chain")
                return false;
              let Z = A(Ae);
              return !(Z.length === 0 || Z.length === 1 && K(Z[0], X)) || Q(Ae, oe) ? false : W.call(z, "callee");
            }
            return F(Ae) ? W.call(z, "object") : ae && (Ae.type === "Identifier" || Ae.type === "ThisExpression");
          }
          __name(V, "V");
          var O = 0.25;
          function K(W, X) {
            let { printWidth: oe } = X;
            if (I(W))
              return false;
            let ae = oe * O;
            if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= ae || P(W) && !I(W.argument))
              return true;
            let Ae = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
            return Ae ? Ae.length <= ae : D(W) ? B(W).length <= ae : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ae && !W.quasis[0].value.raw.includes(`
`) : v(W);
          }
          __name(K, "K");
          function se(W, X, oe) {
            if (!$(W))
              return false;
            X = c(X);
            let ae = 3;
            return typeof X == "string" && s(X) < oe.tabWidth + ae;
          }
          __name(se, "se");
          function Q(W, X) {
            let oe = le(W);
            if (t(oe)) {
              if (oe.length > 1)
                return true;
              if (oe.length === 1) {
                let Ae = oe[0];
                if (Ae.type === "TSUnionType" || Ae.type === "UnionTypeAnnotation" || Ae.type === "TSIntersectionType" || Ae.type === "IntersectionTypeAnnotation" || Ae.type === "TSTypeLiteral" || Ae.type === "ObjectTypeAnnotation")
                  return true;
              }
              let ae = W.typeParameters ? "typeParameters" : "typeArguments";
              if (y(X(ae)))
                return true;
            }
            return false;
          }
          __name(Q, "Q");
          function le(W) {
            return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
          }
          __name(le, "le");
          n.exports = { printVariableDeclarator: o, printAssignmentExpression: E, printAssignment: m, isArrowFunctionVariableDeclarator: J };
        } }), kr = ee({ "src/language-js/print/function-parameters.js"(e, n) {
          "use strict";
          re();
          var { getNextNonSpaceNonCommentCharacter: t } = Ge(), { printDanglingComments: s } = et(), { builders: { line: a, hardline: r, softline: u, group: i, indent: l, ifBreak: c }, utils: { removeLines: y, willBreak: h } } = qe(), { getFunctionParameters: g, iterateFunctionParametersPath: p, isSimpleType: D, isTestCall: v, isTypeAnnotationAFunction: w, isObjectType: T, isObjectTypePropertyAFunction: F, hasRestParameter: A, shouldPrintComma: B, hasComment: I, isNextLineEmpty: P } = Ke(), { locEnd: $ } = it(), { ArgExpansionBailout: f } = Kt(), { printFunctionTypeParameters: x } = Dt();
          function m(C, _, b, N, k) {
            let R = C.getValue(), M = g(R), q = k ? x(C, b, _) : "";
            if (M.length === 0)
              return [q, "(", s(C, b, true, (se) => t(b.originalText, se, $) === ")"), ")"];
            let J = C.getParentNode(), L = v(J), Y = E(R), V = [];
            if (p(C, (se, Q) => {
              let le = Q === M.length - 1;
              le && R.rest && V.push("..."), V.push(_()), !le && (V.push(","), L || Y ? V.push(" ") : P(M[Q], b) ? V.push(r, r) : V.push(a));
            }), N) {
              if (h(q) || h(V))
                throw new f();
              return i([y(q), "(", y(V), ")"]);
            }
            let O = M.every((se) => !se.decorators);
            return Y && O ? [q, "(", ...V, ")"] : L ? [q, "(", ...V, ")"] : (F(J) || w(J) || J.type === "TypeAlias" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || J.type === "IntersectionTypeAnnotation" || J.type === "FunctionTypeAnnotation" && J.returnType === R) && M.length === 1 && M[0].name === null && R.this !== M[0] && M[0].typeAnnotation && R.typeParameters === null && D(M[0].typeAnnotation) && !R.rest ? b.arrowParens === "always" ? ["(", ...V, ")"] : V : [q, "(", l([u, ...V]), c(!A(R) && B(b, "all") ? "," : ""), u, ")"];
          }
          __name(m, "m");
          function E(C) {
            if (!C)
              return false;
            let _ = g(C);
            if (_.length !== 1)
              return false;
            let [b] = _;
            return !I(b) && (b.type === "ObjectPattern" || b.type === "ArrayPattern" || b.type === "Identifier" && b.typeAnnotation && (b.typeAnnotation.type === "TypeAnnotation" || b.typeAnnotation.type === "TSTypeAnnotation") && T(b.typeAnnotation.typeAnnotation) || b.type === "FunctionTypeParam" && T(b.typeAnnotation) || b.type === "AssignmentPattern" && (b.left.type === "ObjectPattern" || b.left.type === "ArrayPattern") && (b.right.type === "Identifier" || b.right.type === "ObjectExpression" && b.right.properties.length === 0 || b.right.type === "ArrayExpression" && b.right.elements.length === 0));
          }
          __name(E, "E");
          function o(C) {
            let _;
            return C.returnType ? (_ = C.returnType, _.typeAnnotation && (_ = _.typeAnnotation)) : C.typeAnnotation && (_ = C.typeAnnotation), _;
          }
          __name(o, "o");
          function d(C, _) {
            let b = o(C);
            if (!b)
              return false;
            let N = C.typeParameters && C.typeParameters.params;
            if (N) {
              if (N.length > 1)
                return false;
              if (N.length === 1) {
                let k = N[0];
                if (k.constraint || k.default)
                  return false;
              }
            }
            return g(C).length === 1 && (T(b) || h(_));
          }
          __name(d, "d");
          n.exports = { printFunctionParameters: m, shouldHugFunctionParameters: E, shouldGroupFunctionParameters: d };
        } }), Lr = ee({ "src/language-js/print/type-annotation.js"(e, n) {
          "use strict";
          re();
          var { printComments: t, printDanglingComments: s } = et(), { isNonEmptyArray: a } = Ge(), { builders: { group: r, join: u, line: i, softline: l, indent: c, align: y, ifBreak: h } } = qe(), g = Ot(), { locStart: p } = it(), { isSimpleType: D, isObjectType: v, hasLeadingOwnLineComment: w, isObjectTypePropertyAFunction: T, shouldPrintComma: F } = Ke(), { printAssignment: A } = Zt(), { printFunctionParameters: B, shouldGroupFunctionParameters: I } = kr(), { printArrayItems: P } = Qt();
          function $(b) {
            if (D(b) || v(b))
              return true;
            if (b.type === "UnionTypeAnnotation" || b.type === "TSUnionType") {
              let N = b.types.filter((R) => R.type === "VoidTypeAnnotation" || R.type === "TSVoidKeyword" || R.type === "NullLiteralTypeAnnotation" || R.type === "TSNullKeyword").length, k = b.types.some((R) => R.type === "ObjectTypeAnnotation" || R.type === "TSTypeLiteral" || R.type === "GenericTypeAnnotation" || R.type === "TSTypeReference");
              if (b.types.length - 1 === N && k)
                return true;
            }
            return false;
          }
          __name($, "$");
          function f(b, N, k) {
            let R = N.semi ? ";" : "", M = b.getValue(), q = [];
            return q.push("opaque type ", k("id"), k("typeParameters")), M.supertype && q.push(": ", k("supertype")), M.impltype && q.push(" = ", k("impltype")), q.push(R), q;
          }
          __name(f, "f");
          function x(b, N, k) {
            let R = N.semi ? ";" : "", M = b.getValue(), q = [];
            M.declare && q.push("declare "), q.push("type ", k("id"), k("typeParameters"));
            let J = M.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
            return [A(b, N, k, q, " =", J), R];
          }
          __name(x, "x");
          function m(b, N, k) {
            let R = b.getValue(), M = b.map(k, "types"), q = [], J = false;
            for (let L = 0; L < M.length; ++L)
              L === 0 ? q.push(M[L]) : v(R.types[L - 1]) && v(R.types[L]) ? q.push([" & ", J ? c(M[L]) : M[L]]) : !v(R.types[L - 1]) && !v(R.types[L]) ? q.push(c([" &", i, M[L]])) : (L > 1 && (J = true), q.push(" & ", L > 1 ? c(M[L]) : M[L]));
            return r(q);
          }
          __name(m, "m");
          function E(b, N, k) {
            let R = b.getValue(), M = b.getParentNode(), q = M.type !== "TypeParameterInstantiation" && M.type !== "TSTypeParameterInstantiation" && M.type !== "GenericTypeAnnotation" && M.type !== "TSTypeReference" && M.type !== "TSTypeAssertion" && M.type !== "TupleTypeAnnotation" && M.type !== "TSTupleType" && !(M.type === "FunctionTypeParam" && !M.name && b.getParentNode(1).this !== M) && !((M.type === "TypeAlias" || M.type === "VariableDeclarator" || M.type === "TSTypeAliasDeclaration") && w(N.originalText, R)), J = $(R), L = b.map((O) => {
              let K = k();
              return J || (K = y(2, K)), t(O, K, N);
            }, "types");
            if (J)
              return u(" | ", L);
            let Y = q && !w(N.originalText, R), V = [h([Y ? i : "", "| "]), u([i, "| "], L)];
            return g(b, N) ? r([c(V), l]) : M.type === "TupleTypeAnnotation" && M.types.length > 1 || M.type === "TSTupleType" && M.elementTypes.length > 1 ? r([c([h(["(", l]), V]), l, h(")")]) : r(q ? c(V) : V);
          }
          __name(E, "E");
          function o(b, N, k) {
            let R = b.getValue(), M = [], q = b.getParentNode(0), J = b.getParentNode(1), L = b.getParentNode(2), Y = R.type === "TSFunctionType" || !((q.type === "ObjectTypeProperty" || q.type === "ObjectTypeInternalSlot") && !q.variance && !q.optional && p(q) === p(R) || q.type === "ObjectTypeCallProperty" || L && L.type === "DeclareFunction"), V = Y && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation"), O = V && Y && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation") && J.type === "ArrowFunctionExpression";
            T(q) && (Y = true, V = true), O && M.push("(");
            let K = B(b, k, N, false, true), se = R.returnType || R.predicate || R.typeAnnotation ? [Y ? " => " : ": ", k("returnType"), k("predicate"), k("typeAnnotation")] : "", Q = I(R, se);
            return M.push(Q ? r(K) : K), se && M.push(se), O && M.push(")"), r(M);
          }
          __name(o, "o");
          function d(b, N, k) {
            let R = b.getValue(), M = R.type === "TSTupleType" ? "elementTypes" : "types", q = R[M], J = a(q), L = J ? l : "";
            return r(["[", c([L, P(b, N, M, k)]), h(J && F(N, "all") ? "," : ""), s(b, N, true), L, "]"]);
          }
          __name(d, "d");
          function C(b, N, k) {
            let R = b.getValue(), M = R.type === "OptionalIndexedAccessType" && R.optional ? "?.[" : "[";
            return [k("objectType"), M, k("indexType"), "]"];
          }
          __name(C, "C");
          function _(b, N, k) {
            let R = b.getValue();
            return [R.postfix ? "" : k, N("typeAnnotation"), R.postfix ? k : ""];
          }
          __name(_, "_");
          n.exports = { printOpaqueType: f, printTypeAlias: x, printIntersectionType: m, printUnionType: E, printFunctionType: o, printTupleType: d, printIndexedAccessType: C, shouldHugType: $, printJSDocType: _ };
        } }), jr = ee({ "src/language-js/print/type-parameters.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { builders: { join: s, line: a, hardline: r, softline: u, group: i, indent: l, ifBreak: c } } = qe(), { isTestCall: y, hasComment: h, CommentCheckFlags: g, isTSXFile: p, shouldPrintComma: D, getFunctionParameters: v, isObjectType: w } = Ke(), { createGroupIdMapper: T } = Ge(), { shouldHugType: F } = Lr(), { isArrowFunctionVariableDeclarator: A } = Zt(), B = T("typeParameters");
          function I(f, x, m, E) {
            let o = f.getValue();
            if (!o[E])
              return "";
            if (!Array.isArray(o[E]))
              return m(E);
            let d = f.getNode(2), C = d && y(d);
            if (!f.match((k) => !(k[E].length === 1 && w(k[E][0])), void 0, (k, R) => R === "typeAnnotation", (k) => k.type === "Identifier", A) && (C || o[E].length === 0 || o[E].length === 1 && (o[E][0].type === "NullableTypeAnnotation" || F(o[E][0]))))
              return ["<", s(", ", f.map(m, E)), P(f, x), ">"];
            let N = o.type === "TSTypeParameterInstantiation" ? "" : v(o).length === 1 && p(x) && !o[E][0].constraint && f.getParentNode().type === "ArrowFunctionExpression" ? "," : D(x, "all") ? c(",") : "";
            return i(["<", l([u, s([",", a], f.map(m, E))]), N, u, ">"], { id: B(o) });
          }
          __name(I, "I");
          function P(f, x) {
            let m = f.getValue();
            if (!h(m, g.Dangling))
              return "";
            let E = !h(m, g.Line), o = t(f, x, E);
            return E ? o : [o, r];
          }
          __name(P, "P");
          function $(f, x, m) {
            let E = f.getValue(), o = [], d = f.getParentNode();
            return d.type === "TSMappedType" ? (o.push("[", m("name")), E.constraint && o.push(" in ", m("constraint")), d.nameType && o.push(" as ", f.callParent(() => m("nameType"))), o.push("]"), o) : (E.variance && o.push(m("variance")), E.in && o.push("in "), E.out && o.push("out "), o.push(m("name")), E.bound && o.push(": ", m("bound")), E.constraint && o.push(" extends ", m("constraint")), E.default && o.push(" = ", m("default")), o);
          }
          __name($, "$");
          n.exports = { printTypeParameter: $, printTypeParameters: I, getTypeParametersGroupId: B };
        } }), er = ee({ "src/language-js/print/property.js"(e, n) {
          "use strict";
          re();
          var { printComments: t } = et(), { printString: s, printNumber: a } = Ge(), { isNumericLiteral: r, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: l, rawText: c } = Ke(), { printAssignment: y } = Zt(), h = /* @__PURE__ */ new WeakMap();
          function g(D, v, w) {
            let T = D.getNode();
            if (T.computed)
              return ["[", w("key"), "]"];
            let F = D.getParentNode(), { key: A } = T;
            if (T.type === "ClassPrivateProperty" && A.type === "Identifier")
              return ["#", w("key")];
            if (v.quoteProps === "consistent" && !h.has(F)) {
              let B = (F.properties || F.body || F.members).some((I) => !I.computed && I.key && i(I.key) && !l(I, v));
              h.set(F, B);
            }
            if ((A.type === "Identifier" || r(A) && u(a(c(A))) && String(A.value) === a(c(A)) && !(v.parser === "typescript" || v.parser === "babel-ts")) && (v.parser === "json" || v.quoteProps === "consistent" && h.get(F))) {
              let B = s(JSON.stringify(A.type === "Identifier" ? A.name : A.value.toString()), v);
              return D.call((I) => t(I, B, v), "key");
            }
            return l(T, v) && (v.quoteProps === "as-needed" || v.quoteProps === "consistent" && !h.get(F)) ? D.call((B) => t(B, /^\d/.test(A.value) ? a(A.value) : A.value, v), "key") : w("key");
          }
          __name(g, "g");
          function p(D, v, w) {
            return D.getValue().shorthand ? w("value") : y(D, v, w, g(D, v, w), ":", "value");
          }
          __name(p, "p");
          n.exports = { printProperty: p, printPropertyKey: g };
        } }), Or = ee({ "src/language-js/print/function.js"(e, n) {
          "use strict";
          re();
          var t = Yt(), { printDanglingComments: s, printCommentsSeparately: a } = et(), r = lt(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ge(), { builders: { line: i, softline: l, group: c, indent: y, ifBreak: h, hardline: g, join: p, indentIfBreak: D }, utils: { removeLines: v, willBreak: w } } = qe(), { ArgExpansionBailout: T } = Kt(), { getFunctionParameters: F, hasLeadingOwnLineComment: A, isFlowAnnotationComment: B, isJsxNode: I, isTemplateOnItsOwnLine: P, shouldPrintComma: $, startsWithNoLookaheadToken: f, isBinaryish: x, isLineComment: m, hasComment: E, getComments: o, CommentCheckFlags: d, isCallLikeExpression: C, isCallExpression: _, getCallArguments: b, hasNakedLeftSide: N, getLeftSide: k } = Ke(), { locEnd: R } = it(), { printFunctionParameters: M, shouldGroupFunctionParameters: q } = kr(), { printPropertyKey: J } = er(), { printFunctionTypeParameters: L } = Dt();
          function Y(H, Z, ne, fe) {
            let ge = H.getValue(), Ce = false;
            if ((ge.type === "FunctionDeclaration" || ge.type === "FunctionExpression") && fe && fe.expandLastArg) {
              let ve = H.getParentNode();
              _(ve) && b(ve).length > 1 && (Ce = true);
            }
            let _e = [];
            ge.type === "TSDeclareFunction" && ge.declare && _e.push("declare "), ge.async && _e.push("async "), ge.generator ? _e.push("function* ") : _e.push("function "), ge.id && _e.push(Z("id"));
            let Oe = M(H, Z, ne, Ce), pe = X(H, Z, ne), ie = q(ge, pe);
            return _e.push(L(H, ne, Z), c([ie ? c(Oe) : Oe, pe]), ge.body ? " " : "", Z("body")), ne.semi && (ge.declare || !ge.body) && _e.push(";"), _e;
          }
          __name(Y, "Y");
          function V(H, Z, ne) {
            let fe = H.getNode(), { kind: ge } = fe, Ce = fe.value || fe, _e = [];
            return !ge || ge === "init" || ge === "method" || ge === "constructor" ? Ce.async && _e.push("async ") : (t.ok(ge === "get" || ge === "set"), _e.push(ge, " ")), Ce.generator && _e.push("*"), _e.push(J(H, Z, ne), fe.optional || fe.key.optional ? "?" : ""), fe === Ce ? _e.push(O(H, Z, ne)) : Ce.type === "FunctionExpression" ? _e.push(H.call((Oe) => O(Oe, Z, ne), "value")) : _e.push(ne("value")), _e;
          }
          __name(V, "V");
          function O(H, Z, ne) {
            let fe = H.getNode(), ge = M(H, ne, Z), Ce = X(H, ne, Z), _e = q(fe, Ce), Oe = [L(H, Z, ne), c([_e ? c(ge) : ge, Ce])];
            return fe.body ? Oe.push(" ", ne("body")) : Oe.push(Z.semi ? ";" : ""), Oe;
          }
          __name(O, "O");
          function K(H, Z, ne, fe) {
            let ge = H.getValue(), Ce = [];
            if (ge.async && Ce.push("async "), W(H, Z))
              Ce.push(ne(["params", 0]));
            else {
              let Oe = fe && (fe.expandLastArg || fe.expandFirstArg), pe = X(H, ne, Z);
              if (Oe) {
                if (w(pe))
                  throw new T();
                pe = c(v(pe));
              }
              Ce.push(c([M(H, ne, Z, Oe, true), pe]));
            }
            let _e = s(H, Z, true, (Oe) => {
              let pe = u(Z.originalText, Oe, R);
              return pe !== false && Z.originalText.slice(pe, pe + 2) === "=>";
            });
            return _e && Ce.push(" ", _e), Ce;
          }
          __name(K, "K");
          function se(H, Z, ne, fe, ge, Ce) {
            let _e = H.getName(), Oe = H.getParentNode(), pe = C(Oe) && _e === "callee", ie = Boolean(Z && Z.assignmentLayout), ve = Ce.body.type !== "BlockStatement" && Ce.body.type !== "ObjectExpression" && Ce.body.type !== "SequenceExpression", ce = pe && ve || Z && Z.assignmentLayout === "chain-tail-arrow-chain", U = Symbol("arrow-chain");
            return Ce.body.type === "SequenceExpression" && (ge = c(["(", y([l, ge]), l, ")"])), c([c(y([pe || ie ? l : "", c(p([" =>", i], ne), { shouldBreak: fe })]), { id: U, shouldBreak: ce }), " =>", D(ve ? y([i, ge]) : [" ", ge], { groupId: U }), pe ? h(l, "", { groupId: U }) : ""]);
          }
          __name(se, "se");
          function Q(H, Z, ne, fe) {
            let ge = H.getValue(), Ce = [], _e = [], Oe = false;
            if ((/* @__PURE__ */ __name(function U() {
              let de = K(H, Z, ne, fe);
              if (Ce.length === 0)
                Ce.push(de);
              else {
                let { leading: De, trailing: he } = a(H, Z);
                Ce.push([De, de]), _e.unshift(he);
              }
              Oe = Oe || ge.returnType && F(ge).length > 0 || ge.typeParameters || F(ge).some((De) => De.type !== "Identifier"), ge.body.type !== "ArrowFunctionExpression" || fe && fe.expandLastArg ? _e.unshift(ne("body", fe)) : (ge = ge.body, H.call(U, "body"));
            }, "U"))(), Ce.length > 1)
              return se(H, fe, Ce, Oe, _e, ge);
            let pe = Ce;
            if (pe.push(" =>"), !A(Z.originalText, ge.body) && (ge.body.type === "ArrayExpression" || ge.body.type === "ObjectExpression" || ge.body.type === "BlockStatement" || I(ge.body) || P(ge.body, Z.originalText) || ge.body.type === "ArrowFunctionExpression" || ge.body.type === "DoExpression"))
              return c([...pe, " ", _e]);
            if (ge.body.type === "SequenceExpression")
              return c([...pe, c([" (", y([l, _e]), l, ")"])]);
            let ie = (fe && fe.expandLastArg || H.getParentNode().type === "JSXExpressionContainer") && !E(ge), ve = fe && fe.expandLastArg && $(Z, "all"), ce = ge.body.type === "ConditionalExpression" && !f(ge.body, false);
            return c([...pe, c([y([i, ce ? h("", "(") : "", _e, ce ? h("", ")") : ""]), ie ? [h(ve ? "," : ""), l] : ""])]);
          }
          __name(Q, "Q");
          function le(H) {
            let Z = F(H);
            return Z.length === 1 && !H.typeParameters && !E(H, d.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !E(Z[0]) && !Z[0].optional && !H.predicate && !H.returnType;
          }
          __name(le, "le");
          function W(H, Z) {
            if (Z.arrowParens === "always")
              return false;
            if (Z.arrowParens === "avoid") {
              let ne = H.getValue();
              return le(ne);
            }
            return false;
          }
          __name(W, "W");
          function X(H, Z, ne) {
            let fe = H.getValue(), ge = Z("returnType");
            if (fe.returnType && B(ne.originalText, fe.returnType))
              return [" /*: ", ge, " */"];
            let Ce = [ge];
            return fe.returnType && fe.returnType.typeAnnotation && Ce.unshift(": "), fe.predicate && Ce.push(fe.returnType ? " " : ": ", Z("predicate")), Ce;
          }
          __name(X, "X");
          function oe(H, Z, ne) {
            let fe = H.getValue(), ge = Z.semi ? ";" : "", Ce = [];
            fe.argument && (z(Z, fe.argument) ? Ce.push([" (", y([g, ne("argument")]), g, ")"]) : x(fe.argument) || fe.argument.type === "SequenceExpression" ? Ce.push(c([h(" (", " "), y([l, ne("argument")]), l, h(")")])) : Ce.push(" ", ne("argument")));
            let _e = o(fe), Oe = r(_e), pe = Oe && m(Oe);
            return pe && Ce.push(ge), E(fe, d.Dangling) && Ce.push(" ", s(H, Z, true)), pe || Ce.push(ge), Ce;
          }
          __name(oe, "oe");
          function ae(H, Z, ne) {
            return ["return", oe(H, Z, ne)];
          }
          __name(ae, "ae");
          function Ae(H, Z, ne) {
            return ["throw", oe(H, Z, ne)];
          }
          __name(Ae, "Ae");
          function z(H, Z) {
            if (A(H.originalText, Z))
              return true;
            if (N(Z)) {
              let ne = Z, fe;
              for (; fe = k(ne); )
                if (ne = fe, A(H.originalText, ne))
                  return true;
            }
            return false;
          }
          __name(z, "z");
          n.exports = { printFunction: Y, printArrowFunction: Q, printMethod: V, printReturnStatement: ae, printThrowStatement: Ae, printMethodInternal: O, shouldPrintParamsWithoutParens: W };
        } }), zn = ee({ "src/language-js/print/decorators.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t, hasNewline: s } = Ge(), { builders: { line: a, hardline: r, join: u, breakParent: i, group: l } } = qe(), { locStart: c, locEnd: y } = it(), { getParentExportDeclaration: h } = Ke();
          function g(T, F, A) {
            let B = T.getValue();
            return l([u(a, T.map(A, "decorators")), v(B, F) ? r : a]);
          }
          __name(g, "g");
          function p(T, F, A) {
            return [u(r, T.map(A, "declaration", "decorators")), r];
          }
          __name(p, "p");
          function D(T, F, A) {
            let B = T.getValue(), { decorators: I } = B;
            if (!t(I) || w(T.getParentNode()))
              return;
            let P = B.type === "ClassExpression" || B.type === "ClassDeclaration" || v(B, F);
            return [h(T) ? r : P ? i : "", u(a, T.map(A, "decorators")), a];
          }
          __name(D, "D");
          function v(T, F) {
            return T.decorators.some((A) => s(F.originalText, y(A)));
          }
          __name(v, "v");
          function w(T) {
            if (T.type !== "ExportDefaultDeclaration" && T.type !== "ExportNamedDeclaration" && T.type !== "DeclareExportDeclaration")
              return false;
            let F = T.declaration && T.declaration.decorators;
            return t(F) && c(T) === c(F[0]);
          }
          __name(w, "w");
          n.exports = { printDecorators: D, printClassMemberDecorators: g, printDecoratorsBeforeExport: p, hasDecoratorsBeforeExport: w };
        } }), tr = ee({ "src/language-js/print/class.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t, createGroupIdMapper: s } = Ge(), { printComments: a, printDanglingComments: r } = et(), { builders: { join: u, line: i, hardline: l, softline: c, group: y, indent: h, ifBreak: g } } = qe(), { hasComment: p, CommentCheckFlags: D } = Ke(), { getTypeParametersGroupId: v } = jr(), { printMethod: w } = Or(), { printOptionalToken: T, printTypeAnnotation: F, printDefiniteToken: A } = Dt(), { printPropertyKey: B } = er(), { printAssignment: I } = Zt(), { printClassMemberDecorators: P } = zn();
          function $(b, N, k) {
            let R = b.getValue(), M = [];
            R.declare && M.push("declare "), R.abstract && M.push("abstract "), M.push("class");
            let q = R.id && p(R.id, D.Trailing) || R.typeParameters && p(R.typeParameters, D.Trailing) || R.superClass && p(R.superClass) || t(R.extends) || t(R.mixins) || t(R.implements), J = [], L = [];
            if (R.id && J.push(" ", k("id")), J.push(k("typeParameters")), R.superClass) {
              let Y = [d(b, N, k), k("superTypeParameters")], V = b.call((O) => ["extends ", a(O, Y, N)], "superClass");
              q ? L.push(i, y(V)) : L.push(" ", V);
            } else
              L.push(o(b, N, k, "extends"));
            if (L.push(o(b, N, k, "mixins"), o(b, N, k, "implements")), q) {
              let Y;
              E(R) ? Y = [...J, h(L)] : Y = h([...J, L]), M.push(y(Y, { id: f(R) }));
            } else
              M.push(...J, ...L);
            return M.push(" ", k("body")), M;
          }
          __name($, "$");
          var f = s("heritageGroup");
          function x(b) {
            return g(l, "", { groupId: f(b) });
          }
          __name(x, "x");
          function m(b) {
            return ["superClass", "extends", "mixins", "implements"].filter((N) => Boolean(b[N])).length > 1;
          }
          __name(m, "m");
          function E(b) {
            return b.typeParameters && !p(b.typeParameters, D.Trailing | D.Line) && !m(b);
          }
          __name(E, "E");
          function o(b, N, k, R) {
            let M = b.getValue();
            if (!t(M[R]))
              return "";
            let q = r(b, N, true, (J) => {
              let { marker: L } = J;
              return L === R;
            });
            return [E(M) ? g(" ", i, { groupId: v(M.typeParameters) }) : i, q, q && l, R, y(h([i, u([",", i], b.map(k, R))]))];
          }
          __name(o, "o");
          function d(b, N, k) {
            let R = k("superClass");
            return b.getParentNode().type === "AssignmentExpression" ? y(g(["(", h([c, R]), c, ")"], R)) : R;
          }
          __name(d, "d");
          function C(b, N, k) {
            let R = b.getValue(), M = [];
            return t(R.decorators) && M.push(P(b, N, k)), R.accessibility && M.push(R.accessibility + " "), R.readonly && M.push("readonly "), R.declare && M.push("declare "), R.static && M.push("static "), (R.type === "TSAbstractMethodDefinition" || R.abstract) && M.push("abstract "), R.override && M.push("override "), M.push(w(b, N, k)), M;
          }
          __name(C, "C");
          function _(b, N, k) {
            let R = b.getValue(), M = [], q = N.semi ? ";" : "";
            return t(R.decorators) && M.push(P(b, N, k)), R.accessibility && M.push(R.accessibility + " "), R.declare && M.push("declare "), R.static && M.push("static "), (R.type === "TSAbstractPropertyDefinition" || R.type === "TSAbstractAccessorProperty" || R.abstract) && M.push("abstract "), R.override && M.push("override "), R.readonly && M.push("readonly "), R.variance && M.push(k("variance")), (R.type === "ClassAccessorProperty" || R.type === "AccessorProperty" || R.type === "TSAbstractAccessorProperty") && M.push("accessor "), M.push(B(b, N, k), T(b), A(b), F(b, N, k)), [I(b, N, k, M, " =", "value"), q];
          }
          __name(_, "_");
          n.exports = { printClass: $, printClassMethod: C, printClassProperty: _, printHardlineAfterHeritage: x };
        } }), uo = ee({ "src/language-js/print/interface.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t } = Ge(), { builders: { join: s, line: a, group: r, indent: u, ifBreak: i } } = qe(), { hasComment: l, identity: c, CommentCheckFlags: y } = Ke(), { getTypeParametersGroupId: h } = jr(), { printTypeScriptModifiers: g } = Dt();
          function p(D, v, w) {
            let T = D.getValue(), F = [];
            T.declare && F.push("declare "), T.type === "TSInterfaceDeclaration" && F.push(T.abstract ? "abstract " : "", g(D, v, w)), F.push("interface");
            let A = [], B = [];
            T.type !== "InterfaceTypeAnnotation" && A.push(" ", w("id"), w("typeParameters"));
            let I = T.typeParameters && !l(T.typeParameters, y.Trailing | y.Line);
            return t(T.extends) && B.push(I ? i(" ", a, { groupId: h(T.typeParameters) }) : a, "extends ", (T.extends.length === 1 ? c : u)(s([",", a], D.map(w, "extends")))), T.id && l(T.id, y.Trailing) || t(T.extends) ? I ? F.push(r([...A, u(B)])) : F.push(r(u([...A, ...B]))) : F.push(...A, ...B), F.push(" ", w("body")), r(F);
          }
          __name(p, "p");
          n.exports = { printInterface: p };
        } }), so = ee({ "src/language-js/print/module.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t } = Ge(), { builders: { softline: s, group: a, indent: r, join: u, line: i, ifBreak: l, hardline: c } } = qe(), { printDanglingComments: y } = et(), { hasComment: h, CommentCheckFlags: g, shouldPrintComma: p, needsHardlineAfterDanglingComment: D, isStringLiteral: v, rawText: w } = Ke(), { locStart: T, hasSameLoc: F } = it(), { hasDecoratorsBeforeExport: A, printDecoratorsBeforeExport: B } = zn();
          function I(_, b, N) {
            let k = _.getValue(), R = b.semi ? ";" : "", M = [], { importKind: q } = k;
            return M.push("import"), q && q !== "value" && M.push(" ", q), M.push(m(_, b, N), x(_, b, N), o(_, b, N), R), M;
          }
          __name(I, "I");
          function P(_, b, N) {
            let k = _.getValue(), R = [];
            A(k) && R.push(B(_, b, N));
            let { type: M, exportKind: q, declaration: J } = k;
            return R.push("export"), (k.default || M === "ExportDefaultDeclaration") && R.push(" default"), h(k, g.Dangling) && (R.push(" ", y(_, b, true)), D(k) && R.push(c)), J ? R.push(" ", N("declaration")) : R.push(q === "type" ? " type" : "", m(_, b, N), x(_, b, N), o(_, b, N)), f(k, b) && R.push(";"), R;
          }
          __name(P, "P");
          function $(_, b, N) {
            let k = _.getValue(), R = b.semi ? ";" : "", M = [], { exportKind: q, exported: J } = k;
            return M.push("export"), q === "type" && M.push(" type"), M.push(" *"), J && M.push(" as ", N("exported")), M.push(x(_, b, N), o(_, b, N), R), M;
          }
          __name($, "$");
          function f(_, b) {
            if (!b.semi)
              return false;
            let { type: N, declaration: k } = _, R = _.default || N === "ExportDefaultDeclaration";
            if (!k)
              return true;
            let { type: M } = k;
            return !!(R && M !== "ClassDeclaration" && M !== "FunctionDeclaration" && M !== "TSInterfaceDeclaration" && M !== "DeclareClass" && M !== "DeclareFunction" && M !== "TSDeclareFunction" && M !== "EnumDeclaration");
          }
          __name(f, "f");
          function x(_, b, N) {
            let k = _.getValue();
            if (!k.source)
              return "";
            let R = [];
            return E(k, b) || R.push(" from"), R.push(" ", N("source")), R;
          }
          __name(x, "x");
          function m(_, b, N) {
            let k = _.getValue();
            if (E(k, b))
              return "";
            let R = [" "];
            if (t(k.specifiers)) {
              let M = [], q = [];
              _.each(() => {
                let J = _.getValue().type;
                if (J === "ExportNamespaceSpecifier" || J === "ExportDefaultSpecifier" || J === "ImportNamespaceSpecifier" || J === "ImportDefaultSpecifier")
                  M.push(N());
                else if (J === "ExportSpecifier" || J === "ImportSpecifier")
                  q.push(N());
                else
                  throw new Error(`Unknown specifier type ${JSON.stringify(J)}`);
              }, "specifiers"), R.push(u(", ", M)), q.length > 0 && (M.length > 0 && R.push(", "), q.length > 1 || M.length > 0 || k.specifiers.some((L) => h(L)) ? R.push(a(["{", r([b.bracketSpacing ? i : s, u([",", i], q)]), l(p(b) ? "," : ""), b.bracketSpacing ? i : s, "}"])) : R.push(["{", b.bracketSpacing ? " " : "", ...q, b.bracketSpacing ? " " : "", "}"]));
            } else
              R.push("{}");
            return R;
          }
          __name(m, "m");
          function E(_, b) {
            let { type: N, importKind: k, source: R, specifiers: M } = _;
            return N !== "ImportDeclaration" || t(M) || k === "type" ? false : !/{\s*}/.test(b.originalText.slice(T(_), T(R)));
          }
          __name(E, "E");
          function o(_, b, N) {
            let k = _.getNode();
            return t(k.assertions) ? [" assert {", b.bracketSpacing ? " " : "", u(", ", _.map(N, "assertions")), b.bracketSpacing ? " " : "", "}"] : "";
          }
          __name(o, "o");
          function d(_, b, N) {
            let k = _.getNode(), { type: R } = k, M = [], q = R === "ImportSpecifier" ? k.importKind : k.exportKind;
            q && q !== "value" && M.push(q, " ");
            let J = R.startsWith("Import"), L = J ? "imported" : "local", Y = J ? "local" : "exported", V = k[L], O = k[Y], K = "", se = "";
            return R === "ExportNamespaceSpecifier" || R === "ImportNamespaceSpecifier" ? K = "*" : V && (K = N(L)), O && !C(k) && (se = N(Y)), M.push(K, K && se ? " as " : "", se), M;
          }
          __name(d, "d");
          function C(_) {
            if (_.type !== "ImportSpecifier" && _.type !== "ExportSpecifier")
              return false;
            let { local: b, [_.type === "ImportSpecifier" ? "imported" : "exported"]: N } = _;
            if (b.type !== N.type || !F(b, N))
              return false;
            if (v(b))
              return b.value === N.value && w(b) === w(N);
            switch (b.type) {
              case "Identifier":
                return b.name === N.name;
              default:
                return false;
            }
          }
          __name(C, "C");
          n.exports = { printImportDeclaration: I, printExportDeclaration: P, printExportAllDeclaration: $, printModuleSpecifier: d };
        } }), Xn = ee({ "src/language-js/print/object.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, group: r, indent: u, ifBreak: i, hardline: l } } = qe(), { getLast: c, hasNewlineInRange: y, hasNewline: h, isNonEmptyArray: g } = Ge(), { shouldPrintComma: p, hasComment: D, getComments: v, CommentCheckFlags: w, isNextLineEmpty: T } = Ke(), { locStart: F, locEnd: A } = it(), { printOptionalToken: B, printTypeAnnotation: I } = Dt(), { shouldHugFunctionParameters: P } = kr(), { shouldHugType: $ } = Lr(), { printHardlineAfterHeritage: f } = tr();
          function x(m, E, o) {
            let d = E.semi ? ";" : "", C = m.getValue(), _;
            C.type === "TSTypeLiteral" ? _ = "members" : C.type === "TSInterfaceBody" ? _ = "body" : _ = "properties";
            let b = C.type === "ObjectTypeAnnotation", N = [_];
            b && N.push("indexers", "callProperties", "internalSlots");
            let k = N.map((W) => C[W][0]).sort((W, X) => F(W) - F(X))[0], R = m.getParentNode(0), M = b && R && (R.type === "InterfaceDeclaration" || R.type === "DeclareInterface" || R.type === "DeclareClass") && m.getName() === "body", q = C.type === "TSInterfaceBody" || M || C.type === "ObjectPattern" && R.type !== "FunctionDeclaration" && R.type !== "FunctionExpression" && R.type !== "ArrowFunctionExpression" && R.type !== "ObjectMethod" && R.type !== "ClassMethod" && R.type !== "ClassPrivateMethod" && R.type !== "AssignmentPattern" && R.type !== "CatchClause" && C.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || C.type !== "ObjectPattern" && k && y(E.originalText, F(C), F(k)), J = M ? ";" : C.type === "TSInterfaceBody" || C.type === "TSTypeLiteral" ? i(d, ";") : ",", L = C.type === "RecordExpression" ? "#{" : C.exact ? "{|" : "{", Y = C.exact ? "|}" : "}", V = [];
            for (let W of N)
              m.each((X) => {
                let oe = X.getValue();
                V.push({ node: oe, printed: o(), loc: F(oe) });
              }, W);
            N.length > 1 && V.sort((W, X) => W.loc - X.loc);
            let O = [], K = V.map((W) => {
              let X = [...O, r(W.printed)];
              return O = [J, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && D(W.node, w.PrettierIgnore) && O.shift(), T(W.node, E) && O.push(l), X;
            });
            if (C.inexact) {
              let W;
              if (D(C, w.Dangling)) {
                let X = D(C, w.Line);
                W = [t(m, E, true), X || h(E.originalText, A(c(v(C)))) ? l : s, "..."];
              } else
                W = ["..."];
              K.push([...O, ...W]);
            }
            let se = c(C[_]), Q = !(C.inexact || se && se.type === "RestElement" || se && (se.type === "TSPropertySignature" || se.type === "TSCallSignatureDeclaration" || se.type === "TSMethodSignature" || se.type === "TSConstructSignatureDeclaration") && D(se, w.PrettierIgnore)), le;
            if (K.length === 0) {
              if (!D(C, w.Dangling))
                return [L, Y, I(m, E, o)];
              le = r([L, t(m, E), a, Y, B(m), I(m, E, o)]);
            } else
              le = [M && g(C.properties) ? f(R) : "", L, u([E.bracketSpacing ? s : a, ...K]), i(Q && (J !== "," || p(E)) ? J : ""), E.bracketSpacing ? s : a, Y, B(m), I(m, E, o)];
            return m.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, X, oe) => P(W) && (X === "params" || X === "parameters" || X === "this" || X === "rest") && oe === 0) || m.match($, (W, X) => X === "typeAnnotation", (W, X) => X === "typeAnnotation", (W, X, oe) => P(W) && (X === "params" || X === "parameters" || X === "this" || X === "rest") && oe === 0) || !q && m.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? le : r(le, { shouldBreak: q });
          }
          __name(x, "x");
          n.exports = { printObject: x };
        } }), Vm = ee({ "src/language-js/print/flow.js"(e, n) {
          "use strict";
          re();
          var t = Yt(), { printDanglingComments: s } = et(), { printString: a, printNumber: r } = Ge(), { builders: { hardline: u, softline: i, group: l, indent: c } } = qe(), { getParentExportDeclaration: y, isFunctionNotation: h, isGetterOrSetter: g, rawText: p, shouldPrintComma: D } = Ke(), { locStart: v, locEnd: w } = it(), { replaceTextEndOfLine: T } = Xt(), { printClass: F } = tr(), { printOpaqueType: A, printTypeAlias: B, printIntersectionType: I, printUnionType: P, printFunctionType: $, printTupleType: f, printIndexedAccessType: x } = Lr(), { printInterface: m } = uo(), { printTypeParameter: E, printTypeParameters: o } = jr(), { printExportDeclaration: d, printExportAllDeclaration: C } = so(), { printArrayItems: _ } = Qt(), { printObject: b } = Xn(), { printPropertyKey: N } = er(), { printOptionalToken: k, printTypeAnnotation: R, printRestSpread: M } = Dt();
          function q(L, Y, V) {
            let O = L.getValue(), K = Y.semi ? ";" : "", se = [];
            switch (O.type) {
              case "DeclareClass":
                return J(L, F(L, Y, V));
              case "DeclareFunction":
                return J(L, ["function ", V("id"), O.predicate ? " " : "", V("predicate"), K]);
              case "DeclareModule":
                return J(L, ["module ", V("id"), " ", V("body")]);
              case "DeclareModuleExports":
                return J(L, ["module.exports", ": ", V("typeAnnotation"), K]);
              case "DeclareVariable":
                return J(L, ["var ", V("id"), K]);
              case "DeclareOpaqueType":
                return J(L, A(L, Y, V));
              case "DeclareInterface":
                return J(L, m(L, Y, V));
              case "DeclareTypeAlias":
                return J(L, B(L, Y, V));
              case "DeclareExportDeclaration":
                return J(L, d(L, Y, V));
              case "DeclareExportAllDeclaration":
                return J(L, C(L, Y, V));
              case "OpaqueType":
                return A(L, Y, V);
              case "TypeAlias":
                return B(L, Y, V);
              case "IntersectionTypeAnnotation":
                return I(L, Y, V);
              case "UnionTypeAnnotation":
                return P(L, Y, V);
              case "FunctionTypeAnnotation":
                return $(L, Y, V);
              case "TupleTypeAnnotation":
                return f(L, Y, V);
              case "GenericTypeAnnotation":
                return [V("id"), o(L, Y, V, "typeParameters")];
              case "IndexedAccessType":
              case "OptionalIndexedAccessType":
                return x(L, Y, V);
              case "TypeAnnotation":
                return V("typeAnnotation");
              case "TypeParameter":
                return E(L, Y, V);
              case "TypeofTypeAnnotation":
                return ["typeof ", V("argument")];
              case "ExistsTypeAnnotation":
                return "*";
              case "EmptyTypeAnnotation":
                return "empty";
              case "MixedTypeAnnotation":
                return "mixed";
              case "ArrayTypeAnnotation":
                return [V("elementType"), "[]"];
              case "BooleanLiteralTypeAnnotation":
                return String(O.value);
              case "EnumDeclaration":
                return ["enum ", V("id"), " ", V("body")];
              case "EnumBooleanBody":
              case "EnumNumberBody":
              case "EnumStringBody":
              case "EnumSymbolBody": {
                if (O.type === "EnumSymbolBody" || O.explicitType) {
                  let Q = null;
                  switch (O.type) {
                    case "EnumBooleanBody":
                      Q = "boolean";
                      break;
                    case "EnumNumberBody":
                      Q = "number";
                      break;
                    case "EnumStringBody":
                      Q = "string";
                      break;
                    case "EnumSymbolBody":
                      Q = "symbol";
                      break;
                  }
                  se.push("of ", Q, " ");
                }
                if (O.members.length === 0 && !O.hasUnknownMembers)
                  se.push(l(["{", s(L, Y), i, "}"]));
                else {
                  let Q = O.members.length > 0 ? [u, _(L, Y, "members", V), O.hasUnknownMembers || D(Y) ? "," : ""] : [];
                  se.push(l(["{", c([...Q, ...O.hasUnknownMembers ? [u, "..."] : []]), s(L, Y, true), u, "}"]));
                }
                return se;
              }
              case "EnumBooleanMember":
              case "EnumNumberMember":
              case "EnumStringMember":
                return [V("id"), " = ", typeof O.init == "object" ? V("init") : String(O.init)];
              case "EnumDefaultedMember":
                return V("id");
              case "FunctionTypeParam": {
                let Q = O.name ? V("name") : L.getParentNode().this === O ? "this" : "";
                return [Q, k(L), Q ? ": " : "", V("typeAnnotation")];
              }
              case "InterfaceDeclaration":
              case "InterfaceTypeAnnotation":
                return m(L, Y, V);
              case "ClassImplements":
              case "InterfaceExtends":
                return [V("id"), V("typeParameters")];
              case "NullableTypeAnnotation":
                return ["?", V("typeAnnotation")];
              case "Variance": {
                let { kind: Q } = O;
                return t.ok(Q === "plus" || Q === "minus"), Q === "plus" ? "+" : "-";
              }
              case "ObjectTypeCallProperty":
                return O.static && se.push("static "), se.push(V("value")), se;
              case "ObjectTypeIndexer":
                return [O.static ? "static " : "", O.variance ? V("variance") : "", "[", V("id"), O.id ? ": " : "", V("key"), "]: ", V("value")];
              case "ObjectTypeProperty": {
                let Q = "";
                return O.proto ? Q = "proto " : O.static && (Q = "static "), [Q, g(O) ? O.kind + " " : "", O.variance ? V("variance") : "", N(L, Y, V), k(L), h(O) ? "" : ": ", V("value")];
              }
              case "ObjectTypeAnnotation":
                return b(L, Y, V);
              case "ObjectTypeInternalSlot":
                return [O.static ? "static " : "", "[[", V("id"), "]]", k(L), O.method ? "" : ": ", V("value")];
              case "ObjectTypeSpreadProperty":
                return M(L, Y, V);
              case "QualifiedTypeofIdentifier":
              case "QualifiedTypeIdentifier":
                return [V("qualification"), ".", V("id")];
              case "StringLiteralTypeAnnotation":
                return T(a(p(O), Y));
              case "NumberLiteralTypeAnnotation":
                t.strictEqual(typeof O.value, "number");
              case "BigIntLiteralTypeAnnotation":
                return O.extra ? r(O.extra.raw) : r(O.raw);
              case "TypeCastExpression":
                return ["(", V("expression"), R(L, Y, V), ")"];
              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation": {
                let Q = o(L, Y, V, "params");
                if (Y.parser === "flow") {
                  let le = v(O), W = w(O), X = Y.originalText.lastIndexOf("/*", le), oe = Y.originalText.indexOf("*/", W);
                  if (X !== -1 && oe !== -1) {
                    let ae = Y.originalText.slice(X + 2, oe).trim();
                    if (ae.startsWith("::") && !ae.includes("/*") && !ae.includes("*/"))
                      return ["/*:: ", Q, " */"];
                  }
                }
                return Q;
              }
              case "InferredPredicate":
                return "%checks";
              case "DeclaredPredicate":
                return ["%checks(", V("value"), ")"];
              case "AnyTypeAnnotation":
                return "any";
              case "BooleanTypeAnnotation":
                return "boolean";
              case "BigIntTypeAnnotation":
                return "bigint";
              case "NullLiteralTypeAnnotation":
                return "null";
              case "NumberTypeAnnotation":
                return "number";
              case "SymbolTypeAnnotation":
                return "symbol";
              case "StringTypeAnnotation":
                return "string";
              case "VoidTypeAnnotation":
                return "void";
              case "ThisTypeAnnotation":
                return "this";
              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "MemberTypeAnnotation":
              case "Type":
                throw new Error("unprintable type: " + JSON.stringify(O.type));
            }
          }
          __name(q, "q");
          function J(L, Y) {
            let V = y(L);
            return V ? (t.strictEqual(V.type, "DeclareExportDeclaration"), Y) : ["declare ", Y];
          }
          __name(J, "J");
          n.exports = { printFlow: q };
        } }), Wm = ee({ "src/language-js/utils/is-ts-keyword-type.js"(e, n) {
          "use strict";
          re();
          function t(s) {
            let { type: a } = s;
            return a.startsWith("TS") && a.endsWith("Keyword");
          }
          __name(t, "t");
          n.exports = t;
        } }), io = ee({ "src/language-js/print/ternary.js"(e, n) {
          "use strict";
          re();
          var { hasNewlineInRange: t } = Ge(), { isJsxNode: s, getComments: a, isCallExpression: r, isMemberExpression: u, isTSTypeExpression: i } = Ke(), { locStart: l, locEnd: c } = it(), y = Lt(), { builders: { line: h, softline: g, group: p, indent: D, align: v, ifBreak: w, dedent: T, breakParent: F } } = qe();
          function A(f) {
            let x = [f];
            for (let m = 0; m < x.length; m++) {
              let E = x[m];
              for (let o of ["test", "consequent", "alternate"]) {
                let d = E[o];
                if (s(d))
                  return true;
                d.type === "ConditionalExpression" && x.push(d);
              }
            }
            return false;
          }
          __name(A, "A");
          function B(f, x, m) {
            let E = f.getValue(), o = E.type === "ConditionalExpression", d = o ? "alternate" : "falseType", C = f.getParentNode(), _ = o ? m("test") : [m("checkType"), " ", "extends", " ", m("extendsType")];
            return C.type === E.type && C[d] === E ? v(2, _) : _;
          }
          __name(B, "B");
          var I = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
          function P(f) {
            let x = f.getValue();
            if (x.type !== "ConditionalExpression")
              return false;
            let m, E = x;
            for (let o = 0; !m; o++) {
              let d = f.getParentNode(o);
              if (r(d) && d.callee === E || u(d) && d.object === E || d.type === "TSNonNullExpression" && d.expression === E) {
                E = d;
                continue;
              }
              d.type === "NewExpression" && d.callee === E || i(d) && d.expression === E ? (m = f.getParentNode(o + 1), E = d) : m = d;
            }
            return E === x ? false : m[I.get(m.type)] === E;
          }
          __name(P, "P");
          function $(f, x, m) {
            let E = f.getValue(), o = E.type === "ConditionalExpression", d = o ? "consequent" : "trueType", C = o ? "alternate" : "falseType", _ = o ? ["test"] : ["checkType", "extendsType"], b = E[d], N = E[C], k = [], R = false, M = f.getParentNode(), q = M.type === E.type && _.some((ae) => M[ae] === E), J = M.type === E.type && !q, L, Y, V = 0;
            do
              Y = L || E, L = f.getParentNode(V), V++;
            while (L && L.type === E.type && _.every((ae) => L[ae] !== Y));
            let O = L || M, K = Y;
            if (o && (s(E[_[0]]) || s(b) || s(N) || A(K))) {
              R = true, J = true;
              let ae = /* @__PURE__ */ __name((z) => [w("("), D([g, z]), g, w(")")], "ae"), Ae = /* @__PURE__ */ __name((z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined", "Ae");
              k.push(" ? ", Ae(b) ? m(d) : ae(m(d)), " : ", N.type === E.type || Ae(N) ? m(C) : ae(m(C)));
            } else {
              let ae = [h, "? ", b.type === E.type ? w("", "(") : "", v(2, m(d)), b.type === E.type ? w("", ")") : "", h, ": ", N.type === E.type ? m(C) : v(2, m(C))];
              k.push(M.type !== E.type || M[C] === E || q ? ae : x.useTabs ? T(D(ae)) : v(Math.max(0, x.tabWidth - 2), ae));
            }
            let Q = [..._.map((ae) => a(E[ae])), a(b), a(N)].flat().some((ae) => y(ae) && t(x.originalText, l(ae), c(ae))), le = /* @__PURE__ */ __name((ae) => M === O ? p(ae, { shouldBreak: Q }) : Q ? [ae, F] : ae, "le"), W = !R && (u(M) || M.type === "NGPipeExpression" && M.left === E) && !M.computed, X = P(f), oe = le([B(f, x, m), J ? k : D(k), o && W && !X ? g : ""]);
            return q || X ? p([D([g, oe]), g]) : oe;
          }
          __name($, "$");
          n.exports = { printTernary: $ };
        } }), ao = ee({ "src/language-js/print/statement.js"(e, n) {
          "use strict";
          re();
          var { builders: { hardline: t } } = qe(), s = Ot(), { getLeftSidePathName: a, hasNakedLeftSide: r, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: l, CommentCheckFlags: c, isNextLineEmpty: y } = Ke(), { shouldPrintParamsWithoutParens: h } = Or();
          function g(B, I, P, $) {
            let f = B.getValue(), x = [], m = f.type === "ClassBody", E = p(f[$]);
            return B.each((o, d, C) => {
              let _ = o.getValue();
              if (_.type === "EmptyStatement")
                return;
              let b = P();
              !I.semi && !m && !i(I, o) && D(o, I) ? l(_, c.Leading) ? x.push(P([], { needsSemi: true })) : x.push(";", b) : x.push(b), !I.semi && m && F(_) && A(_, C[d + 1]) && x.push(";"), _ !== E && (x.push(t), y(_, I) && x.push(t));
            }, $), x;
          }
          __name(g, "g");
          function p(B) {
            for (let I = B.length - 1; I >= 0; I--) {
              let P = B[I];
              if (P.type !== "EmptyStatement")
                return P;
            }
          }
          __name(p, "p");
          function D(B, I) {
            return B.getNode().type !== "ExpressionStatement" ? false : B.call(($) => v($, I), "expression");
          }
          __name(D, "D");
          function v(B, I) {
            let P = B.getValue();
            switch (P.type) {
              case "ParenthesizedExpression":
              case "TypeCastExpression":
              case "ArrayExpression":
              case "ArrayPattern":
              case "TemplateLiteral":
              case "TemplateElement":
              case "RegExpLiteral":
                return true;
              case "ArrowFunctionExpression": {
                if (!h(B, I))
                  return true;
                break;
              }
              case "UnaryExpression": {
                let { prefix: $, operator: f } = P;
                if ($ && (f === "+" || f === "-"))
                  return true;
                break;
              }
              case "BindExpression": {
                if (!P.object)
                  return true;
                break;
              }
              case "Literal": {
                if (P.regex)
                  return true;
                break;
              }
              default:
                if (u(P))
                  return true;
            }
            return s(B, I) ? true : r(P) ? B.call(($) => v($, I), ...a(B, P)) : false;
          }
          __name(v, "v");
          function w(B, I, P) {
            return g(B, I, P, "body");
          }
          __name(w, "w");
          function T(B, I, P) {
            return g(B, I, P, "consequent");
          }
          __name(T, "T");
          var F = /* @__PURE__ */ __name((B) => {
            let { type: I } = B;
            return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty" || I === "AccessorProperty" || I === "TSAbstractPropertyDefinition" || I === "TSAbstractAccessorProperty";
          }, "F");
          function A(B, I) {
            let { name: P } = B.key;
            if ((P === "static" || P === "get" || P === "set" || P === "accessor") && !B.value && !B.typeAnnotation)
              return true;
            if (!I || I.static || I.accessibility)
              return false;
            if (!I.computed) {
              let $ = I.key && I.key.name;
              if ($ === "in" || $ === "instanceof")
                return true;
            }
            if (F(I) && I.variance && !I.static && !I.declare)
              return true;
            switch (I.type) {
              case "ClassProperty":
              case "PropertyDefinition":
              case "TSAbstractPropertyDefinition":
                return I.computed;
              case "MethodDefinition":
              case "TSAbstractMethodDefinition":
              case "ClassMethod":
              case "ClassPrivateMethod": {
                if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set")
                  return false;
                let f = I.value ? I.value.generator : I.generator;
                return !!(I.computed || f);
              }
              case "TSIndexSignature":
                return true;
            }
            return false;
          }
          __name(A, "A");
          n.exports = { printBody: w, printSwitchCaseConsequent: T };
        } }), oo = ee({ "src/language-js/print/block.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { isNonEmptyArray: s } = Ge(), { builders: { hardline: a, indent: r } } = qe(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: l } = Ke(), { printHardlineAfterHeritage: c } = tr(), { printBody: y } = ao();
          function h(p, D, v) {
            let w = p.getValue(), T = [];
            if (w.type === "StaticBlock" && T.push("static "), w.type === "ClassBody" && s(w.body)) {
              let A = p.getParentNode();
              T.push(c(A));
            }
            T.push("{");
            let F = g(p, D, v);
            if (F)
              T.push(r([a, F]), a);
            else {
              let A = p.getParentNode(), B = p.getParentNode(1);
              A.type === "ArrowFunctionExpression" || A.type === "FunctionExpression" || A.type === "FunctionDeclaration" || A.type === "ObjectMethod" || A.type === "ClassMethod" || A.type === "ClassPrivateMethod" || A.type === "ForStatement" || A.type === "WhileStatement" || A.type === "DoWhileStatement" || A.type === "DoExpression" || A.type === "CatchClause" && !B.finalizer || A.type === "TSModuleDeclaration" || A.type === "TSDeclareFunction" || w.type === "StaticBlock" || w.type === "ClassBody" || T.push(a);
            }
            return T.push("}"), T;
          }
          __name(h, "h");
          function g(p, D, v) {
            let w = p.getValue(), T = s(w.directives), F = w.body.some((I) => I.type !== "EmptyStatement"), A = u(w, i.Dangling);
            if (!T && !F && !A)
              return "";
            let B = [];
            if (T && p.each((I, P, $) => {
              B.push(v()), (P < $.length - 1 || F || A) && (B.push(a), l(I.getValue(), D) && B.push(a));
            }, "directives"), F && B.push(y(p, D, v)), A && B.push(t(p, D, true)), w.type === "Program") {
              let I = p.getParentNode();
              (!I || I.type !== "ModuleExpression") && B.push(a);
            }
            return B;
          }
          __name(g, "g");
          n.exports = { printBlock: h, printBlockBody: g };
        } }), Hm = ee({ "src/language-js/print/typescript.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { hasNewlineInRange: s } = Ge(), { builders: { join: a, line: r, hardline: u, softline: i, group: l, indent: c, conditionalGroup: y, ifBreak: h } } = qe(), { isLiteral: g, getTypeScriptMappedTypeModifier: p, shouldPrintComma: D, isCallExpression: v, isMemberExpression: w } = Ke(), T = Wm(), { locStart: F, locEnd: A } = it(), { printOptionalToken: B, printTypeScriptModifiers: I } = Dt(), { printTernary: P } = io(), { printFunctionParameters: $, shouldGroupFunctionParameters: f } = kr(), { printTemplateLiteral: x } = jt(), { printArrayItems: m } = Qt(), { printObject: E } = Xn(), { printClassProperty: o, printClassMethod: d } = tr(), { printTypeParameter: C, printTypeParameters: _ } = jr(), { printPropertyKey: b } = er(), { printFunction: N, printMethodInternal: k } = Or(), { printInterface: R } = uo(), { printBlock: M } = oo(), { printTypeAlias: q, printIntersectionType: J, printUnionType: L, printFunctionType: Y, printTupleType: V, printIndexedAccessType: O, printJSDocType: K } = Lr();
          function se(Q, le, W) {
            let X = Q.getValue();
            if (!X.type.startsWith("TS"))
              return;
            if (T(X))
              return X.type.slice(2, -7).toLowerCase();
            let oe = le.semi ? ";" : "", ae = [];
            switch (X.type) {
              case "TSThisType":
                return "this";
              case "TSTypeAssertion": {
                let Ae = !(X.expression.type === "ArrayExpression" || X.expression.type === "ObjectExpression"), z = l(["<", c([i, W("typeAnnotation")]), i, ">"]), H = [h("("), c([i, W("expression")]), i, h(")")];
                return Ae ? y([[z, W("expression")], [z, l(H, { shouldBreak: true })], [z, W("expression")]]) : l([z, W("expression")]);
              }
              case "TSDeclareFunction":
                return N(Q, W, le);
              case "TSExportAssignment":
                return ["export = ", W("expression"), oe];
              case "TSModuleBlock":
                return M(Q, le, W);
              case "TSInterfaceBody":
              case "TSTypeLiteral":
                return E(Q, le, W);
              case "TSTypeAliasDeclaration":
                return q(Q, le, W);
              case "TSQualifiedName":
                return a(".", [W("left"), W("right")]);
              case "TSAbstractMethodDefinition":
              case "TSDeclareMethod":
                return d(Q, le, W);
              case "TSAbstractAccessorProperty":
              case "TSAbstractPropertyDefinition":
                return o(Q, le, W);
              case "TSInterfaceHeritage":
              case "TSExpressionWithTypeArguments":
                return ae.push(W("expression")), X.typeParameters && ae.push(W("typeParameters")), ae;
              case "TSTemplateLiteralType":
                return x(Q, W, le);
              case "TSNamedTupleMember":
                return [W("label"), X.optional ? "?" : "", ": ", W("elementType")];
              case "TSRestType":
                return ["...", W("typeAnnotation")];
              case "TSOptionalType":
                return [W("typeAnnotation"), "?"];
              case "TSInterfaceDeclaration":
                return R(Q, le, W);
              case "TSClassImplements":
                return [W("expression"), W("typeParameters")];
              case "TSTypeParameterDeclaration":
              case "TSTypeParameterInstantiation":
                return _(Q, le, W, "params");
              case "TSTypeParameter":
                return C(Q, le, W);
              case "TSSatisfiesExpression":
              case "TSAsExpression": {
                let Ae = X.type === "TSAsExpression" ? "as" : "satisfies";
                ae.push(W("expression"), ` ${Ae} `, W("typeAnnotation"));
                let z = Q.getParentNode();
                return v(z) && z.callee === X || w(z) && z.object === X ? l([c([i, ...ae]), i]) : ae;
              }
              case "TSArrayType":
                return [W("elementType"), "[]"];
              case "TSPropertySignature":
                return X.readonly && ae.push("readonly "), ae.push(b(Q, le, W), B(Q)), X.typeAnnotation && ae.push(": ", W("typeAnnotation")), X.initializer && ae.push(" = ", W("initializer")), ae;
              case "TSParameterProperty":
                return X.accessibility && ae.push(X.accessibility + " "), X.export && ae.push("export "), X.static && ae.push("static "), X.override && ae.push("override "), X.readonly && ae.push("readonly "), ae.push(W("parameter")), ae;
              case "TSTypeQuery":
                return ["typeof ", W("exprName"), W("typeParameters")];
              case "TSIndexSignature": {
                let Ae = Q.getParentNode(), z = X.parameters.length > 1 ? h(D(le) ? "," : "") : "", H = l([c([i, a([", ", i], Q.map(W, "parameters"))]), z, i]);
                return [X.export ? "export " : "", X.accessibility ? [X.accessibility, " "] : "", X.static ? "static " : "", X.readonly ? "readonly " : "", X.declare ? "declare " : "", "[", X.parameters ? H : "", X.typeAnnotation ? "]: " : "]", X.typeAnnotation ? W("typeAnnotation") : "", Ae.type === "ClassBody" ? oe : ""];
              }
              case "TSTypePredicate":
                return [X.asserts ? "asserts " : "", W("parameterName"), X.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
              case "TSNonNullExpression":
                return [W("expression"), "!"];
              case "TSImportType":
                return [X.isTypeOf ? "typeof " : "", "import(", W(X.parameter ? "parameter" : "argument"), ")", X.qualifier ? [".", W("qualifier")] : "", _(Q, le, W, "typeParameters")];
              case "TSLiteralType":
                return W("literal");
              case "TSIndexedAccessType":
                return O(Q, le, W);
              case "TSConstructSignatureDeclaration":
              case "TSCallSignatureDeclaration":
              case "TSConstructorType": {
                if (X.type === "TSConstructorType" && X.abstract && ae.push("abstract "), X.type !== "TSCallSignatureDeclaration" && ae.push("new "), ae.push(l($(Q, W, le, false, true))), X.returnType || X.typeAnnotation) {
                  let Ae = X.type === "TSConstructorType";
                  ae.push(Ae ? " => " : ": ", W("returnType"), W("typeAnnotation"));
                }
                return ae;
              }
              case "TSTypeOperator":
                return [X.operator, " ", W("typeAnnotation")];
              case "TSMappedType": {
                let Ae = s(le.originalText, F(X), A(X));
                return l(["{", c([le.bracketSpacing ? r : i, X.readonly ? [p(X.readonly, "readonly"), " "] : "", I(Q, le, W), W("typeParameter"), X.optional ? p(X.optional, "?") : "", X.typeAnnotation ? ": " : "", W("typeAnnotation"), h(oe)]), t(Q, le, true), le.bracketSpacing ? r : i, "}"], { shouldBreak: Ae });
              }
              case "TSMethodSignature": {
                let Ae = X.kind && X.kind !== "method" ? `${X.kind} ` : "";
                ae.push(X.accessibility ? [X.accessibility, " "] : "", Ae, X.export ? "export " : "", X.static ? "static " : "", X.readonly ? "readonly " : "", X.abstract ? "abstract " : "", X.declare ? "declare " : "", X.computed ? "[" : "", W("key"), X.computed ? "]" : "", B(Q));
                let z = $(Q, W, le, false, true), H = X.returnType ? "returnType" : "typeAnnotation", Z = X[H], ne = Z ? W(H) : "", fe = f(X, ne);
                return ae.push(fe ? l(z) : z), Z && ae.push(": ", l(ne)), l(ae);
              }
              case "TSNamespaceExportDeclaration":
                return ae.push("export as namespace ", W("id")), le.semi && ae.push(";"), l(ae);
              case "TSEnumDeclaration":
                return X.declare && ae.push("declare "), X.modifiers && ae.push(I(Q, le, W)), X.const && ae.push("const "), ae.push("enum ", W("id"), " "), X.members.length === 0 ? ae.push(l(["{", t(Q, le), i, "}"])) : ae.push(l(["{", c([u, m(Q, le, "members", W), D(le, "es5") ? "," : ""]), t(Q, le, true), u, "}"])), ae;
              case "TSEnumMember":
                return X.computed ? ae.push("[", W("id"), "]") : ae.push(W("id")), X.initializer && ae.push(" = ", W("initializer")), ae;
              case "TSImportEqualsDeclaration":
                return X.isExport && ae.push("export "), ae.push("import "), X.importKind && X.importKind !== "value" && ae.push(X.importKind, " "), ae.push(W("id"), " = ", W("moduleReference")), le.semi && ae.push(";"), l(ae);
              case "TSExternalModuleReference":
                return ["require(", W("expression"), ")"];
              case "TSModuleDeclaration": {
                let Ae = Q.getParentNode(), z = g(X.id), H = Ae.type === "TSModuleDeclaration", Z = X.body && X.body.type === "TSModuleDeclaration";
                if (H)
                  ae.push(".");
                else {
                  X.declare && ae.push("declare "), ae.push(I(Q, le, W));
                  let ne = le.originalText.slice(F(X), F(X.id));
                  X.id.type === "Identifier" && X.id.name === "global" && !/namespace|module/.test(ne) || ae.push(z || /(?:^|\s)module(?:\s|$)/.test(ne) ? "module " : "namespace ");
                }
                return ae.push(W("id")), Z ? ae.push(W("body")) : X.body ? ae.push(" ", l(W("body"))) : ae.push(oe), ae;
              }
              case "TSConditionalType":
                return P(Q, le, W);
              case "TSInferType":
                return ["infer", " ", W("typeParameter")];
              case "TSIntersectionType":
                return J(Q, le, W);
              case "TSUnionType":
                return L(Q, le, W);
              case "TSFunctionType":
                return Y(Q, le, W);
              case "TSTupleType":
                return V(Q, le, W);
              case "TSTypeReference":
                return [W("typeName"), _(Q, le, W, "typeParameters")];
              case "TSTypeAnnotation":
                return W("typeAnnotation");
              case "TSEmptyBodyFunctionExpression":
                return k(Q, le, W);
              case "TSJSDocAllType":
                return "*";
              case "TSJSDocUnknownType":
                return "?";
              case "TSJSDocNullableType":
                return K(Q, W, "?");
              case "TSJSDocNonNullableType":
                return K(Q, W, "!");
              case "TSInstantiationExpression":
                return [W("expression"), W("typeParameters")];
              default:
                throw new Error(`Unknown TypeScript node type: ${JSON.stringify(X.type)}.`);
            }
          }
          __name(se, "se");
          n.exports = { printTypescript: se };
        } }), Gm = ee({ "src/language-js/print/comment.js"(e, n) {
          "use strict";
          re();
          var { hasNewline: t } = Ge(), { builders: { join: s, hardline: a }, utils: { replaceTextEndOfLine: r } } = qe(), { isLineComment: u } = Ke(), { locStart: i, locEnd: l } = it(), c = Lt();
          function y(p, D) {
            let v = p.getValue();
            if (u(v))
              return D.originalText.slice(i(v), l(v)).trimEnd();
            if (c(v)) {
              if (h(v)) {
                let F = g(v);
                return v.trailing && !t(D.originalText, i(v), { backwards: true }) ? [a, F] : F;
              }
              let w = l(v), T = D.originalText.slice(w - 3, w) === "*-/";
              return ["/*", r(v.value), T ? "*-/" : "*/"];
            }
            throw new Error("Not a comment: " + JSON.stringify(v));
          }
          __name(y, "y");
          function h(p) {
            let D = `*${p.value}*`.split(`
`);
            return D.length > 1 && D.every((v) => v.trim()[0] === "*");
          }
          __name(h, "h");
          function g(p) {
            let D = p.value.split(`
`);
            return ["/*", s(a, D.map((v, w) => w === 0 ? v.trimEnd() : " " + (w < D.length - 1 ? v.trim() : v.trimStart()))), "*/"];
          }
          __name(g, "g");
          n.exports = { printComment: y };
        } }), Um = ee({ "src/language-js/print/literal.js"(e, n) {
          "use strict";
          re();
          var { printString: t, printNumber: s } = Ge(), { replaceTextEndOfLine: a } = Xt();
          function r(l, c) {
            let y = l.getNode();
            switch (y.type) {
              case "RegExpLiteral":
                return i(y);
              case "BigIntLiteral":
                return u(y.bigint || y.extra.raw);
              case "NumericLiteral":
                return s(y.extra.raw);
              case "StringLiteral":
                return a(t(y.extra.raw, c));
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return String(y.value);
              case "DecimalLiteral":
                return s(y.value) + "m";
              case "Literal": {
                if (y.regex)
                  return i(y.regex);
                if (y.bigint)
                  return u(y.raw);
                if (y.decimal)
                  return s(y.decimal) + "m";
                let { value: h } = y;
                return typeof h == "number" ? s(y.raw) : typeof h == "string" ? a(t(y.raw, c)) : String(h);
              }
            }
          }
          __name(r, "r");
          function u(l) {
            return l.toLowerCase();
          }
          __name(u, "u");
          function i(l) {
            let { pattern: c, flags: y } = l;
            return y = [...y].sort().join(""), `/${c}/${y}`;
          }
          __name(i, "i");
          n.exports = { printLiteral: r };
        } }), Jm = ee({ "src/language-js/printer-estree.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { hasNewline: s } = Ge(), { builders: { join: a, line: r, hardline: u, softline: i, group: l, indent: c }, utils: { replaceTextEndOfLine: y } } = qe(), h = Nm(), g = wm(), { insertPragma: p } = Qa(), D = Za(), v = Ot(), w = eo(), { hasFlowShorthandAnnotationComment: T, hasComment: F, CommentCheckFlags: A, isTheOnlyJsxElementInMarkdown: B, isLineComment: I, isNextLineEmpty: P, needsHardlineAfterDanglingComment: $, rawText: f, hasIgnoreComment: x, isCallExpression: m, isMemberExpression: E, markerForIfWithoutBlockAndSameLineComment: o } = Ke(), { locStart: d, locEnd: C } = it(), _ = Lt(), { printHtmlBinding: b, isVueEventBindingExpression: N } = qm(), { printAngular: k } = Mm(), { printJsx: R, hasJsxIgnoreComment: M } = Rm(), { printFlow: q } = Vm(), { printTypescript: J } = Hm(), { printOptionalToken: L, printBindExpressionCallee: Y, printTypeAnnotation: V, adjustClause: O, printRestSpread: K, printDefiniteToken: se } = Dt(), { printImportDeclaration: Q, printExportDeclaration: le, printExportAllDeclaration: W, printModuleSpecifier: X } = so(), { printTernary: oe } = io(), { printTemplateLiteral: ae } = jt(), { printArray: Ae } = Qt(), { printObject: z } = Xn(), { printClass: H, printClassMethod: Z, printClassProperty: ne } = tr(), { printProperty: fe } = er(), { printFunction: ge, printArrowFunction: Ce, printMethod: _e, printReturnStatement: Oe, printThrowStatement: pe } = Or(), { printCallExpression: ie } = no(), { printVariableDeclarator: ve, printAssignmentExpression: ce } = Zt(), { printBinaryishExpression: U } = Jn(), { printSwitchCaseConsequent: de } = ao(), { printMemberExpression: De } = ro(), { printBlock: he, printBlockBody: Be } = oo(), { printComment: Se } = Gm(), { printLiteral: ye } = Um(), { printDecorators: S } = zn();
          function G(Te, Pe, Fe, Ze) {
            let xe = te(Te, Pe, Fe, Ze);
            if (!xe)
              return "";
            let Je = Te.getValue(), { type: we } = Je;
            if (we === "ClassMethod" || we === "ClassPrivateMethod" || we === "ClassProperty" || we === "ClassAccessorProperty" || we === "AccessorProperty" || we === "TSAbstractAccessorProperty" || we === "PropertyDefinition" || we === "TSAbstractPropertyDefinition" || we === "ClassPrivateProperty" || we === "MethodDefinition" || we === "TSAbstractMethodDefinition" || we === "TSDeclareMethod")
              return xe;
            let Le = [xe], Ve = S(Te, Pe, Fe), be = Je.type === "ClassExpression" && Ve;
            if (Ve && (Le = [...Ve, xe], !be))
              return l(Le);
            if (!v(Te, Pe))
              return Ze && Ze.needsSemi && Le.unshift(";"), Le.length === 1 && Le[0] === xe ? xe : Le;
            if (be && (Le = [c([r, ...Le])]), Le.unshift("("), Ze && Ze.needsSemi && Le.unshift(";"), T(Je)) {
              let [Me] = Je.trailingComments;
              Le.push(" /*", Me.value.trimStart(), "*/"), Me.printed = true;
            }
            return be && Le.push(r), Le.push(")"), Le;
          }
          __name(G, "G");
          function te(Te, Pe, Fe, Ze) {
            let xe = Te.getValue(), Je = Pe.semi ? ";" : "";
            if (!xe)
              return "";
            if (typeof xe == "string")
              return xe;
            for (let Le of [ye, b, k, R, q, J]) {
              let Ve = Le(Te, Pe, Fe);
              if (typeof Ve < "u")
                return Ve;
            }
            let we = [];
            switch (xe.type) {
              case "JsExpressionRoot":
                return Fe("node");
              case "JsonRoot":
                return [Fe("node"), u];
              case "File":
                return xe.program && xe.program.interpreter && we.push(Fe(["program", "interpreter"])), we.push(Fe("program")), we;
              case "Program":
                return Be(Te, Pe, Fe);
              case "EmptyStatement":
                return "";
              case "ExpressionStatement": {
                if (xe.directive)
                  return [Ee(xe.expression, Pe), Je];
                if (Pe.parser === "__vue_event_binding" || Pe.parser === "__vue_ts_event_binding") {
                  let Ve = Te.getParentNode();
                  if (Ve.type === "Program" && Ve.body.length === 1 && Ve.body[0] === xe)
                    return [Fe("expression"), N(xe.expression) ? ";" : ""];
                }
                let Le = t(Te, Pe, true, (Ve) => {
                  let { marker: be } = Ve;
                  return be === o;
                });
                return [Fe("expression"), B(Pe, Te) ? "" : Je, Le ? [" ", Le] : ""];
              }
              case "ParenthesizedExpression":
                return !F(xe.expression) && (xe.expression.type === "ObjectExpression" || xe.expression.type === "ArrayExpression") ? ["(", Fe("expression"), ")"] : l(["(", c([i, Fe("expression")]), i, ")"]);
              case "AssignmentExpression":
                return ce(Te, Pe, Fe);
              case "VariableDeclarator":
                return ve(Te, Pe, Fe);
              case "BinaryExpression":
              case "LogicalExpression":
                return U(Te, Pe, Fe);
              case "AssignmentPattern":
                return [Fe("left"), " = ", Fe("right")];
              case "OptionalMemberExpression":
              case "MemberExpression":
                return De(Te, Pe, Fe);
              case "MetaProperty":
                return [Fe("meta"), ".", Fe("property")];
              case "BindExpression":
                return xe.object && we.push(Fe("object")), we.push(l(c([i, Y(Te, Pe, Fe)]))), we;
              case "Identifier":
                return [xe.name, L(Te), se(Te), V(Te, Pe, Fe)];
              case "V8IntrinsicIdentifier":
                return ["%", xe.name];
              case "SpreadElement":
              case "SpreadElementPattern":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "RestElement":
                return K(Te, Pe, Fe);
              case "FunctionDeclaration":
              case "FunctionExpression":
                return ge(Te, Fe, Pe, Ze);
              case "ArrowFunctionExpression":
                return Ce(Te, Pe, Fe, Ze);
              case "YieldExpression":
                return we.push("yield"), xe.delegate && we.push("*"), xe.argument && we.push(" ", Fe("argument")), we;
              case "AwaitExpression": {
                if (we.push("await"), xe.argument) {
                  we.push(" ", Fe("argument"));
                  let Le = Te.getParentNode();
                  if (m(Le) && Le.callee === xe || E(Le) && Le.object === xe) {
                    we = [c([i, ...we]), i];
                    let Ve = Te.findAncestor((be) => be.type === "AwaitExpression" || be.type === "BlockStatement");
                    if (!Ve || Ve.type !== "AwaitExpression")
                      return l(we);
                  }
                }
                return we;
              }
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return le(Te, Pe, Fe);
              case "ExportAllDeclaration":
                return W(Te, Pe, Fe);
              case "ImportDeclaration":
                return Q(Te, Pe, Fe);
              case "ImportSpecifier":
              case "ExportSpecifier":
              case "ImportNamespaceSpecifier":
              case "ExportNamespaceSpecifier":
              case "ImportDefaultSpecifier":
              case "ExportDefaultSpecifier":
                return X(Te, Pe, Fe);
              case "ImportAttribute":
                return [Fe("key"), ": ", Fe("value")];
              case "Import":
                return "import";
              case "BlockStatement":
              case "StaticBlock":
              case "ClassBody":
                return he(Te, Pe, Fe);
              case "ThrowStatement":
                return pe(Te, Pe, Fe);
              case "ReturnStatement":
                return Oe(Te, Pe, Fe);
              case "NewExpression":
              case "ImportExpression":
              case "OptionalCallExpression":
              case "CallExpression":
                return ie(Te, Pe, Fe);
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                return z(Te, Pe, Fe);
              case "ObjectProperty":
              case "Property":
                return xe.method || xe.kind === "get" || xe.kind === "set" ? _e(Te, Pe, Fe) : fe(Te, Pe, Fe);
              case "ObjectMethod":
                return _e(Te, Pe, Fe);
              case "Decorator":
                return ["@", Fe("expression")];
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                return Ae(Te, Pe, Fe);
              case "SequenceExpression": {
                let Le = Te.getParentNode(0);
                if (Le.type === "ExpressionStatement" || Le.type === "ForStatement") {
                  let Ve = [];
                  return Te.each((be, ke) => {
                    ke === 0 ? Ve.push(Fe()) : Ve.push(",", c([r, Fe()]));
                  }, "expressions"), l(Ve);
                }
                return l(a([",", r], Te.map(Fe, "expressions")));
              }
              case "ThisExpression":
                return "this";
              case "Super":
                return "super";
              case "Directive":
                return [Fe("value"), Je];
              case "DirectiveLiteral":
                return Ee(xe, Pe);
              case "UnaryExpression":
                return we.push(xe.operator), /[a-z]$/.test(xe.operator) && we.push(" "), F(xe.argument) ? we.push(l(["(", c([i, Fe("argument")]), i, ")"])) : we.push(Fe("argument")), we;
              case "UpdateExpression":
                return we.push(Fe("argument"), xe.operator), xe.prefix && we.reverse(), we;
              case "ConditionalExpression":
                return oe(Te, Pe, Fe);
              case "VariableDeclaration": {
                let Le = Te.map(Fe, "declarations"), Ve = Te.getParentNode(), be = Ve.type === "ForStatement" || Ve.type === "ForInStatement" || Ve.type === "ForOfStatement", ke = xe.declarations.some((ue) => ue.init), Me;
                return Le.length === 1 && !F(xe.declarations[0]) ? Me = Le[0] : Le.length > 0 && (Me = c(Le[0])), we = [xe.declare ? "declare " : "", xe.kind, Me ? [" ", Me] : "", c(Le.slice(1).map((ue) => [",", ke && !be ? u : r, ue]))], be && Ve.body !== xe || we.push(Je), l(we);
              }
              case "WithStatement":
                return l(["with (", Fe("object"), ")", O(xe.body, Fe("body"))]);
              case "IfStatement": {
                let Le = O(xe.consequent, Fe("consequent")), Ve = l(["if (", l([c([i, Fe("test")]), i]), ")", Le]);
                if (we.push(Ve), xe.alternate) {
                  let be = F(xe.consequent, A.Trailing | A.Line) || $(xe), ke = xe.consequent.type === "BlockStatement" && !be;
                  we.push(ke ? " " : u), F(xe, A.Dangling) && we.push(t(Te, Pe, true), be ? u : " "), we.push("else", l(O(xe.alternate, Fe("alternate"), xe.alternate.type === "IfStatement")));
                }
                return we;
              }
              case "ForStatement": {
                let Le = O(xe.body, Fe("body")), Ve = t(Te, Pe, true), be = Ve ? [Ve, i] : "";
                return !xe.init && !xe.test && !xe.update ? [be, l(["for (;;)", Le])] : [be, l(["for (", l([c([i, Fe("init"), ";", r, Fe("test"), ";", r, Fe("update")]), i]), ")", Le])];
              }
              case "WhileStatement":
                return l(["while (", l([c([i, Fe("test")]), i]), ")", O(xe.body, Fe("body"))]);
              case "ForInStatement":
                return l(["for (", Fe("left"), " in ", Fe("right"), ")", O(xe.body, Fe("body"))]);
              case "ForOfStatement":
                return l(["for", xe.await ? " await" : "", " (", Fe("left"), " of ", Fe("right"), ")", O(xe.body, Fe("body"))]);
              case "DoWhileStatement": {
                let Le = O(xe.body, Fe("body"));
                return we = [l(["do", Le])], xe.body.type === "BlockStatement" ? we.push(" ") : we.push(u), we.push("while (", l([c([i, Fe("test")]), i]), ")", Je), we;
              }
              case "DoExpression":
                return [xe.async ? "async " : "", "do ", Fe("body")];
              case "BreakStatement":
                return we.push("break"), xe.label && we.push(" ", Fe("label")), we.push(Je), we;
              case "ContinueStatement":
                return we.push("continue"), xe.label && we.push(" ", Fe("label")), we.push(Je), we;
              case "LabeledStatement":
                return xe.body.type === "EmptyStatement" ? [Fe("label"), ":;"] : [Fe("label"), ": ", Fe("body")];
              case "TryStatement":
                return ["try ", Fe("block"), xe.handler ? [" ", Fe("handler")] : "", xe.finalizer ? [" finally ", Fe("finalizer")] : ""];
              case "CatchClause":
                if (xe.param) {
                  let Le = F(xe.param, (be) => !_(be) || be.leading && s(Pe.originalText, C(be)) || be.trailing && s(Pe.originalText, d(be), { backwards: true })), Ve = Fe("param");
                  return ["catch ", Le ? ["(", c([i, Ve]), i, ") "] : ["(", Ve, ") "], Fe("body")];
                }
                return ["catch ", Fe("body")];
              case "SwitchStatement":
                return [l(["switch (", c([i, Fe("discriminant")]), i, ")"]), " {", xe.cases.length > 0 ? c([u, a(u, Te.map((Le, Ve, be) => {
                  let ke = Le.getValue();
                  return [Fe(), Ve !== be.length - 1 && P(ke, Pe) ? u : ""];
                }, "cases"))]) : "", u, "}"];
              case "SwitchCase": {
                xe.test ? we.push("case ", Fe("test"), ":") : we.push("default:"), F(xe, A.Dangling) && we.push(" ", t(Te, Pe, true));
                let Le = xe.consequent.filter((Ve) => Ve.type !== "EmptyStatement");
                if (Le.length > 0) {
                  let Ve = de(Te, Pe, Fe);
                  we.push(Le.length === 1 && Le[0].type === "BlockStatement" ? [" ", Ve] : c([u, Ve]));
                }
                return we;
              }
              case "DebuggerStatement":
                return ["debugger", Je];
              case "ClassDeclaration":
              case "ClassExpression":
                return H(Te, Pe, Fe);
              case "ClassMethod":
              case "ClassPrivateMethod":
              case "MethodDefinition":
                return Z(Te, Pe, Fe);
              case "ClassProperty":
              case "PropertyDefinition":
              case "ClassPrivateProperty":
              case "ClassAccessorProperty":
              case "AccessorProperty":
                return ne(Te, Pe, Fe);
              case "TemplateElement":
                return y(xe.value.raw);
              case "TemplateLiteral":
                return ae(Te, Fe, Pe);
              case "TaggedTemplateExpression":
                return [Fe("tag"), Fe("typeParameters"), Fe("quasi")];
              case "PrivateIdentifier":
                return ["#", Fe("name")];
              case "PrivateName":
                return ["#", Fe("id")];
              case "InterpreterDirective":
                return we.push("#!", xe.value, u), P(xe, Pe) && we.push(u), we;
              case "TopicReference":
                return "%";
              case "ArgumentPlaceholder":
                return "?";
              case "ModuleExpression": {
                we.push("module {");
                let Le = Fe("body");
                return Le && we.push(c([u, Le]), u), we.push("}"), we;
              }
              default:
                throw new Error("unknown type: " + JSON.stringify(xe.type));
            }
          }
          __name(te, "te");
          function Ee(Te, Pe) {
            let Fe = f(Te), Ze = Fe.slice(1, -1);
            if (Ze.includes('"') || Ze.includes("'"))
              return Fe;
            let xe = Pe.singleQuote ? "'" : '"';
            return xe + Ze + xe;
          }
          __name(Ee, "Ee");
          function Re(Te) {
            return Te.type && !_(Te) && !I(Te) && Te.type !== "EmptyStatement" && Te.type !== "TemplateElement" && Te.type !== "Import" && Te.type !== "TSEmptyBodyFunctionExpression";
          }
          __name(Re, "Re");
          n.exports = { preprocess: w, print: G, embed: h, insertPragma: p, massageAstNode: g, hasPrettierIgnore(Te) {
            return x(Te) || M(Te);
          }, willPrintOwnComments: D.willPrintOwnComments, canAttachComment: Re, printComment: Se, isBlockComment: _, handleComments: { avoidAstMutation: true, ownLine: D.handleOwnLineComment, endOfLine: D.handleEndOfLineComment, remaining: D.handleRemainingComment }, getCommentChildNodes: D.getCommentChildNodes };
        } }), zm = ee({ "src/language-js/printer-estree-json.js"(e, n) {
          "use strict";
          re();
          var { builders: { hardline: t, indent: s, join: a } } = qe(), r = eo();
          function u(c, y, h) {
            let g = c.getValue();
            switch (g.type) {
              case "JsonRoot":
                return [h("node"), t];
              case "ArrayExpression": {
                if (g.elements.length === 0)
                  return "[]";
                let p = c.map(() => c.getValue() === null ? "null" : h(), "elements");
                return ["[", s([t, a([",", t], p)]), t, "]"];
              }
              case "ObjectExpression":
                return g.properties.length === 0 ? "{}" : ["{", s([t, a([",", t], c.map(h, "properties"))]), t, "}"];
              case "ObjectProperty":
                return [h("key"), ": ", h("value")];
              case "UnaryExpression":
                return [g.operator === "+" ? "" : g.operator, h("argument")];
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return g.value ? "true" : "false";
              case "StringLiteral":
              case "NumericLiteral":
                return JSON.stringify(g.value);
              case "Identifier": {
                let p = c.getParentNode();
                return p && p.type === "ObjectProperty" && p.key === g ? JSON.stringify(g.name) : g.name;
              }
              case "TemplateLiteral":
                return h(["quasis", 0]);
              case "TemplateElement":
                return JSON.stringify(g.value.cooked);
              default:
                throw new Error("unknown type: " + JSON.stringify(g.type));
            }
          }
          __name(u, "u");
          var i = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
          function l(c, y) {
            let { type: h } = c;
            if (h === "ObjectProperty" && c.key.type === "Identifier") {
              y.key = { type: "StringLiteral", value: c.key.name };
              return;
            }
            if (h === "UnaryExpression" && c.operator === "+")
              return y.argument;
            if (h === "ArrayExpression") {
              for (let [g, p] of c.elements.entries())
                p === null && y.elements.splice(g, 0, { type: "NullLiteral" });
              return;
            }
            if (h === "TemplateLiteral")
              return { type: "StringLiteral", value: c.quasis[0].value.cooked };
          }
          __name(l, "l");
          l.ignoredProperties = i, n.exports = { preprocess: r, print: u, massageAstNode: l };
        } }), qt = ee({ "src/common/common-options.js"(e, n) {
          "use strict";
          re();
          var t = "Common";
          n.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
        } }), Xm = ee({ "src/language-js/options.js"(e, n) {
          "use strict";
          re();
          var t = qt(), s = "JavaScript";
          n.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
        } }), Km = ee({ "src/language-js/parse/parsers.js"() {
          re();
        } }), bn = ee({ "node_modules/linguist-languages/data/JavaScript.json"(e, n) {
          n.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
        } }), Ym = ee({ "node_modules/linguist-languages/data/TypeScript.json"(e, n) {
          n.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
        } }), Qm = ee({ "node_modules/linguist-languages/data/TSX.json"(e, n) {
          n.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
        } }), la = ee({ "node_modules/linguist-languages/data/JSON.json"(e, n) {
          n.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
        } }), Zm = ee({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, n) {
          n.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
        } }), ed = ee({ "node_modules/linguist-languages/data/JSON5.json"(e, n) {
          n.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
        } }), td = ee({ "src/language-js/index.js"(e, n) {
          "use strict";
          re();
          var t = wt(), s = Jm(), a = zm(), r = Xm(), u = Km(), i = [t(bn(), (c) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...c.interpreters, "zx"], extensions: [...c.extensions.filter((y) => y !== ".jsx"), ".wxs"] })), t(bn(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(bn(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(Ym(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(Qm(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(la(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(la(), (c) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: c.extensions.filter((y) => y !== ".jsonl") })), t(Zm(), (c) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...c.filenames, ".eslintrc", ".swcrc"] })), t(ed(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l = { estree: s, "estree-json": a };
          n.exports = { languages: i, options: r, printers: l, parsers: u };
        } }), rd = ee({ "src/language-css/clean.js"(e, n) {
          "use strict";
          re();
          var { isFrontMatterNode: t } = Ge(), s = lt(), a = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
          function r(i, l, c) {
            if (t(i) && i.lang === "yaml" && delete l.value, i.type === "css-comment" && c.type === "css-root" && c.nodes.length > 0 && ((c.nodes[0] === i || t(c.nodes[0]) && c.nodes[1] === i) && (delete l.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || c.type === "css-root" && s(c.nodes) === i))
              return null;
            if (i.type === "value-root" && delete l.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete l.value, i.type === "css-rule" && delete l.params, i.type === "selector-combinator" && (l.value = l.value.replace(/\s+/g, " ")), i.type === "media-feature" && (l.value = l.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(l.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (l.value = l.value.toLowerCase()), i.type === "css-decl" && (l.prop = l.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (l.name = l.name.toLowerCase()), i.type === "value-number" && (l.unit = l.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && l.value && (l.value = u(l.value)), i.type === "selector-attribute" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == "string" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = true)), l.value && (l.value = l.value.trim().replace(/^["']|["']$/g, ""), delete l.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && l.value && (l.value = l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (y, h, g) => {
              let p = Number(h);
              return Number.isNaN(p) ? y : p + g.toLowerCase();
            })), i.type === "selector-tag") {
              let y = i.value.toLowerCase();
              ["from", "to"].includes(y) && (l.value = y);
            }
            if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete l.value, i.type === "selector-unknown" && delete l.value, i.type === "value-comma_group") {
              let y = i.groups.findIndex((h) => h.type === "value-number" && h.unit === "...");
              y !== -1 && (l.groups[y].unit = "", l.groups.splice(y + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
            }
          }
          __name(r, "r");
          r.ignoredProperties = a;
          function u(i) {
            return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
          }
          __name(u, "u");
          n.exports = r;
        } }), Kn = ee({ "src/utils/front-matter/print.js"(e, n) {
          "use strict";
          re();
          var { builders: { hardline: t, markAsRoot: s } } = qe();
          function a(r, u) {
            if (r.lang === "yaml") {
              let i = r.value.trim(), l = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
              return s([r.startDelimiter, t, l, l ? t : "", r.endDelimiter]);
            }
          }
          __name(a, "a");
          n.exports = a;
        } }), nd = ee({ "src/language-css/embed.js"(e, n) {
          "use strict";
          re();
          var { builders: { hardline: t } } = qe(), s = Kn();
          function a(r, u, i) {
            let l = r.getValue();
            if (l.type === "front-matter") {
              let c = s(l, i);
              return c ? [c, t] : "";
            }
          }
          __name(a, "a");
          n.exports = a;
        } }), lo = ee({ "src/utils/front-matter/parse.js"(e, n) {
          "use strict";
          re();
          var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function s(a) {
            let r = a.match(t);
            if (!r)
              return { content: a };
            let { startDelimiter: u, language: i, value: l = "", endDelimiter: c } = r.groups, y = i.trim() || "yaml";
            if (u === "+++" && (y = "toml"), y !== "yaml" && u !== c)
              return { content: a };
            let [h] = r;
            return { frontMatter: { type: "front-matter", lang: y, value: l, startDelimiter: u, endDelimiter: c, raw: h.replace(/\n$/, "") }, content: h.replace(/[^\n]/g, " ") + a.slice(h.length) };
          }
          __name(s, "s");
          n.exports = s;
        } }), ud = ee({ "src/language-css/pragma.js"(e, n) {
          "use strict";
          re();
          var t = Qa(), s = lo();
          function a(u) {
            return t.hasPragma(s(u).content);
          }
          __name(a, "a");
          function r(u) {
            let { frontMatter: i, content: l } = s(u);
            return (i ? i.raw + `

` : "") + t.insertPragma(l);
          }
          __name(r, "r");
          n.exports = { hasPragma: a, insertPragma: r };
        } }), sd = ee({ "src/language-css/utils/index.js"(e, n) {
          "use strict";
          re();
          var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
          function s(z, H) {
            let Z = Array.isArray(H) ? H : [H], ne = -1, fe;
            for (; fe = z.getParentNode(++ne); )
              if (Z.includes(fe.type))
                return ne;
            return -1;
          }
          __name(s, "s");
          function a(z, H) {
            let Z = s(z, H);
            return Z === -1 ? null : z.getParentNode(Z);
          }
          __name(a, "a");
          function r(z) {
            var H;
            let Z = a(z, "css-decl");
            return Z == null || (H = Z.prop) === null || H === void 0 ? void 0 : H.toLowerCase();
          }
          __name(r, "r");
          var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
          function i(z) {
            return u.has(z.toLowerCase());
          }
          __name(i, "i");
          function l(z, H) {
            let Z = a(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(H.toLowerCase());
          }
          __name(l, "l");
          function c(z) {
            return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
          }
          __name(c, "c");
          function y(z, H) {
            var Z;
            let ne = a(z, "value-func");
            return (ne == null || (Z = ne.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === H;
          }
          __name(y, "y");
          function h(z) {
            var H;
            let Z = a(z, "css-rule"), ne = Z == null || (H = Z.raws) === null || H === void 0 ? void 0 : H.selector;
            return ne && (ne.startsWith(":import") || ne.startsWith(":export"));
          }
          __name(h, "h");
          function g(z, H) {
            let Z = Array.isArray(H) ? H : [H], ne = a(z, "css-atrule");
            return ne && Z.includes(ne.name.toLowerCase());
          }
          __name(g, "g");
          function p(z) {
            let H = z.getValue(), Z = a(z, "css-atrule");
            return (Z == null ? void 0 : Z.name) === "import" && H.groups[0].value === "url" && H.groups.length === 2;
          }
          __name(p, "p");
          function D(z) {
            return z.type === "value-func" && z.value.toLowerCase() === "url";
          }
          __name(D, "D");
          function v(z, H) {
            var Z;
            let ne = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
            return ne && ne.indexOf(H) === ne.length - 1;
          }
          __name(v, "v");
          function w(z) {
            let { selector: H } = z;
            return H ? typeof H == "string" && /^@.+:.*$/.test(H) || H.value && /^@.+:.*$/.test(H.value) : false;
          }
          __name(w, "w");
          function T(z) {
            return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
          }
          __name(T, "T");
          function F(z) {
            return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
          }
          __name(F, "F");
          function A(z) {
            return z.type === "value-word" && z.value === "in";
          }
          __name(A, "A");
          function B(z) {
            return z.type === "value-operator" && z.value === "*";
          }
          __name(B, "B");
          function I(z) {
            return z.type === "value-operator" && z.value === "/";
          }
          __name(I, "I");
          function P(z) {
            return z.type === "value-operator" && z.value === "+";
          }
          __name(P, "P");
          function $(z) {
            return z.type === "value-operator" && z.value === "-";
          }
          __name($, "$");
          function f(z) {
            return z.type === "value-operator" && z.value === "%";
          }
          __name(f, "f");
          function x(z) {
            return B(z) || I(z) || P(z) || $(z) || f(z);
          }
          __name(x, "x");
          function m(z) {
            return z.type === "value-word" && ["==", "!="].includes(z.value);
          }
          __name(m, "m");
          function E(z) {
            return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
          }
          __name(E, "E");
          function o(z) {
            return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
          }
          __name(o, "o");
          function d(z) {
            var H;
            return ((H = z.raws) === null || H === void 0 ? void 0 : H.params) && /^\(\s*\)$/.test(z.raws.params);
          }
          __name(d, "d");
          function C(z) {
            return z.name.startsWith("prettier-placeholder");
          }
          __name(C, "C");
          function _(z) {
            return z.prop.startsWith("@prettier-placeholder");
          }
          __name(_, "_");
          function b(z, H) {
            return z.value === "$$" && z.type === "value-func" && (H == null ? void 0 : H.type) === "value-word" && !H.raws.before;
          }
          __name(b, "b");
          function N(z) {
            var H, Z;
            return ((H = z.value) === null || H === void 0 ? void 0 : H.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
          }
          __name(N, "N");
          function k(z) {
            var H, Z, ne;
            return ((H = z.value) === null || H === void 0 || (Z = H.group) === null || Z === void 0 || (ne = Z.group) === null || ne === void 0 ? void 0 : ne.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
          }
          __name(k, "k");
          function R(z) {
            var H;
            return ((H = z.raws) === null || H === void 0 ? void 0 : H.before) === "";
          }
          __name(R, "R");
          function M(z) {
            var H, Z;
            return z.type === "value-comma_group" && ((H = z.groups) === null || H === void 0 || (Z = H[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
          }
          __name(M, "M");
          function q(z) {
            var H;
            return z.type === "value-paren_group" && ((H = z.groups) === null || H === void 0 ? void 0 : H[0]) && M(z.groups[0]);
          }
          __name(q, "q");
          function J(z) {
            var H;
            let Z = z.getValue();
            if (Z.groups.length === 0)
              return false;
            let ne = z.getParentNode(1);
            if (!q(Z) && !(ne && q(ne)))
              return false;
            let fe = a(z, "css-decl");
            return !!(fe != null && (H = fe.prop) !== null && H !== void 0 && H.startsWith("$") || q(ne) || ne.type === "value-func");
          }
          __name(J, "J");
          function L(z) {
            return z.type === "value-comment" && z.inline;
          }
          __name(L, "L");
          function Y(z) {
            return z.type === "value-word" && z.value === "#";
          }
          __name(Y, "Y");
          function V(z) {
            return z.type === "value-word" && z.value === "{";
          }
          __name(V, "V");
          function O(z) {
            return z.type === "value-word" && z.value === "}";
          }
          __name(O, "O");
          function K(z) {
            return ["value-word", "value-atword"].includes(z.type);
          }
          __name(K, "K");
          function se(z) {
            return (z == null ? void 0 : z.type) === "value-colon";
          }
          __name(se, "se");
          function Q(z, H) {
            if (!M(H))
              return false;
            let { groups: Z } = H, ne = Z.indexOf(z);
            return ne === -1 ? false : se(Z[ne + 1]);
          }
          __name(Q, "Q");
          function le(z) {
            return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
          }
          __name(le, "le");
          function W(z) {
            return z.type !== "value-func" ? false : t.has(z.value.toLowerCase());
          }
          __name(W, "W");
          function X(z) {
            return /\/\//.test(z.split(/[\n\r]/).pop());
          }
          __name(X, "X");
          function oe(z) {
            return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
          }
          __name(oe, "oe");
          function ae(z, H) {
            var Z, ne;
            if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((ne = z.close) === null || ne === void 0 ? void 0 : ne.value) !== ")" || z.groups.some((fe) => fe.type !== "value-comma_group"))
              return false;
            if (H.type === "value-comma_group") {
              let fe = H.groups.indexOf(z) - 1, ge = H.groups[fe];
              if ((ge == null ? void 0 : ge.type) === "value-word" && ge.value === "with")
                return true;
            }
            return false;
          }
          __name(ae, "ae");
          function Ae(z) {
            var H, Z;
            return z.type === "value-paren_group" && ((H = z.open) === null || H === void 0 ? void 0 : H.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
          }
          __name(Ae, "Ae");
          n.exports = { getAncestorCounter: s, getAncestorNode: a, getPropOfDeclNode: r, maybeToLowerCase: c, insideValueFunctionNode: y, insideICSSRuleNode: h, insideAtRuleNode: g, insideURLFunctionInImportAtRuleNode: p, isKeyframeAtRuleKeywords: l, isWideKeywords: i, isLastNode: v, isSCSSControlDirectiveNode: o, isDetachedRulesetDeclarationNode: w, isRelationalOperatorNode: E, isEqualityOperatorNode: m, isMultiplicationNode: B, isDivisionNode: I, isAdditionNode: P, isSubtractionNode: $, isModuloNode: f, isMathOperatorNode: x, isEachKeywordNode: A, isForKeywordNode: T, isURLFunctionNode: D, isIfElseKeywordNode: F, hasComposesNode: N, hasParensAroundNode: k, hasEmptyRawBefore: R, isDetachedRulesetCallNode: d, isTemplatePlaceholderNode: C, isTemplatePropNode: _, isPostcssSimpleVarNode: b, isKeyValuePairNode: M, isKeyValuePairInParenGroupNode: q, isKeyInValuePairNode: Q, isSCSSMapItemNode: J, isInlineValueCommentNode: L, isHashNode: Y, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: O, isWordNode: K, isColonNode: se, isMediaAndSupportsKeywords: le, isColorAdjusterFuncNode: W, lastLineHasInlineComment: X, isAtWordPlaceholderNode: oe, isConfigurationNode: ae, isParenGroupNode: Ae };
        } }), id = ee({ "src/utils/line-column-to-index.js"(e, n) {
          "use strict";
          re(), n.exports = function(t, s) {
            let a = 0;
            for (let r = 0; r < t.line - 1; ++r)
              a = s.indexOf(`
`, a) + 1;
            return a + t.column;
          };
        } }), ad = ee({ "src/language-css/loc.js"(e, n) {
          "use strict";
          re();
          var { skipEverythingButNewLine: t } = _r(), s = lt(), a = id();
          function r(p, D) {
            return typeof p.sourceIndex == "number" ? p.sourceIndex : p.source ? a(p.source.start, D) - 1 : null;
          }
          __name(r, "r");
          function u(p, D) {
            if (p.type === "css-comment" && p.inline)
              return t(D, p.source.startOffset);
            let v = p.nodes && s(p.nodes);
            return v && p.source && !p.source.end && (p = v), p.source && p.source.end ? a(p.source.end, D) : null;
          }
          __name(u, "u");
          function i(p, D) {
            p.source && (p.source.startOffset = r(p, D), p.source.endOffset = u(p, D));
            for (let v in p) {
              let w = p[v];
              v === "source" || !w || typeof w != "object" || (w.type === "value-root" || w.type === "value-unknown" ? l(w, c(p), w.text || w.value) : i(w, D));
            }
          }
          __name(i, "i");
          function l(p, D, v) {
            p.source && (p.source.startOffset = r(p, v) + D, p.source.endOffset = u(p, v) + D);
            for (let w in p) {
              let T = p[w];
              w === "source" || !T || typeof T != "object" || l(T, D, v);
            }
          }
          __name(l, "l");
          function c(p) {
            let D = p.source.startOffset;
            return typeof p.prop == "string" && (D += p.prop.length), p.type === "css-atrule" && typeof p.name == "string" && (D += 1 + p.name.length + p.raws.afterName.match(/^\s*:?\s*/)[0].length), p.type !== "css-atrule" && p.raws && typeof p.raws.between == "string" && (D += p.raws.between.length), D;
          }
          __name(c, "c");
          function y(p) {
            let D = "initial", v = "initial", w, T = false, F = [];
            for (let A = 0; A < p.length; A++) {
              let B = p[A];
              switch (D) {
                case "initial":
                  if (B === "'") {
                    D = "single-quotes";
                    continue;
                  }
                  if (B === '"') {
                    D = "double-quotes";
                    continue;
                  }
                  if ((B === "u" || B === "U") && p.slice(A, A + 4).toLowerCase() === "url(") {
                    D = "url", A += 3;
                    continue;
                  }
                  if (B === "*" && p[A - 1] === "/") {
                    D = "comment-block";
                    continue;
                  }
                  if (B === "/" && p[A - 1] === "/") {
                    D = "comment-inline", w = A - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (B === "'" && p[A - 1] !== "\\" && (D = v, v = "initial"), B === `
` || B === "\r")
                    return p;
                  continue;
                case "double-quotes":
                  if (B === '"' && p[A - 1] !== "\\" && (D = v, v = "initial"), B === `
` || B === "\r")
                    return p;
                  continue;
                case "url":
                  if (B === ")" && (D = "initial"), B === `
` || B === "\r")
                    return p;
                  if (B === "'") {
                    D = "single-quotes", v = "url";
                    continue;
                  }
                  if (B === '"') {
                    D = "double-quotes", v = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  B === "/" && p[A - 1] === "*" && (D = "initial");
                  continue;
                case "comment-inline":
                  (B === '"' || B === "'" || B === "*") && (T = true), (B === `
` || B === "\r") && (T && F.push([w, A]), D = "initial", T = false);
                  continue;
              }
            }
            for (let [A, B] of F)
              p = p.slice(0, A) + p.slice(A, B).replace(/["'*]/g, " ") + p.slice(B);
            return p;
          }
          __name(y, "y");
          function h(p) {
            return p.source.startOffset;
          }
          __name(h, "h");
          function g(p) {
            return p.source.endOffset;
          }
          __name(g, "g");
          n.exports = { locStart: h, locEnd: g, calculateLoc: i, replaceQuotesInInlineComments: y };
        } }), od = ee({ "src/language-css/utils/is-less-parser.js"(e, n) {
          "use strict";
          re();
          function t(s) {
            return s.parser === "css" || s.parser === "less";
          }
          __name(t, "t");
          n.exports = t;
        } }), ld = ee({ "src/language-css/utils/is-scss.js"(e, n) {
          "use strict";
          re();
          function t(s, a) {
            return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
          }
          __name(t, "t");
          n.exports = t;
        } }), cd = ee({ "src/language-css/utils/css-units.evaluate.js"(e, n) {
          n.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
        } }), pd = ee({ "src/language-css/utils/print-unit.js"(e, n) {
          "use strict";
          re();
          var t = cd();
          function s(a) {
            let r = a.toLowerCase();
            return Object.prototype.hasOwnProperty.call(t, r) ? t[r] : a;
          }
          __name(s, "s");
          n.exports = s;
        } }), fd = ee({ "src/language-css/printer-postcss.js"(e, n) {
          "use strict";
          re();
          var t = lt(), { printNumber: s, printString: a, hasNewline: r, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: l } = Ge(), { builders: { join: c, line: y, hardline: h, softline: g, group: p, fill: D, indent: v, dedent: w, ifBreak: T, breakParent: F }, utils: { removeLines: A, getDocParts: B } } = qe(), I = rd(), P = nd(), { insertPragma: $ } = ud(), { getAncestorNode: f, getPropOfDeclNode: x, maybeToLowerCase: m, insideValueFunctionNode: E, insideICSSRuleNode: o, insideAtRuleNode: d, insideURLFunctionInImportAtRuleNode: C, isKeyframeAtRuleKeywords: _, isWideKeywords: b, isLastNode: N, isSCSSControlDirectiveNode: k, isDetachedRulesetDeclarationNode: R, isRelationalOperatorNode: M, isEqualityOperatorNode: q, isMultiplicationNode: J, isDivisionNode: L, isAdditionNode: Y, isSubtractionNode: V, isMathOperatorNode: O, isEachKeywordNode: K, isForKeywordNode: se, isURLFunctionNode: Q, isIfElseKeywordNode: le, hasComposesNode: W, hasParensAroundNode: X, hasEmptyRawBefore: oe, isKeyValuePairNode: ae, isKeyInValuePairNode: Ae, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: H, isTemplatePropNode: Z, isPostcssSimpleVarNode: ne, isSCSSMapItemNode: fe, isInlineValueCommentNode: ge, isHashNode: Ce, isLeftCurlyBraceNode: _e, isRightCurlyBraceNode: Oe, isWordNode: pe, isColonNode: ie, isMediaAndSupportsKeywords: ve, isColorAdjusterFuncNode: ce, lastLineHasInlineComment: U, isAtWordPlaceholderNode: de, isConfigurationNode: De, isParenGroupNode: he } = sd(), { locStart: Be, locEnd: Se } = ad(), ye = od(), S = ld(), G = pd();
          function te(be) {
            return be.trailingComma === "es5" || be.trailingComma === "all";
          }
          __name(te, "te");
          function Ee(be, ke, Me) {
            let ue = be.getValue();
            if (!ue)
              return "";
            if (typeof ue == "string")
              return ue;
            switch (ue.type) {
              case "front-matter":
                return [ue.raw, h];
              case "css-root": {
                let He = Re(be, ke, Me), Ue = ue.raws.after.trim();
                return [He, Ue ? ` ${Ue}` : "", B(He).length > 0 ? h : ""];
              }
              case "css-comment": {
                let He = ue.inline || ue.raws.inline, Ue = ke.originalText.slice(Be(ue), Se(ue));
                return He ? Ue.trimEnd() : Ue;
              }
              case "css-rule":
                return [Me("selector"), ue.important ? " !important" : "", ue.nodes ? [ue.selector && ue.selector.type === "selector-unknown" && U(ue.selector.value) ? y : " ", "{", ue.nodes.length > 0 ? v([h, Re(be, ke, Me)]) : "", h, "}", R(ue) ? ";" : ""] : ";"];
              case "css-decl": {
                let He = be.getParentNode(), { between: Ue } = ue.raws, Xe = Ue.trim(), at = Xe === ":", nt = W(ue) ? A(Me("value")) : Me("value");
                return !at && U(Xe) && (nt = v([h, w(nt)])), [ue.raws.before.replace(/[\s;]/g, ""), o(be) ? ue.prop : m(ue.prop), Xe.startsWith("//") ? " " : "", Xe, ue.extend ? "" : " ", ye(ke) && ue.extend && ue.selector ? ["extend(", Me("selector"), ")"] : "", nt, ue.raws.important ? ue.raws.important.replace(/\s*!\s*important/i, " !important") : ue.important ? " !important" : "", ue.raws.scssDefault ? ue.raws.scssDefault.replace(/\s*!default/i, " !default") : ue.scssDefault ? " !default" : "", ue.raws.scssGlobal ? ue.raws.scssGlobal.replace(/\s*!global/i, " !global") : ue.scssGlobal ? " !global" : "", ue.nodes ? [" {", v([g, Re(be, ke, Me)]), g, "}"] : Z(ue) && !He.raws.semicolon && ke.originalText[Se(ue) - 1] !== ";" ? "" : ke.__isHTMLStyleAttribute && N(be, ue) ? T(";") : ";"];
              }
              case "css-atrule": {
                let He = be.getParentNode(), Ue = H(ue) && !He.raws.semicolon && ke.originalText[Se(ue) - 1] !== ";";
                if (ye(ke)) {
                  if (ue.mixin)
                    return [Me("selector"), ue.important ? " !important" : "", Ue ? "" : ";"];
                  if (ue.function)
                    return [ue.name, Me("params"), Ue ? "" : ";"];
                  if (ue.variable)
                    return ["@", ue.name, ": ", ue.value ? Me("value") : "", ue.raws.between.trim() ? ue.raws.between.trim() + " " : "", ue.nodes ? ["{", v([ue.nodes.length > 0 ? g : "", Re(be, ke, Me)]), g, "}"] : "", Ue ? "" : ";"];
                }
                return ["@", z(ue) || ue.name.endsWith(":") ? ue.name : m(ue.name), ue.params ? [z(ue) ? "" : H(ue) ? ue.raws.afterName === "" ? "" : ue.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ue.raws.afterName) ? [h, h] : /^\s*\n/.test(ue.raws.afterName) ? h : " " : " ", Me("params")] : "", ue.selector ? v([" ", Me("selector")]) : "", ue.value ? p([" ", Me("value"), k(ue) ? X(ue) ? " " : y : ""]) : ue.name === "else" ? " " : "", ue.nodes ? [k(ue) ? "" : ue.selector && !ue.selector.nodes && typeof ue.selector.value == "string" && U(ue.selector.value) || !ue.selector && typeof ue.params == "string" && U(ue.params) ? y : " ", "{", v([ue.nodes.length > 0 ? g : "", Re(be, ke, Me)]), g, "}"] : Ue ? "" : ";"];
              }
              case "media-query-list": {
                let He = [];
                return be.each((Ue) => {
                  let Xe = Ue.getValue();
                  Xe.type === "media-query" && Xe.value === "" || He.push(Me());
                }, "nodes"), p(v(c(y, He)));
              }
              case "media-query":
                return [c(" ", be.map(Me, "nodes")), N(be, ue) ? "" : ","];
              case "media-type":
                return Le(Je(ue.value, ke));
              case "media-feature-expression":
                return ue.nodes ? ["(", ...be.map(Me, "nodes"), ")"] : ue.value;
              case "media-feature":
                return m(Je(ue.value.replace(/ +/g, " "), ke));
              case "media-colon":
                return [ue.value, " "];
              case "media-value":
                return Le(Je(ue.value, ke));
              case "media-keyword":
                return Je(ue.value, ke);
              case "media-url":
                return Je(ue.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), ke);
              case "media-unknown":
                return ue.value;
              case "selector-root":
                return p([d(be, "custom-selector") ? [f(be, "css-atrule").customSelector, y] : "", c([",", d(be, ["extend", "custom-selector", "nest"]) ? y : h], be.map(Me, "nodes"))]);
              case "selector-selector":
                return p(v(be.map(Me, "nodes")));
              case "selector-comment":
                return ue.value;
              case "selector-string":
                return Je(ue.value, ke);
              case "selector-tag": {
                let He = be.getParentNode(), Ue = He && He.nodes.indexOf(ue), Xe = Ue && He.nodes[Ue - 1];
                return [ue.namespace ? [ue.namespace === true ? "" : ue.namespace.trim(), "|"] : "", Xe.type === "selector-nesting" ? ue.value : Le(_(be, ue.value) ? ue.value.toLowerCase() : ue.value)];
              }
              case "selector-id":
                return ["#", ue.value];
              case "selector-class":
                return [".", Le(Je(ue.value, ke))];
              case "selector-attribute": {
                var st;
                return ["[", ue.namespace ? [ue.namespace === true ? "" : ue.namespace.trim(), "|"] : "", ue.attribute.trim(), (st = ue.operator) !== null && st !== void 0 ? st : "", ue.value ? we(Je(ue.value.trim(), ke), ke) : "", ue.insensitive ? " i" : "", "]"];
              }
              case "selector-combinator": {
                if (ue.value === "+" || ue.value === ">" || ue.value === "~" || ue.value === ">>>") {
                  let Xe = be.getParentNode();
                  return [Xe.type === "selector-selector" && Xe.nodes[0] === ue ? "" : y, ue.value, N(be, ue) ? "" : " "];
                }
                let He = ue.value.trim().startsWith("(") ? y : "", Ue = Le(Je(ue.value.trim(), ke)) || y;
                return [He, Ue];
              }
              case "selector-universal":
                return [ue.namespace ? [ue.namespace === true ? "" : ue.namespace.trim(), "|"] : "", ue.value];
              case "selector-pseudo":
                return [m(ue.value), l(ue.nodes) ? p(["(", v([g, c([",", y], be.map(Me, "nodes"))]), g, ")"]) : ""];
              case "selector-nesting":
                return ue.value;
              case "selector-unknown": {
                let He = f(be, "css-rule");
                if (He && He.isSCSSNesterProperty)
                  return Le(Je(m(ue.value), ke));
                let Ue = be.getParentNode();
                if (Ue.raws && Ue.raws.selector) {
                  let at = Be(Ue), nt = at + Ue.raws.selector.length;
                  return ke.originalText.slice(at, nt).trim();
                }
                let Xe = be.getParentNode(1);
                if (Ue.type === "value-paren_group" && Xe && Xe.type === "value-func" && Xe.value === "selector") {
                  let at = Se(Ue.open) + 1, nt = Be(Ue.close), j = ke.originalText.slice(at, nt).trim();
                  return U(j) ? [F, j] : j;
                }
                return ue.value;
              }
              case "value-value":
              case "value-root":
                return Me("group");
              case "value-comment":
                return ke.originalText.slice(Be(ue), Se(ue));
              case "value-comma_group": {
                let He = be.getParentNode(), Ue = be.getParentNode(1), Xe = x(be), at = Xe && He.type === "value-value" && (Xe === "grid" || Xe.startsWith("grid-template")), nt = f(be, "css-atrule"), j = nt && k(nt), me = ue.groups.some((ot) => ge(ot)), Ie = be.map(Me, "groups"), je = [], Ye = E(be, "url"), ut = false, ze = false;
                for (let ot = 0; ot < ue.groups.length; ++ot) {
                  var rt;
                  je.push(Ie[ot]);
                  let tt = ue.groups[ot - 1], $e = ue.groups[ot], We = ue.groups[ot + 1], nr = ue.groups[ot + 2];
                  if (Ye) {
                    (We && Y(We) || Y($e)) && je.push(" ");
                    continue;
                  }
                  if (d(be, "forward") && $e.type === "value-word" && $e.value && tt !== void 0 && tt.type === "value-word" && tt.value === "as" && We.type === "value-operator" && We.value === "*" || !We || $e.type === "value-word" && $e.value.endsWith("-") && de(We))
                    continue;
                  let go = $e.type === "value-string" && $e.value.startsWith("#{"), yo = ut && We.type === "value-string" && We.value.endsWith("}");
                  if (go || yo) {
                    ut = !ut;
                    continue;
                  }
                  if (ut || ie($e) || ie(We) || $e.type === "value-atword" && $e.value === "" || $e.value === "~" || $e.value && $e.value.includes("\\") && We && We.type !== "value-comment" || tt && tt.value && tt.value.indexOf("\\") === tt.value.length - 1 && $e.type === "value-operator" && $e.value === "/" || $e.value === "\\" || ne($e, We) || Ce($e) || _e($e) || Oe(We) || _e(We) && oe(We) || Oe($e) && oe(We) || $e.value === "--" && Ce(We))
                    continue;
                  let Zn = O($e), eu = O(We);
                  if ((Zn && Ce(We) || eu && Oe($e)) && oe(We) || !tt && L($e) || E(be, "calc") && (Y($e) || Y(We) || V($e) || V(We)) && oe(We))
                    continue;
                  let ho = (Y($e) || V($e)) && ot === 0 && (We.type === "value-number" || We.isHex) && Ue && ce(Ue) && !oe(We), tu = nr && nr.type === "value-func" || nr && pe(nr) || $e.type === "value-func" || pe($e), ru = We.type === "value-func" || pe(We) || tt && tt.type === "value-func" || tt && pe(tt);
                  if (!(!(J(We) || J($e)) && !E(be, "calc") && !ho && (L(We) && !tu || L($e) && !ru || Y(We) && !tu || Y($e) && !ru || V(We) || V($e)) && (oe(We) || Zn && (!tt || tt && O(tt))))) {
                    if (ge($e)) {
                      if (He.type === "value-paren_group") {
                        je.push(w(h));
                        continue;
                      }
                      je.push(h);
                      continue;
                    }
                    if (j && (q(We) || M(We) || le(We) || K($e) || se($e))) {
                      je.push(" ");
                      continue;
                    }
                    if (nt && nt.name.toLowerCase() === "namespace") {
                      je.push(" ");
                      continue;
                    }
                    if (at) {
                      $e.source && We.source && $e.source.start.line !== We.source.start.line ? (je.push(h), ze = true) : je.push(" ");
                      continue;
                    }
                    if (eu) {
                      je.push(" ");
                      continue;
                    }
                    if (!(We && We.value === "...") && !(de($e) && de(We) && Se($e) === Be(We))) {
                      if (de($e) && he(We) && Se($e) === Be(We.open)) {
                        je.push(g);
                        continue;
                      }
                      if ($e.value === "with" && he(We)) {
                        je.push(" ");
                        continue;
                      }
                      (rt = $e.value) !== null && rt !== void 0 && rt.endsWith("#") && We.value === "{" && he(We.group) || je.push(y);
                    }
                  }
                }
                return me && je.push(F), ze && je.unshift(h), j ? p(v(je)) : C(be) ? p(D(je)) : p(v(D(je)));
              }
              case "value-paren_group": {
                let He = be.getParentNode();
                if (He && Q(He) && (ue.groups.length === 1 || ue.groups.length > 0 && ue.groups[0].type === "value-comma_group" && ue.groups[0].groups.length > 0 && ue.groups[0].groups[0].type === "value-word" && ue.groups[0].groups[0].value.startsWith("data:")))
                  return [ue.open ? Me("open") : "", c(",", be.map(Me, "groups")), ue.close ? Me("close") : ""];
                if (!ue.open) {
                  let Ye = be.map(Me, "groups"), ut = [];
                  for (let ze = 0; ze < Ye.length; ze++)
                    ze !== 0 && ut.push([",", y]), ut.push(Ye[ze]);
                  return p(v(D(ut)));
                }
                let Ue = fe(be), Xe = t(ue.groups), at = Xe && Xe.type === "value-comment", nt = Ae(ue, He), j = De(ue, He), me = j || Ue && !nt, Ie = j || nt, je = p([ue.open ? Me("open") : "", v([g, c([y], be.map((Ye, ut) => {
                  let ze = Ye.getValue(), ot = ut === ue.groups.length - 1, tt = [Me(), ot ? "" : ","];
                  if (ae(ze) && ze.type === "value-comma_group" && ze.groups && ze.groups[0].type !== "value-paren_group" && ze.groups[2] && ze.groups[2].type === "value-paren_group") {
                    let $e = B(tt[0].contents.contents);
                    return $e[1] = p($e[1]), p(w(tt));
                  }
                  if (!ot && ze.type === "value-comma_group" && l(ze.groups)) {
                    let $e = t(ze.groups);
                    $e.source && i(ke.originalText, $e, Se) && tt.push(h);
                  }
                  return tt;
                }, "groups"))]), T(!at && S(ke.parser, ke.originalText) && Ue && te(ke) ? "," : ""), g, ue.close ? Me("close") : ""], { shouldBreak: me });
                return Ie ? w(je) : je;
              }
              case "value-func":
                return [ue.value, d(be, "supports") && ve(ue) ? " " : "", Me("group")];
              case "value-paren":
                return ue.value;
              case "value-number":
                return [Ve(ue.value), G(ue.unit)];
              case "value-operator":
                return ue.value;
              case "value-word":
                return ue.isColor && ue.isHex || b(ue.value) ? ue.value.toLowerCase() : ue.value;
              case "value-colon": {
                let He = be.getParentNode(), Ue = He && He.groups.indexOf(ue), Xe = Ue && He.groups[Ue - 1];
                return [ue.value, Xe && typeof Xe.value == "string" && t(Xe.value) === "\\" || E(be, "url") ? "" : y];
              }
              case "value-comma":
                return [ue.value, " "];
              case "value-string":
                return a(ue.raws.quote + ue.value + ue.raws.quote, ke);
              case "value-atword":
                return ["@", ue.value];
              case "value-unicode-range":
                return ue.value;
              case "value-unknown":
                return ue.value;
              default:
                throw new Error(`Unknown postcss type ${JSON.stringify(ue.type)}`);
            }
          }
          __name(Ee, "Ee");
          function Re(be, ke, Me) {
            let ue = [];
            return be.each((st, rt, He) => {
              let Ue = He[rt - 1];
              if (Ue && Ue.type === "css-comment" && Ue.text.trim() === "prettier-ignore") {
                let Xe = st.getValue();
                ue.push(ke.originalText.slice(Be(Xe), Se(Xe)));
              } else
                ue.push(Me());
              rt !== He.length - 1 && (He[rt + 1].type === "css-comment" && !r(ke.originalText, Be(He[rt + 1]), { backwards: true }) && !u(He[rt]) || He[rt + 1].type === "css-atrule" && He[rt + 1].name === "else" && He[rt].type !== "css-comment" ? ue.push(" ") : (ue.push(ke.__isHTMLStyleAttribute ? y : h), i(ke.originalText, st.getValue(), Se) && !u(He[rt]) && ue.push(h)));
            }, "nodes"), ue;
          }
          __name(Re, "Re");
          var Te = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, Pe = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, Fe = /[A-Za-z]+/g, Ze = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, xe = new RegExp(Te.source + `|(${Ze.source})?(${Pe.source})(${Fe.source})?`, "g");
          function Je(be, ke) {
            return be.replace(Te, (Me) => a(Me, ke));
          }
          __name(Je, "Je");
          function we(be, ke) {
            let Me = ke.singleQuote ? "'" : '"';
            return be.includes('"') || be.includes("'") ? be : Me + be + Me;
          }
          __name(we, "we");
          function Le(be) {
            return be.replace(xe, (ke, Me, ue, st, rt) => !ue && st ? Ve(st) + m(rt || "") : ke);
          }
          __name(Le, "Le");
          function Ve(be) {
            return s(be).replace(/\.0(?=$|e)/, "");
          }
          __name(Ve, "Ve");
          n.exports = { print: Ee, embed: P, insertPragma: $, massageAstNode: I };
        } }), Dd = ee({ "src/language-css/options.js"(e, n) {
          "use strict";
          re();
          var t = qt();
          n.exports = { singleQuote: t.singleQuote };
        } }), md = ee({ "src/language-css/parsers.js"() {
          re();
        } }), dd = ee({ "node_modules/linguist-languages/data/CSS.json"(e, n) {
          n.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
        } }), gd = ee({ "node_modules/linguist-languages/data/PostCSS.json"(e, n) {
          n.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
        } }), yd = ee({ "node_modules/linguist-languages/data/Less.json"(e, n) {
          n.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
        } }), hd = ee({ "node_modules/linguist-languages/data/SCSS.json"(e, n) {
          n.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
        } }), vd = ee({ "src/language-css/index.js"(e, n) {
          "use strict";
          re();
          var t = wt(), s = fd(), a = Dd(), r = md(), u = [t(dd(), (l) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l.extensions, ".wxss"] })), t(gd(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(yd(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(hd(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s };
          n.exports = { languages: u, options: a, printers: i, parsers: r };
        } }), Cd = ee({ "src/language-handlebars/loc.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return a.loc.start.offset;
          }
          __name(t, "t");
          function s(a) {
            return a.loc.end.offset;
          }
          __name(s, "s");
          n.exports = { locStart: t, locEnd: s };
        } }), Ed = ee({ "src/language-handlebars/clean.js"(e, n) {
          "use strict";
          re();
          function t(s, a) {
            if (s.type === "TextNode") {
              let r = s.chars.trim();
              if (!r)
                return null;
              a.chars = r.replace(/[\t\n\f\r ]+/g, " ");
            }
            s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a.value;
          }
          __name(t, "t");
          t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), n.exports = t;
        } }), Fd = ee({ "vendors/html-void-elements.json"(e, n) {
          n.exports = { htmlVoidElements: ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"] };
        } }), Ad = ee({ "src/language-handlebars/utils.js"(e, n) {
          "use strict";
          re();
          var { htmlVoidElements: t } = Fd(), s = lt();
          function a(A) {
            let B = A.getValue(), I = A.getParentNode(0);
            return !!(h(A, ["ElementNode"]) && s(I.children) === B || h(A, ["Block"]) && s(I.body) === B);
          }
          __name(a, "a");
          function r(A) {
            return A.toUpperCase() === A;
          }
          __name(r, "r");
          function u(A) {
            return y(A, ["ElementNode"]) && typeof A.tag == "string" && !A.tag.startsWith(":") && (r(A.tag[0]) || A.tag.includes("."));
          }
          __name(u, "u");
          var i = new Set(t);
          function l(A) {
            return i.has(A.tag) || u(A) && A.children.every((B) => c(B));
          }
          __name(l, "l");
          function c(A) {
            return y(A, ["TextNode"]) && !/\S/.test(A.chars);
          }
          __name(c, "c");
          function y(A, B) {
            return A && B.includes(A.type);
          }
          __name(y, "y");
          function h(A, B) {
            let I = A.getParentNode(0);
            return y(I, B);
          }
          __name(h, "h");
          function g(A, B) {
            let I = v(A);
            return y(I, B);
          }
          __name(g, "g");
          function p(A, B) {
            let I = w(A);
            return y(I, B);
          }
          __name(p, "p");
          function D(A, B) {
            var I, P, $, f;
            let x = A.getValue(), m = (I = A.getParentNode(0)) !== null && I !== void 0 ? I : {}, E = (P = ($ = (f = m.children) !== null && f !== void 0 ? f : m.body) !== null && $ !== void 0 ? $ : m.parts) !== null && P !== void 0 ? P : [], o = E.indexOf(x);
            return o !== -1 && E[o + B];
          }
          __name(D, "D");
          function v(A) {
            let B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return D(A, -B);
          }
          __name(v, "v");
          function w(A) {
            return D(A, 1);
          }
          __name(w, "w");
          function T(A) {
            return y(A, ["MustacheCommentStatement"]) && typeof A.value == "string" && A.value.trim() === "prettier-ignore";
          }
          __name(T, "T");
          function F(A) {
            let B = A.getValue(), I = v(A, 2);
            return T(B) || T(I);
          }
          __name(F, "F");
          n.exports = { getNextNode: w, getPreviousNode: v, hasPrettierIgnore: F, isLastNodeOfSiblings: a, isNextNodeOfSomeType: p, isNodeOfSomeType: y, isParentOfSomeType: h, isPreviousNodeOfSomeType: g, isVoid: l, isWhitespaceNode: c };
        } }), Sd = ee({ "src/language-handlebars/printer-glimmer.js"(e, n) {
          "use strict";
          re();
          var { builders: { dedent: t, fill: s, group: a, hardline: r, ifBreak: u, indent: i, join: l, line: c, softline: y }, utils: { getDocParts: h, replaceTextEndOfLine: g } } = qe(), { getPreferredQuote: p, isNonEmptyArray: D } = Ge(), { locStart: v, locEnd: w } = Cd(), T = Ed(), { getNextNode: F, getPreviousNode: A, hasPrettierIgnore: B, isLastNodeOfSiblings: I, isNextNodeOfSomeType: P, isNodeOfSomeType: $, isParentOfSomeType: f, isPreviousNodeOfSomeType: x, isVoid: m, isWhitespaceNode: E } = Ad(), o = 2;
          function d(U, de, De) {
            let he = U.getValue();
            if (!he)
              return "";
            if (B(U))
              return de.originalText.slice(v(he), w(he));
            let Be = de.singleQuote ? "'" : '"';
            switch (he.type) {
              case "Block":
              case "Program":
              case "Template":
                return a(U.map(De, "body"));
              case "ElementNode": {
                let Se = a(_(U, De)), ye = de.htmlWhitespaceSensitivity === "ignore" && P(U, ["ElementNode"]) ? y : "";
                if (m(he))
                  return [Se, ye];
                let S = ["</", he.tag, ">"];
                return he.children.length === 0 ? [Se, i(S), ye] : de.htmlWhitespaceSensitivity === "ignore" ? [Se, i(b(U, de, De)), r, i(S), ye] : [Se, i(a(b(U, de, De))), i(S), ye];
              }
              case "BlockStatement": {
                let Se = U.getParentNode(1);
                return Se && Se.inverse && Se.inverse.body.length === 1 && Se.inverse.body[0] === he && Se.inverse.body[0].path.parts[0] === Se.path.parts[0] ? [se(U, De, Se.inverse.body[0].path.parts[0]), oe(U, De, de), ae(U, De, de)] : [O(U, De), a([oe(U, De, de), ae(U, De, de), Q(U, De, de)])];
              }
              case "ElementModifierStatement":
                return a(["{{", pe(U, De), "}}"]);
              case "MustacheStatement":
                return a([k(he), pe(U, De), R(he)]);
              case "SubExpression":
                return a(["(", Oe(U, De), y, ")"]);
              case "AttrNode": {
                let Se = he.value.type === "TextNode";
                if (Se && he.value.chars === "" && v(he.value) === w(he.value))
                  return he.name;
                let S = Se ? p(he.value.chars, Be).quote : he.value.type === "ConcatStatement" ? p(he.value.parts.filter((te) => te.type === "TextNode").map((te) => te.chars).join(""), Be).quote : "", G = De("value");
                return [he.name, "=", S, he.name === "class" && S ? a(i(G)) : G, S];
              }
              case "ConcatStatement":
                return U.map(De, "parts");
              case "Hash":
                return l(c, U.map(De, "pairs"));
              case "HashPair":
                return [he.key, "=", De("value")];
              case "TextNode": {
                let Se = he.chars.replace(/{{/g, "\\{{"), ye = H(U);
                if (ye) {
                  if (ye === "class") {
                    let xe = Se.trim().split(/\s+/).join(" "), Je = false, we = false;
                    return f(U, ["ConcatStatement"]) && (x(U, ["MustacheStatement"]) && /^\s/.test(Se) && (Je = true), P(U, ["MustacheStatement"]) && /\s$/.test(Se) && xe !== "" && (we = true)), [Je ? c : "", xe, we ? c : ""];
                  }
                  return g(Se);
                }
                let G = /^[\t\n\f\r ]*$/.test(Se), te = !A(U), Ee = !F(U);
                if (de.htmlWhitespaceSensitivity !== "ignore") {
                  let xe = /^[\t\n\f\r ]*/, Je = /[\t\n\f\r ]*$/, we = Ee && f(U, ["Template"]), Le = te && f(U, ["Template"]);
                  if (G) {
                    if (Le || we)
                      return "";
                    let ue = [c], st = Z(Se);
                    return st && (ue = ge(st)), I(U) && (ue = ue.map((rt) => t(rt))), ue;
                  }
                  let [Ve] = Se.match(xe), [be] = Se.match(Je), ke = [];
                  if (Ve) {
                    ke = [c];
                    let ue = Z(Ve);
                    ue && (ke = ge(ue)), Se = Se.replace(xe, "");
                  }
                  let Me = [];
                  if (be) {
                    if (!we) {
                      Me = [c];
                      let ue = Z(be);
                      ue && (Me = ge(ue)), I(U) && (Me = Me.map((st) => t(st)));
                    }
                    Se = Se.replace(Je, "");
                  }
                  return [...ke, s(Ae(Se)), ...Me];
                }
                let Re = Z(Se), Te = ne(Se), Pe = fe(Se);
                if ((te || Ee) && G && f(U, ["Block", "ElementNode", "Template"]))
                  return "";
                G && Re ? (Te = Math.min(Re, o), Pe = 0) : (P(U, ["BlockStatement", "ElementNode"]) && (Pe = Math.max(Pe, 1)), x(U, ["BlockStatement", "ElementNode"]) && (Te = Math.max(Te, 1)));
                let Fe = "", Ze = "";
                return Pe === 0 && P(U, ["MustacheStatement"]) && (Ze = " "), Te === 0 && x(U, ["MustacheStatement"]) && (Fe = " "), te && (Te = 0, Fe = ""), Ee && (Pe = 0, Ze = ""), Se = Se.replace(/^[\t\n\f\r ]+/g, Fe).replace(/[\t\n\f\r ]+$/, Ze), [...ge(Te), s(Ae(Se)), ...ge(Pe)];
              }
              case "MustacheCommentStatement": {
                let Se = v(he), ye = w(he), S = de.originalText.charAt(Se + 2) === "~", G = de.originalText.charAt(ye - 3) === "~", te = he.value.includes("}}") ? "--" : "";
                return ["{{", S ? "~" : "", "!", te, he.value, te, G ? "~" : "", "}}"];
              }
              case "PathExpression":
                return he.original;
              case "BooleanLiteral":
                return String(he.value);
              case "CommentStatement":
                return ["<!--", he.value, "-->"];
              case "StringLiteral": {
                if (_e(U)) {
                  let Se = de.singleQuote ? '"' : "'";
                  return Ce(he.value, Se);
                }
                return Ce(he.value, Be);
              }
              case "NumberLiteral":
                return String(he.value);
              case "UndefinedLiteral":
                return "undefined";
              case "NullLiteral":
                return "null";
              default:
                throw new Error("unknown glimmer type: " + JSON.stringify(he.type));
            }
          }
          __name(d, "d");
          function C(U, de) {
            return v(U) - v(de);
          }
          __name(C, "C");
          function _(U, de) {
            let De = U.getValue(), he = ["attributes", "modifiers", "comments"].filter((Se) => D(De[Se])), Be = he.flatMap((Se) => De[Se]).sort(C);
            for (let Se of he)
              U.each((ye) => {
                let S = Be.indexOf(ye.getValue());
                Be.splice(S, 1, [c, de()]);
              }, Se);
            return D(De.blockParams) && Be.push(c, ce(De)), ["<", De.tag, i(Be), N(De)];
          }
          __name(_, "_");
          function b(U, de, De) {
            let Be = U.getValue().children.every((Se) => E(Se));
            return de.htmlWhitespaceSensitivity === "ignore" && Be ? "" : U.map((Se, ye) => {
              let S = De();
              return ye === 0 && de.htmlWhitespaceSensitivity === "ignore" ? [y, S] : S;
            }, "children");
          }
          __name(b, "b");
          function N(U) {
            return m(U) ? u([y, "/>"], [" />", y]) : u([y, ">"], ">");
          }
          __name(N, "N");
          function k(U) {
            let de = U.escaped === false ? "{{{" : "{{", De = U.strip && U.strip.open ? "~" : "";
            return [de, De];
          }
          __name(k, "k");
          function R(U) {
            let de = U.escaped === false ? "}}}" : "}}";
            return [U.strip && U.strip.close ? "~" : "", de];
          }
          __name(R, "R");
          function M(U) {
            let de = k(U), De = U.openStrip.open ? "~" : "";
            return [de, De, "#"];
          }
          __name(M, "M");
          function q(U) {
            let de = R(U);
            return [U.openStrip.close ? "~" : "", de];
          }
          __name(q, "q");
          function J(U) {
            let de = k(U), De = U.closeStrip.open ? "~" : "";
            return [de, De, "/"];
          }
          __name(J, "J");
          function L(U) {
            let de = R(U);
            return [U.closeStrip.close ? "~" : "", de];
          }
          __name(L, "L");
          function Y(U) {
            let de = k(U), De = U.inverseStrip.open ? "~" : "";
            return [de, De];
          }
          __name(Y, "Y");
          function V(U) {
            let de = R(U);
            return [U.inverseStrip.close ? "~" : "", de];
          }
          __name(V, "V");
          function O(U, de) {
            let De = U.getValue(), he = M(De), Be = q(De), Se = [ie(U, de)], ye = ve(U, de);
            if (ye && Se.push(c, ye), D(De.program.blockParams)) {
              let S = ce(De.program);
              Se.push(c, S);
            }
            return a([he, i(Se), y, Be]);
          }
          __name(O, "O");
          function K(U, de) {
            return [de.htmlWhitespaceSensitivity === "ignore" ? r : "", Y(U), "else", V(U)];
          }
          __name(K, "K");
          function se(U, de, De) {
            let he = U.getParentNode(1);
            return [Y(he), "else ", De, " ", ve(U, de), V(he)];
          }
          __name(se, "se");
          function Q(U, de, De) {
            let he = U.getValue();
            return De.htmlWhitespaceSensitivity === "ignore" ? [le(he) ? y : r, J(he), de("path"), L(he)] : [J(he), de("path"), L(he)];
          }
          __name(Q, "Q");
          function le(U) {
            return $(U, ["BlockStatement"]) && U.program.body.every((de) => E(de));
          }
          __name(le, "le");
          function W(U) {
            return X(U) && U.inverse.body.length === 1 && $(U.inverse.body[0], ["BlockStatement"]) && U.inverse.body[0].path.parts[0] === U.path.parts[0];
          }
          __name(W, "W");
          function X(U) {
            return $(U, ["BlockStatement"]) && U.inverse;
          }
          __name(X, "X");
          function oe(U, de, De) {
            let he = U.getValue();
            if (le(he))
              return "";
            let Be = de("program");
            return De.htmlWhitespaceSensitivity === "ignore" ? i([r, Be]) : i(Be);
          }
          __name(oe, "oe");
          function ae(U, de, De) {
            let he = U.getValue(), Be = de("inverse"), Se = De.htmlWhitespaceSensitivity === "ignore" ? [r, Be] : Be;
            return W(he) ? Se : X(he) ? [K(he, De), i(Se)] : "";
          }
          __name(ae, "ae");
          function Ae(U) {
            return h(l(c, z(U)));
          }
          __name(Ae, "Ae");
          function z(U) {
            return U.split(/[\t\n\f\r ]+/);
          }
          __name(z, "z");
          function H(U) {
            for (let de = 0; de < 2; de++) {
              let De = U.getParentNode(de);
              if (De && De.type === "AttrNode")
                return De.name.toLowerCase();
            }
          }
          __name(H, "H");
          function Z(U) {
            return U = typeof U == "string" ? U : "", U.split(`
`).length - 1;
          }
          __name(Z, "Z");
          function ne(U) {
            U = typeof U == "string" ? U : "";
            let de = (U.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
            return Z(de);
          }
          __name(ne, "ne");
          function fe(U) {
            U = typeof U == "string" ? U : "";
            let de = (U.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
            return Z(de);
          }
          __name(fe, "fe");
          function ge() {
            let U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return Array.from({ length: Math.min(U, o) }).fill(r);
          }
          __name(ge, "ge");
          function Ce(U, de) {
            let { quote: De, regex: he } = p(U, de);
            return [De, U.replace(he, `\\${De}`), De];
          }
          __name(Ce, "Ce");
          function _e(U) {
            let de = 0, De = U.getParentNode(de);
            for (; De && $(De, ["SubExpression"]); )
              de++, De = U.getParentNode(de);
            return !!(De && $(U.getParentNode(de + 1), ["ConcatStatement"]) && $(U.getParentNode(de + 2), ["AttrNode"]));
          }
          __name(_e, "_e");
          function Oe(U, de) {
            let De = ie(U, de), he = ve(U, de);
            return he ? i([De, c, a(he)]) : De;
          }
          __name(Oe, "Oe");
          function pe(U, de) {
            let De = ie(U, de), he = ve(U, de);
            return he ? [i([De, c, he]), y] : De;
          }
          __name(pe, "pe");
          function ie(U, de) {
            return de("path");
          }
          __name(ie, "ie");
          function ve(U, de) {
            let De = U.getValue(), he = [];
            if (De.params.length > 0) {
              let Be = U.map(de, "params");
              he.push(...Be);
            }
            if (De.hash && De.hash.pairs.length > 0) {
              let Be = de("hash");
              he.push(Be);
            }
            return he.length === 0 ? "" : l(c, he);
          }
          __name(ve, "ve");
          function ce(U) {
            return ["as |", U.blockParams.join(" "), "|"];
          }
          __name(ce, "ce");
          n.exports = { print: d, massageAstNode: T };
        } }), xd = ee({ "src/language-handlebars/parsers.js"() {
          re();
        } }), bd = ee({ "node_modules/linguist-languages/data/Handlebars.json"(e, n) {
          n.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
        } }), Td = ee({ "src/language-handlebars/index.js"(e, n) {
          "use strict";
          re();
          var t = wt(), s = Sd(), a = xd(), r = [t(bd(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
          n.exports = { languages: r, printers: u, parsers: a };
        } }), Bd = ee({ "src/language-graphql/pragma.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a);
          }
          __name(t, "t");
          function s(a) {
            return `# @format

` + a;
          }
          __name(s, "s");
          n.exports = { hasPragma: t, insertPragma: s };
        } }), Nd = ee({ "src/language-graphql/loc.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return typeof a.start == "number" ? a.start : a.loc && a.loc.start;
          }
          __name(t, "t");
          function s(a) {
            return typeof a.end == "number" ? a.end : a.loc && a.loc.end;
          }
          __name(s, "s");
          n.exports = { locStart: t, locEnd: s };
        } }), wd = ee({ "src/language-graphql/printer-graphql.js"(e, n) {
          "use strict";
          re();
          var { builders: { join: t, hardline: s, line: a, softline: r, group: u, indent: i, ifBreak: l } } = qe(), { isNextLineEmpty: c, isNonEmptyArray: y } = Ge(), { insertPragma: h } = Bd(), { locStart: g, locEnd: p } = Nd();
          function D(P, $, f) {
            let x = P.getValue();
            if (!x)
              return "";
            if (typeof x == "string")
              return x;
            switch (x.kind) {
              case "Document": {
                let m = [];
                return P.each((E, o, d) => {
                  m.push(f()), o !== d.length - 1 && (m.push(s), c($.originalText, E.getValue(), p) && m.push(s));
                }, "definitions"), [...m, s];
              }
              case "OperationDefinition": {
                let m = $.originalText[g(x)] !== "{", E = Boolean(x.name);
                return [m ? x.operation : "", m && E ? [" ", f("name")] : "", m && !E && y(x.variableDefinitions) ? " " : "", y(x.variableDefinitions) ? u(["(", i([r, t([l("", ", "), r], P.map(f, "variableDefinitions"))]), r, ")"]) : "", v(P, f, x), x.selectionSet ? !m && !E ? "" : " " : "", f("selectionSet")];
              }
              case "FragmentDefinition":
                return ["fragment ", f("name"), y(x.variableDefinitions) ? u(["(", i([r, t([l("", ", "), r], P.map(f, "variableDefinitions"))]), r, ")"]) : "", " on ", f("typeCondition"), v(P, f, x), " ", f("selectionSet")];
              case "SelectionSet":
                return ["{", i([s, t(s, w(P, $, f, "selections"))]), s, "}"];
              case "Field":
                return u([x.alias ? [f("alias"), ": "] : "", f("name"), x.arguments.length > 0 ? u(["(", i([r, t([l("", ", "), r], w(P, $, f, "arguments"))]), r, ")"]) : "", v(P, f, x), x.selectionSet ? " " : "", f("selectionSet")]);
              case "Name":
                return x.value;
              case "StringValue": {
                if (x.block) {
                  let m = x.value.replace(/"""/g, "\\$&").split(`
`);
                  return m.length === 1 && (m[0] = m[0].trim()), m.every((E) => E === "") && (m.length = 0), t(s, ['"""', ...m, '"""']);
                }
                return ['"', x.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
              }
              case "IntValue":
              case "FloatValue":
              case "EnumValue":
                return x.value;
              case "BooleanValue":
                return x.value ? "true" : "false";
              case "NullValue":
                return "null";
              case "Variable":
                return ["$", f("name")];
              case "ListValue":
                return u(["[", i([r, t([l("", ", "), r], P.map(f, "values"))]), r, "]"]);
              case "ObjectValue":
                return u(["{", $.bracketSpacing && x.fields.length > 0 ? " " : "", i([r, t([l("", ", "), r], P.map(f, "fields"))]), r, l("", $.bracketSpacing && x.fields.length > 0 ? " " : ""), "}"]);
              case "ObjectField":
              case "Argument":
                return [f("name"), ": ", f("value")];
              case "Directive":
                return ["@", f("name"), x.arguments.length > 0 ? u(["(", i([r, t([l("", ", "), r], w(P, $, f, "arguments"))]), r, ")"]) : ""];
              case "NamedType":
                return f("name");
              case "VariableDefinition":
                return [f("variable"), ": ", f("type"), x.defaultValue ? [" = ", f("defaultValue")] : "", v(P, f, x)];
              case "ObjectTypeExtension":
              case "ObjectTypeDefinition":
                return [f("description"), x.description ? s : "", x.kind === "ObjectTypeExtension" ? "extend " : "", "type ", f("name"), x.interfaces.length > 0 ? [" implements ", ...A(P, $, f)] : "", v(P, f, x), x.fields.length > 0 ? [" {", i([s, t(s, w(P, $, f, "fields"))]), s, "}"] : ""];
              case "FieldDefinition":
                return [f("description"), x.description ? s : "", f("name"), x.arguments.length > 0 ? u(["(", i([r, t([l("", ", "), r], w(P, $, f, "arguments"))]), r, ")"]) : "", ": ", f("type"), v(P, f, x)];
              case "DirectiveDefinition":
                return [f("description"), x.description ? s : "", "directive ", "@", f("name"), x.arguments.length > 0 ? u(["(", i([r, t([l("", ", "), r], w(P, $, f, "arguments"))]), r, ")"]) : "", x.repeatable ? " repeatable" : "", " on ", t(" | ", P.map(f, "locations"))];
              case "EnumTypeExtension":
              case "EnumTypeDefinition":
                return [f("description"), x.description ? s : "", x.kind === "EnumTypeExtension" ? "extend " : "", "enum ", f("name"), v(P, f, x), x.values.length > 0 ? [" {", i([s, t(s, w(P, $, f, "values"))]), s, "}"] : ""];
              case "EnumValueDefinition":
                return [f("description"), x.description ? s : "", f("name"), v(P, f, x)];
              case "InputValueDefinition":
                return [f("description"), x.description ? x.description.block ? s : a : "", f("name"), ": ", f("type"), x.defaultValue ? [" = ", f("defaultValue")] : "", v(P, f, x)];
              case "InputObjectTypeExtension":
              case "InputObjectTypeDefinition":
                return [f("description"), x.description ? s : "", x.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", f("name"), v(P, f, x), x.fields.length > 0 ? [" {", i([s, t(s, w(P, $, f, "fields"))]), s, "}"] : ""];
              case "SchemaExtension":
                return ["extend schema", v(P, f, x), ...x.operationTypes.length > 0 ? [" {", i([s, t(s, w(P, $, f, "operationTypes"))]), s, "}"] : []];
              case "SchemaDefinition":
                return [f("description"), x.description ? s : "", "schema", v(P, f, x), " {", x.operationTypes.length > 0 ? i([s, t(s, w(P, $, f, "operationTypes"))]) : "", s, "}"];
              case "OperationTypeDefinition":
                return [f("operation"), ": ", f("type")];
              case "InterfaceTypeExtension":
              case "InterfaceTypeDefinition":
                return [f("description"), x.description ? s : "", x.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", f("name"), x.interfaces.length > 0 ? [" implements ", ...A(P, $, f)] : "", v(P, f, x), x.fields.length > 0 ? [" {", i([s, t(s, w(P, $, f, "fields"))]), s, "}"] : ""];
              case "FragmentSpread":
                return ["...", f("name"), v(P, f, x)];
              case "InlineFragment":
                return ["...", x.typeCondition ? [" on ", f("typeCondition")] : "", v(P, f, x), " ", f("selectionSet")];
              case "UnionTypeExtension":
              case "UnionTypeDefinition":
                return u([f("description"), x.description ? s : "", u([x.kind === "UnionTypeExtension" ? "extend " : "", "union ", f("name"), v(P, f, x), x.types.length > 0 ? [" =", l("", " "), i([l([a, "  "]), t([a, "| "], P.map(f, "types"))])] : ""])]);
              case "ScalarTypeExtension":
              case "ScalarTypeDefinition":
                return [f("description"), x.description ? s : "", x.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", f("name"), v(P, f, x)];
              case "NonNullType":
                return [f("type"), "!"];
              case "ListType":
                return ["[", f("type"), "]"];
              default:
                throw new Error("unknown graphql type: " + JSON.stringify(x.kind));
            }
          }
          __name(D, "D");
          function v(P, $, f) {
            if (f.directives.length === 0)
              return "";
            let x = t(a, P.map($, "directives"));
            return f.kind === "FragmentDefinition" || f.kind === "OperationDefinition" ? u([a, x]) : [" ", u(i([r, x]))];
          }
          __name(v, "v");
          function w(P, $, f, x) {
            return P.map((m, E, o) => {
              let d = f();
              return E < o.length - 1 && c($.originalText, m.getValue(), p) ? [d, s] : d;
            }, x);
          }
          __name(w, "w");
          function T(P) {
            return P.kind && P.kind !== "Comment";
          }
          __name(T, "T");
          function F(P) {
            let $ = P.getValue();
            if ($.kind === "Comment")
              return "#" + $.value.trimEnd();
            throw new Error("Not a comment: " + JSON.stringify($));
          }
          __name(F, "F");
          function A(P, $, f) {
            let x = P.getNode(), m = [], { interfaces: E } = x, o = P.map((d) => f(d), "interfaces");
            for (let d = 0; d < E.length; d++) {
              let C = E[d];
              m.push(o[d]);
              let _ = E[d + 1];
              if (_) {
                let b = $.originalText.slice(C.loc.end, _.loc.start), N = b.includes("#"), k = b.replace(/#.*/g, "").trim();
                m.push(k === "," ? "," : " &", N ? a : " ");
              }
            }
            return m;
          }
          __name(A, "A");
          function B(P, $) {
            P.kind === "StringValue" && P.block && !P.value.includes(`
`) && ($.value = $.value.trim());
          }
          __name(B, "B");
          B.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
          function I(P) {
            var $;
            let f = P.getValue();
            return f == null || ($ = f.comments) === null || $ === void 0 ? void 0 : $.some((x) => x.value.trim() === "prettier-ignore");
          }
          __name(I, "I");
          n.exports = { print: D, massageAstNode: B, hasPrettierIgnore: I, insertPragma: h, printComment: F, canAttachComment: T };
        } }), _d = ee({ "src/language-graphql/options.js"(e, n) {
          "use strict";
          re();
          var t = qt();
          n.exports = { bracketSpacing: t.bracketSpacing };
        } }), Pd = ee({ "src/language-graphql/parsers.js"() {
          re();
        } }), Id = ee({ "node_modules/linguist-languages/data/GraphQL.json"(e, n) {
          n.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
        } }), kd = ee({ "src/language-graphql/index.js"(e, n) {
          "use strict";
          re();
          var t = wt(), s = wd(), a = _d(), r = Pd(), u = [t(Id(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s };
          n.exports = { languages: u, options: a, printers: i, parsers: r };
        } }), co = ee({ "src/language-markdown/loc.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return a.position.start.offset;
          }
          __name(t, "t");
          function s(a) {
            return a.position.end.offset;
          }
          __name(s, "s");
          n.exports = { locStart: t, locEnd: s };
        } }), Ld = ee({ "src/language-markdown/constants.evaluate.js"(e, n) {
          n.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
        } }), Yn = ee({ "src/language-markdown/utils.js"(e, n) {
          "use strict";
          re();
          var { getLast: t } = Ge(), { locStart: s, locEnd: a } = co(), { cjkPattern: r, kPattern: u, punctuationPattern: i } = Ld(), l = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], c = [...l, "tableCell", "paragraph", "heading"], y = new RegExp(u), h = new RegExp(i);
          function g(F, A) {
            let B = "non-cjk", I = "cj-letter", P = "k-letter", $ = "cjk-punctuation", f = [], x = (A.proseWrap === "preserve" ? F : F.replace(new RegExp(`(${r})
(${r})`, "g"), "$1$2")).split(/([\t\n ]+)/);
            for (let [E, o] of x.entries()) {
              if (E % 2 === 1) {
                f.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
                continue;
              }
              if ((E === 0 || E === x.length - 1) && o === "")
                continue;
              let d = o.split(new RegExp(`(${r})`));
              for (let [C, _] of d.entries())
                if (!((C === 0 || C === d.length - 1) && _ === "")) {
                  if (C % 2 === 0) {
                    _ !== "" && m({ type: "word", value: _, kind: B, hasLeadingPunctuation: h.test(_[0]), hasTrailingPunctuation: h.test(t(_)) });
                    continue;
                  }
                  m(h.test(_) ? { type: "word", value: _, kind: $, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: _, kind: y.test(_) ? P : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                }
            }
            return f;
            function m(E) {
              let o = t(f);
              o && o.type === "word" && (o.kind === B && E.kind === I && !o.hasTrailingPunctuation || o.kind === I && E.kind === B && !E.hasLeadingPunctuation ? f.push({ type: "whitespace", value: " " }) : !d(B, $) && ![o.value, E.value].some((C) => /\u3000/.test(C)) && f.push({ type: "whitespace", value: "" })), f.push(E);
              function d(C, _) {
                return o.kind === C && E.kind === _ || o.kind === _ && E.kind === C;
              }
              __name(d, "d");
            }
            __name(m, "m");
          }
          __name(g, "g");
          function p(F, A) {
            let [, B, I, P] = A.slice(F.position.start.offset, F.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
            return { numberText: B, marker: I, leadingSpaces: P };
          }
          __name(p, "p");
          function D(F, A) {
            if (!F.ordered || F.children.length < 2)
              return false;
            let B = Number(p(F.children[0], A.originalText).numberText), I = Number(p(F.children[1], A.originalText).numberText);
            if (B === 0 && F.children.length > 2) {
              let P = Number(p(F.children[2], A.originalText).numberText);
              return I === 1 && P === 1;
            }
            return I === 1;
          }
          __name(D, "D");
          function v(F, A) {
            let { value: B } = F;
            return F.position.end.offset === A.length && B.endsWith(`
`) && A.endsWith(`
`) ? B.slice(0, -1) : B;
          }
          __name(v, "v");
          function w(F, A) {
            return (/* @__PURE__ */ __name(function B(I, P, $) {
              let f = Object.assign({}, A(I, P, $));
              return f.children && (f.children = f.children.map((x, m) => B(x, m, [f, ...$]))), f;
            }, "B"))(F, null, []);
          }
          __name(w, "w");
          function T(F) {
            if ((F == null ? void 0 : F.type) !== "link" || F.children.length !== 1)
              return false;
            let [A] = F.children;
            return s(F) === s(A) && a(F) === a(A);
          }
          __name(T, "T");
          n.exports = { mapAst: w, splitText: g, punctuationPattern: i, getFencedCodeBlockValue: v, getOrderedListItemInfo: p, hasGitDiffFriendlyOrderedList: D, INLINE_NODE_TYPES: l, INLINE_NODE_WRAPPER_TYPES: c, isAutolink: T };
        } }), jd = ee({ "src/language-markdown/embed.js"(e, n) {
          "use strict";
          re();
          var { inferParserByLanguage: t, getMaxContinuousCount: s } = Ge(), { builders: { hardline: a, markAsRoot: r }, utils: { replaceEndOfLine: u } } = qe(), i = Kn(), { getFencedCodeBlockValue: l } = Yn();
          function c(y, h, g, p) {
            let D = y.getValue();
            if (D.type === "code" && D.lang !== null) {
              let v = t(D.lang, p);
              if (v) {
                let w = p.__inJsTemplate ? "~" : "`", T = w.repeat(Math.max(3, s(D.value, w) + 1)), F = { parser: v };
                D.lang === "tsx" && (F.filepath = "dummy.tsx");
                let A = g(l(D, p.originalText), F, { stripTrailingHardline: true });
                return r([T, D.lang, D.meta ? " " + D.meta : "", a, u(A), a, T]);
              }
            }
            switch (D.type) {
              case "front-matter":
                return i(D, g);
              case "importExport":
                return [g(D.value, { parser: "babel" }, { stripTrailingHardline: true }), a];
              case "jsx":
                return g(`<$>${D.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
            }
            return null;
          }
          __name(c, "c");
          n.exports = c;
        } }), po = ee({ "src/language-markdown/pragma.js"(e, n) {
          "use strict";
          re();
          var t = lo(), s = ["format", "prettier"];
          function a(r) {
            let u = `@(${s.join("|")})`, i = new RegExp([`<!--\\s*${u}\\s*-->`, `{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l = r.match(i);
            return (l == null ? void 0 : l.index) === 0;
          }
          __name(a, "a");
          n.exports = { startWithPragma: a, hasPragma: (r) => a(t(r).content.trimStart()), insertPragma: (r) => {
            let u = t(r), i = `<!-- @${s[0]} -->`;
            return u.frontMatter ? `${u.frontMatter.raw}

${i}

${u.content}` : `${i}

${u.content}`;
          } };
        } }), Od = ee({ "src/language-markdown/print-preprocess.js"(e, n) {
          "use strict";
          re();
          var t = lt(), { getOrderedListItemInfo: s, mapAst: a, splitText: r } = Yn(), u = /^.$/su;
          function i(T, F) {
            return T = y(T, F), T = p(T), T = c(T, F), T = v(T, F), T = w(T, F), T = D(T, F), T = l(T), T = h(T), T;
          }
          __name(i, "i");
          function l(T) {
            return a(T, (F) => F.type !== "import" && F.type !== "export" ? F : Object.assign(Object.assign({}, F), {}, { type: "importExport" }));
          }
          __name(l, "l");
          function c(T, F) {
            return a(T, (A) => A.type !== "inlineCode" || F.proseWrap === "preserve" ? A : Object.assign(Object.assign({}, A), {}, { value: A.value.replace(/\s+/g, " ") }));
          }
          __name(c, "c");
          function y(T, F) {
            return a(T, (A) => A.type !== "text" || A.value === "*" || A.value === "_" || !u.test(A.value) || A.position.end.offset - A.position.start.offset === A.value.length ? A : Object.assign(Object.assign({}, A), {}, { value: F.originalText.slice(A.position.start.offset, A.position.end.offset) }));
          }
          __name(y, "y");
          function h(T) {
            return g(T, (F, A) => F.type === "importExport" && A.type === "importExport", (F, A) => ({ type: "importExport", value: F.value + `

` + A.value, position: { start: F.position.start, end: A.position.end } }));
          }
          __name(h, "h");
          function g(T, F, A) {
            return a(T, (B) => {
              if (!B.children)
                return B;
              let I = B.children.reduce((P, $) => {
                let f = t(P);
                return f && F(f, $) ? P.splice(-1, 1, A(f, $)) : P.push($), P;
              }, []);
              return Object.assign(Object.assign({}, B), {}, { children: I });
            });
          }
          __name(g, "g");
          function p(T) {
            return g(T, (F, A) => F.type === "text" && A.type === "text", (F, A) => ({ type: "text", value: F.value + A.value, position: { start: F.position.start, end: A.position.end } }));
          }
          __name(p, "p");
          function D(T, F) {
            return a(T, (A, B, I) => {
              let [P] = I;
              if (A.type !== "text")
                return A;
              let { value: $ } = A;
              return P.type === "paragraph" && (B === 0 && ($ = $.trimStart()), B === P.children.length - 1 && ($ = $.trimEnd())), { type: "sentence", position: A.position, children: r($, F) };
            });
          }
          __name(D, "D");
          function v(T, F) {
            return a(T, (A, B, I) => {
              if (A.type === "code") {
                let P = /^\n?(?: {4,}|\t)/.test(F.originalText.slice(A.position.start.offset, A.position.end.offset));
                if (A.isIndented = P, P)
                  for (let $ = 0; $ < I.length; $++) {
                    let f = I[$];
                    if (f.hasIndentedCodeblock)
                      break;
                    f.type === "list" && (f.hasIndentedCodeblock = true);
                  }
              }
              return A;
            });
          }
          __name(v, "v");
          function w(T, F) {
            return a(T, (I, P, $) => {
              if (I.type === "list" && I.children.length > 0) {
                for (let f = 0; f < $.length; f++) {
                  let x = $[f];
                  if (x.type === "list" && !x.isAligned)
                    return I.isAligned = false, I;
                }
                I.isAligned = B(I);
              }
              return I;
            });
            function A(I) {
              return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
            }
            __name(A, "A");
            function B(I) {
              if (!I.ordered)
                return true;
              let [P, $] = I.children;
              if (s(P, F.originalText).leadingSpaces.length > 1)
                return true;
              let x = A(P);
              if (x === -1)
                return false;
              if (I.children.length === 1)
                return x % F.tabWidth === 0;
              let m = A($);
              return x !== m ? false : x % F.tabWidth === 0 ? true : s($, F.originalText).leadingSpaces.length > 1;
            }
            __name(B, "B");
          }
          __name(w, "w");
          n.exports = i;
        } }), qd = ee({ "src/language-markdown/clean.js"(e, n) {
          "use strict";
          re();
          var { isFrontMatterNode: t } = Ge(), { startWithPragma: s } = po(), a = /* @__PURE__ */ new Set(["position", "raw"]);
          function r(u, i, l) {
            if ((u.type === "front-matter" || u.type === "code" || u.type === "yaml" || u.type === "import" || u.type === "export" || u.type === "jsx") && delete i.value, u.type === "list" && delete i.isAligned, (u.type === "list" || u.type === "listItem") && (delete i.spread, delete i.loose), u.type === "text" || (u.type === "inlineCode" && (i.value = u.value.replace(/[\t\n ]+/g, " ")), u.type === "wikiLink" && (i.value = u.value.trim().replace(/[\t\n]+/g, " ")), (u.type === "definition" || u.type === "linkReference") && (i.label = u.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), (u.type === "definition" || u.type === "link" || u.type === "image") && u.title && (i.title = u.title.replace(/\\(["')])/g, "$1")), l && l.type === "root" && l.children.length > 0 && (l.children[0] === u || t(l.children[0]) && l.children[1] === u) && u.type === "html" && s(u.value)))
              return null;
          }
          __name(r, "r");
          r.ignoredProperties = a, n.exports = r;
        } }), Md = ee({ "src/language-markdown/printer-markdown.js"(e, n) {
          "use strict";
          re();
          var { getLast: t, getMinNotPresentContinuousCount: s, getMaxContinuousCount: a, getStringWidth: r, isNonEmptyArray: u } = Ge(), { builders: { breakParent: i, join: l, line: c, literalline: y, markAsRoot: h, hardline: g, softline: p, ifBreak: D, fill: v, align: w, indent: T, group: F, hardlineWithoutBreakParent: A }, utils: { normalizeDoc: B, replaceTextEndOfLine: I }, printer: { printDocToString: P } } = qe(), $ = jd(), { insertPragma: f } = po(), { locStart: x, locEnd: m } = co(), E = Od(), o = qd(), { getFencedCodeBlockValue: d, hasGitDiffFriendlyOrderedList: C, splitText: _, punctuationPattern: b, INLINE_NODE_TYPES: N, INLINE_NODE_WRAPPER_TYPES: k, isAutolink: R } = Yn(), M = /* @__PURE__ */ new Set(["importExport"]), q = ["heading", "tableCell", "link", "wikiLink"], J = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
          function L(pe, ie, ve) {
            let ce = pe.getValue();
            if (fe(pe))
              return _(ie.originalText.slice(ce.position.start.offset, ce.position.end.offset), ie).map((U) => U.type === "word" ? U.value : U.value === "" ? "" : le(pe, U.value, ie));
            switch (ce.type) {
              case "front-matter":
                return ie.originalText.slice(ce.position.start.offset, ce.position.end.offset);
              case "root":
                return ce.children.length === 0 ? "" : [B(X(pe, ie, ve)), M.has(Ae(ce).type) ? "" : g];
              case "paragraph":
                return oe(pe, ie, ve, { postprocessor: v });
              case "sentence":
                return oe(pe, ie, ve);
              case "word": {
                let U = ce.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${b})(_+)`, `(_+)(${b}|$)`].join("|"), "g"), (he, Be, Se, ye, S) => (Se ? `${Be}${Se}` : `${ye}${S}`).replace(/_/g, "\\_")), de = /* @__PURE__ */ __name((he, Be, Se) => he.type === "sentence" && Se === 0, "de"), De = /* @__PURE__ */ __name((he, Be, Se) => R(he.children[Se - 1]), "De");
                return U !== ce.value && (pe.match(void 0, de, De) || pe.match(void 0, de, (he, Be, Se) => he.type === "emphasis" && Se === 0, De)) && (U = U.replace(/^(\\?[*_])+/, (he) => he.replace(/\\/g, ""))), U;
              }
              case "whitespace": {
                let U = pe.getParentNode(), de = U.children.indexOf(ce), De = U.children[de + 1], he = De && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(De.value) ? "never" : ie.proseWrap;
                return le(pe, ce.value, { proseWrap: he });
              }
              case "emphasis": {
                let U;
                if (R(ce.children[0]))
                  U = ie.originalText[ce.position.start.offset];
                else {
                  let de = pe.getParentNode(), De = de.children.indexOf(ce), he = de.children[De - 1], Be = de.children[De + 1];
                  U = he && he.type === "sentence" && he.children.length > 0 && t(he.children).type === "word" && !t(he.children).hasTrailingPunctuation || Be && Be.type === "sentence" && Be.children.length > 0 && Be.children[0].type === "word" && !Be.children[0].hasLeadingPunctuation || Q(pe, "emphasis") ? "*" : "_";
                }
                return [U, oe(pe, ie, ve), U];
              }
              case "strong":
                return ["**", oe(pe, ie, ve), "**"];
              case "delete":
                return ["~~", oe(pe, ie, ve), "~~"];
              case "inlineCode": {
                let U = s(ce.value, "`"), de = "`".repeat(U || 1), De = U && !/^\s/.test(ce.value) ? " " : "";
                return [de, De, ce.value, De, de];
              }
              case "wikiLink": {
                let U = "";
                return ie.proseWrap === "preserve" ? U = ce.value : U = ce.value.replace(/[\t\n]+/g, " "), ["[[", U, "]]"];
              }
              case "link":
                switch (ie.originalText[ce.position.start.offset]) {
                  case "<": {
                    let U = "mailto:", de = ce.url.startsWith(U) && ie.originalText.slice(ce.position.start.offset + 1, ce.position.start.offset + 1 + U.length) !== U ? ce.url.slice(U.length) : ce.url;
                    return ["<", de, ">"];
                  }
                  case "[":
                    return ["[", oe(pe, ie, ve), "](", ge(ce.url, ")"), Ce(ce.title, ie), ")"];
                  default:
                    return ie.originalText.slice(ce.position.start.offset, ce.position.end.offset);
                }
              case "image":
                return ["![", ce.alt || "", "](", ge(ce.url, ")"), Ce(ce.title, ie), ")"];
              case "blockquote":
                return ["> ", w("> ", oe(pe, ie, ve))];
              case "heading":
                return ["#".repeat(ce.depth) + " ", oe(pe, ie, ve)];
              case "code": {
                if (ce.isIndented) {
                  let De = " ".repeat(4);
                  return w(De, [De, ...I(ce.value, g)]);
                }
                let U = ie.__inJsTemplate ? "~" : "`", de = U.repeat(Math.max(3, a(ce.value, U) + 1));
                return [de, ce.lang || "", ce.meta ? " " + ce.meta : "", g, ...I(d(ce, ie.originalText), g), g, de];
              }
              case "html": {
                let U = pe.getParentNode(), de = U.type === "root" && t(U.children) === ce ? ce.value.trimEnd() : ce.value, De = /^<!--.*-->$/s.test(de);
                return I(de, De ? g : h(y));
              }
              case "list": {
                let U = O(ce, pe.getParentNode()), de = C(ce, ie);
                return oe(pe, ie, ve, { processor: (De, he) => {
                  let Be = ye(), Se = De.getValue();
                  if (Se.children.length === 2 && Se.children[1].type === "html" && Se.children[0].position.start.column !== Se.children[1].position.start.column)
                    return [Be, Y(De, ie, ve, Be)];
                  return [Be, w(" ".repeat(Be.length), Y(De, ie, ve, Be))];
                  function ye() {
                    let S = ce.ordered ? (he === 0 ? ce.start : de ? 1 : ce.start + he) + (U % 2 === 0 ? ". " : ") ") : U % 2 === 0 ? "- " : "* ";
                    return ce.isAligned || ce.hasIndentedCodeblock ? V(S, ie) : S;
                  }
                  __name(ye, "ye");
                } });
              }
              case "thematicBreak": {
                let U = se(pe, "list");
                return U === -1 ? "---" : O(pe.getParentNode(U), pe.getParentNode(U + 1)) % 2 === 0 ? "***" : "---";
              }
              case "linkReference":
                return ["[", oe(pe, ie, ve), "]", ce.referenceType === "full" ? ["[", ce.identifier, "]"] : ce.referenceType === "collapsed" ? "[]" : ""];
              case "imageReference":
                switch (ce.referenceType) {
                  case "full":
                    return ["![", ce.alt || "", "][", ce.identifier, "]"];
                  default:
                    return ["![", ce.alt, "]", ce.referenceType === "collapsed" ? "[]" : ""];
                }
              case "definition": {
                let U = ie.proseWrap === "always" ? c : " ";
                return F(["[", ce.identifier, "]:", T([U, ge(ce.url), ce.title === null ? "" : [U, Ce(ce.title, ie, false)]])]);
              }
              case "footnote":
                return ["[^", oe(pe, ie, ve), "]"];
              case "footnoteReference":
                return ["[^", ce.identifier, "]"];
              case "footnoteDefinition": {
                let U = pe.getParentNode().children[pe.getName() + 1], de = ce.children.length === 1 && ce.children[0].type === "paragraph" && (ie.proseWrap === "never" || ie.proseWrap === "preserve" && ce.children[0].position.start.line === ce.children[0].position.end.line);
                return ["[^", ce.identifier, "]: ", de ? oe(pe, ie, ve) : F([w(" ".repeat(4), oe(pe, ie, ve, { processor: (De, he) => he === 0 ? F([p, ve()]) : ve() })), U && U.type === "footnoteDefinition" ? p : ""])];
              }
              case "table":
                return W(pe, ie, ve);
              case "tableCell":
                return oe(pe, ie, ve);
              case "break":
                return /\s/.test(ie.originalText[ce.position.start.offset]) ? ["  ", h(y)] : ["\\", g];
              case "liquidNode":
                return I(ce.value, g);
              case "importExport":
                return [ce.value, g];
              case "esComment":
                return ["{/* ", ce.value, " */}"];
              case "jsx":
                return ce.value;
              case "math":
                return ["$$", g, ce.value ? [...I(ce.value, g), g] : "", "$$"];
              case "inlineMath":
                return ie.originalText.slice(x(ce), m(ce));
              case "tableRow":
              case "listItem":
              default:
                throw new Error(`Unknown markdown type ${JSON.stringify(ce.type)}`);
            }
          }
          __name(L, "L");
          function Y(pe, ie, ve, ce) {
            let U = pe.getValue(), de = U.checked === null ? "" : U.checked ? "[x] " : "[ ] ";
            return [de, oe(pe, ie, ve, { processor: (De, he) => {
              if (he === 0 && De.getValue().type !== "list")
                return w(" ".repeat(de.length), ve());
              let Be = " ".repeat(_e(ie.tabWidth - ce.length, 0, 3));
              return [Be, w(Be, ve())];
            } })];
          }
          __name(Y, "Y");
          function V(pe, ie) {
            let ve = ce();
            return pe + " ".repeat(ve >= 4 ? 0 : ve);
            function ce() {
              let U = pe.length % ie.tabWidth;
              return U === 0 ? 0 : ie.tabWidth - U;
            }
            __name(ce, "ce");
          }
          __name(V, "V");
          function O(pe, ie) {
            return K(pe, ie, (ve) => ve.ordered === pe.ordered);
          }
          __name(O, "O");
          function K(pe, ie, ve) {
            let ce = -1;
            for (let U of ie.children)
              if (U.type === pe.type && ve(U) ? ce++ : ce = -1, U === pe)
                return ce;
          }
          __name(K, "K");
          function se(pe, ie) {
            let ve = Array.isArray(ie) ? ie : [ie], ce = -1, U;
            for (; U = pe.getParentNode(++ce); )
              if (ve.includes(U.type))
                return ce;
            return -1;
          }
          __name(se, "se");
          function Q(pe, ie) {
            let ve = se(pe, ie);
            return ve === -1 ? null : pe.getParentNode(ve);
          }
          __name(Q, "Q");
          function le(pe, ie, ve) {
            if (ve.proseWrap === "preserve" && ie === `
`)
              return g;
            let ce = ve.proseWrap === "always" && !Q(pe, q);
            return ie !== "" ? ce ? c : " " : ce ? p : "";
          }
          __name(le, "le");
          function W(pe, ie, ve) {
            let ce = pe.getValue(), U = [], de = pe.map((S) => S.map((G, te) => {
              let Ee = P(ve(), ie).formatted, Re = r(Ee);
              return U[te] = Math.max(U[te] || 3, Re), { text: Ee, width: Re };
            }, "children"), "children"), De = Be(false);
            if (ie.proseWrap !== "never")
              return [i, De];
            let he = Be(true);
            return [i, F(D(he, De))];
            function Be(S) {
              let G = [ye(de[0], S), Se(S)];
              return de.length > 1 && G.push(l(A, de.slice(1).map((te) => ye(te, S)))), l(A, G);
            }
            __name(Be, "Be");
            function Se(S) {
              return `| ${U.map((te, Ee) => {
                let Re = ce.align[Ee], Te = Re === "center" || Re === "left" ? ":" : "-", Pe = Re === "center" || Re === "right" ? ":" : "-", Fe = S ? "-" : "-".repeat(te - 2);
                return `${Te}${Fe}${Pe}`;
              }).join(" | ")} |`;
            }
            __name(Se, "Se");
            function ye(S, G) {
              return `| ${S.map((Ee, Re) => {
                let { text: Te, width: Pe } = Ee;
                if (G)
                  return Te;
                let Fe = U[Re] - Pe, Ze = ce.align[Re], xe = 0;
                Ze === "right" ? xe = Fe : Ze === "center" && (xe = Math.floor(Fe / 2));
                let Je = Fe - xe;
                return `${" ".repeat(xe)}${Te}${" ".repeat(Je)}`;
              }).join(" | ")} |`;
            }
            __name(ye, "ye");
          }
          __name(W, "W");
          function X(pe, ie, ve) {
            let ce = [], U = null, { children: de } = pe.getValue();
            for (let [De, he] of de.entries())
              switch (z(he)) {
                case "start":
                  U === null && (U = { index: De, offset: he.position.end.offset });
                  break;
                case "end":
                  U !== null && (ce.push({ start: U, end: { index: De, offset: he.position.start.offset } }), U = null);
                  break;
                default:
                  break;
              }
            return oe(pe, ie, ve, { processor: (De, he) => {
              if (ce.length > 0) {
                let Be = ce[0];
                if (he === Be.start.index)
                  return [ae(de[Be.start.index]), ie.originalText.slice(Be.start.offset, Be.end.offset), ae(de[Be.end.index])];
                if (Be.start.index < he && he < Be.end.index)
                  return false;
                if (he === Be.end.index)
                  return ce.shift(), false;
              }
              return ve();
            } });
          }
          __name(X, "X");
          function oe(pe, ie, ve) {
            let ce = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: U } = ce, de = ce.processor || (() => ve()), De = pe.getValue(), he = [], Be;
            return pe.each((Se, ye) => {
              let S = Se.getValue(), G = de(Se, ye);
              if (G !== false) {
                let te = { parts: he, prevNode: Be, parentNode: De, options: ie };
                H(S, te) && (he.push(g), Be && M.has(Be.type) || (Z(S, te) || ne(S, te)) && he.push(g), ne(S, te) && he.push(g)), he.push(G), Be = S;
              }
            }, "children"), U ? U(he) : he;
          }
          __name(oe, "oe");
          function ae(pe) {
            if (pe.type === "html")
              return pe.value;
            if (pe.type === "paragraph" && Array.isArray(pe.children) && pe.children.length === 1 && pe.children[0].type === "esComment")
              return ["{/* ", pe.children[0].value, " */}"];
          }
          __name(ae, "ae");
          function Ae(pe) {
            let ie = pe;
            for (; u(ie.children); )
              ie = t(ie.children);
            return ie;
          }
          __name(Ae, "Ae");
          function z(pe) {
            let ie;
            if (pe.type === "html")
              ie = pe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
            else {
              let ve;
              pe.type === "esComment" ? ve = pe : pe.type === "paragraph" && pe.children.length === 1 && pe.children[0].type === "esComment" && (ve = pe.children[0]), ve && (ie = ve.value.match(/^prettier-ignore(?:-(start|end))?$/));
            }
            return ie ? ie[1] || "next" : false;
          }
          __name(z, "z");
          function H(pe, ie) {
            let ve = ie.parts.length === 0, ce = N.includes(pe.type), U = pe.type === "html" && k.includes(ie.parentNode.type);
            return !ve && !ce && !U;
          }
          __name(H, "H");
          function Z(pe, ie) {
            var ve, ce, U;
            let De = (ie.prevNode && ie.prevNode.type) === pe.type && J.has(pe.type), he = ie.parentNode.type === "listItem" && !ie.parentNode.loose, Be = ((ve = ie.prevNode) === null || ve === void 0 ? void 0 : ve.type) === "listItem" && ie.prevNode.loose, Se = z(ie.prevNode) === "next", ye = pe.type === "html" && ((ce = ie.prevNode) === null || ce === void 0 ? void 0 : ce.type) === "html" && ie.prevNode.position.end.line + 1 === pe.position.start.line, S = pe.type === "html" && ie.parentNode.type === "listItem" && ((U = ie.prevNode) === null || U === void 0 ? void 0 : U.type) === "paragraph" && ie.prevNode.position.end.line + 1 === pe.position.start.line;
            return Be || !(De || he || Se || ye || S);
          }
          __name(Z, "Z");
          function ne(pe, ie) {
            let ve = ie.prevNode && ie.prevNode.type === "list", ce = pe.type === "code" && pe.isIndented;
            return ve && ce;
          }
          __name(ne, "ne");
          function fe(pe) {
            let ie = Q(pe, ["linkReference", "imageReference"]);
            return ie && (ie.type !== "linkReference" || ie.referenceType !== "full");
          }
          __name(fe, "fe");
          function ge(pe) {
            let ie = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], ve = [" ", ...Array.isArray(ie) ? ie : [ie]];
            return new RegExp(ve.map((ce) => `\\${ce}`).join("|")).test(pe) ? `<${pe}>` : pe;
          }
          __name(ge, "ge");
          function Ce(pe, ie) {
            let ve = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            if (!pe)
              return "";
            if (ve)
              return " " + Ce(pe, ie, false);
            if (pe = pe.replace(/\\(["')])/g, "$1"), pe.includes('"') && pe.includes("'") && !pe.includes(")"))
              return `(${pe})`;
            let ce = pe.split("'").length - 1, U = pe.split('"').length - 1, de = ce > U ? '"' : U > ce || ie.singleQuote ? "'" : '"';
            return pe = pe.replace(/\\/, "\\\\"), pe = pe.replace(new RegExp(`(${de})`, "g"), "\\$1"), `${de}${pe}${de}`;
          }
          __name(Ce, "Ce");
          function _e(pe, ie, ve) {
            return pe < ie ? ie : pe > ve ? ve : pe;
          }
          __name(_e, "_e");
          function Oe(pe) {
            let ie = Number(pe.getName());
            if (ie === 0)
              return false;
            let ve = pe.getParentNode().children[ie - 1];
            return z(ve) === "next";
          }
          __name(Oe, "Oe");
          n.exports = { preprocess: E, print: L, embed: $, massageAstNode: o, hasPrettierIgnore: Oe, insertPragma: f };
        } }), Rd = ee({ "src/language-markdown/options.js"(e, n) {
          "use strict";
          re();
          var t = qt();
          n.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
        } }), $d = ee({ "src/language-markdown/parsers.js"() {
          re();
        } }), ca = ee({ "node_modules/linguist-languages/data/Markdown.json"(e, n) {
          n.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
        } }), Vd = ee({ "src/language-markdown/index.js"(e, n) {
          "use strict";
          re();
          var t = wt(), s = Md(), a = Rd(), r = $d(), u = [t(ca(), (l) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l.filenames, "README"], extensions: l.extensions.filter((c) => c !== ".mdx") })), t(ca(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s };
          n.exports = { languages: u, options: a, printers: i, parsers: r };
        } }), Wd = ee({ "src/language-html/clean.js"(e, n) {
          "use strict";
          re();
          var { isFrontMatterNode: t } = Ge(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
          function a(r, u) {
            if (r.type === "text" || r.type === "comment" || t(r) || r.type === "yaml" || r.type === "toml")
              return null;
            r.type === "attribute" && delete u.value, r.type === "docType" && delete u.value;
          }
          __name(a, "a");
          a.ignoredProperties = s, n.exports = a;
        } }), Hd = ee({ "src/language-html/constants.evaluate.js"(e, n) {
          n.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
        } }), Gd = ee({ "src/language-html/utils/is-unknown-namespace.js"(e, n) {
          "use strict";
          re();
          function t(s) {
            return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
          }
          __name(t, "t");
          n.exports = t;
        } }), Mt = ee({ "src/language-html/utils/index.js"(e, n) {
          "use strict";
          re();
          var { inferParserByLanguage: t, isFrontMatterNode: s } = Ge(), { builders: { line: a, hardline: r, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: l } } = qe(), { CSS_DISPLAY_TAGS: c, CSS_DISPLAY_DEFAULT: y, CSS_WHITE_SPACE_TAGS: h, CSS_WHITE_SPACE_DEFAULT: g } = Hd(), p = Gd(), D = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), v = /* @__PURE__ */ __name((S) => S.replace(/^[\t\n\f\r ]+/, ""), "v"), w = /* @__PURE__ */ __name((S) => S.replace(/[\t\n\f\r ]+$/, ""), "w"), T = /* @__PURE__ */ __name((S) => v(w(S)), "T"), F = /* @__PURE__ */ __name((S) => S.replace(/^[\t\f\r ]*\n/g, ""), "F"), A = /* @__PURE__ */ __name((S) => F(w(S)), "A"), B = /* @__PURE__ */ __name((S) => S.split(/[\t\n\f\r ]+/), "B"), I = /* @__PURE__ */ __name((S) => S.match(/^[\t\n\f\r ]*/)[0], "I"), P = /* @__PURE__ */ __name((S) => {
            let [, G, te, Ee] = S.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
            return { leadingWhitespace: G, trailingWhitespace: Ee, text: te };
          }, "P"), $ = /* @__PURE__ */ __name((S) => /[\t\n\f\r ]/.test(S), "$");
          function f(S, G) {
            return !!(S.type === "ieConditionalComment" && S.lastChild && !S.lastChild.isSelfClosing && !S.lastChild.endSourceSpan || S.type === "ieConditionalComment" && !S.complete || ne(S) && S.children.some((te) => te.type !== "text" && te.type !== "interpolation") || De(S, G) && !o(S) && S.type !== "interpolation");
          }
          __name(f, "f");
          function x(S) {
            return S.type === "attribute" || !S.parent || !S.prev ? false : m(S.prev);
          }
          __name(x, "x");
          function m(S) {
            return S.type === "comment" && S.value.trim() === "prettier-ignore";
          }
          __name(m, "m");
          function E(S) {
            return S.type === "text" || S.type === "comment";
          }
          __name(E, "E");
          function o(S) {
            return S.type === "element" && (S.fullName === "script" || S.fullName === "style" || S.fullName === "svg:style" || p(S) && (S.name === "script" || S.name === "style"));
          }
          __name(o, "o");
          function d(S) {
            return S.children && !o(S);
          }
          __name(d, "d");
          function C(S) {
            return o(S) || S.type === "interpolation" || _(S);
          }
          __name(C, "C");
          function _(S) {
            return _e(S).startsWith("pre");
          }
          __name(_, "_");
          function b(S, G) {
            let te = Ee();
            if (te && !S.prev && S.parent && S.parent.tagDefinition && S.parent.tagDefinition.ignoreFirstLf)
              return S.type === "interpolation";
            return te;
            function Ee() {
              return s(S) ? false : (S.type === "text" || S.type === "interpolation") && S.prev && (S.prev.type === "text" || S.prev.type === "interpolation") ? true : !S.parent || S.parent.cssDisplay === "none" ? false : ne(S.parent) ? true : !(!S.prev && (S.parent.type === "root" || ne(S) && S.parent || o(S.parent) || U(S.parent, G) || !ae(S.parent.cssDisplay)) || S.prev && !H(S.prev.cssDisplay));
            }
            __name(Ee, "Ee");
          }
          __name(b, "b");
          function N(S, G) {
            return s(S) ? false : (S.type === "text" || S.type === "interpolation") && S.next && (S.next.type === "text" || S.next.type === "interpolation") ? true : !S.parent || S.parent.cssDisplay === "none" ? false : ne(S.parent) ? true : !(!S.next && (S.parent.type === "root" || ne(S) && S.parent || o(S.parent) || U(S.parent, G) || !Ae(S.parent.cssDisplay)) || S.next && !z(S.next.cssDisplay));
          }
          __name(N, "N");
          function k(S) {
            return Z(S.cssDisplay) && !o(S);
          }
          __name(k, "k");
          function R(S) {
            return s(S) || S.next && S.sourceSpan.end && S.sourceSpan.end.line + 1 < S.next.sourceSpan.start.line;
          }
          __name(R, "R");
          function M(S) {
            return q(S) || S.type === "element" && S.children.length > 0 && (["body", "script", "style"].includes(S.name) || S.children.some((G) => Q(G))) || S.firstChild && S.firstChild === S.lastChild && S.firstChild.type !== "text" && V(S.firstChild) && (!S.lastChild.isTrailingSpaceSensitive || O(S.lastChild));
          }
          __name(M, "M");
          function q(S) {
            return S.type === "element" && S.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(S.name) || S.cssDisplay.startsWith("table") && S.cssDisplay !== "table-cell");
          }
          __name(q, "q");
          function J(S) {
            return K(S) || S.prev && L(S.prev) || Y(S);
          }
          __name(J, "J");
          function L(S) {
            return K(S) || S.type === "element" && S.fullName === "br" || Y(S);
          }
          __name(L, "L");
          function Y(S) {
            return V(S) && O(S);
          }
          __name(Y, "Y");
          function V(S) {
            return S.hasLeadingSpaces && (S.prev ? S.prev.sourceSpan.end.line < S.sourceSpan.start.line : S.parent.type === "root" || S.parent.startSourceSpan.end.line < S.sourceSpan.start.line);
          }
          __name(V, "V");
          function O(S) {
            return S.hasTrailingSpaces && (S.next ? S.next.sourceSpan.start.line > S.sourceSpan.end.line : S.parent.type === "root" || S.parent.endSourceSpan && S.parent.endSourceSpan.start.line > S.sourceSpan.end.line);
          }
          __name(O, "O");
          function K(S) {
            switch (S.type) {
              case "ieConditionalComment":
              case "comment":
              case "directive":
                return true;
              case "element":
                return ["script", "select"].includes(S.name);
            }
            return false;
          }
          __name(K, "K");
          function se(S) {
            return S.lastChild ? se(S.lastChild) : S;
          }
          __name(se, "se");
          function Q(S) {
            return S.children && S.children.some((G) => G.type !== "text");
          }
          __name(Q, "Q");
          function le(S) {
            let { type: G, lang: te } = S.attrMap;
            if (G === "module" || G === "text/javascript" || G === "text/babel" || G === "application/javascript" || te === "jsx")
              return "babel";
            if (G === "application/x-typescript" || te === "ts" || te === "tsx")
              return "typescript";
            if (G === "text/markdown")
              return "markdown";
            if (G === "text/html")
              return "html";
            if (G && (G.endsWith("json") || G.endsWith("importmap")) || G === "speculationrules")
              return "json";
            if (G === "text/x-handlebars-template")
              return "glimmer";
          }
          __name(le, "le");
          function W(S, G) {
            let { lang: te } = S.attrMap;
            if (!te || te === "postcss" || te === "css")
              return "css";
            if (te === "scss")
              return "scss";
            if (te === "less")
              return "less";
            if (te === "stylus")
              return t("stylus", G);
          }
          __name(W, "W");
          function X(S, G) {
            if (S.name === "script" && !S.attrMap.src)
              return !S.attrMap.lang && !S.attrMap.type ? "babel" : le(S);
            if (S.name === "style")
              return W(S, G);
            if (G && De(S, G))
              return le(S) || !("src" in S.attrMap) && t(S.attrMap.lang, G);
          }
          __name(X, "X");
          function oe(S) {
            return S === "block" || S === "list-item" || S.startsWith("table");
          }
          __name(oe, "oe");
          function ae(S) {
            return !oe(S) && S !== "inline-block";
          }
          __name(ae, "ae");
          function Ae(S) {
            return !oe(S) && S !== "inline-block";
          }
          __name(Ae, "Ae");
          function z(S) {
            return !oe(S);
          }
          __name(z, "z");
          function H(S) {
            return !oe(S);
          }
          __name(H, "H");
          function Z(S) {
            return !oe(S) && S !== "inline-block";
          }
          __name(Z, "Z");
          function ne(S) {
            return _e(S).startsWith("pre");
          }
          __name(ne, "ne");
          function fe(S, G) {
            let te = 0;
            for (let Ee = S.stack.length - 1; Ee >= 0; Ee--) {
              let Re = S.stack[Ee];
              Re && typeof Re == "object" && !Array.isArray(Re) && G(Re) && te++;
            }
            return te;
          }
          __name(fe, "fe");
          function ge(S, G) {
            let te = S;
            for (; te; ) {
              if (G(te))
                return true;
              te = te.parent;
            }
            return false;
          }
          __name(ge, "ge");
          function Ce(S, G) {
            if (S.prev && S.prev.type === "comment") {
              let Ee = S.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
              if (Ee)
                return Ee[1];
            }
            let te = false;
            if (S.type === "element" && S.namespace === "svg")
              if (ge(S, (Ee) => Ee.fullName === "svg:foreignObject"))
                te = true;
              else
                return S.name === "svg" ? "inline-block" : "block";
            switch (G.htmlWhitespaceSensitivity) {
              case "strict":
                return "inline";
              case "ignore":
                return "block";
              default:
                return G.parser === "vue" && S.parent && S.parent.type === "root" ? "block" : S.type === "element" && (!S.namespace || te || p(S)) && c[S.name] || y;
            }
          }
          __name(Ce, "Ce");
          function _e(S) {
            return S.type === "element" && (!S.namespace || p(S)) && h[S.name] || g;
          }
          __name(_e, "_e");
          function Oe(S) {
            let G = Number.POSITIVE_INFINITY;
            for (let te of S.split(`
`)) {
              if (te.length === 0)
                continue;
              if (!D.has(te[0]))
                return 0;
              let Ee = I(te).length;
              te.length !== Ee && Ee < G && (G = Ee);
            }
            return G === Number.POSITIVE_INFINITY ? 0 : G;
          }
          __name(Oe, "Oe");
          function pe(S) {
            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Oe(S);
            return G === 0 ? S : S.split(`
`).map((te) => te.slice(G)).join(`
`);
          }
          __name(pe, "pe");
          function ie(S, G) {
            let te = 0;
            for (let Ee = 0; Ee < S.length; Ee++)
              S[Ee] === G && te++;
            return te;
          }
          __name(ie, "ie");
          function ve(S) {
            return S.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
          }
          __name(ve, "ve");
          var ce = /* @__PURE__ */ new Set(["template", "style", "script"]);
          function U(S, G) {
            return de(S, G) && !ce.has(S.fullName);
          }
          __name(U, "U");
          function de(S, G) {
            return G.parser === "vue" && S.type === "element" && S.parent.type === "root" && S.fullName.toLowerCase() !== "html";
          }
          __name(de, "de");
          function De(S, G) {
            return de(S, G) && (U(S, G) || S.attrMap.lang && S.attrMap.lang !== "html");
          }
          __name(De, "De");
          function he(S) {
            let G = S.fullName;
            return G.charAt(0) === "#" || G === "slot-scope" || G === "v-slot" || G.startsWith("v-slot:");
          }
          __name(he, "he");
          function Be(S, G) {
            let te = S.parent;
            if (!de(te, G))
              return false;
            let Ee = te.fullName, Re = S.fullName;
            return Ee === "script" && Re === "setup" || Ee === "style" && Re === "vars";
          }
          __name(Be, "Be");
          function Se(S) {
            let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : S.value;
            return S.parent.isWhitespaceSensitive ? S.parent.isIndentationSensitive ? l(G) : l(pe(A(G)), r) : i(u(a, B(G)));
          }
          __name(Se, "Se");
          function ye(S, G) {
            return de(S, G) && S.name === "script";
          }
          __name(ye, "ye");
          n.exports = { htmlTrim: T, htmlTrimPreserveIndentation: A, hasHtmlWhitespace: $, getLeadingAndTrailingHtmlWhitespace: P, canHaveInterpolation: d, countChars: ie, countParents: fe, dedentString: pe, forceBreakChildren: q, forceBreakContent: M, forceNextEmptyLine: R, getLastDescendant: se, getNodeCssStyleDisplay: Ce, getNodeCssStyleWhiteSpace: _e, hasPrettierIgnore: x, inferScriptParser: X, isVueCustomBlock: U, isVueNonHtmlBlock: De, isVueScriptTag: ye, isVueSlotAttribute: he, isVueSfcBindingsAttribute: Be, isVueSfcBlock: de, isDanglingSpaceSensitiveNode: k, isIndentationSensitiveNode: _, isLeadingSpaceSensitiveNode: b, isPreLikeNode: ne, isScriptLikeTag: o, isTextLikeNode: E, isTrailingSpaceSensitiveNode: N, isWhitespaceSensitiveNode: C, isUnknownNamespace: p, preferHardlineAsLeadingSpaces: J, preferHardlineAsTrailingSpaces: L, shouldPreserveContent: f, unescapeQuoteEntities: ve, getTextValueParts: Se };
        } }), Ud = ee({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
          function n(i) {
            return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
          }
          __name(n, "n");
          e.isWhitespace = n;
          function t(i) {
            return e.$0 <= i && i <= e.$9;
          }
          __name(t, "t");
          e.isDigit = t;
          function s(i) {
            return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
          }
          __name(s, "s");
          e.isAsciiLetter = s;
          function a(i) {
            return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);
          }
          __name(a, "a");
          e.isAsciiHexDigit = a;
          function r(i) {
            return i === e.$LF || i === e.$CR;
          }
          __name(r, "r");
          e.isNewLine = r;
          function u(i) {
            return e.$0 <= i && i <= e.$7;
          }
          __name(u, "u");
          e.isOctalDigit = u;
        } }), Jd = ee({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = /* @__PURE__ */ __name(class {
            constructor(s, a, r) {
              this.filePath = s, this.name = a, this.members = r;
            }
            assertNoMembers() {
              if (this.members.length)
                throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
            }
          }, "n");
          e.StaticSymbol = n;
          var t = /* @__PURE__ */ __name(class {
            constructor() {
              this.cache = /* @__PURE__ */ new Map();
            }
            get(s, a, r) {
              r = r || [];
              let u = r.length ? `.${r.join(".")}` : "", i = `"${s}".${a}${u}`, l = this.cache.get(i);
              return l || (l = new n(s, a, r), this.cache.set(i, l)), l;
            }
          }, "t");
          e.StaticSymbolCache = t;
        } }), zd = ee({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = /-+([a-z0-9])/g;
          function t(o) {
            return o.replace(n, function() {
              for (var d = arguments.length, C = new Array(d), _ = 0; _ < d; _++)
                C[_] = arguments[_];
              return C[1].toUpperCase();
            });
          }
          __name(t, "t");
          e.dashCaseToCamelCase = t;
          function s(o, d) {
            return r(o, ":", d);
          }
          __name(s, "s");
          e.splitAtColon = s;
          function a(o, d) {
            return r(o, ".", d);
          }
          __name(a, "a");
          e.splitAtPeriod = a;
          function r(o, d, C) {
            let _ = o.indexOf(d);
            return _ == -1 ? C : [o.slice(0, _).trim(), o.slice(_ + 1).trim()];
          }
          __name(r, "r");
          function u(o, d, C) {
            return Array.isArray(o) ? d.visitArray(o, C) : F(o) ? d.visitStringMap(o, C) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? d.visitPrimitive(o, C) : d.visitOther(o, C);
          }
          __name(u, "u");
          e.visitValue = u;
          function i(o) {
            return o != null;
          }
          __name(i, "i");
          e.isDefined = i;
          function l(o) {
            return o === void 0 ? null : o;
          }
          __name(l, "l");
          e.noUndefined = l;
          var c = /* @__PURE__ */ __name(class {
            visitArray(o, d) {
              return o.map((C) => u(C, this, d));
            }
            visitStringMap(o, d) {
              let C = {};
              return Object.keys(o).forEach((_) => {
                C[_] = u(o[_], this, d);
              }), C;
            }
            visitPrimitive(o, d) {
              return o;
            }
            visitOther(o, d) {
              return o;
            }
          }, "c");
          e.ValueTransformer = c, e.SyncAsync = { assertSync: (o) => {
            if (P(o))
              throw new Error("Illegal state: value cannot be a promise");
            return o;
          }, then: (o, d) => P(o) ? o.then(d) : d(o), all: (o) => o.some(P) ? Promise.all(o) : o };
          function y(o) {
            throw new Error(`Internal Error: ${o}`);
          }
          __name(y, "y");
          e.error = y;
          function h(o, d) {
            let C = Error(o);
            return C[g] = true, d && (C[p] = d), C;
          }
          __name(h, "h");
          e.syntaxError = h;
          var g = "ngSyntaxError", p = "ngParseErrors";
          function D(o) {
            return o[g];
          }
          __name(D, "D");
          e.isSyntaxError = D;
          function v(o) {
            return o[p] || [];
          }
          __name(v, "v");
          e.getParseErrors = v;
          function w(o) {
            return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          __name(w, "w");
          e.escapeRegExp = w;
          var T = Object.getPrototypeOf({});
          function F(o) {
            return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === T;
          }
          __name(F, "F");
          function A(o) {
            let d = "";
            for (let C = 0; C < o.length; C++) {
              let _ = o.charCodeAt(C);
              if (_ >= 55296 && _ <= 56319 && o.length > C + 1) {
                let b = o.charCodeAt(C + 1);
                b >= 56320 && b <= 57343 && (C++, _ = (_ - 55296 << 10) + b - 56320 + 65536);
              }
              _ <= 127 ? d += String.fromCharCode(_) : _ <= 2047 ? d += String.fromCharCode(_ >> 6 & 31 | 192, _ & 63 | 128) : _ <= 65535 ? d += String.fromCharCode(_ >> 12 | 224, _ >> 6 & 63 | 128, _ & 63 | 128) : _ <= 2097151 && (d += String.fromCharCode(_ >> 18 & 7 | 240, _ >> 12 & 63 | 128, _ >> 6 & 63 | 128, _ & 63 | 128));
            }
            return d;
          }
          __name(A, "A");
          e.utf8Encode = A;
          function B(o) {
            if (typeof o == "string")
              return o;
            if (o instanceof Array)
              return "[" + o.map(B).join(", ") + "]";
            if (o == null)
              return "" + o;
            if (o.overriddenName)
              return `${o.overriddenName}`;
            if (o.name)
              return `${o.name}`;
            if (!o.toString)
              return "object";
            let d = o.toString();
            if (d == null)
              return "" + d;
            let C = d.indexOf(`
`);
            return C === -1 ? d : d.substring(0, C);
          }
          __name(B, "B");
          e.stringify = B;
          function I(o) {
            return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
          }
          __name(I, "I");
          e.resolveForwardRef = I;
          function P(o) {
            return !!o && typeof o.then == "function";
          }
          __name(P, "P");
          e.isPromise = P;
          var $ = /* @__PURE__ */ __name(class {
            constructor(o) {
              this.full = o;
              let d = o.split(".");
              this.major = d[0], this.minor = d[1], this.patch = d.slice(2).join(".");
            }
          }, "$");
          e.Version = $;
          var f = typeof window < "u" && window, x = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m = typeof globalThis < "u" && globalThis, E = m || f || x;
          e.global = E;
        } }), Xd = ee({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Jd(), t = zd(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function a(C) {
            return C.replace(/\W/g, "_");
          }
          __name(a, "a");
          e.sanitizeIdentifier = a;
          var r = 0;
          function u(C) {
            if (!C || !C.reference)
              return null;
            let _ = C.reference;
            if (_ instanceof n.StaticSymbol)
              return _.name;
            if (_.__anonymousType)
              return _.__anonymousType;
            let b = t.stringify(_);
            return b.indexOf("(") >= 0 ? (b = `anonymous_${r++}`, _.__anonymousType = b) : b = a(b), b;
          }
          __name(u, "u");
          e.identifierName = u;
          function i(C) {
            let _ = C.reference;
            return _ instanceof n.StaticSymbol ? _.filePath : `./${t.stringify(_)}`;
          }
          __name(i, "i");
          e.identifierModuleUrl = i;
          function l(C, _) {
            return `View_${u({ reference: C })}_${_}`;
          }
          __name(l, "l");
          e.viewClassName = l;
          function c(C) {
            return `RenderType_${u({ reference: C })}`;
          }
          __name(c, "c");
          e.rendererTypeName = c;
          function y(C) {
            return `HostView_${u({ reference: C })}`;
          }
          __name(y, "y");
          e.hostViewClassName = y;
          function h(C) {
            return `${u({ reference: C })}NgFactory`;
          }
          __name(h, "h");
          e.componentFactoryName = h;
          var g;
          (function(C) {
            C[C.Pipe = 0] = "Pipe", C[C.Directive = 1] = "Directive", C[C.NgModule = 2] = "NgModule", C[C.Injectable = 3] = "Injectable";
          })(g = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
          function p(C) {
            return C.value != null ? a(C.value) : u(C.identifier);
          }
          __name(p, "p");
          e.tokenName = p;
          function D(C) {
            return C.identifier != null ? C.identifier.reference : C.value;
          }
          __name(D, "D");
          e.tokenReference = D;
          var v = /* @__PURE__ */ __name(class {
            constructor() {
              let { moduleUrl: C, styles: _, styleUrls: b } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.moduleUrl = C || null, this.styles = P(_), this.styleUrls = P(b);
            }
          }, "v");
          e.CompileStylesheetMetadata = v;
          var w = /* @__PURE__ */ __name(class {
            constructor(C) {
              let { encapsulation: _, template: b, templateUrl: N, htmlAst: k, styles: R, styleUrls: M, externalStylesheets: q, animations: J, ngContentSelectors: L, interpolation: Y, isInline: V, preserveWhitespaces: O } = C;
              if (this.encapsulation = _, this.template = b, this.templateUrl = N, this.htmlAst = k, this.styles = P(R), this.styleUrls = P(M), this.externalStylesheets = P(q), this.animations = J ? f(J) : [], this.ngContentSelectors = L || [], Y && Y.length != 2)
                throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = Y, this.isInline = V, this.preserveWhitespaces = O;
            }
            toSummary() {
              return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
            }
          }, "w");
          e.CompileTemplateMetadata = w;
          var T = /* @__PURE__ */ __name(class {
            static create(C) {
              let { isHost: _, type: b, isComponent: N, selector: k, exportAs: R, changeDetection: M, inputs: q, outputs: J, host: L, providers: Y, viewProviders: V, queries: O, guards: K, viewQueries: se, entryComponents: Q, template: le, componentViewType: W, rendererType: X, componentFactory: oe } = C, ae = {}, Ae = {}, z = {};
              L != null && Object.keys(L).forEach((ne) => {
                let fe = L[ne], ge = ne.match(s);
                ge === null ? z[ne] = fe : ge[1] != null ? Ae[ge[1]] = fe : ge[2] != null && (ae[ge[2]] = fe);
              });
              let H = {};
              q != null && q.forEach((ne) => {
                let fe = t.splitAtColon(ne, [ne, ne]);
                H[fe[0]] = fe[1];
              });
              let Z = {};
              return J != null && J.forEach((ne) => {
                let fe = t.splitAtColon(ne, [ne, ne]);
                Z[fe[0]] = fe[1];
              }), new T({ isHost: _, type: b, isComponent: !!N, selector: k, exportAs: R, changeDetection: M, inputs: H, outputs: Z, hostListeners: ae, hostProperties: Ae, hostAttributes: z, providers: Y, viewProviders: V, queries: O, guards: K, viewQueries: se, entryComponents: Q, template: le, componentViewType: W, rendererType: X, componentFactory: oe });
            }
            constructor(C) {
              let { isHost: _, type: b, isComponent: N, selector: k, exportAs: R, changeDetection: M, inputs: q, outputs: J, hostListeners: L, hostProperties: Y, hostAttributes: V, providers: O, viewProviders: K, queries: se, guards: Q, viewQueries: le, entryComponents: W, template: X, componentViewType: oe, rendererType: ae, componentFactory: Ae } = C;
              this.isHost = !!_, this.type = b, this.isComponent = N, this.selector = k, this.exportAs = R, this.changeDetection = M, this.inputs = q, this.outputs = J, this.hostListeners = L, this.hostProperties = Y, this.hostAttributes = V, this.providers = P(O), this.viewProviders = P(K), this.queries = P(se), this.guards = Q, this.viewQueries = P(le), this.entryComponents = P(W), this.template = X, this.componentViewType = oe, this.rendererType = ae, this.componentFactory = Ae;
            }
            toSummary() {
              return { summaryKind: g.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
            }
          }, "T");
          e.CompileDirectiveMetadata = T;
          var F = /* @__PURE__ */ __name(class {
            constructor(C) {
              let { type: _, name: b, pure: N } = C;
              this.type = _, this.name = b, this.pure = !!N;
            }
            toSummary() {
              return { summaryKind: g.Pipe, type: this.type, name: this.name, pure: this.pure };
            }
          }, "F");
          e.CompilePipeMetadata = F;
          var A = /* @__PURE__ */ __name(class {
          }, "A");
          e.CompileShallowModuleMetadata = A;
          var B = /* @__PURE__ */ __name(class {
            constructor(C) {
              let { type: _, providers: b, declaredDirectives: N, exportedDirectives: k, declaredPipes: R, exportedPipes: M, entryComponents: q, bootstrapComponents: J, importedModules: L, exportedModules: Y, schemas: V, transitiveModule: O, id: K } = C;
              this.type = _ || null, this.declaredDirectives = P(N), this.exportedDirectives = P(k), this.declaredPipes = P(R), this.exportedPipes = P(M), this.providers = P(b), this.entryComponents = P(q), this.bootstrapComponents = P(J), this.importedModules = P(L), this.exportedModules = P(Y), this.schemas = P(V), this.id = K || null, this.transitiveModule = O || null;
            }
            toSummary() {
              let C = this.transitiveModule;
              return { summaryKind: g.NgModule, type: this.type, entryComponents: C.entryComponents, providers: C.providers, modules: C.modules, exportedDirectives: C.exportedDirectives, exportedPipes: C.exportedPipes };
            }
          }, "B");
          e.CompileNgModuleMetadata = B;
          var I = /* @__PURE__ */ __name(class {
            constructor() {
              this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
            }
            addProvider(C, _) {
              this.providers.push({ provider: C, module: _ });
            }
            addDirective(C) {
              this.directivesSet.has(C.reference) || (this.directivesSet.add(C.reference), this.directives.push(C));
            }
            addExportedDirective(C) {
              this.exportedDirectivesSet.has(C.reference) || (this.exportedDirectivesSet.add(C.reference), this.exportedDirectives.push(C));
            }
            addPipe(C) {
              this.pipesSet.has(C.reference) || (this.pipesSet.add(C.reference), this.pipes.push(C));
            }
            addExportedPipe(C) {
              this.exportedPipesSet.has(C.reference) || (this.exportedPipesSet.add(C.reference), this.exportedPipes.push(C));
            }
            addModule(C) {
              this.modulesSet.has(C.reference) || (this.modulesSet.add(C.reference), this.modules.push(C));
            }
            addEntryComponent(C) {
              this.entryComponentsSet.has(C.componentType) || (this.entryComponentsSet.add(C.componentType), this.entryComponents.push(C));
            }
          }, "I");
          e.TransitiveCompileNgModuleMetadata = I;
          function P(C) {
            return C || [];
          }
          __name(P, "P");
          var $ = /* @__PURE__ */ __name(class {
            constructor(C, _) {
              let { useClass: b, useValue: N, useExisting: k, useFactory: R, deps: M, multi: q } = _;
              this.token = C, this.useClass = b || null, this.useValue = N, this.useExisting = k, this.useFactory = R || null, this.dependencies = M || null, this.multi = !!q;
            }
          }, "$");
          e.ProviderMeta = $;
          function f(C) {
            return C.reduce((_, b) => {
              let N = Array.isArray(b) ? f(b) : b;
              return _.concat(N);
            }, []);
          }
          __name(f, "f");
          e.flatten = f;
          function x(C) {
            return C.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          __name(x, "x");
          function m(C, _, b) {
            let N;
            return b.isInline ? _.type.reference instanceof n.StaticSymbol ? N = `${_.type.reference.filePath}.${_.type.reference.name}.html` : N = `${u(C)}/${u(_.type)}.html` : N = b.templateUrl, _.type.reference instanceof n.StaticSymbol ? N : x(N);
          }
          __name(m, "m");
          e.templateSourceUrl = m;
          function E(C, _) {
            let b = C.moduleUrl.split(/\/\\/g), N = b[b.length - 1];
            return x(`css/${_}${N}.ngstyle.js`);
          }
          __name(E, "E");
          e.sharedStylesheetJitUrl = E;
          function o(C) {
            return x(`${u(C.type)}/module.ngfactory.js`);
          }
          __name(o, "o");
          e.ngModuleJitUrl = o;
          function d(C, _) {
            return x(`${u(C)}/${u(_.type)}.ngfactory.js`);
          }
          __name(d, "d");
          e.templateJitUrl = d;
        } }), Kd = ee({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Ud(), t = Xd(), s = /* @__PURE__ */ __name(class {
            constructor(y, h, g, p) {
              this.file = y, this.offset = h, this.line = g, this.col = p;
            }
            toString() {
              return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
            }
            moveBy(y) {
              let h = this.file.content, g = h.length, p = this.offset, D = this.line, v = this.col;
              for (; p > 0 && y < 0; )
                if (p--, y++, h.charCodeAt(p) == n.$LF) {
                  D--;
                  let T = h.substr(0, p - 1).lastIndexOf(String.fromCharCode(n.$LF));
                  v = T > 0 ? p - T : p;
                } else
                  v--;
              for (; p < g && y > 0; ) {
                let w = h.charCodeAt(p);
                p++, y--, w == n.$LF ? (D++, v = 0) : v++;
              }
              return new s(this.file, p, D, v);
            }
            getContext(y, h) {
              let g = this.file.content, p = this.offset;
              if (p != null) {
                p > g.length - 1 && (p = g.length - 1);
                let D = p, v = 0, w = 0;
                for (; v < y && p > 0 && (p--, v++, !(g[p] == `
` && ++w == h)); )
                  ;
                for (v = 0, w = 0; v < y && D < g.length - 1 && (D++, v++, !(g[D] == `
` && ++w == h)); )
                  ;
                return { before: g.substring(p, this.offset), after: g.substring(this.offset, D + 1) };
              }
              return null;
            }
          }, "s");
          e.ParseLocation = s;
          var a = /* @__PURE__ */ __name(class {
            constructor(y, h) {
              this.content = y, this.url = h;
            }
          }, "a");
          e.ParseSourceFile = a;
          var r = /* @__PURE__ */ __name(class {
            constructor(y, h) {
              let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = y, this.end = h, this.details = g;
            }
            toString() {
              return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
          }, "r");
          e.ParseSourceSpan = r, e.EMPTY_PARSE_LOCATION = new s(new a("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new r(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
          var u;
          (function(y) {
            y[y.WARNING = 0] = "WARNING", y[y.ERROR = 1] = "ERROR";
          })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
          var i = /* @__PURE__ */ __name(class {
            constructor(y, h) {
              let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
              this.span = y, this.msg = h, this.level = g;
            }
            contextualMessage() {
              let y = this.span.start.getContext(100, 3);
              return y ? `${this.msg} ("${y.before}[${u[this.level]} ->]${y.after}")` : this.msg;
            }
            toString() {
              let y = this.span.details ? `, ${this.span.details}` : "";
              return `${this.contextualMessage()}: ${this.span.start}${y}`;
            }
          }, "i");
          e.ParseError = i;
          function l(y, h) {
            let g = t.identifierModuleUrl(h), p = g != null ? `in ${y} ${t.identifierName(h)} in ${g}` : `in ${y} ${t.identifierName(h)}`, D = new a("", p);
            return new r(new s(D, -1, -1, -1), new s(D, -1, -1, -1));
          }
          __name(l, "l");
          e.typeSourceSpan = l;
          function c(y, h, g) {
            let p = `in ${y} ${h} in ${g}`, D = new a("", p);
            return new r(new s(D, -1, -1, -1), new s(D, -1, -1, -1));
          }
          __name(c, "c");
          e.r3JitTypeSourceSpan = c;
        } }), Yd = ee({ "src/language-html/print-preprocess.js"(e, n) {
          "use strict";
          re();
          var { ParseSourceSpan: t } = Kd(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: a, hasHtmlWhitespace: r, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: l, isIndentationSensitiveNode: c, isLeadingSpaceSensitiveNode: y, isTrailingSpaceSensitiveNode: h, isWhitespaceSensitiveNode: g, isVueScriptTag: p } = Mt(), D = [w, T, A, I, P, x, $, f, m, B, E];
          function v(o, d) {
            for (let C of D)
              C(o, d);
            return o;
          }
          __name(v, "v");
          function w(o) {
            o.walk((d) => {
              if (d.type === "element" && d.tagDefinition.ignoreFirstLf && d.children.length > 0 && d.children[0].type === "text" && d.children[0].value[0] === `
`) {
                let C = d.children[0];
                C.value.length === 1 ? d.removeChild(C) : C.value = C.value.slice(1);
              }
            });
          }
          __name(w, "w");
          function T(o) {
            let d = /* @__PURE__ */ __name((C) => C.type === "element" && C.prev && C.prev.type === "ieConditionalStartComment" && C.prev.sourceSpan.end.offset === C.startSourceSpan.start.offset && C.firstChild && C.firstChild.type === "ieConditionalEndComment" && C.firstChild.sourceSpan.start.offset === C.startSourceSpan.end.offset, "d");
            o.walk((C) => {
              if (C.children)
                for (let _ = 0; _ < C.children.length; _++) {
                  let b = C.children[_];
                  if (!d(b))
                    continue;
                  let N = b.prev, k = b.firstChild;
                  C.removeChild(N), _--;
                  let R = new t(N.sourceSpan.start, k.sourceSpan.end), M = new t(R.start, b.sourceSpan.end);
                  b.condition = N.condition, b.sourceSpan = M, b.startSourceSpan = R, b.removeChild(k);
                }
            });
          }
          __name(T, "T");
          function F(o, d, C) {
            o.walk((_) => {
              if (_.children)
                for (let b = 0; b < _.children.length; b++) {
                  let N = _.children[b];
                  if (N.type !== "text" && !d(N))
                    continue;
                  N.type !== "text" && (N.type = "text", N.value = C(N));
                  let k = N.prev;
                  !k || k.type !== "text" || (k.value += N.value, k.sourceSpan = new t(k.sourceSpan.start, N.sourceSpan.end), _.removeChild(N), b--);
                }
            });
          }
          __name(F, "F");
          function A(o) {
            return F(o, (d) => d.type === "cdata", (d) => `<![CDATA[${d.value}]]>`);
          }
          __name(A, "A");
          function B(o) {
            let d = /* @__PURE__ */ __name((C) => C.type === "element" && C.attrs.length === 0 && C.children.length === 1 && C.firstChild.type === "text" && !r(C.children[0].value) && !C.firstChild.hasLeadingSpaces && !C.firstChild.hasTrailingSpaces && C.isLeadingSpaceSensitive && !C.hasLeadingSpaces && C.isTrailingSpaceSensitive && !C.hasTrailingSpaces && C.prev && C.prev.type === "text" && C.next && C.next.type === "text", "d");
            o.walk((C) => {
              if (C.children)
                for (let _ = 0; _ < C.children.length; _++) {
                  let b = C.children[_];
                  if (!d(b))
                    continue;
                  let N = b.prev, k = b.next;
                  N.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, N.sourceSpan = new t(N.sourceSpan.start, k.sourceSpan.end), N.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, N.hasTrailingSpaces = k.hasTrailingSpaces, C.removeChild(b), _--, C.removeChild(k);
                }
            });
          }
          __name(B, "B");
          function I(o, d) {
            if (d.parser === "html")
              return;
            let C = /{{(.+?)}}/s;
            o.walk((_) => {
              if (!!u(_))
                for (let b of _.children) {
                  if (b.type !== "text")
                    continue;
                  let N = b.sourceSpan.start, k = null, R = b.value.split(C);
                  for (let M = 0; M < R.length; M++, N = k) {
                    let q = R[M];
                    if (M % 2 === 0) {
                      k = N.moveBy(q.length), q.length > 0 && _.insertChildBefore(b, { type: "text", value: q, sourceSpan: new t(N, k) });
                      continue;
                    }
                    k = N.moveBy(q.length + 4), _.insertChildBefore(b, { type: "interpolation", sourceSpan: new t(N, k), children: q.length === 0 ? [] : [{ type: "text", value: q, sourceSpan: new t(N.moveBy(2), k.moveBy(-2)) }] });
                  }
                  _.removeChild(b);
                }
            });
          }
          __name(I, "I");
          function P(o) {
            o.walk((d) => {
              if (!d.children)
                return;
              if (d.children.length === 0 || d.children.length === 1 && d.children[0].type === "text" && s(d.children[0].value).length === 0) {
                d.hasDanglingSpaces = d.children.length > 0, d.children = [];
                return;
              }
              let C = g(d), _ = c(d);
              if (!C)
                for (let b = 0; b < d.children.length; b++) {
                  let N = d.children[b];
                  if (N.type !== "text")
                    continue;
                  let { leadingWhitespace: k, text: R, trailingWhitespace: M } = a(N.value), q = N.prev, J = N.next;
                  R ? (N.value = R, N.sourceSpan = new t(N.sourceSpan.start.moveBy(k.length), N.sourceSpan.end.moveBy(-M.length)), k && (q && (q.hasTrailingSpaces = true), N.hasLeadingSpaces = true), M && (N.hasTrailingSpaces = true, J && (J.hasLeadingSpaces = true))) : (d.removeChild(N), b--, (k || M) && (q && (q.hasTrailingSpaces = true), J && (J.hasLeadingSpaces = true)));
                }
              d.isWhitespaceSensitive = C, d.isIndentationSensitive = _;
            });
          }
          __name(P, "P");
          function $(o) {
            o.walk((d) => {
              d.isSelfClosing = !d.children || d.type === "element" && (d.tagDefinition.isVoid || d.startSourceSpan === d.endSourceSpan);
            });
          }
          __name($, "$");
          function f(o, d) {
            o.walk((C) => {
              C.type === "element" && (C.hasHtmComponentClosingTag = C.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(d.originalText.slice(C.endSourceSpan.start.offset, C.endSourceSpan.end.offset)));
            });
          }
          __name(f, "f");
          function x(o, d) {
            o.walk((C) => {
              C.cssDisplay = i(C, d);
            });
          }
          __name(x, "x");
          function m(o, d) {
            o.walk((C) => {
              let { children: _ } = C;
              if (!!_) {
                if (_.length === 0) {
                  C.isDanglingSpaceSensitive = l(C);
                  return;
                }
                for (let b of _)
                  b.isLeadingSpaceSensitive = y(b, d), b.isTrailingSpaceSensitive = h(b, d);
                for (let b = 0; b < _.length; b++) {
                  let N = _[b];
                  N.isLeadingSpaceSensitive = (b === 0 || N.prev.isTrailingSpaceSensitive) && N.isLeadingSpaceSensitive, N.isTrailingSpaceSensitive = (b === _.length - 1 || N.next.isLeadingSpaceSensitive) && N.isTrailingSpaceSensitive;
                }
              }
            });
          }
          __name(m, "m");
          function E(o, d) {
            if (d.parser === "vue") {
              let C = o.children.find((b) => p(b, d));
              if (!C)
                return;
              let { lang: _ } = C.attrMap;
              (_ === "ts" || _ === "typescript") && (d.__should_parse_vue_template_with_ts = true);
            }
          }
          __name(E, "E");
          n.exports = v;
        } }), Qd = ee({ "src/language-html/pragma.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a);
          }
          __name(t, "t");
          function s(a) {
            return `<!-- @format -->

` + a.replace(/^\s*\n/, "");
          }
          __name(s, "s");
          n.exports = { hasPragma: t, insertPragma: s };
        } }), Qn = ee({ "src/language-html/loc.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return a.sourceSpan.start.offset;
          }
          __name(t, "t");
          function s(a) {
            return a.sourceSpan.end.offset;
          }
          __name(s, "s");
          n.exports = { locStart: t, locEnd: s };
        } }), rr = ee({ "src/language-html/print/tag.js"(e, n) {
          "use strict";
          re();
          var t = Yt(), { isNonEmptyArray: s } = Ge(), { builders: { indent: a, join: r, line: u, softline: i, hardline: l }, utils: { replaceTextEndOfLine: c } } = qe(), { locStart: y, locEnd: h } = Qn(), { isTextLikeNode: g, getLastDescendant: p, isPreLikeNode: D, hasPrettierIgnore: v, shouldPreserveContent: w, isVueSfcBlock: T } = Mt();
          function F(L, Y) {
            return [L.isSelfClosing ? "" : A(L, Y), B(L, Y)];
          }
          __name(F, "F");
          function A(L, Y) {
            return L.lastChild && o(L.lastChild) ? "" : [I(L, Y), $(L, Y)];
          }
          __name(A, "A");
          function B(L, Y) {
            return (L.next ? m(L.next) : E(L.parent)) ? "" : [f(L, Y), P(L, Y)];
          }
          __name(B, "B");
          function I(L, Y) {
            return E(L) ? f(L.lastChild, Y) : "";
          }
          __name(I, "I");
          function P(L, Y) {
            return o(L) ? $(L.parent, Y) : d(L) ? q(L.next) : "";
          }
          __name(P, "P");
          function $(L, Y) {
            if (t(!L.isSelfClosing), x(L, Y))
              return "";
            switch (L.type) {
              case "ieConditionalComment":
                return "<!";
              case "element":
                if (L.hasHtmComponentClosingTag)
                  return "<//";
              default:
                return `</${L.rawName}`;
            }
          }
          __name($, "$");
          function f(L, Y) {
            if (x(L, Y))
              return "";
            switch (L.type) {
              case "ieConditionalComment":
              case "ieConditionalEndComment":
                return "[endif]-->";
              case "ieConditionalStartComment":
                return "]><!-->";
              case "interpolation":
                return "}}";
              case "element":
                if (L.isSelfClosing)
                  return "/>";
              default:
                return ">";
            }
          }
          __name(f, "f");
          function x(L, Y) {
            return !L.isSelfClosing && !L.endSourceSpan && (v(L) || w(L.parent, Y));
          }
          __name(x, "x");
          function m(L) {
            return L.prev && L.prev.type !== "docType" && !g(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
          }
          __name(m, "m");
          function E(L) {
            return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g(p(L.lastChild)) && !D(L);
          }
          __name(E, "E");
          function o(L) {
            return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g(p(L));
          }
          __name(o, "o");
          function d(L) {
            return L.next && !g(L.next) && g(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;
          }
          __name(d, "d");
          function C(L) {
            let Y = L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
            return Y ? Y[1] ? Y[1].split(/\s+/) : true : false;
          }
          __name(C, "C");
          function _(L) {
            return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
          }
          __name(_, "_");
          function b(L, Y, V) {
            let O = L.getValue();
            if (!s(O.attrs))
              return O.isSelfClosing ? " " : "";
            let K = O.prev && O.prev.type === "comment" && C(O.prev.value), se = typeof K == "boolean" ? () => K : Array.isArray(K) ? (ae) => K.includes(ae.rawName) : () => false, Q = L.map((ae) => {
              let Ae = ae.getValue();
              return se(Ae) ? c(Y.originalText.slice(y(Ae), h(Ae))) : V();
            }, "attrs"), le = O.type === "element" && O.fullName === "script" && O.attrs.length === 1 && O.attrs[0].fullName === "src" && O.children.length === 0, X = Y.singleAttributePerLine && O.attrs.length > 1 && !T(O, Y) ? l : u, oe = [a([le ? " " : u, r(X, Q)])];
            return O.firstChild && _(O.firstChild) || O.isSelfClosing && E(O.parent) || le ? oe.push(O.isSelfClosing ? " " : "") : oe.push(Y.bracketSameLine ? O.isSelfClosing ? " " : "" : O.isSelfClosing ? u : i), oe;
          }
          __name(b, "b");
          function N(L) {
            return L.firstChild && _(L.firstChild) ? "" : J(L);
          }
          __name(N, "N");
          function k(L, Y, V) {
            let O = L.getValue();
            return [R(O, Y), b(L, Y, V), O.isSelfClosing ? "" : N(O)];
          }
          __name(k, "k");
          function R(L, Y) {
            return L.prev && d(L.prev) ? "" : [M(L, Y), q(L)];
          }
          __name(R, "R");
          function M(L, Y) {
            return _(L) ? J(L.parent) : m(L) ? f(L.prev, Y) : "";
          }
          __name(M, "M");
          function q(L) {
            switch (L.type) {
              case "ieConditionalComment":
              case "ieConditionalStartComment":
                return `<!--[if ${L.condition}`;
              case "ieConditionalEndComment":
                return "<!--<!";
              case "interpolation":
                return "{{";
              case "docType":
                return "<!DOCTYPE";
              case "element":
                if (L.condition)
                  return `<!--[if ${L.condition}]><!--><${L.rawName}`;
              default:
                return `<${L.rawName}`;
            }
          }
          __name(q, "q");
          function J(L) {
            switch (t(!L.isSelfClosing), L.type) {
              case "ieConditionalComment":
                return "]>";
              case "element":
                if (L.condition)
                  return "><!--<![endif]-->";
              default:
                return ">";
            }
          }
          __name(J, "J");
          n.exports = { printClosingTag: F, printClosingTagStart: A, printClosingTagStartMarker: $, printClosingTagEndMarker: f, printClosingTagSuffix: P, printClosingTagEnd: B, needsToBorrowLastChildClosingTagEndMarker: E, needsToBorrowParentClosingTagStartMarker: o, needsToBorrowPrevClosingTagEndMarker: m, printOpeningTag: k, printOpeningTagStart: R, printOpeningTagPrefix: M, printOpeningTagStartMarker: q, printOpeningTagEndMarker: J, needsToBorrowNextOpeningTagStartMarker: d, needsToBorrowParentOpeningTagEndMarker: _ };
        } }), Zd = ee({ "node_modules/parse-srcset/src/parse-srcset.js"(e, n) {
          re(), function(t, s) {
            typeof define == "function" && define.amd ? define([], s) : typeof n == "object" && n.exports ? n.exports = s() : t.parseSrcset = s();
          }(e, function() {
            return function(t, s) {
              var a = s && s.logger || console;
              function r($) {
                return $ === " " || $ === "	" || $ === `
` || $ === "\f" || $ === "\r";
              }
              __name(r, "r");
              function u($) {
                var f, x = $.exec(t.substring(A));
                if (x)
                  return f = x[0], A += f.length, f;
              }
              __name(u, "u");
              for (var i = t.length, l = /^[ \t\n\r\u000c]+/, c = /^[, \t\n\r\u000c]+/, y = /^[^ \t\n\r\u000c]+/, h = /[,]+$/, g = /^\d+$/, p = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, D, v, w, T, F, A = 0, B = []; ; ) {
                if (u(c), A >= i)
                  return B;
                D = u(y), v = [], D.slice(-1) === "," ? (D = D.replace(h, ""), P()) : I();
              }
              function I() {
                for (u(l), w = "", T = "in descriptor"; ; ) {
                  if (F = t.charAt(A), T === "in descriptor")
                    if (r(F))
                      w && (v.push(w), w = "", T = "after descriptor");
                    else if (F === ",") {
                      A += 1, w && v.push(w), P();
                      return;
                    } else if (F === "(")
                      w = w + F, T = "in parens";
                    else if (F === "") {
                      w && v.push(w), P();
                      return;
                    } else
                      w = w + F;
                  else if (T === "in parens")
                    if (F === ")")
                      w = w + F, T = "in descriptor";
                    else if (F === "") {
                      v.push(w), P();
                      return;
                    } else
                      w = w + F;
                  else if (T === "after descriptor" && !r(F))
                    if (F === "") {
                      P();
                      return;
                    } else
                      T = "in descriptor", A -= 1;
                  A += 1;
                }
              }
              __name(I, "I");
              function P() {
                var $ = false, f, x, m, E, o = {}, d, C, _, b, N;
                for (E = 0; E < v.length; E++)
                  d = v[E], C = d[d.length - 1], _ = d.substring(0, d.length - 1), b = parseInt(_, 10), N = parseFloat(_), g.test(_) && C === "w" ? ((f || x) && ($ = true), b === 0 ? $ = true : f = b) : p.test(_) && C === "x" ? ((f || x || m) && ($ = true), N < 0 ? $ = true : x = N) : g.test(_) && C === "h" ? ((m || x) && ($ = true), b === 0 ? $ = true : m = b) : $ = true;
                $ ? a && a.error && a.error("Invalid srcset descriptor found in '" + t + "' at '" + d + "'.") : (o.url = D, f && (o.w = f), x && (o.d = x), m && (o.h = m), B.push(o));
              }
              __name(P, "P");
            };
          });
        } }), eg = ee({ "src/language-html/syntax-attribute.js"(e, n) {
          "use strict";
          re();
          var t = Zd(), { builders: { ifBreak: s, join: a, line: r } } = qe();
          function u(l) {
            let c = t(l, { logger: { error(I) {
              throw new Error(I);
            } } }), y = c.some((I) => {
              let { w: P } = I;
              return P;
            }), h = c.some((I) => {
              let { h: P } = I;
              return P;
            }), g = c.some((I) => {
              let { d: P } = I;
              return P;
            });
            if (y + h + g > 1)
              throw new Error("Mixed descriptor in srcset is not supported");
            let p = y ? "w" : h ? "h" : "d", D = y ? "w" : h ? "h" : "x", v = /* @__PURE__ */ __name((I) => Math.max(...I), "v"), w = c.map((I) => I.url), T = v(w.map((I) => I.length)), F = c.map((I) => I[p]).map((I) => I ? I.toString() : ""), A = F.map((I) => {
              let P = I.indexOf(".");
              return P === -1 ? I.length : P;
            }), B = v(A);
            return a([",", r], w.map((I, P) => {
              let $ = [I], f = F[P];
              if (f) {
                let x = T - I.length + 1, m = B - A[P], E = " ".repeat(x + m);
                $.push(s(E, " "), f + D);
              }
              return $;
            }));
          }
          __name(u, "u");
          function i(l) {
            return l.trim().split(/\s+/).join(" ");
          }
          __name(i, "i");
          n.exports = { printImgSrcset: u, printClassNames: i };
        } }), tg = ee({ "src/language-html/syntax-vue.js"(e, n) {
          "use strict";
          re();
          var { builders: { group: t } } = qe();
          function s(i, l) {
            let { left: c, operator: y, right: h } = a(i);
            return [t(l(`function _(${c}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", y, " ", l(h, { parser: "__js_expression" }, { stripTrailingHardline: true })];
          }
          __name(s, "s");
          function a(i) {
            let l = /(.*?)\s+(in|of)\s+(.*)/s, c = /,([^,\]}]*)(?:,([^,\]}]*))?$/, y = /^\(|\)$/g, h = i.match(l);
            if (!h)
              return;
            let g = {};
            if (g.for = h[3].trim(), !g.for)
              return;
            let p = h[1].trim().replace(y, ""), D = p.match(c);
            D ? (g.alias = p.replace(c, ""), g.iterator1 = D[1].trim(), D[2] && (g.iterator2 = D[2].trim())) : g.alias = p;
            let v = [g.alias, g.iterator1, g.iterator2];
            if (!v.some((w, T) => !w && (T === 0 || v.slice(T + 1).some(Boolean))))
              return { left: v.filter(Boolean).join(","), operator: h[2], right: g.for };
          }
          __name(a, "a");
          function r(i, l) {
            return l(`function _(${i}) {}`, { parser: "babel", __isVueBindings: true });
          }
          __name(r, "r");
          function u(i) {
            let l = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, c = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, y = i.trim();
            return l.test(y) || c.test(y);
          }
          __name(u, "u");
          n.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: r };
        } }), fo = ee({ "src/language-html/get-node-content.js"(e, n) {
          "use strict";
          re();
          var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: a, printClosingTagEndMarker: r, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = rr();
          function l(c, y) {
            let h = c.startSourceSpan.end.offset;
            c.firstChild && u(c.firstChild) && (h -= i(c).length);
            let g = c.endSourceSpan.start.offset;
            return c.lastChild && t(c.lastChild) ? g += s(c, y).length : a(c) && (g -= r(c.lastChild, y).length), y.originalText.slice(h, g);
          }
          __name(l, "l");
          n.exports = l;
        } }), rg = ee({ "src/language-html/embed.js"(e, n) {
          "use strict";
          re();
          var { builders: { breakParent: t, group: s, hardline: a, indent: r, line: u, fill: i, softline: l }, utils: { mapDoc: c, replaceTextEndOfLine: y } } = qe(), h = Kn(), { printClosingTag: g, printClosingTagSuffix: p, needsToBorrowPrevClosingTagEndMarker: D, printOpeningTagPrefix: v, printOpeningTag: w } = rr(), { printImgSrcset: T, printClassNames: F } = eg(), { printVueFor: A, printVueBindings: B, isVueEventBindingExpression: I } = tg(), { isScriptLikeTag: P, isVueNonHtmlBlock: $, inferScriptParser: f, htmlTrimPreserveIndentation: x, dedentString: m, unescapeQuoteEntities: E, isVueSlotAttribute: o, isVueSfcBindingsAttribute: d, getTextValueParts: C } = Mt(), _ = fo();
          function b(k, R, M) {
            let q = /* @__PURE__ */ __name((Q) => new RegExp(Q.join("|")).test(k.fullName), "q"), J = /* @__PURE__ */ __name(() => E(k.value), "J"), L = false, Y = /* @__PURE__ */ __name((Q, le) => {
              let W = Q.type === "NGRoot" ? Q.node.type === "NGMicrosyntax" && Q.node.body.length === 1 && Q.node.body[0].type === "NGMicrosyntaxExpression" ? Q.node.body[0].expression : Q.node : Q.type === "JsExpressionRoot" ? Q.node : Q;
              W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || le.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (L = true);
            }, "Y"), V = /* @__PURE__ */ __name((Q) => s(Q), "V"), O = /* @__PURE__ */ __name(function(Q) {
              let le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              return s([r([l, Q]), le ? l : ""]);
            }, "O"), K = /* @__PURE__ */ __name((Q) => L ? V(Q) : O(Q), "K"), se = /* @__PURE__ */ __name((Q, le) => R(Q, Object.assign({ __onHtmlBindingRoot: Y, __embeddedInHtml: true }, le)), "se");
            if (k.fullName === "srcset" && (k.parent.fullName === "img" || k.parent.fullName === "source"))
              return O(T(J()));
            if (k.fullName === "class" && !M.parentParser) {
              let Q = J();
              if (!Q.includes("{{"))
                return F(Q);
            }
            if (k.fullName === "style" && !M.parentParser) {
              let Q = J();
              if (!Q.includes("{{"))
                return O(se(Q, { parser: "css", __isHTMLStyleAttribute: true }));
            }
            if (M.parser === "vue") {
              if (k.fullName === "v-for")
                return A(J(), se);
              if (o(k) || d(k, M))
                return B(J(), se);
              let Q = ["^@", "^v-on:"], le = ["^:", "^v-bind:"], W = ["^v-"];
              if (q(Q)) {
                let X = J(), oe = I(X) ? "__js_expression" : M.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                return K(se(X, { parser: oe }));
              }
              if (q(le))
                return K(se(J(), { parser: "__vue_expression" }));
              if (q(W))
                return K(se(J(), { parser: "__js_expression" }));
            }
            if (M.parser === "angular") {
              let Q = /* @__PURE__ */ __name((z, H) => se(z, Object.assign(Object.assign({}, H), {}, { trailingComma: "none" })), "Q"), le = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], X = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], oe = ["^i18n(-.+)?$"];
              if (q(W))
                return K(Q(J(), { parser: "__ng_action" }));
              if (q(X))
                return K(Q(J(), { parser: "__ng_binding" }));
              if (q(oe)) {
                let z = J().trim();
                return O(i(C(k, z)), !z.includes("@@"));
              }
              if (q(le))
                return K(Q(J(), { parser: "__ng_directive" }));
              let ae = /{{(.+?)}}/s, Ae = J();
              if (ae.test(Ae)) {
                let z = [];
                for (let [H, Z] of Ae.split(ae).entries())
                  if (H % 2 === 0)
                    z.push(y(Z));
                  else
                    try {
                      z.push(s(["{{", r([u, Q(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                    } catch {
                      z.push("{{", y(Z), "}}");
                    }
                return s(z);
              }
            }
            return null;
          }
          __name(b, "b");
          function N(k, R, M, q) {
            let J = k.getValue();
            switch (J.type) {
              case "element": {
                if (P(J) || J.type === "interpolation")
                  return;
                if (!J.isSelfClosing && $(J, q)) {
                  let L = f(J, q);
                  if (!L)
                    return;
                  let Y = _(J, q), V = /^\s*$/.test(Y), O = "";
                  return V || (O = M(x(Y), { parser: L, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = O === ""), [v(J, q), s(w(k, q, R)), V ? "" : a, O, V ? "" : a, g(J, q), p(J, q)];
                }
                break;
              }
              case "text": {
                if (P(J.parent)) {
                  let L = f(J.parent, q);
                  if (L) {
                    let Y = L === "markdown" ? m(J.value.replace(/^[^\S\n]*\n/, "")) : J.value, V = { parser: L, __embeddedInHtml: true };
                    if (q.parser === "html" && L === "babel") {
                      let O = "script", { attrMap: K } = J.parent;
                      K && (K.type === "module" || K.type === "text/babel" && K["data-type"] === "module") && (O = "module"), V.__babelSourceType = O;
                    }
                    return [t, v(J, q), M(Y, V, { stripTrailingHardline: true }), p(J, q)];
                  }
                } else if (J.parent.type === "interpolation") {
                  let L = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                  return q.parser === "angular" ? (L.parser = "__ng_interpolation", L.trailingComma = "none") : q.parser === "vue" ? L.parser = q.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L.parser = "__js_expression", [r([u, M(J.value, L, { stripTrailingHardline: true })]), J.parent.next && D(J.parent.next) ? " " : u];
                }
                break;
              }
              case "attribute": {
                if (!J.value)
                  break;
                if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                  return [J.rawName, "=", J.value];
                if (q.parser === "lwc" && /^{.*}$/s.test(q.originalText.slice(J.valueSpan.start.offset, J.valueSpan.end.offset)))
                  return [J.rawName, "=", J.value];
                let L = b(J, (Y, V) => M(Y, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q);
                if (L)
                  return [J.rawName, '="', s(c(L, (Y) => typeof Y == "string" ? Y.replace(/"/g, "&quot;") : Y)), '"'];
                break;
              }
              case "front-matter":
                return h(J, M);
            }
          }
          __name(N, "N");
          n.exports = N;
        } }), Do = ee({ "src/language-html/print/children.js"(e, n) {
          "use strict";
          re();
          var { builders: { breakParent: t, group: s, ifBreak: a, line: r, softline: u, hardline: i }, utils: { replaceTextEndOfLine: l } } = qe(), { locStart: c, locEnd: y } = Qn(), { forceBreakChildren: h, forceNextEmptyLine: g, isTextLikeNode: p, hasPrettierIgnore: D, preferHardlineAsLeadingSpaces: v } = Mt(), { printOpeningTagPrefix: w, needsToBorrowNextOpeningTagStartMarker: T, printOpeningTagStartMarker: F, needsToBorrowPrevClosingTagEndMarker: A, printClosingTagEndMarker: B, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: P } = rr();
          function $(m, E, o) {
            let d = m.getValue();
            return D(d) ? [w(d, E), ...l(E.originalText.slice(c(d) + (d.prev && T(d.prev) ? F(d).length : 0), y(d) - (d.next && A(d.next) ? B(d, E).length : 0))), I(d, E)] : o();
          }
          __name($, "$");
          function f(m, E) {
            return p(m) && p(E) ? m.isTrailingSpaceSensitive ? m.hasTrailingSpaces ? v(E) ? i : r : "" : v(E) ? i : u : T(m) && (D(E) || E.firstChild || E.isSelfClosing || E.type === "element" && E.attrs.length > 0) || m.type === "element" && m.isSelfClosing && A(E) ? "" : !E.isLeadingSpaceSensitive || v(E) || A(E) && m.lastChild && P(m.lastChild) && m.lastChild.lastChild && P(m.lastChild.lastChild) ? i : E.hasLeadingSpaces ? r : u;
          }
          __name(f, "f");
          function x(m, E, o) {
            let d = m.getValue();
            if (h(d))
              return [t, ...m.map((_) => {
                let b = _.getValue(), N = b.prev ? f(b.prev, b) : "";
                return [N ? [N, g(b.prev) ? i : ""] : "", $(_, E, o)];
              }, "children")];
            let C = d.children.map(() => Symbol(""));
            return m.map((_, b) => {
              let N = _.getValue();
              if (p(N)) {
                if (N.prev && p(N.prev)) {
                  let Y = f(N.prev, N);
                  if (Y)
                    return g(N.prev) ? [i, i, $(_, E, o)] : [Y, $(_, E, o)];
                }
                return $(_, E, o);
              }
              let k = [], R = [], M = [], q = [], J = N.prev ? f(N.prev, N) : "", L = N.next ? f(N, N.next) : "";
              return J && (g(N.prev) ? k.push(i, i) : J === i ? k.push(i) : p(N.prev) ? R.push(J) : R.push(a("", u, { groupId: C[b - 1] }))), L && (g(N) ? p(N.next) && q.push(i, i) : L === i ? p(N.next) && q.push(i) : M.push(L)), [...k, s([...R, s([$(_, E, o), ...M], { id: C[b] })]), ...q];
            }, "children");
          }
          __name(x, "x");
          n.exports = { printChildren: x };
        } }), ng = ee({ "src/language-html/print/element.js"(e, n) {
          "use strict";
          re();
          var { builders: { breakParent: t, dedentToRoot: s, group: a, ifBreak: r, indentIfBreak: u, indent: i, line: l, softline: c }, utils: { replaceTextEndOfLine: y } } = qe(), h = fo(), { shouldPreserveContent: g, isScriptLikeTag: p, isVueCustomBlock: D, countParents: v, forceBreakContent: w } = Mt(), { printOpeningTagPrefix: T, printOpeningTag: F, printClosingTagSuffix: A, printClosingTag: B, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: P } = rr(), { printChildren: $ } = Do();
          function f(x, m, E) {
            let o = x.getValue();
            if (g(o, m))
              return [T(o, m), a(F(x, m, E)), ...y(h(o, m)), ...B(o, m), A(o, m)];
            let d = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, C = Symbol("element-attr-group-id"), _ = /* @__PURE__ */ __name((R) => a([a(F(x, m, E), { id: C }), R, B(o, m)]), "_"), b = /* @__PURE__ */ __name((R) => d ? u(R, { groupId: C }) : (p(o) || D(o, m)) && o.parent.type === "root" && m.parser === "vue" && !m.vueIndentScriptAndStyle ? R : i(R), "b"), N = /* @__PURE__ */ __name(() => d ? r(c, "", { groupId: C }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(c) : c, "N"), k = /* @__PURE__ */ __name(() => (o.next ? I(o.next) : P(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : d ? r(c, "", { groupId: C }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m.tabWidth * v(x, (M) => M.parent && M.parent.type !== "root")}}$`).test(o.lastChild.value) ? "" : c, "k");
            return o.children.length === 0 ? _(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : "") : _([w(o) ? t : "", b([N(), $(x, m, E)]), k()]);
          }
          __name(f, "f");
          n.exports = { printElement: f };
        } }), ug = ee({ "src/language-html/printer-html.js"(e, n) {
          "use strict";
          re();
          var { builders: { fill: t, group: s, hardline: a, literalline: r }, utils: { cleanDoc: u, getDocParts: i, isConcat: l, replaceTextEndOfLine: c } } = qe(), y = Wd(), { countChars: h, unescapeQuoteEntities: g, getTextValueParts: p } = Mt(), D = Yd(), { insertPragma: v } = Qd(), { locStart: w, locEnd: T } = Qn(), F = rg(), { printClosingTagSuffix: A, printClosingTagEnd: B, printOpeningTagPrefix: I, printOpeningTagStart: P } = rr(), { printElement: $ } = ng(), { printChildren: f } = Do();
          function x(m, E, o) {
            let d = m.getValue();
            switch (d.type) {
              case "front-matter":
                return c(d.raw);
              case "root":
                return E.__onHtmlRoot && E.__onHtmlRoot(d), [s(f(m, E, o)), a];
              case "element":
              case "ieConditionalComment":
                return $(m, E, o);
              case "ieConditionalStartComment":
              case "ieConditionalEndComment":
                return [P(d), B(d)];
              case "interpolation":
                return [P(d, E), ...m.map(o, "children"), B(d, E)];
              case "text": {
                if (d.parent.type === "interpolation") {
                  let _ = /\n[^\S\n]*$/, b = _.test(d.value), N = b ? d.value.replace(_, "") : d.value;
                  return [...c(N), b ? a : ""];
                }
                let C = u([I(d, E), ...p(d), A(d, E)]);
                return l(C) || C.type === "fill" ? t(i(C)) : C;
              }
              case "docType":
                return [s([P(d, E), " ", d.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), B(d, E)];
              case "comment":
                return [I(d, E), ...c(E.originalText.slice(w(d), T(d)), r), A(d, E)];
              case "attribute": {
                if (d.value === null)
                  return d.rawName;
                let C = g(d.value), _ = h(C, "'"), b = h(C, '"'), N = _ < b ? "'" : '"';
                return [d.rawName, "=", N, ...c(N === '"' ? C.replace(/"/g, "&quot;") : C.replace(/'/g, "&apos;")), N];
              }
              default:
                throw new Error(`Unexpected node type ${d.type}`);
            }
          }
          __name(x, "x");
          n.exports = { preprocess: D, print: x, insertPragma: v, massageAstNode: y, embed: F };
        } }), sg = ee({ "src/language-html/options.js"(e, n) {
          "use strict";
          re();
          var t = qt(), s = "HTML";
          n.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
        } }), ig = ee({ "src/language-html/parsers.js"() {
          re();
        } }), Tn = ee({ "node_modules/linguist-languages/data/HTML.json"(e, n) {
          n.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
        } }), ag = ee({ "node_modules/linguist-languages/data/Vue.json"(e, n) {
          n.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
        } }), og = ee({ "src/language-html/index.js"(e, n) {
          "use strict";
          re();
          var t = wt(), s = ug(), a = sg(), r = ig(), u = [t(Tn(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(Tn(), (l) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l.extensions, ".mjml"] })), t(Tn(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(ag(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s };
          n.exports = { languages: u, printers: i, options: a, parsers: r };
        } }), lg = ee({ "src/language-yaml/pragma.js"(e, n) {
          "use strict";
          re();
          function t(r) {
            return /^\s*@(?:prettier|format)\s*$/.test(r);
          }
          __name(t, "t");
          function s(r) {
            return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(r);
          }
          __name(s, "s");
          function a(r) {
            return `# @format

${r}`;
          }
          __name(a, "a");
          n.exports = { isPragma: t, hasPragma: s, insertPragma: a };
        } }), cg = ee({ "src/language-yaml/loc.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return a.position.start.offset;
          }
          __name(t, "t");
          function s(a) {
            return a.position.end.offset;
          }
          __name(s, "s");
          n.exports = { locStart: t, locEnd: s };
        } }), pg = ee({ "src/language-yaml/embed.js"(e, n) {
          "use strict";
          re();
          function t(s, a, r, u) {
            if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath))
              return r(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
          }
          __name(t, "t");
          n.exports = t;
        } }), Rt = ee({ "src/language-yaml/utils.js"(e, n) {
          "use strict";
          re();
          var { getLast: t, isNonEmptyArray: s } = Ge();
          function a(f, x) {
            let m = 0, E = f.stack.length - 1;
            for (let o = 0; o < E; o++) {
              let d = f.stack[o];
              r(d) && x(d) && m++;
            }
            return m;
          }
          __name(a, "a");
          function r(f, x) {
            return f && typeof f.type == "string" && (!x || x.includes(f.type));
          }
          __name(r, "r");
          function u(f, x, m) {
            return x("children" in f ? Object.assign(Object.assign({}, f), {}, { children: f.children.map((E) => u(E, x, f)) }) : f, m);
          }
          __name(u, "u");
          function i(f, x, m) {
            Object.defineProperty(f, x, { get: m, enumerable: false });
          }
          __name(i, "i");
          function l(f, x) {
            let m = 0, E = x.length;
            for (let o = f.position.end.offset - 1; o < E; o++) {
              let d = x[o];
              if (d === `
` && m++, m === 1 && /\S/.test(d))
                return false;
              if (m === 2)
                return true;
            }
            return false;
          }
          __name(l, "l");
          function c(f) {
            switch (f.getValue().type) {
              case "tag":
              case "anchor":
              case "comment":
                return false;
            }
            let m = f.stack.length;
            for (let E = 1; E < m; E++) {
              let o = f.stack[E], d = f.stack[E - 1];
              if (Array.isArray(d) && typeof o == "number" && o !== d.length - 1)
                return false;
            }
            return true;
          }
          __name(c, "c");
          function y(f) {
            return s(f.children) ? y(t(f.children)) : f;
          }
          __name(y, "y");
          function h(f) {
            return f.value.trim() === "prettier-ignore";
          }
          __name(h, "h");
          function g(f) {
            let x = f.getValue();
            if (x.type === "documentBody") {
              let m = f.getParentNode();
              return A(m.head) && h(t(m.head.endComments));
            }
            return v(x) && h(t(x.leadingComments));
          }
          __name(g, "g");
          function p(f) {
            return !s(f.children) && !D(f);
          }
          __name(p, "p");
          function D(f) {
            return v(f) || w(f) || T(f) || F(f) || A(f);
          }
          __name(D, "D");
          function v(f) {
            return s(f == null ? void 0 : f.leadingComments);
          }
          __name(v, "v");
          function w(f) {
            return s(f == null ? void 0 : f.middleComments);
          }
          __name(w, "w");
          function T(f) {
            return f == null ? void 0 : f.indicatorComment;
          }
          __name(T, "T");
          function F(f) {
            return f == null ? void 0 : f.trailingComment;
          }
          __name(F, "F");
          function A(f) {
            return s(f == null ? void 0 : f.endComments);
          }
          __name(A, "A");
          function B(f) {
            let x = [], m;
            for (let E of f.split(/( +)/))
              E !== " " ? m === " " ? x.push(E) : x.push((x.pop() || "") + E) : m === void 0 && x.unshift(""), m = E;
            return m === " " && x.push((x.pop() || "") + " "), x[0] === "" && (x.shift(), x.unshift(" " + (x.shift() || ""))), x;
          }
          __name(B, "B");
          function I(f, x, m) {
            let E = x.split(`
`).map((o, d, C) => d === 0 && d === C.length - 1 ? o : d !== 0 && d !== C.length - 1 ? o.trim() : d === 0 ? o.trimEnd() : o.trimStart());
            return m.proseWrap === "preserve" ? E.map((o) => o.length === 0 ? [] : [o]) : E.map((o) => o.length === 0 ? [] : B(o)).reduce((o, d, C) => C !== 0 && E[C - 1].length > 0 && d.length > 0 && !(f === "quoteDouble" && t(t(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t(o), ...d]] : [...o, d], []).map((o) => m.proseWrap === "never" ? [o.join(" ")] : o);
          }
          __name(I, "I");
          function P(f, x) {
            let { parentIndent: m, isLastDescendant: E, options: o } = x, d = f.position.start.line === f.position.end.line ? "" : o.originalText.slice(f.position.start.offset, f.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], C;
            if (f.indent === null) {
              let N = d.match(/^(?<leadingSpace> *)[^\n\r ]/m);
              C = N ? N.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
            } else
              C = f.indent - 1 + m;
            let _ = d.split(`
`).map((N) => N.slice(C));
            if (o.proseWrap === "preserve" || f.type === "blockLiteral")
              return b(_.map((N) => N.length === 0 ? [] : [N]));
            return b(_.map((N) => N.length === 0 ? [] : B(N)).reduce((N, k, R) => R !== 0 && _[R - 1].length > 0 && k.length > 0 && !/^\s/.test(k[0]) && !/^\s|\s$/.test(t(N)) ? [...N.slice(0, -1), [...t(N), ...k]] : [...N, k], []).map((N) => N.reduce((k, R) => k.length > 0 && /\s$/.test(t(k)) ? [...k.slice(0, -1), t(k) + " " + R] : [...k, R], [])).map((N) => o.proseWrap === "never" ? [N.join(" ")] : N));
            function b(N) {
              if (f.chomping === "keep")
                return t(N).length === 0 ? N.slice(0, -1) : N;
              let k = 0;
              for (let R = N.length - 1; R >= 0 && N[R].length === 0; R--)
                k++;
              return k === 0 ? N : k >= 2 && !E ? N.slice(0, -(k - 1)) : N.slice(0, -k);
            }
            __name(b, "b");
          }
          __name(P, "P");
          function $(f) {
            if (!f)
              return true;
            switch (f.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
              case "alias":
              case "flowMapping":
              case "flowSequence":
                return true;
              default:
                return false;
            }
          }
          __name($, "$");
          n.exports = { getLast: t, getAncestorCount: a, isNode: r, isEmptyNode: p, isInlineNode: $, mapNode: u, defineShortcut: i, isNextLineEmpty: l, isLastDescendantNode: c, getBlockValueLineContents: P, getFlowScalarLineContents: I, getLastDescendantNode: y, hasPrettierIgnore: g, hasLeadingComments: v, hasMiddleComments: w, hasIndicatorComment: T, hasTrailingComment: F, hasEndComments: A };
        } }), fg = ee({ "src/language-yaml/print-preprocess.js"(e, n) {
          "use strict";
          re();
          var { defineShortcut: t, mapNode: s } = Rt();
          function a(u) {
            return s(u, r);
          }
          __name(a, "a");
          function r(u) {
            switch (u.type) {
              case "document":
                t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
                break;
              case "documentBody":
              case "sequenceItem":
              case "flowSequenceItem":
              case "mappingKey":
              case "mappingValue":
                t(u, "content", () => u.children[0]);
                break;
              case "mappingItem":
              case "flowMappingItem":
                t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
                break;
            }
            return u;
          }
          __name(r, "r");
          n.exports = a;
        } }), qr = ee({ "src/language-yaml/print/misc.js"(e, n) {
          "use strict";
          re();
          var { builders: { softline: t, align: s } } = qe(), { hasEndComments: a, isNextLineEmpty: r, isNode: u } = Rt(), i = /* @__PURE__ */ new WeakMap();
          function l(h, g) {
            let p = h.getValue(), D = h.stack[0], v;
            return i.has(D) ? v = i.get(D) : (v = /* @__PURE__ */ new Set(), i.set(D, v)), !v.has(p.position.end.line) && (v.add(p.position.end.line), r(p, g) && !c(h.getParentNode())) ? t : "";
          }
          __name(l, "l");
          function c(h) {
            return a(h) && !u(h, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
          }
          __name(c, "c");
          function y(h, g) {
            return s(" ".repeat(h), g);
          }
          __name(y, "y");
          n.exports = { alignWithSpaces: y, shouldPrintEndComments: c, printNextEmptyLine: l };
        } }), Dg = ee({ "src/language-yaml/print/flow-mapping-sequence.js"(e, n) {
          "use strict";
          re();
          var { builders: { ifBreak: t, line: s, softline: a, hardline: r, join: u } } = qe(), { isEmptyNode: i, getLast: l, hasEndComments: c } = Rt(), { printNextEmptyLine: y, alignWithSpaces: h } = qr();
          function g(D, v, w) {
            let T = D.getValue(), F = T.type === "flowMapping", A = F ? "{" : "[", B = F ? "}" : "]", I = a;
            F && T.children.length > 0 && w.bracketSpacing && (I = s);
            let P = l(T.children), $ = P && P.type === "flowMappingItem" && i(P.key) && i(P.value);
            return [A, h(w.tabWidth, [I, p(D, v, w), w.trailingComma === "none" ? "" : t(","), c(T) ? [r, u(r, D.map(v, "endComments"))] : ""]), $ ? "" : I, B];
          }
          __name(g, "g");
          function p(D, v, w) {
            let T = D.getValue();
            return D.map((A, B) => [v(), B === T.children.length - 1 ? "" : [",", s, T.children[B].position.start.line !== T.children[B + 1].position.start.line ? y(A, w.originalText) : ""]], "children");
          }
          __name(p, "p");
          n.exports = { printFlowMapping: g, printFlowSequence: g };
        } }), mg = ee({ "src/language-yaml/print/mapping-item.js"(e, n) {
          "use strict";
          re();
          var { builders: { conditionalGroup: t, group: s, hardline: a, ifBreak: r, join: u, line: i } } = qe(), { hasLeadingComments: l, hasMiddleComments: c, hasTrailingComment: y, hasEndComments: h, isNode: g, isEmptyNode: p, isInlineNode: D } = Rt(), { alignWithSpaces: v } = qr();
          function w(B, I, P, $, f) {
            let { key: x, value: m } = B, E = p(x), o = p(m);
            if (E && o)
              return ": ";
            let d = $("key"), C = F(B) ? " " : "";
            if (o)
              return B.type === "flowMappingItem" && I.type === "flowMapping" ? d : B.type === "mappingItem" && T(x.content, f) && !y(x.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [d, C, ":"] : ["? ", v(2, d)];
            let _ = $("value");
            if (E)
              return [": ", v(2, _)];
            if (l(m) || !D(x.content))
              return ["? ", v(2, d), a, u("", P.map($, "value", "leadingComments").map((q) => [q, a])), ": ", v(2, _)];
            if (A(x.content) && !l(x.content) && !c(x.content) && !y(x.content) && !h(x) && !l(m.content) && !c(m.content) && !h(m) && T(m.content, f))
              return [d, C, ": ", _];
            let b = Symbol("mappingKey"), N = s([r("? "), s(v(2, d), { id: b })]), k = [a, ": ", v(2, _)], R = [C, ":"];
            l(m.content) || h(m) && m.content && !g(m.content, ["mapping", "sequence"]) || I.type === "mapping" && y(x.content) && D(m.content) || g(m.content, ["mapping", "sequence"]) && m.content.tag === null && m.content.anchor === null ? R.push(a) : m.content && R.push(i), R.push(_);
            let M = v(f.tabWidth, R);
            return T(x.content, f) && !l(x.content) && !c(x.content) && !h(x) ? t([[d, M]]) : t([[N, r(k, M, { groupId: b })]]);
          }
          __name(w, "w");
          function T(B, I) {
            if (!B)
              return true;
            switch (B.type) {
              case "plain":
              case "quoteSingle":
              case "quoteDouble":
                break;
              case "alias":
                return true;
              default:
                return false;
            }
            if (I.proseWrap === "preserve")
              return B.position.start.line === B.position.end.line;
            if (/\\$/m.test(I.originalText.slice(B.position.start.offset, B.position.end.offset)))
              return false;
            switch (I.proseWrap) {
              case "never":
                return !B.value.includes(`
`);
              case "always":
                return !/[\n ]/.test(B.value);
              default:
                return false;
            }
          }
          __name(T, "T");
          function F(B) {
            return B.key.content && B.key.content.type === "alias";
          }
          __name(F, "F");
          function A(B) {
            if (!B)
              return true;
            switch (B.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
                return B.position.start.line === B.position.end.line;
              case "alias":
                return true;
              default:
                return false;
            }
          }
          __name(A, "A");
          n.exports = w;
        } }), dg = ee({ "src/language-yaml/print/block.js"(e, n) {
          "use strict";
          re();
          var { builders: { dedent: t, dedentToRoot: s, fill: a, hardline: r, join: u, line: i, literalline: l, markAsRoot: c }, utils: { getDocParts: y } } = qe(), { getAncestorCount: h, getBlockValueLineContents: g, hasIndicatorComment: p, isLastDescendantNode: D, isNode: v } = Rt(), { alignWithSpaces: w } = qr();
          function T(F, A, B) {
            let I = F.getValue(), P = h(F, (E) => v(E, ["sequence", "mapping"])), $ = D(F), f = [I.type === "blockFolded" ? ">" : "|"];
            I.indent !== null && f.push(I.indent.toString()), I.chomping !== "clip" && f.push(I.chomping === "keep" ? "+" : "-"), p(I) && f.push(" ", A("indicatorComment"));
            let x = g(I, { parentIndent: P, isLastDescendant: $, options: B }), m = [];
            for (let [E, o] of x.entries())
              E === 0 && m.push(r), m.push(a(y(u(i, o)))), E !== x.length - 1 ? m.push(o.length === 0 ? r : c(l)) : I.chomping === "keep" && $ && m.push(s(o.length === 0 ? r : l));
            return I.indent === null ? f.push(t(w(B.tabWidth, m))) : f.push(s(w(I.indent - 1 + P, m))), f;
          }
          __name(T, "T");
          n.exports = T;
        } }), gg = ee({ "src/language-yaml/printer-yaml.js"(e, n) {
          "use strict";
          re();
          var { builders: { breakParent: t, fill: s, group: a, hardline: r, join: u, line: i, lineSuffix: l, literalline: c }, utils: { getDocParts: y, replaceTextEndOfLine: h } } = qe(), { isPreviousLineEmpty: g } = Ge(), { insertPragma: p, isPragma: D } = lg(), { locStart: v } = cg(), w = pg(), { getFlowScalarLineContents: T, getLastDescendantNode: F, hasLeadingComments: A, hasMiddleComments: B, hasTrailingComment: I, hasEndComments: P, hasPrettierIgnore: $, isLastDescendantNode: f, isNode: x, isInlineNode: m } = Rt(), E = fg(), { alignWithSpaces: o, printNextEmptyLine: d, shouldPrintEndComments: C } = qr(), { printFlowMapping: _, printFlowSequence: b } = Dg(), N = mg(), k = dg();
          function R(O, K, se) {
            let Q = O.getValue(), le = [];
            Q.type !== "mappingValue" && A(Q) && le.push([u(r, O.map(se, "leadingComments")), r]);
            let { tag: W, anchor: X } = Q;
            W && le.push(se("tag")), W && X && le.push(" "), X && le.push(se("anchor"));
            let oe = "";
            x(Q, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !f(O) && (oe = d(O, K.originalText)), (W || X) && (x(Q, ["sequence", "mapping"]) && !B(Q) ? le.push(r) : le.push(" ")), B(Q) && le.push([Q.middleComments.length === 1 ? "" : r, u(r, O.map(se, "middleComments")), r]);
            let ae = O.getParentNode();
            return $(O) ? le.push(h(K.originalText.slice(Q.position.start.offset, Q.position.end.offset).trimEnd(), c)) : le.push(a(M(Q, ae, O, K, se))), I(Q) && !x(Q, ["document", "documentHead"]) && le.push(l([Q.type === "mappingValue" && !Q.content ? "" : " ", ae.type === "mappingKey" && O.getParentNode(2).type === "mapping" && m(Q) ? "" : t, se("trailingComment")])), C(Q) && le.push(o(Q.type === "sequenceItem" ? 2 : 0, [r, u(r, O.map((Ae) => [g(K.originalText, Ae.getValue(), v) ? r : "", se()], "endComments"))])), le.push(oe), le;
          }
          __name(R, "R");
          function M(O, K, se, Q, le) {
            switch (O.type) {
              case "root": {
                let { children: W } = O, X = [];
                se.each((ae, Ae) => {
                  let z = W[Ae], H = W[Ae + 1];
                  Ae !== 0 && X.push(r), X.push(le()), J(z, H) ? (X.push(r, "..."), I(z) && X.push(" ", le("trailingComment"))) : H && !I(H.head) && X.push(r, "---");
                }, "children");
                let oe = F(O);
                return (!x(oe, ["blockLiteral", "blockFolded"]) || oe.chomping !== "keep") && X.push(r), X;
              }
              case "document": {
                let W = K.children[se.getName() + 1], X = [];
                return L(O, W, K, Q) === "head" && ((O.head.children.length > 0 || O.head.endComments.length > 0) && X.push(le("head")), I(O.head) ? X.push(["---", " ", le(["head", "trailingComment"])]) : X.push("---")), q(O) && X.push(le("body")), u(r, X);
              }
              case "documentHead":
                return u(r, [...se.map(le, "children"), ...se.map(le, "endComments")]);
              case "documentBody": {
                let { children: W, endComments: X } = O, oe = "";
                if (W.length > 0 && X.length > 0) {
                  let ae = F(O);
                  x(ae, ["blockFolded", "blockLiteral"]) ? ae.chomping !== "keep" && (oe = [r, r]) : oe = r;
                }
                return [u(r, se.map(le, "children")), oe, u(r, se.map(le, "endComments"))];
              }
              case "directive":
                return ["%", u(" ", [O.name, ...O.parameters])];
              case "comment":
                return ["#", O.value];
              case "alias":
                return ["*", O.value];
              case "tag":
                return Q.originalText.slice(O.position.start.offset, O.position.end.offset);
              case "anchor":
                return ["&", O.value];
              case "plain":
                return Y(O.type, Q.originalText.slice(O.position.start.offset, O.position.end.offset), Q);
              case "quoteDouble":
              case "quoteSingle": {
                let W = "'", X = '"', oe = Q.originalText.slice(O.position.start.offset + 1, O.position.end.offset - 1);
                if (O.type === "quoteSingle" && oe.includes("\\") || O.type === "quoteDouble" && /\\[^"]/.test(oe)) {
                  let Ae = O.type === "quoteDouble" ? X : W;
                  return [Ae, Y(O.type, oe, Q), Ae];
                }
                if (oe.includes(X))
                  return [W, Y(O.type, O.type === "quoteDouble" ? oe.replace(/\\"/g, X).replace(/'/g, W.repeat(2)) : oe, Q), W];
                if (oe.includes(W))
                  return [X, Y(O.type, O.type === "quoteSingle" ? oe.replace(/''/g, W) : oe, Q), X];
                let ae = Q.singleQuote ? W : X;
                return [ae, Y(O.type, oe, Q), ae];
              }
              case "blockFolded":
              case "blockLiteral":
                return k(se, le, Q);
              case "mapping":
              case "sequence":
                return u(r, se.map(le, "children"));
              case "sequenceItem":
                return ["- ", o(2, O.content ? le("content") : "")];
              case "mappingKey":
              case "mappingValue":
                return O.content ? le("content") : "";
              case "mappingItem":
              case "flowMappingItem":
                return N(O, K, se, le, Q);
              case "flowMapping":
                return _(se, le, Q);
              case "flowSequence":
                return b(se, le, Q);
              case "flowSequenceItem":
                return le("content");
              default:
                throw new Error(`Unexpected node type ${O.type}`);
            }
          }
          __name(M, "M");
          function q(O) {
            return O.body.children.length > 0 || P(O.body);
          }
          __name(q, "q");
          function J(O, K) {
            return I(O) || K && (K.head.children.length > 0 || P(K.head));
          }
          __name(J, "J");
          function L(O, K, se, Q) {
            return se.children[0] === O && /---(?:\s|$)/.test(Q.originalText.slice(v(O), v(O) + 4)) || O.head.children.length > 0 || P(O.head) || I(O.head) ? "head" : J(O, K) ? false : K ? "root" : false;
          }
          __name(L, "L");
          function Y(O, K, se) {
            let Q = T(O, K, se);
            return u(r, Q.map((le) => s(y(u(i, le)))));
          }
          __name(Y, "Y");
          function V(O, K) {
            if (x(K))
              switch (delete K.position, K.type) {
                case "comment":
                  if (D(K.value))
                    return null;
                  break;
                case "quoteDouble":
                case "quoteSingle":
                  K.type = "quote";
                  break;
              }
          }
          __name(V, "V");
          n.exports = { preprocess: E, embed: w, print: R, massageAstNode: V, insertPragma: p };
        } }), yg = ee({ "src/language-yaml/options.js"(e, n) {
          "use strict";
          re();
          var t = qt();
          n.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
        } }), hg = ee({ "src/language-yaml/parsers.js"() {
          re();
        } }), vg = ee({ "node_modules/linguist-languages/data/YAML.json"(e, n) {
          n.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
        } }), Cg = ee({ "src/language-yaml/index.js"(e, n) {
          "use strict";
          re();
          var t = wt(), s = gg(), a = yg(), r = hg(), u = [t(vg(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((l) => l !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
          n.exports = { languages: u, printers: { yaml: s }, options: a, parsers: r };
        } }), Eg = ee({ "src/languages.js"(e, n) {
          "use strict";
          re(), n.exports = [td(), vd(), Td(), kd(), Vd(), og(), Cg()];
        } });
        re();
        var { version: Fg } = fa(), kt = vm(), { getSupportInfo: Ag } = Rn(), Sg = Cm(), xg = Eg(), bg = qe();
        function Bt(e) {
          let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return function() {
            for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++)
              s[a] = arguments[a];
            let r = s[n] || {}, u = r.plugins || [];
            return s[n] = Object.assign(Object.assign({}, r), {}, { plugins: [...xg, ...Array.isArray(u) ? u : Object.values(u)] }), e(...s);
          };
        }
        __name(Bt, "Bt");
        var Bn = Bt(kt.formatWithCursor);
        mo.exports = { formatWithCursor: Bn, format(e, n) {
          return Bn(e, n).formatted;
        }, check(e, n) {
          let { formatted: t } = Bn(e, n);
          return t === e;
        }, doc: bg, getSupportInfo: Bt(Ag, 0), version: Fg, util: Sg, __debug: { parse: Bt(kt.parse), formatAST: Bt(kt.formatAST), formatDoc: Bt(kt.formatDoc), printToDoc: Bt(kt.printToDoc), printDocToString: Bt(kt.printDocToString) } };
      });
      return Tg();
    });
  }
});

// node_modules/fast-diff/diff.js
var require_diff = __commonJS({
  "node_modules/fast-diff/diff.js"(exports, module) {
    init_define_process();
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    function diff_main(text1, text2, cursor_pos, _fix_unicode) {
      if (text1 === text2) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }
      if (cursor_pos != null) {
        var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
        if (editdiff) {
          return editdiff;
        }
      }
      var commonlength = diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = diff_compute_(text1, text2);
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs, _fix_unicode);
      return diffs;
    }
    __name(diff_main, "diff_main");
    function diff_compute_(text1, text2) {
      var diffs;
      if (!text1) {
        return [[DIFF_INSERT, text2]];
      }
      if (!text2) {
        return [[DIFF_DELETE, text1]];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i !== -1) {
        diffs = [
          [DIFF_INSERT, longtext.substring(0, i)],
          [DIFF_EQUAL, shorttext],
          [DIFF_INSERT, longtext.substring(i + shorttext.length)]
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length === 1) {
        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
      }
      var hm = diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }
      return diff_bisect_(text1, text2);
    }
    __name(diff_compute_, "diff_compute_");
    function diff_bisect_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 !== 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
      }
      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
    }
    __name(diff_bisect_, "diff_bisect_");
    function diff_bisectSplit_(text1, text2, x, y) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);
      return diffs.concat(diffsb);
    }
    __name(diff_bisectSplit_, "diff_bisectSplit_");
    function diff_commonPrefix(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
        pointermid--;
      }
      return pointermid;
    }
    __name(diff_commonPrefix, "diff_commonPrefix");
    function diff_commonSuffix(text1, text2) {
      if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
        pointermid--;
      }
      return pointermid;
    }
    __name(diff_commonSuffix, "diff_commonSuffix");
    function diff_halfMatch_(text1, text2) {
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
          var prefixLength = diff_commonPrefix(
            longtext2.substring(i),
            shorttext2.substring(j)
          );
          var suffixLength = diff_commonSuffix(
            longtext2.substring(0, i),
            shorttext2.substring(0, j)
          );
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(
              j - suffixLength,
              j
            ) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      __name(diff_halfMatchI_, "diff_halfMatchI_");
      var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
      var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }
    __name(diff_halfMatch_, "diff_halfMatch_");
    function diff_cleanupMerge(diffs, fix_unicode) {
      diffs.push([DIFF_EQUAL, ""]);
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          diffs.splice(pointer, 1);
          continue;
        }
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            var previous_equality = pointer - count_insert - count_delete - 1;
            if (fix_unicode) {
              if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                var stray = diffs[previous_equality][1].slice(-1);
                diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);
                text_delete = stray + text_delete;
                text_insert = stray + text_insert;
                if (!diffs[previous_equality][1]) {
                  diffs.splice(previous_equality, 1);
                  pointer--;
                  var k = previous_equality - 1;
                  if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                    count_insert++;
                    text_insert = diffs[k][1] + text_insert;
                    k--;
                  }
                  if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                    count_delete++;
                    text_delete = diffs[k][1] + text_delete;
                    k--;
                  }
                  previous_equality = k;
                }
              }
              if (starts_with_pair_end(diffs[pointer][1])) {
                var stray = diffs[pointer][1].charAt(0);
                diffs[pointer][1] = diffs[pointer][1].slice(1);
                text_delete += stray;
                text_insert += stray;
              }
            }
            if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
              diffs.splice(pointer, 1);
              break;
            }
            if (text_delete.length > 0 || text_insert.length > 0) {
              if (text_delete.length > 0 && text_insert.length > 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (previous_equality >= 0) {
                    diffs[previous_equality][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              var n = count_insert + count_delete;
              if (text_delete.length === 0 && text_insert.length === 0) {
                diffs.splice(pointer - n, n);
                pointer = pointer - n;
              } else if (text_delete.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 1;
              } else if (text_insert.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
                pointer = pointer - n + 1;
              } else {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 2;
              }
            }
            if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs, fix_unicode);
      }
    }
    __name(diff_cleanupMerge, "diff_cleanupMerge");
    function is_surrogate_pair_start(charCode) {
      return charCode >= 55296 && charCode <= 56319;
    }
    __name(is_surrogate_pair_start, "is_surrogate_pair_start");
    function is_surrogate_pair_end(charCode) {
      return charCode >= 56320 && charCode <= 57343;
    }
    __name(is_surrogate_pair_end, "is_surrogate_pair_end");
    function starts_with_pair_end(str) {
      return is_surrogate_pair_end(str.charCodeAt(0));
    }
    __name(starts_with_pair_end, "starts_with_pair_end");
    function ends_with_pair_start(str) {
      return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
    }
    __name(ends_with_pair_start, "ends_with_pair_start");
    function remove_empty_tuples(tuples) {
      var ret = [];
      for (var i = 0; i < tuples.length; i++) {
        if (tuples[i][1].length > 0) {
          ret.push(tuples[i]);
        }
      }
      return ret;
    }
    __name(remove_empty_tuples, "remove_empty_tuples");
    function make_edit_splice(before, oldMiddle, newMiddle, after) {
      if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
        return null;
      }
      return remove_empty_tuples([
        [DIFF_EQUAL, before],
        [DIFF_DELETE, oldMiddle],
        [DIFF_INSERT, newMiddle],
        [DIFF_EQUAL, after]
      ]);
    }
    __name(make_edit_splice, "make_edit_splice");
    function find_cursor_edit_diff(oldText, newText, cursor_pos) {
      var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
      var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
      var oldLength = oldText.length;
      var newLength = newText.length;
      if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
        var oldCursor = oldRange.index;
        var oldBefore = oldText.slice(0, oldCursor);
        var oldAfter = oldText.slice(oldCursor);
        var maybeNewCursor = newRange ? newRange.index : null;
        editBefore: {
          var newCursor = oldCursor + newLength - oldLength;
          if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
            break editBefore;
          }
          if (newCursor < 0 || newCursor > newLength) {
            break editBefore;
          }
          var newBefore = newText.slice(0, newCursor);
          var newAfter = newText.slice(newCursor);
          if (newAfter !== oldAfter) {
            break editBefore;
          }
          var prefixLength = Math.min(oldCursor, newCursor);
          var oldPrefix = oldBefore.slice(0, prefixLength);
          var newPrefix = newBefore.slice(0, prefixLength);
          if (oldPrefix !== newPrefix) {
            break editBefore;
          }
          var oldMiddle = oldBefore.slice(prefixLength);
          var newMiddle = newBefore.slice(prefixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
        }
        editAfter: {
          if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
            break editAfter;
          }
          var cursor = oldCursor;
          var newBefore = newText.slice(0, cursor);
          var newAfter = newText.slice(cursor);
          if (newBefore !== oldBefore) {
            break editAfter;
          }
          var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
          var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
          var newSuffix = newAfter.slice(newAfter.length - suffixLength);
          if (oldSuffix !== newSuffix) {
            break editAfter;
          }
          var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
          var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
          return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
        }
      }
      if (oldRange.length > 0 && newRange && newRange.length === 0) {
        replaceRange: {
          var oldPrefix = oldText.slice(0, oldRange.index);
          var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
          var prefixLength = oldPrefix.length;
          var suffixLength = oldSuffix.length;
          if (newLength < prefixLength + suffixLength) {
            break replaceRange;
          }
          var newPrefix = newText.slice(0, prefixLength);
          var newSuffix = newText.slice(newLength - suffixLength);
          if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
            break replaceRange;
          }
          var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
          var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
        }
      }
      return null;
    }
    __name(find_cursor_edit_diff, "find_cursor_edit_diff");
    function diff2(text1, text2, cursor_pos) {
      return diff_main(text1, text2, cursor_pos, true);
    }
    __name(diff2, "diff");
    diff2.INSERT = DIFF_INSERT;
    diff2.DELETE = DIFF_DELETE;
    diff2.EQUAL = DIFF_EQUAL;
    module.exports = diff2;
  }
});

// js/sharedWorker.ts
init_define_process();

// js/sab.ts
init_define_process();
function str2ab(str) {
  var buf = new ArrayBuffer(str.length * 2);
  var bufView = new Uint16Array(buf);
  for (var i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}
__name(str2ab, "str2ab");

// js/session.ts
init_define_process();
var import_lodash = __toESM(require_lodash(), 1);

// js/md5.js
init_define_process();
var cache = globalThis.md5cache = globalThis.md5cache || /* @__PURE__ */ new Map();

// js/getResetCss.ts
init_define_process();

// js/importMapReplace.ts
init_define_process();

// js/importmap.json
var importmap_default = {
  imports: {
    "framer-motion": "/motion.mjs",
    "@emotion/react": "/emotion.mjs",
    "@emotion/cache": "/emotionCache.mjs",
    "@emotion/styled": "/emotionStyled.mjs",
    "@emotion/react/jsx-runtime": "/emotionJsxRuntime.mjs",
    react: "/reactMod.mjs",
    "react/jsx-runtime": "/jsx.mjs",
    "react-dom": "/reactDom.mjs",
    "react-dom/client": "/reactDomClient.mjs",
    "react-error-boundary": "/reactMod.mjs",
    "hydrate.mjs": "/hydrate.mjs",
    "load.mjs": "/load.mjs"
  }
};

// js/importMapReplace.ts
var importMapImports = importmap_default.imports;

// js/prettierEsm.ts
init_define_process();
var import_parser_typescript = __toESM(require_parser_typescript(), 1);
var import_standalone = __toESM(require_standalone(), 1);

// js/textDiff.ts
init_define_process();
var import_fast_diff = __toESM(require_diff(), 1);

// js/sharedWorker.ts
var hashStore = {};
var names = {};
var blockedMessages = {};
self.mod = self.mod || {};
self.counters = self.counters || {};
self.connections = self.connections || {};
var { mod, counters } = self;
async function onMessage(port, {
  name,
  codeSpace,
  target,
  type,
  code,
  baseUrl,
  patch,
  reversePatch,
  users,
  i,
  address,
  hashCode,
  newHash,
  oldHash,
  candidate,
  offer,
  answer,
  sess
}) {
  console.log("onMessage", {
    codeSpace,
    name,
    sess,
    oldHash,
    newHash,
    hashCode,
    patch,
    reversePatch
  });
  const hash = newHash || hashCode;
  if (sess && hash)
    hashStore[hash] = sess;
  if (sess && newHash)
    hashStore[newHash] = sess;
  if (sess && hashCode)
    hashStore[hashCode] = sess;
  if (i && !counters[codeSpace])
    counters[codeSpace] = i;
  else if (i && counters[codeSpace] >= i)
    return;
  counters[codeSpace] = i;
  if (codeSpace && type === "ata") {
  }
  if (codeSpace && name && type === "handshake") {
    self.connections[codeSpace] = self.connections[codeSpace] || [];
    self.connections[codeSpace].push(port);
    console.log(
      "onconnect",
      self.connections[codeSpace].length,
      Object.keys(self.connections)
    );
    if (!names[codeSpace]) {
      names[codeSpace] = name;
    }
    if (!mod[codeSpace] || mod[codeSpace].readyState !== mod[codeSpace].OPEN) {
      blockedMessages[codeSpace] = blockedMessages[codeSpace] || [];
      if (!mod[codeSpace] || mod[codeSpace].readyState !== mod[codeSpace].CONNECTING) {
        reconnect(codeSpace, name);
      }
    }
  }
  const obj = {
    name,
    target,
    type,
    patch,
    reversePatch,
    address,
    i,
    users,
    hashCode,
    newHash,
    oldHash,
    candidate,
    offer,
    answer
  };
  Object.keys(obj).forEach((key) => !obj[key] && delete obj[key]);
  if (mod[codeSpace].readyState === mod[codeSpace].OPEN) {
    mod[codeSpace].send(JSON.stringify(obj));
  } else {
    blockedMessages[codeSpace].push(JSON.stringify(obj));
  }
}
__name(onMessage, "onMessage");
var iii = 0;
self.onconnect = ({ ports }) => {
  ports[0].postMessage({ type: "onconnect", connections: ++iii });
  ports[0].onmessage = ({ data }) => onMessage(ports[0], data);
};
function reconnect(codeSpace, name) {
  if (mod[codeSpace])
    return mod[codeSpace];
  const websocket = new WebSocket(
    `wss://${location.host}/live/` + codeSpace + "/websocket"
  );
  mod[codeSpace] = websocket;
  websocket.addEventListener(
    "message",
    (ev) => {
      const patch = JSON.parse(ev.data);
      const mess = { codeSpace, ...patch };
      mess.name = names[codeSpace];
      const hash = patch.newHash || patch.hashCode;
      if (hash && hashStore[hash]) {
        mess.sess = hashStore[hash];
      }
      const str = JSON.stringify(mess);
      self.connections[codeSpace] = self.connections[codeSpace].map((conn) => {
        try {
          const ab = str2ab(str);
          conn.postMessage(ab, [ab]);
          return conn;
        } catch (err) {
          console.error("can't post message connection");
          return null;
        }
      }).filter((x) => x !== null);
    }
  );
  blockedMessages[codeSpace].push(JSON.stringify({ name }));
  websocket.onopen = () => {
    let i = 0;
    while (i <= blockedMessages[codeSpace].length) {
      websocket.send(blockedMessages[codeSpace][i++]);
    }
  };
  return mod[codeSpace];
}
__name(reconnect, "reconnect");

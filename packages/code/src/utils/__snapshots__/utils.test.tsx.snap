// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`getParts > e2e 1`] = `
[
  {
    "content": "I apologize for the oversight. It seems the colors are not visible due to the way they're being generated and applied. Let's fix this issue by making the colors more vibrant and ensuring they're properly displayed. Here are the changes I suggest:

1. Modify the color generation function to create more vibrant colors:",
    "type": "text",
  },
  {
    "content": "<<<<<<< SEARCH
  const generateNewColors = () => {
  const newColors = Array.from(
      { length: 8 },
      () => zzz
    );
    setPrideColors(newColors);
  };
=======
  const generateNewColors = () => {
    const newColors = [
      '#FF1B8D', // Pink
      '#FF3F00', // Red
      '#FF8E00', // Orange
      '#FFE500', // Yellow
      '#00ED00', // Green
      '#00B3FF', // Light Blue
      '#3D00FF', // Blue
      '#8F00FF', // Purple
    ].sort(() => Math.random() - 0.5);
    setPrideColors(newColors);
  };
>>>>>>> REPLACE",
    "language": "diff",
    "type": "code",
  },
  {
    "content": "This change creates a set of predefined vibrant colors and shuffles them randomly. This ensures that the colors are always visible and vibrant.

2. Adjust the drawPrideRings function to make the rings more prominent:",
    "type": "text",
  },
  {
    "content": "<<<<<<< SEARCH
    const drawPrideRings = (ctx: CanvasRenderingContext2D, radius: number) => {
      if (prideColors.length === 0) return; // Skip if colors haven't been generated yet
      const ringWidth = radius * 0.06;
      const startRadius = radius * 0.98;
      prideColors.forEach((color, index) => {
        const currentRadius = startRadius - index * (ringWidth / 1.2);
        ctx.beginPath();
        ctx.arc(0, 0, currentRadius, 0, 2 * Math.PI);
        ctx.strokeStyle = color;
        ctx.lineWidth = ringWidth;
        ctx.globalAlpha = 0.8;
        ctx.stroke();
        ctx.globalAlpha = 1;
        // Add texture to rings
        for (let i = 0; i < 50; i++) {
          const ang = Math.random() * Math.PI * 2;
          const x = Math.cos(ang) * currentRadius;
          const y = Math.sin(ang) * currentRadius;
          ctx.fillStyle = rgba(0, 0, 0, 33 * 0.2);
          ctx.fillRect(x, y, 2, 2);
        }
      });
    };
=======
    const drawPrideRings = (ctx: CanvasRenderingContext2D, radius: number) => {
      if (prideColors.length === 0) return; // Skip if colors haven't been generated yet
      const ringWidth = radius * 0.08;
      const startRadius = radius * 0.95;
      prideColors.forEach((color, index) => {
        const currentRadius = startRadius - index * (ringWidth / 1.1);
        ctx.beginPath();
        ctx.arc(0, 0, currentRadius, 0, 2 * Math.PI);
        ctx.strokeStyle = color;
        ctx.lineWidth = ringWidth;
        ctx.globalAlpha = 1;
        ctx.stroke();
      });
    };
>>>>>>> REPLACE",
    "language": "diff",
    "type": "code",
  },
  {
    "content": "This change increases the width of the rings, adjusts their positioning, and removes the texture effect that was making them less visible. It also sets the globalAlpha to 1 for full opacity.

3. Update the updateColorsAndClock function to redraw the entire clock when colors change:",
    "type": "text",
  },
  {
    "content": "<<<<<<< SEARCH
    const updateColorsAndClock = () => {
      generateNewColors();
      updateClock();
    };
=======
    const updateColorsAndClock = () => {
      generateNewColors();
      ctx.clearRect(-radius, -radius, canvas.width, canvas.height);
      drawClock();
    };
>>>>>>> REPLACE",
    "language": "diff",
    "type": "code",
  },
  {
    "content": "This change ensures that the entire clock, including the new colors, is redrawn when the colors are updated.

These modifications should make the pride colors clearly visible and change every second as intended. The clock will now display vibrant, shuffling colors that are easy to see against the dark background.

To further improve this feature, you could consider:

1. Adding a transition effect between color changes for a smoother appearance.
2. Allowing users to choose between different color palettes or themes.
3. Optimizing the redraw process to reduce potential flickering on slower devices.",
    "type": "text",
  },
  {
    "content": "",
    "isStreaming": true,
    "language": "plaintext",
    "type": "code",
  },
]
`;

exports[`getParts > should handle multiple search and replace markers 1`] = `
[
  {
    "content": "first change:",
    "type": "text",
  },
  {
    "content": "<<<<<<< SEARCH
      const a = 1;
      =======
      const a = 2;
      >>>>>>> REPLACE",
    "language": "diff",
    "type": "code",
  },
  {
    "content": "second change:",
    "type": "text",
  },
  {
    "content": "<<<<<<< SEARCH
      let b = 3;
      =======
      let b = 4;
      >>>>>>> REPLACE",
    "language": "diff",
    "type": "code",
  },
]
`;

exports[`getParts > should handle multiple search and replace markers2 1`] = `
[
  {
    "content": "first change:",
    "type": "text",
  },
  {
    "content": "<<<<<<< SEARCH
      const a = 1;
      =======
      const a = 2;
      >>>>>>> REPLACE",
    "language": "diff",
    "type": "code",
  },
  {
    "content": "second change:",
    "type": "text",
  },
  {
    "content": "<<<<<<< SEARCH
      let b = 3;
      =======
      let b =",
    "isStreaming": true,
    "language": "diff",
    "type": "code",
  },
]
`;

{
  "version": 3,
  "sources": ["../../../../node_modules/async-mutex/index.mjs", "../esbuildEsm.mjs"],
  "sourcesContent": ["const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_maxConcurrency, _cancelError = E_CANCELED) {\n        this._maxConcurrency = _maxConcurrency;\n        this._cancelError = _cancelError;\n        this._queue = [];\n        this._waiters = [];\n        if (_maxConcurrency <= 0) {\n            throw new Error('semaphore must be initialized to a positive value');\n        }\n        this._value = _maxConcurrency;\n    }\n    acquire() {\n        const locked = this.isLocked();\n        const ticketPromise = new Promise((resolve, reject) => this._queue.push({ resolve, reject }));\n        if (!locked)\n            this._dispatch();\n        return ticketPromise;\n    }\n    runExclusive(callback) {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            const [value, release] = yield this.acquire();\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock() {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            if (!this.isLocked()) {\n                return Promise.resolve();\n            }\n            const waitPromise = new Promise((resolve) => this._waiters.push({ resolve }));\n            return waitPromise;\n        });\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    release() {\n        if (this._maxConcurrency > 1) {\n            throw new Error('this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead');\n        }\n        if (this._currentReleaser) {\n            const releaser = this._currentReleaser;\n            this._currentReleaser = undefined;\n            releaser();\n        }\n    }\n    cancel() {\n        this._queue.forEach((ticket) => ticket.reject(this._cancelError));\n        this._queue = [];\n    }\n    _dispatch() {\n        const nextTicket = this._queue.shift();\n        if (!nextTicket)\n            return;\n        let released = false;\n        this._currentReleaser = () => {\n            if (released)\n                return;\n            released = true;\n            this._value++;\n            this._resolveWaiters();\n            this._dispatch();\n        };\n        nextTicket.resolve([this._value--, this._currentReleaser]);\n    }\n    _resolveWaiters() {\n        this._waiters.forEach((waiter) => waiter.resolve());\n        this._waiters = [];\n    }\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, void 0, void 0, function* () {\n            const [, releaser] = yield this._semaphore.acquire();\n            return releaser;\n        });\n    }\n    runExclusive(callback) {\n        return this._semaphore.runExclusive(() => callback());\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock() {\n        return this._semaphore.waitForUnlock();\n    }\n    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n    release() {\n        this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: () => new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            let isTimeout = false;\n            const handle = setTimeout(() => {\n                isTimeout = true;\n                reject(timeoutError);\n            }, timeout);\n            try {\n                const ticket = yield sync.acquire();\n                if (isTimeout) {\n                    const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                    release();\n                }\n                else {\n                    clearTimeout(handle);\n                    resolve(ticket);\n                }\n            }\n            catch (e) {\n                if (!isTimeout) {\n                    clearTimeout(handle);\n                    reject(e);\n                }\n            }\n        })),\n        runExclusive(callback) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire();\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n        release() {\n            sync.release();\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: () => sync.waitForUnlock(),\n        isLocked: () => sync.isLocked(),\n    };\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n", "import { Mutex } from \"async-mutex\";\nimport * as esbuild from \"https://unpkg.com/esbuild-wasm@0.14.9/esm/browser.min.js\";\n\nconst init = esbuild.initialize({\n  wasmURL: \"https://unpkg.com/esbuild-wasm@0.14.9/esbuild.wasm\",\n});\n\nlet initFinished = false;\nconst mutex = new Mutex();\n\nexport const transform = async (code) => {\n  var startTime = performance.now();\n\n  await mutex.waitForUnlock();\n\n  if (!initFinished) {\n    initFinished = true;\n  }\n\n  const result = await esbuild.transform(code, {\n    loader: \"tsx\",\n    // minify: true,\n    // treeShaking: true,\n    target: \"es2018\",\n  });\n\n  var endTime = performance.now();\n\n  console.log(`esbuildEsmTransform: took ${endTime - startTime} milliseconds`);\n  return result.code;\n};\n"],
  "mappings": "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",
  "names": []
}

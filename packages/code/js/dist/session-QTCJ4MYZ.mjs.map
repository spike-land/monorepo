{
  "version": 3,
  "sources": ["../session.tsx"],
  "sourcesContent": ["import { fromJS, isKeyed, Record } from \"immutable\";\n// @ts-expect-error\nimport createDelta from \"textdiff-create\";\n// @ts-expect-error\nimport applyPatch from \"textdiff-patch\";\n// import * as Immutable from \"immutable\"\n\ntype IUsername = string;\n\nexport interface ICodeSession {\n  code: string;\n  i: number;\n  errorDiff: string;\n  transpiled: string;\n  html: string;\n  css: string;\n}\n\nexport interface INewWSConnection {\n  uuid: string;\n  timestamp: number;\n  hashCode: number;\n  type: \"new-ws-connection\";\n}\n\ninterface ICodeInitEvent extends ICodeSession {\n  name: IUsername;\n  uuid: string;\n  type: \"code-init\";\n  hashOfCode: string;\n}\n\ninterface OtherEvent {\n  name: IUsername;\n  uuid: string;\n  target: IUsername | \"broadcast\";\n  type: \"start\" | \"open\" | \"quit\" | \"get-cid\" | \"provide-cid\" | \"new-ws\";\n  timestamp: number;\n}\n\nexport type IEvent =\n  | INewWSConnection\n  | OtherEvent\n  | ICodeInitEvent;\n\ninterface ICapabilities {\n  prettier: boolean;\n  babel: boolean;\n  sessionStorage?: boolean;\n  webRRT: boolean;\n  prerender: boolean;\n  IPFS: boolean;\n}\n\nexport interface IUserJSON {\n  name: IUsername;\n  capabilities: ICapabilities;\n  state: ICodeSession;\n  users: {};\n  events: IEvent[];\n}\n\ninterface IQTaskEvent {\n  uuid: string;\n  name: string;\n  operation: string;\n  data: string;\n}\n\nexport interface IUser extends\n  Record<{\n    name: IUsername;\n    room: string;\n    state: Record<ICodeSession>;\n    capabilities: ICapabilities;\n    users: {};\n    events: IEvent[];\n  }> {\n}\n\nfunction initSession(room: string, u: IUserJSON) {\n  return Record({ ...u, room, state: Record(u.state)() });\n}\n\nexport interface ICodeSess {\n  room: string;\n  hashCodeSession: number;\n  hashCode: () => number;\n  addEvent: (e: IEvent) => void;\n  setRoom: (room: string) => void;\n  json: () => IUserJSON;\n  processEvents: () => void;\n}\n\nexport class CodeSession implements ICodeSess {\n  session: IUser;\n  hashCodeSession: number;\n  public room: string = \"\";\n  created: string = new Date().toISOString();\n  constructor(room: string, user: IUserJSON) {\n    let savedState: ICodeSession | null = null;\n    this.room = room;\n    // if (user.state.code === \"\" && room) {\n    // const cacheKey = `state-${room}`;\n\n    // if (storageAvailable(\"localStorage\")) {\n    //   const savedStateStr = localStorage.getItem(cacheKey);\n    //   if (savedStateStr) {\n    //     savedState = JSON.parse(savedStateStr);\n    //   } else {\n    //     fetch(`https://code.spike.land/api/room/${room}/mySession`).then(\n    //       (resp) => resp.json(),\n    //     ).then((session: IUserJSON) => {\n    //       localStorage.setItem(cacheKey, JSON.stringify(session.state));\n    //       this.session.set(\"state\", Record(session.state)());\n    //     });\n    //   }\n    // }\n    // }\n\n    this.session = initSession(room, {\n      ...user,\n      state: savedState ? savedState : user.state,\n\n      capabilities: {\n        ...user.capabilities,\n        sessionStorage: storageAvailable(\"sessionStorage\"),\n      },\n    })();\n\n    this.hashCodeSession = this.session.get(\"state\").hashCode();\n  }\n\n  public addEvent(e: IEvent) {\n    this.session.get(\"events\").push({\n      ...e,\n    });\n    setTimeout(() => this.processEvents);\n  }\n\n  public hashCode() {\n    return this.session.get(\"state\").hashCode();\n  }\n\n  processEvents() {\n    const events = this.session.get(\"events\");\n    const event = events.shift();\n\n    if (event) {\n      switch (event.type) {\n        case \"code-init\":\n          const { code, transpiled, i, css, errorDiff, html } = event;\n          const sess: ICodeSession = {\n            code,\n            transpiled,\n            i,\n            css,\n            errorDiff,\n            html,\n          };\n\n          this.session.set(\"events\", events);\n          this.session.set(\"state\", Record(sess)());\n\n          // const cacheKey = `state-${this.room}`;\n\n          // if (storageAvailable(\"localStorage\")) {\n          //   localStorage.setItem(cacheKey, JSON.stringify(sess));\n          // }\n          // this.session.set(\"events\", events);\n      }\n    }\n  }\n  public updateState(state: ICodeSession) {\n    const oldState = JSON.stringify(this.session.get(\"state\").toJS());\n    const oldHash = this.session.get(\"state\").hashCode();\n\n    this.session = this.session.set(\"state\", Record<ICodeSession>(state)());\n    const newState = JSON.stringify(this.session.get(\"state\").toJS());\n    const newHash = this.session.get(\"state\").hashCode();\n    const patch = createPatch(oldState, newState);\n    return {\n      oldHash,\n      newHash,\n      patch,\n    };\n  }\n\n  public applyPatch({\n    oldHash,\n    newHash,\n    patch,\n  }: { oldHash: number; newHash: number; patch: string }) {\n    const oldHashCheck = this.session.get(\"state\").hashCode();\n\n    if (oldHashCheck !== oldHash) {\n      console.error(\"Cant update\");\n      return;\n    }\n\n    const oldState = JSON.stringify(this.session.get(\"state\").toJS());\n    const newState = JSON.parse(applyPatch(oldState, JSON.parse(patch)));\n\n    this.session = this.session.set(\"state\", Record<ICodeSession>(newState)());\n    const newHashCheck = this.session.get(\"state\").hashCode();\n\n    if (newHashCheck !== newHash) {\n      console.error(\"WRONG update\");\n      return;\n    }\n  }\n\n  public json() {\n    const user = this.session.toJSON();\n    const state = user.state.toJSON();\n    return { ...user, state };\n  }\n  public setRoom(room: string) {\n    const user = this.session.set(\"room\", room);\n    this.session = user;\n  }\n}\n\nlet session: CodeSession | null = null;\n\nexport default (room: string, u: IUserJSON): ICodeSess =>\n  session || new CodeSession(room, u);\n\nfunction storageAvailable(type: string) {\n  try {\n    if (window.hasOwnProperty(type) === false) return;\n    var storage = window[type as keyof Window];\n    var x = \"__storage_test__\";\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction createPatch(oldCode: string, newCode: string) {\n  return JSON.stringify(createDelta(oldCode, newCode));\n}\n"],
  "mappings": "AAAA,qFAEA,iFAEA,gFA4EA,WAAqB,EAAc,EAAc,CAC/C,MAAO,GAAO,IAAK,EAAG,KAAA,EAAM,MAAO,EAAO,EAAE,WAavC,GAAA,GAAA,KAAuC,CAC5C,QACA,gBACO,KAAe,GACtB,QAAkB,GAAI,QAAO,cAC7B,YAAY,EAAc,EAAiB,CACzC,GAAI,GAAkC,KACtC,KAAK,KAAO,EAmBZ,KAAK,QAAU,EAAY,EAAM,IAC5B,EACH,MAAO,GAA0B,EAAK,MAEtC,aAAc,IACT,EAAK,aACR,eAAgB,EAAiB,uBAIrC,KAAK,gBAAkB,KAAK,QAAQ,IAAI,SAAS,WAG5C,SAAS,EAAW,CACzB,KAAK,QAAQ,IAAI,UAAU,KAAK,IAC3B,IAEL,WAAW,IAAM,KAAK,eAGjB,UAAW,CAChB,MAAO,MAAK,QAAQ,IAAI,SAAS,WAGnC,eAAgB,CACd,GAAM,GAAS,KAAK,QAAQ,IAAI,UAC1B,EAAQ,EAAO,QAErB,GAAI,EACF,OAAQ,EAAM,UACP,YACH,GAAM,CAAE,KAAA,EAAM,WAAA,EAAY,EAAG,IAAA,EAAK,UAAA,EAAW,KAAA,GAAS,EAChD,EAAqB,CACzB,KAAA,EACA,WAAA,EACA,EACA,IAAA,EACA,UAAA,EACA,KAAA,GAGF,KAAK,QAAQ,IAAI,SAAU,GAC3B,KAAK,QAAQ,IAAI,QAAS,EAAO,OAWlC,YAAY,EAAqB,CACtC,GAAM,GAAW,KAAK,UAAU,KAAK,QAAQ,IAAI,SAAS,QACpD,EAAU,KAAK,QAAQ,IAAI,SAAS,WAE1C,KAAK,QAAU,KAAK,QAAQ,IAAI,QAAS,EAAqB,MAC9D,GAAM,GAAW,KAAK,UAAU,KAAK,QAAQ,IAAI,SAAS,QACpD,EAAU,KAAK,QAAQ,IAAI,SAAS,WACpC,EAAQ,EAAY,EAAU,GACpC,MAAO,CACL,QAAA,EACA,QAAA,EACA,MAAA,GAIG,WAAW,CAChB,QAAA,EACA,QAAA,EACA,MAAA,GACsD,CAGtD,GAFqB,KAAK,QAAQ,IAAI,SAAS,aAE1B,EAAS,CAC5B,QAAQ,MAAM,eACd,OAGF,GAAM,GAAW,KAAK,UAAU,KAAK,QAAQ,IAAI,SAAS,QACpD,EAAW,KAAK,MAAM,EAAW,EAAU,KAAK,MAAM,KAK5D,GAHA,KAAK,QAAU,KAAK,QAAQ,IAAI,QAAS,EAAqB,MACzC,KAAK,QAAQ,IAAI,SAAS,aAE1B,EAAS,CAC5B,QAAQ,MAAM,gBACd,QAIG,MAAO,CACZ,GAAM,GAAO,KAAK,QAAQ,SACpB,EAAQ,EAAK,MAAM,SACzB,MAAO,IAAK,EAAM,MAAA,GAEb,QAAQ,EAAc,CAC3B,GAAM,GAAO,KAAK,QAAQ,IAAI,OAAQ,GACtC,KAAK,QAAU,IAIf,EAA8B,KAE3B,EAAQ,CAAC,EAAc,IAC5B,GAAW,GAAI,GAAY,EAAM,GAEnC,WAA0B,EAAc,CACtC,GAAI,CACF,GAAI,OAAO,eAAe,KAAU,GAAO,OAC3C,GAAI,GAAU,OAAO,GACjB,EAAI,mBACR,MAAA,GAAQ,QAAQ,EAAG,GACnB,EAAQ,WAAW,GACZ,QAAA,CAEP,MAAO,IAIX,WAAqB,EAAiB,EAAiB,CACrD,MAAO,MAAK,UAAU,EAAY,EAAS",
  "names": []
}

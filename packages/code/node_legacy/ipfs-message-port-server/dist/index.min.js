!function (e, n) {
  "object" == typeof exports && "object" == typeof module
    ? module.exports = n()
    : "function" == typeof define && define.amd
    ? define([], n)
    : "object" == typeof exports
    ? exports.IpfsMessagePortServer = n()
    : e.IpfsMessagePortServer = n();
}(
  self,
  (function () {
    return function (e) {
      var n = {};
      function t(s) {
        if (n[s]) return n[s].exports;
        var i = n[s] = { i: s, l: !1, exports: {} };
        return e[s].call(i.exports, i, i.exports, t), i.l = !0, i.exports;
      }
      return t.m = e,
        t.c = n,
        t.d = function (e, n, s) {
          t.o(e, n) || Object.defineProperty(e, n, { enumerable: !0, get: s });
        },
        t.r = function (e) {
          "undefined" != typeof Symbol && Symbol.toStringTag &&
          Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
            Object.defineProperty(e, "__esModule", { value: !0 });
        },
        t.t = function (e, n) {
          if (1 & n && (e = t(e)), 8 & n)return e;
          if (4 & n && "object" == typeof e && e && e.__esModule) return e;
          var s = Object.create(null);
          if (
            t.r(s),
              Object.defineProperty(s, "default", { enumerable: !0, value: e }),
              2 & n && "string" != typeof e
          ) {
            for (var i in e) {
              t.d(
                s,
                i,
                function (n) {
                  return e[n];
                }.bind(null, i),
              );
            }
          }
          return s;
        },
        t.n = function (e) {
          var n = e && e.__esModule
            ? function () {
              return e.default;
            }
            : function () {
              return e;
            };
          return t.d(n, "a", n), n;
        },
        t.o = function (e, n) {
          return Object.prototype.hasOwnProperty.call(e, n);
        },
        t.p = "",
        t(t.s = 16);
    }([function (e, n, t) {
      "use strict";
      const s = t(9);
      n.encodeCID = (e, n) => (n && n.push(e.multihash.buffer), e);
      n.decodeCID = (e) => {
        const n = e;
        return Object.setPrototypeOf(n.multihash, Uint8Array.prototype),
          Object.setPrototypeOf(n, s.prototype),
          Object.defineProperty(n, Symbol.for("@ipld/js-cid/CID"), {
            value: !0,
          }),
          n;
      }, n.CID = s;
    }, function (e, n, t) {
      "use strict";
      n.TextEncoder = TextEncoder, n.TextDecoder = TextDecoder;
    }, function (e, n, t) {
      "use strict";
      const s = t(4), { encodeText: i, decodeText: r, concat: o } = t(5);
      function a(e) {
        if (s.names[e]) return s.names[e];
        if (s.codes[e]) return s.codes[e];
        throw new Error("Unsupported encoding: " + e);
      }
      (n = e.exports = function (e, n) {
        if (!n) throw new Error("requires an encoded Uint8Array");
        const { name: t, codeBuf: s } = a(e);
        return function (e, n) {
          a(e).decode(r(n));
        }(t, n),
          o([s, n], s.length + n.length);
      }).encode = function (e, n) {
        const t = a(e), s = i(t.encode(n));
        return o([t.codeBuf, s], t.codeBuf.length + s.length);
      },
        n.decode = function (e) {
          e instanceof Uint8Array && (e = r(e));
          const n = e[0];
          return [
            "f",
            "F",
            "v",
            "V",
            "t",
            "T",
            "b",
            "B",
            "c",
            "C",
            "h",
            "k",
            "K",
          ].includes(n) && (e = e.toLowerCase()),
            a(e[0]).decode(e.substring(1));
        },
        n.isEncoded = function (e) {
          if (
            e instanceof Uint8Array && (e = r(e)),
              "[object String]" !== Object.prototype.toString.call(e)
          ) {
            return !1;
          }
          try {
            return a(e[0]).name;
          } catch (n) {
            return !1;
          }
        },
        n.encoding = a,
        n.encodingFromData = function (e) {
          return e instanceof Uint8Array && (e = r(e)), a(e[0]);
        },
        n.names = Object.freeze(s.names),
        n.codes = Object.freeze(s.codes);
    }, function (e, n, t) {
      "use strict";
      const s = Object.freeze({
        identity: 0,
        cidv1: 1,
        cidv2: 2,
        cidv3: 3,
        ip4: 4,
        tcp: 6,
        sha1: 17,
        "sha2-256": 18,
        "sha2-512": 19,
        "sha3-512": 20,
        "sha3-384": 21,
        "sha3-256": 22,
        "sha3-224": 23,
        "shake-128": 24,
        "shake-256": 25,
        "keccak-224": 26,
        "keccak-256": 27,
        "keccak-384": 28,
        "keccak-512": 29,
        blake3: 30,
        dccp: 33,
        "murmur3-128": 34,
        "murmur3-32": 35,
        ip6: 41,
        ip6zone: 42,
        path: 47,
        multicodec: 48,
        multihash: 49,
        multiaddr: 50,
        multibase: 51,
        dns: 53,
        dns4: 54,
        dns6: 55,
        dnsaddr: 56,
        protobuf: 80,
        cbor: 81,
        raw: 85,
        "dbl-sha2-256": 86,
        rlp: 96,
        bencode: 99,
        "dag-pb": 112,
        "dag-cbor": 113,
        "libp2p-key": 114,
        "git-raw": 120,
        "torrent-info": 123,
        "torrent-file": 124,
        "leofcoin-block": 129,
        "leofcoin-tx": 130,
        "leofcoin-pr": 131,
        sctp: 132,
        "dag-jose": 133,
        "dag-cose": 134,
        "eth-block": 144,
        "eth-block-list": 145,
        "eth-tx-trie": 146,
        "eth-tx": 147,
        "eth-tx-receipt-trie": 148,
        "eth-tx-receipt": 149,
        "eth-state-trie": 150,
        "eth-account-snapshot": 151,
        "eth-storage-trie": 152,
        "bitcoin-block": 176,
        "bitcoin-tx": 177,
        "bitcoin-witness-commitment": 178,
        "zcash-block": 192,
        "zcash-tx": 193,
        docid: 206,
        "stellar-block": 208,
        "stellar-tx": 209,
        md4: 212,
        md5: 213,
        bmt: 214,
        "decred-block": 224,
        "decred-tx": 225,
        "ipld-ns": 226,
        "ipfs-ns": 227,
        "swarm-ns": 228,
        "ipns-ns": 229,
        zeronet: 230,
        "secp256k1-pub": 231,
        "bls12_381-g1-pub": 234,
        "bls12_381-g2-pub": 235,
        "x25519-pub": 236,
        "ed25519-pub": 237,
        "bls12_381-g1g2-pub": 238,
        "dash-block": 240,
        "dash-tx": 241,
        "swarm-manifest": 250,
        "swarm-feed": 251,
        udp: 273,
        "p2p-webrtc-star": 275,
        "p2p-webrtc-direct": 276,
        "p2p-stardust": 277,
        "p2p-circuit": 290,
        "dag-json": 297,
        udt: 301,
        utp: 302,
        unix: 400,
        p2p: 421,
        ipfs: 421,
        https: 443,
        onion: 444,
        onion3: 445,
        garlic64: 446,
        garlic32: 447,
        tls: 448,
        quic: 460,
        ws: 477,
        wss: 478,
        "p2p-websocket-star": 479,
        http: 480,
        json: 512,
        messagepack: 513,
        "libp2p-peer-record": 769,
        "sha2-256-trunc254-padded": 4114,
        "ripemd-128": 4178,
        "ripemd-160": 4179,
        "ripemd-256": 4180,
        "ripemd-320": 4181,
        x11: 4352,
        "p256-pub": 4608,
        "p384-pub": 4609,
        "p521-pub": 4610,
        "ed448-pub": 4611,
        "x448-pub": 4612,
        "ed25519-priv": 4864,
        kangarootwelve: 7425,
        "sm3-256": 21325,
        "blake2b-8": 45569,
        "blake2b-16": 45570,
        "blake2b-24": 45571,
        "blake2b-32": 45572,
        "blake2b-40": 45573,
        "blake2b-48": 45574,
        "blake2b-56": 45575,
        "blake2b-64": 45576,
        "blake2b-72": 45577,
        "blake2b-80": 45578,
        "blake2b-88": 45579,
        "blake2b-96": 45580,
        "blake2b-104": 45581,
        "blake2b-112": 45582,
        "blake2b-120": 45583,
        "blake2b-128": 45584,
        "blake2b-136": 45585,
        "blake2b-144": 45586,
        "blake2b-152": 45587,
        "blake2b-160": 45588,
        "blake2b-168": 45589,
        "blake2b-176": 45590,
        "blake2b-184": 45591,
        "blake2b-192": 45592,
        "blake2b-200": 45593,
        "blake2b-208": 45594,
        "blake2b-216": 45595,
        "blake2b-224": 45596,
        "blake2b-232": 45597,
        "blake2b-240": 45598,
        "blake2b-248": 45599,
        "blake2b-256": 45600,
        "blake2b-264": 45601,
        "blake2b-272": 45602,
        "blake2b-280": 45603,
        "blake2b-288": 45604,
        "blake2b-296": 45605,
        "blake2b-304": 45606,
        "blake2b-312": 45607,
        "blake2b-320": 45608,
        "blake2b-328": 45609,
        "blake2b-336": 45610,
        "blake2b-344": 45611,
        "blake2b-352": 45612,
        "blake2b-360": 45613,
        "blake2b-368": 45614,
        "blake2b-376": 45615,
        "blake2b-384": 45616,
        "blake2b-392": 45617,
        "blake2b-400": 45618,
        "blake2b-408": 45619,
        "blake2b-416": 45620,
        "blake2b-424": 45621,
        "blake2b-432": 45622,
        "blake2b-440": 45623,
        "blake2b-448": 45624,
        "blake2b-456": 45625,
        "blake2b-464": 45626,
        "blake2b-472": 45627,
        "blake2b-480": 45628,
        "blake2b-488": 45629,
        "blake2b-496": 45630,
        "blake2b-504": 45631,
        "blake2b-512": 45632,
        "blake2s-8": 45633,
        "blake2s-16": 45634,
        "blake2s-24": 45635,
        "blake2s-32": 45636,
        "blake2s-40": 45637,
        "blake2s-48": 45638,
        "blake2s-56": 45639,
        "blake2s-64": 45640,
        "blake2s-72": 45641,
        "blake2s-80": 45642,
        "blake2s-88": 45643,
        "blake2s-96": 45644,
        "blake2s-104": 45645,
        "blake2s-112": 45646,
        "blake2s-120": 45647,
        "blake2s-128": 45648,
        "blake2s-136": 45649,
        "blake2s-144": 45650,
        "blake2s-152": 45651,
        "blake2s-160": 45652,
        "blake2s-168": 45653,
        "blake2s-176": 45654,
        "blake2s-184": 45655,
        "blake2s-192": 45656,
        "blake2s-200": 45657,
        "blake2s-208": 45658,
        "blake2s-216": 45659,
        "blake2s-224": 45660,
        "blake2s-232": 45661,
        "blake2s-240": 45662,
        "blake2s-248": 45663,
        "blake2s-256": 45664,
        "skein256-8": 45825,
        "skein256-16": 45826,
        "skein256-24": 45827,
        "skein256-32": 45828,
        "skein256-40": 45829,
        "skein256-48": 45830,
        "skein256-56": 45831,
        "skein256-64": 45832,
        "skein256-72": 45833,
        "skein256-80": 45834,
        "skein256-88": 45835,
        "skein256-96": 45836,
        "skein256-104": 45837,
        "skein256-112": 45838,
        "skein256-120": 45839,
        "skein256-128": 45840,
        "skein256-136": 45841,
        "skein256-144": 45842,
        "skein256-152": 45843,
        "skein256-160": 45844,
        "skein256-168": 45845,
        "skein256-176": 45846,
        "skein256-184": 45847,
        "skein256-192": 45848,
        "skein256-200": 45849,
        "skein256-208": 45850,
        "skein256-216": 45851,
        "skein256-224": 45852,
        "skein256-232": 45853,
        "skein256-240": 45854,
        "skein256-248": 45855,
        "skein256-256": 45856,
        "skein512-8": 45857,
        "skein512-16": 45858,
        "skein512-24": 45859,
        "skein512-32": 45860,
        "skein512-40": 45861,
        "skein512-48": 45862,
        "skein512-56": 45863,
        "skein512-64": 45864,
        "skein512-72": 45865,
        "skein512-80": 45866,
        "skein512-88": 45867,
        "skein512-96": 45868,
        "skein512-104": 45869,
        "skein512-112": 45870,
        "skein512-120": 45871,
        "skein512-128": 45872,
        "skein512-136": 45873,
        "skein512-144": 45874,
        "skein512-152": 45875,
        "skein512-160": 45876,
        "skein512-168": 45877,
        "skein512-176": 45878,
        "skein512-184": 45879,
        "skein512-192": 45880,
        "skein512-200": 45881,
        "skein512-208": 45882,
        "skein512-216": 45883,
        "skein512-224": 45884,
        "skein512-232": 45885,
        "skein512-240": 45886,
        "skein512-248": 45887,
        "skein512-256": 45888,
        "skein512-264": 45889,
        "skein512-272": 45890,
        "skein512-280": 45891,
        "skein512-288": 45892,
        "skein512-296": 45893,
        "skein512-304": 45894,
        "skein512-312": 45895,
        "skein512-320": 45896,
        "skein512-328": 45897,
        "skein512-336": 45898,
        "skein512-344": 45899,
        "skein512-352": 45900,
        "skein512-360": 45901,
        "skein512-368": 45902,
        "skein512-376": 45903,
        "skein512-384": 45904,
        "skein512-392": 45905,
        "skein512-400": 45906,
        "skein512-408": 45907,
        "skein512-416": 45908,
        "skein512-424": 45909,
        "skein512-432": 45910,
        "skein512-440": 45911,
        "skein512-448": 45912,
        "skein512-456": 45913,
        "skein512-464": 45914,
        "skein512-472": 45915,
        "skein512-480": 45916,
        "skein512-488": 45917,
        "skein512-496": 45918,
        "skein512-504": 45919,
        "skein512-512": 45920,
        "skein1024-8": 45921,
        "skein1024-16": 45922,
        "skein1024-24": 45923,
        "skein1024-32": 45924,
        "skein1024-40": 45925,
        "skein1024-48": 45926,
        "skein1024-56": 45927,
        "skein1024-64": 45928,
        "skein1024-72": 45929,
        "skein1024-80": 45930,
        "skein1024-88": 45931,
        "skein1024-96": 45932,
        "skein1024-104": 45933,
        "skein1024-112": 45934,
        "skein1024-120": 45935,
        "skein1024-128": 45936,
        "skein1024-136": 45937,
        "skein1024-144": 45938,
        "skein1024-152": 45939,
        "skein1024-160": 45940,
        "skein1024-168": 45941,
        "skein1024-176": 45942,
        "skein1024-184": 45943,
        "skein1024-192": 45944,
        "skein1024-200": 45945,
        "skein1024-208": 45946,
        "skein1024-216": 45947,
        "skein1024-224": 45948,
        "skein1024-232": 45949,
        "skein1024-240": 45950,
        "skein1024-248": 45951,
        "skein1024-256": 45952,
        "skein1024-264": 45953,
        "skein1024-272": 45954,
        "skein1024-280": 45955,
        "skein1024-288": 45956,
        "skein1024-296": 45957,
        "skein1024-304": 45958,
        "skein1024-312": 45959,
        "skein1024-320": 45960,
        "skein1024-328": 45961,
        "skein1024-336": 45962,
        "skein1024-344": 45963,
        "skein1024-352": 45964,
        "skein1024-360": 45965,
        "skein1024-368": 45966,
        "skein1024-376": 45967,
        "skein1024-384": 45968,
        "skein1024-392": 45969,
        "skein1024-400": 45970,
        "skein1024-408": 45971,
        "skein1024-416": 45972,
        "skein1024-424": 45973,
        "skein1024-432": 45974,
        "skein1024-440": 45975,
        "skein1024-448": 45976,
        "skein1024-456": 45977,
        "skein1024-464": 45978,
        "skein1024-472": 45979,
        "skein1024-480": 45980,
        "skein1024-488": 45981,
        "skein1024-496": 45982,
        "skein1024-504": 45983,
        "skein1024-512": 45984,
        "skein1024-520": 45985,
        "skein1024-528": 45986,
        "skein1024-536": 45987,
        "skein1024-544": 45988,
        "skein1024-552": 45989,
        "skein1024-560": 45990,
        "skein1024-568": 45991,
        "skein1024-576": 45992,
        "skein1024-584": 45993,
        "skein1024-592": 45994,
        "skein1024-600": 45995,
        "skein1024-608": 45996,
        "skein1024-616": 45997,
        "skein1024-624": 45998,
        "skein1024-632": 45999,
        "skein1024-640": 46e3,
        "skein1024-648": 46001,
        "skein1024-656": 46002,
        "skein1024-664": 46003,
        "skein1024-672": 46004,
        "skein1024-680": 46005,
        "skein1024-688": 46006,
        "skein1024-696": 46007,
        "skein1024-704": 46008,
        "skein1024-712": 46009,
        "skein1024-720": 46010,
        "skein1024-728": 46011,
        "skein1024-736": 46012,
        "skein1024-744": 46013,
        "skein1024-752": 46014,
        "skein1024-760": 46015,
        "skein1024-768": 46016,
        "skein1024-776": 46017,
        "skein1024-784": 46018,
        "skein1024-792": 46019,
        "skein1024-800": 46020,
        "skein1024-808": 46021,
        "skein1024-816": 46022,
        "skein1024-824": 46023,
        "skein1024-832": 46024,
        "skein1024-840": 46025,
        "skein1024-848": 46026,
        "skein1024-856": 46027,
        "skein1024-864": 46028,
        "skein1024-872": 46029,
        "skein1024-880": 46030,
        "skein1024-888": 46031,
        "skein1024-896": 46032,
        "skein1024-904": 46033,
        "skein1024-912": 46034,
        "skein1024-920": 46035,
        "skein1024-928": 46036,
        "skein1024-936": 46037,
        "skein1024-944": 46038,
        "skein1024-952": 46039,
        "skein1024-960": 46040,
        "skein1024-968": 46041,
        "skein1024-976": 46042,
        "skein1024-984": 46043,
        "skein1024-992": 46044,
        "skein1024-1000": 46045,
        "skein1024-1008": 46046,
        "skein1024-1016": 46047,
        "skein1024-1024": 46048,
        "poseidon-bls12_381-a2-fc1": 46081,
        "poseidon-bls12_381-a2-fc1-sc": 46082,
        "zeroxcert-imprint-256": 52753,
        "fil-commitment-unsealed": 61697,
        "fil-commitment-sealed": 61698,
        "holochain-adr-v0": 8417572,
        "holochain-adr-v1": 8483108,
        "holochain-key-v0": 9728292,
        "holochain-key-v1": 9793828,
        "holochain-sig-v0": 10645796,
        "holochain-sig-v1": 10711332,
        "skynet-ns": 11639056,
      });
      e.exports = { baseTable: s };
    }, function (e, n, t) {
      "use strict";
      const s = t(18),
        i = t(19),
        { rfc4648: r } = t(20),
        { decodeText: o, encodeText: a } = t(5),
        c = [
          ["identity", "\0", () => ({ encode: o, decode: a }), ""],
          ["base2", "0", r(1), "01"],
          ["base8", "7", r(3), "01234567"],
          ["base10", "9", s, "0123456789"],
          ["base16", "f", r(4), "0123456789abcdef"],
          ["base16upper", "F", r(4), "0123456789ABCDEF"],
          ["base32hex", "v", r(5), "0123456789abcdefghijklmnopqrstuv"],
          ["base32hexupper", "V", r(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
          ["base32hexpad", "t", r(5), "0123456789abcdefghijklmnopqrstuv="],
          ["base32hexpadupper", "T", r(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
          ["base32", "b", r(5), "abcdefghijklmnopqrstuvwxyz234567"],
          ["base32upper", "B", r(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
          ["base32pad", "c", r(5), "abcdefghijklmnopqrstuvwxyz234567="],
          ["base32padupper", "C", r(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
          ["base32z", "h", r(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
          ["base36", "k", s, "0123456789abcdefghijklmnopqrstuvwxyz"],
          ["base36upper", "K", s, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
          [
            "base58btc",
            "z",
            s,
            "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
          ],
          [
            "base58flickr",
            "Z",
            s,
            "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
          ],
          [
            "base64",
            "m",
            r(6),
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          ],
          [
            "base64pad",
            "M",
            r(6),
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          ],
          [
            "base64url",
            "u",
            r(6),
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
          ],
          [
            "base64urlpad",
            "U",
            r(6),
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
          ],
        ],
        l = c.reduce(
          (e, n) => (e[n[0]] = new i(n[0], n[1], n[2], n[3]), e),
          {},
        ),
        k = c.reduce((e, n) => (e[n[1]] = l[n[0]], e), {});
      e.exports = { names: l, codes: k };
    }, function (e, n, t) {
      "use strict";
      const { TextEncoder: s, TextDecoder: i } = t(1), r = new i(), o = new s();
      e.exports = {
        decodeText: (e) => r.decode(e),
        encodeText: (e) => o.encode(e),
        concat: function (e, n) {
          const t = new Uint8Array(n);
          let s = 0;
          for (const i of e) t.set(i, s), s += i.length;
          return t;
        },
      };
    }, function (e, n, t) {
      "use strict";
      e.exports = { encode: t(21), decode: t(22), encodingLength: t(23) };
    }, function (e, n, t) {
      "use strict";
      n.encodeError = (e) => {
        const { name: n, message: t, stack: s, code: i, detail: r } = e;
        return { name: n, message: t, stack: s, code: i, detail: r };
      };
      n.decodeError = (e) => {
        if (e instanceof Error) return e;
        {
          const { name: n, message: t, stack: i, code: r } = e;
          return Object.assign(s(n, t), { name: n, stack: i, code: r });
        }
      };
      const s = (e, n) => {
        switch (e) {
          case "RangeError":
            return new RangeError(n);
          case "ReferenceError":
            return ReferenceError(n);
          case "SyntaxError":
            return new SyntaxError(n);
          case "TypeError":
            return new TypeError(n);
          case "URIError":
            return new URIError(n);
          default:
            return new Error(n);
        }
      };
    }, function (e, n, t) {
      "use strict";
      const { encodeCID: s, decodeCID: i } = t(0),
        { decodeNode: r, encodeNode: o } = t(40),
        a = t(12);
      n.DAGService = class {
        constructor(e) {
          this.ipfs = e;
        }
        async put(e) {
          const n = r(e.dagNode),
            t = await this.ipfs.dag.put(n, {
              ...e,
              cid: e.cid ? i(e.cid) : void 0,
            });
          return s(t);
        }
        async get(e) {
          const { cid: n, path: t, localResolve: s, timeout: r, signal: a } = e,
            { value: c, remainderPath: l } = await this.ipfs.dag.get(i(n), {
              path: t,
              localResolve: s,
              timeout: r,
              signal: a,
            }),
            k = [];
          return { remainderPath: l, value: o(c, k), transfer: k };
        }
        async resolve(e) {
          const { cid: n, remainderPath: t } = await this.ipfs.dag.resolve(
            c(e.cid),
            e,
          );
          return { cid: s(n), remainderPath: t };
        }
        async tree(e) {
          const { cid: n, path: t, recursive: s, timeout: r, signal: o } = e,
            c = await this.ipfs.dag.tree(i(n), {
              path: t,
              recursive: s,
              timeout: r,
              signal: o,
            });
          return await a(c);
        }
      };
      const c = (e) => "string" == typeof e ? e : i(e);
    }, function (e, n, t) {
      "use strict";
      const s = t(10),
        i = t(2),
        r = t(28),
        { baseTable: o } = t(3),
        a = t(36),
        c = t(37),
        l = t(38),
        k = t(39),
        d = Object.keys(o).reduce((e, n) => (e[o[n]] = n, e), {}),
        u = Symbol.for("@ipld/js-cid/CID");
      class b {
        constructor(e, n, t, o) {
          if (
            this.version,
              this.codec,
              this.multihash,
              Object.defineProperty(this, u, { value: !0 }),
              b.isCID(e)
          ) {
            const n = e;
            return this.version = n.version,
              this.codec = n.codec,
              this.multihash = n.multihash,
              void (this.multibaseName = n.multibaseName ||
                (0 === n.version ? "base58btc" : "base32"));
          }
          if ("string" == typeof e) {
            const n = i.isEncoded(e);
            if (n) {
              const t = i.decode(e);
              this.version = parseInt(t[0].toString(), 16),
                this.codec = r.getCodec(t.slice(1)),
                this.multihash = r.rmPrefix(t.slice(1)),
                this.multibaseName = n;
            } else {
              this.version = 0,
                this.codec = "dag-pb",
                this.multihash = s.fromB58String(e),
                this.multibaseName = "base58btc";
            }
            return b.validateCID(this),
              void Object.defineProperty(this, "string", { value: e });
          }
          if (e instanceof Uint8Array) {
            const n = parseInt(e[0].toString(), 16);
            if (1 === n) {
              const t = e;
              this.version = n,
                this.codec = r.getCodec(t.slice(1)),
                this.multihash = r.rmPrefix(t.slice(1)),
                this.multibaseName = "base32";
            } else {
              this.version = 0,
                this.codec = "dag-pb",
                this.multihash = e,
                this.multibaseName = "base58btc";
            }
            b.validateCID(this);
          } else {
            this.version = e,
              "number" == typeof n && (n = d[n]),
              this.codec = n,
              this.multihash = t,
              this.multibaseName = o || (0 === e ? "base58btc" : "base32"),
              b.validateCID(this);
          }
        }
        get bytes() {
          let e = this._bytes;
          if (!e) {
            if (0 === this.version) e = this.multihash;
            else {
              if (1 !== this.version) throw new Error("unsupported version");
              {
                const n = r.getCodeVarint(this.codec);
                e = c(
                  [[1], n, this.multihash],
                  1 + n.byteLength + this.multihash.byteLength,
                );
              }
            }
            Object.defineProperty(this, "_bytes", { value: e });
          }
          return e;
        }
        get prefix() {
          const e = r.getCodeVarint(this.codec), n = s.prefix(this.multihash);
          return c([[this.version], e, n], 1 + e.byteLength + n.byteLength);
        }
        get code() {
          return o[this.codec];
        }
        toV0() {
          if ("dag-pb" !== this.codec) {
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          }
          const { name: e, length: n } = s.decode(this.multihash);
          if ("sha2-256" !== e) {
            throw new Error(
              "Cannot convert non sha2-256 multihash CID to CIDv0",
            );
          }
          if (32 !== n) {
            throw new Error(
              "Cannot convert non 32 byte multihash CID to CIDv0",
            );
          }
          return new b(0, this.codec, this.multihash);
        }
        toV1() {
          return new b(1, this.codec, this.multihash);
        }
        toBaseEncodedString(e = this.multibaseName) {
          if (
            this.string && 0 !== this.string.length && e === this.multibaseName
          ) {
            return this.string;
          }
          let n;
          if (0 === this.version) {
            if ("base58btc" !== e) {
              throw new Error(
                "not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()",
              );
            }
            n = s.toB58String(this.multihash);
          } else {
            if (1 !== this.version) throw new Error("unsupported version");
            n = l(i.encode(e, this.bytes));
          }
          return e === this.multibaseName &&
            Object.defineProperty(this, "string", { value: n }),
            n;
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return "CID(" + this.toString() + ")";
        }
        toString(e) {
          return this.toBaseEncodedString(e);
        }
        toJSON() {
          return {
            codec: this.codec,
            version: this.version,
            hash: this.multihash,
          };
        }
        equals(e) {
          return this.codec === e.codec && this.version === e.version &&
            k(this.multihash, e.multihash);
        }
        static validateCID(e) {
          const n = a.checkCIDComponents(e);
          if (n) throw new Error(n);
        }
        static isCID(e) {
          return e instanceof b || Boolean(e && e[u]);
        }
      }
      b.codecs = o, e.exports = b;
    }, function (e, n, t) {
      "use strict";
      const s = t(2),
        i = t(6),
        { names: r } = t(24),
        o = t(25),
        a = t(26),
        c = t(27),
        l = {};
      for (const f in r) {
        const e = f;
        l[r[e]] = e;
      }
      function k(e) {
        if (!(e instanceof Uint8Array)) {
          throw new Error("multihash must be a Uint8Array");
        }
        if (e.length < 2) {
          throw new Error("multihash too short. must be > 2 bytes.");
        }
        const n = i.decode(e);
        if (!b(n)) {
          throw new Error(
            "multihash unknown function code: 0x" + n.toString(16),
          );
        }
        e = e.slice(i.decode.bytes);
        const t = i.decode(e);
        if (t < 0) throw new Error("multihash invalid length: " + t);
        if ((e = e.slice(i.decode.bytes)).length !== t) {
          throw new Error("multihash length inconsistent: 0x" + o(e, "base16"));
        }
        return { code: n, name: l[n], length: t, digest: e };
      }
      function d(e) {
        let n = e;
        if ("string" == typeof e) {
          if (void 0 === r[e]) {
            throw new Error("Unrecognized hash function named: " + e);
          }
          n = r[e];
        }
        if ("number" != typeof n) {
          throw new Error("Hash function code should be a number. Got: " + n);
        }
        if (void 0 === l[n] && !u(n)) {
          throw new Error("Unrecognized function code: " + n);
        }
        return n;
      }
      function u(e) {
        return e > 0 && e < 16;
      }
      function b(e) {
        return !!u(e) || !!l[e];
      }
      function h(e) {
        k(e);
      }
      e.exports = {
        names: r,
        codes: Object.freeze(l),
        toHexString: function (e) {
          if (!(e instanceof Uint8Array)) {
            throw new Error("must be passed a Uint8Array");
          }
          return o(e, "base16");
        },
        fromHexString: function (e) {
          return a(e, "base16");
        },
        toB58String: function (e) {
          if (!(e instanceof Uint8Array)) {
            throw new Error("must be passed a Uint8Array");
          }
          return o(s.encode("base58btc", e)).slice(1);
        },
        fromB58String: function (e) {
          const n = e instanceof Uint8Array ? o(e) : e;
          return s.decode("z" + n);
        },
        decode: k,
        encode: function (e, n, t) {
          if (!e || void 0 === n) {
            throw new Error(
              "multihash encode requires at least two args: digest, code",
            );
          }
          const s = d(n);
          if (!(e instanceof Uint8Array)) {
            throw new Error("digest should be a Uint8Array");
          }
          if (null == t && (t = e.length), t && e.length !== t) {
            throw new Error(
              "digest length should be equal to specified length.",
            );
          }
          const r = i.encode(s), o = i.encode(t);
          return c([r, o, e], r.length + o.length + e.length);
        },
        coerceCode: d,
        isAppCode: u,
        validate: h,
        prefix: function (e) {
          return h(e), e.subarray(0, 2);
        },
        isValidCode: b,
      };
    }, function (e, n, t) {
      "use strict";
      const s = t(6), i = t(31), r = t(32);
      function o(e) {
        return parseInt(i(e, "base16"), 16);
      }
      e.exports = {
        numberToUint8Array: function (e) {
          let n = e.toString(16);
          n.length % 2 == 1 && (n = "0" + n);
          return r(n, "base16");
        },
        uint8ArrayToNumber: o,
        varintUint8ArrayEncode: function (e) {
          return Uint8Array.from(s.encode(o(e)));
        },
        varintEncode: function (e) {
          return Uint8Array.from(s.encode(e));
        },
      };
    }, function (e, n, t) {
      "use strict";
      e.exports = async (e) => {
        const n = [];
        for await (const t of e) n.push(t);
        return n;
      };
    }, function (e, n, t) {
      "use strict";
      const { decodeIterable: s, encodeIterable: i, decodeCallback: r } = t(41),
        { decodeCID: o, encodeCID: a } = t(0);
      n.CoreService = class {
        constructor(e) {
          this.ipfs = e;
        }
        addAll(e) {
          const { input: n } = e,
            {
              chunker: t,
              cidVersion: s,
              enableShardingExperiment: i,
              hashAlg: o,
              onlyHash: a,
              pin: l,
              progress: k,
              rawLeaves: d,
              shardSplitThreshold: u,
              trickle: h,
              wrapWithDirectory: f,
              timeout: p,
              signal: m,
            } = e;
          let g;
          if (k) {
            const e = r(k);
            g = (n, t) => e([n, t]);
          }
          const y = {
              chunker: t,
              cidVersion: s,
              enableShardingExperiment: i,
              hashAlg: o,
              onlyHash: a,
              pin: l,
              rawLeaves: d,
              shardSplitThreshold: u,
              trickle: h,
              wrapWithDirectory: f,
              timeout: p,
              progress: g,
              signal: m,
            },
            w = c(n);
          return b(this.ipfs.addAll(w, y));
        }
        async add(e) {
          const { input: n } = e,
            {
              chunker: t,
              cidVersion: s,
              enableShardingExperiment: i,
              hashAlg: o,
              onlyHash: a,
              pin: c,
              progress: k,
              rawLeaves: d,
              shardSplitThreshold: u,
              trickle: b,
              wrapWithDirectory: f,
              timeout: p,
              signal: m,
            } = e;
          let g;
          if (k) {
            const e = r(k);
            g = (n, t) => e([n, t]);
          }
          const y = {
              chunker: t,
              cidVersion: s,
              enableShardingExperiment: i,
              hashAlg: o,
              onlyHash: a,
              pin: c,
              rawLeaves: d,
              shardSplitThreshold: u,
              trickle: b,
              wrapWithDirectory: f,
              timeout: p,
              progress: g,
              signal: m,
            },
            w = l(n);
          return h(await this.ipfs.add(w, y));
        }
        cat(e) {
          const { path: n, offset: t, length: s, timeout: i, signal: r } = e,
            a = "string" == typeof n ? n : o(n),
            c = this.ipfs.cat(a, {
              offset: t,
              length: s,
              timeout: i,
              signal: r,
            });
          return f(c);
        }
        ls(e) {
          const { path: n, recursive: t, preload: s, timeout: i, signal: r } =
              e,
            a = "string" == typeof n ? n : o(n),
            c = this.ipfs.ls(a, {
              recursive: t,
              preload: s,
              timeout: i,
              signal: r,
            });
          return p(c);
        }
      };
      const c = (e) => s(e, k),
        l = (e) =>
          u(
            e,
            (e) => "RemoteIterable" === e.type ? { content: s(e, k) } : k(e),
          ),
        k = (e) => u(e, (e) => ({ ...e, content: e.content && d(e.content) })),
        d = (e) => u(e, (e) => s(e, w)),
        u = (e, n) =>
          "string" == typeof e || e instanceof ArrayBuffer ||
            e instanceof Blob || ArrayBuffer.isView(e)
            ? e
            : n(e),
        b = (e) => {
          const n = [];
          return { data: i(e, y, n), transfer: n };
        },
        h = (e) => {
          const n = [];
          return { data: y(e, n), transfer: n };
        },
        f = (e) => {
          const n = [];
          return { data: i(e, g, n), transfer: n };
        },
        p = (e) => {
          const n = [];
          return { data: i(e, m, n), transfer: n };
        },
        m = (
          {
            depth: e,
            name: n,
            path: t,
            size: s,
            cid: i,
            type: r,
            mode: o,
            mtime: c,
          },
        ) => ({
          cid: a(i),
          type: r,
          name: n,
          path: t,
          mode: o,
          mtime: c,
          size: s,
          depth: e,
        }),
        g = (e, n) => (n.push(e.buffer), e),
        y = (e, n) => ({ ...e, cid: a(e.cid) }),
        w = (e) => e;
    }, function (e, n, t) {
      "use strict";
      const { encodeCID: s } = t(0);
      n.FilesService = class {
        constructor(e) {
          this.ipfs = e;
        }
        async stat(e) {
          const n = await this.ipfs.files.stat(e.path, e), t = [];
          return { stat: { ...n, cid: s(n.cid, t) }, transfer: t };
        }
      };
    }, function (e, n, t) {
      "use strict";
      const s = t(12),
        { encodeError: i } = t(7),
        { decodeCID: r, encodeCID: o } = t(0),
        { decodeBlock: a, encodeBlock: c } = t(42);
      n.BlockService = class {
        constructor(e) {
          this.ipfs = e;
        }
        async get(e) {
          const n = r(e.cid), t = await this.ipfs.block.get(n, e), s = [];
          return { transfer: s, block: c(t, s) };
        }
        async put(e) {
          const n = e.block,
            t = n instanceof Uint8Array ? n : a(n),
            s = await this.ipfs.block.put(t, {
              ...e,
              cid: e.cid ? r(e.cid) : e.cid,
            }),
            i = [];
          return { transfer: i, block: c(s, i) };
        }
        async rm(e) {
          const n = [];
          return (await s(this.ipfs.block.rm(e.cids.map(r), e))).map((e) =>
            l(e, n)
          );
        }
        async stat(e) {
          const n = r(e.cid), t = await this.ipfs.block.stat(n, e);
          return { ...t, cid: o(t.cid) };
        }
      };
      const l = (e, n) => {
        const t = o(e.cid, n);
        return e.error ? { cid: t, error: i(e.error) } : { cid: t };
      };
    }, function (e, n, t) {
      e.exports = t(17);
    }, function (e, n, t) {
      "use strict";
      const { DAGService: s } = t(8);
      n.DAGService = s;
      const { CoreService: i } = t(13);
      n.CoreService = i;
      const { FilesService: r } = t(14);
      n.FilesService = r;
      const { BlockService: o } = t(15);
      n.BlockService = o;
      const { IPFSService: a } = t(45);
      n.IPFSService = a;
      const { Server: c } = t(46);
      n.Server = c;
    }, function (e, n, t) {
      "use strict";
      e.exports = function (e) {
        if (e.length >= 255) throw new TypeError("Alphabet too long");
        for (var n = new Uint8Array(256), t = 0; t < n.length; t++) n[t] = 255;
        for (var s = 0; s < e.length; s++) {
          var i = e.charAt(s), r = i.charCodeAt(0);
          if (255 !== n[r]) throw new TypeError(i + " is ambiguous");
          n[r] = s;
        }
        var o = e.length,
          a = e.charAt(0),
          c = Math.log(o) / Math.log(256),
          l = Math.log(256) / Math.log(o);
        function k(e) {
          if ("string" != typeof e) throw new TypeError("Expected String");
          if (0 === e.length) return new Uint8Array();
          var t = 0;
          if (" " !== e[t]) {
            for (var s = 0, i = 0; e[t] === a;) s++, t++;
            for (
              var r = (e.length - t) * c + 1 >>> 0, l = new Uint8Array(r); e[t];
            ) {
              var k = n[e.charCodeAt(t)];
              if (255 === k) return;
              for (
                var d = 0, u = r - 1; (0 !== k || d < i) && -1 !== u; u--, d++
              ) {
                k += o * l[u] >>> 0, l[u] = k % 256 >>> 0, k = k / 256 >>> 0;
              }
              if (0 !== k) throw new Error("Non-zero carry");
              i = d, t++;
            }
            if (" " !== e[t]) {
              for (var b = r - i; b !== r && 0 === l[b];) b++;
              for (var h = new Uint8Array(s + (r - b)), f = s; b !== r;) {
                h[f++] = l[b++];
              }
              return h;
            }
          }
        }
        return {
          encode: function (n) {
            if (
              n instanceof Uint8Array || (ArrayBuffer.isView(n)
                ? n = new Uint8Array(n.buffer, n.byteOffset, n.byteLength)
                : Array.isArray(n) && (n = Uint8Array.from(n))),
                !(n instanceof Uint8Array)
            ) {
              throw new TypeError("Expected Uint8Array");
            }
            if (0 === n.length) return "";
            for (
              var t = 0, s = 0, i = 0, r = n.length; i !== r && 0 === n[i];
            ) {
              i++, t++;
            }
            for (
              var c = (r - i) * l + 1 >>> 0, k = new Uint8Array(c); i !== r;
            ) {
              for (
                var d = n[i], u = 0, b = c - 1;
                (0 !== d || u < s) && -1 !== b;
                b--, u++
              ) {
                d += 256 * k[b] >>> 0, k[b] = d % o >>> 0, d = d / o >>> 0;
              }
              if (0 !== d) throw new Error("Non-zero carry");
              s = u, i++;
            }
            for (var h = c - s; h !== c && 0 === k[h];) h++;
            for (var f = a.repeat(t); h < c; ++h) f += e.charAt(k[h]);
            return f;
          },
          decodeUnsafe: k,
          decode: function (e) {
            var n = k(e);
            if (n) return n;
            throw new Error("Non-base" + o + " character");
          },
        };
      };
    }, function (e, n, t) {
      "use strict";
      const { encodeText: s } = t(5);
      e.exports = class {
        constructor(e, n, t, i) {
          this.name = e,
            this.code = n,
            this.codeBuf = s(this.code),
            this.alphabet = i,
            this.codec = t(i);
        }
        encode(e) {
          return this.codec.encode(e);
        }
        decode(e) {
          for (const n of e) {
            if (this.alphabet && this.alphabet.indexOf(n) < 0) {
              throw new Error(`invalid character '${n}' in '${e}'`);
            }
          }
          return this.codec.decode(e);
        }
      };
    }, function (e, n, t) {
      "use strict";
      e.exports = {
        rfc4648: (e) =>
          (n) => ({
            encode: (t) =>
              ((e, n, t) => {
                const s = "=" === n[n.length - 1], i = (1 << t) - 1;
                let r = "", o = 0, a = 0;
                for (let c = 0; c < e.length; ++c) {
                  for (a = a << 8 | e[c], o += 8; o > t;) {
                    o -= t, r += n[i & a >> o];
                  }
                }
                if (o && (r += n[i & a << t - o]), s) {
                  for (; r.length * t & 7;) {
                    r += "=";
                  }
                }
                return r;
              })(t, n, e),
            decode: (t) =>
              ((e, n, t) => {
                const s = {};
                for (let l = 0; l < n.length; ++l) s[n[l]] = l;
                let i = e.length;
                for (; "=" === e[i - 1];) --i;
                const r = new Uint8Array(i * t / 8 | 0);
                let o = 0, a = 0, c = 0;
                for (let l = 0; l < i; ++l) {
                  const n = s[e[l]];
                  if (void 0 === n) {
                    throw new SyntaxError("Invalid character " + e[l]);
                  }
                  a = a << t | n,
                    o += t,
                    o >= 8 && (o -= 8, r[c++] = 255 & a >> o);
                }
                if (o >= t || 255 & a << 8 - o) {
                  throw new SyntaxError("Unexpected end of data");
                }
                return r;
              })(t, n, e),
          }),
      };
    }, function (e, n, t) {
      "use strict";
      e.exports = function e(n, t, i) {
        if (
          Number.MAX_SAFE_INTEGER && n > Number.MAX_SAFE_INTEGER
        ) {
          throw e.bytes = 0, new RangeError("Could not encode varint");
        }
        t = t || [];
        var r = i = i || 0;
        for (; n >= s;) t[i++] = 255 & n | 128, n /= 128;
        for (; -128 & n;) t[i++] = 255 & n | 128, n >>>= 7;
        return t[i] = 0 | n, e.bytes = i - r + 1, t;
      };
      var s = Math.pow(2, 31);
    }, function (e, n, t) {
      "use strict";
      e.exports = function e(n, t) {
        var s, i = 0, r = 0, o = t = t || 0, a = n.length;
        do {
          if (o >= a || r > 49) {
            throw e.bytes = 0, new RangeError("Could not decode varint");
          }
          s = n[o++],
            i += r < 28 ? (127 & s) << r : (127 & s) * Math.pow(2, r),
            r += 7;
        } while (s >= 128);
        return e.bytes = o - t, i;
      };
    }, function (e, n, t) {
      "use strict";
      var s = Math.pow(2, 7),
        i = Math.pow(2, 14),
        r = Math.pow(2, 21),
        o = Math.pow(2, 28),
        a = Math.pow(2, 35),
        c = Math.pow(2, 42),
        l = Math.pow(2, 49),
        k = Math.pow(2, 56),
        d = Math.pow(2, 63);
      e.exports = function (e) {
        return e < s
          ? 1
          : e < i
          ? 2
          : e < r
          ? 3
          : e < o
          ? 4
          : e < a
          ? 5
          : e < c
          ? 6
          : e < l
          ? 7
          : e < k
          ? 8
          : e < d
          ? 9
          : 10;
      };
    }, function (e, n, t) {
      "use strict";
      const s = Object.freeze({
        identity: 0,
        sha1: 17,
        "sha2-256": 18,
        "sha2-512": 19,
        "sha3-512": 20,
        "sha3-384": 21,
        "sha3-256": 22,
        "sha3-224": 23,
        "shake-128": 24,
        "shake-256": 25,
        "keccak-224": 26,
        "keccak-256": 27,
        "keccak-384": 28,
        "keccak-512": 29,
        blake3: 30,
        "murmur3-128": 34,
        "murmur3-32": 35,
        "dbl-sha2-256": 86,
        md4: 212,
        md5: 213,
        bmt: 214,
        "sha2-256-trunc254-padded": 4114,
        "ripemd-128": 4178,
        "ripemd-160": 4179,
        "ripemd-256": 4180,
        "ripemd-320": 4181,
        x11: 4352,
        kangarootwelve: 7425,
        "sm3-256": 21325,
        "blake2b-8": 45569,
        "blake2b-16": 45570,
        "blake2b-24": 45571,
        "blake2b-32": 45572,
        "blake2b-40": 45573,
        "blake2b-48": 45574,
        "blake2b-56": 45575,
        "blake2b-64": 45576,
        "blake2b-72": 45577,
        "blake2b-80": 45578,
        "blake2b-88": 45579,
        "blake2b-96": 45580,
        "blake2b-104": 45581,
        "blake2b-112": 45582,
        "blake2b-120": 45583,
        "blake2b-128": 45584,
        "blake2b-136": 45585,
        "blake2b-144": 45586,
        "blake2b-152": 45587,
        "blake2b-160": 45588,
        "blake2b-168": 45589,
        "blake2b-176": 45590,
        "blake2b-184": 45591,
        "blake2b-192": 45592,
        "blake2b-200": 45593,
        "blake2b-208": 45594,
        "blake2b-216": 45595,
        "blake2b-224": 45596,
        "blake2b-232": 45597,
        "blake2b-240": 45598,
        "blake2b-248": 45599,
        "blake2b-256": 45600,
        "blake2b-264": 45601,
        "blake2b-272": 45602,
        "blake2b-280": 45603,
        "blake2b-288": 45604,
        "blake2b-296": 45605,
        "blake2b-304": 45606,
        "blake2b-312": 45607,
        "blake2b-320": 45608,
        "blake2b-328": 45609,
        "blake2b-336": 45610,
        "blake2b-344": 45611,
        "blake2b-352": 45612,
        "blake2b-360": 45613,
        "blake2b-368": 45614,
        "blake2b-376": 45615,
        "blake2b-384": 45616,
        "blake2b-392": 45617,
        "blake2b-400": 45618,
        "blake2b-408": 45619,
        "blake2b-416": 45620,
        "blake2b-424": 45621,
        "blake2b-432": 45622,
        "blake2b-440": 45623,
        "blake2b-448": 45624,
        "blake2b-456": 45625,
        "blake2b-464": 45626,
        "blake2b-472": 45627,
        "blake2b-480": 45628,
        "blake2b-488": 45629,
        "blake2b-496": 45630,
        "blake2b-504": 45631,
        "blake2b-512": 45632,
        "blake2s-8": 45633,
        "blake2s-16": 45634,
        "blake2s-24": 45635,
        "blake2s-32": 45636,
        "blake2s-40": 45637,
        "blake2s-48": 45638,
        "blake2s-56": 45639,
        "blake2s-64": 45640,
        "blake2s-72": 45641,
        "blake2s-80": 45642,
        "blake2s-88": 45643,
        "blake2s-96": 45644,
        "blake2s-104": 45645,
        "blake2s-112": 45646,
        "blake2s-120": 45647,
        "blake2s-128": 45648,
        "blake2s-136": 45649,
        "blake2s-144": 45650,
        "blake2s-152": 45651,
        "blake2s-160": 45652,
        "blake2s-168": 45653,
        "blake2s-176": 45654,
        "blake2s-184": 45655,
        "blake2s-192": 45656,
        "blake2s-200": 45657,
        "blake2s-208": 45658,
        "blake2s-216": 45659,
        "blake2s-224": 45660,
        "blake2s-232": 45661,
        "blake2s-240": 45662,
        "blake2s-248": 45663,
        "blake2s-256": 45664,
        "skein256-8": 45825,
        "skein256-16": 45826,
        "skein256-24": 45827,
        "skein256-32": 45828,
        "skein256-40": 45829,
        "skein256-48": 45830,
        "skein256-56": 45831,
        "skein256-64": 45832,
        "skein256-72": 45833,
        "skein256-80": 45834,
        "skein256-88": 45835,
        "skein256-96": 45836,
        "skein256-104": 45837,
        "skein256-112": 45838,
        "skein256-120": 45839,
        "skein256-128": 45840,
        "skein256-136": 45841,
        "skein256-144": 45842,
        "skein256-152": 45843,
        "skein256-160": 45844,
        "skein256-168": 45845,
        "skein256-176": 45846,
        "skein256-184": 45847,
        "skein256-192": 45848,
        "skein256-200": 45849,
        "skein256-208": 45850,
        "skein256-216": 45851,
        "skein256-224": 45852,
        "skein256-232": 45853,
        "skein256-240": 45854,
        "skein256-248": 45855,
        "skein256-256": 45856,
        "skein512-8": 45857,
        "skein512-16": 45858,
        "skein512-24": 45859,
        "skein512-32": 45860,
        "skein512-40": 45861,
        "skein512-48": 45862,
        "skein512-56": 45863,
        "skein512-64": 45864,
        "skein512-72": 45865,
        "skein512-80": 45866,
        "skein512-88": 45867,
        "skein512-96": 45868,
        "skein512-104": 45869,
        "skein512-112": 45870,
        "skein512-120": 45871,
        "skein512-128": 45872,
        "skein512-136": 45873,
        "skein512-144": 45874,
        "skein512-152": 45875,
        "skein512-160": 45876,
        "skein512-168": 45877,
        "skein512-176": 45878,
        "skein512-184": 45879,
        "skein512-192": 45880,
        "skein512-200": 45881,
        "skein512-208": 45882,
        "skein512-216": 45883,
        "skein512-224": 45884,
        "skein512-232": 45885,
        "skein512-240": 45886,
        "skein512-248": 45887,
        "skein512-256": 45888,
        "skein512-264": 45889,
        "skein512-272": 45890,
        "skein512-280": 45891,
        "skein512-288": 45892,
        "skein512-296": 45893,
        "skein512-304": 45894,
        "skein512-312": 45895,
        "skein512-320": 45896,
        "skein512-328": 45897,
        "skein512-336": 45898,
        "skein512-344": 45899,
        "skein512-352": 45900,
        "skein512-360": 45901,
        "skein512-368": 45902,
        "skein512-376": 45903,
        "skein512-384": 45904,
        "skein512-392": 45905,
        "skein512-400": 45906,
        "skein512-408": 45907,
        "skein512-416": 45908,
        "skein512-424": 45909,
        "skein512-432": 45910,
        "skein512-440": 45911,
        "skein512-448": 45912,
        "skein512-456": 45913,
        "skein512-464": 45914,
        "skein512-472": 45915,
        "skein512-480": 45916,
        "skein512-488": 45917,
        "skein512-496": 45918,
        "skein512-504": 45919,
        "skein512-512": 45920,
        "skein1024-8": 45921,
        "skein1024-16": 45922,
        "skein1024-24": 45923,
        "skein1024-32": 45924,
        "skein1024-40": 45925,
        "skein1024-48": 45926,
        "skein1024-56": 45927,
        "skein1024-64": 45928,
        "skein1024-72": 45929,
        "skein1024-80": 45930,
        "skein1024-88": 45931,
        "skein1024-96": 45932,
        "skein1024-104": 45933,
        "skein1024-112": 45934,
        "skein1024-120": 45935,
        "skein1024-128": 45936,
        "skein1024-136": 45937,
        "skein1024-144": 45938,
        "skein1024-152": 45939,
        "skein1024-160": 45940,
        "skein1024-168": 45941,
        "skein1024-176": 45942,
        "skein1024-184": 45943,
        "skein1024-192": 45944,
        "skein1024-200": 45945,
        "skein1024-208": 45946,
        "skein1024-216": 45947,
        "skein1024-224": 45948,
        "skein1024-232": 45949,
        "skein1024-240": 45950,
        "skein1024-248": 45951,
        "skein1024-256": 45952,
        "skein1024-264": 45953,
        "skein1024-272": 45954,
        "skein1024-280": 45955,
        "skein1024-288": 45956,
        "skein1024-296": 45957,
        "skein1024-304": 45958,
        "skein1024-312": 45959,
        "skein1024-320": 45960,
        "skein1024-328": 45961,
        "skein1024-336": 45962,
        "skein1024-344": 45963,
        "skein1024-352": 45964,
        "skein1024-360": 45965,
        "skein1024-368": 45966,
        "skein1024-376": 45967,
        "skein1024-384": 45968,
        "skein1024-392": 45969,
        "skein1024-400": 45970,
        "skein1024-408": 45971,
        "skein1024-416": 45972,
        "skein1024-424": 45973,
        "skein1024-432": 45974,
        "skein1024-440": 45975,
        "skein1024-448": 45976,
        "skein1024-456": 45977,
        "skein1024-464": 45978,
        "skein1024-472": 45979,
        "skein1024-480": 45980,
        "skein1024-488": 45981,
        "skein1024-496": 45982,
        "skein1024-504": 45983,
        "skein1024-512": 45984,
        "skein1024-520": 45985,
        "skein1024-528": 45986,
        "skein1024-536": 45987,
        "skein1024-544": 45988,
        "skein1024-552": 45989,
        "skein1024-560": 45990,
        "skein1024-568": 45991,
        "skein1024-576": 45992,
        "skein1024-584": 45993,
        "skein1024-592": 45994,
        "skein1024-600": 45995,
        "skein1024-608": 45996,
        "skein1024-616": 45997,
        "skein1024-624": 45998,
        "skein1024-632": 45999,
        "skein1024-640": 46e3,
        "skein1024-648": 46001,
        "skein1024-656": 46002,
        "skein1024-664": 46003,
        "skein1024-672": 46004,
        "skein1024-680": 46005,
        "skein1024-688": 46006,
        "skein1024-696": 46007,
        "skein1024-704": 46008,
        "skein1024-712": 46009,
        "skein1024-720": 46010,
        "skein1024-728": 46011,
        "skein1024-736": 46012,
        "skein1024-744": 46013,
        "skein1024-752": 46014,
        "skein1024-760": 46015,
        "skein1024-768": 46016,
        "skein1024-776": 46017,
        "skein1024-784": 46018,
        "skein1024-792": 46019,
        "skein1024-800": 46020,
        "skein1024-808": 46021,
        "skein1024-816": 46022,
        "skein1024-824": 46023,
        "skein1024-832": 46024,
        "skein1024-840": 46025,
        "skein1024-848": 46026,
        "skein1024-856": 46027,
        "skein1024-864": 46028,
        "skein1024-872": 46029,
        "skein1024-880": 46030,
        "skein1024-888": 46031,
        "skein1024-896": 46032,
        "skein1024-904": 46033,
        "skein1024-912": 46034,
        "skein1024-920": 46035,
        "skein1024-928": 46036,
        "skein1024-936": 46037,
        "skein1024-944": 46038,
        "skein1024-952": 46039,
        "skein1024-960": 46040,
        "skein1024-968": 46041,
        "skein1024-976": 46042,
        "skein1024-984": 46043,
        "skein1024-992": 46044,
        "skein1024-1000": 46045,
        "skein1024-1008": 46046,
        "skein1024-1016": 46047,
        "skein1024-1024": 46048,
        "poseidon-bls12_381-a2-fc1": 46081,
        "poseidon-bls12_381-a2-fc1-sc": 46082,
      });
      e.exports = { names: s };
    }, function (e, n, t) {
      "use strict";
      const { encoding: s } = t(2),
        { TextDecoder: i } = t(1),
        r = new i("utf8");
      e.exports = function (e, n = "utf8") {
        return "utf8" === n || "utf-8" === n
          ? r.decode(e)
          : "ascii" === n
          ? function (e) {
            let n = "";
            for (let t = 0; t < e.length; t++) n += String.fromCharCode(e[t]);
            return n;
          }(e)
          : s(n).encode(e);
      };
    }, function (e, n, t) {
      "use strict";
      const { encoding: s } = t(2), { TextEncoder: i } = t(1), r = new i();
      e.exports = function (e, n = "utf8") {
        return "utf8" === n || "utf-8" === n ? r.encode(e) : "ascii" === n
          ? function (e) {
            const n = new Uint8Array(e.length);
            for (let t = 0; t < e.length; t++) n[t] = e.charCodeAt(t);
            return n;
          }(e)
          : s(n).decode(e);
      };
    }, function (e, n, t) {
      "use strict";
      e.exports = function (e, n) {
        n || (n = e.reduce((e, n) => e + n.length, 0));
        const t = new Uint8Array(n);
        let s = 0;
        for (const i of e) t.set(i, s), s += i.length;
        return t;
      };
    }, function (e, n, t) {
      "use strict";
      const s = t(6), i = t(29), r = t(30), o = t(11), a = t(33);
      const c = t(34), l = t(35);
      e.exports = {
        addPrefix: function (e, n) {
          let t;
          if (e instanceof Uint8Array) t = o.varintUint8ArrayEncode(e);
          else {
            if (!r[e]) throw new Error("multicodec not recognized");
            t = r[e];
          }
          return a([t, n], t.length + n.length);
        },
        rmPrefix: function (e) {
          return s.decode(e), e.slice(s.decode.bytes);
        },
        getCodec: function (e) {
          const n = s.decode(e), t = i.get(n);
          if (void 0 === t) throw new Error(`Code ${n} not found`);
          return t;
        },
        getName: function (e) {
          return i.get(e);
        },
        getNumber: function (e) {
          const n = r[e];
          if (void 0 === n)throw new Error("Codec `" + e + "` not found");
          return s.decode(n);
        },
        getCode: function (e) {
          return s.decode(e);
        },
        getCodeVarint: function (e) {
          const n = r[e];
          if (void 0 === n)throw new Error("Codec `" + e + "` not found");
          return n;
        },
        getVarint: function (e) {
          return s.encode(e);
        },
        print: l,
        ...c,
      };
    }, function (e, n, t) {
      "use strict";
      const { baseTable: s } = t(3), i = new Map();
      for (const r in s) {
        const e = s[r];
        i.set(e, r);
      }
      e.exports = Object.freeze(i);
    }, function (e, n, t) {
      "use strict";
      const { baseTable: s } = t(3), i = t(11).varintEncode, r = {};
      for (const o in s) {
        const e = s[o];
        r[o] = i(e);
      }
      e.exports = Object.freeze(r);
    }, function (e, n, t) {
      "use strict";
      const { names: s } = t(4), { TextDecoder: i } = t(1), r = new i("utf8");
      e.exports = function (e, n = "utf8") {
        if ("utf8" === n || "utf-8" === n) return r.decode(e);
        if ("ascii" === n) {
          return function (e) {
            let n = "";
            for (let t = 0; t < e.length; t++) n += String.fromCharCode(e[t]);
            return n;
          }(e);
        }
        const t = s[n];
        if (!t) throw new Error("Unknown base");
        return t.encode(e);
      };
    }, function (e, n, t) {
      "use strict";
      const { names: s } = t(4), { TextEncoder: i } = t(1), r = new i();
      e.exports = function (e, n = "utf8") {
        if ("utf8" === n || "utf-8" === n) return r.encode(e);
        if ("ascii" === n) {
          return function (e) {
            const n = new Uint8Array(e.length);
            for (let t = 0; t < e.length; t++) n[t] = e.charCodeAt(t);
            return n;
          }(e);
        }
        const t = s[n];
        if (!t) throw new Error("Unknown base");
        return t.decode(e);
      };
    }, function (e, n, t) {
      "use strict";
      e.exports = function (e, n) {
        n || (n = e.reduce((e, n) => e + n.length, 0));
        const t = new Uint8Array(n);
        let s = 0;
        for (const i of e) t.set(i, s), s += i.length;
        return t;
      };
    }, function (e, n, t) {
      "use strict";
      const { baseTable: s } = t(3), i = {};
      for (
        const [r, o] of Object.entries(s)
      ) {
        i[r.toUpperCase().replace(/-/g, "_")] = o;
      }
      e.exports = Object.freeze(i);
    }, function (e, n, t) {
      "use strict";
      const { baseTable: s } = t(3), i = {};
      for (const [r, o] of Object.entries(s)) void 0 === i[o] && (i[o] = r);
      e.exports = Object.freeze(i);
    }, function (e, n, t) {
      "use strict";
      const s = t(10),
        i = {
          checkCIDComponents: function (e) {
            if (null == e) return "null values are not valid CIDs";
            if (0 !== e.version && 1 !== e.version) {
              return "Invalid version, must be a number equal to 1 or 0";
            }
            if ("string" != typeof e.codec) { 
              return "codec must be string";
            }
            if (0 === e.version) {
              if ("dag-pb" !== e.codec) {
                return "codec must be 'dag-pb' for CIDv0";
              }
              if (
                "base58btc" !== e.multibaseName
              ) { 
                return "multibaseName must be 'base58btc' for CIDv0";
              }
            }
            if (
              !(e.multihash instanceof Uint8Array)
            ) {
              return "multihash must be a Uint8Array";
            }
            try {
              s.validate(e.multihash);
            } catch (n) {
              let e = n.message;
              return e || (e = "Multihash validation failed"), e;
            }
          },
        };
      e.exports = i;
    }, function (e, n, t) {
      "use strict";
      e.exports = function (e, n) {
        n || (n = e.reduce((e, n) => e + n.length, 0));
        const t = new Uint8Array(n);
        let s = 0;
        for (const i of e) t.set(i, s), s += i.length;
        return t;
      };
    }, function (e, n, t) {
      "use strict";
      const { encoding: s } = t(2),
        { TextDecoder: i } = t(1),
        r = new i("utf8");
      e.exports = function (e, n = "utf8") {
        return "utf8" === n || "utf-8" === n ? r.decode(e) : "ascii" === n
          ? function (e) {
            let n = "";
            for (let t = 0; t < e.length; t++) n += String.fromCharCode(e[t]);
            return n;
          }(e)
          : s(n).encode(e);
      };
    }, function (e, n, t) {
      "use strict";
      e.exports = function (e, n) {
        if (e === n) return !0;
        if (e.byteLength !== n.byteLength) return !1;
        for (let t = 0; t < e.byteLength; t++) if (e[t] !== n[t]) return !1;
        return !0;
      };
    }, function (e, n, t) {
      "use strict";
      const { encodeCID: s, decodeCID: i, CID: r } = t(0);
      n.decodeNode = ({ dagNode: e, cids: n }) => {
        for (const t of n) i(t);
        return e;
      };
      n.encodeNode = (e, n) => {
        const t = [];
        return o(e, t, n), { dagNode: e, cids: t };
      };
      const o = (e, n, t) => {
        if (null != e && "object" == typeof e) {if (r.isCID(e)) {
            n.push(e), s(e, t);
          } else if (e instanceof ArrayBuffer) t && t.push(e);
          else if (ArrayBuffer.isView(e)) t && t.push(e.buffer);
          else if (Array.isArray(e)) for (const s of e) o(s, n, t);
          else for (const s of Object.values(e)) o(s, n, t);}
      };
    }, function (e, n, t) {
      "use strict";
      const { encodeError: s, decodeError: i } = t(7);
      n.decodeIterable = async function* ({ port: e }, n) {
        let t = (e) => {};
        const s =
          () => (e.postMessage({ method: "next" }), new Promise((e) => t = e));
        e.onmessage = (e) => t(e.data);
        let r = !1;
        try {
          for (; !r;) {
            const { done: e, value: t, error: o } = await s();
            if (r = e, null != o) throw i(o);
            null != t && (yield n(t));
          }
        } finally {
          r || e.postMessage({ method: "return" }), e.close();
        }
      };
      n.encodeIterable = (e, n, t) => {
        const { port1: i, port2: o } = new MessageChannel(), a = [], c = r(e);
        return i.onmessage = async ({ data: { method: e } }) => {
          switch (e) {
            case "next":
              try {
                const { done: e, value: t } = await c.next();
                e
                  ? (i.postMessage({ type: "next", done: !0 }), i.close())
                  : (a.length = 0,
                    i.postMessage(
                      { type: "next", done: !1, value: n(t, a) },
                      a,
                    ));
              } catch (t) {
                i.postMessage({ type: "throw", error: s(t) }), i.close();
              }
              break;
            case "return":
              i.close(), c.return && c.return();
          }
        },
          i.start(),
          t.push(o),
          { type: "RemoteIterable", port: o };
      };
      const r = (e) => {
        if (null != e) {
          if (
            "function" == typeof e[Symbol.asyncIterator]
          ) {
            return e[Symbol.asyncIterator]();
          }
          if (
            "function" == typeof e[Symbol.iterator]
          ) {
            return e[Symbol.iterator]();
          }
        }
        throw TypeError("Value must be async or sync iterable");
      };
      n.encodeCallback = (e, n) => {
        const { port1: t, port2: s } = new MessageChannel();
        return t.onmessage = ({ data: n }) => e.apply(null, n),
          n.push(s),
          { type: "RemoteCallback", port: s };
      };
      n.decodeCallback = ({ port: e }) => (n, t = []) => {
        e.postMessage(n, [...new Set(t)]);
      };
    }, function (e, n, t) {
      "use strict";
      const { encodeCID: s, decodeCID: i } = t(0), r = t(43);
      n.encodeBlock = (
        { cid: e, data: n },
        t,
      ) => (t && t.push(n.buffer), { cid: s(e, t), data: n });
      n.decodeBlock = ({ cid: e, data: n }) => new r(n, i(e)), n.Block = r;
    }, function (e, n, t) {
      "use strict";
      const s = t(9),
        { version: i } = t(44),
        r = Symbol.for("@ipld/js-ipld-block/block"),
        o = { writable: !1, configurable: !1, enumerable: !0 };
      class a {
        constructor(e, n) {
          if (!(e && e instanceof Uint8Array)) {
            throw new Error("first argument  must be a Uint8Array");
          }
          if (!n || !s.isCID(n)) {
            throw new Error("second argument must be a CID");
          }
          this.data = e,
            this.cid = n,
            Object.defineProperties(this, { data: o, cid: o });
        }
        get _data() {
          return k(), this.data;
        }
        get _cid() {
          return l(), this.cid;
        }
        get [Symbol.toStringTag]() {
          return "Block";
        }
        get [r]() {
          return !0;
        }
        static isBlock(e) {
          return Boolean(e && e[r]);
        }
      }
      const c = (e, n) => {
          let t = !1;
          return () => {
            if (!e.test(i)) throw new Error(n);
            t || (t = !0, console.warn(n));
          };
        },
        l = c(
          /^0\.10|^0\.11/,
          "block._cid is deprecated and will be removed in 0.12 release. Please use block.cid instead",
        ),
        k = c(
          /^0\.10|^0.11/,
          "block._data is deprecated and will be removed in 0.12 release. Please use block.data instead",
        );
      e.exports = a;
    }, function (e) {
      e.exports = JSON.parse(
        '{"_from":"ipld-block@^0.11.0","_id":"ipld-block@0.11.0","_inBundle":false,"_integrity":"sha512-Kk56OOPmlWAjXfBJXvx2jX5RA6R9qUrcc2JXwF7Y4IL9mlmxcxTNkgcsJYR78DbyMllQbi7yreghjGjtCTYKaw==","_location":"/ipld-block","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"ipld-block@^0.11.0","name":"ipld-block","escapedName":"ipld-block","rawSpec":"^0.11.0","saveSpec":null,"fetchSpec":"^0.11.0"},"_requiredBy":["/","/ipfs-bitswap","/ipfs-core","/ipfs-repo","/ipld"],"_resolved":"https://registry.npmjs.org/ipld-block/-/ipld-block-0.11.0.tgz","_shasum":"71b24b70f4d867b0609a738efa4872ef4df84c7a","_spec":"ipld-block@^0.11.0","_where":"/Users/alex/Documents/Workspaces/ipfs/js-ipfs","bugs":{"url":"https://github.com/ipld/js-ipld-block/issues"},"bundleDependencies":false,"contributors":[{"name":"David Dias","email":"daviddias.p@gmail.com"},{"name":"Volker Mische","email":"volker.mische@gmail.com"},{"name":"Friedel Ziegelmayer","email":"dignifiedquire@gmail.com"},{"name":"Irakli Gozalishvili","email":"contact@gozala.io"},{"name":"achingbrain","email":"alex@achingbrain.net"},{"name":"ᴠɪᴄᴛᴏʀ ʙᴊᴇʟᴋʜᴏʟᴍ","email":"victorbjelkholm@gmail.com"},{"name":"Alan Shaw","email":"alan.shaw@protocol.ai"},{"name":"Charlie","email":"the_charlie_daly@hotmail.co.uk"},{"name":"Diogo Silva","email":"fsdiogo@gmail.com"},{"name":"Hugo Dias","email":"hugomrdias@gmail.com"},{"name":"Mikeal Rogers","email":"mikeal.rogers@gmail.com"},{"name":"Richard Littauer","email":"richard.littauer@gmail.com"},{"name":"Richard Schneider","email":"makaretu@gmail.com"},{"name":"Xmader","email":"xmader@outlook.com"}],"dependencies":{"cids":"^1.0.0"},"deprecated":false,"description":"JavaScript Implementation of IPLD Block","devDependencies":{"aegir":"^27.0.0","typescript":"^4.0.3","uint8arrays":"^1.0.0"},"engines":{"node":">=6.0.0","npm":">=3.0.0"},"homepage":"https://github.com/ipld/js-ipld-block#readme","keywords":["IPLD"],"leadMaintainer":"Volker Mische <volker.mische@gmail.com>","license":"MIT","main":"src/index.js","name":"ipld-block","pre-push":["lint","test"],"repository":{"type":"git","url":"git+https://github.com/ipld/js-ipld-block.git"},"scripts":{"build":"npm run build:js && npm run build:types","build:js":"aegir build","build:types":"tsc --emitDeclarationOnly --declarationDir dist","check":"tsc --noEmit --noErrorTruncation","coverage":"aegir coverage","coverage-publish":"aegir coverage --provider coveralls","docs":"aegir docs","lint":"aegir lint","prepare":"npm run build:types","release":"aegir release --docs","release-major":"aegir release --type major --docs","release-minor":"aegir release --type minor --docs","test":"aegir test","test:browser":"aegir test --target browser","test:node":"aegir test --target node"},"typesVersions":{"*":{"*":["dist/*"]}},"version":"0.11.0"}',
      );
    }, function (e, n, t) {
      "use strict";
      const { DAGService: s } = t(8),
        { CoreService: i } = t(13),
        { FilesService: r } = t(14),
        { BlockService: o } = t(15);
      n.IPFSService = class {
        constructor(e) {
          this.dag = new s(e),
            this.core = new i(e),
            this.files = new r(e),
            this.block = new o(e);
        }
      };
    }, function (e, n, t) {
      "use strict";
      const { encodeError: s } = t(7),
        i = class {
          constructor(e, n, t) {
            this.result = new Promise((s, i) => {
              this.succeed = s,
                this.fail = i,
                this.namespace = e,
                this.method = n,
                this.input = t,
                this.abortController = new AbortController(),
                this.signal = this.abortController.signal;
            });
          }
          abort() {
            this.abortController.abort(), this.fail(new o());
          }
        };
      n.Query = i,
        n.Server = class {
          constructor(e) {
            this.services = e, this.queries = Object.create(null);
          }
          connect(e) {
            e.addEventListener("message", this), e.start();
          }
          disconnect(e) {
            e.removeEventListener("message", this), e.close();
          }
          handleEvent(e) {
            const n = e.data;
            switch (n.type) {
              case "query":
                return void this.handleQuery(
                  n.id,
                  new i(n.namespace, n.method, n.input),
                  e.target,
                );
              case "abort":
                return this.abort(n.id);
              default:
                throw new r(e);
            }
          }
          abort(e) {
            const n = this.queries[e];
            n && (delete this.queries[e], n.abort());
          }
          async handleQuery(e, n, t) {
            if (
              this.queries[e] = n,
                await this.run(n),
                delete this.queries[e],
                !n.signal.aborted
            ) {
              try {
                const s = await n.result, i = [...new Set(s.transfer || [])];
                delete s.transfer,
                  t.postMessage({
                    type: "result",
                    id: e,
                    result: { ok: !0, value: s },
                  }, i);
              } catch (i) {
                t.postMessage({
                  type: "result",
                  id: e,
                  result: { ok: !1, error: s(i) },
                });
              }
            }
          }
          run(e) {
            const { services: n } = this,
              { namespace: t, method: s } = e,
              i = n[t];
            if (i) {
              if ("function" == typeof i[s]) {
                try {
                  const n = i[s]({ ...e.input, signal: e.signal });
                  Promise.resolve(n).then(e.succeed, e.fail);
                } catch (r) {
                  e.fail(r);
                }
              } else e.fail(new RangeError(`Method '${s}' is not found`));
            } else e.fail(new RangeError(`Namespace '${t}' is not found`));
          }
          execute(e) {
            const n = new i(e.namespace, e.method, e.input);
            return this.run(n), n.result;
          }
        };
      const r = class extends RangeError {
        constructor(e) {
          super("Unexpected message was received by the server"),
            this.event = e;
        }
        get name() {
          return this.constructor.name;
        }
      };
      n.UnsupportedMessageError = r;
      const o = class extends Error {
        get name() {
          return this.constructor.name;
        }
      };
      n.AbortError = o;
    }]);
  }),
);
